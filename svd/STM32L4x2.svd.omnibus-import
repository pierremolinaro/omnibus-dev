//------------------------------------------------------------------------------
// STM32L4x2: STM32L4x2
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Peripheral ADC1: Analog-to-Digital Converter
//------------------------------------------------------------------------------

registers ©ADC1 @at 0x50040000 {
//---  Register ISR: interrupt and status register
  ISR @offset 0x0 $u32 {
    21
    JQOVF // at 10: JQOVF
    AWD3 // at 9: AWD3
    AWD2 // at 8: AWD2
    AWD1 // at 7: AWD1
    JEOS // at 6: JEOS
    JEOC // at 5: JEOC
    OVR // at 4: OVR
    EOS // at 3: EOS
    EOC // at 2: EOC
    EOSMP // at 1: EOSMP
    ADRDY // at 0: ADRDY
  }

//---  Register IER: interrupt enable register
  IER @offset 0x4 $u32 {
    21
    JQOVFIE // at 10: JQOVFIE
    AWD3IE // at 9: AWD3IE
    AWD2IE // at 8: AWD2IE
    AWD1IE // at 7: AWD1IE
    JEOSIE // at 6: JEOSIE
    JEOCIE // at 5: JEOCIE
    OVRIE // at 4: OVRIE
    EOSIE // at 3: EOSIE
    EOCIE // at 2: EOCIE
    EOSMPIE // at 1: EOSMPIE
    ADRDYIE // at 0: ADRDYIE
  }

//---  Register CR: control register
  CR @offset 0x8 $u32 {
    ADCAL // at 31: ADCAL
    ADCALDIF // at 30: ADCALDIF
    DEEPPWD // at 29: DEEPPWD
    ADVREGEN // at 28: ADVREGEN
    22
    JADSTP // at 5: JADSTP
    ADSTP // at 4: ADSTP
    JADSTART // at 3: JADSTART
    ADSTART // at 2: ADSTART
    ADDIS // at 1: ADDIS
    ADEN // at 0: ADEN
  }

//---  Register CFGR: configuration register
  CFGR @offset 0xc $u32 {
    JQDIS // at 31: JQDIS
    AWDCH1CH:5 // at 26: AWDCH1CH
    JAUTO // at 25: JAUTO
    JAWD1EN // at 24: JAWD1EN
    AWD1EN // at 23: AWD1EN
    AWD1SGL // at 22: AWD1SGL
    JQM // at 21: JQM
    JDISCEN // at 20: JDISCEN
    DISCNUM:3 // at 17: DISCNUM
    DISCEN // at 16: DISCEN
    1
    AUTDLY // at 14: AUTDLY
    CONT // at 13: CONT
    OVRMOD // at 12: OVRMOD
    EXTEN:2 // at 10: EXTEN
    EXTSEL:4 // at 6: EXTSEL
    ALIGN // at 5: ALIGN
    RES:2 // at 3: RES
    1
    DMACFG // at 1: DMACFG
    DMAEN // at 0: DMAEN
  }

//---  Register CFGR2: configuration register
  CFGR2 @offset 0x10 $u32 {
    21
    ROVSM // at 10: EXTEN
    TOVS // at 9: EXTSEL
    OVSS:4 // at 5: ALIGN
    OVSR:3 // at 2: RES
    JOVSE // at 1: DMACFG
    ROVSE // at 0: DMAEN
  }

//---  Register SMPR1: sample time register 1
  SMPR1 @offset 0x14 $u32 {
    2
    SMP9:3 // at 27: SMP9
    SMP8:3 // at 24: SMP8
    SMP7:3 // at 21: SMP7
    SMP6:3 // at 18: SMP6
    SMP5:3 // at 15: SMP5
    SMP4:3 // at 12: SMP4
    SMP3:3 // at 9: SMP3
    SMP2:3 // at 6: SMP2
    SMP1:3 // at 3: SMP1
    SMP0:3 // at 0: SMP0
  }

//---  Register SMPR2: sample time register 2
  SMPR2 @offset 0x18 $u32 {
    5
    SMP18:3 // at 24: SMP18
    SMP17:3 // at 21: SMP17
    SMP16:3 // at 18: SMP16
    SMP15:3 // at 15: SMP15
    SMP14:3 // at 12: SMP14
    SMP13:3 // at 9: SMP13
    SMP12:3 // at 6: SMP12
    SMP11:3 // at 3: SMP11
    SMP10:3 // at 0: SMP10
  }

//---  Register TR1: watchdog threshold register 1
  TR1 @offset 0x20 $u32 {
    4
    HT1:12 // at 16: HT1
    4
    LT1:12 // at 0: LT1
  }

//---  Register TR2: watchdog threshold register
  TR2 @offset 0x24 $u32 {
    8
    HT2:8 // at 16: HT2
    8
    LT2:8 // at 0: LT2
  }

//---  Register TR3: watchdog threshold register 3
  TR3 @offset 0x28 $u32 {
    8
    HT3:8 // at 16: HT3
    8
    LT3:8 // at 0: LT3
  }

//---  Register SQR1: regular sequence register 1
  SQR1 @offset 0x30 $u32 {
    3
    SQ4:5 // at 24: SQ4
    1
    SQ3:5 // at 18: SQ3
    1
    SQ2:5 // at 12: SQ2
    1
    SQ1:5 // at 6: SQ1
    2
    L:4 // at 0: L
  }

//---  Register SQR2: regular sequence register 2
  SQR2 @offset 0x34 $u32 {
    3
    SQ9:5 // at 24: SQ9
    1
    SQ8:5 // at 18: SQ8
    1
    SQ7:5 // at 12: SQ7
    1
    SQ6:5 // at 6: SQ6
    1
    SQ5:5 // at 0: SQ5
  }

//---  Register SQR3: regular sequence register 3
  SQR3 @offset 0x38 $u32 {
    3
    SQ14:5 // at 24: SQ14
    1
    SQ13:5 // at 18: SQ13
    1
    SQ12:5 // at 12: SQ12
    1
    SQ11:5 // at 6: SQ11
    1
    SQ10:5 // at 0: SQ10
  }

//---  Register SQR4: regular sequence register 4
  SQR4 @offset 0x3c $u32 {
    21
    SQ16:5 // at 6: SQ16
    1
    SQ15:5 // at 0: SQ15
  }

//---  Register DR: regular Data Register
  DR @offset 0x40 @ro $u32 {
    16
    regularDATA:16 // at 0: regularDATA
  }

//---  Register JSQR: injected sequence register
  JSQR @offset 0x4c $u32 {
    1
    JSQ4:5 // at 26: JSQ4
    1
    JSQ3:5 // at 20: JSQ3
    1
    JSQ2:5 // at 14: JSQ2
    1
    JSQ1:5 // at 8: JSQ1
    JEXTEN:2 // at 6: JEXTEN
    JEXTSEL:4 // at 2: JEXTSEL
    JL:2 // at 0: JL
  }

//---  Register OFR1: offset register 1
  OFR1 @offset 0x60 $u32 {
    OFFSET1_EN // at 31: OFFSET1_EN
    OFFSET1_CH:5 // at 26: OFFSET1_CH
    14
    OFFSET1:12 // at 0: OFFSET1
  }

//---  Register OFR2: offset register 2
  OFR2 @offset 0x64 $u32 {
    OFFSET2_EN // at 31: OFFSET2_EN
    OFFSET2_CH:5 // at 26: OFFSET2_CH
    14
    OFFSET2:12 // at 0: OFFSET2
  }

//---  Register OFR3: offset register 3
  OFR3 @offset 0x68 $u32 {
    OFFSET3_EN // at 31: OFFSET3_EN
    OFFSET3_CH:5 // at 26: OFFSET3_CH
    14
    OFFSET3:12 // at 0: OFFSET3
  }

//---  Register OFR4: offset register 4
  OFR4 @offset 0x6c $u32 {
    OFFSET4_EN // at 31: OFFSET4_EN
    OFFSET4_CH:5 // at 26: OFFSET4_CH
    14
    OFFSET4:12 // at 0: OFFSET4
  }

//---  Register JDR1: injected data register 1
  JDR1 @offset 0x80 @ro $u32 {
    16
    JDATA1:16 // at 0: JDATA1
  }

//---  Register JDR2: injected data register 2
  JDR2 @offset 0x84 @ro $u32 {
    16
    JDATA2:16 // at 0: JDATA2
  }

//---  Register JDR3: injected data register 3
  JDR3 @offset 0x88 @ro $u32 {
    16
    JDATA3:16 // at 0: JDATA3
  }

//---  Register JDR4: injected data register 4
  JDR4 @offset 0x8c @ro $u32 {
    16
    JDATA4:16 // at 0: JDATA4
  }

//---  Register AWD2CR: Analog Watchdog 2 Configuration           Register
  AWD2CR @offset 0xa0 $u32 {
    13
    AWD2CH:19 // at 0: AWD2CH
  }

//---  Register AWD3CR: Analog Watchdog 3 Configuration           Register
  AWD3CR @offset 0xa4 $u32 {
    13
    AWD3CH:19 // at 0: AWD3CH
  }

//---  Register DIFSEL: Differential Mode Selection Register           2
  DIFSEL @offset 0xb0 $u32 {
    13
    DIFSEL_16_18:3 // at 16: Differential mode for channels 18 to 16
    DIFSEL_1_15:15 // at 1: Differential mode for channels 15 to 1
    DIFSEL_0 // at 0: Differential mode for channel 0
  }

//---  Register CALFACT: Calibration Factors
  CALFACT @offset 0xb4 $u32 {
    9
    CALFACT_D:7 // at 16: CALFACT_D
    9
    CALFACT_S:7 // at 0: CALFACT_S
  }

}

//------------------------------------------------------------------------------
// Peripheral ADC123_Common: Analog-to-Digital Converter
//------------------------------------------------------------------------------

registers ©ADC123_Common @at 0x50040300 {
//---  Register CSR: ADC Common status register
  CSR @offset 0x0 @ro $u32 {
    5
    JQOVF_SLV // at 26: Injected Context Queue Overflow flag of the slave ADC
    AWD3_SLV // at 25: Analog watchdog 3 flag of the slave ADC
    AWD2_SLV // at 24: Analog watchdog 2 flag of the slave ADC
    AWD1_SLV // at 23: Analog watchdog 1 flag of the slave ADC
    JEOS_SLV // at 22: End of injected sequence flag of the slave ADC
    JEOC_SLV // at 21: End of injected conversion flag of the slave ADC
    OVR_SLV // at 20: Overrun flag of the slave ADC
    EOS_SLV // at 19: End of regular sequence flag of the slave ADC
    EOC_SLV // at 18: End of regular conversion of the slave ADC
    EOSMP_SLV // at 17: EOSMP_SLV
    ADRDY_SLV // at 16: ADRDY_SLV
    5
    JQOVF_MST // at 10: JQOVF_MST
    AWD3_MST // at 9: AWD3_MST
    AWD2_MST // at 8: AWD2_MST
    AWD1_MST // at 7: AWD1_MST
    JEOS_MST // at 6: JEOS_MST
    JEOC_MST // at 5: JEOC_MST
    OVR_MST // at 4: OVR_MST
    EOS_MST // at 3: EOS_MST
    EOC_MST // at 2: EOC_MST
    EOSMP_MST // at 1: EOSMP_MST
    ADDRDY_MST // at 0: ADDRDY_MST
  }

//---  Register CCR: ADC common control register
  CCR @offset 0x8 $u32 {
    7
    CH18SEL // at 24: CH18SEL
    CH17SEL // at 23: CH17SEL
    VREFEN // at 22: VREFINT enable
    PRESC:4 // at 18: ADC prescaler
    CKMODE:2 // at 16: ADC clock mode
    MDMA:2 // at 14: Direct memory access mode for multi ADC mode
    DMACFG // at 13: DMA configuration (for multi-ADC mode)
    1
    DELAY:4 // at 8: Delay between 2 sampling phases
    3
    DUAL:5 // at 0: Dual ADC mode selection
  }

//---  Register CDR: ADC common regular data register for dual           and triple modes
  CDR @offset 0xc @ro $u32 {
    RDATA_SLV:16 // at 16: Regular data of the slave ADC
    RDATA_MST:16 // at 0: Regular data of the master ADC
  }

}

//------------------------------------------------------------------------------
// Peripheral ADC2
//------------------------------------------------------------------------------

registers ©ADC2 @at 0x50040100 {
//---  Register ISR: interrupt and status register
  ISR @offset 0x0 $u32 {
    21
    JQOVF // at 10: JQOVF
    AWD3 // at 9: AWD3
    AWD2 // at 8: AWD2
    AWD1 // at 7: AWD1
    JEOS // at 6: JEOS
    JEOC // at 5: JEOC
    OVR // at 4: OVR
    EOS // at 3: EOS
    EOC // at 2: EOC
    EOSMP // at 1: EOSMP
    ADRDY // at 0: ADRDY
  }

//---  Register IER: interrupt enable register
  IER @offset 0x4 $u32 {
    21
    JQOVFIE // at 10: JQOVFIE
    AWD3IE // at 9: AWD3IE
    AWD2IE // at 8: AWD2IE
    AWD1IE // at 7: AWD1IE
    JEOSIE // at 6: JEOSIE
    JEOCIE // at 5: JEOCIE
    OVRIE // at 4: OVRIE
    EOSIE // at 3: EOSIE
    EOCIE // at 2: EOCIE
    EOSMPIE // at 1: EOSMPIE
    ADRDYIE // at 0: ADRDYIE
  }

//---  Register CR: control register
  CR @offset 0x8 $u32 {
    ADCAL // at 31: ADCAL
    ADCALDIF // at 30: ADCALDIF
    DEEPPWD // at 29: DEEPPWD
    ADVREGEN // at 28: ADVREGEN
    22
    JADSTP // at 5: JADSTP
    ADSTP // at 4: ADSTP
    JADSTART // at 3: JADSTART
    ADSTART // at 2: ADSTART
    ADDIS // at 1: ADDIS
    ADEN // at 0: ADEN
  }

//---  Register CFGR: configuration register
  CFGR @offset 0xc $u32 {
    JQDIS // at 31: JQDIS
    AWDCH1CH:5 // at 26: AWDCH1CH
    JAUTO // at 25: JAUTO
    JAWD1EN // at 24: JAWD1EN
    AWD1EN // at 23: AWD1EN
    AWD1SGL // at 22: AWD1SGL
    JQM // at 21: JQM
    JDISCEN // at 20: JDISCEN
    DISCNUM:3 // at 17: DISCNUM
    DISCEN // at 16: DISCEN
    1
    AUTDLY // at 14: AUTDLY
    CONT // at 13: CONT
    OVRMOD // at 12: OVRMOD
    EXTEN:2 // at 10: EXTEN
    EXTSEL:4 // at 6: EXTSEL
    ALIGN // at 5: ALIGN
    RES:2 // at 3: RES
    1
    DMACFG // at 1: DMACFG
    DMAEN // at 0: DMAEN
  }

//---  Register CFGR2: configuration register
  CFGR2 @offset 0x10 $u32 {
    21
    ROVSM // at 10: EXTEN
    TOVS // at 9: EXTSEL
    OVSS:4 // at 5: ALIGN
    OVSR:3 // at 2: RES
    JOVSE // at 1: DMACFG
    ROVSE // at 0: DMAEN
  }

//---  Register SMPR1: sample time register 1
  SMPR1 @offset 0x14 $u32 {
    2
    SMP9:3 // at 27: SMP9
    SMP8:3 // at 24: SMP8
    SMP7:3 // at 21: SMP7
    SMP6:3 // at 18: SMP6
    SMP5:3 // at 15: SMP5
    SMP4:3 // at 12: SMP4
    SMP3:3 // at 9: SMP3
    SMP2:3 // at 6: SMP2
    SMP1:3 // at 3: SMP1
    SMP0:3 // at 0: SMP0
  }

//---  Register SMPR2: sample time register 2
  SMPR2 @offset 0x18 $u32 {
    5
    SMP18:3 // at 24: SMP18
    SMP17:3 // at 21: SMP17
    SMP16:3 // at 18: SMP16
    SMP15:3 // at 15: SMP15
    SMP14:3 // at 12: SMP14
    SMP13:3 // at 9: SMP13
    SMP12:3 // at 6: SMP12
    SMP11:3 // at 3: SMP11
    SMP10:3 // at 0: SMP10
  }

//---  Register TR1: watchdog threshold register 1
  TR1 @offset 0x20 $u32 {
    4
    HT1:12 // at 16: HT1
    4
    LT1:12 // at 0: LT1
  }

//---  Register TR2: watchdog threshold register
  TR2 @offset 0x24 $u32 {
    8
    HT2:8 // at 16: HT2
    8
    LT2:8 // at 0: LT2
  }

//---  Register TR3: watchdog threshold register 3
  TR3 @offset 0x28 $u32 {
    8
    HT3:8 // at 16: HT3
    8
    LT3:8 // at 0: LT3
  }

//---  Register SQR1: regular sequence register 1
  SQR1 @offset 0x30 $u32 {
    3
    SQ4:5 // at 24: SQ4
    1
    SQ3:5 // at 18: SQ3
    1
    SQ2:5 // at 12: SQ2
    1
    SQ1:5 // at 6: SQ1
    2
    L:4 // at 0: L
  }

//---  Register SQR2: regular sequence register 2
  SQR2 @offset 0x34 $u32 {
    3
    SQ9:5 // at 24: SQ9
    1
    SQ8:5 // at 18: SQ8
    1
    SQ7:5 // at 12: SQ7
    1
    SQ6:5 // at 6: SQ6
    1
    SQ5:5 // at 0: SQ5
  }

//---  Register SQR3: regular sequence register 3
  SQR3 @offset 0x38 $u32 {
    3
    SQ14:5 // at 24: SQ14
    1
    SQ13:5 // at 18: SQ13
    1
    SQ12:5 // at 12: SQ12
    1
    SQ11:5 // at 6: SQ11
    1
    SQ10:5 // at 0: SQ10
  }

//---  Register SQR4: regular sequence register 4
  SQR4 @offset 0x3c $u32 {
    21
    SQ16:5 // at 6: SQ16
    1
    SQ15:5 // at 0: SQ15
  }

//---  Register DR: regular Data Register
  DR @offset 0x40 @ro $u32 {
    16
    regularDATA:16 // at 0: regularDATA
  }

//---  Register JSQR: injected sequence register
  JSQR @offset 0x4c $u32 {
    1
    JSQ4:5 // at 26: JSQ4
    1
    JSQ3:5 // at 20: JSQ3
    1
    JSQ2:5 // at 14: JSQ2
    1
    JSQ1:5 // at 8: JSQ1
    JEXTEN:2 // at 6: JEXTEN
    JEXTSEL:4 // at 2: JEXTSEL
    JL:2 // at 0: JL
  }

//---  Register OFR1: offset register 1
  OFR1 @offset 0x60 $u32 {
    OFFSET1_EN // at 31: OFFSET1_EN
    OFFSET1_CH:5 // at 26: OFFSET1_CH
    14
    OFFSET1:12 // at 0: OFFSET1
  }

//---  Register OFR2: offset register 2
  OFR2 @offset 0x64 $u32 {
    OFFSET2_EN // at 31: OFFSET2_EN
    OFFSET2_CH:5 // at 26: OFFSET2_CH
    14
    OFFSET2:12 // at 0: OFFSET2
  }

//---  Register OFR3: offset register 3
  OFR3 @offset 0x68 $u32 {
    OFFSET3_EN // at 31: OFFSET3_EN
    OFFSET3_CH:5 // at 26: OFFSET3_CH
    14
    OFFSET3:12 // at 0: OFFSET3
  }

//---  Register OFR4: offset register 4
  OFR4 @offset 0x6c $u32 {
    OFFSET4_EN // at 31: OFFSET4_EN
    OFFSET4_CH:5 // at 26: OFFSET4_CH
    14
    OFFSET4:12 // at 0: OFFSET4
  }

//---  Register JDR1: injected data register 1
  JDR1 @offset 0x80 @ro $u32 {
    16
    JDATA1:16 // at 0: JDATA1
  }

//---  Register JDR2: injected data register 2
  JDR2 @offset 0x84 @ro $u32 {
    16
    JDATA2:16 // at 0: JDATA2
  }

//---  Register JDR3: injected data register 3
  JDR3 @offset 0x88 @ro $u32 {
    16
    JDATA3:16 // at 0: JDATA3
  }

//---  Register JDR4: injected data register 4
  JDR4 @offset 0x8c @ro $u32 {
    16
    JDATA4:16 // at 0: JDATA4
  }

//---  Register AWD2CR: Analog Watchdog 2 Configuration           Register
  AWD2CR @offset 0xa0 $u32 {
    13
    AWD2CH:19 // at 0: AWD2CH
  }

//---  Register AWD3CR: Analog Watchdog 3 Configuration           Register
  AWD3CR @offset 0xa4 $u32 {
    13
    AWD3CH:19 // at 0: AWD3CH
  }

//---  Register DIFSEL: Differential Mode Selection Register           2
  DIFSEL @offset 0xb0 $u32 {
    13
    DIFSEL_16_18:3 // at 16: Differential mode for channels 18 to 16
    DIFSEL_1_15:15 // at 1: Differential mode for channels 15 to 1
    DIFSEL_0 // at 0: Differential mode for channel 0
  }

//---  Register CALFACT: Calibration Factors
  CALFACT @offset 0xb4 $u32 {
    9
    CALFACT_D:7 // at 16: CALFACT_D
    9
    CALFACT_S:7 // at 0: CALFACT_S
  }

}

//------------------------------------------------------------------------------
// Peripheral ADC3
//------------------------------------------------------------------------------

registers ©ADC3 @at 0x50040200 {
//---  Register ISR: interrupt and status register
  ISR @offset 0x0 $u32 {
    21
    JQOVF // at 10: JQOVF
    AWD3 // at 9: AWD3
    AWD2 // at 8: AWD2
    AWD1 // at 7: AWD1
    JEOS // at 6: JEOS
    JEOC // at 5: JEOC
    OVR // at 4: OVR
    EOS // at 3: EOS
    EOC // at 2: EOC
    EOSMP // at 1: EOSMP
    ADRDY // at 0: ADRDY
  }

//---  Register IER: interrupt enable register
  IER @offset 0x4 $u32 {
    21
    JQOVFIE // at 10: JQOVFIE
    AWD3IE // at 9: AWD3IE
    AWD2IE // at 8: AWD2IE
    AWD1IE // at 7: AWD1IE
    JEOSIE // at 6: JEOSIE
    JEOCIE // at 5: JEOCIE
    OVRIE // at 4: OVRIE
    EOSIE // at 3: EOSIE
    EOCIE // at 2: EOCIE
    EOSMPIE // at 1: EOSMPIE
    ADRDYIE // at 0: ADRDYIE
  }

//---  Register CR: control register
  CR @offset 0x8 $u32 {
    ADCAL // at 31: ADCAL
    ADCALDIF // at 30: ADCALDIF
    DEEPPWD // at 29: DEEPPWD
    ADVREGEN // at 28: ADVREGEN
    22
    JADSTP // at 5: JADSTP
    ADSTP // at 4: ADSTP
    JADSTART // at 3: JADSTART
    ADSTART // at 2: ADSTART
    ADDIS // at 1: ADDIS
    ADEN // at 0: ADEN
  }

//---  Register CFGR: configuration register
  CFGR @offset 0xc $u32 {
    JQDIS // at 31: JQDIS
    AWDCH1CH:5 // at 26: AWDCH1CH
    JAUTO // at 25: JAUTO
    JAWD1EN // at 24: JAWD1EN
    AWD1EN // at 23: AWD1EN
    AWD1SGL // at 22: AWD1SGL
    JQM // at 21: JQM
    JDISCEN // at 20: JDISCEN
    DISCNUM:3 // at 17: DISCNUM
    DISCEN // at 16: DISCEN
    1
    AUTDLY // at 14: AUTDLY
    CONT // at 13: CONT
    OVRMOD // at 12: OVRMOD
    EXTEN:2 // at 10: EXTEN
    EXTSEL:4 // at 6: EXTSEL
    ALIGN // at 5: ALIGN
    RES:2 // at 3: RES
    1
    DMACFG // at 1: DMACFG
    DMAEN // at 0: DMAEN
  }

//---  Register CFGR2: configuration register
  CFGR2 @offset 0x10 $u32 {
    21
    ROVSM // at 10: EXTEN
    TOVS // at 9: EXTSEL
    OVSS:4 // at 5: ALIGN
    OVSR:3 // at 2: RES
    JOVSE // at 1: DMACFG
    ROVSE // at 0: DMAEN
  }

//---  Register SMPR1: sample time register 1
  SMPR1 @offset 0x14 $u32 {
    2
    SMP9:3 // at 27: SMP9
    SMP8:3 // at 24: SMP8
    SMP7:3 // at 21: SMP7
    SMP6:3 // at 18: SMP6
    SMP5:3 // at 15: SMP5
    SMP4:3 // at 12: SMP4
    SMP3:3 // at 9: SMP3
    SMP2:3 // at 6: SMP2
    SMP1:3 // at 3: SMP1
    SMP0:3 // at 0: SMP0
  }

//---  Register SMPR2: sample time register 2
  SMPR2 @offset 0x18 $u32 {
    5
    SMP18:3 // at 24: SMP18
    SMP17:3 // at 21: SMP17
    SMP16:3 // at 18: SMP16
    SMP15:3 // at 15: SMP15
    SMP14:3 // at 12: SMP14
    SMP13:3 // at 9: SMP13
    SMP12:3 // at 6: SMP12
    SMP11:3 // at 3: SMP11
    SMP10:3 // at 0: SMP10
  }

//---  Register TR1: watchdog threshold register 1
  TR1 @offset 0x20 $u32 {
    4
    HT1:12 // at 16: HT1
    4
    LT1:12 // at 0: LT1
  }

//---  Register TR2: watchdog threshold register
  TR2 @offset 0x24 $u32 {
    8
    HT2:8 // at 16: HT2
    8
    LT2:8 // at 0: LT2
  }

//---  Register TR3: watchdog threshold register 3
  TR3 @offset 0x28 $u32 {
    8
    HT3:8 // at 16: HT3
    8
    LT3:8 // at 0: LT3
  }

//---  Register SQR1: regular sequence register 1
  SQR1 @offset 0x30 $u32 {
    3
    SQ4:5 // at 24: SQ4
    1
    SQ3:5 // at 18: SQ3
    1
    SQ2:5 // at 12: SQ2
    1
    SQ1:5 // at 6: SQ1
    2
    L:4 // at 0: L
  }

//---  Register SQR2: regular sequence register 2
  SQR2 @offset 0x34 $u32 {
    3
    SQ9:5 // at 24: SQ9
    1
    SQ8:5 // at 18: SQ8
    1
    SQ7:5 // at 12: SQ7
    1
    SQ6:5 // at 6: SQ6
    1
    SQ5:5 // at 0: SQ5
  }

//---  Register SQR3: regular sequence register 3
  SQR3 @offset 0x38 $u32 {
    3
    SQ14:5 // at 24: SQ14
    1
    SQ13:5 // at 18: SQ13
    1
    SQ12:5 // at 12: SQ12
    1
    SQ11:5 // at 6: SQ11
    1
    SQ10:5 // at 0: SQ10
  }

//---  Register SQR4: regular sequence register 4
  SQR4 @offset 0x3c $u32 {
    21
    SQ16:5 // at 6: SQ16
    1
    SQ15:5 // at 0: SQ15
  }

//---  Register DR: regular Data Register
  DR @offset 0x40 @ro $u32 {
    16
    regularDATA:16 // at 0: regularDATA
  }

//---  Register JSQR: injected sequence register
  JSQR @offset 0x4c $u32 {
    1
    JSQ4:5 // at 26: JSQ4
    1
    JSQ3:5 // at 20: JSQ3
    1
    JSQ2:5 // at 14: JSQ2
    1
    JSQ1:5 // at 8: JSQ1
    JEXTEN:2 // at 6: JEXTEN
    JEXTSEL:4 // at 2: JEXTSEL
    JL:2 // at 0: JL
  }

//---  Register OFR1: offset register 1
  OFR1 @offset 0x60 $u32 {
    OFFSET1_EN // at 31: OFFSET1_EN
    OFFSET1_CH:5 // at 26: OFFSET1_CH
    14
    OFFSET1:12 // at 0: OFFSET1
  }

//---  Register OFR2: offset register 2
  OFR2 @offset 0x64 $u32 {
    OFFSET2_EN // at 31: OFFSET2_EN
    OFFSET2_CH:5 // at 26: OFFSET2_CH
    14
    OFFSET2:12 // at 0: OFFSET2
  }

//---  Register OFR3: offset register 3
  OFR3 @offset 0x68 $u32 {
    OFFSET3_EN // at 31: OFFSET3_EN
    OFFSET3_CH:5 // at 26: OFFSET3_CH
    14
    OFFSET3:12 // at 0: OFFSET3
  }

//---  Register OFR4: offset register 4
  OFR4 @offset 0x6c $u32 {
    OFFSET4_EN // at 31: OFFSET4_EN
    OFFSET4_CH:5 // at 26: OFFSET4_CH
    14
    OFFSET4:12 // at 0: OFFSET4
  }

//---  Register JDR1: injected data register 1
  JDR1 @offset 0x80 @ro $u32 {
    16
    JDATA1:16 // at 0: JDATA1
  }

//---  Register JDR2: injected data register 2
  JDR2 @offset 0x84 @ro $u32 {
    16
    JDATA2:16 // at 0: JDATA2
  }

//---  Register JDR3: injected data register 3
  JDR3 @offset 0x88 @ro $u32 {
    16
    JDATA3:16 // at 0: JDATA3
  }

//---  Register JDR4: injected data register 4
  JDR4 @offset 0x8c @ro $u32 {
    16
    JDATA4:16 // at 0: JDATA4
  }

//---  Register AWD2CR: Analog Watchdog 2 Configuration           Register
  AWD2CR @offset 0xa0 $u32 {
    13
    AWD2CH:19 // at 0: AWD2CH
  }

//---  Register AWD3CR: Analog Watchdog 3 Configuration           Register
  AWD3CR @offset 0xa4 $u32 {
    13
    AWD3CH:19 // at 0: AWD3CH
  }

//---  Register DIFSEL: Differential Mode Selection Register           2
  DIFSEL @offset 0xb0 $u32 {
    13
    DIFSEL_16_18:3 // at 16: Differential mode for channels 18 to 16
    DIFSEL_1_15:15 // at 1: Differential mode for channels 15 to 1
    DIFSEL_0 // at 0: Differential mode for channel 0
  }

//---  Register CALFACT: Calibration Factors
  CALFACT @offset 0xb4 $u32 {
    9
    CALFACT_D:7 // at 16: CALFACT_D
    9
    CALFACT_S:7 // at 0: CALFACT_S
  }

}

//------------------------------------------------------------------------------
// Peripheral AES: Advanced encryption standard hardware       accelerator
//------------------------------------------------------------------------------

registers ©AES @at 0x50060000 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    19
    DMAOUTEN // at 12: Enable DMA management of data output phase
    DMAINEN // at 11: Enable DMA management of data input phase
    ERRIE // at 10: Error interrupt enable
    CCFIE // at 9: CCF flag interrupt enable
    ERRC // at 8: Error clear
    CCFC // at 7: Computation Complete Flag Clear
    CHMOD:2 // at 5: AES chaining mode
    MODE:2 // at 3: AES operating mode
    DATATYPE:2 // at 1: Data type selection (for data in and data out to/from the cryptographic block)
    EN // at 0: AES enable
  }

//---  Register SR: status register
  SR @offset 0x4 @ro $u32 {
    29
    WRERR // at 2: Write error flag
    RDERR // at 1: Read error flag
    CCF // at 0: Computation complete flag
  }

//---  Register DINR: data input register
  DINR @offset 0x8 $u32 {
    AES_DINR:32 // at 0: Data Input Register
  }

//---  Register DOUTR: data output register
  DOUTR @offset 0xc @ro $u32 {
    AES_DOUTR:32 // at 0: Data output register
  }

//---  Register KEYR0: key register 0
  KEYR0 @offset 0x10 $u32 {
    AES_KEYR0:32 // at 0: Data Output Register (LSB key [31:0])
  }

//---  Register KEYR1: key register 1
  KEYR1 @offset 0x14 $u32 {
    AES_KEYR1:32 // at 0: AES key register (key [63:32])
  }

//---  Register KEYR2: key register 2
  KEYR2 @offset 0x18 $u32 {
    AES_KEYR2:32 // at 0: AES key register (key [95:64])
  }

//---  Register KEYR3: key register 3
  KEYR3 @offset 0x1c $u32 {
    AES_KEYR3:32 // at 0: AES key register (MSB key [127:96])
  }

//---  Register IVR0: initialization vector register           0
  IVR0 @offset 0x20 $u32 {
    AES_IVR0:32 // at 0: initialization vector register (LSB IVR [31:0])
  }

//---  Register IVR1: initialization vector register           1
  IVR1 @offset 0x24 $u32 {
    AES_IVR1:32 // at 0: Initialization Vector Register (IVR [63:32])
  }

//---  Register IVR2: initialization vector register           2
  IVR2 @offset 0x28 $u32 {
    AES_IVR2:32 // at 0: Initialization Vector Register (IVR [95:64])
  }

//---  Register IVR3: initialization vector register           3
  IVR3 @offset 0x2c $u32 {
    AES_IVR3:32 // at 0: Initialization Vector Register (MSB IVR [127:96])
  }

}

//------------------------------------------------------------------------------
// Peripheral CAN1: Controller area network
//------------------------------------------------------------------------------

registers ©CAN1 @at 0x40006400 {
//---  Register MCR: master control register
  MCR @offset 0x0 $u32 {
    15
    DBF // at 16: DBF
    RESET // at 15: RESET
    7
    TTCM // at 7: TTCM
    ABOM // at 6: ABOM
    AWUM // at 5: AWUM
    NART // at 4: NART
    RFLM // at 3: RFLM
    TXFP // at 2: TXFP
    SLEEP // at 1: SLEEP
    INRQ // at 0: INRQ
  }

//---  Register MSR: master status register
  MSR @offset 0x4 $u32 {
    20
    RX // at 11: RX
    SAMP // at 10: SAMP
    RXM // at 9: RXM
    TXM // at 8: TXM
    3
    SLAKI // at 4: SLAKI
    WKUI // at 3: WKUI
    ERRI // at 2: ERRI
    SLAK // at 1: SLAK
    INAK // at 0: INAK
  }

//---  Register TSR: transmit status register
  TSR @offset 0x8 $u32 {
    LOW2 // at 31: Lowest priority flag for mailbox 2
    LOW1 // at 30: Lowest priority flag for mailbox 1
    LOW0 // at 29: Lowest priority flag for mailbox 0
    TME2 // at 28: Lowest priority flag for mailbox 2
    TME1 // at 27: Lowest priority flag for mailbox 1
    TME0 // at 26: Lowest priority flag for mailbox 0
    CODE:2 // at 24: CODE
    ABRQ2 // at 23: ABRQ2
    3
    TERR2 // at 19: TERR2
    ALST2 // at 18: ALST2
    TXOK2 // at 17: TXOK2
    RQCP2 // at 16: RQCP2
    ABRQ1 // at 15: ABRQ1
    3
    TERR1 // at 11: TERR1
    ALST1 // at 10: ALST1
    TXOK1 // at 9: TXOK1
    RQCP1 // at 8: RQCP1
    ABRQ0 // at 7: ABRQ0
    3
    TERR0 // at 3: TERR0
    ALST0 // at 2: ALST0
    TXOK0 // at 1: TXOK0
    RQCP0 // at 0: RQCP0
  }

//---  Register RF0R: receive FIFO 0 register
  RF0R @offset 0xc $u32 {
    26
    RFOM0 // at 5: RFOM0
    FOVR0 // at 4: FOVR0
    FULL0 // at 3: FULL0
    1
    FMP0:2 // at 0: FMP0
  }

//---  Register RF1R: receive FIFO 1 register
  RF1R @offset 0x10 $u32 {
    26
    RFOM1 // at 5: RFOM1
    FOVR1 // at 4: FOVR1
    FULL1 // at 3: FULL1
    1
    FMP1:2 // at 0: FMP1
  }

//---  Register IER: interrupt enable register
  IER @offset 0x14 $u32 {
    14
    SLKIE // at 17: SLKIE
    WKUIE // at 16: WKUIE
    ERRIE // at 15: ERRIE
    3
    LECIE // at 11: LECIE
    BOFIE // at 10: BOFIE
    EPVIE // at 9: EPVIE
    EWGIE // at 8: EWGIE
    1
    FOVIE1 // at 6: FOVIE1
    FFIE1 // at 5: FFIE1
    FMPIE1 // at 4: FMPIE1
    FOVIE0 // at 3: FOVIE0
    FFIE0 // at 2: FFIE0
    FMPIE0 // at 1: FMPIE0
    TMEIE // at 0: TMEIE
  }

//---  Register ESR: interrupt enable register
  ESR @offset 0x18 $u32 {
    REC:8 // at 24: REC
    TEC:8 // at 16: TEC
    9
    LEC:3 // at 4: LEC
    1
    BOFF // at 2: BOFF
    EPVF // at 1: EPVF
    EWGF // at 0: EWGF
  }

//---  Register BTR: bit timing register
  BTR @offset 0x1c $u32 {
    SILM // at 31: SILM
    LBKM // at 30: LBKM
    4
    SJW:2 // at 24: SJW
    1
    TS2:3 // at 20: TS2
    TS1:4 // at 16: TS1
    6
    BRP:10 // at 0: BRP
  }

//---  Register TI0R: TX mailbox identifier register
  TI0R @offset 0x180 $u32 {
    STID:11 // at 21: STID
    EXID:18 // at 3: EXID
    IDE // at 2: IDE
    RTR // at 1: RTR
    TXRQ // at 0: TXRQ
  }

//---  Register TDT0R: mailbox data length control and time stamp           register
  TDT0R @offset 0x184 $u32 {
    TIME:16 // at 16: TIME
    7
    TGT // at 8: TGT
    4
    DLC:4 // at 0: DLC
  }

//---  Register TDL0R: mailbox data low register
  TDL0R @offset 0x188 $u32 {
    DATA3:8 // at 24: DATA3
    DATA2:8 // at 16: DATA2
    DATA1:8 // at 8: DATA1
    DATA0:8 // at 0: DATA0
  }

//---  Register TDH0R: mailbox data high register
  TDH0R @offset 0x18c $u32 {
    DATA7:8 // at 24: DATA7
    DATA6:8 // at 16: DATA6
    DATA5:8 // at 8: DATA5
    DATA4:8 // at 0: DATA4
  }

//---  Register TI1R: mailbox identifier register
  TI1R @offset 0x190 $u32 {
    STID:11 // at 21: STID
    EXID:18 // at 3: EXID
    IDE // at 2: IDE
    RTR // at 1: RTR
    TXRQ // at 0: TXRQ
  }

//---  Register TDT1R: mailbox data length control and time stamp           register
  TDT1R @offset 0x194 $u32 {
    TIME:16 // at 16: TIME
    7
    TGT // at 8: TGT
    4
    DLC:4 // at 0: DLC
  }

//---  Register TDL1R: mailbox data low register
  TDL1R @offset 0x198 $u32 {
    DATA3:8 // at 24: DATA3
    DATA2:8 // at 16: DATA2
    DATA1:8 // at 8: DATA1
    DATA0:8 // at 0: DATA0
  }

//---  Register TDH1R: mailbox data high register
  TDH1R @offset 0x19c $u32 {
    DATA7:8 // at 24: DATA7
    DATA6:8 // at 16: DATA6
    DATA5:8 // at 8: DATA5
    DATA4:8 // at 0: DATA4
  }

//---  Register TI2R: mailbox identifier register
  TI2R @offset 0x1a0 $u32 {
    STID:11 // at 21: STID
    EXID:18 // at 3: EXID
    IDE // at 2: IDE
    RTR // at 1: RTR
    TXRQ // at 0: TXRQ
  }

//---  Register TDT2R: mailbox data length control and time stamp           register
  TDT2R @offset 0x1a4 $u32 {
    TIME:16 // at 16: TIME
    7
    TGT // at 8: TGT
    4
    DLC:4 // at 0: DLC
  }

//---  Register TDL2R: mailbox data low register
  TDL2R @offset 0x1a8 $u32 {
    DATA3:8 // at 24: DATA3
    DATA2:8 // at 16: DATA2
    DATA1:8 // at 8: DATA1
    DATA0:8 // at 0: DATA0
  }

//---  Register TDH2R: mailbox data high register
  TDH2R @offset 0x1ac $u32 {
    DATA7:8 // at 24: DATA7
    DATA6:8 // at 16: DATA6
    DATA5:8 // at 8: DATA5
    DATA4:8 // at 0: DATA4
  }

//---  Register RI0R: receive FIFO mailbox identifier           register
  RI0R @offset 0x1b0 @ro $u32 {
    STID:11 // at 21: STID
    EXID:18 // at 3: EXID
    IDE // at 2: IDE
    RTR // at 1: RTR
    1
  }

//---  Register RDT0R: mailbox data high register
  RDT0R @offset 0x1b4 @ro $u32 {
    TIME:16 // at 16: TIME
    FMI:8 // at 8: FMI
    4
    DLC:4 // at 0: DLC
  }

//---  Register RDL0R: mailbox data high register
  RDL0R @offset 0x1b8 @ro $u32 {
    DATA3:8 // at 24: DATA3
    DATA2:8 // at 16: DATA2
    DATA1:8 // at 8: DATA1
    DATA0:8 // at 0: DATA0
  }

//---  Register RDH0R: receive FIFO mailbox data high           register
  RDH0R @offset 0x1bc @ro $u32 {
    DATA7:8 // at 24: DATA7
    DATA6:8 // at 16: DATA6
    DATA5:8 // at 8: DATA5
    DATA4:8 // at 0: DATA4
  }

//---  Register RI1R: mailbox data high register
  RI1R @offset 0x1c0 @ro $u32 {
    STID:11 // at 21: STID
    EXID:18 // at 3: EXID
    IDE // at 2: IDE
    RTR // at 1: RTR
    1
  }

//---  Register RDT1R: mailbox data high register
  RDT1R @offset 0x1c4 @ro $u32 {
    TIME:16 // at 16: TIME
    FMI:8 // at 8: FMI
    4
    DLC:4 // at 0: DLC
  }

//---  Register RDL1R: mailbox data high register
  RDL1R @offset 0x1c8 @ro $u32 {
    DATA3:8 // at 24: DATA3
    DATA2:8 // at 16: DATA2
    DATA1:8 // at 8: DATA1
    DATA0:8 // at 0: DATA0
  }

//---  Register RDH1R: mailbox data high register
  RDH1R @offset 0x1cc @ro $u32 {
    DATA7:8 // at 24: DATA7
    DATA6:8 // at 16: DATA6
    DATA5:8 // at 8: DATA5
    DATA4:8 // at 0: DATA4
  }

//---  Register FMR: filter master register
  FMR @offset 0x200 $u32 {
    31
    FINIT // at 0: Filter initialization mode
  }

//---  Register FM1R: filter mode register
  FM1R @offset 0x204 $u32 {
    18
    FBM13 // at 13: Filter mode
    FBM12 // at 12: Filter mode
    FBM11 // at 11: Filter mode
    FBM10 // at 10: Filter mode
    FBM9 // at 9: Filter mode
    FBM8 // at 8: Filter mode
    FBM7 // at 7: Filter mode
    FBM6 // at 6: Filter mode
    FBM5 // at 5: Filter mode
    FBM4 // at 4: Filter mode
    FBM3 // at 3: Filter mode
    FBM2 // at 2: Filter mode
    FBM1 // at 1: Filter mode
    FBM0 // at 0: Filter mode
  }

//---  Register FS1R: filter scale register
  FS1R @offset 0x20c $u32 {
    18
    FSC13 // at 13: Filter scale configuration
    FSC12 // at 12: Filter scale configuration
    FSC11 // at 11: Filter scale configuration
    FSC10 // at 10: Filter scale configuration
    FSC9 // at 9: Filter scale configuration
    FSC8 // at 8: Filter scale configuration
    FSC7 // at 7: Filter scale configuration
    FSC6 // at 6: Filter scale configuration
    FSC5 // at 5: Filter scale configuration
    FSC4 // at 4: Filter scale configuration
    FSC3 // at 3: Filter scale configuration
    FSC2 // at 2: Filter scale configuration
    FSC1 // at 1: Filter scale configuration
    FSC0 // at 0: Filter scale configuration
  }

//---  Register FFA1R: filter FIFO assignment           register
  FFA1R @offset 0x214 $u32 {
    18
    FFA13 // at 13: Filter FIFO assignment for filter 13
    FFA12 // at 12: Filter FIFO assignment for filter 12
    FFA11 // at 11: Filter FIFO assignment for filter 11
    FFA10 // at 10: Filter FIFO assignment for filter 10
    FFA9 // at 9: Filter FIFO assignment for filter 9
    FFA8 // at 8: Filter FIFO assignment for filter 8
    FFA7 // at 7: Filter FIFO assignment for filter 7
    FFA6 // at 6: Filter FIFO assignment for filter 6
    FFA5 // at 5: Filter FIFO assignment for filter 5
    FFA4 // at 4: Filter FIFO assignment for filter 4
    FFA3 // at 3: Filter FIFO assignment for filter 3
    FFA2 // at 2: Filter FIFO assignment for filter 2
    FFA1 // at 1: Filter FIFO assignment for filter 1
    FFA0 // at 0: Filter FIFO assignment for filter 0
  }

//---  Register FA1R: filter activation register
  FA1R @offset 0x21c $u32 {
    18
    FACT13 // at 13: Filter active
    FACT12 // at 12: Filter active
    FACT11 // at 11: Filter active
    FACT10 // at 10: Filter active
    FACT9 // at 9: Filter active
    FACT8 // at 8: Filter active
    FACT7 // at 7: Filter active
    FACT6 // at 6: Filter active
    FACT5 // at 5: Filter active
    FACT4 // at 4: Filter active
    FACT3 // at 3: Filter active
    FACT2 // at 2: Filter active
    FACT1 // at 1: Filter active
    FACT0 // at 0: Filter active
  }

//---  Register F0R1: Filter bank 0 register 1
  F0R1 @offset 0x240 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F0R2: Filter bank 0 register 2
  F0R2 @offset 0x244 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F1R1: Filter bank 1 register 1
  F1R1 @offset 0x248 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F1R2: Filter bank 1 register 2
  F1R2 @offset 0x24c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F2R1: Filter bank 2 register 1
  F2R1 @offset 0x250 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F2R2: Filter bank 2 register 2
  F2R2 @offset 0x254 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F3R1: Filter bank 3 register 1
  F3R1 @offset 0x258 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F3R2: Filter bank 3 register 2
  F3R2 @offset 0x25c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F4R1: Filter bank 4 register 1
  F4R1 @offset 0x260 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F4R2: Filter bank 4 register 2
  F4R2 @offset 0x264 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F5R1: Filter bank 5 register 1
  F5R1 @offset 0x268 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F5R2: Filter bank 5 register 2
  F5R2 @offset 0x26c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F6R1: Filter bank 6 register 1
  F6R1 @offset 0x270 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F6R2: Filter bank 6 register 2
  F6R2 @offset 0x274 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F7R1: Filter bank 7 register 1
  F7R1 @offset 0x278 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F7R2: Filter bank 7 register 2
  F7R2 @offset 0x27c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F8R1: Filter bank 8 register 1
  F8R1 @offset 0x280 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F8R2: Filter bank 8 register 2
  F8R2 @offset 0x284 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F9R1: Filter bank 9 register 1
  F9R1 @offset 0x288 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F9R2: Filter bank 9 register 2
  F9R2 @offset 0x28c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F10R1: Filter bank 10 register 1
  F10R1 @offset 0x290 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F10R2: Filter bank 10 register 2
  F10R2 @offset 0x294 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F11R1: Filter bank 11 register 1
  F11R1 @offset 0x298 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F11R2: Filter bank 11 register 2
  F11R2 @offset 0x29c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F12R1: Filter bank 4 register 1
  F12R1 @offset 0x2a0 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F12R2: Filter bank 12 register 2
  F12R2 @offset 0x2a4 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F13R1: Filter bank 13 register 1
  F13R1 @offset 0x2a8 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F13R2: Filter bank 13 register 2
  F13R2 @offset 0x2ac $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F14R1: Filter bank 14 register 1
  F14R1 @offset 0x2b0 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F14R2: Filter bank 14 register 2
  F14R2 @offset 0x2b4 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F15R1: Filter bank 15 register 1
  F15R1 @offset 0x2b8 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F15R2: Filter bank 15 register 2
  F15R2 @offset 0x2bc $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F16R1: Filter bank 16 register 1
  F16R1 @offset 0x2c0 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F16R2: Filter bank 16 register 2
  F16R2 @offset 0x2c4 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F17R1: Filter bank 17 register 1
  F17R1 @offset 0x2c8 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F17R2: Filter bank 17 register 2
  F17R2 @offset 0x2cc $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F18R1: Filter bank 18 register 1
  F18R1 @offset 0x2d0 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F18R2: Filter bank 18 register 2
  F18R2 @offset 0x2d4 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F19R1: Filter bank 19 register 1
  F19R1 @offset 0x2d8 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F19R2: Filter bank 19 register 2
  F19R2 @offset 0x2dc $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F20R1: Filter bank 20 register 1
  F20R1 @offset 0x2e0 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F20R2: Filter bank 20 register 2
  F20R2 @offset 0x2e4 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F21R1: Filter bank 21 register 1
  F21R1 @offset 0x2e8 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F21R2: Filter bank 21 register 2
  F21R2 @offset 0x2ec $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F22R1: Filter bank 22 register 1
  F22R1 @offset 0x2f0 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F22R2: Filter bank 22 register 2
  F22R2 @offset 0x2f4 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F23R1: Filter bank 23 register 1
  F23R1 @offset 0x2f8 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F23R2: Filter bank 23 register 2
  F23R2 @offset 0x2fc $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F24R1: Filter bank 24 register 1
  F24R1 @offset 0x300 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F24R2: Filter bank 24 register 2
  F24R2 @offset 0x304 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F25R1: Filter bank 25 register 1
  F25R1 @offset 0x308 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F25R2: Filter bank 25 register 2
  F25R2 @offset 0x30c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F26R1: Filter bank 26 register 1
  F26R1 @offset 0x310 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F26R2: Filter bank 26 register 2
  F26R2 @offset 0x314 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F27R1: Filter bank 27 register 1
  F27R1 @offset 0x318 $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

//---  Register F27R2: Filter bank 27 register 2
  F27R2 @offset 0x31c $u32 {
    FB31 // at 31: Filter bits
    FB30 // at 30: Filter bits
    FB29 // at 29: Filter bits
    FB28 // at 28: Filter bits
    FB27 // at 27: Filter bits
    FB26 // at 26: Filter bits
    FB25 // at 25: Filter bits
    FB24 // at 24: Filter bits
    FB23 // at 23: Filter bits
    FB22 // at 22: Filter bits
    FB21 // at 21: Filter bits
    FB20 // at 20: Filter bits
    FB19 // at 19: Filter bits
    FB18 // at 18: Filter bits
    FB17 // at 17: Filter bits
    FB16 // at 16: Filter bits
    FB15 // at 15: Filter bits
    FB14 // at 14: Filter bits
    FB13 // at 13: Filter bits
    FB12 // at 12: Filter bits
    FB11 // at 11: Filter bits
    FB10 // at 10: Filter bits
    FB9 // at 9: Filter bits
    FB8 // at 8: Filter bits
    FB7 // at 7: Filter bits
    FB6 // at 6: Filter bits
    FB5 // at 5: Filter bits
    FB4 // at 4: Filter bits
    FB3 // at 3: Filter bits
    FB2 // at 2: Filter bits
    FB1 // at 1: Filter bits
    FB0 // at 0: Filter bits
  }

}

//------------------------------------------------------------------------------
// Peripheral COMP: Comparator
//------------------------------------------------------------------------------

registers ©COMP @at 0x40010200 {
//---  Register COMP1_CSR: Comparator 1 control and status           register
  COMP1_CSR @offset 0x0 $u32 {
    COMP1_LOCK // at 31: COMP1_CSR register lock bit
    COMP1_VALUE // at 30: Comparator 1 output status bit
    3
    COMP1_INMESEL:2 // at 25: comparator 1 input minus extended selection bits
    1
    COMP1_SCALEN // at 23: Voltage scaler enable bit
    COMP1_BRGEN // at 22: Scaler bridge enable
    1
    COMP1_BLANKING:3 // at 18: Comparator 1 blanking source selection bits
    COMP1_HYST:2 // at 16: Comparator 1 hysteresis selection bits
    COMP1_POLARITY // at 15: Comparator 1 polarity selection bit
    6
    COMP1_INPSEL:2 // at 7: Comparator1 input plus selection bit
    COMP1_INMSEL:3 // at 4: Comparator 1 Input Minus connection configuration bit
    COMP1_PWRMODE:2 // at 2: Power Mode of the comparator 1
    1
    COMP1_EN // at 0: Comparator 1 enable bit
  }

//---  Register COMP2_CSR: Comparator 2 control and status           register
  COMP2_CSR @offset 0x4 $u32 {
    COMP2_LOCK // at 31: COMP2_CSR register lock bit
    COMP2_VALUE // at 30: Comparator 2 output status bit
    3
    COMP2_INMESEL:2 // at 25: comparator 2 input minus extended selection bits
    1
    COMP2_SCALEN // at 23: Voltage scaler enable bit
    COMP2_BRGEN // at 22: Scaler bridge enable
    1
    COMP2_BLANKING:3 // at 18: Comparator 2 blanking source selection bits
    COMP2_HYST:2 // at 16: Comparator 2 hysteresis selection bits
    COMP2_POLARITY // at 15: Comparator 2 polarity selection bit
    5
    COMP2_WINMODE // at 9: Windows mode selection bit
    COMP2_INPSEL:2 // at 7: Comparator 2 Input Plus connection configuration bit
    COMP2_INMSEL:3 // at 4: Comparator 2 Input Minus connection configuration bit
    COMP2_PWRMODE:2 // at 2: Power Mode of the comparator 2
    1
    COMP2_EN // at 0: Comparator 2 enable bit
  }

}

//------------------------------------------------------------------------------
// Peripheral CRC: Cyclic redundancy check calculation       unit
//------------------------------------------------------------------------------

registers ©CRC @at 0x40023000 {
//---  Register DR: Data register
  DR @offset 0x0 $u32 {
    DR:32 // at 0: Data register bits
  }

//---  Register IDR: Independent data register
  IDR @offset 0x4 $u32 {
    24
    IDR:8 // at 0: General-purpose 8-bit data register bits
  }

//---  Register CR: Control register
  CR @offset 0x8 $u32 {
    24
    REV_OUT // at 7: Reverse output data
    REV_IN:2 // at 5: Reverse input data
    POLYSIZE:2 // at 3: Polynomial size
    2
    RESET // at 0: RESET bit
  }

//---  Register INIT: Initial CRC value
  INIT @offset 0x10 $u32 {
    CRC_INIT:32 // at 0: Programmable initial CRC value
  }

//---  Register POL: polynomial
  POL @offset 0x14 $u32 {
    Polynomialcoefficients:32 // at 0: Programmable polynomial
  }

}

//------------------------------------------------------------------------------
// Peripheral CRS: Clock recovery system
//------------------------------------------------------------------------------

registers ©CRS @at 0x40006000 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    18
    TRIM:6 // at 8: HSI48 oscillator smooth trimming
    SWSYNC // at 7: Generate software SYNC event
    AUTOTRIMEN // at 6: Automatic trimming enable
    CEN // at 5: Frequency error counter enable
    1
    ESYNCIE // at 3: Expected SYNC interrupt enable
    ERRIE // at 2: Synchronization or trimming error interrupt enable
    SYNCWARNIE // at 1: SYNC warning interrupt enable
    SYNCOKIE // at 0: SYNC event OK interrupt enable
  }

//---  Register CFGR: configuration register
  CFGR @offset 0x4 $u32 {
    SYNCPOL // at 31: SYNC polarity selection
    1
    SYNCSRC:2 // at 28: SYNC signal source selection
    1
    SYNCDIV:3 // at 24: SYNC divider
    FELIM:8 // at 16: Frequency error limit
    RELOAD:16 // at 0: Counter reload value
  }

//---  Register ISR: interrupt and status register
  ISR @offset 0x8 @ro $u32 {
    FECAP:16 // at 16: Frequency error capture
    FEDIR // at 15: Frequency error direction
    4
    TRIMOVF // at 10: Trimming overflow or underflow
    SYNCMISS // at 9: SYNC missed
    SYNCERR // at 8: SYNC error
    4
    ESYNCF // at 3: Expected SYNC flag
    ERRF // at 2: Error flag
    SYNCWARNF // at 1: SYNC warning flag
    SYNCOKF // at 0: SYNC event OK flag
  }

//---  Register ICR: interrupt flag clear register
  ICR @offset 0xc $u32 {
    28
    ESYNCC // at 3: Expected SYNC clear flag
    ERRC // at 2: Error clear flag
    SYNCWARNC // at 1: SYNC warning clear flag
    SYNCOKC // at 0: SYNC event OK clear flag
  }

}

//------------------------------------------------------------------------------
// Peripheral DAC1: Digital-to-analog converter
//------------------------------------------------------------------------------

registers ©DAC1 @at 0x40007400 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    1
    CEN2 // at 30: DAC Channel 2 calibration enable
    DMAUDRIE2 // at 29: DAC channel2 DMA underrun interrupt enable
    DMAEN2 // at 28: DAC channel2 DMA enable
    MAMP2:4 // at 24: DAC channel2 mask/amplitude selector
    WAVE2:2 // at 22: DAC channel2 noise/triangle wave generation enable
    TSEL2:3 // at 19: DAC channel2 trigger selection
    TEN2 // at 18: DAC channel2 trigger enable
    1
    EN2 // at 16: DAC channel2 enable
    1
    CEN1 // at 14: DAC Channel 1 calibration enable
    DMAUDRIE1 // at 13: DAC channel1 DMA Underrun Interrupt enable
    DMAEN1 // at 12: DAC channel1 DMA enable
    MAMP1:4 // at 8: DAC channel1 mask/amplitude selector
    WAVE1:2 // at 6: DAC channel1 noise/triangle wave generation enable
    TSEL1:3 // at 3: DAC channel1 trigger selection
    TEN1 // at 2: DAC channel1 trigger enable
    1
    EN1 // at 0: DAC channel1 enable
  }

//---  Register SWTRIGR: software trigger register
  SWTRIGR @offset 0x4 $u32 {
    30
    SWTRIG2 // at 1: DAC channel2 software trigger
    SWTRIG1 // at 0: DAC channel1 software trigger
  }

//---  Register DHR12R1: channel1 12-bit right-aligned data holding           register
  DHR12R1 @offset 0x8 $u32 {
    20
    DACC1DHR:12 // at 0: DAC channel1 12-bit right-aligned data
  }

//---  Register DHR12L1: channel1 12-bit left-aligned data holding           register
  DHR12L1 @offset 0xc $u32 {
    16
    DACC1DHR:12 // at 4: DAC channel1 12-bit left-aligned data
    4
  }

//---  Register DHR8R1: channel1 8-bit right-aligned data holding           register
  DHR8R1 @offset 0x10 $u32 {
    24
    DACC1DHR:8 // at 0: DAC channel1 8-bit right-aligned data
  }

//---  Register DHR12R2: channel2 12-bit right aligned data holding           register
  DHR12R2 @offset 0x14 $u32 {
    20
    DACC2DHR:12 // at 0: DAC channel2 12-bit right-aligned data
  }

//---  Register DHR12L2: channel2 12-bit left aligned data holding           register
  DHR12L2 @offset 0x18 $u32 {
    16
    DACC2DHR:12 // at 4: DAC channel2 12-bit left-aligned data
    4
  }

//---  Register DHR8R2: channel2 8-bit right-aligned data holding           register
  DHR8R2 @offset 0x1c $u32 {
    24
    DACC2DHR:8 // at 0: DAC channel2 8-bit right-aligned data
  }

//---  Register DHR12RD: Dual DAC 12-bit right-aligned data holding           register
  DHR12RD @offset 0x20 $u32 {
    4
    DACC2DHR:12 // at 16: DAC channel2 12-bit right-aligned data
    4
    DACC1DHR:12 // at 0: DAC channel1 12-bit right-aligned data
  }

//---  Register DHR12LD: DUAL DAC 12-bit left aligned data holding           register
  DHR12LD @offset 0x24 $u32 {
    DACC2DHR:12 // at 20: DAC channel2 12-bit left-aligned data
    4
    DACC1DHR:12 // at 4: DAC channel1 12-bit left-aligned data
    4
  }

//---  Register DHR8RD: DUAL DAC 8-bit right aligned data holding           register
  DHR8RD @offset 0x28 $u32 {
    16
    DACC2DHR:8 // at 8: DAC channel2 8-bit right-aligned data
    DACC1DHR:8 // at 0: DAC channel1 8-bit right-aligned data
  }

//---  Register DOR1: channel1 data output register
  DOR1 @offset 0x2c @ro $u32 {
    20
    DACC1DOR:12 // at 0: DAC channel1 data output
  }

//---  Register DOR2: channel2 data output register
  DOR2 @offset 0x30 @ro $u32 {
    20
    DACC2DOR:12 // at 0: DAC channel2 data output
  }

//---  Register SR: status register
  SR @offset 0x34 $u32 {
    BWST2 // at 31: DAC Channel 2 busy writing sample time flag
    CAL_FLAG2 // at 30: DAC Channel 2 calibration offset status
    DMAUDR2 // at 29: DAC channel2 DMA underrun flag
    13
    BWST1 // at 15: DAC Channel 1 busy writing sample time flag
    CAL_FLAG1 // at 14: DAC Channel 1 calibration offset status
    DMAUDR1 // at 13: DAC channel1 DMA underrun flag
    13
  }

//---  Register CCR: calibration control register
  CCR @offset 0x38 $u32 {
    11
    OTRIM2:5 // at 16: DAC Channel 2 offset trimming value
    11
    OTRIM1:5 // at 0: DAC Channel 1 offset trimming value
  }

//---  Register MCR: mode control register
  MCR @offset 0x3c $u32 {
    13
    MODE2:3 // at 16: DAC Channel 2 mode
    13
    MODE1:3 // at 0: DAC Channel 1 mode
  }

//---  Register SHSR1: Sample and Hold sample time register           1
  SHSR1 @offset 0x40 $u32 {
    22
    TSAMPLE1:10 // at 0: DAC Channel 1 sample Time
  }

//---  Register SHSR2: Sample and Hold sample time register           2
  SHSR2 @offset 0x44 $u32 {
    22
    TSAMPLE2:10 // at 0: DAC Channel 2 sample Time
  }

//---  Register SHHR: Sample and Hold hold time           register
  SHHR @offset 0x48 $u32 {
    6
    THOLD2:10 // at 16: DAC Channel 2 hold time
    6
    THOLD1:10 // at 0: DAC Channel 1 hold Time
  }

//---  Register SHRR: Sample and Hold refresh time           register
  SHRR @offset 0x4c $u32 {
    8
    TREFRESH2:8 // at 16: DAC Channel 2 refresh Time
    8
    TREFRESH1:8 // at 0: DAC Channel 1 refresh Time
  }

}

//------------------------------------------------------------------------------
// Peripheral DBGMCU: MCU debug component
//------------------------------------------------------------------------------

registers ©DBGMCU @at 0xe0042000 {
//---  Register IDCODE: DBGMCU_IDCODE
  IDCODE @offset 0x0 @ro $u32 {
    REV_ID:16 // at 16: Revision identifie
    4
    DEV_ID:12 // at 0: Device identifier
  }

//---  Register CR: Debug MCU configuration           register
  CR @offset 0x4 $u32 {
    24
    TRACE_MODE:2 // at 6: Trace pin assignment control
    TRACE_IOEN // at 5: Trace pin assignment control
    2
    DBG_STANDBY // at 2: Debug Standby mode
    DBG_STOP // at 1: Debug Stop mode
    DBG_SLEEP // at 0: Debug Sleep mode
  }

//---  Register APB1FZR1: Debug MCU APB1 freeze           register1
  APB1FZR1 @offset 0x8 $u32 {
    DBG_LPTIM1_STOP // at 31: LPTIM1 counter stopped when core is halted
    5
    DBG_CAN_STOP // at 25: bxCAN stopped when core is halted
    1
    DBG_I2C3_STOP // at 23: I2C3 SMBUS timeout counter stopped when core is halted
    DBG_I2C2_STOP // at 22: I2C2 SMBUS timeout counter stopped when core is halted
    DBG_I2C1_STOP // at 21: I2C1 SMBUS timeout counter stopped when core is halted
    8
    DBG_IWDG_STOP // at 12: Independent watchdog counter stopped when core is halted
    DBG_WWDG_STOP // at 11: Window watchdog counter stopped when core is halted
    DBG_RTC_STOP // at 10: RTC counter stopped when core is halted
    4
    DBG_TIM7_STOP // at 5: TIM7 counter stopped when core is halted
    DBG_TIM6_STOP // at 4: TIM6 counter stopped when core is halted
    3
    DBG_TIM2_STOP // at 0: TIM2 counter stopped when core is halted
  }

//---  Register APB1FZR2: Debug MCU APB1 freeze register           2
  APB1FZR2 @offset 0xc $u32 {
    26
    DBG_LPTIM2_STOP // at 5: LPTIM2 counter stopped when core is halted
    5
  }

//---  Register APB2FZR: Debug MCU APB2 freeze register
  APB2FZR @offset 0x10 $u32 {
    14
    DBG_TIM16_STOP // at 17: TIM16 counter stopped when core is halted
    DBG_TIM15_STOP // at 16: TIM15 counter stopped when core is halted
    4
    DBG_TIM1_STOP // at 11: TIM1 counter stopped when core is halted
    11
  }

}

//------------------------------------------------------------------------------
// Peripheral DFSDM: Digital filter for sigma delta       modulators
//------------------------------------------------------------------------------

registers ©DFSDM @at 0x40016000 {
//---  Register CHCFG0R1: channel configuration y           register
  CHCFG0R1 @offset 0x0 $u32 {
    DFSDMEN // at 31: DFSDMEN
    CKOUTSRC // at 30: CKOUTSRC
    6
    CKOUTDIV:8 // at 16: CKOUTDIV
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG0R2: channel configuration y           register
  CHCFG0R2 @offset 0x4 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD0R: analog watchdog and short-circuit detector           register
  AWSCD0R @offset 0x8 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT0R: channel watchdog filter data           register
  CHWDAT0R @offset 0xc $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN0R: channel data input register
  CHDATIN0R @offset 0x10 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG1R1: CHCFG1R1
  CHCFG1R1 @offset 0x20 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG1R2: CHCFG1R2
  CHCFG1R2 @offset 0x24 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD1R: AWSCD1R
  AWSCD1R @offset 0x28 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT1R: CHWDAT1R
  CHWDAT1R @offset 0x2c $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN1R: CHDATIN1R
  CHDATIN1R @offset 0x30 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG2R1: CHCFG2R1
  CHCFG2R1 @offset 0x40 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG2R2: CHCFG2R2
  CHCFG2R2 @offset 0x44 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD2R: AWSCD2R
  AWSCD2R @offset 0x48 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT2R: CHWDAT2R
  CHWDAT2R @offset 0x4c $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN2R: CHDATIN2R
  CHDATIN2R @offset 0x50 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG3R1: CHCFG3R1
  CHCFG3R1 @offset 0x60 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG3R2: CHCFG3R2
  CHCFG3R2 @offset 0x64 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD3R: AWSCD3R
  AWSCD3R @offset 0x68 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT3R: CHWDAT3R
  CHWDAT3R @offset 0x6c $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN3R: CHDATIN3R
  CHDATIN3R @offset 0x70 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG4R1: CHCFG4R1
  CHCFG4R1 @offset 0x80 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG4R2: CHCFG4R2
  CHCFG4R2 @offset 0x84 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD4R: AWSCD4R
  AWSCD4R @offset 0x88 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT4R: CHWDAT4R
  CHWDAT4R @offset 0x8c $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN4R: CHDATIN4R
  CHDATIN4R @offset 0x90 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG5R1: CHCFG5R1
  CHCFG5R1 @offset 0xa0 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG5R2: CHCFG5R2
  CHCFG5R2 @offset 0xa4 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD5R: AWSCD5R
  AWSCD5R @offset 0xa8 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT5R: CHWDAT5R
  CHWDAT5R @offset 0xac $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN5R: CHDATIN5R
  CHDATIN5R @offset 0xb0 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG6R1: CHCFG6R1
  CHCFG6R1 @offset 0xc0 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG6R2: CHCFG6R2
  CHCFG6R2 @offset 0xc4 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD6R: AWSCD6R
  AWSCD6R @offset 0xc8 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT6R: CHWDAT6R
  CHWDAT6R @offset 0xcc $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN6R: CHDATIN6R
  CHDATIN6R @offset 0xd0 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register CHCFG7R1: CHCFG7R1
  CHCFG7R1 @offset 0xe0 $u32 {
    16
    DATPACK:2 // at 14: DATPACK
    DATMPX:2 // at 12: DATMPX
    3
    CHINSEL // at 8: CHINSEL
    CHEN // at 7: CHEN
    CKABEN // at 6: CKABEN
    SCDEN // at 5: SCDEN
    1
    SPICKSEL:2 // at 2: SPICKSEL
    SITP:2 // at 0: SITP
  }

//---  Register CHCFG7R2: CHCFG7R2
  CHCFG7R2 @offset 0xe4 $u32 {
    OFFSET:24 // at 8: OFFSET
    DTRBS:5 // at 3: DTRBS
    3
  }

//---  Register AWSCD7R: AWSCD7R
  AWSCD7R @offset 0xe8 $u32 {
    8
    AWFORD:2 // at 22: AWFORD
    1
    AWFOSR:5 // at 16: AWFOSR
    BKSCD:4 // at 12: BKSCD
    4
    SCDT:8 // at 0: SCDT
  }

//---  Register CHWDAT7R: CHWDAT7R
  CHWDAT7R @offset 0xec $u32 {
    16
    WDATA:16 // at 0: WDATA
  }

//---  Register CHDATIN7R: CHDATIN7R
  CHDATIN7R @offset 0xf0 $u32 {
    INDAT1:16 // at 16: INDAT1
    INDAT0:16 // at 0: INDAT0
  }

//---  Register DFSDM0_CR1: control register 1
  DFSDM0_CR1 @offset 0x100 $u32 {
    1
    AWFSEL // at 30: Analog watchdog fast mode select
    FAST // at 29: Fast conversion mode selection for regular conversions
    2
    RCH:3 // at 24: Regular channel selection
    2
    RDMAEN // at 21: DMA channel enabled to read data for the regular conversion
    1
    RSYNC // at 19: Launch regular conversion synchronously with DFSDM0
    RCONT // at 18: Continuous mode selection for regular conversions
    RSWSTART // at 17: Software start of a conversion on the regular channel
    2
    JEXTEN:2 // at 13: Trigger enable and trigger edge selection for injected conversions
    2
    JEXTSEL:3 // at 8: Trigger signal selection for launching injected conversions
    2
    JDMAEN // at 5: DMA channel enabled to read data for the injected channel group
    JSCAN // at 4: Scanning conversion mode for injected conversions
    JSYNC // at 3: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    1
    JSWSTART // at 1: Start a conversion of the injected group of channels
    DFEN // at 0: DFSDM enable
  }

//---  Register DFSDM0_CR2: control register 2
  DFSDM0_CR2 @offset 0x104 $u32 {
    8
    AWDCH:8 // at 16: Analog watchdog channel selection
    EXCH:8 // at 8: Extremes detector channel selection
    1
    CKABIE // at 6: Clock absence interrupt enable
    SCDIE // at 5: Short-circuit detector interrupt enable
    AWDIE // at 4: Analog watchdog interrupt enable
    ROVRIE // at 3: Regular data overrun interrupt enable
    JOVRIE // at 2: Injected data overrun interrupt enable
    REOCIE // at 1: Regular end of conversion interrupt enable
    JEOCIE // at 0: Injected end of conversion interrupt enable
  }

//---  Register DFSDM0_ISR: interrupt and status register
  DFSDM0_ISR @offset 0x108 @ro $u32 {
    SCDF:8 // at 24: short-circuit detector flag
    CKABF:8 // at 16: Clock absence flag
    1
    RCIP // at 14: Regular conversion in progress status
    JCIP // at 13: Injected conversion in progress status
    8
    AWDF // at 4: Analog watchdog
    ROVRF // at 3: Regular conversion overrun flag
    JOVRF // at 2: Injected conversion overrun flag
    REOCF // at 1: End of regular conversion flag
    JEOCF // at 0: End of injected conversion flag
  }

//---  Register DFSDM0_ICR: interrupt flag clear register
  DFSDM0_ICR @offset 0x10c $u32 {
    CLRSCDF:8 // at 24: Clear the short-circuit detector flag
    CLRCKABF:8 // at 16: Clear the clock absence flag
    12
    CLRROVRF // at 3: Clear the regular conversion overrun flag
    CLRJOVRF // at 2: Clear the injected conversion overrun flag
    2
  }

//---  Register DFSDM0_JCHGR: injected channel group selection           register
  DFSDM0_JCHGR @offset 0x110 $u32 {
    24
    JCHG:8 // at 0: Injected channel group selection
  }

//---  Register DFSDM0_FCR: filter control register
  DFSDM0_FCR @offset 0x114 $u32 {
    FORD:3 // at 29: Sinc filter order
    3
    FOSR:10 // at 16: Sinc filter oversampling ratio (decimation rate)
    8
    IOSR:8 // at 0: Integrator oversampling ratio (averaging length)
  }

//---  Register DFSDM0_JDATAR: data register for injected           group
  DFSDM0_JDATAR @offset 0x118 @ro $u32 {
    JDATA:24 // at 8: Injected group conversion data
    5
    JDATACH:3 // at 0: Injected channel most recently converted
  }

//---  Register DFSDM0_RDATAR: data register for the regular           channel
  DFSDM0_RDATAR @offset 0x11c @ro $u32 {
    RDATA:24 // at 8: Regular channel conversion data
    3
    RPEND // at 4: Regular channel pending data
    1
    RDATACH:3 // at 0: Regular channel most recently converted
  }

//---  Register DFSDM0_AWHTR: analog watchdog high threshold           register
  DFSDM0_AWHTR @offset 0x120 $u32 {
    AWHT:24 // at 8: Analog watchdog high threshold
    4
    BKAWH:4 // at 0: Break signal assignment to analog watchdog high threshold event
  }

//---  Register DFSDM0_AWLTR: analog watchdog low threshold           register
  DFSDM0_AWLTR @offset 0x124 $u32 {
    AWLT:24 // at 8: Analog watchdog low threshold
    4
    BKAWL:4 // at 0: Break signal assignment to analog watchdog low threshold event
  }

//---  Register DFSDM0_AWSR: analog watchdog status           register
  DFSDM0_AWSR @offset 0x128 @ro $u32 {
    16
    AWHTF:8 // at 8: Analog watchdog high threshold flag
    AWLTF:8 // at 0: Analog watchdog low threshold flag
  }

//---  Register DFSDM0_AWCFR: analog watchdog clear flag           register
  DFSDM0_AWCFR @offset 0x12c $u32 {
    16
    CLRAWHTF:8 // at 8: Clear the analog watchdog high threshold flag
    CLRAWLTF:8 // at 0: Clear the analog watchdog low threshold flag
  }

//---  Register DFSDM0_EXMAX: Extremes detector maximum           register
  DFSDM0_EXMAX @offset 0x130 @ro $u32 {
    EXMAX:24 // at 8: Extremes detector maximum value
    5
    EXMAXCH:3 // at 0: Extremes detector maximum data channel
  }

//---  Register DFSDM0_EXMIN: Extremes detector minimum           register
  DFSDM0_EXMIN @offset 0x134 @ro $u32 {
    EXMIN:24 // at 8: EXMIN
    5
    EXMINCH:3 // at 0: Extremes detector minimum data channel
  }

//---  Register DFSDM0_CNVTIMR: conversion timer register
  DFSDM0_CNVTIMR @offset 0x138 @ro $u32 {
    CNVCNT:28 // at 4: 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    4
  }

//---  Register DFSDM1_CR1: control register 1
  DFSDM1_CR1 @offset 0x200 $u32 {
    1
    AWFSEL // at 30: Analog watchdog fast mode select
    FAST // at 29: Fast conversion mode selection for regular conversions
    2
    RCH:3 // at 24: Regular channel selection
    2
    RDMAEN // at 21: DMA channel enabled to read data for the regular conversion
    1
    RSYNC // at 19: Launch regular conversion synchronously with DFSDM0
    RCONT // at 18: Continuous mode selection for regular conversions
    RSWSTART // at 17: Software start of a conversion on the regular channel
    2
    JEXTEN:2 // at 13: Trigger enable and trigger edge selection for injected conversions
    2
    JEXTSEL:3 // at 8: Trigger signal selection for launching injected conversions
    2
    JDMAEN // at 5: DMA channel enabled to read data for the injected channel group
    JSCAN // at 4: Scanning conversion mode for injected conversions
    JSYNC // at 3: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    1
    JSWSTART // at 1: Start a conversion of the injected group of channels
    DFEN // at 0: DFSDM enable
  }

//---  Register DFSDM1_CR2: control register 2
  DFSDM1_CR2 @offset 0x204 $u32 {
    8
    AWDCH:8 // at 16: Analog watchdog channel selection
    EXCH:8 // at 8: Extremes detector channel selection
    1
    CKABIE // at 6: Clock absence interrupt enable
    SCDIE // at 5: Short-circuit detector interrupt enable
    AWDIE // at 4: Analog watchdog interrupt enable
    ROVRIE // at 3: Regular data overrun interrupt enable
    JOVRIE // at 2: Injected data overrun interrupt enable
    REOCIE // at 1: Regular end of conversion interrupt enable
    JEOCIE // at 0: Injected end of conversion interrupt enable
  }

//---  Register DFSDM1_ISR: interrupt and status register
  DFSDM1_ISR @offset 0x208 @ro $u32 {
    SCDF:8 // at 24: short-circuit detector flag
    CKABF:8 // at 16: Clock absence flag
    1
    RCIP // at 14: Regular conversion in progress status
    JCIP // at 13: Injected conversion in progress status
    8
    AWDF // at 4: Analog watchdog
    ROVRF // at 3: Regular conversion overrun flag
    JOVRF // at 2: Injected conversion overrun flag
    REOCF // at 1: End of regular conversion flag
    JEOCF // at 0: End of injected conversion flag
  }

//---  Register DFSDM1_ICR: interrupt flag clear register
  DFSDM1_ICR @offset 0x20c $u32 {
    CLRSCDF:8 // at 24: Clear the short-circuit detector flag
    CLRCKABF:8 // at 16: Clear the clock absence flag
    12
    CLRROVRF // at 3: Clear the regular conversion overrun flag
    CLRJOVRF // at 2: Clear the injected conversion overrun flag
    2
  }

//---  Register DFSDM1_JCHGR: injected channel group selection           register
  DFSDM1_JCHGR @offset 0x210 $u32 {
    24
    JCHG:8 // at 0: Injected channel group selection
  }

//---  Register DFSDM1_FCR: filter control register
  DFSDM1_FCR @offset 0x214 $u32 {
    FORD:3 // at 29: Sinc filter order
    3
    FOSR:10 // at 16: Sinc filter oversampling ratio (decimation rate)
    8
    IOSR:8 // at 0: Integrator oversampling ratio (averaging length)
  }

//---  Register DFSDM1_JDATAR: data register for injected           group
  DFSDM1_JDATAR @offset 0x218 @ro $u32 {
    JDATA:24 // at 8: Injected group conversion data
    5
    JDATACH:3 // at 0: Injected channel most recently converted
  }

//---  Register DFSDM1_RDATAR: data register for the regular           channel
  DFSDM1_RDATAR @offset 0x21c @ro $u32 {
    RDATA:24 // at 8: Regular channel conversion data
    3
    RPEND // at 4: Regular channel pending data
    1
    RDATACH:3 // at 0: Regular channel most recently converted
  }

//---  Register DFSDM1_AWHTR: analog watchdog high threshold           register
  DFSDM1_AWHTR @offset 0x220 $u32 {
    AWHT:24 // at 8: Analog watchdog high threshold
    4
    BKAWH:4 // at 0: Break signal assignment to analog watchdog high threshold event
  }

//---  Register DFSDM1_AWLTR: analog watchdog low threshold           register
  DFSDM1_AWLTR @offset 0x224 $u32 {
    AWLT:24 // at 8: Analog watchdog low threshold
    4
    BKAWL:4 // at 0: Break signal assignment to analog watchdog low threshold event
  }

//---  Register DFSDM1_AWSR: analog watchdog status           register
  DFSDM1_AWSR @offset 0x228 @ro $u32 {
    16
    AWHTF:8 // at 8: Analog watchdog high threshold flag
    AWLTF:8 // at 0: Analog watchdog low threshold flag
  }

//---  Register DFSDM1_AWCFR: analog watchdog clear flag           register
  DFSDM1_AWCFR @offset 0x22c $u32 {
    16
    CLRAWHTF:8 // at 8: Clear the analog watchdog high threshold flag
    CLRAWLTF:8 // at 0: Clear the analog watchdog low threshold flag
  }

//---  Register DFSDM1_EXMAX: Extremes detector maximum           register
  DFSDM1_EXMAX @offset 0x230 @ro $u32 {
    EXMAX:24 // at 8: Extremes detector maximum value
    5
    EXMAXCH:3 // at 0: Extremes detector maximum data channel
  }

//---  Register DFSDM1_EXMIN: Extremes detector minimum           register
  DFSDM1_EXMIN @offset 0x234 @ro $u32 {
    EXMIN:24 // at 8: EXMIN
    5
    EXMINCH:3 // at 0: Extremes detector minimum data channel
  }

//---  Register DFSDM1_CNVTIMR: conversion timer register
  DFSDM1_CNVTIMR @offset 0x238 @ro $u32 {
    CNVCNT:28 // at 4: 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    4
  }

//---  Register DFSDM2_CR1: control register 1
  DFSDM2_CR1 @offset 0x300 $u32 {
    1
    AWFSEL // at 30: Analog watchdog fast mode select
    FAST // at 29: Fast conversion mode selection for regular conversions
    2
    RCH:3 // at 24: Regular channel selection
    2
    RDMAEN // at 21: DMA channel enabled to read data for the regular conversion
    1
    RSYNC // at 19: Launch regular conversion synchronously with DFSDM0
    RCONT // at 18: Continuous mode selection for regular conversions
    RSWSTART // at 17: Software start of a conversion on the regular channel
    2
    JEXTEN:2 // at 13: Trigger enable and trigger edge selection for injected conversions
    2
    JEXTSEL:3 // at 8: Trigger signal selection for launching injected conversions
    2
    JDMAEN // at 5: DMA channel enabled to read data for the injected channel group
    JSCAN // at 4: Scanning conversion mode for injected conversions
    JSYNC // at 3: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    1
    JSWSTART // at 1: Start a conversion of the injected group of channels
    DFEN // at 0: DFSDM enable
  }

//---  Register DFSDM2_CR2: control register 2
  DFSDM2_CR2 @offset 0x304 $u32 {
    8
    AWDCH:8 // at 16: Analog watchdog channel selection
    EXCH:8 // at 8: Extremes detector channel selection
    1
    CKABIE // at 6: Clock absence interrupt enable
    SCDIE // at 5: Short-circuit detector interrupt enable
    AWDIE // at 4: Analog watchdog interrupt enable
    ROVRIE // at 3: Regular data overrun interrupt enable
    JOVRIE // at 2: Injected data overrun interrupt enable
    REOCIE // at 1: Regular end of conversion interrupt enable
    JEOCIE // at 0: Injected end of conversion interrupt enable
  }

//---  Register DFSDM2_ISR: interrupt and status register
  DFSDM2_ISR @offset 0x308 @ro $u32 {
    SCDF:8 // at 24: short-circuit detector flag
    CKABF:8 // at 16: Clock absence flag
    1
    RCIP // at 14: Regular conversion in progress status
    JCIP // at 13: Injected conversion in progress status
    8
    AWDF // at 4: Analog watchdog
    ROVRF // at 3: Regular conversion overrun flag
    JOVRF // at 2: Injected conversion overrun flag
    REOCF // at 1: End of regular conversion flag
    JEOCF // at 0: End of injected conversion flag
  }

//---  Register DFSDM2_ICR: interrupt flag clear register
  DFSDM2_ICR @offset 0x30c $u32 {
    CLRSCDF:8 // at 24: Clear the short-circuit detector flag
    CLRCKABF:8 // at 16: Clear the clock absence flag
    12
    CLRROVRF // at 3: Clear the regular conversion overrun flag
    CLRJOVRF // at 2: Clear the injected conversion overrun flag
    2
  }

//---  Register DFSDM2_JCHGR: injected channel group selection           register
  DFSDM2_JCHGR @offset 0x310 $u32 {
    24
    JCHG:8 // at 0: Injected channel group selection
  }

//---  Register DFSDM2_FCR: filter control register
  DFSDM2_FCR @offset 0x314 $u32 {
    FORD:3 // at 29: Sinc filter order
    3
    FOSR:10 // at 16: Sinc filter oversampling ratio (decimation rate)
    8
    IOSR:8 // at 0: Integrator oversampling ratio (averaging length)
  }

//---  Register DFSDM2_JDATAR: data register for injected           group
  DFSDM2_JDATAR @offset 0x318 @ro $u32 {
    JDATA:24 // at 8: Injected group conversion data
    5
    JDATACH:3 // at 0: Injected channel most recently converted
  }

//---  Register DFSDM2_RDATAR: data register for the regular           channel
  DFSDM2_RDATAR @offset 0x31c @ro $u32 {
    RDATA:24 // at 8: Regular channel conversion data
    3
    RPEND // at 4: Regular channel pending data
    1
    RDATACH:3 // at 0: Regular channel most recently converted
  }

//---  Register DFSDM2_AWHTR: analog watchdog high threshold           register
  DFSDM2_AWHTR @offset 0x320 $u32 {
    AWHT:24 // at 8: Analog watchdog high threshold
    4
    BKAWH:4 // at 0: Break signal assignment to analog watchdog high threshold event
  }

//---  Register DFSDM2_AWLTR: analog watchdog low threshold           register
  DFSDM2_AWLTR @offset 0x324 $u32 {
    AWLT:24 // at 8: Analog watchdog low threshold
    4
    BKAWL:4 // at 0: Break signal assignment to analog watchdog low threshold event
  }

//---  Register DFSDM2_AWSR: analog watchdog status           register
  DFSDM2_AWSR @offset 0x328 @ro $u32 {
    16
    AWHTF:8 // at 8: Analog watchdog high threshold flag
    AWLTF:8 // at 0: Analog watchdog low threshold flag
  }

//---  Register DFSDM2_AWCFR: analog watchdog clear flag           register
  DFSDM2_AWCFR @offset 0x32c $u32 {
    16
    CLRAWHTF:8 // at 8: Clear the analog watchdog high threshold flag
    CLRAWLTF:8 // at 0: Clear the analog watchdog low threshold flag
  }

//---  Register DFSDM2_EXMAX: Extremes detector maximum           register
  DFSDM2_EXMAX @offset 0x330 @ro $u32 {
    EXMAX:24 // at 8: Extremes detector maximum value
    5
    EXMAXCH:3 // at 0: Extremes detector maximum data channel
  }

//---  Register DFSDM2_EXMIN: Extremes detector minimum           register
  DFSDM2_EXMIN @offset 0x334 @ro $u32 {
    EXMIN:24 // at 8: EXMIN
    5
    EXMINCH:3 // at 0: Extremes detector minimum data channel
  }

//---  Register DFSDM2_CNVTIMR: conversion timer register
  DFSDM2_CNVTIMR @offset 0x338 @ro $u32 {
    CNVCNT:28 // at 4: 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    4
  }

//---  Register DFSDM3_CR1: control register 1
  DFSDM3_CR1 @offset 0x400 $u32 {
    1
    AWFSEL // at 30: Analog watchdog fast mode select
    FAST // at 29: Fast conversion mode selection for regular conversions
    2
    RCH:3 // at 24: Regular channel selection
    2
    RDMAEN // at 21: DMA channel enabled to read data for the regular conversion
    1
    RSYNC // at 19: Launch regular conversion synchronously with DFSDM0
    RCONT // at 18: Continuous mode selection for regular conversions
    RSWSTART // at 17: Software start of a conversion on the regular channel
    2
    JEXTEN:2 // at 13: Trigger enable and trigger edge selection for injected conversions
    2
    JEXTSEL:3 // at 8: Trigger signal selection for launching injected conversions
    2
    JDMAEN // at 5: DMA channel enabled to read data for the injected channel group
    JSCAN // at 4: Scanning conversion mode for injected conversions
    JSYNC // at 3: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    1
    JSWSTART // at 1: Start a conversion of the injected group of channels
    DFEN // at 0: DFSDM enable
  }

//---  Register DFSDM3_CR2: control register 2
  DFSDM3_CR2 @offset 0x404 $u32 {
    8
    AWDCH:8 // at 16: Analog watchdog channel selection
    EXCH:8 // at 8: Extremes detector channel selection
    1
    CKABIE // at 6: Clock absence interrupt enable
    SCDIE // at 5: Short-circuit detector interrupt enable
    AWDIE // at 4: Analog watchdog interrupt enable
    ROVRIE // at 3: Regular data overrun interrupt enable
    JOVRIE // at 2: Injected data overrun interrupt enable
    REOCIE // at 1: Regular end of conversion interrupt enable
    JEOCIE // at 0: Injected end of conversion interrupt enable
  }

//---  Register DFSDM3_ISR: interrupt and status register
  DFSDM3_ISR @offset 0x408 @ro $u32 {
    SCDF:8 // at 24: short-circuit detector flag
    CKABF:8 // at 16: Clock absence flag
    1
    RCIP // at 14: Regular conversion in progress status
    JCIP // at 13: Injected conversion in progress status
    8
    AWDF // at 4: Analog watchdog
    ROVRF // at 3: Regular conversion overrun flag
    JOVRF // at 2: Injected conversion overrun flag
    REOCF // at 1: End of regular conversion flag
    JEOCF // at 0: End of injected conversion flag
  }

//---  Register DFSDM3_ICR: interrupt flag clear register
  DFSDM3_ICR @offset 0x40c $u32 {
    CLRSCDF:8 // at 24: Clear the short-circuit detector flag
    CLRCKABF:8 // at 16: Clear the clock absence flag
    12
    CLRROVRF // at 3: Clear the regular conversion overrun flag
    CLRJOVRF // at 2: Clear the injected conversion overrun flag
    2
  }

//---  Register DFSDM3_JCHGR: injected channel group selection           register
  DFSDM3_JCHGR @offset 0x410 $u32 {
    24
    JCHG:8 // at 0: Injected channel group selection
  }

//---  Register DFSDM3_FCR: filter control register
  DFSDM3_FCR @offset 0x414 $u32 {
    FORD:3 // at 29: Sinc filter order
    3
    FOSR:10 // at 16: Sinc filter oversampling ratio (decimation rate)
    8
    IOSR:8 // at 0: Integrator oversampling ratio (averaging length)
  }

//---  Register DFSDM3_JDATAR: data register for injected           group
  DFSDM3_JDATAR @offset 0x418 @ro $u32 {
    JDATA:24 // at 8: Injected group conversion data
    5
    JDATACH:3 // at 0: Injected channel most recently converted
  }

//---  Register DFSDM3_RDATAR: data register for the regular           channel
  DFSDM3_RDATAR @offset 0x41c @ro $u32 {
    RDATA:24 // at 8: Regular channel conversion data
    3
    RPEND // at 4: Regular channel pending data
    1
    RDATACH:3 // at 0: Regular channel most recently converted
  }

//---  Register DFSDM3_AWHTR: analog watchdog high threshold           register
  DFSDM3_AWHTR @offset 0x420 $u32 {
    AWHT:24 // at 8: Analog watchdog high threshold
    4
    BKAWH:4 // at 0: Break signal assignment to analog watchdog high threshold event
  }

//---  Register DFSDM3_AWLTR: analog watchdog low threshold           register
  DFSDM3_AWLTR @offset 0x424 $u32 {
    AWLT:24 // at 8: Analog watchdog low threshold
    4
    BKAWL:4 // at 0: Break signal assignment to analog watchdog low threshold event
  }

//---  Register DFSDM3_AWSR: analog watchdog status           register
  DFSDM3_AWSR @offset 0x428 @ro $u32 {
    16
    AWHTF:8 // at 8: Analog watchdog high threshold flag
    AWLTF:8 // at 0: Analog watchdog low threshold flag
  }

//---  Register DFSDM3_AWCFR: analog watchdog clear flag           register
  DFSDM3_AWCFR @offset 0x42c $u32 {
    16
    CLRAWHTF:8 // at 8: Clear the analog watchdog high threshold flag
    CLRAWLTF:8 // at 0: Clear the analog watchdog low threshold flag
  }

//---  Register DFSDM3_EXMAX: Extremes detector maximum           register
  DFSDM3_EXMAX @offset 0x430 @ro $u32 {
    EXMAX:24 // at 8: Extremes detector maximum value
    5
    EXMAXCH:3 // at 0: Extremes detector maximum data channel
  }

//---  Register DFSDM3_EXMIN: Extremes detector minimum           register
  DFSDM3_EXMIN @offset 0x434 @ro $u32 {
    EXMIN:24 // at 8: EXMIN
    5
    EXMINCH:3 // at 0: Extremes detector minimum data channel
  }

//---  Register DFSDM3_CNVTIMR: conversion timer register
  DFSDM3_CNVTIMR @offset 0x438 @ro $u32 {
    CNVCNT:28 // at 4: 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN
    4
  }

}

//------------------------------------------------------------------------------
// Peripheral DMA1: Direct memory access controller
//------------------------------------------------------------------------------

registers ©DMA1 @at 0x40020000 {
//---  Register ISR: interrupt status register
  ISR @offset 0x0 @ro $u32 {
    4
    TEIF7 // at 27: Channel x transfer error flag (x = 1 ..7)
    HTIF7 // at 26: Channel x half transfer flag (x = 1 ..7)
    TCIF7 // at 25: Channel x transfer complete flag (x = 1 ..7)
    GIF7 // at 24: Channel x global interrupt flag (x = 1 ..7)
    TEIF6 // at 23: Channel x transfer error flag (x = 1 ..7)
    HTIF6 // at 22: Channel x half transfer flag (x = 1 ..7)
    TCIF6 // at 21: Channel x transfer complete flag (x = 1 ..7)
    GIF6 // at 20: Channel x global interrupt flag (x = 1 ..7)
    TEIF5 // at 19: Channel x transfer error flag (x = 1 ..7)
    HTIF5 // at 18: Channel x half transfer flag (x = 1 ..7)
    TCIF5 // at 17: Channel x transfer complete flag (x = 1 ..7)
    GIF5 // at 16: Channel x global interrupt flag (x = 1 ..7)
    TEIF4 // at 15: Channel x transfer error flag (x = 1 ..7)
    HTIF4 // at 14: Channel x half transfer flag (x = 1 ..7)
    TCIF4 // at 13: Channel x transfer complete flag (x = 1 ..7)
    GIF4 // at 12: Channel x global interrupt flag (x = 1 ..7)
    TEIF3 // at 11: Channel x transfer error flag (x = 1 ..7)
    HTIF3 // at 10: Channel x half transfer flag (x = 1 ..7)
    TCIF3 // at 9: Channel x transfer complete flag (x = 1 ..7)
    GIF3 // at 8: Channel x global interrupt flag (x = 1 ..7)
    TEIF2 // at 7: Channel x transfer error flag (x = 1 ..7)
    HTIF2 // at 6: Channel x half transfer flag (x = 1 ..7)
    TCIF2 // at 5: Channel x transfer complete flag (x = 1 ..7)
    GIF2 // at 4: Channel x global interrupt flag (x = 1 ..7)
    TEIF1 // at 3: Channel x transfer error flag (x = 1 ..7)
    HTIF1 // at 2: Channel x half transfer flag (x = 1 ..7)
    TCIF1 // at 1: Channel x transfer complete flag (x = 1 ..7)
    GIF1 // at 0: Channel x global interrupt flag (x = 1 ..7)
  }

//---  Register IFCR: interrupt flag clear register
  IFCR @offset 0x4 $u32 {
    4
    CTEIF7 // at 27: Channel x transfer error clear (x = 1 ..7)
    CHTIF7 // at 26: Channel x half transfer clear (x = 1 ..7)
    CTCIF7 // at 25: Channel x transfer complete clear (x = 1 ..7)
    CGIF7 // at 24: Channel x global interrupt clear (x = 1 ..7)
    CTEIF6 // at 23: Channel x transfer error clear (x = 1 ..7)
    CHTIF6 // at 22: Channel x half transfer clear (x = 1 ..7)
    CTCIF6 // at 21: Channel x transfer complete clear (x = 1 ..7)
    CGIF6 // at 20: Channel x global interrupt clear (x = 1 ..7)
    CTEIF5 // at 19: Channel x transfer error clear (x = 1 ..7)
    CHTIF5 // at 18: Channel x half transfer clear (x = 1 ..7)
    CTCIF5 // at 17: Channel x transfer complete clear (x = 1 ..7)
    CGIF5 // at 16: Channel x global interrupt clear (x = 1 ..7)
    CTEIF4 // at 15: Channel x transfer error clear (x = 1 ..7)
    CHTIF4 // at 14: Channel x half transfer clear (x = 1 ..7)
    CTCIF4 // at 13: Channel x transfer complete clear (x = 1 ..7)
    CGIF4 // at 12: Channel x global interrupt clear (x = 1 ..7)
    CTEIF3 // at 11: Channel x transfer error clear (x = 1 ..7)
    CHTIF3 // at 10: Channel x half transfer clear (x = 1 ..7)
    CTCIF3 // at 9: Channel x transfer complete clear (x = 1 ..7)
    CGIF3 // at 8: Channel x global interrupt clear (x = 1 ..7)
    CTEIF2 // at 7: Channel x transfer error clear (x = 1 ..7)
    CHTIF2 // at 6: Channel x half transfer clear (x = 1 ..7)
    CTCIF2 // at 5: Channel x transfer complete clear (x = 1 ..7)
    CGIF2 // at 4: Channel x global interrupt clear (x = 1 ..7)
    CTEIF1 // at 3: Channel x transfer error clear (x = 1 ..7)
    CHTIF1 // at 2: Channel x half transfer clear (x = 1 ..7)
    CTCIF1 // at 1: Channel x transfer complete clear (x = 1 ..7)
    CGIF1 // at 0: Channel x global interrupt clear (x = 1 ..7)
  }

//---  Register CCR1: channel x configuration           register
  CCR1 @offset 0x8 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR1: channel x number of data           register
  CNDTR1 @offset 0xc $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR1: channel x peripheral address           register
  CPAR1 @offset 0x10 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR1: channel x memory address           register
  CMAR1 @offset 0x14 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR2: channel x configuration           register
  CCR2 @offset 0x1c $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR2: channel x number of data           register
  CNDTR2 @offset 0x20 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR2: channel x peripheral address           register
  CPAR2 @offset 0x24 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR2: channel x memory address           register
  CMAR2 @offset 0x28 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR3: channel x configuration           register
  CCR3 @offset 0x30 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR3: channel x number of data           register
  CNDTR3 @offset 0x34 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR3: channel x peripheral address           register
  CPAR3 @offset 0x38 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR3: channel x memory address           register
  CMAR3 @offset 0x3c $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR4: channel x configuration           register
  CCR4 @offset 0x44 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR4: channel x number of data           register
  CNDTR4 @offset 0x48 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR4: channel x peripheral address           register
  CPAR4 @offset 0x4c $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR4: channel x memory address           register
  CMAR4 @offset 0x50 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR5: channel x configuration           register
  CCR5 @offset 0x58 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR5: channel x number of data           register
  CNDTR5 @offset 0x5c $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR5: channel x peripheral address           register
  CPAR5 @offset 0x60 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR5: channel x memory address           register
  CMAR5 @offset 0x64 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR6: channel x configuration           register
  CCR6 @offset 0x6c $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR6: channel x number of data           register
  CNDTR6 @offset 0x70 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR6: channel x peripheral address           register
  CPAR6 @offset 0x74 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR6: channel x memory address           register
  CMAR6 @offset 0x78 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR7: channel x configuration           register
  CCR7 @offset 0x80 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR7: channel x number of data           register
  CNDTR7 @offset 0x84 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR7: channel x peripheral address           register
  CPAR7 @offset 0x88 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR7: channel x memory address           register
  CMAR7 @offset 0x8c $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CSELR: channel selection register
  CSELR @offset 0xa8 $u32 {
    4
    C7S:4 // at 24: DMA channel 7 selection
    C6S:4 // at 20: DMA channel 6 selection
    C5S:4 // at 16: DMA channel 5 selection
    C4S:4 // at 12: DMA channel 4 selection
    C3S:4 // at 8: DMA channel 3 selection
    C2S:4 // at 4: DMA channel 2 selection
    C1S:4 // at 0: DMA channel 1 selection
  }

}

//------------------------------------------------------------------------------
// Peripheral DMA2
//------------------------------------------------------------------------------

registers ©DMA2 @at 0x40020400 {
//---  Register ISR: interrupt status register
  ISR @offset 0x0 @ro $u32 {
    4
    TEIF7 // at 27: Channel x transfer error flag (x = 1 ..7)
    HTIF7 // at 26: Channel x half transfer flag (x = 1 ..7)
    TCIF7 // at 25: Channel x transfer complete flag (x = 1 ..7)
    GIF7 // at 24: Channel x global interrupt flag (x = 1 ..7)
    TEIF6 // at 23: Channel x transfer error flag (x = 1 ..7)
    HTIF6 // at 22: Channel x half transfer flag (x = 1 ..7)
    TCIF6 // at 21: Channel x transfer complete flag (x = 1 ..7)
    GIF6 // at 20: Channel x global interrupt flag (x = 1 ..7)
    TEIF5 // at 19: Channel x transfer error flag (x = 1 ..7)
    HTIF5 // at 18: Channel x half transfer flag (x = 1 ..7)
    TCIF5 // at 17: Channel x transfer complete flag (x = 1 ..7)
    GIF5 // at 16: Channel x global interrupt flag (x = 1 ..7)
    TEIF4 // at 15: Channel x transfer error flag (x = 1 ..7)
    HTIF4 // at 14: Channel x half transfer flag (x = 1 ..7)
    TCIF4 // at 13: Channel x transfer complete flag (x = 1 ..7)
    GIF4 // at 12: Channel x global interrupt flag (x = 1 ..7)
    TEIF3 // at 11: Channel x transfer error flag (x = 1 ..7)
    HTIF3 // at 10: Channel x half transfer flag (x = 1 ..7)
    TCIF3 // at 9: Channel x transfer complete flag (x = 1 ..7)
    GIF3 // at 8: Channel x global interrupt flag (x = 1 ..7)
    TEIF2 // at 7: Channel x transfer error flag (x = 1 ..7)
    HTIF2 // at 6: Channel x half transfer flag (x = 1 ..7)
    TCIF2 // at 5: Channel x transfer complete flag (x = 1 ..7)
    GIF2 // at 4: Channel x global interrupt flag (x = 1 ..7)
    TEIF1 // at 3: Channel x transfer error flag (x = 1 ..7)
    HTIF1 // at 2: Channel x half transfer flag (x = 1 ..7)
    TCIF1 // at 1: Channel x transfer complete flag (x = 1 ..7)
    GIF1 // at 0: Channel x global interrupt flag (x = 1 ..7)
  }

//---  Register IFCR: interrupt flag clear register
  IFCR @offset 0x4 $u32 {
    4
    CTEIF7 // at 27: Channel x transfer error clear (x = 1 ..7)
    CHTIF7 // at 26: Channel x half transfer clear (x = 1 ..7)
    CTCIF7 // at 25: Channel x transfer complete clear (x = 1 ..7)
    CGIF7 // at 24: Channel x global interrupt clear (x = 1 ..7)
    CTEIF6 // at 23: Channel x transfer error clear (x = 1 ..7)
    CHTIF6 // at 22: Channel x half transfer clear (x = 1 ..7)
    CTCIF6 // at 21: Channel x transfer complete clear (x = 1 ..7)
    CGIF6 // at 20: Channel x global interrupt clear (x = 1 ..7)
    CTEIF5 // at 19: Channel x transfer error clear (x = 1 ..7)
    CHTIF5 // at 18: Channel x half transfer clear (x = 1 ..7)
    CTCIF5 // at 17: Channel x transfer complete clear (x = 1 ..7)
    CGIF5 // at 16: Channel x global interrupt clear (x = 1 ..7)
    CTEIF4 // at 15: Channel x transfer error clear (x = 1 ..7)
    CHTIF4 // at 14: Channel x half transfer clear (x = 1 ..7)
    CTCIF4 // at 13: Channel x transfer complete clear (x = 1 ..7)
    CGIF4 // at 12: Channel x global interrupt clear (x = 1 ..7)
    CTEIF3 // at 11: Channel x transfer error clear (x = 1 ..7)
    CHTIF3 // at 10: Channel x half transfer clear (x = 1 ..7)
    CTCIF3 // at 9: Channel x transfer complete clear (x = 1 ..7)
    CGIF3 // at 8: Channel x global interrupt clear (x = 1 ..7)
    CTEIF2 // at 7: Channel x transfer error clear (x = 1 ..7)
    CHTIF2 // at 6: Channel x half transfer clear (x = 1 ..7)
    CTCIF2 // at 5: Channel x transfer complete clear (x = 1 ..7)
    CGIF2 // at 4: Channel x global interrupt clear (x = 1 ..7)
    CTEIF1 // at 3: Channel x transfer error clear (x = 1 ..7)
    CHTIF1 // at 2: Channel x half transfer clear (x = 1 ..7)
    CTCIF1 // at 1: Channel x transfer complete clear (x = 1 ..7)
    CGIF1 // at 0: Channel x global interrupt clear (x = 1 ..7)
  }

//---  Register CCR1: channel x configuration           register
  CCR1 @offset 0x8 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR1: channel x number of data           register
  CNDTR1 @offset 0xc $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR1: channel x peripheral address           register
  CPAR1 @offset 0x10 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR1: channel x memory address           register
  CMAR1 @offset 0x14 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR2: channel x configuration           register
  CCR2 @offset 0x1c $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR2: channel x number of data           register
  CNDTR2 @offset 0x20 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR2: channel x peripheral address           register
  CPAR2 @offset 0x24 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR2: channel x memory address           register
  CMAR2 @offset 0x28 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR3: channel x configuration           register
  CCR3 @offset 0x30 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR3: channel x number of data           register
  CNDTR3 @offset 0x34 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR3: channel x peripheral address           register
  CPAR3 @offset 0x38 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR3: channel x memory address           register
  CMAR3 @offset 0x3c $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR4: channel x configuration           register
  CCR4 @offset 0x44 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR4: channel x number of data           register
  CNDTR4 @offset 0x48 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR4: channel x peripheral address           register
  CPAR4 @offset 0x4c $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR4: channel x memory address           register
  CMAR4 @offset 0x50 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR5: channel x configuration           register
  CCR5 @offset 0x58 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR5: channel x number of data           register
  CNDTR5 @offset 0x5c $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR5: channel x peripheral address           register
  CPAR5 @offset 0x60 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR5: channel x memory address           register
  CMAR5 @offset 0x64 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR6: channel x configuration           register
  CCR6 @offset 0x6c $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR6: channel x number of data           register
  CNDTR6 @offset 0x70 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR6: channel x peripheral address           register
  CPAR6 @offset 0x74 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR6: channel x memory address           register
  CMAR6 @offset 0x78 $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CCR7: channel x configuration           register
  CCR7 @offset 0x80 $u32 {
    17
    MEM2MEM // at 14: Memory to memory mode
    PL:2 // at 12: Channel priority level
    MSIZE:2 // at 10: Memory size
    PSIZE:2 // at 8: Peripheral size
    MINC // at 7: Memory increment mode
    PINC // at 6: Peripheral increment mode
    CIRC // at 5: Circular mode
    DIR // at 4: Data transfer direction
    TEIE // at 3: Transfer error interrupt enable
    HTIE // at 2: Half transfer interrupt enable
    TCIE // at 1: Transfer complete interrupt enable
    EN // at 0: Channel enable
  }

//---  Register CNDTR7: channel x number of data           register
  CNDTR7 @offset 0x84 $u32 {
    16
    NDT:16 // at 0: Number of data to transfer
  }

//---  Register CPAR7: channel x peripheral address           register
  CPAR7 @offset 0x88 $u32 {
    PA:32 // at 0: Peripheral address
  }

//---  Register CMAR7: channel x memory address           register
  CMAR7 @offset 0x8c $u32 {
    MA:32 // at 0: Memory address
  }

//---  Register CSELR: channel selection register
  CSELR @offset 0xa8 $u32 {
    4
    C7S:4 // at 24: DMA channel 7 selection
    C6S:4 // at 20: DMA channel 6 selection
    C5S:4 // at 16: DMA channel 5 selection
    C4S:4 // at 12: DMA channel 4 selection
    C3S:4 // at 8: DMA channel 3 selection
    C2S:4 // at 4: DMA channel 2 selection
    C1S:4 // at 0: DMA channel 1 selection
  }

}

//------------------------------------------------------------------------------
// Peripheral EXTI: External interrupt/event       controller
//------------------------------------------------------------------------------

registers ©EXTI @at 0x40010400 {
//---  Register IMR1: Interrupt mask register
  IMR1 @offset 0x0 $u32 {
    MR31 // at 31: Interrupt Mask on line 31
    MR30 // at 30: Interrupt Mask on line 30
    MR29 // at 29: Interrupt Mask on line 29
    MR28 // at 28: Interrupt Mask on line 28
    MR27 // at 27: Interrupt Mask on line 27
    MR26 // at 26: Interrupt Mask on line 26
    MR25 // at 25: Interrupt Mask on line 25
    MR24 // at 24: Interrupt Mask on line 24
    MR23 // at 23: Interrupt Mask on line 23
    MR22 // at 22: Interrupt Mask on line 22
    MR21 // at 21: Interrupt Mask on line 21
    MR20 // at 20: Interrupt Mask on line 20
    MR19 // at 19: Interrupt Mask on line 19
    MR18 // at 18: Interrupt Mask on line 18
    MR17 // at 17: Interrupt Mask on line 17
    MR16 // at 16: Interrupt Mask on line 16
    MR15 // at 15: Interrupt Mask on line 15
    MR14 // at 14: Interrupt Mask on line 14
    MR13 // at 13: Interrupt Mask on line 13
    MR12 // at 12: Interrupt Mask on line 12
    MR11 // at 11: Interrupt Mask on line 11
    MR10 // at 10: Interrupt Mask on line 10
    MR9 // at 9: Interrupt Mask on line 9
    MR8 // at 8: Interrupt Mask on line 8
    MR7 // at 7: Interrupt Mask on line 7
    MR6 // at 6: Interrupt Mask on line 6
    MR5 // at 5: Interrupt Mask on line 5
    MR4 // at 4: Interrupt Mask on line 4
    MR3 // at 3: Interrupt Mask on line 3
    MR2 // at 2: Interrupt Mask on line 2
    MR1 // at 1: Interrupt Mask on line 1
    MR0 // at 0: Interrupt Mask on line 0
  }

//---  Register EMR1: Event mask register
  EMR1 @offset 0x4 $u32 {
    MR31 // at 31: Event Mask on line 31
    MR30 // at 30: Event Mask on line 30
    MR29 // at 29: Event Mask on line 29
    MR28 // at 28: Event Mask on line 28
    MR27 // at 27: Event Mask on line 27
    MR26 // at 26: Event Mask on line 26
    MR25 // at 25: Event Mask on line 25
    MR24 // at 24: Event Mask on line 24
    MR23 // at 23: Event Mask on line 23
    MR22 // at 22: Event Mask on line 22
    MR21 // at 21: Event Mask on line 21
    MR20 // at 20: Event Mask on line 20
    MR19 // at 19: Event Mask on line 19
    MR18 // at 18: Event Mask on line 18
    MR17 // at 17: Event Mask on line 17
    MR16 // at 16: Event Mask on line 16
    MR15 // at 15: Event Mask on line 15
    MR14 // at 14: Event Mask on line 14
    MR13 // at 13: Event Mask on line 13
    MR12 // at 12: Event Mask on line 12
    MR11 // at 11: Event Mask on line 11
    MR10 // at 10: Event Mask on line 10
    MR9 // at 9: Event Mask on line 9
    MR8 // at 8: Event Mask on line 8
    MR7 // at 7: Event Mask on line 7
    MR6 // at 6: Event Mask on line 6
    MR5 // at 5: Event Mask on line 5
    MR4 // at 4: Event Mask on line 4
    MR3 // at 3: Event Mask on line 3
    MR2 // at 2: Event Mask on line 2
    MR1 // at 1: Event Mask on line 1
    MR0 // at 0: Event Mask on line 0
  }

//---  Register RTSR1: Rising Trigger selection           register
  RTSR1 @offset 0x8 $u32 {
    9
    TR22 // at 22: Rising trigger event configuration of line 22
    TR21 // at 21: Rising trigger event configuration of line 21
    TR20 // at 20: Rising trigger event configuration of line 20
    TR19 // at 19: Rising trigger event configuration of line 19
    TR18 // at 18: Rising trigger event configuration of line 18
    1
    TR16 // at 16: Rising trigger event configuration of line 16
    TR15 // at 15: Rising trigger event configuration of line 15
    TR14 // at 14: Rising trigger event configuration of line 14
    TR13 // at 13: Rising trigger event configuration of line 13
    TR12 // at 12: Rising trigger event configuration of line 12
    TR11 // at 11: Rising trigger event configuration of line 11
    TR10 // at 10: Rising trigger event configuration of line 10
    TR9 // at 9: Rising trigger event configuration of line 9
    TR8 // at 8: Rising trigger event configuration of line 8
    TR7 // at 7: Rising trigger event configuration of line 7
    TR6 // at 6: Rising trigger event configuration of line 6
    TR5 // at 5: Rising trigger event configuration of line 5
    TR4 // at 4: Rising trigger event configuration of line 4
    TR3 // at 3: Rising trigger event configuration of line 3
    TR2 // at 2: Rising trigger event configuration of line 2
    TR1 // at 1: Rising trigger event configuration of line 1
    TR0 // at 0: Rising trigger event configuration of line 0
  }

//---  Register FTSR1: Falling Trigger selection           register
  FTSR1 @offset 0xc $u32 {
    9
    TR22 // at 22: Falling trigger event configuration of line 22
    TR21 // at 21: Falling trigger event configuration of line 21
    TR20 // at 20: Falling trigger event configuration of line 20
    TR19 // at 19: Falling trigger event configuration of line 19
    TR18 // at 18: Falling trigger event configuration of line 18
    1
    TR16 // at 16: Falling trigger event configuration of line 16
    TR15 // at 15: Falling trigger event configuration of line 15
    TR14 // at 14: Falling trigger event configuration of line 14
    TR13 // at 13: Falling trigger event configuration of line 13
    TR12 // at 12: Falling trigger event configuration of line 12
    TR11 // at 11: Falling trigger event configuration of line 11
    TR10 // at 10: Falling trigger event configuration of line 10
    TR9 // at 9: Falling trigger event configuration of line 9
    TR8 // at 8: Falling trigger event configuration of line 8
    TR7 // at 7: Falling trigger event configuration of line 7
    TR6 // at 6: Falling trigger event configuration of line 6
    TR5 // at 5: Falling trigger event configuration of line 5
    TR4 // at 4: Falling trigger event configuration of line 4
    TR3 // at 3: Falling trigger event configuration of line 3
    TR2 // at 2: Falling trigger event configuration of line 2
    TR1 // at 1: Falling trigger event configuration of line 1
    TR0 // at 0: Falling trigger event configuration of line 0
  }

//---  Register SWIER1: Software interrupt event           register
  SWIER1 @offset 0x10 $u32 {
    9
    SWIER22 // at 22: Software Interrupt on line 22
    SWIER21 // at 21: Software Interrupt on line 21
    SWIER20 // at 20: Software Interrupt on line 20
    SWIER19 // at 19: Software Interrupt on line 19
    SWIER18 // at 18: Software Interrupt on line 18
    1
    SWIER16 // at 16: Software Interrupt on line 16
    SWIER15 // at 15: Software Interrupt on line 15
    SWIER14 // at 14: Software Interrupt on line 14
    SWIER13 // at 13: Software Interrupt on line 13
    SWIER12 // at 12: Software Interrupt on line 12
    SWIER11 // at 11: Software Interrupt on line 11
    SWIER10 // at 10: Software Interrupt on line 10
    SWIER9 // at 9: Software Interrupt on line 9
    SWIER8 // at 8: Software Interrupt on line 8
    SWIER7 // at 7: Software Interrupt on line 7
    SWIER6 // at 6: Software Interrupt on line 6
    SWIER5 // at 5: Software Interrupt on line 5
    SWIER4 // at 4: Software Interrupt on line 4
    SWIER3 // at 3: Software Interrupt on line 3
    SWIER2 // at 2: Software Interrupt on line 2
    SWIER1 // at 1: Software Interrupt on line 1
    SWIER0 // at 0: Software Interrupt on line 0
  }

//---  Register PR1: Pending register
  PR1 @offset 0x14 $u32 {
    9
    PR22 // at 22: Pending bit 22
    PR21 // at 21: Pending bit 21
    PR20 // at 20: Pending bit 20
    PR19 // at 19: Pending bit 19
    PR18 // at 18: Pending bit 18
    1
    PR16 // at 16: Pending bit 16
    PR15 // at 15: Pending bit 15
    PR14 // at 14: Pending bit 14
    PR13 // at 13: Pending bit 13
    PR12 // at 12: Pending bit 12
    PR11 // at 11: Pending bit 11
    PR10 // at 10: Pending bit 10
    PR9 // at 9: Pending bit 9
    PR8 // at 8: Pending bit 8
    PR7 // at 7: Pending bit 7
    PR6 // at 6: Pending bit 6
    PR5 // at 5: Pending bit 5
    PR4 // at 4: Pending bit 4
    PR3 // at 3: Pending bit 3
    PR2 // at 2: Pending bit 2
    PR1 // at 1: Pending bit 1
    PR0 // at 0: Pending bit 0
  }

//---  Register IMR2: Interrupt mask register
  IMR2 @offset 0x20 $u32 {
    24
    MR39 // at 7: Interrupt Mask on external/internal line 39
    MR38 // at 6: Interrupt Mask on external/internal line 38
    MR37 // at 5: Interrupt Mask on external/internal line 37
    MR36 // at 4: Interrupt Mask on external/internal line 36
    MR35 // at 3: Interrupt Mask on external/internal line 35
    MR34 // at 2: Interrupt Mask on external/internal line 34
    MR33 // at 1: Interrupt Mask on external/internal line 33
    MR32 // at 0: Interrupt Mask on external/internal line 32
  }

//---  Register EMR2: Event mask register
  EMR2 @offset 0x24 $u32 {
    24
    MR39 // at 7: Event mask on external/internal line 39
    MR38 // at 6: Event mask on external/internal line 38
    MR37 // at 5: Event mask on external/internal line 37
    MR36 // at 4: Event mask on external/internal line 36
    MR35 // at 3: Event mask on external/internal line 35
    MR34 // at 2: Event mask on external/internal line 34
    MR33 // at 1: Event mask on external/internal line 33
    MR32 // at 0: Event mask on external/internal line 32
  }

//---  Register RTSR2: Rising Trigger selection           register
  RTSR2 @offset 0x28 $u32 {
    25
    RT38 // at 6: Rising trigger event configuration bit of line 38
    RT37 // at 5: Rising trigger event configuration bit of line 37
    RT36 // at 4: Rising trigger event configuration bit of line 36
    RT35 // at 3: Rising trigger event configuration bit of line 35
    3
  }

//---  Register FTSR2: Falling Trigger selection           register
  FTSR2 @offset 0x2c $u32 {
    25
    FT38 // at 6: Falling trigger event configuration bit of line 38
    FT37 // at 5: Falling trigger event configuration bit of line 37
    FT36 // at 4: Falling trigger event configuration bit of line 36
    FT35 // at 3: Falling trigger event configuration bit of line 35
    3
  }

//---  Register SWIER2: Software interrupt event           register
  SWIER2 @offset 0x30 $u32 {
    25
    SWI38 // at 6: Software interrupt on line 38
    SWI37 // at 5: Software interrupt on line 37
    SWI36 // at 4: Software interrupt on line 36
    SWI35 // at 3: Software interrupt on line 35
    3
  }

//---  Register PR2: Pending register
  PR2 @offset 0x34 $u32 {
    25
    PIF38 // at 6: Pending interrupt flag on line 38
    PIF37 // at 5: Pending interrupt flag on line 37
    PIF36 // at 4: Pending interrupt flag on line 36
    PIF35 // at 3: Pending interrupt flag on line 35
    3
  }

}

//------------------------------------------------------------------------------
// Peripheral FIREWALL: Firewall
//------------------------------------------------------------------------------

registers ©FIREWALL @at 0x40011c00 {
//---  Register CSSA: Code segment start address
  CSSA @offset 0x0 $u32 {
    8
    ADD:16 // at 8: code segment start address
    8
  }

//---  Register CSL: Code segment length
  CSL @offset 0x4 $u32 {
    10
    LENG:14 // at 8: code segment length
    8
  }

//---  Register NVDSSA: Non-volatile data segment start           address
  NVDSSA @offset 0x8 $u32 {
    8
    ADD:16 // at 8: Non-volatile data segment start address
    8
  }

//---  Register NVDSL: Non-volatile data segment           length
  NVDSL @offset 0xc $u32 {
    10
    LENG:14 // at 8: Non-volatile data segment length
    8
  }

//---  Register VDSSA: Volatile data segment start           address
  VDSSA @offset 0x10 $u32 {
    16
    ADD:10 // at 6: Volatile data segment start address
    6
  }

//---  Register VDSL: Volatile data segment length
  VDSL @offset 0x14 $u32 {
    16
    LENG:10 // at 6: Non-volatile data segment length
    6
  }

//---  Register CR: Configuration register
  CR @offset 0x20 $u32 {
    29
    VDE // at 2: Volatile data execution
    VDS // at 1: Volatile data shared
    FPA // at 0: Firewall pre alarm
  }

}

//------------------------------------------------------------------------------
// Peripheral FLASH: Flash
//------------------------------------------------------------------------------

registers ©FLASH @at 0x40022000 {
//---  Register ACR: Access control register
  ACR @offset 0x0 $u32 {
    17
    SLEEP_PD // at 14: Flash Power-down mode during Low-power sleep mode
    RUN_PD // at 13: Flash Power-down mode during Low-power run mode
    DCRST // at 12: Data cache reset
    ICRST // at 11: Instruction cache reset
    DCEN // at 10: Data cache enable
    ICEN // at 9: Instruction cache enable
    PRFTEN // at 8: Prefetch enable
    5
    LATENCY:3 // at 0: Latency
  }

//---  Register PDKEYR: Power down key register
  PDKEYR @offset 0x4 $u32 {
    PDKEYR:32 // at 0: RUN_PD in FLASH_ACR key
  }

//---  Register KEYR: Flash key register
  KEYR @offset 0x8 $u32 {
    KEYR:32 // at 0: KEYR
  }

//---  Register OPTKEYR: Option byte key register
  OPTKEYR @offset 0xc $u32 {
    OPTKEYR:32 // at 0: Option byte key
  }

//---  Register SR: Status register
  SR @offset 0x10 $u32 {
    15
    BSY // at 16: Busy
    OPTVERR // at 15: Option validity error
    RDERR // at 14: PCROP read error
    4
    FASTERR // at 9: Fast programming error
    MISERR // at 8: Fast programming data miss error
    PGSERR // at 7: Programming sequence error
    SIZERR // at 6: Size error
    PGAERR // at 5: Programming alignment error
    WRPERR // at 4: Write protected error
    PROGERR // at 3: Programming error
    1
    OPERR // at 1: Operation error
    EOP // at 0: End of operation
  }

//---  Register CR: Flash control register
  CR @offset 0x14 $u32 {
    LOCK // at 31: FLASH_CR Lock
    OPTLOCK // at 30: Options Lock
    2
    OBL_LAUNCH // at 27: Force the option byte loading
    RDERRIE // at 26: PCROP read error interrupt enable
    ERRIE // at 25: Error interrupt enable
    EOPIE // at 24: End of operation interrupt enable
    5
    FSTPG // at 18: Fast programming
    OPTSTRT // at 17: Options modification start
    START // at 16: Start
    MER2 // at 15: Bank 2 Mass erase
    3
    BKER // at 11: Bank erase
    PNB:8 // at 3: Page number
    MER1 // at 2: Bank 1 Mass erase
    PER // at 1: Page erase
    PG // at 0: Programming
  }

//---  Register ECCR: Flash ECC register
  ECCR @offset 0x18 $u32 {
    ECCD // at 31: ECC detection
    ECCC // at 30: ECC correction
    5
    ECCIE // at 24: ECC correction interrupt enable
    3
    SYSF_ECC // at 20: System Flash ECC fail
    BK_ECC // at 19: ECC fail bank
    ADDR_ECC:19 // at 0: ECC fail address
  }

//---  Register OPTR: Flash option register
  OPTR @offset 0x20 $u32 {
    6
    SRAM2_RST // at 25: SRAM2 Erase when system reset
    SRAM2_PE // at 24: SRAM2 parity check enable
    nBOOT1 // at 23: Boot configuration
    1
    DUALBANK // at 21: Dual-Bank on 512 KB or 256 KB Flash memory devices
    BFB2 // at 20: Dual-bank boot
    WWDG_SW // at 19: Window watchdog selection
    IWDG_STDBY // at 18: Independent watchdog counter freeze in Standby mode
    IWDG_STOP // at 17: Independent watchdog counter freeze in Stop mode
    IDWG_SW // at 16: Independent watchdog selection
    2
    nRST_STDBY // at 13: nRST_STDBY
    nRST_STOP // at 12: nRST_STOP
    1
    BOR_LEV:3 // at 8: BOR reset Level
    RDP:8 // at 0: Read protection level
  }

//---  Register PCROP1SR: Flash Bank 1 PCROP Start address           register
  PCROP1SR @offset 0x24 $u32 {
    16
    PCROP1_STRT:16 // at 0: Bank 1 PCROP area start offset
  }

//---  Register PCROP1ER: Flash Bank 1 PCROP End address           register
  PCROP1ER @offset 0x28 $u32 {
    PCROP_RDP // at 31: PCROP area preserved when RDP level decreased
    15
    PCROP1_END:16 // at 0: Bank 1 PCROP area end offset
  }

//---  Register WRP1AR: Flash Bank 1 WRP area A address           register
  WRP1AR @offset 0x2c $u32 {
    8
    WRP1A_END:8 // at 16: Bank 1 WRP first area A end offset
    8
    WRP1A_STRT:8 // at 0: Bank 1 WRP first area tart offset
  }

//---  Register WRP1BR: Flash Bank 1 WRP area B address           register
  WRP1BR @offset 0x30 $u32 {
    8
    WRP1B_STRT:8 // at 16: Bank 1 WRP second area B end offset
    8
    WRP1B_END:8 // at 0: Bank 1 WRP second area B start offset
  }

//---  Register PCROP2SR: Flash Bank 2 PCROP Start address           register
  PCROP2SR @offset 0x44 $u32 {
    16
    PCROP2_STRT:16 // at 0: Bank 2 PCROP area start offset
  }

//---  Register PCROP2ER: Flash Bank 2 PCROP End address           register
  PCROP2ER @offset 0x48 $u32 {
    16
    PCROP2_END:16 // at 0: Bank 2 PCROP area end offset
  }

//---  Register WRP2AR: Flash Bank 2 WRP area A address           register
  WRP2AR @offset 0x4c $u32 {
    8
    WRP2A_END:8 // at 16: Bank 2 WRP first area A end offset
    8
    WRP2A_STRT:8 // at 0: Bank 2 WRP first area A start offset
  }

//---  Register WRP2BR: Flash Bank 2 WRP area B address           register
  WRP2BR @offset 0x50 $u32 {
    8
    WRP2B_END:8 // at 16: Bank 2 WRP second area B end offset
    8
    WRP2B_STRT:8 // at 0: Bank 2 WRP second area B start offset
  }

}

//------------------------------------------------------------------------------
// Peripheral FPU: Floting point unit
//------------------------------------------------------------------------------

registers ©FPU @at 0xe000ef34 {
//---  Register FPCCR: Floating-point context control           register
  FPCCR @offset 0x0 $u32 {
    ASPEN // at 31: ASPEN
    LSPEN // at 30: LSPEN
    21
    MONRDY // at 8: MONRDY
    1
    BFRDY // at 6: BFRDY
    MMRDY // at 5: MMRDY
    HFRDY // at 4: HFRDY
    THREAD // at 3: THREAD
    1
    USER // at 1: USER
    LSPACT // at 0: LSPACT
  }

//---  Register FPCAR: Floating-point context address           register
  FPCAR @offset 0x4 $u32 {
    ADDRESS:29 // at 3: Location of unpopulated floating-point
    3
  }

//---  Register FPSCR: Floating-point status control           register
  FPSCR @offset 0x8 $u32 {
    N // at 31: Negative condition code flag
    Z // at 30: Zero condition code flag
    C // at 29: Carry condition code flag
    V // at 28: Overflow condition code flag
    1
    AHP // at 26: Alternative half-precision control bit
    DN // at 25: Default NaN mode control bit
    FZ // at 24: Flush-to-zero mode control bit:
    RMode:2 // at 22: Rounding Mode control field
    14
    IDC // at 7: Input denormal cumulative exception bit.
    2
    IXC // at 4: Inexact cumulative exception bit
    UFC // at 3: Underflow cumulative exception bit
    OFC // at 2: Overflow cumulative exception bit
    DZC // at 1: Division by zero cumulative exception bit.
    IOC // at 0: Invalid operation cumulative exception bit
  }

}

//------------------------------------------------------------------------------
// Peripheral FPU_CPACR: Floating point unit CPACR
//------------------------------------------------------------------------------

registers ©FPU_CPACR @at 0xe000ed88 {
//---  Register CPACR: Coprocessor access control           register
  CPACR @offset 0x0 $u32 {
    8
    CP:4 // at 20: CP
    20
  }

}

//------------------------------------------------------------------------------
// Peripheral GPIOA: General-purpose I/Os
//------------------------------------------------------------------------------

registers ©GPIOA @at 0x48000000 {
//---  Register MODER: GPIO port mode register
  MODER @offset 0x0 $u32 {
    MODER15:2 // at 30: Port x configuration bits (y = 0..15)
    MODER14:2 // at 28: Port x configuration bits (y = 0..15)
    MODER13:2 // at 26: Port x configuration bits (y = 0..15)
    MODER12:2 // at 24: Port x configuration bits (y = 0..15)
    MODER11:2 // at 22: Port x configuration bits (y = 0..15)
    MODER10:2 // at 20: Port x configuration bits (y = 0..15)
    MODER9:2 // at 18: Port x configuration bits (y = 0..15)
    MODER8:2 // at 16: Port x configuration bits (y = 0..15)
    MODER7:2 // at 14: Port x configuration bits (y = 0..15)
    MODER6:2 // at 12: Port x configuration bits (y = 0..15)
    MODER5:2 // at 10: Port x configuration bits (y = 0..15)
    MODER4:2 // at 8: Port x configuration bits (y = 0..15)
    MODER3:2 // at 6: Port x configuration bits (y = 0..15)
    MODER2:2 // at 4: Port x configuration bits (y = 0..15)
    MODER1:2 // at 2: Port x configuration bits (y = 0..15)
    MODER0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OTYPER: GPIO port output type register
  OTYPER @offset 0x4 $u32 {
    16
    OT15 // at 15: Port x configuration bits (y = 0..15)
    OT14 // at 14: Port x configuration bits (y = 0..15)
    OT13 // at 13: Port x configuration bits (y = 0..15)
    OT12 // at 12: Port x configuration bits (y = 0..15)
    OT11 // at 11: Port x configuration bits (y = 0..15)
    OT10 // at 10: Port x configuration bits (y = 0..15)
    OT9 // at 9: Port x configuration bits (y = 0..15)
    OT8 // at 8: Port x configuration bits (y = 0..15)
    OT7 // at 7: Port x configuration bits (y = 0..15)
    OT6 // at 6: Port x configuration bits (y = 0..15)
    OT5 // at 5: Port x configuration bits (y = 0..15)
    OT4 // at 4: Port x configuration bits (y = 0..15)
    OT3 // at 3: Port x configuration bits (y = 0..15)
    OT2 // at 2: Port x configuration bits (y = 0..15)
    OT1 // at 1: Port x configuration bits (y = 0..15)
    OT0 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OSPEEDR: GPIO port output speed           register
  OSPEEDR @offset 0x8 $u32 {
    OSPEEDR15:2 // at 30: Port x configuration bits (y = 0..15)
    OSPEEDR14:2 // at 28: Port x configuration bits (y = 0..15)
    OSPEEDR13:2 // at 26: Port x configuration bits (y = 0..15)
    OSPEEDR12:2 // at 24: Port x configuration bits (y = 0..15)
    OSPEEDR11:2 // at 22: Port x configuration bits (y = 0..15)
    OSPEEDR10:2 // at 20: Port x configuration bits (y = 0..15)
    OSPEEDR9:2 // at 18: Port x configuration bits (y = 0..15)
    OSPEEDR8:2 // at 16: Port x configuration bits (y = 0..15)
    OSPEEDR7:2 // at 14: Port x configuration bits (y = 0..15)
    OSPEEDR6:2 // at 12: Port x configuration bits (y = 0..15)
    OSPEEDR5:2 // at 10: Port x configuration bits (y = 0..15)
    OSPEEDR4:2 // at 8: Port x configuration bits (y = 0..15)
    OSPEEDR3:2 // at 6: Port x configuration bits (y = 0..15)
    OSPEEDR2:2 // at 4: Port x configuration bits (y = 0..15)
    OSPEEDR1:2 // at 2: Port x configuration bits (y = 0..15)
    OSPEEDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register PUPDR: GPIO port pull-up/pull-down           register
  PUPDR @offset 0xc $u32 {
    PUPDR15:2 // at 30: Port x configuration bits (y = 0..15)
    PUPDR14:2 // at 28: Port x configuration bits (y = 0..15)
    PUPDR13:2 // at 26: Port x configuration bits (y = 0..15)
    PUPDR12:2 // at 24: Port x configuration bits (y = 0..15)
    PUPDR11:2 // at 22: Port x configuration bits (y = 0..15)
    PUPDR10:2 // at 20: Port x configuration bits (y = 0..15)
    PUPDR9:2 // at 18: Port x configuration bits (y = 0..15)
    PUPDR8:2 // at 16: Port x configuration bits (y = 0..15)
    PUPDR7:2 // at 14: Port x configuration bits (y = 0..15)
    PUPDR6:2 // at 12: Port x configuration bits (y = 0..15)
    PUPDR5:2 // at 10: Port x configuration bits (y = 0..15)
    PUPDR4:2 // at 8: Port x configuration bits (y = 0..15)
    PUPDR3:2 // at 6: Port x configuration bits (y = 0..15)
    PUPDR2:2 // at 4: Port x configuration bits (y = 0..15)
    PUPDR1:2 // at 2: Port x configuration bits (y = 0..15)
    PUPDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register IDR: GPIO port input data register
  IDR @offset 0x10 @ro $u32 {
    16
    IDR15 // at 15: Port input data (y = 0..15)
    IDR14 // at 14: Port input data (y = 0..15)
    IDR13 // at 13: Port input data (y = 0..15)
    IDR12 // at 12: Port input data (y = 0..15)
    IDR11 // at 11: Port input data (y = 0..15)
    IDR10 // at 10: Port input data (y = 0..15)
    IDR9 // at 9: Port input data (y = 0..15)
    IDR8 // at 8: Port input data (y = 0..15)
    IDR7 // at 7: Port input data (y = 0..15)
    IDR6 // at 6: Port input data (y = 0..15)
    IDR5 // at 5: Port input data (y = 0..15)
    IDR4 // at 4: Port input data (y = 0..15)
    IDR3 // at 3: Port input data (y = 0..15)
    IDR2 // at 2: Port input data (y = 0..15)
    IDR1 // at 1: Port input data (y = 0..15)
    IDR0 // at 0: Port input data (y = 0..15)
  }

//---  Register ODR: GPIO port output data register
  ODR @offset 0x14 $u32 {
    16
    ODR15 // at 15: Port output data (y = 0..15)
    ODR14 // at 14: Port output data (y = 0..15)
    ODR13 // at 13: Port output data (y = 0..15)
    ODR12 // at 12: Port output data (y = 0..15)
    ODR11 // at 11: Port output data (y = 0..15)
    ODR10 // at 10: Port output data (y = 0..15)
    ODR9 // at 9: Port output data (y = 0..15)
    ODR8 // at 8: Port output data (y = 0..15)
    ODR7 // at 7: Port output data (y = 0..15)
    ODR6 // at 6: Port output data (y = 0..15)
    ODR5 // at 5: Port output data (y = 0..15)
    ODR4 // at 4: Port output data (y = 0..15)
    ODR3 // at 3: Port output data (y = 0..15)
    ODR2 // at 2: Port output data (y = 0..15)
    ODR1 // at 1: Port output data (y = 0..15)
    ODR0 // at 0: Port output data (y = 0..15)
  }

//---  Register BSRR: GPIO port bit set/reset           register
  BSRR @offset 0x18 $u32 {
    BR15 // at 31: Port x reset bit y (y = 0..15)
    BR14 // at 30: Port x reset bit y (y = 0..15)
    BR13 // at 29: Port x reset bit y (y = 0..15)
    BR12 // at 28: Port x reset bit y (y = 0..15)
    BR11 // at 27: Port x reset bit y (y = 0..15)
    BR10 // at 26: Port x reset bit y (y = 0..15)
    BR9 // at 25: Port x reset bit y (y = 0..15)
    BR8 // at 24: Port x reset bit y (y = 0..15)
    BR7 // at 23: Port x reset bit y (y = 0..15)
    BR6 // at 22: Port x reset bit y (y = 0..15)
    BR5 // at 21: Port x reset bit y (y = 0..15)
    BR4 // at 20: Port x reset bit y (y = 0..15)
    BR3 // at 19: Port x reset bit y (y = 0..15)
    BR2 // at 18: Port x reset bit y (y = 0..15)
    BR1 // at 17: Port x reset bit y (y = 0..15)
    BR0 // at 16: Port x set bit y (y= 0..15)
    BS15 // at 15: Port x set bit y (y= 0..15)
    BS14 // at 14: Port x set bit y (y= 0..15)
    BS13 // at 13: Port x set bit y (y= 0..15)
    BS12 // at 12: Port x set bit y (y= 0..15)
    BS11 // at 11: Port x set bit y (y= 0..15)
    BS10 // at 10: Port x set bit y (y= 0..15)
    BS9 // at 9: Port x set bit y (y= 0..15)
    BS8 // at 8: Port x set bit y (y= 0..15)
    BS7 // at 7: Port x set bit y (y= 0..15)
    BS6 // at 6: Port x set bit y (y= 0..15)
    BS5 // at 5: Port x set bit y (y= 0..15)
    BS4 // at 4: Port x set bit y (y= 0..15)
    BS3 // at 3: Port x set bit y (y= 0..15)
    BS2 // at 2: Port x set bit y (y= 0..15)
    BS1 // at 1: Port x set bit y (y= 0..15)
    BS0 // at 0: Port x set bit y (y= 0..15)
  }

//---  Register LCKR: GPIO port configuration lock           register
  LCKR @offset 0x1c $u32 {
    15
    LCKK // at 16: Port x lock bit y (y= 0..15)
    LCK15 // at 15: Port x lock bit y (y= 0..15)
    LCK14 // at 14: Port x lock bit y (y= 0..15)
    LCK13 // at 13: Port x lock bit y (y= 0..15)
    LCK12 // at 12: Port x lock bit y (y= 0..15)
    LCK11 // at 11: Port x lock bit y (y= 0..15)
    LCK10 // at 10: Port x lock bit y (y= 0..15)
    LCK9 // at 9: Port x lock bit y (y= 0..15)
    LCK8 // at 8: Port x lock bit y (y= 0..15)
    LCK7 // at 7: Port x lock bit y (y= 0..15)
    LCK6 // at 6: Port x lock bit y (y= 0..15)
    LCK5 // at 5: Port x lock bit y (y= 0..15)
    LCK4 // at 4: Port x lock bit y (y= 0..15)
    LCK3 // at 3: Port x lock bit y (y= 0..15)
    LCK2 // at 2: Port x lock bit y (y= 0..15)
    LCK1 // at 1: Port x lock bit y (y= 0..15)
    LCK0 // at 0: Port x lock bit y (y= 0..15)
  }

//---  Register AFRL: GPIO alternate function low           register
  AFRL @offset 0x20 $u32 {
    AFRL7:4 // at 28: Alternate function selection for port x bit y (y = 0..7)
    AFRL6:4 // at 24: Alternate function selection for port x bit y (y = 0..7)
    AFRL5:4 // at 20: Alternate function selection for port x bit y (y = 0..7)
    AFRL4:4 // at 16: Alternate function selection for port x bit y (y = 0..7)
    AFRL3:4 // at 12: Alternate function selection for port x bit y (y = 0..7)
    AFRL2:4 // at 8: Alternate function selection for port x bit y (y = 0..7)
    AFRL1:4 // at 4: Alternate function selection for port x bit y (y = 0..7)
    AFRL0:4 // at 0: Alternate function selection for port x bit y (y = 0..7)
  }

//---  Register AFRH: GPIO alternate function high           register
  AFRH @offset 0x24 $u32 {
    AFRH15:4 // at 28: Alternate function selection for port x bit y (y = 8..15)
    AFRH14:4 // at 24: Alternate function selection for port x bit y (y = 8..15)
    AFRH13:4 // at 20: Alternate function selection for port x bit y (y = 8..15)
    AFRH12:4 // at 16: Alternate function selection for port x bit y (y = 8..15)
    AFRH11:4 // at 12: Alternate function selection for port x bit y (y = 8..15)
    AFRH10:4 // at 8: Alternate function selection for port x bit y (y = 8..15)
    AFRH9:4 // at 4: Alternate function selection for port x bit y (y = 8..15)
    AFRH8:4 // at 0: Alternate function selection for port x bit y (y = 8..15)
  }

}

//------------------------------------------------------------------------------
// Peripheral GPIOB: General-purpose I/Os
//------------------------------------------------------------------------------

registers ©GPIOB @at 0x48000400 {
//---  Register MODER: GPIO port mode register
  MODER @offset 0x0 $u32 {
    MODER15:2 // at 30: Port x configuration bits (y = 0..15)
    MODER14:2 // at 28: Port x configuration bits (y = 0..15)
    MODER13:2 // at 26: Port x configuration bits (y = 0..15)
    MODER12:2 // at 24: Port x configuration bits (y = 0..15)
    MODER11:2 // at 22: Port x configuration bits (y = 0..15)
    MODER10:2 // at 20: Port x configuration bits (y = 0..15)
    MODER9:2 // at 18: Port x configuration bits (y = 0..15)
    MODER8:2 // at 16: Port x configuration bits (y = 0..15)
    MODER7:2 // at 14: Port x configuration bits (y = 0..15)
    MODER6:2 // at 12: Port x configuration bits (y = 0..15)
    MODER5:2 // at 10: Port x configuration bits (y = 0..15)
    MODER4:2 // at 8: Port x configuration bits (y = 0..15)
    MODER3:2 // at 6: Port x configuration bits (y = 0..15)
    MODER2:2 // at 4: Port x configuration bits (y = 0..15)
    MODER1:2 // at 2: Port x configuration bits (y = 0..15)
    MODER0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OTYPER: GPIO port output type register
  OTYPER @offset 0x4 $u32 {
    16
    OT15 // at 15: Port x configuration bits (y = 0..15)
    OT14 // at 14: Port x configuration bits (y = 0..15)
    OT13 // at 13: Port x configuration bits (y = 0..15)
    OT12 // at 12: Port x configuration bits (y = 0..15)
    OT11 // at 11: Port x configuration bits (y = 0..15)
    OT10 // at 10: Port x configuration bits (y = 0..15)
    OT9 // at 9: Port x configuration bits (y = 0..15)
    OT8 // at 8: Port x configuration bits (y = 0..15)
    OT7 // at 7: Port x configuration bits (y = 0..15)
    OT6 // at 6: Port x configuration bits (y = 0..15)
    OT5 // at 5: Port x configuration bits (y = 0..15)
    OT4 // at 4: Port x configuration bits (y = 0..15)
    OT3 // at 3: Port x configuration bits (y = 0..15)
    OT2 // at 2: Port x configuration bits (y = 0..15)
    OT1 // at 1: Port x configuration bits (y = 0..15)
    OT0 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OSPEEDR: GPIO port output speed           register
  OSPEEDR @offset 0x8 $u32 {
    OSPEEDR15:2 // at 30: Port x configuration bits (y = 0..15)
    OSPEEDR14:2 // at 28: Port x configuration bits (y = 0..15)
    OSPEEDR13:2 // at 26: Port x configuration bits (y = 0..15)
    OSPEEDR12:2 // at 24: Port x configuration bits (y = 0..15)
    OSPEEDR11:2 // at 22: Port x configuration bits (y = 0..15)
    OSPEEDR10:2 // at 20: Port x configuration bits (y = 0..15)
    OSPEEDR9:2 // at 18: Port x configuration bits (y = 0..15)
    OSPEEDR8:2 // at 16: Port x configuration bits (y = 0..15)
    OSPEEDR7:2 // at 14: Port x configuration bits (y = 0..15)
    OSPEEDR6:2 // at 12: Port x configuration bits (y = 0..15)
    OSPEEDR5:2 // at 10: Port x configuration bits (y = 0..15)
    OSPEEDR4:2 // at 8: Port x configuration bits (y = 0..15)
    OSPEEDR3:2 // at 6: Port x configuration bits (y = 0..15)
    OSPEEDR2:2 // at 4: Port x configuration bits (y = 0..15)
    OSPEEDR1:2 // at 2: Port x configuration bits (y = 0..15)
    OSPEEDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register PUPDR: GPIO port pull-up/pull-down           register
  PUPDR @offset 0xc $u32 {
    PUPDR15:2 // at 30: Port x configuration bits (y = 0..15)
    PUPDR14:2 // at 28: Port x configuration bits (y = 0..15)
    PUPDR13:2 // at 26: Port x configuration bits (y = 0..15)
    PUPDR12:2 // at 24: Port x configuration bits (y = 0..15)
    PUPDR11:2 // at 22: Port x configuration bits (y = 0..15)
    PUPDR10:2 // at 20: Port x configuration bits (y = 0..15)
    PUPDR9:2 // at 18: Port x configuration bits (y = 0..15)
    PUPDR8:2 // at 16: Port x configuration bits (y = 0..15)
    PUPDR7:2 // at 14: Port x configuration bits (y = 0..15)
    PUPDR6:2 // at 12: Port x configuration bits (y = 0..15)
    PUPDR5:2 // at 10: Port x configuration bits (y = 0..15)
    PUPDR4:2 // at 8: Port x configuration bits (y = 0..15)
    PUPDR3:2 // at 6: Port x configuration bits (y = 0..15)
    PUPDR2:2 // at 4: Port x configuration bits (y = 0..15)
    PUPDR1:2 // at 2: Port x configuration bits (y = 0..15)
    PUPDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register IDR: GPIO port input data register
  IDR @offset 0x10 @ro $u32 {
    16
    IDR15 // at 15: Port input data (y = 0..15)
    IDR14 // at 14: Port input data (y = 0..15)
    IDR13 // at 13: Port input data (y = 0..15)
    IDR12 // at 12: Port input data (y = 0..15)
    IDR11 // at 11: Port input data (y = 0..15)
    IDR10 // at 10: Port input data (y = 0..15)
    IDR9 // at 9: Port input data (y = 0..15)
    IDR8 // at 8: Port input data (y = 0..15)
    IDR7 // at 7: Port input data (y = 0..15)
    IDR6 // at 6: Port input data (y = 0..15)
    IDR5 // at 5: Port input data (y = 0..15)
    IDR4 // at 4: Port input data (y = 0..15)
    IDR3 // at 3: Port input data (y = 0..15)
    IDR2 // at 2: Port input data (y = 0..15)
    IDR1 // at 1: Port input data (y = 0..15)
    IDR0 // at 0: Port input data (y = 0..15)
  }

//---  Register ODR: GPIO port output data register
  ODR @offset 0x14 $u32 {
    16
    ODR15 // at 15: Port output data (y = 0..15)
    ODR14 // at 14: Port output data (y = 0..15)
    ODR13 // at 13: Port output data (y = 0..15)
    ODR12 // at 12: Port output data (y = 0..15)
    ODR11 // at 11: Port output data (y = 0..15)
    ODR10 // at 10: Port output data (y = 0..15)
    ODR9 // at 9: Port output data (y = 0..15)
    ODR8 // at 8: Port output data (y = 0..15)
    ODR7 // at 7: Port output data (y = 0..15)
    ODR6 // at 6: Port output data (y = 0..15)
    ODR5 // at 5: Port output data (y = 0..15)
    ODR4 // at 4: Port output data (y = 0..15)
    ODR3 // at 3: Port output data (y = 0..15)
    ODR2 // at 2: Port output data (y = 0..15)
    ODR1 // at 1: Port output data (y = 0..15)
    ODR0 // at 0: Port output data (y = 0..15)
  }

//---  Register BSRR: GPIO port bit set/reset           register
  BSRR @offset 0x18 $u32 {
    BR15 // at 31: Port x reset bit y (y = 0..15)
    BR14 // at 30: Port x reset bit y (y = 0..15)
    BR13 // at 29: Port x reset bit y (y = 0..15)
    BR12 // at 28: Port x reset bit y (y = 0..15)
    BR11 // at 27: Port x reset bit y (y = 0..15)
    BR10 // at 26: Port x reset bit y (y = 0..15)
    BR9 // at 25: Port x reset bit y (y = 0..15)
    BR8 // at 24: Port x reset bit y (y = 0..15)
    BR7 // at 23: Port x reset bit y (y = 0..15)
    BR6 // at 22: Port x reset bit y (y = 0..15)
    BR5 // at 21: Port x reset bit y (y = 0..15)
    BR4 // at 20: Port x reset bit y (y = 0..15)
    BR3 // at 19: Port x reset bit y (y = 0..15)
    BR2 // at 18: Port x reset bit y (y = 0..15)
    BR1 // at 17: Port x reset bit y (y = 0..15)
    BR0 // at 16: Port x set bit y (y= 0..15)
    BS15 // at 15: Port x set bit y (y= 0..15)
    BS14 // at 14: Port x set bit y (y= 0..15)
    BS13 // at 13: Port x set bit y (y= 0..15)
    BS12 // at 12: Port x set bit y (y= 0..15)
    BS11 // at 11: Port x set bit y (y= 0..15)
    BS10 // at 10: Port x set bit y (y= 0..15)
    BS9 // at 9: Port x set bit y (y= 0..15)
    BS8 // at 8: Port x set bit y (y= 0..15)
    BS7 // at 7: Port x set bit y (y= 0..15)
    BS6 // at 6: Port x set bit y (y= 0..15)
    BS5 // at 5: Port x set bit y (y= 0..15)
    BS4 // at 4: Port x set bit y (y= 0..15)
    BS3 // at 3: Port x set bit y (y= 0..15)
    BS2 // at 2: Port x set bit y (y= 0..15)
    BS1 // at 1: Port x set bit y (y= 0..15)
    BS0 // at 0: Port x set bit y (y= 0..15)
  }

//---  Register LCKR: GPIO port configuration lock           register
  LCKR @offset 0x1c $u32 {
    15
    LCKK // at 16: Port x lock bit y (y= 0..15)
    LCK15 // at 15: Port x lock bit y (y= 0..15)
    LCK14 // at 14: Port x lock bit y (y= 0..15)
    LCK13 // at 13: Port x lock bit y (y= 0..15)
    LCK12 // at 12: Port x lock bit y (y= 0..15)
    LCK11 // at 11: Port x lock bit y (y= 0..15)
    LCK10 // at 10: Port x lock bit y (y= 0..15)
    LCK9 // at 9: Port x lock bit y (y= 0..15)
    LCK8 // at 8: Port x lock bit y (y= 0..15)
    LCK7 // at 7: Port x lock bit y (y= 0..15)
    LCK6 // at 6: Port x lock bit y (y= 0..15)
    LCK5 // at 5: Port x lock bit y (y= 0..15)
    LCK4 // at 4: Port x lock bit y (y= 0..15)
    LCK3 // at 3: Port x lock bit y (y= 0..15)
    LCK2 // at 2: Port x lock bit y (y= 0..15)
    LCK1 // at 1: Port x lock bit y (y= 0..15)
    LCK0 // at 0: Port x lock bit y (y= 0..15)
  }

//---  Register AFRL: GPIO alternate function low           register
  AFRL @offset 0x20 $u32 {
    AFRL7:4 // at 28: Alternate function selection for port x bit y (y = 0..7)
    AFRL6:4 // at 24: Alternate function selection for port x bit y (y = 0..7)
    AFRL5:4 // at 20: Alternate function selection for port x bit y (y = 0..7)
    AFRL4:4 // at 16: Alternate function selection for port x bit y (y = 0..7)
    AFRL3:4 // at 12: Alternate function selection for port x bit y (y = 0..7)
    AFRL2:4 // at 8: Alternate function selection for port x bit y (y = 0..7)
    AFRL1:4 // at 4: Alternate function selection for port x bit y (y = 0..7)
    AFRL0:4 // at 0: Alternate function selection for port x bit y (y = 0..7)
  }

//---  Register AFRH: GPIO alternate function high           register
  AFRH @offset 0x24 $u32 {
    AFRH15:4 // at 28: Alternate function selection for port x bit y (y = 8..15)
    AFRH14:4 // at 24: Alternate function selection for port x bit y (y = 8..15)
    AFRH13:4 // at 20: Alternate function selection for port x bit y (y = 8..15)
    AFRH12:4 // at 16: Alternate function selection for port x bit y (y = 8..15)
    AFRH11:4 // at 12: Alternate function selection for port x bit y (y = 8..15)
    AFRH10:4 // at 8: Alternate function selection for port x bit y (y = 8..15)
    AFRH9:4 // at 4: Alternate function selection for port x bit y (y = 8..15)
    AFRH8:4 // at 0: Alternate function selection for port x bit y (y = 8..15)
  }

}

//------------------------------------------------------------------------------
// Peripheral GPIOC: General-purpose I/Os
//------------------------------------------------------------------------------

registers ©GPIOC @at 0x48000800 {
//---  Register MODER: GPIO port mode register
  MODER @offset 0x0 $u32 {
    MODER15:2 // at 30: Port x configuration bits (y = 0..15)
    MODER14:2 // at 28: Port x configuration bits (y = 0..15)
    MODER13:2 // at 26: Port x configuration bits (y = 0..15)
    MODER12:2 // at 24: Port x configuration bits (y = 0..15)
    MODER11:2 // at 22: Port x configuration bits (y = 0..15)
    MODER10:2 // at 20: Port x configuration bits (y = 0..15)
    MODER9:2 // at 18: Port x configuration bits (y = 0..15)
    MODER8:2 // at 16: Port x configuration bits (y = 0..15)
    MODER7:2 // at 14: Port x configuration bits (y = 0..15)
    MODER6:2 // at 12: Port x configuration bits (y = 0..15)
    MODER5:2 // at 10: Port x configuration bits (y = 0..15)
    MODER4:2 // at 8: Port x configuration bits (y = 0..15)
    MODER3:2 // at 6: Port x configuration bits (y = 0..15)
    MODER2:2 // at 4: Port x configuration bits (y = 0..15)
    MODER1:2 // at 2: Port x configuration bits (y = 0..15)
    MODER0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OTYPER: GPIO port output type register
  OTYPER @offset 0x4 $u32 {
    16
    OT15 // at 15: Port x configuration bits (y = 0..15)
    OT14 // at 14: Port x configuration bits (y = 0..15)
    OT13 // at 13: Port x configuration bits (y = 0..15)
    OT12 // at 12: Port x configuration bits (y = 0..15)
    OT11 // at 11: Port x configuration bits (y = 0..15)
    OT10 // at 10: Port x configuration bits (y = 0..15)
    OT9 // at 9: Port x configuration bits (y = 0..15)
    OT8 // at 8: Port x configuration bits (y = 0..15)
    OT7 // at 7: Port x configuration bits (y = 0..15)
    OT6 // at 6: Port x configuration bits (y = 0..15)
    OT5 // at 5: Port x configuration bits (y = 0..15)
    OT4 // at 4: Port x configuration bits (y = 0..15)
    OT3 // at 3: Port x configuration bits (y = 0..15)
    OT2 // at 2: Port x configuration bits (y = 0..15)
    OT1 // at 1: Port x configuration bits (y = 0..15)
    OT0 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OSPEEDR: GPIO port output speed           register
  OSPEEDR @offset 0x8 $u32 {
    OSPEEDR15:2 // at 30: Port x configuration bits (y = 0..15)
    OSPEEDR14:2 // at 28: Port x configuration bits (y = 0..15)
    OSPEEDR13:2 // at 26: Port x configuration bits (y = 0..15)
    OSPEEDR12:2 // at 24: Port x configuration bits (y = 0..15)
    OSPEEDR11:2 // at 22: Port x configuration bits (y = 0..15)
    OSPEEDR10:2 // at 20: Port x configuration bits (y = 0..15)
    OSPEEDR9:2 // at 18: Port x configuration bits (y = 0..15)
    OSPEEDR8:2 // at 16: Port x configuration bits (y = 0..15)
    OSPEEDR7:2 // at 14: Port x configuration bits (y = 0..15)
    OSPEEDR6:2 // at 12: Port x configuration bits (y = 0..15)
    OSPEEDR5:2 // at 10: Port x configuration bits (y = 0..15)
    OSPEEDR4:2 // at 8: Port x configuration bits (y = 0..15)
    OSPEEDR3:2 // at 6: Port x configuration bits (y = 0..15)
    OSPEEDR2:2 // at 4: Port x configuration bits (y = 0..15)
    OSPEEDR1:2 // at 2: Port x configuration bits (y = 0..15)
    OSPEEDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register PUPDR: GPIO port pull-up/pull-down           register
  PUPDR @offset 0xc $u32 {
    PUPDR15:2 // at 30: Port x configuration bits (y = 0..15)
    PUPDR14:2 // at 28: Port x configuration bits (y = 0..15)
    PUPDR13:2 // at 26: Port x configuration bits (y = 0..15)
    PUPDR12:2 // at 24: Port x configuration bits (y = 0..15)
    PUPDR11:2 // at 22: Port x configuration bits (y = 0..15)
    PUPDR10:2 // at 20: Port x configuration bits (y = 0..15)
    PUPDR9:2 // at 18: Port x configuration bits (y = 0..15)
    PUPDR8:2 // at 16: Port x configuration bits (y = 0..15)
    PUPDR7:2 // at 14: Port x configuration bits (y = 0..15)
    PUPDR6:2 // at 12: Port x configuration bits (y = 0..15)
    PUPDR5:2 // at 10: Port x configuration bits (y = 0..15)
    PUPDR4:2 // at 8: Port x configuration bits (y = 0..15)
    PUPDR3:2 // at 6: Port x configuration bits (y = 0..15)
    PUPDR2:2 // at 4: Port x configuration bits (y = 0..15)
    PUPDR1:2 // at 2: Port x configuration bits (y = 0..15)
    PUPDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register IDR: GPIO port input data register
  IDR @offset 0x10 @ro $u32 {
    16
    IDR15 // at 15: Port input data (y = 0..15)
    IDR14 // at 14: Port input data (y = 0..15)
    IDR13 // at 13: Port input data (y = 0..15)
    IDR12 // at 12: Port input data (y = 0..15)
    IDR11 // at 11: Port input data (y = 0..15)
    IDR10 // at 10: Port input data (y = 0..15)
    IDR9 // at 9: Port input data (y = 0..15)
    IDR8 // at 8: Port input data (y = 0..15)
    IDR7 // at 7: Port input data (y = 0..15)
    IDR6 // at 6: Port input data (y = 0..15)
    IDR5 // at 5: Port input data (y = 0..15)
    IDR4 // at 4: Port input data (y = 0..15)
    IDR3 // at 3: Port input data (y = 0..15)
    IDR2 // at 2: Port input data (y = 0..15)
    IDR1 // at 1: Port input data (y = 0..15)
    IDR0 // at 0: Port input data (y = 0..15)
  }

//---  Register ODR: GPIO port output data register
  ODR @offset 0x14 $u32 {
    16
    ODR15 // at 15: Port output data (y = 0..15)
    ODR14 // at 14: Port output data (y = 0..15)
    ODR13 // at 13: Port output data (y = 0..15)
    ODR12 // at 12: Port output data (y = 0..15)
    ODR11 // at 11: Port output data (y = 0..15)
    ODR10 // at 10: Port output data (y = 0..15)
    ODR9 // at 9: Port output data (y = 0..15)
    ODR8 // at 8: Port output data (y = 0..15)
    ODR7 // at 7: Port output data (y = 0..15)
    ODR6 // at 6: Port output data (y = 0..15)
    ODR5 // at 5: Port output data (y = 0..15)
    ODR4 // at 4: Port output data (y = 0..15)
    ODR3 // at 3: Port output data (y = 0..15)
    ODR2 // at 2: Port output data (y = 0..15)
    ODR1 // at 1: Port output data (y = 0..15)
    ODR0 // at 0: Port output data (y = 0..15)
  }

//---  Register BSRR: GPIO port bit set/reset           register
  BSRR @offset 0x18 $u32 {
    BR15 // at 31: Port x reset bit y (y = 0..15)
    BR14 // at 30: Port x reset bit y (y = 0..15)
    BR13 // at 29: Port x reset bit y (y = 0..15)
    BR12 // at 28: Port x reset bit y (y = 0..15)
    BR11 // at 27: Port x reset bit y (y = 0..15)
    BR10 // at 26: Port x reset bit y (y = 0..15)
    BR9 // at 25: Port x reset bit y (y = 0..15)
    BR8 // at 24: Port x reset bit y (y = 0..15)
    BR7 // at 23: Port x reset bit y (y = 0..15)
    BR6 // at 22: Port x reset bit y (y = 0..15)
    BR5 // at 21: Port x reset bit y (y = 0..15)
    BR4 // at 20: Port x reset bit y (y = 0..15)
    BR3 // at 19: Port x reset bit y (y = 0..15)
    BR2 // at 18: Port x reset bit y (y = 0..15)
    BR1 // at 17: Port x reset bit y (y = 0..15)
    BR0 // at 16: Port x set bit y (y= 0..15)
    BS15 // at 15: Port x set bit y (y= 0..15)
    BS14 // at 14: Port x set bit y (y= 0..15)
    BS13 // at 13: Port x set bit y (y= 0..15)
    BS12 // at 12: Port x set bit y (y= 0..15)
    BS11 // at 11: Port x set bit y (y= 0..15)
    BS10 // at 10: Port x set bit y (y= 0..15)
    BS9 // at 9: Port x set bit y (y= 0..15)
    BS8 // at 8: Port x set bit y (y= 0..15)
    BS7 // at 7: Port x set bit y (y= 0..15)
    BS6 // at 6: Port x set bit y (y= 0..15)
    BS5 // at 5: Port x set bit y (y= 0..15)
    BS4 // at 4: Port x set bit y (y= 0..15)
    BS3 // at 3: Port x set bit y (y= 0..15)
    BS2 // at 2: Port x set bit y (y= 0..15)
    BS1 // at 1: Port x set bit y (y= 0..15)
    BS0 // at 0: Port x set bit y (y= 0..15)
  }

//---  Register LCKR: GPIO port configuration lock           register
  LCKR @offset 0x1c $u32 {
    15
    LCKK // at 16: Port x lock bit y (y= 0..15)
    LCK15 // at 15: Port x lock bit y (y= 0..15)
    LCK14 // at 14: Port x lock bit y (y= 0..15)
    LCK13 // at 13: Port x lock bit y (y= 0..15)
    LCK12 // at 12: Port x lock bit y (y= 0..15)
    LCK11 // at 11: Port x lock bit y (y= 0..15)
    LCK10 // at 10: Port x lock bit y (y= 0..15)
    LCK9 // at 9: Port x lock bit y (y= 0..15)
    LCK8 // at 8: Port x lock bit y (y= 0..15)
    LCK7 // at 7: Port x lock bit y (y= 0..15)
    LCK6 // at 6: Port x lock bit y (y= 0..15)
    LCK5 // at 5: Port x lock bit y (y= 0..15)
    LCK4 // at 4: Port x lock bit y (y= 0..15)
    LCK3 // at 3: Port x lock bit y (y= 0..15)
    LCK2 // at 2: Port x lock bit y (y= 0..15)
    LCK1 // at 1: Port x lock bit y (y= 0..15)
    LCK0 // at 0: Port x lock bit y (y= 0..15)
  }

//---  Register AFRL: GPIO alternate function low           register
  AFRL @offset 0x20 $u32 {
    AFRL7:4 // at 28: Alternate function selection for port x bit y (y = 0..7)
    AFRL6:4 // at 24: Alternate function selection for port x bit y (y = 0..7)
    AFRL5:4 // at 20: Alternate function selection for port x bit y (y = 0..7)
    AFRL4:4 // at 16: Alternate function selection for port x bit y (y = 0..7)
    AFRL3:4 // at 12: Alternate function selection for port x bit y (y = 0..7)
    AFRL2:4 // at 8: Alternate function selection for port x bit y (y = 0..7)
    AFRL1:4 // at 4: Alternate function selection for port x bit y (y = 0..7)
    AFRL0:4 // at 0: Alternate function selection for port x bit y (y = 0..7)
  }

//---  Register AFRH: GPIO alternate function high           register
  AFRH @offset 0x24 $u32 {
    AFRH15:4 // at 28: Alternate function selection for port x bit y (y = 8..15)
    AFRH14:4 // at 24: Alternate function selection for port x bit y (y = 8..15)
    AFRH13:4 // at 20: Alternate function selection for port x bit y (y = 8..15)
    AFRH12:4 // at 16: Alternate function selection for port x bit y (y = 8..15)
    AFRH11:4 // at 12: Alternate function selection for port x bit y (y = 8..15)
    AFRH10:4 // at 8: Alternate function selection for port x bit y (y = 8..15)
    AFRH9:4 // at 4: Alternate function selection for port x bit y (y = 8..15)
    AFRH8:4 // at 0: Alternate function selection for port x bit y (y = 8..15)
  }

}

//------------------------------------------------------------------------------
// Peripheral GPIOD
//------------------------------------------------------------------------------

registers ©GPIOD @at 0x48000c00 {
//---  Register MODER: GPIO port mode register
  MODER @offset 0x0 $u32 {
    MODER15:2 // at 30: Port x configuration bits (y = 0..15)
    MODER14:2 // at 28: Port x configuration bits (y = 0..15)
    MODER13:2 // at 26: Port x configuration bits (y = 0..15)
    MODER12:2 // at 24: Port x configuration bits (y = 0..15)
    MODER11:2 // at 22: Port x configuration bits (y = 0..15)
    MODER10:2 // at 20: Port x configuration bits (y = 0..15)
    MODER9:2 // at 18: Port x configuration bits (y = 0..15)
    MODER8:2 // at 16: Port x configuration bits (y = 0..15)
    MODER7:2 // at 14: Port x configuration bits (y = 0..15)
    MODER6:2 // at 12: Port x configuration bits (y = 0..15)
    MODER5:2 // at 10: Port x configuration bits (y = 0..15)
    MODER4:2 // at 8: Port x configuration bits (y = 0..15)
    MODER3:2 // at 6: Port x configuration bits (y = 0..15)
    MODER2:2 // at 4: Port x configuration bits (y = 0..15)
    MODER1:2 // at 2: Port x configuration bits (y = 0..15)
    MODER0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OTYPER: GPIO port output type register
  OTYPER @offset 0x4 $u32 {
    16
    OT15 // at 15: Port x configuration bits (y = 0..15)
    OT14 // at 14: Port x configuration bits (y = 0..15)
    OT13 // at 13: Port x configuration bits (y = 0..15)
    OT12 // at 12: Port x configuration bits (y = 0..15)
    OT11 // at 11: Port x configuration bits (y = 0..15)
    OT10 // at 10: Port x configuration bits (y = 0..15)
    OT9 // at 9: Port x configuration bits (y = 0..15)
    OT8 // at 8: Port x configuration bits (y = 0..15)
    OT7 // at 7: Port x configuration bits (y = 0..15)
    OT6 // at 6: Port x configuration bits (y = 0..15)
    OT5 // at 5: Port x configuration bits (y = 0..15)
    OT4 // at 4: Port x configuration bits (y = 0..15)
    OT3 // at 3: Port x configuration bits (y = 0..15)
    OT2 // at 2: Port x configuration bits (y = 0..15)
    OT1 // at 1: Port x configuration bits (y = 0..15)
    OT0 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OSPEEDR: GPIO port output speed           register
  OSPEEDR @offset 0x8 $u32 {
    OSPEEDR15:2 // at 30: Port x configuration bits (y = 0..15)
    OSPEEDR14:2 // at 28: Port x configuration bits (y = 0..15)
    OSPEEDR13:2 // at 26: Port x configuration bits (y = 0..15)
    OSPEEDR12:2 // at 24: Port x configuration bits (y = 0..15)
    OSPEEDR11:2 // at 22: Port x configuration bits (y = 0..15)
    OSPEEDR10:2 // at 20: Port x configuration bits (y = 0..15)
    OSPEEDR9:2 // at 18: Port x configuration bits (y = 0..15)
    OSPEEDR8:2 // at 16: Port x configuration bits (y = 0..15)
    OSPEEDR7:2 // at 14: Port x configuration bits (y = 0..15)
    OSPEEDR6:2 // at 12: Port x configuration bits (y = 0..15)
    OSPEEDR5:2 // at 10: Port x configuration bits (y = 0..15)
    OSPEEDR4:2 // at 8: Port x configuration bits (y = 0..15)
    OSPEEDR3:2 // at 6: Port x configuration bits (y = 0..15)
    OSPEEDR2:2 // at 4: Port x configuration bits (y = 0..15)
    OSPEEDR1:2 // at 2: Port x configuration bits (y = 0..15)
    OSPEEDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register PUPDR: GPIO port pull-up/pull-down           register
  PUPDR @offset 0xc $u32 {
    PUPDR15:2 // at 30: Port x configuration bits (y = 0..15)
    PUPDR14:2 // at 28: Port x configuration bits (y = 0..15)
    PUPDR13:2 // at 26: Port x configuration bits (y = 0..15)
    PUPDR12:2 // at 24: Port x configuration bits (y = 0..15)
    PUPDR11:2 // at 22: Port x configuration bits (y = 0..15)
    PUPDR10:2 // at 20: Port x configuration bits (y = 0..15)
    PUPDR9:2 // at 18: Port x configuration bits (y = 0..15)
    PUPDR8:2 // at 16: Port x configuration bits (y = 0..15)
    PUPDR7:2 // at 14: Port x configuration bits (y = 0..15)
    PUPDR6:2 // at 12: Port x configuration bits (y = 0..15)
    PUPDR5:2 // at 10: Port x configuration bits (y = 0..15)
    PUPDR4:2 // at 8: Port x configuration bits (y = 0..15)
    PUPDR3:2 // at 6: Port x configuration bits (y = 0..15)
    PUPDR2:2 // at 4: Port x configuration bits (y = 0..15)
    PUPDR1:2 // at 2: Port x configuration bits (y = 0..15)
    PUPDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register IDR: GPIO port input data register
  IDR @offset 0x10 @ro $u32 {
    16
    IDR15 // at 15: Port input data (y = 0..15)
    IDR14 // at 14: Port input data (y = 0..15)
    IDR13 // at 13: Port input data (y = 0..15)
    IDR12 // at 12: Port input data (y = 0..15)
    IDR11 // at 11: Port input data (y = 0..15)
    IDR10 // at 10: Port input data (y = 0..15)
    IDR9 // at 9: Port input data (y = 0..15)
    IDR8 // at 8: Port input data (y = 0..15)
    IDR7 // at 7: Port input data (y = 0..15)
    IDR6 // at 6: Port input data (y = 0..15)
    IDR5 // at 5: Port input data (y = 0..15)
    IDR4 // at 4: Port input data (y = 0..15)
    IDR3 // at 3: Port input data (y = 0..15)
    IDR2 // at 2: Port input data (y = 0..15)
    IDR1 // at 1: Port input data (y = 0..15)
    IDR0 // at 0: Port input data (y = 0..15)
  }

//---  Register ODR: GPIO port output data register
  ODR @offset 0x14 $u32 {
    16
    ODR15 // at 15: Port output data (y = 0..15)
    ODR14 // at 14: Port output data (y = 0..15)
    ODR13 // at 13: Port output data (y = 0..15)
    ODR12 // at 12: Port output data (y = 0..15)
    ODR11 // at 11: Port output data (y = 0..15)
    ODR10 // at 10: Port output data (y = 0..15)
    ODR9 // at 9: Port output data (y = 0..15)
    ODR8 // at 8: Port output data (y = 0..15)
    ODR7 // at 7: Port output data (y = 0..15)
    ODR6 // at 6: Port output data (y = 0..15)
    ODR5 // at 5: Port output data (y = 0..15)
    ODR4 // at 4: Port output data (y = 0..15)
    ODR3 // at 3: Port output data (y = 0..15)
    ODR2 // at 2: Port output data (y = 0..15)
    ODR1 // at 1: Port output data (y = 0..15)
    ODR0 // at 0: Port output data (y = 0..15)
  }

//---  Register BSRR: GPIO port bit set/reset           register
  BSRR @offset 0x18 $u32 {
    BR15 // at 31: Port x reset bit y (y = 0..15)
    BR14 // at 30: Port x reset bit y (y = 0..15)
    BR13 // at 29: Port x reset bit y (y = 0..15)
    BR12 // at 28: Port x reset bit y (y = 0..15)
    BR11 // at 27: Port x reset bit y (y = 0..15)
    BR10 // at 26: Port x reset bit y (y = 0..15)
    BR9 // at 25: Port x reset bit y (y = 0..15)
    BR8 // at 24: Port x reset bit y (y = 0..15)
    BR7 // at 23: Port x reset bit y (y = 0..15)
    BR6 // at 22: Port x reset bit y (y = 0..15)
    BR5 // at 21: Port x reset bit y (y = 0..15)
    BR4 // at 20: Port x reset bit y (y = 0..15)
    BR3 // at 19: Port x reset bit y (y = 0..15)
    BR2 // at 18: Port x reset bit y (y = 0..15)
    BR1 // at 17: Port x reset bit y (y = 0..15)
    BR0 // at 16: Port x set bit y (y= 0..15)
    BS15 // at 15: Port x set bit y (y= 0..15)
    BS14 // at 14: Port x set bit y (y= 0..15)
    BS13 // at 13: Port x set bit y (y= 0..15)
    BS12 // at 12: Port x set bit y (y= 0..15)
    BS11 // at 11: Port x set bit y (y= 0..15)
    BS10 // at 10: Port x set bit y (y= 0..15)
    BS9 // at 9: Port x set bit y (y= 0..15)
    BS8 // at 8: Port x set bit y (y= 0..15)
    BS7 // at 7: Port x set bit y (y= 0..15)
    BS6 // at 6: Port x set bit y (y= 0..15)
    BS5 // at 5: Port x set bit y (y= 0..15)
    BS4 // at 4: Port x set bit y (y= 0..15)
    BS3 // at 3: Port x set bit y (y= 0..15)
    BS2 // at 2: Port x set bit y (y= 0..15)
    BS1 // at 1: Port x set bit y (y= 0..15)
    BS0 // at 0: Port x set bit y (y= 0..15)
  }

//---  Register LCKR: GPIO port configuration lock           register
  LCKR @offset 0x1c $u32 {
    15
    LCKK // at 16: Port x lock bit y (y= 0..15)
    LCK15 // at 15: Port x lock bit y (y= 0..15)
    LCK14 // at 14: Port x lock bit y (y= 0..15)
    LCK13 // at 13: Port x lock bit y (y= 0..15)
    LCK12 // at 12: Port x lock bit y (y= 0..15)
    LCK11 // at 11: Port x lock bit y (y= 0..15)
    LCK10 // at 10: Port x lock bit y (y= 0..15)
    LCK9 // at 9: Port x lock bit y (y= 0..15)
    LCK8 // at 8: Port x lock bit y (y= 0..15)
    LCK7 // at 7: Port x lock bit y (y= 0..15)
    LCK6 // at 6: Port x lock bit y (y= 0..15)
    LCK5 // at 5: Port x lock bit y (y= 0..15)
    LCK4 // at 4: Port x lock bit y (y= 0..15)
    LCK3 // at 3: Port x lock bit y (y= 0..15)
    LCK2 // at 2: Port x lock bit y (y= 0..15)
    LCK1 // at 1: Port x lock bit y (y= 0..15)
    LCK0 // at 0: Port x lock bit y (y= 0..15)
  }

//---  Register AFRL: GPIO alternate function low           register
  AFRL @offset 0x20 $u32 {
    AFRL7:4 // at 28: Alternate function selection for port x bit y (y = 0..7)
    AFRL6:4 // at 24: Alternate function selection for port x bit y (y = 0..7)
    AFRL5:4 // at 20: Alternate function selection for port x bit y (y = 0..7)
    AFRL4:4 // at 16: Alternate function selection for port x bit y (y = 0..7)
    AFRL3:4 // at 12: Alternate function selection for port x bit y (y = 0..7)
    AFRL2:4 // at 8: Alternate function selection for port x bit y (y = 0..7)
    AFRL1:4 // at 4: Alternate function selection for port x bit y (y = 0..7)
    AFRL0:4 // at 0: Alternate function selection for port x bit y (y = 0..7)
  }

//---  Register AFRH: GPIO alternate function high           register
  AFRH @offset 0x24 $u32 {
    AFRH15:4 // at 28: Alternate function selection for port x bit y (y = 8..15)
    AFRH14:4 // at 24: Alternate function selection for port x bit y (y = 8..15)
    AFRH13:4 // at 20: Alternate function selection for port x bit y (y = 8..15)
    AFRH12:4 // at 16: Alternate function selection for port x bit y (y = 8..15)
    AFRH11:4 // at 12: Alternate function selection for port x bit y (y = 8..15)
    AFRH10:4 // at 8: Alternate function selection for port x bit y (y = 8..15)
    AFRH9:4 // at 4: Alternate function selection for port x bit y (y = 8..15)
    AFRH8:4 // at 0: Alternate function selection for port x bit y (y = 8..15)
  }

}

//------------------------------------------------------------------------------
// Peripheral GPIOE
//------------------------------------------------------------------------------

registers ©GPIOE @at 0x48001000 {
//---  Register MODER: GPIO port mode register
  MODER @offset 0x0 $u32 {
    MODER15:2 // at 30: Port x configuration bits (y = 0..15)
    MODER14:2 // at 28: Port x configuration bits (y = 0..15)
    MODER13:2 // at 26: Port x configuration bits (y = 0..15)
    MODER12:2 // at 24: Port x configuration bits (y = 0..15)
    MODER11:2 // at 22: Port x configuration bits (y = 0..15)
    MODER10:2 // at 20: Port x configuration bits (y = 0..15)
    MODER9:2 // at 18: Port x configuration bits (y = 0..15)
    MODER8:2 // at 16: Port x configuration bits (y = 0..15)
    MODER7:2 // at 14: Port x configuration bits (y = 0..15)
    MODER6:2 // at 12: Port x configuration bits (y = 0..15)
    MODER5:2 // at 10: Port x configuration bits (y = 0..15)
    MODER4:2 // at 8: Port x configuration bits (y = 0..15)
    MODER3:2 // at 6: Port x configuration bits (y = 0..15)
    MODER2:2 // at 4: Port x configuration bits (y = 0..15)
    MODER1:2 // at 2: Port x configuration bits (y = 0..15)
    MODER0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OTYPER: GPIO port output type register
  OTYPER @offset 0x4 $u32 {
    16
    OT15 // at 15: Port x configuration bits (y = 0..15)
    OT14 // at 14: Port x configuration bits (y = 0..15)
    OT13 // at 13: Port x configuration bits (y = 0..15)
    OT12 // at 12: Port x configuration bits (y = 0..15)
    OT11 // at 11: Port x configuration bits (y = 0..15)
    OT10 // at 10: Port x configuration bits (y = 0..15)
    OT9 // at 9: Port x configuration bits (y = 0..15)
    OT8 // at 8: Port x configuration bits (y = 0..15)
    OT7 // at 7: Port x configuration bits (y = 0..15)
    OT6 // at 6: Port x configuration bits (y = 0..15)
    OT5 // at 5: Port x configuration bits (y = 0..15)
    OT4 // at 4: Port x configuration bits (y = 0..15)
    OT3 // at 3: Port x configuration bits (y = 0..15)
    OT2 // at 2: Port x configuration bits (y = 0..15)
    OT1 // at 1: Port x configuration bits (y = 0..15)
    OT0 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OSPEEDR: GPIO port output speed           register
  OSPEEDR @offset 0x8 $u32 {
    OSPEEDR15:2 // at 30: Port x configuration bits (y = 0..15)
    OSPEEDR14:2 // at 28: Port x configuration bits (y = 0..15)
    OSPEEDR13:2 // at 26: Port x configuration bits (y = 0..15)
    OSPEEDR12:2 // at 24: Port x configuration bits (y = 0..15)
    OSPEEDR11:2 // at 22: Port x configuration bits (y = 0..15)
    OSPEEDR10:2 // at 20: Port x configuration bits (y = 0..15)
    OSPEEDR9:2 // at 18: Port x configuration bits (y = 0..15)
    OSPEEDR8:2 // at 16: Port x configuration bits (y = 0..15)
    OSPEEDR7:2 // at 14: Port x configuration bits (y = 0..15)
    OSPEEDR6:2 // at 12: Port x configuration bits (y = 0..15)
    OSPEEDR5:2 // at 10: Port x configuration bits (y = 0..15)
    OSPEEDR4:2 // at 8: Port x configuration bits (y = 0..15)
    OSPEEDR3:2 // at 6: Port x configuration bits (y = 0..15)
    OSPEEDR2:2 // at 4: Port x configuration bits (y = 0..15)
    OSPEEDR1:2 // at 2: Port x configuration bits (y = 0..15)
    OSPEEDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register PUPDR: GPIO port pull-up/pull-down           register
  PUPDR @offset 0xc $u32 {
    PUPDR15:2 // at 30: Port x configuration bits (y = 0..15)
    PUPDR14:2 // at 28: Port x configuration bits (y = 0..15)
    PUPDR13:2 // at 26: Port x configuration bits (y = 0..15)
    PUPDR12:2 // at 24: Port x configuration bits (y = 0..15)
    PUPDR11:2 // at 22: Port x configuration bits (y = 0..15)
    PUPDR10:2 // at 20: Port x configuration bits (y = 0..15)
    PUPDR9:2 // at 18: Port x configuration bits (y = 0..15)
    PUPDR8:2 // at 16: Port x configuration bits (y = 0..15)
    PUPDR7:2 // at 14: Port x configuration bits (y = 0..15)
    PUPDR6:2 // at 12: Port x configuration bits (y = 0..15)
    PUPDR5:2 // at 10: Port x configuration bits (y = 0..15)
    PUPDR4:2 // at 8: Port x configuration bits (y = 0..15)
    PUPDR3:2 // at 6: Port x configuration bits (y = 0..15)
    PUPDR2:2 // at 4: Port x configuration bits (y = 0..15)
    PUPDR1:2 // at 2: Port x configuration bits (y = 0..15)
    PUPDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register IDR: GPIO port input data register
  IDR @offset 0x10 @ro $u32 {
    16
    IDR15 // at 15: Port input data (y = 0..15)
    IDR14 // at 14: Port input data (y = 0..15)
    IDR13 // at 13: Port input data (y = 0..15)
    IDR12 // at 12: Port input data (y = 0..15)
    IDR11 // at 11: Port input data (y = 0..15)
    IDR10 // at 10: Port input data (y = 0..15)
    IDR9 // at 9: Port input data (y = 0..15)
    IDR8 // at 8: Port input data (y = 0..15)
    IDR7 // at 7: Port input data (y = 0..15)
    IDR6 // at 6: Port input data (y = 0..15)
    IDR5 // at 5: Port input data (y = 0..15)
    IDR4 // at 4: Port input data (y = 0..15)
    IDR3 // at 3: Port input data (y = 0..15)
    IDR2 // at 2: Port input data (y = 0..15)
    IDR1 // at 1: Port input data (y = 0..15)
    IDR0 // at 0: Port input data (y = 0..15)
  }

//---  Register ODR: GPIO port output data register
  ODR @offset 0x14 $u32 {
    16
    ODR15 // at 15: Port output data (y = 0..15)
    ODR14 // at 14: Port output data (y = 0..15)
    ODR13 // at 13: Port output data (y = 0..15)
    ODR12 // at 12: Port output data (y = 0..15)
    ODR11 // at 11: Port output data (y = 0..15)
    ODR10 // at 10: Port output data (y = 0..15)
    ODR9 // at 9: Port output data (y = 0..15)
    ODR8 // at 8: Port output data (y = 0..15)
    ODR7 // at 7: Port output data (y = 0..15)
    ODR6 // at 6: Port output data (y = 0..15)
    ODR5 // at 5: Port output data (y = 0..15)
    ODR4 // at 4: Port output data (y = 0..15)
    ODR3 // at 3: Port output data (y = 0..15)
    ODR2 // at 2: Port output data (y = 0..15)
    ODR1 // at 1: Port output data (y = 0..15)
    ODR0 // at 0: Port output data (y = 0..15)
  }

//---  Register BSRR: GPIO port bit set/reset           register
  BSRR @offset 0x18 $u32 {
    BR15 // at 31: Port x reset bit y (y = 0..15)
    BR14 // at 30: Port x reset bit y (y = 0..15)
    BR13 // at 29: Port x reset bit y (y = 0..15)
    BR12 // at 28: Port x reset bit y (y = 0..15)
    BR11 // at 27: Port x reset bit y (y = 0..15)
    BR10 // at 26: Port x reset bit y (y = 0..15)
    BR9 // at 25: Port x reset bit y (y = 0..15)
    BR8 // at 24: Port x reset bit y (y = 0..15)
    BR7 // at 23: Port x reset bit y (y = 0..15)
    BR6 // at 22: Port x reset bit y (y = 0..15)
    BR5 // at 21: Port x reset bit y (y = 0..15)
    BR4 // at 20: Port x reset bit y (y = 0..15)
    BR3 // at 19: Port x reset bit y (y = 0..15)
    BR2 // at 18: Port x reset bit y (y = 0..15)
    BR1 // at 17: Port x reset bit y (y = 0..15)
    BR0 // at 16: Port x set bit y (y= 0..15)
    BS15 // at 15: Port x set bit y (y= 0..15)
    BS14 // at 14: Port x set bit y (y= 0..15)
    BS13 // at 13: Port x set bit y (y= 0..15)
    BS12 // at 12: Port x set bit y (y= 0..15)
    BS11 // at 11: Port x set bit y (y= 0..15)
    BS10 // at 10: Port x set bit y (y= 0..15)
    BS9 // at 9: Port x set bit y (y= 0..15)
    BS8 // at 8: Port x set bit y (y= 0..15)
    BS7 // at 7: Port x set bit y (y= 0..15)
    BS6 // at 6: Port x set bit y (y= 0..15)
    BS5 // at 5: Port x set bit y (y= 0..15)
    BS4 // at 4: Port x set bit y (y= 0..15)
    BS3 // at 3: Port x set bit y (y= 0..15)
    BS2 // at 2: Port x set bit y (y= 0..15)
    BS1 // at 1: Port x set bit y (y= 0..15)
    BS0 // at 0: Port x set bit y (y= 0..15)
  }

//---  Register LCKR: GPIO port configuration lock           register
  LCKR @offset 0x1c $u32 {
    15
    LCKK // at 16: Port x lock bit y (y= 0..15)
    LCK15 // at 15: Port x lock bit y (y= 0..15)
    LCK14 // at 14: Port x lock bit y (y= 0..15)
    LCK13 // at 13: Port x lock bit y (y= 0..15)
    LCK12 // at 12: Port x lock bit y (y= 0..15)
    LCK11 // at 11: Port x lock bit y (y= 0..15)
    LCK10 // at 10: Port x lock bit y (y= 0..15)
    LCK9 // at 9: Port x lock bit y (y= 0..15)
    LCK8 // at 8: Port x lock bit y (y= 0..15)
    LCK7 // at 7: Port x lock bit y (y= 0..15)
    LCK6 // at 6: Port x lock bit y (y= 0..15)
    LCK5 // at 5: Port x lock bit y (y= 0..15)
    LCK4 // at 4: Port x lock bit y (y= 0..15)
    LCK3 // at 3: Port x lock bit y (y= 0..15)
    LCK2 // at 2: Port x lock bit y (y= 0..15)
    LCK1 // at 1: Port x lock bit y (y= 0..15)
    LCK0 // at 0: Port x lock bit y (y= 0..15)
  }

//---  Register AFRL: GPIO alternate function low           register
  AFRL @offset 0x20 $u32 {
    AFRL7:4 // at 28: Alternate function selection for port x bit y (y = 0..7)
    AFRL6:4 // at 24: Alternate function selection for port x bit y (y = 0..7)
    AFRL5:4 // at 20: Alternate function selection for port x bit y (y = 0..7)
    AFRL4:4 // at 16: Alternate function selection for port x bit y (y = 0..7)
    AFRL3:4 // at 12: Alternate function selection for port x bit y (y = 0..7)
    AFRL2:4 // at 8: Alternate function selection for port x bit y (y = 0..7)
    AFRL1:4 // at 4: Alternate function selection for port x bit y (y = 0..7)
    AFRL0:4 // at 0: Alternate function selection for port x bit y (y = 0..7)
  }

//---  Register AFRH: GPIO alternate function high           register
  AFRH @offset 0x24 $u32 {
    AFRH15:4 // at 28: Alternate function selection for port x bit y (y = 8..15)
    AFRH14:4 // at 24: Alternate function selection for port x bit y (y = 8..15)
    AFRH13:4 // at 20: Alternate function selection for port x bit y (y = 8..15)
    AFRH12:4 // at 16: Alternate function selection for port x bit y (y = 8..15)
    AFRH11:4 // at 12: Alternate function selection for port x bit y (y = 8..15)
    AFRH10:4 // at 8: Alternate function selection for port x bit y (y = 8..15)
    AFRH9:4 // at 4: Alternate function selection for port x bit y (y = 8..15)
    AFRH8:4 // at 0: Alternate function selection for port x bit y (y = 8..15)
  }

}

//------------------------------------------------------------------------------
// Peripheral GPIOH
//------------------------------------------------------------------------------

registers ©GPIOH @at 0x48001c00 {
//---  Register MODER: GPIO port mode register
  MODER @offset 0x0 $u32 {
    MODER15:2 // at 30: Port x configuration bits (y = 0..15)
    MODER14:2 // at 28: Port x configuration bits (y = 0..15)
    MODER13:2 // at 26: Port x configuration bits (y = 0..15)
    MODER12:2 // at 24: Port x configuration bits (y = 0..15)
    MODER11:2 // at 22: Port x configuration bits (y = 0..15)
    MODER10:2 // at 20: Port x configuration bits (y = 0..15)
    MODER9:2 // at 18: Port x configuration bits (y = 0..15)
    MODER8:2 // at 16: Port x configuration bits (y = 0..15)
    MODER7:2 // at 14: Port x configuration bits (y = 0..15)
    MODER6:2 // at 12: Port x configuration bits (y = 0..15)
    MODER5:2 // at 10: Port x configuration bits (y = 0..15)
    MODER4:2 // at 8: Port x configuration bits (y = 0..15)
    MODER3:2 // at 6: Port x configuration bits (y = 0..15)
    MODER2:2 // at 4: Port x configuration bits (y = 0..15)
    MODER1:2 // at 2: Port x configuration bits (y = 0..15)
    MODER0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OTYPER: GPIO port output type register
  OTYPER @offset 0x4 $u32 {
    16
    OT15 // at 15: Port x configuration bits (y = 0..15)
    OT14 // at 14: Port x configuration bits (y = 0..15)
    OT13 // at 13: Port x configuration bits (y = 0..15)
    OT12 // at 12: Port x configuration bits (y = 0..15)
    OT11 // at 11: Port x configuration bits (y = 0..15)
    OT10 // at 10: Port x configuration bits (y = 0..15)
    OT9 // at 9: Port x configuration bits (y = 0..15)
    OT8 // at 8: Port x configuration bits (y = 0..15)
    OT7 // at 7: Port x configuration bits (y = 0..15)
    OT6 // at 6: Port x configuration bits (y = 0..15)
    OT5 // at 5: Port x configuration bits (y = 0..15)
    OT4 // at 4: Port x configuration bits (y = 0..15)
    OT3 // at 3: Port x configuration bits (y = 0..15)
    OT2 // at 2: Port x configuration bits (y = 0..15)
    OT1 // at 1: Port x configuration bits (y = 0..15)
    OT0 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register OSPEEDR: GPIO port output speed           register
  OSPEEDR @offset 0x8 $u32 {
    OSPEEDR15:2 // at 30: Port x configuration bits (y = 0..15)
    OSPEEDR14:2 // at 28: Port x configuration bits (y = 0..15)
    OSPEEDR13:2 // at 26: Port x configuration bits (y = 0..15)
    OSPEEDR12:2 // at 24: Port x configuration bits (y = 0..15)
    OSPEEDR11:2 // at 22: Port x configuration bits (y = 0..15)
    OSPEEDR10:2 // at 20: Port x configuration bits (y = 0..15)
    OSPEEDR9:2 // at 18: Port x configuration bits (y = 0..15)
    OSPEEDR8:2 // at 16: Port x configuration bits (y = 0..15)
    OSPEEDR7:2 // at 14: Port x configuration bits (y = 0..15)
    OSPEEDR6:2 // at 12: Port x configuration bits (y = 0..15)
    OSPEEDR5:2 // at 10: Port x configuration bits (y = 0..15)
    OSPEEDR4:2 // at 8: Port x configuration bits (y = 0..15)
    OSPEEDR3:2 // at 6: Port x configuration bits (y = 0..15)
    OSPEEDR2:2 // at 4: Port x configuration bits (y = 0..15)
    OSPEEDR1:2 // at 2: Port x configuration bits (y = 0..15)
    OSPEEDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register PUPDR: GPIO port pull-up/pull-down           register
  PUPDR @offset 0xc $u32 {
    PUPDR15:2 // at 30: Port x configuration bits (y = 0..15)
    PUPDR14:2 // at 28: Port x configuration bits (y = 0..15)
    PUPDR13:2 // at 26: Port x configuration bits (y = 0..15)
    PUPDR12:2 // at 24: Port x configuration bits (y = 0..15)
    PUPDR11:2 // at 22: Port x configuration bits (y = 0..15)
    PUPDR10:2 // at 20: Port x configuration bits (y = 0..15)
    PUPDR9:2 // at 18: Port x configuration bits (y = 0..15)
    PUPDR8:2 // at 16: Port x configuration bits (y = 0..15)
    PUPDR7:2 // at 14: Port x configuration bits (y = 0..15)
    PUPDR6:2 // at 12: Port x configuration bits (y = 0..15)
    PUPDR5:2 // at 10: Port x configuration bits (y = 0..15)
    PUPDR4:2 // at 8: Port x configuration bits (y = 0..15)
    PUPDR3:2 // at 6: Port x configuration bits (y = 0..15)
    PUPDR2:2 // at 4: Port x configuration bits (y = 0..15)
    PUPDR1:2 // at 2: Port x configuration bits (y = 0..15)
    PUPDR0:2 // at 0: Port x configuration bits (y = 0..15)
  }

//---  Register IDR: GPIO port input data register
  IDR @offset 0x10 @ro $u32 {
    16
    IDR15 // at 15: Port input data (y = 0..15)
    IDR14 // at 14: Port input data (y = 0..15)
    IDR13 // at 13: Port input data (y = 0..15)
    IDR12 // at 12: Port input data (y = 0..15)
    IDR11 // at 11: Port input data (y = 0..15)
    IDR10 // at 10: Port input data (y = 0..15)
    IDR9 // at 9: Port input data (y = 0..15)
    IDR8 // at 8: Port input data (y = 0..15)
    IDR7 // at 7: Port input data (y = 0..15)
    IDR6 // at 6: Port input data (y = 0..15)
    IDR5 // at 5: Port input data (y = 0..15)
    IDR4 // at 4: Port input data (y = 0..15)
    IDR3 // at 3: Port input data (y = 0..15)
    IDR2 // at 2: Port input data (y = 0..15)
    IDR1 // at 1: Port input data (y = 0..15)
    IDR0 // at 0: Port input data (y = 0..15)
  }

//---  Register ODR: GPIO port output data register
  ODR @offset 0x14 $u32 {
    16
    ODR15 // at 15: Port output data (y = 0..15)
    ODR14 // at 14: Port output data (y = 0..15)
    ODR13 // at 13: Port output data (y = 0..15)
    ODR12 // at 12: Port output data (y = 0..15)
    ODR11 // at 11: Port output data (y = 0..15)
    ODR10 // at 10: Port output data (y = 0..15)
    ODR9 // at 9: Port output data (y = 0..15)
    ODR8 // at 8: Port output data (y = 0..15)
    ODR7 // at 7: Port output data (y = 0..15)
    ODR6 // at 6: Port output data (y = 0..15)
    ODR5 // at 5: Port output data (y = 0..15)
    ODR4 // at 4: Port output data (y = 0..15)
    ODR3 // at 3: Port output data (y = 0..15)
    ODR2 // at 2: Port output data (y = 0..15)
    ODR1 // at 1: Port output data (y = 0..15)
    ODR0 // at 0: Port output data (y = 0..15)
  }

//---  Register BSRR: GPIO port bit set/reset           register
  BSRR @offset 0x18 $u32 {
    BR15 // at 31: Port x reset bit y (y = 0..15)
    BR14 // at 30: Port x reset bit y (y = 0..15)
    BR13 // at 29: Port x reset bit y (y = 0..15)
    BR12 // at 28: Port x reset bit y (y = 0..15)
    BR11 // at 27: Port x reset bit y (y = 0..15)
    BR10 // at 26: Port x reset bit y (y = 0..15)
    BR9 // at 25: Port x reset bit y (y = 0..15)
    BR8 // at 24: Port x reset bit y (y = 0..15)
    BR7 // at 23: Port x reset bit y (y = 0..15)
    BR6 // at 22: Port x reset bit y (y = 0..15)
    BR5 // at 21: Port x reset bit y (y = 0..15)
    BR4 // at 20: Port x reset bit y (y = 0..15)
    BR3 // at 19: Port x reset bit y (y = 0..15)
    BR2 // at 18: Port x reset bit y (y = 0..15)
    BR1 // at 17: Port x reset bit y (y = 0..15)
    BR0 // at 16: Port x set bit y (y= 0..15)
    BS15 // at 15: Port x set bit y (y= 0..15)
    BS14 // at 14: Port x set bit y (y= 0..15)
    BS13 // at 13: Port x set bit y (y= 0..15)
    BS12 // at 12: Port x set bit y (y= 0..15)
    BS11 // at 11: Port x set bit y (y= 0..15)
    BS10 // at 10: Port x set bit y (y= 0..15)
    BS9 // at 9: Port x set bit y (y= 0..15)
    BS8 // at 8: Port x set bit y (y= 0..15)
    BS7 // at 7: Port x set bit y (y= 0..15)
    BS6 // at 6: Port x set bit y (y= 0..15)
    BS5 // at 5: Port x set bit y (y= 0..15)
    BS4 // at 4: Port x set bit y (y= 0..15)
    BS3 // at 3: Port x set bit y (y= 0..15)
    BS2 // at 2: Port x set bit y (y= 0..15)
    BS1 // at 1: Port x set bit y (y= 0..15)
    BS0 // at 0: Port x set bit y (y= 0..15)
  }

//---  Register LCKR: GPIO port configuration lock           register
  LCKR @offset 0x1c $u32 {
    15
    LCKK // at 16: Port x lock bit y (y= 0..15)
    LCK15 // at 15: Port x lock bit y (y= 0..15)
    LCK14 // at 14: Port x lock bit y (y= 0..15)
    LCK13 // at 13: Port x lock bit y (y= 0..15)
    LCK12 // at 12: Port x lock bit y (y= 0..15)
    LCK11 // at 11: Port x lock bit y (y= 0..15)
    LCK10 // at 10: Port x lock bit y (y= 0..15)
    LCK9 // at 9: Port x lock bit y (y= 0..15)
    LCK8 // at 8: Port x lock bit y (y= 0..15)
    LCK7 // at 7: Port x lock bit y (y= 0..15)
    LCK6 // at 6: Port x lock bit y (y= 0..15)
    LCK5 // at 5: Port x lock bit y (y= 0..15)
    LCK4 // at 4: Port x lock bit y (y= 0..15)
    LCK3 // at 3: Port x lock bit y (y= 0..15)
    LCK2 // at 2: Port x lock bit y (y= 0..15)
    LCK1 // at 1: Port x lock bit y (y= 0..15)
    LCK0 // at 0: Port x lock bit y (y= 0..15)
  }

//---  Register AFRL: GPIO alternate function low           register
  AFRL @offset 0x20 $u32 {
    AFRL7:4 // at 28: Alternate function selection for port x bit y (y = 0..7)
    AFRL6:4 // at 24: Alternate function selection for port x bit y (y = 0..7)
    AFRL5:4 // at 20: Alternate function selection for port x bit y (y = 0..7)
    AFRL4:4 // at 16: Alternate function selection for port x bit y (y = 0..7)
    AFRL3:4 // at 12: Alternate function selection for port x bit y (y = 0..7)
    AFRL2:4 // at 8: Alternate function selection for port x bit y (y = 0..7)
    AFRL1:4 // at 4: Alternate function selection for port x bit y (y = 0..7)
    AFRL0:4 // at 0: Alternate function selection for port x bit y (y = 0..7)
  }

//---  Register AFRH: GPIO alternate function high           register
  AFRH @offset 0x24 $u32 {
    AFRH15:4 // at 28: Alternate function selection for port x bit y (y = 8..15)
    AFRH14:4 // at 24: Alternate function selection for port x bit y (y = 8..15)
    AFRH13:4 // at 20: Alternate function selection for port x bit y (y = 8..15)
    AFRH12:4 // at 16: Alternate function selection for port x bit y (y = 8..15)
    AFRH11:4 // at 12: Alternate function selection for port x bit y (y = 8..15)
    AFRH10:4 // at 8: Alternate function selection for port x bit y (y = 8..15)
    AFRH9:4 // at 4: Alternate function selection for port x bit y (y = 8..15)
    AFRH8:4 // at 0: Alternate function selection for port x bit y (y = 8..15)
  }

}

//------------------------------------------------------------------------------
// Peripheral I2C1: Inter-integrated circuit
//------------------------------------------------------------------------------

registers ©I2C1 @at 0x40005400 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    8
    PECEN // at 23: PEC enable
    ALERTEN // at 22: SMBUS alert enable
    SMBDEN // at 21: SMBus Device Default address enable
    SMBHEN // at 20: SMBus Host address enable
    GCEN // at 19: General call enable
    WUPEN // at 18: Wakeup from STOP enable
    NOSTRETCH // at 17: Clock stretching disable
    SBC // at 16: Slave byte control
    RXDMAEN // at 15: DMA reception requests enable
    TXDMAEN // at 14: DMA transmission requests enable
    1
    ANFOFF // at 12: Analog noise filter OFF
    DNF:4 // at 8: Digital noise filter
    ERRIE // at 7: Error interrupts enable
    TCIE // at 6: Transfer Complete interrupt enable
    STOPIE // at 5: STOP detection Interrupt enable
    NACKIE // at 4: Not acknowledge received interrupt enable
    ADDRIE // at 3: Address match interrupt enable (slave only)
    RXIE // at 2: RX Interrupt enable
    TXIE // at 1: TX Interrupt enable
    PE // at 0: Peripheral enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    5
    PECBYTE // at 26: Packet error checking byte
    AUTOEND // at 25: Automatic end mode (master mode)
    RELOAD // at 24: NBYTES reload mode
    NBYTES:8 // at 16: Number of bytes
    NACK // at 15: NACK generation (slave mode)
    STOP // at 14: Stop generation (master mode)
    START // at 13: Start generation
    HEAD10R // at 12: 10-bit address header only read direction (master receiver mode)
    ADD10 // at 11: 10-bit addressing mode (master mode)
    RD_WRN // at 10: Transfer direction (master mode)
    SADD:10 // at 0: Slave address bit (master mode)
  }

//---  Register OAR1: Own address register 1
  OAR1 @offset 0x8 $u32 {
    16
    OA1EN // at 15: Own Address 1 enable
    4
    OA1MODE // at 10: Own Address 1 10-bit mode
    OA1:10 // at 0: Interface address
  }

//---  Register OAR2: Own address register 2
  OAR2 @offset 0xc $u32 {
    16
    OA2EN // at 15: Own Address 2 enable
    4
    OA2MSK:3 // at 8: Own Address 2 masks
    OA2:7 // at 1: Interface address
    1
  }

//---  Register TIMINGR: Timing register
  TIMINGR @offset 0x10 $u32 {
    PRESC:4 // at 28: Timing prescaler
    4
    SCLDEL:4 // at 20: Data setup time
    SDADEL:4 // at 16: Data hold time
    SCLH:8 // at 8: SCL high period (master mode)
    SCLL:8 // at 0: SCL low period (master mode)
  }

//---  Register TIMEOUTR: Status register 1
  TIMEOUTR @offset 0x14 $u32 {
    TEXTEN // at 31: Extended clock timeout enable
    3
    TIMEOUTB:12 // at 16: Bus timeout B
    TIMOUTEN // at 15: Clock timeout enable
    2
    TIDLE // at 12: Idle clock timeout detection
    TIMEOUTA:12 // at 0: Bus timeout A
  }

//---  Register ISR: Interrupt and Status register
  ISR @offset 0x18 $u32 {
    8
    ADDCODE:7 // at 17: Address match code (Slave mode)
    DIR // at 16: Transfer direction (Slave mode)
    BUSY // at 15: Bus busy
    1
    ALERT // at 13: SMBus alert
    TIMEOUT // at 12: Timeout or t_low detection flag
    PECERR // at 11: PEC Error in reception
    OVR // at 10: Overrun/Underrun (slave mode)
    ARLO // at 9: Arbitration lost
    BERR // at 8: Bus error
    TCR // at 7: Transfer Complete Reload
    TC // at 6: Transfer Complete (master mode)
    STOPF // at 5: Stop detection flag
    NACKF // at 4: Not acknowledge received flag
    ADDR // at 3: Address matched (slave mode)
    RXNE // at 2: Receive data register not empty (receivers)
    TXIS // at 1: Transmit interrupt status (transmitters)
    TXE // at 0: Transmit data register empty (transmitters)
  }

//---  Register ICR: Interrupt clear register
  ICR @offset 0x1c $u32 {
    18
    ALERTCF // at 13: Alert flag clear
    TIMOUTCF // at 12: Timeout detection flag clear
    PECCF // at 11: PEC Error flag clear
    OVRCF // at 10: Overrun/Underrun flag clear
    ARLOCF // at 9: Arbitration lost flag clear
    BERRCF // at 8: Bus error flag clear
    2
    STOPCF // at 5: Stop detection flag clear
    NACKCF // at 4: Not Acknowledge flag clear
    ADDRCF // at 3: Address Matched flag clear
    3
  }

//---  Register PECR: PEC register
  PECR @offset 0x20 @ro $u32 {
    24
    PEC:8 // at 0: Packet error checking register
  }

//---  Register RXDR: Receive data register
  RXDR @offset 0x24 @ro $u32 {
    24
    RXDATA:8 // at 0: 8-bit receive data
  }

//---  Register TXDR: Transmit data register
  TXDR @offset 0x28 $u32 {
    24
    TXDATA:8 // at 0: 8-bit transmit data
  }

}

//------------------------------------------------------------------------------
// Peripheral I2C2
//------------------------------------------------------------------------------

registers ©I2C2 @at 0x40005800 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    8
    PECEN // at 23: PEC enable
    ALERTEN // at 22: SMBUS alert enable
    SMBDEN // at 21: SMBus Device Default address enable
    SMBHEN // at 20: SMBus Host address enable
    GCEN // at 19: General call enable
    WUPEN // at 18: Wakeup from STOP enable
    NOSTRETCH // at 17: Clock stretching disable
    SBC // at 16: Slave byte control
    RXDMAEN // at 15: DMA reception requests enable
    TXDMAEN // at 14: DMA transmission requests enable
    1
    ANFOFF // at 12: Analog noise filter OFF
    DNF:4 // at 8: Digital noise filter
    ERRIE // at 7: Error interrupts enable
    TCIE // at 6: Transfer Complete interrupt enable
    STOPIE // at 5: STOP detection Interrupt enable
    NACKIE // at 4: Not acknowledge received interrupt enable
    ADDRIE // at 3: Address match interrupt enable (slave only)
    RXIE // at 2: RX Interrupt enable
    TXIE // at 1: TX Interrupt enable
    PE // at 0: Peripheral enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    5
    PECBYTE // at 26: Packet error checking byte
    AUTOEND // at 25: Automatic end mode (master mode)
    RELOAD // at 24: NBYTES reload mode
    NBYTES:8 // at 16: Number of bytes
    NACK // at 15: NACK generation (slave mode)
    STOP // at 14: Stop generation (master mode)
    START // at 13: Start generation
    HEAD10R // at 12: 10-bit address header only read direction (master receiver mode)
    ADD10 // at 11: 10-bit addressing mode (master mode)
    RD_WRN // at 10: Transfer direction (master mode)
    SADD:10 // at 0: Slave address bit (master mode)
  }

//---  Register OAR1: Own address register 1
  OAR1 @offset 0x8 $u32 {
    16
    OA1EN // at 15: Own Address 1 enable
    4
    OA1MODE // at 10: Own Address 1 10-bit mode
    OA1:10 // at 0: Interface address
  }

//---  Register OAR2: Own address register 2
  OAR2 @offset 0xc $u32 {
    16
    OA2EN // at 15: Own Address 2 enable
    4
    OA2MSK:3 // at 8: Own Address 2 masks
    OA2:7 // at 1: Interface address
    1
  }

//---  Register TIMINGR: Timing register
  TIMINGR @offset 0x10 $u32 {
    PRESC:4 // at 28: Timing prescaler
    4
    SCLDEL:4 // at 20: Data setup time
    SDADEL:4 // at 16: Data hold time
    SCLH:8 // at 8: SCL high period (master mode)
    SCLL:8 // at 0: SCL low period (master mode)
  }

//---  Register TIMEOUTR: Status register 1
  TIMEOUTR @offset 0x14 $u32 {
    TEXTEN // at 31: Extended clock timeout enable
    3
    TIMEOUTB:12 // at 16: Bus timeout B
    TIMOUTEN // at 15: Clock timeout enable
    2
    TIDLE // at 12: Idle clock timeout detection
    TIMEOUTA:12 // at 0: Bus timeout A
  }

//---  Register ISR: Interrupt and Status register
  ISR @offset 0x18 $u32 {
    8
    ADDCODE:7 // at 17: Address match code (Slave mode)
    DIR // at 16: Transfer direction (Slave mode)
    BUSY // at 15: Bus busy
    1
    ALERT // at 13: SMBus alert
    TIMEOUT // at 12: Timeout or t_low detection flag
    PECERR // at 11: PEC Error in reception
    OVR // at 10: Overrun/Underrun (slave mode)
    ARLO // at 9: Arbitration lost
    BERR // at 8: Bus error
    TCR // at 7: Transfer Complete Reload
    TC // at 6: Transfer Complete (master mode)
    STOPF // at 5: Stop detection flag
    NACKF // at 4: Not acknowledge received flag
    ADDR // at 3: Address matched (slave mode)
    RXNE // at 2: Receive data register not empty (receivers)
    TXIS // at 1: Transmit interrupt status (transmitters)
    TXE // at 0: Transmit data register empty (transmitters)
  }

//---  Register ICR: Interrupt clear register
  ICR @offset 0x1c $u32 {
    18
    ALERTCF // at 13: Alert flag clear
    TIMOUTCF // at 12: Timeout detection flag clear
    PECCF // at 11: PEC Error flag clear
    OVRCF // at 10: Overrun/Underrun flag clear
    ARLOCF // at 9: Arbitration lost flag clear
    BERRCF // at 8: Bus error flag clear
    2
    STOPCF // at 5: Stop detection flag clear
    NACKCF // at 4: Not Acknowledge flag clear
    ADDRCF // at 3: Address Matched flag clear
    3
  }

//---  Register PECR: PEC register
  PECR @offset 0x20 @ro $u32 {
    24
    PEC:8 // at 0: Packet error checking register
  }

//---  Register RXDR: Receive data register
  RXDR @offset 0x24 @ro $u32 {
    24
    RXDATA:8 // at 0: 8-bit receive data
  }

//---  Register TXDR: Transmit data register
  TXDR @offset 0x28 $u32 {
    24
    TXDATA:8 // at 0: 8-bit transmit data
  }

}

//------------------------------------------------------------------------------
// Peripheral I2C3
//------------------------------------------------------------------------------

registers ©I2C3 @at 0x40005c00 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    8
    PECEN // at 23: PEC enable
    ALERTEN // at 22: SMBUS alert enable
    SMBDEN // at 21: SMBus Device Default address enable
    SMBHEN // at 20: SMBus Host address enable
    GCEN // at 19: General call enable
    WUPEN // at 18: Wakeup from STOP enable
    NOSTRETCH // at 17: Clock stretching disable
    SBC // at 16: Slave byte control
    RXDMAEN // at 15: DMA reception requests enable
    TXDMAEN // at 14: DMA transmission requests enable
    1
    ANFOFF // at 12: Analog noise filter OFF
    DNF:4 // at 8: Digital noise filter
    ERRIE // at 7: Error interrupts enable
    TCIE // at 6: Transfer Complete interrupt enable
    STOPIE // at 5: STOP detection Interrupt enable
    NACKIE // at 4: Not acknowledge received interrupt enable
    ADDRIE // at 3: Address match interrupt enable (slave only)
    RXIE // at 2: RX Interrupt enable
    TXIE // at 1: TX Interrupt enable
    PE // at 0: Peripheral enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    5
    PECBYTE // at 26: Packet error checking byte
    AUTOEND // at 25: Automatic end mode (master mode)
    RELOAD // at 24: NBYTES reload mode
    NBYTES:8 // at 16: Number of bytes
    NACK // at 15: NACK generation (slave mode)
    STOP // at 14: Stop generation (master mode)
    START // at 13: Start generation
    HEAD10R // at 12: 10-bit address header only read direction (master receiver mode)
    ADD10 // at 11: 10-bit addressing mode (master mode)
    RD_WRN // at 10: Transfer direction (master mode)
    SADD:10 // at 0: Slave address bit (master mode)
  }

//---  Register OAR1: Own address register 1
  OAR1 @offset 0x8 $u32 {
    16
    OA1EN // at 15: Own Address 1 enable
    4
    OA1MODE // at 10: Own Address 1 10-bit mode
    OA1:10 // at 0: Interface address
  }

//---  Register OAR2: Own address register 2
  OAR2 @offset 0xc $u32 {
    16
    OA2EN // at 15: Own Address 2 enable
    4
    OA2MSK:3 // at 8: Own Address 2 masks
    OA2:7 // at 1: Interface address
    1
  }

//---  Register TIMINGR: Timing register
  TIMINGR @offset 0x10 $u32 {
    PRESC:4 // at 28: Timing prescaler
    4
    SCLDEL:4 // at 20: Data setup time
    SDADEL:4 // at 16: Data hold time
    SCLH:8 // at 8: SCL high period (master mode)
    SCLL:8 // at 0: SCL low period (master mode)
  }

//---  Register TIMEOUTR: Status register 1
  TIMEOUTR @offset 0x14 $u32 {
    TEXTEN // at 31: Extended clock timeout enable
    3
    TIMEOUTB:12 // at 16: Bus timeout B
    TIMOUTEN // at 15: Clock timeout enable
    2
    TIDLE // at 12: Idle clock timeout detection
    TIMEOUTA:12 // at 0: Bus timeout A
  }

//---  Register ISR: Interrupt and Status register
  ISR @offset 0x18 $u32 {
    8
    ADDCODE:7 // at 17: Address match code (Slave mode)
    DIR // at 16: Transfer direction (Slave mode)
    BUSY // at 15: Bus busy
    1
    ALERT // at 13: SMBus alert
    TIMEOUT // at 12: Timeout or t_low detection flag
    PECERR // at 11: PEC Error in reception
    OVR // at 10: Overrun/Underrun (slave mode)
    ARLO // at 9: Arbitration lost
    BERR // at 8: Bus error
    TCR // at 7: Transfer Complete Reload
    TC // at 6: Transfer Complete (master mode)
    STOPF // at 5: Stop detection flag
    NACKF // at 4: Not acknowledge received flag
    ADDR // at 3: Address matched (slave mode)
    RXNE // at 2: Receive data register not empty (receivers)
    TXIS // at 1: Transmit interrupt status (transmitters)
    TXE // at 0: Transmit data register empty (transmitters)
  }

//---  Register ICR: Interrupt clear register
  ICR @offset 0x1c $u32 {
    18
    ALERTCF // at 13: Alert flag clear
    TIMOUTCF // at 12: Timeout detection flag clear
    PECCF // at 11: PEC Error flag clear
    OVRCF // at 10: Overrun/Underrun flag clear
    ARLOCF // at 9: Arbitration lost flag clear
    BERRCF // at 8: Bus error flag clear
    2
    STOPCF // at 5: Stop detection flag clear
    NACKCF // at 4: Not Acknowledge flag clear
    ADDRCF // at 3: Address Matched flag clear
    3
  }

//---  Register PECR: PEC register
  PECR @offset 0x20 @ro $u32 {
    24
    PEC:8 // at 0: Packet error checking register
  }

//---  Register RXDR: Receive data register
  RXDR @offset 0x24 @ro $u32 {
    24
    RXDATA:8 // at 0: 8-bit receive data
  }

//---  Register TXDR: Transmit data register
  TXDR @offset 0x28 $u32 {
    24
    TXDATA:8 // at 0: 8-bit transmit data
  }

}

//------------------------------------------------------------------------------
// Peripheral I2C4
//------------------------------------------------------------------------------

registers ©I2C4 @at 0x40008400 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    8
    PECEN // at 23: PEC enable
    ALERTEN // at 22: SMBUS alert enable
    SMBDEN // at 21: SMBus Device Default address enable
    SMBHEN // at 20: SMBus Host address enable
    GCEN // at 19: General call enable
    WUPEN // at 18: Wakeup from STOP enable
    NOSTRETCH // at 17: Clock stretching disable
    SBC // at 16: Slave byte control
    RXDMAEN // at 15: DMA reception requests enable
    TXDMAEN // at 14: DMA transmission requests enable
    1
    ANFOFF // at 12: Analog noise filter OFF
    DNF:4 // at 8: Digital noise filter
    ERRIE // at 7: Error interrupts enable
    TCIE // at 6: Transfer Complete interrupt enable
    STOPIE // at 5: STOP detection Interrupt enable
    NACKIE // at 4: Not acknowledge received interrupt enable
    ADDRIE // at 3: Address match interrupt enable (slave only)
    RXIE // at 2: RX Interrupt enable
    TXIE // at 1: TX Interrupt enable
    PE // at 0: Peripheral enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    5
    PECBYTE // at 26: Packet error checking byte
    AUTOEND // at 25: Automatic end mode (master mode)
    RELOAD // at 24: NBYTES reload mode
    NBYTES:8 // at 16: Number of bytes
    NACK // at 15: NACK generation (slave mode)
    STOP // at 14: Stop generation (master mode)
    START // at 13: Start generation
    HEAD10R // at 12: 10-bit address header only read direction (master receiver mode)
    ADD10 // at 11: 10-bit addressing mode (master mode)
    RD_WRN // at 10: Transfer direction (master mode)
    SADD:10 // at 0: Slave address bit (master mode)
  }

//---  Register OAR1: Own address register 1
  OAR1 @offset 0x8 $u32 {
    16
    OA1EN // at 15: Own Address 1 enable
    4
    OA1MODE // at 10: Own Address 1 10-bit mode
    OA1:10 // at 0: Interface address
  }

//---  Register OAR2: Own address register 2
  OAR2 @offset 0xc $u32 {
    16
    OA2EN // at 15: Own Address 2 enable
    4
    OA2MSK:3 // at 8: Own Address 2 masks
    OA2:7 // at 1: Interface address
    1
  }

//---  Register TIMINGR: Timing register
  TIMINGR @offset 0x10 $u32 {
    PRESC:4 // at 28: Timing prescaler
    4
    SCLDEL:4 // at 20: Data setup time
    SDADEL:4 // at 16: Data hold time
    SCLH:8 // at 8: SCL high period (master mode)
    SCLL:8 // at 0: SCL low period (master mode)
  }

//---  Register TIMEOUTR: Status register 1
  TIMEOUTR @offset 0x14 $u32 {
    TEXTEN // at 31: Extended clock timeout enable
    3
    TIMEOUTB:12 // at 16: Bus timeout B
    TIMOUTEN // at 15: Clock timeout enable
    2
    TIDLE // at 12: Idle clock timeout detection
    TIMEOUTA:12 // at 0: Bus timeout A
  }

//---  Register ISR: Interrupt and Status register
  ISR @offset 0x18 $u32 {
    8
    ADDCODE:7 // at 17: Address match code (Slave mode)
    DIR // at 16: Transfer direction (Slave mode)
    BUSY // at 15: Bus busy
    1
    ALERT // at 13: SMBus alert
    TIMEOUT // at 12: Timeout or t_low detection flag
    PECERR // at 11: PEC Error in reception
    OVR // at 10: Overrun/Underrun (slave mode)
    ARLO // at 9: Arbitration lost
    BERR // at 8: Bus error
    TCR // at 7: Transfer Complete Reload
    TC // at 6: Transfer Complete (master mode)
    STOPF // at 5: Stop detection flag
    NACKF // at 4: Not acknowledge received flag
    ADDR // at 3: Address matched (slave mode)
    RXNE // at 2: Receive data register not empty (receivers)
    TXIS // at 1: Transmit interrupt status (transmitters)
    TXE // at 0: Transmit data register empty (transmitters)
  }

//---  Register ICR: Interrupt clear register
  ICR @offset 0x1c $u32 {
    18
    ALERTCF // at 13: Alert flag clear
    TIMOUTCF // at 12: Timeout detection flag clear
    PECCF // at 11: PEC Error flag clear
    OVRCF // at 10: Overrun/Underrun flag clear
    ARLOCF // at 9: Arbitration lost flag clear
    BERRCF // at 8: Bus error flag clear
    2
    STOPCF // at 5: Stop detection flag clear
    NACKCF // at 4: Not Acknowledge flag clear
    ADDRCF // at 3: Address Matched flag clear
    3
  }

//---  Register PECR: PEC register
  PECR @offset 0x20 @ro $u32 {
    24
    PEC:8 // at 0: Packet error checking register
  }

//---  Register RXDR: Receive data register
  RXDR @offset 0x24 @ro $u32 {
    24
    RXDATA:8 // at 0: 8-bit receive data
  }

//---  Register TXDR: Transmit data register
  TXDR @offset 0x28 $u32 {
    24
    TXDATA:8 // at 0: 8-bit transmit data
  }

}

//------------------------------------------------------------------------------
// Peripheral IWDG: Independent watchdog
//------------------------------------------------------------------------------

registers ©IWDG @at 0x40003000 {
//---  Register KR: Key register
  KR @offset 0x0 $u32 {
    16
    KEY:16 // at 0: Key value (write only, read 0x0000)
  }

//---  Register PR: Prescaler register
  PR @offset 0x4 $u32 {
    29
    PR:3 // at 0: Prescaler divider
  }

//---  Register RLR: Reload register
  RLR @offset 0x8 $u32 {
    20
    RL:12 // at 0: Watchdog counter reload value
  }

//---  Register SR: Status register
  SR @offset 0xc @ro $u32 {
    29
    WVU // at 2: Watchdog counter window value update
    RVU // at 1: Watchdog counter reload value update
    PVU // at 0: Watchdog prescaler value update
  }

//---  Register WINR: Window register
  WINR @offset 0x10 $u32 {
    20
    WIN:12 // at 0: Watchdog counter window value
  }

}

//------------------------------------------------------------------------------
// Peripheral LCD: Liquid crystal display controller
//------------------------------------------------------------------------------

registers ©LCD @at 0x40002400 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    23
    BUFEN // at 8: Voltage output buffer enable
    MUX_SEG // at 7: Mux segment enable
    BIAS:2 // at 5: Bias selector
    DUTY:3 // at 2: Duty selection
    VSEL // at 1: Voltage source selection
    LCDEN // at 0: LCD controller enable
  }

//---  Register FCR: frame control register
  FCR @offset 0x4 $u32 {
    6
    PS:4 // at 22: PS 16-bit prescaler
    DIV:4 // at 18: DIV clock divider
    BLINK:2 // at 16: Blink mode selection
    BLINKF:3 // at 13: Blink frequency selection
    CC:3 // at 10: Contrast control
    DEAD:3 // at 7: Dead time duration
    PON:3 // at 4: Pulse ON duration
    UDDIE // at 3: Update display done interrupt enable
    1
    SOFIE // at 1: Start of frame interrupt enable
    HD // at 0: High drive enable
  }

//---  Register SR: status register
  SR @offset 0x8 $u32 {
    26
    FCRSF // at 5: LCD Frame Control Register Synchronization flag
    RDY // at 4: Ready flag
    UDD // at 3: Update Display Done
    UDR // at 2: Update display request
    SOF // at 1: Start of frame flag
    ENS // at 0: ENS
  }

//---  Register CLR: clear register
  CLR @offset 0xc $u32 {
    28
    UDDC // at 3: Update display done clear
    1
    SOFC // at 1: Start of frame flag clear
    1
  }

//---  Register RAM_COM0: display memory
  RAM_COM0 @offset 0x14 $u32 {
    1
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM1: display memory
  RAM_COM1 @offset 0x1c $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM2: display memory
  RAM_COM2 @offset 0x24 $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM3: display memory
  RAM_COM3 @offset 0x2c $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM4: display memory
  RAM_COM4 @offset 0x34 $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM5: display memory
  RAM_COM5 @offset 0x3c $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM6: display memory
  RAM_COM6 @offset 0x44 $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

//---  Register RAM_COM7: display memory
  RAM_COM7 @offset 0x4c $u32 {
    S31 // at 31: S31
    S30 // at 30: S30
    S29 // at 29: S29
    S28 // at 28: S28
    S27 // at 27: S27
    S26 // at 26: S26
    S25 // at 25: S25
    S24 // at 24: S24
    S23 // at 23: S23
    S22 // at 22: S22
    S21 // at 21: S21
    S20 // at 20: S20
    S19 // at 19: S19
    S18 // at 18: S18
    S17 // at 17: S17
    S16 // at 16: S16
    S15 // at 15: S15
    S14 // at 14: S14
    S13 // at 13: S13
    S12 // at 12: S12
    S11 // at 11: S11
    S10 // at 10: S10
    S09 // at 9: S09
    S08 // at 8: S08
    S07 // at 7: S07
    S06 // at 6: S06
    S05 // at 5: S05
    S04 // at 4: S04
    S03 // at 3: S03
    S02 // at 2: S02
    S01 // at 1: S01
    S00 // at 0: S00
  }

}

//------------------------------------------------------------------------------
// Peripheral LPTIM1: Low power timer
//------------------------------------------------------------------------------

registers ©LPTIM1 @at 0x40007c00 {
//---  Register ISR: Interrupt and Status Register
  ISR @offset 0x0 @ro $u32 {
    25
    DOWN // at 6: Counter direction change up to down
    UP // at 5: Counter direction change down to up
    ARROK // at 4: Autoreload register update OK
    CMPOK // at 3: Compare register update OK
    EXTTRIG // at 2: External trigger edge event
    ARRM // at 1: Autoreload match
    CMPM // at 0: Compare match
  }

//---  Register ICR: Interrupt Clear Register
  ICR @offset 0x4 $u32 {
    25
    DOWNCF // at 6: Direction change to down Clear Flag
    UPCF // at 5: Direction change to UP Clear Flag
    ARROKCF // at 4: Autoreload register update OK Clear Flag
    CMPOKCF // at 3: Compare register update OK Clear Flag
    EXTTRIGCF // at 2: External trigger valid edge Clear Flag
    ARRMCF // at 1: Autoreload match Clear Flag
    CMPMCF // at 0: compare match Clear Flag
  }

//---  Register IER: Interrupt Enable Register
  IER @offset 0x8 $u32 {
    25
    DOWNIE // at 6: Direction change to down Interrupt Enable
    UPIE // at 5: Direction change to UP Interrupt Enable
    ARROKIE // at 4: Autoreload register update OK Interrupt Enable
    CMPOKIE // at 3: Compare register update OK Interrupt Enable
    EXTTRIGIE // at 2: External trigger valid edge Interrupt Enable
    ARRMIE // at 1: Autoreload match Interrupt Enable
    CMPMIE // at 0: Compare match Interrupt Enable
  }

//---  Register CFGR: Configuration Register
  CFGR @offset 0xc $u32 {
    7
    ENC // at 24: Encoder mode enable
    COUNTMODE // at 23: counter mode enabled
    PRELOAD // at 22: Registers update mode
    WAVPOL // at 21: Waveform shape polarity
    WAVE // at 20: Waveform shape
    TIMOUT // at 19: Timeout enable
    TRIGEN:2 // at 17: Trigger enable and polarity
    1
    TRIGSEL:3 // at 13: Trigger selector
    1
    PRESC:3 // at 9: Clock prescaler
    1
    TRGFLT:2 // at 6: Configurable digital filter for trigger
    1
    CKFLT:2 // at 3: Configurable digital filter for external clock
    CKPOL:2 // at 1: Clock Polarity
    CKSEL // at 0: Clock selector
  }

//---  Register CR: Control Register
  CR @offset 0x10 $u32 {
    29
    CNTSTRT // at 2: Timer start in continuous mode
    SNGSTRT // at 1: LPTIM start in single mode
    ENABLE // at 0: LPTIM Enable
  }

//---  Register CMP: Compare Register
  CMP @offset 0x14 $u32 {
    16
    CMP:16 // at 0: Compare value
  }

//---  Register ARR: Autoreload Register
  ARR @offset 0x18 $u32 {
    16
    ARR:16 // at 0: Auto reload value
  }

//---  Register CNT: Counter Register
  CNT @offset 0x1c @ro $u32 {
    16
    CNT:16 // at 0: Counter value
  }

}

//------------------------------------------------------------------------------
// Peripheral LPTIM2
//------------------------------------------------------------------------------

registers ©LPTIM2 @at 0x40009400 {
//---  Register ISR: Interrupt and Status Register
  ISR @offset 0x0 @ro $u32 {
    25
    DOWN // at 6: Counter direction change up to down
    UP // at 5: Counter direction change down to up
    ARROK // at 4: Autoreload register update OK
    CMPOK // at 3: Compare register update OK
    EXTTRIG // at 2: External trigger edge event
    ARRM // at 1: Autoreload match
    CMPM // at 0: Compare match
  }

//---  Register ICR: Interrupt Clear Register
  ICR @offset 0x4 $u32 {
    25
    DOWNCF // at 6: Direction change to down Clear Flag
    UPCF // at 5: Direction change to UP Clear Flag
    ARROKCF // at 4: Autoreload register update OK Clear Flag
    CMPOKCF // at 3: Compare register update OK Clear Flag
    EXTTRIGCF // at 2: External trigger valid edge Clear Flag
    ARRMCF // at 1: Autoreload match Clear Flag
    CMPMCF // at 0: compare match Clear Flag
  }

//---  Register IER: Interrupt Enable Register
  IER @offset 0x8 $u32 {
    25
    DOWNIE // at 6: Direction change to down Interrupt Enable
    UPIE // at 5: Direction change to UP Interrupt Enable
    ARROKIE // at 4: Autoreload register update OK Interrupt Enable
    CMPOKIE // at 3: Compare register update OK Interrupt Enable
    EXTTRIGIE // at 2: External trigger valid edge Interrupt Enable
    ARRMIE // at 1: Autoreload match Interrupt Enable
    CMPMIE // at 0: Compare match Interrupt Enable
  }

//---  Register CFGR: Configuration Register
  CFGR @offset 0xc $u32 {
    7
    ENC // at 24: Encoder mode enable
    COUNTMODE // at 23: counter mode enabled
    PRELOAD // at 22: Registers update mode
    WAVPOL // at 21: Waveform shape polarity
    WAVE // at 20: Waveform shape
    TIMOUT // at 19: Timeout enable
    TRIGEN:2 // at 17: Trigger enable and polarity
    1
    TRIGSEL:3 // at 13: Trigger selector
    1
    PRESC:3 // at 9: Clock prescaler
    1
    TRGFLT:2 // at 6: Configurable digital filter for trigger
    1
    CKFLT:2 // at 3: Configurable digital filter for external clock
    CKPOL:2 // at 1: Clock Polarity
    CKSEL // at 0: Clock selector
  }

//---  Register CR: Control Register
  CR @offset 0x10 $u32 {
    29
    CNTSTRT // at 2: Timer start in continuous mode
    SNGSTRT // at 1: LPTIM start in single mode
    ENABLE // at 0: LPTIM Enable
  }

//---  Register CMP: Compare Register
  CMP @offset 0x14 $u32 {
    16
    CMP:16 // at 0: Compare value
  }

//---  Register ARR: Autoreload Register
  ARR @offset 0x18 $u32 {
    16
    ARR:16 // at 0: Auto reload value
  }

//---  Register CNT: Counter Register
  CNT @offset 0x1c @ro $u32 {
    16
    CNT:16 // at 0: Counter value
  }

}

//------------------------------------------------------------------------------
// Peripheral LPUART1: Universal synchronous asynchronous receiver       transmitter
//------------------------------------------------------------------------------

registers ©LPUART1 @at 0x40008000 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    3
    M1 // at 28: Word length
    2
    DEAT4 // at 25: Driver Enable assertion time
    DEAT3 // at 24: DEAT3
    DEAT2 // at 23: DEAT2
    DEAT1 // at 22: DEAT1
    DEAT0 // at 21: DEAT0
    DEDT4 // at 20: Driver Enable de-assertion time
    DEDT3 // at 19: DEDT3
    DEDT2 // at 18: DEDT2
    DEDT1 // at 17: DEDT1
    DEDT0 // at 16: DEDT0
    1
    CMIE // at 14: Character match interrupt enable
    MME // at 13: Mute mode enable
    M0 // at 12: Word length
    WAKE // at 11: Receiver wakeup method
    PCE // at 10: Parity control enable
    PS // at 9: Parity selection
    PEIE // at 8: PE interrupt enable
    TXEIE // at 7: interrupt enable
    TCIE // at 6: Transmission complete interrupt enable
    RXNEIE // at 5: RXNE interrupt enable
    IDLEIE // at 4: IDLE interrupt enable
    TE // at 3: Transmitter enable
    RE // at 2: Receiver enable
    UESM // at 1: USART enable in Stop mode
    UE // at 0: USART enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    ADD4_7:4 // at 28: Address of the USART node
    ADD0_3:4 // at 24: Address of the USART node
    4
    MSBFIRST // at 19: Most significant bit first
    TAINV // at 18: Binary data inversion
    TXINV // at 17: TX pin active level inversion
    RXINV // at 16: RX pin active level inversion
    SWAP // at 15: Swap TX/RX pins
    1
    STOP:2 // at 12: STOP bits
    CLKEN // at 11: Clock enable
    6
    ADDM7 // at 4: 7-bit Address Detection/4-bit Address Detection
    4
  }

//---  Register CR3: Control register 3
  CR3 @offset 0x8 $u32 {
    9
    WUFIE // at 22: Wakeup from Stop mode interrupt enable
    WUS:2 // at 20: Wakeup from Stop mode interrupt flag selection
    4
    DEP // at 15: Driver enable polarity selection
    DEM // at 14: Driver enable mode
    DDRE // at 13: DMA Disable on Reception Error
    OVRDIS // at 12: Overrun Disable
    1
    CTSIE // at 10: CTS interrupt enable
    CTSE // at 9: CTS enable
    RTSE // at 8: RTS enable
    DMAT // at 7: DMA enable transmitter
    DMAR // at 6: DMA enable receiver
    2
    HDSEL // at 3: Half-duplex selection
    2
    EIE // at 0: Error interrupt enable
  }

//---  Register BRR: Baud rate register
  BRR @offset 0xc $u32 {
    12
    BRR:20 // at 0: BRR
  }

//---  Register RQR: Request register
  RQR @offset 0x18 $u32 {
    28
    RXFRQ // at 3: Receive data flush request
    MMRQ // at 2: Mute mode request
    SBKRQ // at 1: Send break request
    1
  }

//---  Register ISR: Interrupt & status           register
  ISR @offset 0x1c @ro $u32 {
    9
    REACK // at 22: REACK
    TEACK // at 21: TEACK
    WUF // at 20: WUF
    RWU // at 19: RWU
    SBKF // at 18: SBKF
    CMF // at 17: CMF
    BUSY // at 16: BUSY
    5
    CTS // at 10: CTS
    CTSIF // at 9: CTSIF
    1
    TXE // at 7: TXE
    TC // at 6: TC
    RXNE // at 5: RXNE
    IDLE // at 4: IDLE
    ORE // at 3: ORE
    NF // at 2: NF
    FE // at 1: FE
    PE // at 0: PE
  }

//---  Register ICR: Interrupt flag clear register
  ICR @offset 0x20 $u32 {
    11
    WUCF // at 20: Wakeup from Stop mode clear flag
    2
    CMCF // at 17: Character match clear flag
    7
    CTSCF // at 9: CTS clear flag
    2
    TCCF // at 6: Transmission complete clear flag
    1
    IDLECF // at 4: Idle line detected clear flag
    ORECF // at 3: Overrun error clear flag
    NCF // at 2: Noise detected clear flag
    FECF // at 1: Framing error clear flag
    PECF // at 0: Parity error clear flag
  }

//---  Register RDR: Receive data register
  RDR @offset 0x24 @ro $u32 {
    23
    RDR:9 // at 0: Receive data value
  }

//---  Register TDR: Transmit data register
  TDR @offset 0x28 $u32 {
    23
    TDR:9 // at 0: Transmit data value
  }

}

//------------------------------------------------------------------------------
// Peripheral MPU: Memory protection unit
//------------------------------------------------------------------------------

registers ©MPU @at 0xe000ed90 {
//---  Register MPU_TYPER: MPU type register
  MPU_TYPER @offset 0x0 @ro $u32 {
    8
    IREGION:8 // at 16: Number of MPU instruction regions
    DREGION:8 // at 8: Number of MPU data regions
    7
    SEPARATE // at 0: Separate flag
  }

//---  Register MPU_CTRL: MPU control register
  MPU_CTRL @offset 0x4 @ro $u32 {
    29
    PRIVDEFENA // at 2: Enable priviliged software access to default memory map
    HFNMIENA // at 1: Enables the operation of MPU during hard fault
    ENABLE // at 0: Enables the MPU
  }

//---  Register MPU_RNR: MPU region number register
  MPU_RNR @offset 0x8 $u32 {
    24
    REGION:8 // at 0: MPU region
  }

//---  Register MPU_RBAR: MPU region base address           register
  MPU_RBAR @offset 0xc $u32 {
    ADDR:27 // at 5: Region base address field
    VALID // at 4: MPU region number valid
    REGION:4 // at 0: MPU region field
  }

//---  Register MPU_RASR: MPU region attribute and size           register
  MPU_RASR @offset 0x10 $u32 {
    3
    XN // at 28: Instruction access disable bit
    1
    AP:3 // at 24: Access permission
    2
    TEX:3 // at 19: memory attribute
    S // at 18: Shareable memory attribute
    C // at 17: memory attribute
    B // at 16: memory attribute
    SRD:8 // at 8: Subregion disable bits
    2
    SIZE:5 // at 1: Size of the MPU protection region
    ENABLE // at 0: Region enable bit.
  }

}

//------------------------------------------------------------------------------
// Peripheral NVIC: Nested Vectored Interrupt       Controller
//------------------------------------------------------------------------------

registers ©NVIC @at 0xe000e100 {
//---  Register ISER0: Interrupt Set-Enable Register
  ISER0 @offset 0x0 $u32 {
    SETENA:32 // at 0: SETENA
  }

//---  Register ISER1: Interrupt Set-Enable Register
  ISER1 @offset 0x4 $u32 {
    SETENA:32 // at 0: SETENA
  }

//---  Register ISER2: Interrupt Set-Enable Register
  ISER2 @offset 0x8 $u32 {
    SETENA:32 // at 0: SETENA
  }

//---  Register ICER0: Interrupt Clear-Enable           Register
  ICER0 @offset 0x80 $u32 {
    CLRENA:32 // at 0: CLRENA
  }

//---  Register ICER1: Interrupt Clear-Enable           Register
  ICER1 @offset 0x84 $u32 {
    CLRENA:32 // at 0: CLRENA
  }

//---  Register ICER2: Interrupt Clear-Enable           Register
  ICER2 @offset 0x88 $u32 {
    CLRENA:32 // at 0: CLRENA
  }

//---  Register ISPR0: Interrupt Set-Pending Register
  ISPR0 @offset 0x100 $u32 {
    SETPEND:32 // at 0: SETPEND
  }

//---  Register ISPR1: Interrupt Set-Pending Register
  ISPR1 @offset 0x104 $u32 {
    SETPEND:32 // at 0: SETPEND
  }

//---  Register ISPR2: Interrupt Set-Pending Register
  ISPR2 @offset 0x108 $u32 {
    SETPEND:32 // at 0: SETPEND
  }

//---  Register ICPR0: Interrupt Clear-Pending           Register
  ICPR0 @offset 0x180 $u32 {
    CLRPEND:32 // at 0: CLRPEND
  }

//---  Register ICPR1: Interrupt Clear-Pending           Register
  ICPR1 @offset 0x184 $u32 {
    CLRPEND:32 // at 0: CLRPEND
  }

//---  Register ICPR2: Interrupt Clear-Pending           Register
  ICPR2 @offset 0x188 $u32 {
    CLRPEND:32 // at 0: CLRPEND
  }

//---  Register IABR0: Interrupt Active Bit Register
  IABR0 @offset 0x200 @ro $u32 {
    ACTIVE:32 // at 0: ACTIVE
  }

//---  Register IABR1: Interrupt Active Bit Register
  IABR1 @offset 0x204 @ro $u32 {
    ACTIVE:32 // at 0: ACTIVE
  }

//---  Register IABR2: Interrupt Active Bit Register
  IABR2 @offset 0x208 @ro $u32 {
    ACTIVE:32 // at 0: ACTIVE
  }

//---  Register IPR0: Interrupt Priority Register
  IPR0 @offset 0x300 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR1: Interrupt Priority Register
  IPR1 @offset 0x304 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR2: Interrupt Priority Register
  IPR2 @offset 0x308 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR3: Interrupt Priority Register
  IPR3 @offset 0x30c $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR4: Interrupt Priority Register
  IPR4 @offset 0x310 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR5: Interrupt Priority Register
  IPR5 @offset 0x314 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR6: Interrupt Priority Register
  IPR6 @offset 0x318 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR7: Interrupt Priority Register
  IPR7 @offset 0x31c $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR8: Interrupt Priority Register
  IPR8 @offset 0x320 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR9: Interrupt Priority Register
  IPR9 @offset 0x324 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR10: Interrupt Priority Register
  IPR10 @offset 0x328 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR11: Interrupt Priority Register
  IPR11 @offset 0x32c $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR12: Interrupt Priority Register
  IPR12 @offset 0x330 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR13: Interrupt Priority Register
  IPR13 @offset 0x334 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR14: Interrupt Priority Register
  IPR14 @offset 0x338 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR15: Interrupt Priority Register
  IPR15 @offset 0x33c $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR16: Interrupt Priority Register
  IPR16 @offset 0x340 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR17: Interrupt Priority Register
  IPR17 @offset 0x344 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR18: Interrupt Priority Register
  IPR18 @offset 0x348 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR19: Interrupt Priority Register
  IPR19 @offset 0x34c $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

//---  Register IPR20: Interrupt Priority Register
  IPR20 @offset 0x350 $u32 {
    IPR_N3:8 // at 24: IPR_N3
    IPR_N2:8 // at 16: IPR_N2
    IPR_N1:8 // at 8: IPR_N1
    IPR_N0:8 // at 0: IPR_N0
  }

}

//------------------------------------------------------------------------------
// Peripheral NVIC_STIR: Nested vectored interrupt       controller
//------------------------------------------------------------------------------

registers ©NVIC_STIR @at 0xe000ef00 {
//---  Register STIR: Software trigger interrupt           register
  STIR @offset 0x0 $u32 {
    23
    INTID:9 // at 0: Software generated interrupt ID
  }

}

//------------------------------------------------------------------------------
// Peripheral OPAMP: Operational amplifiers
//------------------------------------------------------------------------------

registers ©OPAMP @at 0x40007800 {
//---  Register OPAMP1_CSR: OPAMP1 control/status register
  OPAMP1_CSR @offset 0x0 $u32 {
    OPA_RANGE // at 31: Operational amplifier power supply range for stability
    15
    CALOUT // at 15: Operational amplifier calibration output
    USERTRIM // at 14: allows to switch from AOP offset trimmed values to AOP offset
    CALSEL // at 13: Calibration selection
    CALON // at 12: Calibration mode enabled
    1
    VP_SEL // at 10: Non inverted input selection
    VM_SEL:2 // at 8: Inverting input selection
    2
    PGA_GAIN:2 // at 4: Operational amplifier Programmable amplifier gain value
    OPAMODE:2 // at 2: Operational amplifier PGA mode
    OPALPM // at 1: Operational amplifier Low Power Mode
    OPAEN // at 0: Operational amplifier Enable
  }

//---  Register OPAMP1_OTR: OPAMP1 offset trimming register in normal           mode
  OPAMP1_OTR @offset 0x4 $u32 {
    19
    TRIMOFFSETP:5 // at 8: Trim for PMOS differential pairs
    3
    TRIMOFFSETN:5 // at 0: Trim for NMOS differential pairs
  }

//---  Register OPAMP1_LPOTR: OPAMP1 offset trimming register in low-power           mode
  OPAMP1_LPOTR @offset 0x8 $u32 {
    19
    TRIMLPOFFSETP:5 // at 8: Trim for PMOS differential pairs
    3
    TRIMLPOFFSETN:5 // at 0: Trim for NMOS differential pairs
  }

//---  Register OPAMP2_CSR: OPAMP2 control/status register
  OPAMP2_CSR @offset 0x10 $u32 {
    16
    CALOUT // at 15: Operational amplifier calibration output
    USERTRIM // at 14: allows to switch from AOP offset trimmed values to AOP offset
    CALSEL // at 13: Calibration selection
    CALON // at 12: Calibration mode enabled
    1
    VP_SEL // at 10: Non inverted input selection
    VM_SEL:2 // at 8: Inverting input selection
    2
    PGA_GAIN:2 // at 4: Operational amplifier Programmable amplifier gain value
    OPAMODE:2 // at 2: Operational amplifier PGA mode
    OPALPM // at 1: Operational amplifier Low Power Mode
    OPAEN // at 0: Operational amplifier Enable
  }

//---  Register OPAMP2_OTR: OPAMP2 offset trimming register in normal           mode
  OPAMP2_OTR @offset 0x14 $u32 {
    19
    TRIMOFFSETP:5 // at 8: Trim for PMOS differential pairs
    3
    TRIMOFFSETN:5 // at 0: Trim for NMOS differential pairs
  }

//---  Register OPAMP2_LPOTR: OPAMP2 offset trimming register in low-power           mode
  OPAMP2_LPOTR @offset 0x18 $u32 {
    19
    TRIMLPOFFSETP:5 // at 8: Trim for PMOS differential pairs
    3
    TRIMLPOFFSETN:5 // at 0: Trim for NMOS differential pairs
  }

}

//------------------------------------------------------------------------------
// Peripheral PWR: Power control
//------------------------------------------------------------------------------

registers ©PWR @at 0x40007000 {
//---  Register CR1: Power control register 1
  CR1 @offset 0x0 $u32 {
    17
    LPR // at 14: Low-power run
    3
    VOS:2 // at 9: Voltage scaling range selection
    DBP // at 8: Disable backup domain write protection
    5
    LPMS:3 // at 0: Low-power mode selection
  }

//---  Register CR2: Power control register 2
  CR2 @offset 0x4 $u32 {
    21
    USV // at 10: VDDUSB USB supply valid
    IOSV // at 9: VDDIO2 Independent I/Os supply valid
    1
    PVME4 // at 7: Peripheral voltage monitoring 4 enable: VDDA vs. 2.2V
    PVME3 // at 6: Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V
    PVME2 // at 5: Peripheral voltage monitoring 2 enable: VDDIO2 vs. 0.9V
    PVME1 // at 4: Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V
    PLS:3 // at 1: Power voltage detector level selection
    PVDE // at 0: Power voltage detector enable
  }

//---  Register CR3: Power control register 3
  CR3 @offset 0x8 $u32 {
    16
    EWF // at 15: Enable internal wakeup line
    4
    APC // at 10: Apply pull-up and pull-down configuration
    1
    RRS // at 8: SRAM2 retention in Standby mode
    3
    EWUP5 // at 4: Enable Wakeup pin WKUP5
    EWUP4 // at 3: Enable Wakeup pin WKUP4
    EWUP3 // at 2: Enable Wakeup pin WKUP3
    EWUP2 // at 1: Enable Wakeup pin WKUP2
    EWUP1 // at 0: Enable Wakeup pin WKUP1
  }

//---  Register CR4: Power control register 4
  CR4 @offset 0xc $u32 {
    22
    VBRS // at 9: VBAT battery charging resistor selection
    VBE // at 8: VBAT battery charging enable
    3
    WP5 // at 4: Wakeup pin WKUP5 polarity
    WP4 // at 3: Wakeup pin WKUP4 polarity
    WP3 // at 2: Wakeup pin WKUP3 polarity
    WP2 // at 1: Wakeup pin WKUP2 polarity
    WP1 // at 0: Wakeup pin WKUP1 polarity
  }

//---  Register SR1: Power status register 1
  SR1 @offset 0x10 @ro $u32 {
    16
    WUFI // at 15: Wakeup flag internal
    6
    CSBF // at 8: Standby flag
    3
    CWUF5 // at 4: Wakeup flag 5
    CWUF4 // at 3: Wakeup flag 4
    CWUF3 // at 2: Wakeup flag 3
    CWUF2 // at 1: Wakeup flag 2
    CWUF1 // at 0: Wakeup flag 1
  }

//---  Register SR2: Power status register 2
  SR2 @offset 0x14 @ro $u32 {
    16
    PVMO4 // at 15: Peripheral voltage monitoring output: VDDA vs. 2.2 V
    PVMO3 // at 14: Peripheral voltage monitoring output: VDDA vs. 1.62 V
    PVMO2 // at 13: Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
    PVMO1 // at 12: Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
    PVDO // at 11: Power voltage detector output
    VOSF // at 10: Voltage scaling flag
    REGLPF // at 9: Low-power regulator flag
    REGLPS // at 8: Low-power regulator started
    8
  }

//---  Register SCR: Power status clear register
  SCR @offset 0x18 $u32 {
    23
    SBF // at 8: Clear standby flag
    3
    WUF5 // at 4: Clear wakeup flag 5
    WUF4 // at 3: Clear wakeup flag 4
    WUF3 // at 2: Clear wakeup flag 3
    WUF2 // at 1: Clear wakeup flag 2
    WUF1 // at 0: Clear wakeup flag 1
  }

//---  Register PUCRA: Power Port A pull-up control           register
  PUCRA @offset 0x20 $u32 {
    16
    PU15 // at 15: Port A pull-up bit y (y=0..15)
    PU14 // at 14: Port A pull-up bit y (y=0..15)
    PU13 // at 13: Port A pull-up bit y (y=0..15)
    PU12 // at 12: Port A pull-up bit y (y=0..15)
    PU11 // at 11: Port A pull-up bit y (y=0..15)
    PU10 // at 10: Port A pull-up bit y (y=0..15)
    PU9 // at 9: Port A pull-up bit y (y=0..15)
    PU8 // at 8: Port A pull-up bit y (y=0..15)
    PU7 // at 7: Port A pull-up bit y (y=0..15)
    PU6 // at 6: Port A pull-up bit y (y=0..15)
    PU5 // at 5: Port A pull-up bit y (y=0..15)
    PU4 // at 4: Port A pull-up bit y (y=0..15)
    PU3 // at 3: Port A pull-up bit y (y=0..15)
    PU2 // at 2: Port A pull-up bit y (y=0..15)
    PU1 // at 1: Port A pull-up bit y (y=0..15)
    PU0 // at 0: Port A pull-up bit y (y=0..15)
  }

//---  Register PDCRA: Power Port A pull-down control           register
  PDCRA @offset 0x24 $u32 {
    16
    PD15 // at 15: Port A pull-down bit y (y=0..15)
    PD14 // at 14: Port A pull-down bit y (y=0..15)
    PD13 // at 13: Port A pull-down bit y (y=0..15)
    PD12 // at 12: Port A pull-down bit y (y=0..15)
    PD11 // at 11: Port A pull-down bit y (y=0..15)
    PD10 // at 10: Port A pull-down bit y (y=0..15)
    PD9 // at 9: Port A pull-down bit y (y=0..15)
    PD8 // at 8: Port A pull-down bit y (y=0..15)
    PD7 // at 7: Port A pull-down bit y (y=0..15)
    PD6 // at 6: Port A pull-down bit y (y=0..15)
    PD5 // at 5: Port A pull-down bit y (y=0..15)
    PD4 // at 4: Port A pull-down bit y (y=0..15)
    PD3 // at 3: Port A pull-down bit y (y=0..15)
    PD2 // at 2: Port A pull-down bit y (y=0..15)
    PD1 // at 1: Port A pull-down bit y (y=0..15)
    PD0 // at 0: Port A pull-down bit y (y=0..15)
  }

//---  Register PUCRB: Power Port B pull-up control           register
  PUCRB @offset 0x28 $u32 {
    16
    PU15 // at 15: Port B pull-up bit y (y=0..15)
    PU14 // at 14: Port B pull-up bit y (y=0..15)
    PU13 // at 13: Port B pull-up bit y (y=0..15)
    PU12 // at 12: Port B pull-up bit y (y=0..15)
    PU11 // at 11: Port B pull-up bit y (y=0..15)
    PU10 // at 10: Port B pull-up bit y (y=0..15)
    PU9 // at 9: Port B pull-up bit y (y=0..15)
    PU8 // at 8: Port B pull-up bit y (y=0..15)
    PU7 // at 7: Port B pull-up bit y (y=0..15)
    PU6 // at 6: Port B pull-up bit y (y=0..15)
    PU5 // at 5: Port B pull-up bit y (y=0..15)
    PU4 // at 4: Port B pull-up bit y (y=0..15)
    PU3 // at 3: Port B pull-up bit y (y=0..15)
    PU2 // at 2: Port B pull-up bit y (y=0..15)
    PU1 // at 1: Port B pull-up bit y (y=0..15)
    PU0 // at 0: Port B pull-up bit y (y=0..15)
  }

//---  Register PDCRB: Power Port B pull-down control           register
  PDCRB @offset 0x2c $u32 {
    16
    PD15 // at 15: Port B pull-down bit y (y=0..15)
    PD14 // at 14: Port B pull-down bit y (y=0..15)
    PD13 // at 13: Port B pull-down bit y (y=0..15)
    PD12 // at 12: Port B pull-down bit y (y=0..15)
    PD11 // at 11: Port B pull-down bit y (y=0..15)
    PD10 // at 10: Port B pull-down bit y (y=0..15)
    PD9 // at 9: Port B pull-down bit y (y=0..15)
    PD8 // at 8: Port B pull-down bit y (y=0..15)
    PD7 // at 7: Port B pull-down bit y (y=0..15)
    PD6 // at 6: Port B pull-down bit y (y=0..15)
    PD5 // at 5: Port B pull-down bit y (y=0..15)
    PD4 // at 4: Port B pull-down bit y (y=0..15)
    PD3 // at 3: Port B pull-down bit y (y=0..15)
    PD2 // at 2: Port B pull-down bit y (y=0..15)
    PD1 // at 1: Port B pull-down bit y (y=0..15)
    PD0 // at 0: Port B pull-down bit y (y=0..15)
  }

//---  Register PUCRC: Power Port C pull-up control           register
  PUCRC @offset 0x30 $u32 {
    16
    PU15 // at 15: Port C pull-up bit y (y=0..15)
    PU14 // at 14: Port C pull-up bit y (y=0..15)
    PU13 // at 13: Port C pull-up bit y (y=0..15)
    PU12 // at 12: Port C pull-up bit y (y=0..15)
    PU11 // at 11: Port C pull-up bit y (y=0..15)
    PU10 // at 10: Port C pull-up bit y (y=0..15)
    PU9 // at 9: Port C pull-up bit y (y=0..15)
    PU8 // at 8: Port C pull-up bit y (y=0..15)
    PU7 // at 7: Port C pull-up bit y (y=0..15)
    PU6 // at 6: Port C pull-up bit y (y=0..15)
    PU5 // at 5: Port C pull-up bit y (y=0..15)
    PU4 // at 4: Port C pull-up bit y (y=0..15)
    PU3 // at 3: Port C pull-up bit y (y=0..15)
    PU2 // at 2: Port C pull-up bit y (y=0..15)
    PU1 // at 1: Port C pull-up bit y (y=0..15)
    PU0 // at 0: Port C pull-up bit y (y=0..15)
  }

//---  Register PDCRC: Power Port C pull-down control           register
  PDCRC @offset 0x34 $u32 {
    16
    PD15 // at 15: Port C pull-down bit y (y=0..15)
    PD14 // at 14: Port C pull-down bit y (y=0..15)
    PD13 // at 13: Port C pull-down bit y (y=0..15)
    PD12 // at 12: Port C pull-down bit y (y=0..15)
    PD11 // at 11: Port C pull-down bit y (y=0..15)
    PD10 // at 10: Port C pull-down bit y (y=0..15)
    PD9 // at 9: Port C pull-down bit y (y=0..15)
    PD8 // at 8: Port C pull-down bit y (y=0..15)
    PD7 // at 7: Port C pull-down bit y (y=0..15)
    PD6 // at 6: Port C pull-down bit y (y=0..15)
    PD5 // at 5: Port C pull-down bit y (y=0..15)
    PD4 // at 4: Port C pull-down bit y (y=0..15)
    PD3 // at 3: Port C pull-down bit y (y=0..15)
    PD2 // at 2: Port C pull-down bit y (y=0..15)
    PD1 // at 1: Port C pull-down bit y (y=0..15)
    PD0 // at 0: Port C pull-down bit y (y=0..15)
  }

//---  Register PUCRD: Power Port D pull-up control           register
  PUCRD @offset 0x38 $u32 {
    16
    PU15 // at 15: Port D pull-up bit y (y=0..15)
    PU14 // at 14: Port D pull-up bit y (y=0..15)
    PU13 // at 13: Port D pull-up bit y (y=0..15)
    PU12 // at 12: Port D pull-up bit y (y=0..15)
    PU11 // at 11: Port D pull-up bit y (y=0..15)
    PU10 // at 10: Port D pull-up bit y (y=0..15)
    PU9 // at 9: Port D pull-up bit y (y=0..15)
    PU8 // at 8: Port D pull-up bit y (y=0..15)
    PU7 // at 7: Port D pull-up bit y (y=0..15)
    PU6 // at 6: Port D pull-up bit y (y=0..15)
    PU5 // at 5: Port D pull-up bit y (y=0..15)
    PU4 // at 4: Port D pull-up bit y (y=0..15)
    PU3 // at 3: Port D pull-up bit y (y=0..15)
    PU2 // at 2: Port D pull-up bit y (y=0..15)
    PU1 // at 1: Port D pull-up bit y (y=0..15)
    PU0 // at 0: Port D pull-up bit y (y=0..15)
  }

//---  Register PDCRD: Power Port D pull-down control           register
  PDCRD @offset 0x3c $u32 {
    16
    PD15 // at 15: Port D pull-down bit y (y=0..15)
    PD14 // at 14: Port D pull-down bit y (y=0..15)
    PD13 // at 13: Port D pull-down bit y (y=0..15)
    PD12 // at 12: Port D pull-down bit y (y=0..15)
    PD11 // at 11: Port D pull-down bit y (y=0..15)
    PD10 // at 10: Port D pull-down bit y (y=0..15)
    PD9 // at 9: Port D pull-down bit y (y=0..15)
    PD8 // at 8: Port D pull-down bit y (y=0..15)
    PD7 // at 7: Port D pull-down bit y (y=0..15)
    PD6 // at 6: Port D pull-down bit y (y=0..15)
    PD5 // at 5: Port D pull-down bit y (y=0..15)
    PD4 // at 4: Port D pull-down bit y (y=0..15)
    PD3 // at 3: Port D pull-down bit y (y=0..15)
    PD2 // at 2: Port D pull-down bit y (y=0..15)
    PD1 // at 1: Port D pull-down bit y (y=0..15)
    PD0 // at 0: Port D pull-down bit y (y=0..15)
  }

//---  Register PUCRE: Power Port E pull-up control           register
  PUCRE @offset 0x40 $u32 {
    16
    PU15 // at 15: Port E pull-up bit y (y=0..15)
    PU14 // at 14: Port E pull-up bit y (y=0..15)
    PU13 // at 13: Port E pull-up bit y (y=0..15)
    PU12 // at 12: Port E pull-up bit y (y=0..15)
    PU11 // at 11: Port E pull-up bit y (y=0..15)
    PU10 // at 10: Port E pull-up bit y (y=0..15)
    PU9 // at 9: Port E pull-up bit y (y=0..15)
    PU8 // at 8: Port E pull-up bit y (y=0..15)
    PU7 // at 7: Port E pull-up bit y (y=0..15)
    PU6 // at 6: Port E pull-up bit y (y=0..15)
    PU5 // at 5: Port E pull-up bit y (y=0..15)
    PU4 // at 4: Port E pull-up bit y (y=0..15)
    PU3 // at 3: Port E pull-up bit y (y=0..15)
    PU2 // at 2: Port E pull-up bit y (y=0..15)
    PU1 // at 1: Port E pull-up bit y (y=0..15)
    PU0 // at 0: Port E pull-up bit y (y=0..15)
  }

//---  Register PDCRE: Power Port E pull-down control           register
  PDCRE @offset 0x44 $u32 {
    16
    PD15 // at 15: Port E pull-down bit y (y=0..15)
    PD14 // at 14: Port E pull-down bit y (y=0..15)
    PD13 // at 13: Port E pull-down bit y (y=0..15)
    PD12 // at 12: Port E pull-down bit y (y=0..15)
    PD11 // at 11: Port E pull-down bit y (y=0..15)
    PD10 // at 10: Port E pull-down bit y (y=0..15)
    PD9 // at 9: Port E pull-down bit y (y=0..15)
    PD8 // at 8: Port E pull-down bit y (y=0..15)
    PD7 // at 7: Port E pull-down bit y (y=0..15)
    PD6 // at 6: Port E pull-down bit y (y=0..15)
    PD5 // at 5: Port E pull-down bit y (y=0..15)
    PD4 // at 4: Port E pull-down bit y (y=0..15)
    PD3 // at 3: Port E pull-down bit y (y=0..15)
    PD2 // at 2: Port E pull-down bit y (y=0..15)
    PD1 // at 1: Port E pull-down bit y (y=0..15)
    PD0 // at 0: Port E pull-down bit y (y=0..15)
  }

//---  Register PUCRF: Power Port F pull-up control           register
  PUCRF @offset 0x48 $u32 {
    16
    PU15 // at 15: Port F pull-up bit y (y=0..15)
    PU14 // at 14: Port F pull-up bit y (y=0..15)
    PU13 // at 13: Port F pull-up bit y (y=0..15)
    PU12 // at 12: Port F pull-up bit y (y=0..15)
    PU11 // at 11: Port F pull-up bit y (y=0..15)
    PU10 // at 10: Port F pull-up bit y (y=0..15)
    PU9 // at 9: Port F pull-up bit y (y=0..15)
    PU8 // at 8: Port F pull-up bit y (y=0..15)
    PU7 // at 7: Port F pull-up bit y (y=0..15)
    PU6 // at 6: Port F pull-up bit y (y=0..15)
    PU5 // at 5: Port F pull-up bit y (y=0..15)
    PU4 // at 4: Port F pull-up bit y (y=0..15)
    PU3 // at 3: Port F pull-up bit y (y=0..15)
    PU2 // at 2: Port F pull-up bit y (y=0..15)
    PU1 // at 1: Port F pull-up bit y (y=0..15)
    PU0 // at 0: Port F pull-up bit y (y=0..15)
  }

//---  Register PDCRF: Power Port F pull-down control           register
  PDCRF @offset 0x4c $u32 {
    16
    PD15 // at 15: Port F pull-down bit y (y=0..15)
    PD14 // at 14: Port F pull-down bit y (y=0..15)
    PD13 // at 13: Port F pull-down bit y (y=0..15)
    PD12 // at 12: Port F pull-down bit y (y=0..15)
    PD11 // at 11: Port F pull-down bit y (y=0..15)
    PD10 // at 10: Port F pull-down bit y (y=0..15)
    PD9 // at 9: Port F pull-down bit y (y=0..15)
    PD8 // at 8: Port F pull-down bit y (y=0..15)
    PD7 // at 7: Port F pull-down bit y (y=0..15)
    PD6 // at 6: Port F pull-down bit y (y=0..15)
    PD5 // at 5: Port F pull-down bit y (y=0..15)
    PD4 // at 4: Port F pull-down bit y (y=0..15)
    PD3 // at 3: Port F pull-down bit y (y=0..15)
    PD2 // at 2: Port F pull-down bit y (y=0..15)
    PD1 // at 1: Port F pull-down bit y (y=0..15)
    PD0 // at 0: Port F pull-down bit y (y=0..15)
  }

//---  Register PUCRG: Power Port G pull-up control           register
  PUCRG @offset 0x50 $u32 {
    16
    PU15 // at 15: Port G pull-up bit y (y=0..15)
    PU14 // at 14: Port G pull-up bit y (y=0..15)
    PU13 // at 13: Port G pull-up bit y (y=0..15)
    PU12 // at 12: Port G pull-up bit y (y=0..15)
    PU11 // at 11: Port G pull-up bit y (y=0..15)
    PU10 // at 10: Port G pull-up bit y (y=0..15)
    PU9 // at 9: Port G pull-up bit y (y=0..15)
    PU8 // at 8: Port G pull-up bit y (y=0..15)
    PU7 // at 7: Port G pull-up bit y (y=0..15)
    PU6 // at 6: Port G pull-up bit y (y=0..15)
    PU5 // at 5: Port G pull-up bit y (y=0..15)
    PU4 // at 4: Port G pull-up bit y (y=0..15)
    PU3 // at 3: Port G pull-up bit y (y=0..15)
    PU2 // at 2: Port G pull-up bit y (y=0..15)
    PU1 // at 1: Port G pull-up bit y (y=0..15)
    PU0 // at 0: Port G pull-up bit y (y=0..15)
  }

//---  Register PDCRG: Power Port G pull-down control           register
  PDCRG @offset 0x54 $u32 {
    16
    PD15 // at 15: Port G pull-down bit y (y=0..15)
    PD14 // at 14: Port G pull-down bit y (y=0..15)
    PD13 // at 13: Port G pull-down bit y (y=0..15)
    PD12 // at 12: Port G pull-down bit y (y=0..15)
    PD11 // at 11: Port G pull-down bit y (y=0..15)
    PD10 // at 10: Port G pull-down bit y (y=0..15)
    PD9 // at 9: Port G pull-down bit y (y=0..15)
    PD8 // at 8: Port G pull-down bit y (y=0..15)
    PD7 // at 7: Port G pull-down bit y (y=0..15)
    PD6 // at 6: Port G pull-down bit y (y=0..15)
    PD5 // at 5: Port G pull-down bit y (y=0..15)
    PD4 // at 4: Port G pull-down bit y (y=0..15)
    PD3 // at 3: Port G pull-down bit y (y=0..15)
    PD2 // at 2: Port G pull-down bit y (y=0..15)
    PD1 // at 1: Port G pull-down bit y (y=0..15)
    PD0 // at 0: Port G pull-down bit y (y=0..15)
  }

//---  Register PUCRH: Power Port H pull-up control           register
  PUCRH @offset 0x58 $u32 {
    30
    PU1 // at 1: Port H pull-up bit y (y=0..1)
    PU0 // at 0: Port H pull-up bit y (y=0..1)
  }

//---  Register PDCRH: Power Port H pull-down control           register
  PDCRH @offset 0x5c $u32 {
    30
    PD1 // at 1: Port H pull-down bit y (y=0..1)
    PD0 // at 0: Port H pull-down bit y (y=0..1)
  }

}

//------------------------------------------------------------------------------
// Peripheral QUADSPI: QuadSPI interface
//------------------------------------------------------------------------------

registers ©QUADSPI @at 0xa0001000 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    PRESCALER:8 // at 24: Clock prescaler
    PMM // at 23: Polling match mode
    APMS // at 22: Automatic poll mode stop
    1
    TOIE // at 20: TimeOut interrupt enable
    SMIE // at 19: Status match interrupt enable
    FTIE // at 18: FIFO threshold interrupt enable
    TCIE // at 17: Transfer complete interrupt enable
    TEIE // at 16: Transfer error interrupt enable
    3
    FTHRES:5 // at 8: IFO threshold level
    FSEL // at 7: FLASH memory selection
    DFM // at 6: Dual-flash mode
    1
    SSHIFT // at 4: Sample shift
    TCEN // at 3: Timeout counter enable
    DMAEN // at 2: DMA enable
    ABORT // at 1: Abort request
    EN // at 0: Enable
  }

//---  Register DCR: device configuration register
  DCR @offset 0x4 $u32 {
    11
    FSIZE:5 // at 16: FLASH memory size
    5
    CSHT:3 // at 8: Chip select high time
    7
    CKMODE // at 0: Mode 0 / mode 3
  }

//---  Register SR: status register
  SR @offset 0x8 @ro $u32 {
    17
    FLEVEL:7 // at 8: FIFO level
    2
    BUSY // at 5: Busy
    TOF // at 4: Timeout flag
    SMF // at 3: Status match flag
    FTF // at 2: FIFO threshold flag
    TCF // at 1: Transfer complete flag
    TEF // at 0: Transfer error flag
  }

//---  Register FCR: flag clear register
  FCR @offset 0xc $u32 {
    27
    CTOF // at 4: Clear timeout flag
    CSMF // at 3: Clear status match flag
    1
    CTCF // at 1: Clear transfer complete flag
    CTEF // at 0: Clear transfer error flag
  }

//---  Register DLR: data length register
  DLR @offset 0x10 $u32 {
    DL:32 // at 0: Data length
  }

//---  Register CCR: communication configuration           register
  CCR @offset 0x14 $u32 {
    DDRM // at 31: Double data rate mode
    DHHC // at 30: DDR hold half cycle
    1
    SIOO // at 28: Send instruction only once mode
    FMODE:2 // at 26: Functional mode
    DMODE:2 // at 24: Data mode
    1
    DCYC:5 // at 18: Number of dummy cycles
    ABSIZE:2 // at 16: Alternate bytes size
    ABMODE:2 // at 14: Alternate bytes mode
    ADSIZE:2 // at 12: Address size
    ADMODE:2 // at 10: Address mode
    IMODE:2 // at 8: Instruction mode
    INSTRUCTION:8 // at 0: Instruction
  }

//---  Register AR: address register
  AR @offset 0x18 $u32 {
    ADDRESS:32 // at 0: Address
  }

//---  Register ABR: ABR
  ABR @offset 0x1c $u32 {
    ALTERNATE:32 // at 0: ALTERNATE
  }

//---  Register DR: data register
  DR @offset 0x20 $u32 {
    DATA:32 // at 0: Data
  }

//---  Register PSMKR: polling status mask register
  PSMKR @offset 0x24 $u32 {
    MASK:32 // at 0: Status mask
  }

//---  Register PSMAR: polling status match register
  PSMAR @offset 0x28 $u32 {
    MATCH:32 // at 0: Status match
  }

//---  Register PIR: polling interval register
  PIR @offset 0x2c $u32 {
    16
    INTERVAL:16 // at 0: Polling interval
  }

//---  Register LPTR: low-power timeout register
  LPTR @offset 0x30 $u32 {
    16
    TIMEOUT:16 // at 0: Timeout period
  }

}

//------------------------------------------------------------------------------
// Peripheral RCC: Reset and clock control
//------------------------------------------------------------------------------

registers ©RCC @at 0x40021000 {
//---  Register CR: Clock control register
  CR @offset 0x0 $u32 {
    4
    PLLSAI1RDY // at 27: SAI1 PLL clock ready flag
    PLLSAI1ON // at 26: SAI1 PLL enable
    PLLRDY // at 25: Main PLL clock ready flag
    PLLON // at 24: Main PLL enable
    4
    CSSON // at 19: Clock security system enable
    HSEBYP // at 18: HSE crystal oscillator bypass
    HSERDY // at 17: HSE clock ready flag
    HSEON // at 16: HSE clock enable
    4
    HSIASFS // at 11: HSI automatic start from Stop
    HSIRDY // at 10: HSI clock ready flag
    HSIKERON // at 9: HSI always enable for peripheral kernels
    HSION // at 8: HSI clock enable
    MSIRANGE:4 // at 4: MSI clock ranges
    MSIRGSEL // at 3: MSI clock range selection
    MSIPLLEN // at 2: MSI clock PLL enable
    MSIRDY // at 1: MSI clock ready flag
    MSION // at 0: MSI clock enable
  }

//---  Register ICSCR: Internal clock sources calibration           register
  ICSCR @offset 0x4 $u32 {
    3
    HSITRIM:5 // at 24: HSI clock trimming
    HSICAL:8 // at 16: HSI clock calibration
    MSITRIM:8 // at 8: MSI clock trimming
    MSICAL:8 // at 0: MSI clock calibration
  }

//---  Register CFGR: Clock configuration register
  CFGR @offset 0x8 $u32 {
    1
    MCOPRE:3 // at 28: Microcontroller clock output prescaler
    1
    MCOSEL:3 // at 24: Microcontroller clock output
    8
    STOPWUCK // at 15: Wakeup from Stop and CSS backup clock selection
    1
    PPRE2:3 // at 11: APB high-speed prescaler (APB2)
    PPRE1:3 // at 8: PB low-speed prescaler (APB1)
    HPRE:4 // at 4: AHB prescaler
    SWS:2 // at 2: System clock switch status
    SW:2 // at 0: System clock switch
  }

//---  Register PLLCFGR: PLL configuration register
  PLLCFGR @offset 0xc $u32 {
    PLLPDIV:5 // at 27: Main PLL division factor for PLLSAI2CLK
    PLLR:2 // at 25: Main PLL division factor for PLLCLK (system clock)
    PLLREN // at 24: Main PLL PLLCLK output enable
    1
    PLLQ:2 // at 21: Main PLL division factor for PLLUSB1CLK(48 MHz clock)
    PLLQEN // at 20: Main PLL PLLUSB1CLK output enable
    2
    PLLP // at 17: Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
    PLLPEN // at 16: Main PLL PLLSAI3CLK output enable
    1
    PLLN:7 // at 8: Main PLL multiplication factor for VCO
    1
    PLLM:3 // at 4: Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
    2
    PLLSRC:2 // at 0: Main PLL, PLLSAI1 and PLLSAI2 entry clock source
  }

//---  Register PLLSAI1CFGR: PLLSAI1 configuration register
  PLLSAI1CFGR @offset 0x10 $u32 {
    PLLSAI1PDIV:5 // at 27: PLLSAI1 division factor for PLLSAI1CLK
    PLLSAI1R:2 // at 25: PLLSAI1 division factor for PLLADC1CLK (ADC clock)
    PLLSAI1REN // at 24: PLLSAI1 PLLADC1CLK output enable
    1
    PLLSAI1Q:2 // at 21: SAI1PLL division factor for PLLUSB2CLK (48 MHz clock)
    PLLSAI1QEN // at 20: SAI1PLL PLLUSB2CLK output enable
    2
    PLLSAI1P // at 17: SAI1PLL division factor for PLLSAI1CLK (SAI1 or SAI2 clock)
    PLLSAI1PEN // at 16: SAI1PLL PLLSAI1CLK output enable
    1
    PLLSAI1N:7 // at 8: SAI1PLL multiplication factor for VCO
    8
  }

//---  Register CIER: Clock interrupt enable           register
  CIER @offset 0x18 $u32 {
    21
    HSI48RDYIE // at 10: HSI48 ready interrupt enable
    LSECSSIE // at 9: LSE clock security system interrupt enable
    2
    PLLSAI1RDYIE // at 6: PLLSAI1 ready interrupt enable
    PLLRDYIE // at 5: PLL ready interrupt enable
    HSERDYIE // at 4: HSE ready interrupt enable
    HSIRDYIE // at 3: HSI ready interrupt enable
    MSIRDYIE // at 2: MSI ready interrupt enable
    LSERDYIE // at 1: LSE ready interrupt enable
    LSIRDYIE // at 0: LSI ready interrupt enable
  }

//---  Register CIFR: Clock interrupt flag register
  CIFR @offset 0x1c @ro $u32 {
    21
    HSI48RDYF // at 10: HSI48 ready interrupt flag
    LSECSSF // at 9: LSE Clock security system interrupt flag
    CSSF // at 8: Clock security system interrupt flag
    1
    PLLSAI1RDYF // at 6: PLLSAI1 ready interrupt flag
    PLLRDYF // at 5: PLL ready interrupt flag
    HSERDYF // at 4: HSE ready interrupt flag
    HSIRDYF // at 3: HSI ready interrupt flag
    MSIRDYF // at 2: MSI ready interrupt flag
    LSERDYF // at 1: LSE ready interrupt flag
    LSIRDYF // at 0: LSI ready interrupt flag
  }

//---  Register CICR: Clock interrupt clear register
  CICR @offset 0x20 $u32 {
    21
    HSI48RDYC // at 10: HSI48 oscillator ready interrupt clear
    LSECSSC // at 9: LSE Clock security system interrupt clear
    CSSC // at 8: Clock security system interrupt clear
    1
    PLLSAI1RDYC // at 6: PLLSAI1 ready interrupt clear
    PLLRDYC // at 5: PLL ready interrupt clear
    HSERDYC // at 4: HSE ready interrupt clear
    HSIRDYC // at 3: HSI ready interrupt clear
    MSIRDYC // at 2: MSI ready interrupt clear
    LSERDYC // at 1: LSE ready interrupt clear
    LSIRDYC // at 0: LSI ready interrupt clear
  }

//---  Register AHB1RSTR: AHB1 peripheral reset register
  AHB1RSTR @offset 0x28 $u32 {
    15
    TSCRST // at 16: Touch Sensing Controller reset
    4
    CRCRST // at 11: CRC reset
    2
    FLASHRST // at 8: Flash memory interface reset
    6
    DMA2RST // at 1: DMA2 reset
    DMA1RST // at 0: DMA1 reset
  }

//---  Register AHB2RSTR: AHB2 peripheral reset register
  AHB2RSTR @offset 0x2c $u32 {
    13
    RNGRST // at 18: Random number generator reset
    1
    AESRST // at 16: AES hardware accelerator reset
    2
    ADCRST // at 13: ADC reset
    5
    GPIOHRST // at 7: IO port H reset
    2
    GPIOERST // at 4: IO port E reset
    GPIODRST // at 3: IO port D reset
    GPIOCRST // at 2: IO port C reset
    GPIOBRST // at 1: IO port B reset
    GPIOARST // at 0: IO port A reset
  }

//---  Register AHB3RSTR: AHB3 peripheral reset register
  AHB3RSTR @offset 0x30 $u32 {
    23
    QSPIRST // at 8: Quad SPI memory interface reset
    8
  }

//---  Register APB1RSTR1: APB1 peripheral reset register           1
  APB1RSTR1 @offset 0x38 $u32 {
    LPTIM1RST // at 31: Low Power Timer 1 reset
    OPAMPRST // at 30: OPAMP interface reset
    DAC1RST // at 29: DAC1 interface reset
    PWRRST // at 28: Power interface reset
    1
    USBFSRST // at 26: USB FS reset
    CAN1RST // at 25: CAN1 reset
    CRSRST // at 24: CRS reset
    I2C3RST // at 23: I2C3 reset
    I2C2RST // at 22: I2C2 reset
    I2C1RST // at 21: I2C1 reset
    1
    USART4RST // at 19: USART4 reset.
    USART1RST // at 18: USART1 reset
    USART2RST // at 17: USART2 reset
    1
    SPI3RST // at 15: SPI3 reset
    SPI2RST // at 14: SPI2 reset
    4
    LCDRST // at 9: LCD interface reset
    3
    TIM7RST // at 5: TIM7 timer reset
    TIM6RST // at 4: TIM6 timer reset
    3
    TIM2RST // at 0: TIM2 timer reset
  }

//---  Register APB1RSTR2: APB1 peripheral reset register           2
  APB1RSTR2 @offset 0x3c $u32 {
    26
    LPTIM2RST // at 5: Low-power timer 2 reset
    2
    SWPMI1RST // at 2: Single wire protocol reset
    I2C4RST // at 1: I2C4 reset
    LPUART1RST // at 0: Low-power UART 1 reset
  }

//---  Register APB2RSTR: APB2 peripheral reset register
  APB2RSTR @offset 0x40 $u32 {
    7
    DFSDMRST // at 24: DFSDM filter reset
    2
    SAI1RST // at 21: Serial audio interface 1 (SAI1) reset
    3
    TIM16RST // at 17: TIM16 timer reset
    TIM15RST // at 16: TIM15 timer reset
    1
    USART1RST // at 14: USART1 reset
    1
    SPI1RST // at 12: SPI1 reset
    TIM1RST // at 11: TIM1 timer reset
    SDMMCRST // at 10: SDMMC reset
    9
    SYSCFGRST // at 0: System configuration (SYSCFG) reset
  }

//---  Register AHB1ENR: AHB1 peripheral clock enable           register
  AHB1ENR @offset 0x48 $u32 {
    15
    TSCEN // at 16: Touch Sensing Controller clock enable
    3
    CRCEN // at 12: CRC clock enable
    3
    FLASHEN // at 8: Flash memory interface clock enable
    6
    DMA2EN // at 1: DMA2 clock enable
    DMA1EN // at 0: DMA1 clock enable
  }

//---  Register AHB2ENR: AHB2 peripheral clock enable           register
  AHB2ENR @offset 0x4c $u32 {
    13
    RNGEN // at 18: Random Number Generator clock enable
    1
    AESEN // at 16: AES accelerator clock enable
    2
    ADCEN // at 13: ADC clock enable
    5
    GPIOHEN // at 7: IO port H clock enable
    2
    GPIOEEN // at 4: IO port E clock enable
    GPIODEN // at 3: IO port D clock enable
    GPIOCEN // at 2: IO port C clock enable
    GPIOBEN // at 1: IO port B clock enable
    GPIOAEN // at 0: IO port A clock enable
  }

//---  Register AHB3ENR: AHB3 peripheral clock enable           register
  AHB3ENR @offset 0x50 $u32 {
    23
    QSPIEN // at 8: QSPIEN
    8
  }

//---  Register APB1ENR1: APB1ENR1
  APB1ENR1 @offset 0x58 $u32 {
    LPTIM1EN // at 31: Low power timer 1 clock enable
    OPAMPEN // at 30: OPAMP interface clock enable
    DAC1EN // at 29: DAC1 interface clock enable
    PWREN // at 28: Power interface clock enable
    1
    USBF // at 26: USB FS clock enable
    CAN1EN // at 25: CAN1 clock enable
    CRSEN // at 24: CRS clock enable
    I2C3EN // at 23: I2C3 clock enable
    I2C2EN // at 22: I2C2 clock enable
    I2C1EN // at 21: I2C1 clock enable
    1
    UART4EN // at 19: UART4 clock enable
    USART1EN // at 18: USART1 clock enable
    USART2EN // at 17: USART2 clock enable
    1
    SPI3EN // at 15: SPI3 clock enable
    SPI1EN // at 14: SPI1 clock enable
    2
    WWDGEN // at 11: Window watchdog clock enable
    RTCAPBEN // at 10: RTC APB clock enable
    LCDEN // at 9: LCD clock enable
    3
    TIM7EN // at 5: TIM7 timer clock enable
    TIM6EN // at 4: TIM6 timer clock enable
    2
    TIM3EN // at 1: TIM3 timer clock enable
    TIM2EN // at 0: TIM2 timer clock enable
  }

//---  Register APB1ENR2: APB1 peripheral clock enable register           2
  APB1ENR2 @offset 0x5c $u32 {
    7
    DFSDMEN // at 24: DFSDMEN enable
    18
    LPTIM2EN // at 5: LPTIM2EN
    2
    SWPMI1EN // at 2: Single wire protocol clock enable
    I2C4EN // at 1: I2C4 clock enable
    LPUART1EN // at 0: Low power UART 1 clock enable
  }

//---  Register APB2ENR: APB2ENR
  APB2ENR @offset 0x60 $u32 {
    10
    SAI1EN // at 21: SAI1 clock enable
    3
    TIM16EN // at 17: TIM16 timer clock enable
    TIM15EN // at 16: TIM15 timer clock enable
    1
    USART1EN // at 14: USART1clock enable
    1
    SPI1EN // at 12: SPI1 clock enable
    TIM1EN // at 11: TIM1 timer clock enable
    SDMMCEN // at 10: SDMMC clock enable
    2
    FIREWALLEN // at 7: Firewall clock enable
    6
    SYSCFGEN // at 0: SYSCFG clock enable
  }

//---  Register AHB1SMENR: AHB1 peripheral clocks enable in Sleep and           Stop modes register
  AHB1SMENR @offset 0x68 $u32 {
    15
    TSCSMEN // at 16: Touch Sensing Controller clocks enable during Sleep and Stop modes
    3
    CRCSMEN // at 12: CRCSMEN
    2
    SRAM1SMEN // at 9: SRAM1 interface clocks enable during Sleep and Stop modes
    FLASHSMEN // at 8: Flash memory interface clocks enable during Sleep and Stop modes
    6
    DMA2SMEN // at 1: DMA2 clocks enable during Sleep and Stop modes
    DMA1SMEN // at 0: DMA1 clocks enable during Sleep and Stop modes
  }

//---  Register AHB2SMENR: AHB2 peripheral clocks enable in Sleep and           Stop modes register
  AHB2SMENR @offset 0x6c $u32 {
    13
    RNGSMEN // at 18: Random Number Generator clocks enable during Sleep and Stop modes
    1
    AESSMEN // at 16: AES accelerator clocks enable during Sleep and Stop modes
    2
    ADCFSSMEN // at 13: ADC clocks enable during Sleep and Stop modes
    3
    SRAM2SMEN // at 9: SRAM2 interface clocks enable during Sleep and Stop modes
    1
    GPIOHSMEN // at 7: IO port H clocks enable during Sleep and Stop modes
    2
    GPIOESMEN // at 4: IO port E clocks enable during Sleep and Stop modes
    GPIODSMEN // at 3: IO port D clocks enable during Sleep and Stop modes
    GPIOCSMEN // at 2: IO port C clocks enable during Sleep and Stop modes
    GPIOBSMEN // at 1: IO port B clocks enable during Sleep and Stop modes
    GPIOASMEN // at 0: IO port A clocks enable during Sleep and Stop modes
  }

//---  Register AHB3SMENR: AHB3 peripheral clocks enable in Sleep and           Stop modes register
  AHB3SMENR @offset 0x70 $u32 {
    23
    QSPISMEN // at 8: QSPISMEN
    8
  }

//---  Register APB1SMENR1: APB1SMENR1
  APB1SMENR1 @offset 0x78 $u32 {
    LPTIM1SMEN // at 31: Low power timer 1 clocks enable during Sleep and Stop modes
    OPAMPSMEN // at 30: OPAMP interface clocks enable during Sleep and Stop modes
    DAC1SMEN // at 29: DAC1 interface clocks enable during Sleep and Stop modes
    PWRSMEN // at 28: Power interface clocks enable during Sleep and Stop modes
    1
    USBFSSMEN // at 26: USB FS clock enable during Sleep and Stop modes
    CAN1SMEN // at 25: CAN1 clocks enable during Sleep and Stop modes
    CRSSMEN // at 24: CRS clock enable during Sleep and Stop modes
    I2C3SMEN // at 23: I2C3 clocks enable during Sleep and Stop modes
    I2C2SMEN // at 22: I2C2 clocks enable during Sleep and Stop modes
    I2C1SMEN // at 21: I2C1 clocks enable during Sleep and Stop modes
    2
    USART2SMEN // at 18: USART2 clocks enable during Sleep and Stop modes
    USART1SMEN // at 17: USART1 clocks enable during Sleep and Stop modes
    1
    SP3SMEN // at 15: SPI3 clocks enable during Sleep and Stop modes
    SPI2SMEN // at 14: SPI2 clocks enable during Sleep and Stop modes
    2
    WWDGSMEN // at 11: Window watchdog clocks enable during Sleep and Stop modes
    RTCAPBSMEN // at 10: RTC APB clock enable during Sleep and Stop modes
    LCDSMEN // at 9: LCD clocks enable during Sleep and Stop modes
    3
    TIM7SMEN // at 5: TIM7 timer clocks enable during Sleep and Stop modes
    TIM6SMEN // at 4: TIM6 timer clocks enable during Sleep and Stop modes
    3
    TIM2SMEN // at 0: TIM2 timer clocks enable during Sleep and Stop modes
  }

//---  Register APB1SMENR2: APB1 peripheral clocks enable in Sleep and           Stop modes register 2
  APB1SMENR2 @offset 0x7c $u32 {
    26
    LPTIM2SMEN // at 5: LPTIM2SMEN
    2
    SWPMI1SMEN // at 2: Single wire protocol clocks enable during Sleep and Stop modes
    1
    LPUART1SMEN // at 0: Low power UART 1 clocks enable during Sleep and Stop modes
  }

//---  Register APB2SMENR: APB2SMENR
  APB2SMENR @offset 0x80 $u32 {
    10
    SAI1SMEN // at 21: SAI1 clocks enable during Sleep and Stop modes
    3
    TIM16SMEN // at 17: TIM16 timer clocks enable during Sleep and Stop modes
    TIM15SMEN // at 16: TIM15 timer clocks enable during Sleep and Stop modes
    1
    USART1SMEN // at 14: USART1clocks enable during Sleep and Stop modes
    1
    SPI1SMEN // at 12: SPI1 clocks enable during Sleep and Stop modes
    TIM1SMEN // at 11: TIM1 timer clocks enable during Sleep and Stop modes
    SDMMCSMEN // at 10: SDMMC clocks enable during Sleep and Stop modes
    9
    SYSCFGSMEN // at 0: SYSCFG clocks enable during Sleep and Stop modes
  }

//---  Register CCIPR: CCIPR
  CCIPR @offset 0x88 $u32 {
    1
    SWPMI1SEL // at 30: SWPMI1 clock source selection
    ADCSEL:2 // at 28: ADCs clock source selection
    CLK48SEL:2 // at 26: 48 MHz clock source selection
    2
    SAI1SEL:2 // at 22: SAI1 clock source selection
    LPTIM2SEL:2 // at 20: Low power timer 2 clock source selection
    LPTIM1SEL:2 // at 18: Low power timer 1 clock source selection
    I2C3SEL:2 // at 16: I2C3 clock source selection
    I2C2SEL:2 // at 14: I2C2 clock source selection
    I2C1SEL:2 // at 12: I2C1 clock source selection
    LPUART1SEL:2 // at 10: LPUART1 clock source selection
    2
    USART4SEL:2 // at 6: USART4 clock source selection
    USART3SEL:2 // at 4: USART3 clock source selection
    USART2SEL:2 // at 2: USART2 clock source selection
    USART1SEL:2 // at 0: USART1 clock source selection
  }

//---  Register BDCR: BDCR
  BDCR @offset 0x90 $u32 {
    6
    LSCOSEL // at 25: Low speed clock output selection
    LSCOEN // at 24: Low speed clock output enable
    7
    BDRST // at 16: Backup domain software reset
    RTCEN // at 15: RTC clock enable
    5
    RTCSEL:2 // at 8: RTC clock source selection
    1
    LSECSSD // at 6: LSECSSD
    LSECSSON // at 5: LSECSSON
    LSEDRV:2 // at 3: SE oscillator drive capability
    LSEBYP // at 2: LSE oscillator bypass
    LSERDY // at 1: LSE oscillator ready
    LSEON // at 0: LSE oscillator enable
  }

//---  Register CSR: CSR
  CSR @offset 0x94 $u32 {
    LPWRSTF // at 31: Low-power reset flag
    WWDGRSTF // at 30: Window watchdog reset flag
    IWDGRSTF // at 29: Independent window watchdog reset flag
    SFTRSTF // at 28: Software reset flag
    BORRSTF // at 27: BOR flag
    PINRSTF // at 26: Pin reset flag
    OBLRSTF // at 25: Option byte loader reset flag
    FIREWALLRSTF // at 24: Firewall reset flag
    RMVF // at 23: Remove reset flag
    11
    MSISRANGE:4 // at 8: SI range after Standby mode
    6
    LSIRDY // at 1: LSI oscillator ready
    LSION // at 0: LSI oscillator enable
  }

//---  Register CRRCR: Clock recovery RC register
  CRRCR @offset 0x98 $u32 {
    16
    HSI48CAL:9 // at 7: HSI48 clock calibration
    5
    HSI48RDY // at 1: HSI48 clock ready flag
    HSI48ON // at 0: HSI48 clock enable
  }

}

//------------------------------------------------------------------------------
// Peripheral RNG: Random number generator
//------------------------------------------------------------------------------

registers ©RNG @at 0x50060800 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    28
    IE // at 3: Interrupt enable
    RNGEN // at 2: Random number generator enable
    2
  }

//---  Register SR: status register
  SR @offset 0x4 $u32 {
    25
    SEIS // at 6: Seed error interrupt status
    CEIS // at 5: Clock error interrupt status
    2
    SECS // at 2: Seed error current status
    CECS // at 1: Clock error current status
    DRDY // at 0: Data ready
  }

//---  Register DR: data register
  DR @offset 0x8 @ro $u32 {
    RNDATA:32 // at 0: Random data
  }

}

//------------------------------------------------------------------------------
// Peripheral RTC: Real-time clock
//------------------------------------------------------------------------------

registers ©RTC @at 0x40002800 {
//---  Register TR: time register
  TR @offset 0x0 $u32 {
    9
    PM // at 22: AM/PM notation
    HT:2 // at 20: Hour tens in BCD format
    HU:4 // at 16: Hour units in BCD format
    1
    MNT:3 // at 12: Minute tens in BCD format
    MNU:4 // at 8: Minute units in BCD format
    1
    ST:3 // at 4: Second tens in BCD format
    SU:4 // at 0: Second units in BCD format
  }

//---  Register DR: date register
  DR @offset 0x4 $u32 {
    8
    YT:4 // at 20: Year tens in BCD format
    YU:4 // at 16: Year units in BCD format
    WDU:3 // at 13: Week day units
    MT // at 12: Month tens in BCD format
    MU:4 // at 8: Month units in BCD format
    2
    DT:2 // at 4: Date tens in BCD format
    DU:4 // at 0: Date units in BCD format
  }

//---  Register CR: control register
  CR @offset 0x8 $u32 {
    7
    ITSE // at 24: timestamp on internal event enable
    COE // at 23: Calibration output enable
    OSEL:2 // at 21: Output selection
    POL // at 20: Output polarity
    COSEL // at 19: Calibration output selection
    BKP // at 18: Backup
    SUB1H // at 17: Subtract 1 hour (winter time change)
    ADD1H // at 16: Add 1 hour (summer time change)
    TSIE // at 15: Time-stamp interrupt enable
    WUTIE // at 14: Wakeup timer interrupt enable
    ALRBIE // at 13: Alarm B interrupt enable
    ALRAIE // at 12: Alarm A interrupt enable
    TSE // at 11: Time stamp enable
    WUTE // at 10: Wakeup timer enable
    ALRBE // at 9: Alarm B enable
    ALRAE // at 8: Alarm A enable
    1
    FMT // at 6: Hour format
    BYPSHAD // at 5: Bypass the shadow registers
    REFCKON // at 4: Reference clock detection enable (50 or 60 Hz)
    TSEDGE // at 3: Time-stamp event active edge
    WCKSEL:3 // at 0: Wakeup clock selection
  }

//---  Register ISR: initialization and status           register
  ISR @offset 0xc $u32 {
    15
    RECALPF // at 16: Recalibration pending Flag
    TAMP3F // at 15: RTC_TAMP3 detection flag
    TAMP2F // at 14: RTC_TAMP2 detection flag
    TAMP1F // at 13: Tamper detection flag
    TSOVF // at 12: Time-stamp overflow flag
    TSF // at 11: Time-stamp flag
    WUTF // at 10: Wakeup timer flag
    ALRBF // at 9: Alarm B flag
    ALRAF // at 8: Alarm A flag
    INIT // at 7: Initialization mode
    INITF // at 6: Initialization flag
    RSF // at 5: Registers synchronization flag
    INITS // at 4: Initialization status flag
    SHPF // at 3: Shift operation pending
    WUTWF // at 2: Wakeup timer write flag
    ALRBWF // at 1: Alarm B write flag
    ALRAWF // at 0: Alarm A write flag
  }

//---  Register PRER: prescaler register
  PRER @offset 0x10 $u32 {
    9
    PREDIV_A:7 // at 16: Asynchronous prescaler factor
    1
    PREDIV_S:15 // at 0: Synchronous prescaler factor
  }

//---  Register WUTR: wakeup timer register
  WUTR @offset 0x14 $u32 {
    16
    WUT:16 // at 0: Wakeup auto-reload value bits
  }

//---  Register ALRMAR: alarm A register
  ALRMAR @offset 0x1c $u32 {
    MSK4 // at 31: Alarm A date mask
    WDSEL // at 30: Week day selection
    DT:2 // at 28: Date tens in BCD format
    DU:4 // at 24: Date units or day in BCD format
    MSK3 // at 23: Alarm A hours mask
    PM // at 22: AM/PM notation
    HT:2 // at 20: Hour tens in BCD format
    HU:4 // at 16: Hour units in BCD format
    MSK2 // at 15: Alarm A minutes mask
    MNT:3 // at 12: Minute tens in BCD format
    MNU:4 // at 8: Minute units in BCD format
    MSK1 // at 7: Alarm A seconds mask
    ST:3 // at 4: Second tens in BCD format
    SU:4 // at 0: Second units in BCD format
  }

//---  Register ALRMBR: alarm B register
  ALRMBR @offset 0x20 $u32 {
    MSK4 // at 31: Alarm B date mask
    WDSEL // at 30: Week day selection
    DT:2 // at 28: Date tens in BCD format
    DU:4 // at 24: Date units or day in BCD format
    MSK3 // at 23: Alarm B hours mask
    PM // at 22: AM/PM notation
    HT:2 // at 20: Hour tens in BCD format
    HU:4 // at 16: Hour units in BCD format
    MSK2 // at 15: Alarm B minutes mask
    MNT:3 // at 12: Minute tens in BCD format
    MNU:4 // at 8: Minute units in BCD format
    MSK1 // at 7: Alarm B seconds mask
    ST:3 // at 4: Second tens in BCD format
    SU:4 // at 0: Second units in BCD format
  }

//---  Register WPR: write protection register
  WPR @offset 0x24 $u32 {
    24
    KEY:8 // at 0: Write protection key
  }

//---  Register SSR: sub second register
  SSR @offset 0x28 @ro $u32 {
    16
    SS:16 // at 0: Sub second value
  }

//---  Register SHIFTR: shift control register
  SHIFTR @offset 0x2c $u32 {
    ADD1S // at 31: Add one second
    16
    SUBFS:15 // at 0: Subtract a fraction of a second
  }

//---  Register TSTR: time stamp time register
  TSTR @offset 0x30 @ro $u32 {
    9
    PM // at 22: AM/PM notation
    HT:2 // at 20: Hour tens in BCD format
    HU:4 // at 16: Hour units in BCD format
    1
    MNT:3 // at 12: Minute tens in BCD format
    MNU:4 // at 8: Minute units in BCD format
    1
    ST:3 // at 4: Second tens in BCD format
    SU:4 // at 0: Second units in BCD format
  }

//---  Register TSDR: time stamp date register
  TSDR @offset 0x34 @ro $u32 {
    16
    WDU:3 // at 13: Week day units
    MT // at 12: Month tens in BCD format
    MU:4 // at 8: Month units in BCD format
    2
    DT:2 // at 4: Date tens in BCD format
    DU:4 // at 0: Date units in BCD format
  }

//---  Register TSSSR: timestamp sub second register
  TSSSR @offset 0x38 @ro $u32 {
    16
    SS:16 // at 0: Sub second value
  }

//---  Register CALR: calibration register
  CALR @offset 0x3c $u32 {
    16
    CALP // at 15: Increase frequency of RTC by 488.5 ppm
    CALW8 // at 14: Use an 8-second calibration cycle period
    CALW16 // at 13: Use a 16-second calibration cycle period
    4
    CALM:9 // at 0: Calibration minus
  }

//---  Register TAMPCR: tamper configuration register
  TAMPCR @offset 0x40 $u32 {
    7
    TAMP3MF // at 24: Tamper 3 mask flag
    TAMP3NOERASE // at 23: Tamper 3 no erase
    TAMP3IE // at 22: Tamper 3 interrupt enable
    TAMP2MF // at 21: Tamper 2 mask flag
    TAMP2NOERASE // at 20: Tamper 2 no erase
    TAMP2IE // at 19: Tamper 2 interrupt enable
    TAMP1MF // at 18: Tamper 1 mask flag
    TAMP1NOERASE // at 17: Tamper 1 no erase
    TAMP1IE // at 16: Tamper 1 interrupt enable
    TAMPPUDIS // at 15: TAMPER pull-up disable
    TAMPPRCH:2 // at 13: Tamper precharge duration
    TAMPFLT:2 // at 11: Tamper filter count
    TAMPFREQ:3 // at 8: Tamper sampling frequency
    TAMPTS // at 7: Activate timestamp on tamper detection event
    TAMP3TRG // at 6: Active level for tamper 3
    TAMP3E // at 5: Tamper 3 detection enable
    TAMP2TRG // at 4: Active level for tamper 2
    TAMP2E // at 3: Tamper 2 detection enable
    TAMPIE // at 2: Tamper interrupt enable
    TAMP1TRG // at 1: Active level for tamper 1
    TAMP1E // at 0: Tamper 1 detection enable
  }

//---  Register ALRMASSR: alarm A sub second register
  ALRMASSR @offset 0x44 $u32 {
    4
    MASKSS:4 // at 24: Mask the most-significant bits starting at this bit
    9
    SS:15 // at 0: Sub seconds value
  }

//---  Register ALRMBSSR: alarm B sub second register
  ALRMBSSR @offset 0x48 $u32 {
    4
    MASKSS:4 // at 24: Mask the most-significant bits starting at this bit
    9
    SS:15 // at 0: Sub seconds value
  }

//---  Register OR: option register
  OR @offset 0x4c $u32 {
    30
    RTC_OUT_RMP // at 1: RTC_OUT remap
    RTC_ALARM_TYPE // at 0: RTC_ALARM on PC13 output type
  }

//---  Register BKP0R: backup register
  BKP0R @offset 0x50 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP1R: backup register
  BKP1R @offset 0x54 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP2R: backup register
  BKP2R @offset 0x58 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP3R: backup register
  BKP3R @offset 0x5c $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP4R: backup register
  BKP4R @offset 0x60 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP5R: backup register
  BKP5R @offset 0x64 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP6R: backup register
  BKP6R @offset 0x68 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP7R: backup register
  BKP7R @offset 0x6c $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP8R: backup register
  BKP8R @offset 0x70 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP9R: backup register
  BKP9R @offset 0x74 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP10R: backup register
  BKP10R @offset 0x78 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP11R: backup register
  BKP11R @offset 0x7c $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP12R: backup register
  BKP12R @offset 0x80 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP13R: backup register
  BKP13R @offset 0x84 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP14R: backup register
  BKP14R @offset 0x88 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP15R: backup register
  BKP15R @offset 0x8c $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP16R: backup register
  BKP16R @offset 0x90 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP17R: backup register
  BKP17R @offset 0x94 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP18R: backup register
  BKP18R @offset 0x98 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP19R: backup register
  BKP19R @offset 0x9c $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP20R: backup register
  BKP20R @offset 0xa0 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP21R: backup register
  BKP21R @offset 0xa4 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP22R: backup register
  BKP22R @offset 0xa8 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP23R: backup register
  BKP23R @offset 0xac $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP24R: backup register
  BKP24R @offset 0xb0 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP25R: backup register
  BKP25R @offset 0xb4 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP26R: backup register
  BKP26R @offset 0xb8 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP27R: backup register
  BKP27R @offset 0xbc $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP28R: backup register
  BKP28R @offset 0xc0 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP29R: backup register
  BKP29R @offset 0xc4 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP30R: backup register
  BKP30R @offset 0xc8 $u32 {
    BKP:32 // at 0: BKP
  }

//---  Register BKP31R: backup register
  BKP31R @offset 0xcc $u32 {
    BKP:32 // at 0: BKP
  }

}

//------------------------------------------------------------------------------
// Peripheral SAI1: Serial audio interface
//------------------------------------------------------------------------------

registers ©SAI1 @at 0x40015400 {
//---  Register BCR1: BConfiguration register 1
  BCR1 @offset 0x24 $u32 {
    8
    MCKDIV:4 // at 20: Master clock divider
    NODIV // at 19: No divider
    1
    DMAEN // at 17: DMA enable
    SAIBEN // at 16: Audio block B enable
    2
    OutDri // at 13: Output drive
    MONO // at 12: Mono mode
    SYNCEN:2 // at 10: Synchronization enable
    CKSTR // at 9: Clock strobing edge
    LSBFIRST // at 8: Least significant bit first
    DS:3 // at 5: Data size
    1
    PRTCFG:2 // at 2: Protocol configuration
    MODE:2 // at 0: Audio block mode
  }

//---  Register BCR2: BConfiguration register 2
  BCR2 @offset 0x28 $u32 {
    16
    COMP:2 // at 14: Companding mode
    CPL // at 13: Complement bit
    MUTECN:6 // at 7: Mute counter
    MUTEVAL // at 6: Mute value
    MUTE // at 5: Mute
    TRIS // at 4: Tristate management on data line
    FFLUS // at 3: FIFO flush
    FTH:3 // at 0: FIFO threshold
  }

//---  Register BFRCR: BFRCR
  BFRCR @offset 0x2c $u32 {
    13
    FSOFF // at 18: Frame synchronization offset
    FSPOL // at 17: Frame synchronization polarity
    FSDEF // at 16: Frame synchronization definition
    1
    FSALL:7 // at 8: Frame synchronization active level length
    FRL:8 // at 0: Frame length
  }

//---  Register BSLOTR: BSlot register
  BSLOTR @offset 0x30 $u32 {
    SLOTEN:16 // at 16: Slot enable
    4
    NBSLOT:4 // at 8: Number of slots in an audio frame
    SLOTSZ:2 // at 6: Slot size
    1
    FBOFF:5 // at 0: First bit offset
  }

//---  Register BIM: BInterrupt mask register2
  BIM @offset 0x34 $u32 {
    25
    LFSDETIE // at 6: Late frame synchronization detection interrupt enable
    AFSDETIE // at 5: Anticipated frame synchronization detection interrupt enable
    CNRDYIE // at 4: Codec not ready interrupt enable
    FREQIE // at 3: FIFO request interrupt enable
    WCKCFG // at 2: Wrong clock configuration interrupt enable
    MUTEDET // at 1: Mute detection interrupt enable
    OVRUDRIE // at 0: Overrun/underrun interrupt enable
  }

//---  Register BSR: BStatus register
  BSR @offset 0x38 @ro $u32 {
    13
    FLVL:3 // at 16: FIFO level threshold
    9
    LFSDET // at 6: Late frame synchronization detection
    AFSDET // at 5: Anticipated frame synchronization detection
    CNRDY // at 4: Codec not ready
    FREQ // at 3: FIFO request
    WCKCFG // at 2: Wrong clock configuration flag
    MUTEDET // at 1: Mute detection
    OVRUDR // at 0: Overrun / underrun
  }

//---  Register BCLRFR: BClear flag register
  BCLRFR @offset 0x3c $u32 {
    25
    LFSDET // at 6: Clear late frame synchronization detection flag
    CAFSDET // at 5: Clear anticipated frame synchronization detection flag
    CNRDY // at 4: Clear codec not ready flag
    1
    WCKCFG // at 2: Clear wrong clock configuration flag
    MUTEDET // at 1: Mute detection flag
    OVRUDR // at 0: Clear overrun / underrun
  }

//---  Register BDR: BData register
  BDR @offset 0x40 $u32 {
    DATA:32 // at 0: Data
  }

//---  Register ACR1: AConfiguration register 1
  ACR1 @offset 0x4 $u32 {
    8
    MCKDIV:4 // at 20: Master clock divider
    NODIV // at 19: No divider
    1
    DMAEN // at 17: DMA enable
    SAIAEN // at 16: Audio block A enable
    2
    OutDri // at 13: Output drive
    MONO // at 12: Mono mode
    SYNCEN:2 // at 10: Synchronization enable
    CKSTR // at 9: Clock strobing edge
    LSBFIRST // at 8: Least significant bit first
    DS:3 // at 5: Data size
    1
    PRTCFG:2 // at 2: Protocol configuration
    MODE:2 // at 0: Audio block mode
  }

//---  Register ACR2: AConfiguration register 2
  ACR2 @offset 0x8 $u32 {
    16
    COMP:2 // at 14: Companding mode
    CPL // at 13: Complement bit
    MUTECN:6 // at 7: Mute counter
    MUTEVAL // at 6: Mute value
    MUTE // at 5: Mute
    TRIS // at 4: Tristate management on data line
    FFLUS // at 3: FIFO flush
    FTH:3 // at 0: FIFO threshold
  }

//---  Register AFRCR: AFRCR
  AFRCR @offset 0xc $u32 {
    13
    FSOFF // at 18: Frame synchronization offset
    FSPOL // at 17: Frame synchronization polarity
    FSDEF // at 16: Frame synchronization definition
    1
    FSALL:7 // at 8: Frame synchronization active level length
    FRL:8 // at 0: Frame length
  }

//---  Register ASLOTR: ASlot register
  ASLOTR @offset 0x10 $u32 {
    SLOTEN:16 // at 16: Slot enable
    4
    NBSLOT:4 // at 8: Number of slots in an audio frame
    SLOTSZ:2 // at 6: Slot size
    1
    FBOFF:5 // at 0: First bit offset
  }

//---  Register AIM: AInterrupt mask register2
  AIM @offset 0x14 $u32 {
    25
    LFSDET // at 6: Late frame synchronization detection interrupt enable
    AFSDETIE // at 5: Anticipated frame synchronization detection interrupt enable
    CNRDYIE // at 4: Codec not ready interrupt enable
    FREQIE // at 3: FIFO request interrupt enable
    WCKCFG // at 2: Wrong clock configuration interrupt enable
    MUTEDET // at 1: Mute detection interrupt enable
    OVRUDRIE // at 0: Overrun/underrun interrupt enable
  }

//---  Register ASR: AStatus register
  ASR @offset 0x18 $u32 {
    13
    FLVL:3 // at 16: FIFO level threshold
    9
    LFSDET // at 6: Late frame synchronization detection
    AFSDET // at 5: Anticipated frame synchronization detection
    CNRDY // at 4: Codec not ready
    FREQ // at 3: FIFO request
    WCKCFG // at 2: Wrong clock configuration flag. This bit is read only
    MUTEDET // at 1: Mute detection
    OVRUDR // at 0: Overrun / underrun
  }

//---  Register ACLRFR: AClear flag register
  ACLRFR @offset 0x1c $u32 {
    25
    LFSDET // at 6: Clear late frame synchronization detection flag
    CAFSDET // at 5: Clear anticipated frame synchronization detection flag
    CNRDY // at 4: Clear codec not ready flag
    1
    WCKCFG // at 2: Clear wrong clock configuration flag
    MUTEDET // at 1: Mute detection flag
    OVRUDR // at 0: Clear overrun / underrun
  }

//---  Register ADR: AData register
  ADR @offset 0x20 $u32 {
    DATA:32 // at 0: Data
  }

}

//------------------------------------------------------------------------------
// Peripheral SCB: System control block
//------------------------------------------------------------------------------

registers ©SCB @at 0xe000ed00 {
//---  Register CPUID: CPUID base register
  CPUID @offset 0x0 @ro $u32 {
    Implementer:8 // at 24: Implementer code
    Variant:4 // at 20: Variant number
    Constant:4 // at 16: Reads as 0xF
    PartNo:12 // at 4: Part number of the processor
    Revision:4 // at 0: Revision number
  }

//---  Register ICSR: Interrupt control and state           register
  ICSR @offset 0x4 $u32 {
    NMIPENDSET // at 31: NMI set-pending bit.
    2
    PENDSVSET // at 28: PendSV set-pending bit
    PENDSVCLR // at 27: PendSV clear-pending bit
    PENDSTSET // at 26: SysTick exception set-pending bit
    PENDSTCLR // at 25: SysTick exception clear-pending bit
    2
    ISRPENDING // at 22: Interrupt pending flag
    3
    VECTPENDING:7 // at 12: Pending vector
    RETTOBASE // at 11: Return to base level
    2
    VECTACTIVE:9 // at 0: Active vector
  }

//---  Register VTOR: Vector table offset register
  VTOR @offset 0x8 $u32 {
    2
    TBLOFF:21 // at 9: Vector table base offset field
    9
  }

//---  Register AIRCR: Application interrupt and reset control           register
  AIRCR @offset 0xc $u32 {
    VECTKEYSTAT:16 // at 16: Register key
    ENDIANESS // at 15: ENDIANESS
    4
    PRIGROUP:3 // at 8: PRIGROUP
    5
    SYSRESETREQ // at 2: SYSRESETREQ
    VECTCLRACTIVE // at 1: VECTCLRACTIVE
    VECTRESET // at 0: VECTRESET
  }

//---  Register SCR: System control register
  SCR @offset 0x10 $u32 {
    27
    SEVEONPEND // at 4: Send Event on Pending bit
    1
    SLEEPDEEP // at 2: SLEEPDEEP
    SLEEPONEXIT // at 1: SLEEPONEXIT
    1
  }

//---  Register CCR: Configuration and control           register
  CCR @offset 0x14 $u32 {
    22
    STKALIGN // at 9: STKALIGN
    BFHFNMIGN // at 8: BFHFNMIGN
    3
    DIV_0_TRP // at 4: DIV_0_TRP
    UNALIGN__TRP // at 3: UNALIGN_ TRP
    1
    USERSETMPEND // at 1: USERSETMPEND
    NONBASETHRDENA // at 0: Configures how the processor enters Thread mode
  }

//---  Register SHPR1: System handler priority           registers
  SHPR1 @offset 0x18 $u32 {
    8
    PRI_6:8 // at 16: Priority of system handler 6
    PRI_5:8 // at 8: Priority of system handler 5
    PRI_4:8 // at 0: Priority of system handler 4
  }

//---  Register SHPR2: System handler priority           registers
  SHPR2 @offset 0x1c $u32 {
    PRI_11:8 // at 24: Priority of system handler 11
    24
  }

//---  Register SHPR3: System handler priority           registers
  SHPR3 @offset 0x20 $u32 {
    PRI_15:8 // at 24: Priority of system handler 15
    PRI_14:8 // at 16: Priority of system handler 14
    16
  }

//---  Register SHCRS: System handler control and state           register
  SHCRS @offset 0x24 $u32 {
    13
    USGFAULTENA // at 18: Usage fault enable bit
    BUSFAULTENA // at 17: Bus fault enable bit
    MEMFAULTENA // at 16: Memory management fault enable bit
    SVCALLPENDED // at 15: SVC call pending bit
    BUSFAULTPENDED // at 14: Bus fault exception pending bit
    MEMFAULTPENDED // at 13: Memory management fault exception pending bit
    USGFAULTPENDED // at 12: Usage fault exception pending bit
    SYSTICKACT // at 11: SysTick exception active bit
    PENDSVACT // at 10: PendSV exception active bit
    1
    MONITORACT // at 8: Debug monitor active bit
    SVCALLACT // at 7: SVC call active bit
    3
    USGFAULTACT // at 3: Usage fault exception active bit
    1
    BUSFAULTACT // at 1: Bus fault exception active bit
    MEMFAULTACT // at 0: Memory management fault exception active bit
  }

//---  Register CFSR_UFSR_BFSR_MMFSR: Configurable fault status           register
  CFSR_UFSR_BFSR_MMFSR @offset 0x28 $u32 {
    6
    DIVBYZERO // at 25: Divide by zero usage fault
    UNALIGNED // at 24: Unaligned access usage fault
    4
    NOCP // at 19: No coprocessor usage fault.
    INVPC // at 18: Invalid PC load usage fault
    INVSTATE // at 17: Invalid state usage fault
    UNDEFINSTR // at 16: Undefined instruction usage fault
    BFARVALID // at 15: Bus Fault Address Register (BFAR) valid flag
    1
    LSPERR // at 13: Bus fault on floating-point lazy state preservation
    STKERR // at 12: Bus fault on stacking for exception entry
    UNSTKERR // at 11: Bus fault on unstacking for a return from exception
    IMPRECISERR // at 10: Imprecise data bus error
    PRECISERR // at 9: Precise data bus error
    IBUSERR // at 8: Instruction bus error
    MMARVALID // at 7: Memory Management Fault Address Register (MMAR) valid flag
    1
    MLSPERR // at 5: MLSPERR
    MSTKERR // at 4: Memory manager fault on stacking for exception entry.
    MUNSTKERR // at 3: Memory manager fault on unstacking for a return from exception
    1
    IACCVIOL // at 1: Instruction access violation flag
    1
  }

//---  Register HFSR: Hard fault status register
  HFSR @offset 0x2c $u32 {
    DEBUG_VT // at 31: Reserved for Debug use
    FORCED // at 30: Forced hard fault
    28
    VECTTBL // at 1: Vector table hard fault
    1
  }

//---  Register MMFAR: Memory management fault address           register
  MMFAR @offset 0x34 $u32 {
    MMFAR:32 // at 0: Memory management fault address
  }

//---  Register BFAR: Bus fault address register
  BFAR @offset 0x38 $u32 {
    BFAR:32 // at 0: Bus fault address
  }

//---  Register AFSR: Auxiliary fault status           register
  AFSR @offset 0x3c $u32 {
    IMPDEF:32 // at 0: Implementation defined
  }

}

//------------------------------------------------------------------------------
// Peripheral SCB_ACTRL: System control block ACTLR
//------------------------------------------------------------------------------

registers ©SCB_ACTRL @at 0xe000e008 {
//---  Register ACTRL: Auxiliary control register
  ACTRL @offset 0x0 $u32 {
    22
    DISOOFP // at 9: DISOOFP
    DISFPCA // at 8: DISFPCA
    5
    DISFOLD // at 2: DISFOLD
    DISDEFWBUF // at 1: DISDEFWBUF
    DISMCYCINT // at 0: DISMCYCINT
  }

}

//------------------------------------------------------------------------------
// Peripheral SDMMC: Secure digital input/output       interface
//------------------------------------------------------------------------------

registers ©SDMMC @at 0x40012800 {
//---  Register POWER: power control register
  POWER @offset 0x0 $u32 {
    30
    PWRCTRL:2 // at 0: PWRCTRL
  }

//---  Register CLKCR: SDI clock control register
  CLKCR @offset 0x4 $u32 {
    17
    HWFC_EN // at 14: HW Flow Control enable
    NEGEDGE // at 13: SDIO_CK dephasing selection bit
    WIDBUS:2 // at 11: Wide bus mode enable bit
    BYPASS // at 10: Clock divider bypass enable bit
    PWRSAV // at 9: Power saving configuration bit
    CLKEN // at 8: Clock enable bit
    CLKDIV:8 // at 0: Clock divide factor
  }

//---  Register ARG: argument register
  ARG @offset 0x8 $u32 {
    CMDARG:32 // at 0: Command argument
  }

//---  Register CMD: command register
  CMD @offset 0xc $u32 {
    17
    CE_ATACMD // at 14: CE-ATA command
    nIEN // at 13: not Interrupt Enable
    ENCMDcompl // at 12: Enable CMD completion
    SDIOSuspend // at 11: SD I/O suspend command
    CPSMEN // at 10: Command path state machine (CPSM) Enable bit
    WAITPEND // at 9: CPSM Waits for ends of data transfer (CmdPend internal signal)
    WAITINT // at 8: CPSM waits for interrupt request
    WAITRESP:2 // at 6: Wait for response bits
    CMDINDEX:6 // at 0: Command index
  }

//---  Register RESPCMD: command response register
  RESPCMD @offset 0x10 @ro $u32 {
    26
    RESPCMD:6 // at 0: Response command index
  }

//---  Register RESP1: response 1..4 register
  RESP1 @offset 0x14 @ro $u32 {
    CARDSTATUS1:32 // at 0: see Table 132
  }

//---  Register RESP2: response 1..4 register
  RESP2 @offset 0x18 @ro $u32 {
    CARDSTATUS2:32 // at 0: see Table 132
  }

//---  Register RESP3: response 1..4 register
  RESP3 @offset 0x1c @ro $u32 {
    CARDSTATUS3:32 // at 0: see Table 132
  }

//---  Register RESP4: response 1..4 register
  RESP4 @offset 0x20 @ro $u32 {
    CARDSTATUS4:32 // at 0: see Table 132
  }

//---  Register DTIMER: data timer register
  DTIMER @offset 0x24 $u32 {
    DATATIME:32 // at 0: Data timeout period
  }

//---  Register DLEN: data length register
  DLEN @offset 0x28 $u32 {
    7
    DATALENGTH:25 // at 0: Data length value
  }

//---  Register DCTRL: data control register
  DCTRL @offset 0x2c $u32 {
    20
    SDIOEN // at 11: SD I/O enable functions
    RWMOD // at 10: Read wait mode
    RWSTOP // at 9: Read wait stop
    RWSTART // at 8: Read wait start
    DBLOCKSIZE:4 // at 4: Data block size
    DMAEN // at 3: DMA enable bit
    DTMODE // at 2: Data transfer mode selection 1: Stream or SDIO multibyte data transfer
    DTDIR // at 1: Data transfer direction selection
    DTEN // at 0: DTEN
  }

//---  Register DCOUNT: data counter register
  DCOUNT @offset 0x30 @ro $u32 {
    7
    DATACOUNT:25 // at 0: Data count value
  }

//---  Register STA: status register
  STA @offset 0x34 @ro $u32 {
    8
    CEATAEND // at 23: CE-ATA command completion signal received for CMD61
    SDIOIT // at 22: SDIO interrupt received
    RXDAVL // at 21: Data available in receive FIFO
    TXDAVL // at 20: Data available in transmit FIFO
    RXFIFOE // at 19: Receive FIFO empty
    TXFIFOE // at 18: Transmit FIFO empty
    RXFIFOF // at 17: Receive FIFO full
    TXFIFOF // at 16: Transmit FIFO full
    RXFIFOHF // at 15: Receive FIFO half full: there are at least 8 words in the FIFO
    TXFIFOHE // at 14: Transmit FIFO half empty: at least 8 words can be written into the FIFO
    RXACT // at 13: Data receive in progress
    TXACT // at 12: Data transmit in progress
    CMDACT // at 11: Command transfer in progress
    DBCKEND // at 10: Data block sent/received (CRC check passed)
    STBITERR // at 9: Start bit not detected on all data signals in wide bus mode
    DATAEND // at 8: Data end (data counter, SDIDCOUNT, is zero)
    CMDSENT // at 7: Command sent (no response required)
    CMDREND // at 6: Command response received (CRC check passed)
    RXOVERR // at 5: Received FIFO overrun error
    TXUNDERR // at 4: Transmit FIFO underrun error
    DTIMEOUT // at 3: Data timeout
    CTIMEOUT // at 2: Command response timeout
    DCRCFAIL // at 1: Data block sent/received (CRC check failed)
    CCRCFAIL // at 0: Command response received (CRC check failed)
  }

//---  Register ICR: interrupt clear register
  ICR @offset 0x38 $u32 {
    8
    CEATAENDC // at 23: CEATAEND flag clear bit
    SDIOITC // at 22: SDIOIT flag clear bit
    11
    DBCKENDC // at 10: DBCKEND flag clear bit
    STBITERRC // at 9: STBITERR flag clear bit
    DATAENDC // at 8: DATAEND flag clear bit
    CMDSENTC // at 7: CMDSENT flag clear bit
    CMDRENDC // at 6: CMDREND flag clear bit
    RXOVERRC // at 5: RXOVERR flag clear bit
    TXUNDERRC // at 4: TXUNDERR flag clear bit
    DTIMEOUTC // at 3: DTIMEOUT flag clear bit
    CTIMEOUTC // at 2: CTIMEOUT flag clear bit
    DCRCFAILC // at 1: DCRCFAIL flag clear bit
    CCRCFAILC // at 0: CCRCFAIL flag clear bit
  }

//---  Register MASK: mask register
  MASK @offset 0x3c $u32 {
    8
    CEATAENDIE // at 23: CE-ATA command completion signal received interrupt enable
    SDIOITIE // at 22: SDIO mode interrupt received interrupt enable
    RXDAVLIE // at 21: Data available in Rx FIFO interrupt enable
    TXDAVLIE // at 20: Data available in Tx FIFO interrupt enable
    RXFIFOEIE // at 19: Rx FIFO empty interrupt enable
    TXFIFOEIE // at 18: Tx FIFO empty interrupt enable
    RXFIFOFIE // at 17: Rx FIFO full interrupt enable
    TXFIFOFIE // at 16: Tx FIFO full interrupt enable
    RXFIFOHFIE // at 15: Rx FIFO half full interrupt enable
    TXFIFOHEIE // at 14: Tx FIFO half empty interrupt enable
    RXACTIE // at 13: Data receive acting interrupt enable
    TXACTIE // at 12: Data transmit acting interrupt enable
    CMDACTIE // at 11: Command acting interrupt enable
    DBCKENDIE // at 10: Data block end interrupt enable
    STBITERRIE // at 9: Start bit error interrupt enable
    DATAENDIE // at 8: Data end interrupt enable
    CMDSENTIE // at 7: Command sent interrupt enable
    CMDRENDIE // at 6: Command response received interrupt enable
    RXOVERRIE // at 5: Rx FIFO overrun error interrupt enable
    TXUNDERRIE // at 4: Tx FIFO underrun error interrupt enable
    DTIMEOUTIE // at 3: Data timeout interrupt enable
    CTIMEOUTIE // at 2: Command timeout interrupt enable
    DCRCFAILIE // at 1: Data CRC fail interrupt enable
    CCRCFAILIE // at 0: Command CRC fail interrupt enable
  }

//---  Register FIFOCNT: FIFO counter register
  FIFOCNT @offset 0x48 @ro $u32 {
    8
    FIFOCOUNT:24 // at 0: Remaining number of words to be written to or read from the FIFO
  }

//---  Register FIFO: data FIFO register
  FIFO @offset 0x80 $u32 {
    FIFOData:32 // at 0: Receive and transmit FIFO data
  }

}

//------------------------------------------------------------------------------
// Peripheral SPI1: Serial peripheral interface/Inter-IC       sound
//------------------------------------------------------------------------------

registers ©SPI1 @at 0x40013000 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    16
    BIDIMODE // at 15: Bidirectional data mode enable
    BIDIOE // at 14: Output enable in bidirectional mode
    CRCEN // at 13: Hardware CRC calculation enable
    CRCNEXT // at 12: CRC transfer next
    DFF // at 11: Data frame format
    RXONLY // at 10: Receive only
    SSM // at 9: Software slave management
    SSI // at 8: Internal slave select
    LSBFIRST // at 7: Frame format
    SPE // at 6: SPI enable
    BR:3 // at 3: Baud rate control
    MSTR // at 2: Master selection
    CPOL // at 1: Clock polarity
    CPHA // at 0: Clock phase
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    17
    LDMA_TX // at 14: Last DMA transfer for transmission
    LDMA_RX // at 13: Last DMA transfer for reception
    FRXTH // at 12: FIFO reception threshold
    DS:4 // at 8: Data size
    TXEIE // at 7: Tx buffer empty interrupt enable
    RXNEIE // at 6: RX buffer not empty interrupt enable
    ERRIE // at 5: Error interrupt enable
    FRF // at 4: Frame format
    NSSP // at 3: NSS pulse management
    SSOE // at 2: SS output enable
    TXDMAEN // at 1: Tx buffer DMA enable
    RXDMAEN // at 0: Rx buffer DMA enable
  }

//---  Register SR: status register
  SR @offset 0x8 $u32 {
    19
    FTLVL:2 // at 11: FIFO transmission level
    FRLVL:2 // at 9: FIFO reception level
    TIFRFE // at 8: TI frame format error
    BSY // at 7: Busy flag
    OVR // at 6: Overrun flag
    MODF // at 5: Mode fault
    CRCERR // at 4: CRC error flag
    2
    TXE // at 1: Transmit buffer empty
    RXNE // at 0: Receive buffer not empty
  }

//---  Register DR: data register
  DR @offset 0xc $u32 {
    16
    DR:16 // at 0: Data register
  }

//---  Register CRCPR: CRC polynomial register
  CRCPR @offset 0x10 $u32 {
    16
    CRCPOLY:16 // at 0: CRC polynomial register
  }

//---  Register RXCRCR: RX CRC register
  RXCRCR @offset 0x14 @ro $u32 {
    16
    RxCRC:16 // at 0: Rx CRC register
  }

//---  Register TXCRCR: TX CRC register
  TXCRCR @offset 0x18 @ro $u32 {
    16
    TxCRC:16 // at 0: Tx CRC register
  }

}

//------------------------------------------------------------------------------
// Peripheral SPI2
//------------------------------------------------------------------------------

registers ©SPI2 @at 0x40003800 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    16
    BIDIMODE // at 15: Bidirectional data mode enable
    BIDIOE // at 14: Output enable in bidirectional mode
    CRCEN // at 13: Hardware CRC calculation enable
    CRCNEXT // at 12: CRC transfer next
    DFF // at 11: Data frame format
    RXONLY // at 10: Receive only
    SSM // at 9: Software slave management
    SSI // at 8: Internal slave select
    LSBFIRST // at 7: Frame format
    SPE // at 6: SPI enable
    BR:3 // at 3: Baud rate control
    MSTR // at 2: Master selection
    CPOL // at 1: Clock polarity
    CPHA // at 0: Clock phase
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    17
    LDMA_TX // at 14: Last DMA transfer for transmission
    LDMA_RX // at 13: Last DMA transfer for reception
    FRXTH // at 12: FIFO reception threshold
    DS:4 // at 8: Data size
    TXEIE // at 7: Tx buffer empty interrupt enable
    RXNEIE // at 6: RX buffer not empty interrupt enable
    ERRIE // at 5: Error interrupt enable
    FRF // at 4: Frame format
    NSSP // at 3: NSS pulse management
    SSOE // at 2: SS output enable
    TXDMAEN // at 1: Tx buffer DMA enable
    RXDMAEN // at 0: Rx buffer DMA enable
  }

//---  Register SR: status register
  SR @offset 0x8 $u32 {
    19
    FTLVL:2 // at 11: FIFO transmission level
    FRLVL:2 // at 9: FIFO reception level
    TIFRFE // at 8: TI frame format error
    BSY // at 7: Busy flag
    OVR // at 6: Overrun flag
    MODF // at 5: Mode fault
    CRCERR // at 4: CRC error flag
    2
    TXE // at 1: Transmit buffer empty
    RXNE // at 0: Receive buffer not empty
  }

//---  Register DR: data register
  DR @offset 0xc $u32 {
    16
    DR:16 // at 0: Data register
  }

//---  Register CRCPR: CRC polynomial register
  CRCPR @offset 0x10 $u32 {
    16
    CRCPOLY:16 // at 0: CRC polynomial register
  }

//---  Register RXCRCR: RX CRC register
  RXCRCR @offset 0x14 @ro $u32 {
    16
    RxCRC:16 // at 0: Rx CRC register
  }

//---  Register TXCRCR: TX CRC register
  TXCRCR @offset 0x18 @ro $u32 {
    16
    TxCRC:16 // at 0: Tx CRC register
  }

}

//------------------------------------------------------------------------------
// Peripheral SPI3
//------------------------------------------------------------------------------

registers ©SPI3 @at 0x40003c00 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    16
    BIDIMODE // at 15: Bidirectional data mode enable
    BIDIOE // at 14: Output enable in bidirectional mode
    CRCEN // at 13: Hardware CRC calculation enable
    CRCNEXT // at 12: CRC transfer next
    DFF // at 11: Data frame format
    RXONLY // at 10: Receive only
    SSM // at 9: Software slave management
    SSI // at 8: Internal slave select
    LSBFIRST // at 7: Frame format
    SPE // at 6: SPI enable
    BR:3 // at 3: Baud rate control
    MSTR // at 2: Master selection
    CPOL // at 1: Clock polarity
    CPHA // at 0: Clock phase
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    17
    LDMA_TX // at 14: Last DMA transfer for transmission
    LDMA_RX // at 13: Last DMA transfer for reception
    FRXTH // at 12: FIFO reception threshold
    DS:4 // at 8: Data size
    TXEIE // at 7: Tx buffer empty interrupt enable
    RXNEIE // at 6: RX buffer not empty interrupt enable
    ERRIE // at 5: Error interrupt enable
    FRF // at 4: Frame format
    NSSP // at 3: NSS pulse management
    SSOE // at 2: SS output enable
    TXDMAEN // at 1: Tx buffer DMA enable
    RXDMAEN // at 0: Rx buffer DMA enable
  }

//---  Register SR: status register
  SR @offset 0x8 $u32 {
    19
    FTLVL:2 // at 11: FIFO transmission level
    FRLVL:2 // at 9: FIFO reception level
    TIFRFE // at 8: TI frame format error
    BSY // at 7: Busy flag
    OVR // at 6: Overrun flag
    MODF // at 5: Mode fault
    CRCERR // at 4: CRC error flag
    2
    TXE // at 1: Transmit buffer empty
    RXNE // at 0: Receive buffer not empty
  }

//---  Register DR: data register
  DR @offset 0xc $u32 {
    16
    DR:16 // at 0: Data register
  }

//---  Register CRCPR: CRC polynomial register
  CRCPR @offset 0x10 $u32 {
    16
    CRCPOLY:16 // at 0: CRC polynomial register
  }

//---  Register RXCRCR: RX CRC register
  RXCRCR @offset 0x14 @ro $u32 {
    16
    RxCRC:16 // at 0: Rx CRC register
  }

//---  Register TXCRCR: TX CRC register
  TXCRCR @offset 0x18 @ro $u32 {
    16
    TxCRC:16 // at 0: Tx CRC register
  }

}

//------------------------------------------------------------------------------
// Peripheral STK: SysTick timer
//------------------------------------------------------------------------------

registers ©STK @at 0xe000e010 {
//---  Register CTRL: SysTick control and status           register
  CTRL @offset 0x0 $u32 {
    15
    COUNTFLAG // at 16: COUNTFLAG
    13
    CLKSOURCE // at 2: Clock source selection
    TICKINT // at 1: SysTick exception request enable
    ENABLE // at 0: Counter enable
  }

//---  Register LOAD: SysTick reload value register
  LOAD @offset 0x4 $u32 {
    8
    RELOAD:24 // at 0: RELOAD value
  }

//---  Register VAL: SysTick current value register
  VAL @offset 0x8 $u32 {
    8
    CURRENT:24 // at 0: Current counter value
  }

//---  Register CALIB: SysTick calibration value           register
  CALIB @offset 0xc $u32 {
    NOREF // at 31: NOREF flag. Reads as zero
    SKEW // at 30: SKEW flag: Indicates whether the TENMS value is exact
    6
    TENMS:24 // at 0: Calibration value
  }

}

//------------------------------------------------------------------------------
// Peripheral SWPMI1: Single Wire Protocol Master       Interface
//------------------------------------------------------------------------------

registers ©SWPMI1 @at 0x40008800 {
//---  Register CR: SWPMI Configuration/Control           register
  CR @offset 0x0 $u32 {
    21
    DEACT // at 10: Single wire protocol master interface deactivate
    4
    SWPME // at 5: Single wire protocol master interface enable
    LPBK // at 4: Loopback mode enable
    TXMODE // at 3: Transmission buffering mode
    RXMODE // at 2: Reception buffering mode
    TXDMA // at 1: Transmission DMA enable
    RXDMA // at 0: Reception DMA enable
  }

//---  Register BRR: SWPMI Bitrate register
  BRR @offset 0x4 $u32 {
    26
    BR:6 // at 0: Bitrate prescaler
  }

//---  Register ISR: SWPMI Interrupt and Status           register
  ISR @offset 0xc @ro $u32 {
    21
    DEACTF // at 10: DEACTIVATED flag
    SUSP // at 9: SUSPEND flag
    SRF // at 8: Slave resume flag
    TCF // at 7: Transfer complete flag
    TXE // at 6: Transmit data register empty
    RXNE // at 5: Receive data register not empty
    TXUNRF // at 4: Transmit underrun error flag
    RXOVRF // at 3: Receive overrun error flag
    RXBERF // at 2: Receive CRC error flag
    TXBEF // at 1: Transmit buffer empty flag
    RXBFF // at 0: Receive buffer full flag
  }

//---  Register ICR: SWPMI Interrupt Flag Clear           register
  ICR @offset 0x10 $u32 {
    23
    CSRF // at 8: Clear slave resume flag
    CTCF // at 7: Clear transfer complete flag
    2
    CTXUNRF // at 4: Clear transmit underrun error flag
    CRXOVRF // at 3: Clear receive overrun error flag
    CRXBERF // at 2: Clear receive CRC error flag
    CTXBEF // at 1: Clear transmit buffer empty flag
    CRXBFF // at 0: Clear receive buffer full flag
  }

//---  Register IER: SWPMI Interrupt Enable           register
  IER @offset 0x14 $u32 {
    23
    SRIE // at 8: Slave resume interrupt enable
    TCIE // at 7: Transmit complete interrupt enable
    TIE // at 6: Transmit interrupt enable
    RIE // at 5: Receive interrupt enable
    TXUNRIE // at 4: Transmit underrun error interrupt enable
    RXOVRIE // at 3: Receive overrun error interrupt enable
    RXBERIE // at 2: Receive CRC error interrupt enable
    TXBEIE // at 1: Transmit buffer empty interrupt enable
    RXBFIE // at 0: Receive buffer full interrupt enable
  }

//---  Register RFL: SWPMI Receive Frame Length           register
  RFL @offset 0x18 @ro $u32 {
    27
    RFL:5 // at 0: Receive frame length
  }

//---  Register TDR: SWPMI Transmit data register
  TDR @offset 0x1c $u32 {
    TD:32 // at 0: Transmit data
  }

//---  Register RDR: SWPMI Receive data register
  RDR @offset 0x20 @ro $u32 {
    RD:32 // at 0: received data
  }

}

//------------------------------------------------------------------------------
// Peripheral SYSCFG: System configuration controller
//------------------------------------------------------------------------------

registers ©SYSCFG @at 0x40010000 {
//---  Register MEMRMP: memory remap register
  MEMRMP @offset 0x0 $u32 {
    23
    FB_MODE // at 8: Flash Bank mode selection
    4
    QFS // at 3: QUADSPI memory mapping swap
    MEM_MODE:3 // at 0: Memory mapping selection
  }

//---  Register CFGR1: configuration register 1
  CFGR1 @offset 0x4 $u32 {
    FPU_IE:6 // at 26: Floating Point Unit interrupts enable bits
    3
    I2C3_FMP // at 22: I2C3 Fast-mode Plus driving capability activation
    I2C2_FMP // at 21: I2C2 Fast-mode Plus driving capability activation
    I2C1_FMP // at 20: I2C1 Fast-mode Plus driving capability activation
    I2C_PB9_FMP // at 19: Fast-mode Plus (Fm+) driving capability activation on PB9
    I2C_PB8_FMP // at 18: Fast-mode Plus (Fm+) driving capability activation on PB8
    I2C_PB7_FMP // at 17: Fast-mode Plus (Fm+) driving capability activation on PB7
    I2C_PB6_FMP // at 16: Fast-mode Plus (Fm+) driving capability activation on PB6
    7
    BOOSTEN // at 8: I/O analog switch voltage booster enable
    7
    FWDIS // at 0: Firewall disable
  }

//---  Register EXTICR1: external interrupt configuration register           1
  EXTICR1 @offset 0x8 $u32 {
    17
    EXTI3:3 // at 12: EXTI 3 configuration bits
    1
    EXTI2:3 // at 8: EXTI 2 configuration bits
    1
    EXTI1:3 // at 4: EXTI 1 configuration bits
    1
    EXTI0:3 // at 0: EXTI 0 configuration bits
  }

//---  Register EXTICR2: external interrupt configuration register           2
  EXTICR2 @offset 0xc $u32 {
    17
    EXTI7:3 // at 12: EXTI 7 configuration bits
    1
    EXTI6:3 // at 8: EXTI 6 configuration bits
    1
    EXTI5:3 // at 4: EXTI 5 configuration bits
    1
    EXTI4:3 // at 0: EXTI 4 configuration bits
  }

//---  Register EXTICR3: external interrupt configuration register           3
  EXTICR3 @offset 0x10 $u32 {
    17
    EXTI11:3 // at 12: EXTI 11 configuration bits
    1
    EXTI10:3 // at 8: EXTI 10 configuration bits
    1
    EXTI9:3 // at 4: EXTI 9 configuration bits
    1
    EXTI8:3 // at 0: EXTI 8 configuration bits
  }

//---  Register EXTICR4: external interrupt configuration register           4
  EXTICR4 @offset 0x14 $u32 {
    17
    EXTI15:3 // at 12: EXTI15 configuration bits
    1
    EXTI14:3 // at 8: EXTI14 configuration bits
    1
    EXTI13:3 // at 4: EXTI13 configuration bits
    1
    EXTI12:3 // at 0: EXTI12 configuration bits
  }

//---  Register SCSR: SCSR
  SCSR @offset 0x18 $u32 {
    30
    SRAM2BSY // at 1: SRAM2 busy by erase operation
    SRAM2ER // at 0: SRAM2 Erase
  }

//---  Register CFGR2: CFGR2
  CFGR2 @offset 0x1c $u32 {
    23
    SPF // at 8: SRAM2 parity error flag
    4
    ECCL // at 3: ECC Lock
    PVDL // at 2: PVD lock enable bit
    SPL // at 1: SRAM2 parity lock bit
    CLL // at 0: OCKUP (Hardfault) output enable bit
  }

//---  Register SWPR: SWPR
  SWPR @offset 0x20 $u32 {
    P31WP // at 31: SRAM2 page 31 write protection
    P30WP // at 30: P30WP
    P29WP // at 29: P29WP
    P28WP // at 28: P28WP
    P27WP // at 27: P27WP
    P26WP // at 26: P26WP
    P25WP // at 25: P25WP
    P24WP // at 24: P24WP
    P23WP // at 23: P23WP
    P22WP // at 22: P22WP
    P21WP // at 21: P21WP
    P20WP // at 20: P20WP
    P19WP // at 19: P19WP
    P18WP // at 18: P18WP
    P17WP // at 17: P17WP
    P16WP // at 16: P16WP
    P15WP // at 15: P15WP
    P14WP // at 14: P14WP
    P13WP // at 13: P13WP
    P12WP // at 12: P12WP
    P11WP // at 11: P11WP
    P10WP // at 10: P10WP
    P9WP // at 9: P9WP
    P8WP // at 8: P8WP
    P7WP // at 7: P7WP
    P6WP // at 6: P6WP
    P5WP // at 5: P5WP
    P4WP // at 4: P4WP
    P3WP // at 3: P3WP
    P2WP // at 2: P2WP
    P1WP // at 1: P1WP
    P0WP // at 0: P0WP
  }

//---  Register SKR: SKR
  SKR @offset 0x24 $u32 {
    24
    KEY:8 // at 0: SRAM2 write protection key for software erase
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM1: Advanced-timers
//------------------------------------------------------------------------------

registers ©TIM1 @at 0x40012c00 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    22
    CKD:2 // at 8: Clock division
    ARPE // at 7: Auto-reload preload enable
    CMS:2 // at 5: Center-aligned mode selection
    DIR // at 4: Direction
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    17
    OIS4 // at 14: Output Idle state 4
    OIS3N // at 13: Output Idle state 3
    OIS3 // at 12: Output Idle state 3
    OIS2N // at 11: Output Idle state 2
    OIS2 // at 10: Output Idle state 2
    OIS1N // at 9: Output Idle state 1
    OIS1 // at 8: Output Idle state 1
    TI1S // at 7: TI1 selection
    MMS:3 // at 4: Master mode selection
    CCDS // at 3: Capture/compare DMA selection
    CCUS // at 2: Capture/compare control update selection
    1
    CCPC // at 0: Capture/compare preloaded control
  }

//---  Register SMCR: slave mode control register
  SMCR @offset 0x8 $u32 {
    16
    ETP // at 15: External trigger polarity
    ECE // at 14: External clock enable
    ETPS:2 // at 12: External trigger prescaler
    ETF:4 // at 8: External trigger filter
    MSM // at 7: Master/Slave mode
    TS:3 // at 4: Trigger selection
    1
    SMS:3 // at 0: Slave mode selection
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    17
    TDE // at 14: Trigger DMA request enable
    COMDE // at 13: COM DMA request enable
    CC4DE // at 12: Capture/Compare 4 DMA request enable
    CC3DE // at 11: Capture/Compare 3 DMA request enable
    CC2DE // at 10: Capture/Compare 2 DMA request enable
    CC1DE // at 9: Capture/Compare 1 DMA request enable
    UDE // at 8: Update DMA request enable
    BIE // at 7: Break interrupt enable
    TIE // at 6: Trigger interrupt enable
    COMIE // at 5: COM interrupt enable
    CC4IE // at 4: Capture/Compare 4 interrupt enable
    CC3IE // at 3: Capture/Compare 3 interrupt enable
    CC2IE // at 2: Capture/Compare 2 interrupt enable
    CC1IE // at 1: Capture/Compare 1 interrupt enable
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    19
    CC4OF // at 12: Capture/Compare 4 overcapture flag
    CC3OF // at 11: Capture/Compare 3 overcapture flag
    CC2OF // at 10: Capture/compare 2 overcapture flag
    CC1OF // at 9: Capture/Compare 1 overcapture flag
    1
    BIF // at 7: Break interrupt flag
    TIF // at 6: Trigger interrupt flag
    COMIF // at 5: COM interrupt flag
    CC4IF // at 4: Capture/Compare 4 interrupt flag
    CC3IF // at 3: Capture/Compare 3 interrupt flag
    CC2IF // at 2: Capture/Compare 2 interrupt flag
    CC1IF // at 1: Capture/compare 1 interrupt flag
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    24
    BG // at 7: Break generation
    TG // at 6: Trigger generation
    COMG // at 5: Capture/Compare control update generation
    CC4G // at 4: Capture/compare 4 generation
    CC3G // at 3: Capture/compare 3 generation
    CC2G // at 2: Capture/compare 2 generation
    CC1G // at 1: Capture/compare 1 generation
    UG // at 0: Update generation
  }

//---  Register CCMR1_Output: capture/compare mode register 1 (output           mode)
  CCMR1_Output @offset 0x18 $u32 {
    16
    OC2CE // at 15: Output Compare 2 clear enable
    OC2M:3 // at 12: Output Compare 2 mode
    OC2PE // at 11: Output Compare 2 preload enable
    OC2FE // at 10: Output Compare 2 fast enable
    CC2S:2 // at 8: Capture/Compare 2 selection
    OC1CE // at 7: Output Compare 1 clear enable
    OC1M:3 // at 4: Output Compare 1 mode
    OC1PE // at 3: Output Compare 1 preload enable
    OC1FE // at 2: Output Compare 1 fast enable
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR1_Input: capture/compare mode register 1 (input           mode)
  CCMR1_Input @offset 0x18 $u32 {
    16
    IC2F:4 // at 12: Input capture 2 filter
    IC2PCS:2 // at 10: Input capture 2 prescaler
    CC2S:2 // at 8: Capture/Compare 2 selection
    IC1F:4 // at 4: Input capture 1 filter
    ICPCS:2 // at 2: Input capture 1 prescaler
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR2_Output: capture/compare mode register 2 (output           mode)
  CCMR2_Output @offset 0x1c $u32 {
    16
    OC4CE // at 15: Output compare 4 clear enable
    OC4M:3 // at 12: Output compare 4 mode
    OC4PE // at 11: Output compare 4 preload enable
    OC4FE // at 10: Output compare 4 fast enable
    CC4S:2 // at 8: Capture/Compare 4 selection
    OC3CE // at 7: Output compare 3 clear enable
    OC3M:3 // at 4: Output compare 3 mode
    OC3PE // at 3: Output compare 3 preload enable
    OC3FE // at 2: Output compare 3 fast enable
    CC3S:2 // at 0: Capture/Compare 3 selection
  }

//---  Register CCMR2_Input: capture/compare mode register 2 (input           mode)
  CCMR2_Input @offset 0x1c $u32 {
    16
    IC4F:4 // at 12: Input capture 4 filter
    IC4PSC:2 // at 10: Input capture 4 prescaler
    CC4S:2 // at 8: Capture/Compare 4 selection
    IC3F:4 // at 4: Input capture 3 filter
    IC3PSC:2 // at 2: Input capture 3 prescaler
    CC3S:2 // at 0: Capture/compare 3 selection
  }

//---  Register CCER: capture/compare enable           register
  CCER @offset 0x20 $u32 {
    18
    CC4P // at 13: Capture/Compare 3 output Polarity
    CC4E // at 12: Capture/Compare 4 output enable
    CC3NP // at 11: Capture/Compare 3 output Polarity
    CC3NE // at 10: Capture/Compare 3 complementary output enable
    CC3P // at 9: Capture/Compare 3 output Polarity
    CC3E // at 8: Capture/Compare 3 output enable
    CC2NP // at 7: Capture/Compare 2 output Polarity
    CC2NE // at 6: Capture/Compare 2 complementary output enable
    CC2P // at 5: Capture/Compare 2 output Polarity
    CC2E // at 4: Capture/Compare 2 output enable
    CC1NP // at 3: Capture/Compare 1 output Polarity
    CC1NE // at 2: Capture/Compare 1 complementary output enable
    CC1P // at 1: Capture/Compare 1 output Polarity
    CC1E // at 0: Capture/Compare 1 output enable
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    16
    CNT:16 // at 0: counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    16
    ARR:16 // at 0: Auto-reload value
  }

//---  Register RCR: repetition counter register
  RCR @offset 0x30 $u32 {
    24
    REP:8 // at 0: Repetition counter value
  }

//---  Register CCR1: capture/compare register 1
  CCR1 @offset 0x34 $u32 {
    16
    CCR1:16 // at 0: Capture/Compare 1 value
  }

//---  Register CCR2: capture/compare register 2
  CCR2 @offset 0x38 $u32 {
    16
    CCR2:16 // at 0: Capture/Compare 2 value
  }

//---  Register CCR3: capture/compare register 3
  CCR3 @offset 0x3c $u32 {
    16
    CCR3:16 // at 0: Capture/Compare value
  }

//---  Register CCR4: capture/compare register 4
  CCR4 @offset 0x40 $u32 {
    16
    CCR4:16 // at 0: Capture/Compare value
  }

//---  Register BDTR: break and dead-time register
  BDTR @offset 0x44 $u32 {
    16
    MOE // at 15: Main output enable
    AOE // at 14: Automatic output enable
    BKP // at 13: Break polarity
    BKE // at 12: Break enable
    OSSR // at 11: Off-state selection for Run mode
    OSSI // at 10: Off-state selection for Idle mode
    LOCK:2 // at 8: Lock configuration
    DTG:8 // at 0: Dead-time generator setup
  }

//---  Register DCR: DMA control register
  DCR @offset 0x48 $u32 {
    19
    DBL:5 // at 8: DMA burst length
    3
    DBA:5 // at 0: DMA base address
  }

//---  Register DMAR: DMA address for full transfer
  DMAR @offset 0x4c $u32 {
    16
    DMAB:16 // at 0: DMA register for burst accesses
  }

//---  Register OR1: DMA address for full transfer
  OR1 @offset 0x50 $u32 {
    27
    TI1_RMP // at 4: Input Capture 1 remap
    ETR_ADC3_RMP:2 // at 2: External trigger remap on ADC3 analog watchdog
    ETR_ADC1_RMP:2 // at 0: External trigger remap on ADC1 analog watchdog
  }

//---  Register CCMR3_Output: capture/compare mode register 2 (output           mode)
  CCMR3_Output @offset 0x54 $u32 {
    7
    OC6M_bit3 // at 24: Output Compare 6 mode bit 3
    5
    OC5M_bit3:3 // at 16: Output Compare 5 mode bit 3
    OC6CE // at 15: Output compare 6 clear enable
    OC6M:3 // at 12: Output compare 6 mode
    OC6PE // at 11: Output compare 6 preload enable
    OC6FE // at 10: Output compare 6 fast enable
    2
    OC5CE // at 7: Output compare 5 clear enable
    OC5M:3 // at 4: Output compare 5 mode
    OC5PE // at 3: Output compare 5 preload enable
    OC5FE // at 2: Output compare 5 fast enable
    2
  }

//---  Register CCR5: capture/compare register 4
  CCR5 @offset 0x58 $u32 {
    GC5C3 // at 31: Group Channel 5 and Channel 3
    GC5C2 // at 30: Group Channel 5 and Channel 2
    GC5C1 // at 29: Group Channel 5 and Channel 1
    13
    CCR5:16 // at 0: Capture/Compare value
  }

//---  Register CCR6: capture/compare register 4
  CCR6 @offset 0x5c $u32 {
    16
    CCR6:16 // at 0: Capture/Compare value
  }

//---  Register OR2: DMA address for full transfer
  OR2 @offset 0x60 $u32 {
    15
    ETRSEL:3 // at 14: ETR source selection
    2
    BKCMP2P // at 11: BRK COMP2 input polarity
    BKCMP1P // at 10: BRK COMP1 input polarity
    BKINP // at 9: BRK BKIN input polarity
    BKDFBK0E // at 8: BRK DFSDM_BREAK0 enable
    5
    BKCMP2E // at 2: BRK COMP2 enable
    BKCMP1E // at 1: BRK COMP1 enable
    BKINE // at 0: BRK BKIN input enable
  }

//---  Register OR3: DMA address for full transfer
  OR3 @offset 0x64 $u32 {
    20
    BK2CMP2P // at 11: BRK2 COMP2 input polarity
    BK2CMP1P // at 10: BRK2 COMP1 input polarity
    BK2INP // at 9: BRK2 BKIN input polarity
    BK2DFBK0E // at 8: BRK2 DFSDM_BREAK0 enable
    5
    BK2CMP2E // at 2: BRK2 COMP2 enable
    BK2CMP1E // at 1: BRK2 COMP1 enable
    BK2INE // at 0: BRK2 BKIN input enable
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM15: General purpose timers
//------------------------------------------------------------------------------

registers ©TIM15 @at 0x40014000 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    20
    UIFREMAP // at 11: UIF status bit remapping
    1
    CKD:2 // at 8: Clock division
    ARPE // at 7: Auto-reload preload enable
    3
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    22
    OIS1N // at 9: Output Idle state 1
    OIS1 // at 8: Output Idle state 1
    4
    CCDS // at 3: Capture/compare DMA selection
    CCUS // at 2: Capture/compare control update selection
    1
    CCPC // at 0: Capture/compare preloaded control
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    17
    TDE // at 14: Trigger DMA request enable
    COMDE // at 13: COM DMA request enable
    3
    CC1DE // at 9: Capture/Compare 1 DMA request enable
    UDE // at 8: Update DMA request enable
    BIE // at 7: Break interrupt enable
    TIE // at 6: Trigger interrupt enable
    COMIE // at 5: COM interrupt enable
    3
    CC1IE // at 1: Capture/Compare 1 interrupt enable
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    22
    CC1OF // at 9: Capture/Compare 1 overcapture flag
    1
    BIF // at 7: Break interrupt flag
    TIF // at 6: Trigger interrupt flag
    COMIF // at 5: COM interrupt flag
    3
    CC1IF // at 1: Capture/compare 1 interrupt flag
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    24
    BG // at 7: Break generation
    TG // at 6: Trigger generation
    COMG // at 5: Capture/Compare control update generation
    3
    CC1G // at 1: Capture/compare 1 generation
    UG // at 0: Update generation
  }

//---  Register CCMR1_Output: capture/compare mode register (output           mode)
  CCMR1_Output @offset 0x18 $u32 {
    15
    OC1M_2 // at 16: Output Compare 1 mode
    9
    OC1M:3 // at 4: Output Compare 1 mode
    OC1PE // at 3: Output Compare 1 preload enable
    OC1FE // at 2: Output Compare 1 fast enable
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR1_Input: capture/compare mode register 1 (input           mode)
  CCMR1_Input @offset 0x18 $u32 {
    24
    IC1F:4 // at 4: Input capture 1 filter
    IC1PSC:2 // at 2: Input capture 1 prescaler
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCER: capture/compare enable           register
  CCER @offset 0x20 $u32 {
    28
    CC1NP // at 3: Capture/Compare 1 output Polarity
    CC1NE // at 2: Capture/Compare 1 complementary output enable
    CC1P // at 1: Capture/Compare 1 output Polarity
    CC1E // at 0: Capture/Compare 1 output enable
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    UIFCPY // at 31: UIF Copy
    15
    CNT:16 // at 0: counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    16
    ARR:16 // at 0: Auto-reload value
  }

//---  Register RCR: repetition counter register
  RCR @offset 0x30 $u32 {
    24
    REP:8 // at 0: Repetition counter value
  }

//---  Register CCR1: capture/compare register 1
  CCR1 @offset 0x34 $u32 {
    16
    CCR1:16 // at 0: Capture/Compare 1 value
  }

//---  Register BDTR: break and dead-time register
  BDTR @offset 0x44 $u32 {
    12
    BKF:4 // at 16: Break filter
    MOE // at 15: Main output enable
    AOE // at 14: Automatic output enable
    BKP // at 13: Break polarity
    BKE // at 12: Break enable
    OSSR // at 11: Off-state selection for Run mode
    OSSI // at 10: Off-state selection for Idle mode
    LOCK:2 // at 8: Lock configuration
    DTG:8 // at 0: Dead-time generator setup
  }

//---  Register DCR: DMA control register
  DCR @offset 0x48 $u32 {
    19
    DBL:5 // at 8: DMA burst length
    3
    DBA:5 // at 0: DMA base address
  }

//---  Register DMAR: DMA address for full transfer
  DMAR @offset 0x4c $u32 {
    16
    DMAB:16 // at 0: DMA register for burst accesses
  }

//---  Register CCR2: TIM15 capture/compare register           2
  CCR2 @offset 0x38 $u32 {
    16
    CCR2:16 // at 0: Capture/Compare 2 value
  }

//---  Register OR1: TIM15 option register 1
  OR1 @offset 0x50 $u32 {
    29
    ENCODER_MODE:2 // at 1: Encoder mode
    TI1_RMP // at 0: Input capture 1 remap
  }

//---  Register OR2: TIM15 option register 2
  OR2 @offset 0x60 $u32 {
    20
    BKCMP2P // at 11: BRK COMP2 input polarity
    BKCMP1P // at 10: BRK COMP1 input polarity
    BKINP // at 9: BRK BKIN input polarity
    6
    BKCMP2E // at 2: BRK COMP2 enable
    BKCMP1E // at 1: BRK COMP1 enable
    BKINE // at 0: BRK BKIN input enable
  }

//---  Register SMCR: TIM15 slave mode control           register
  SMCR @offset 0x8 $u32 {
    15
    SMS_16 // at 16: SMS bit 16
    8
    MSM // at 7: MSM
    TS:3 // at 4: TS
    1
    SMS:3 // at 0: SMS
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM16: General purpose timers
//------------------------------------------------------------------------------

registers ©TIM16 @at 0x40014400 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    20
    UIFREMAP // at 11: UIF status bit remapping
    1
    CKD:2 // at 8: Clock division
    ARPE // at 7: Auto-reload preload enable
    3
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    22
    OIS1N // at 9: Output Idle state 1
    OIS1 // at 8: Output Idle state 1
    4
    CCDS // at 3: Capture/compare DMA selection
    CCUS // at 2: Capture/compare control update selection
    1
    CCPC // at 0: Capture/compare preloaded control
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    17
    TDE // at 14: Trigger DMA request enable
    COMDE // at 13: COM DMA request enable
    3
    CC1DE // at 9: Capture/Compare 1 DMA request enable
    UDE // at 8: Update DMA request enable
    BIE // at 7: Break interrupt enable
    TIE // at 6: Trigger interrupt enable
    COMIE // at 5: COM interrupt enable
    3
    CC1IE // at 1: Capture/Compare 1 interrupt enable
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    22
    CC1OF // at 9: Capture/Compare 1 overcapture flag
    1
    BIF // at 7: Break interrupt flag
    TIF // at 6: Trigger interrupt flag
    COMIF // at 5: COM interrupt flag
    3
    CC1IF // at 1: Capture/compare 1 interrupt flag
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    24
    BG // at 7: Break generation
    TG // at 6: Trigger generation
    COMG // at 5: Capture/Compare control update generation
    3
    CC1G // at 1: Capture/compare 1 generation
    UG // at 0: Update generation
  }

//---  Register CCMR1_Output: capture/compare mode register (output           mode)
  CCMR1_Output @offset 0x18 $u32 {
    15
    OC1M_2 // at 16: Output Compare 1 mode
    9
    OC1M:3 // at 4: Output Compare 1 mode
    OC1PE // at 3: Output Compare 1 preload enable
    OC1FE // at 2: Output Compare 1 fast enable
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR1_Input: capture/compare mode register 1 (input           mode)
  CCMR1_Input @offset 0x18 $u32 {
    24
    IC1F:4 // at 4: Input capture 1 filter
    IC1PSC:2 // at 2: Input capture 1 prescaler
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCER: capture/compare enable           register
  CCER @offset 0x20 $u32 {
    28
    CC1NP // at 3: Capture/Compare 1 output Polarity
    CC1NE // at 2: Capture/Compare 1 complementary output enable
    CC1P // at 1: Capture/Compare 1 output Polarity
    CC1E // at 0: Capture/Compare 1 output enable
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    UIFCPY // at 31: UIF Copy
    15
    CNT:16 // at 0: counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    16
    ARR:16 // at 0: Auto-reload value
  }

//---  Register RCR: repetition counter register
  RCR @offset 0x30 $u32 {
    24
    REP:8 // at 0: Repetition counter value
  }

//---  Register CCR1: capture/compare register 1
  CCR1 @offset 0x34 $u32 {
    16
    CCR1:16 // at 0: Capture/Compare 1 value
  }

//---  Register BDTR: break and dead-time register
  BDTR @offset 0x44 $u32 {
    12
    BKF:4 // at 16: Break filter
    MOE // at 15: Main output enable
    AOE // at 14: Automatic output enable
    BKP // at 13: Break polarity
    BKE // at 12: Break enable
    OSSR // at 11: Off-state selection for Run mode
    OSSI // at 10: Off-state selection for Idle mode
    LOCK:2 // at 8: Lock configuration
    DTG:8 // at 0: Dead-time generator setup
  }

//---  Register DCR: DMA control register
  DCR @offset 0x48 $u32 {
    19
    DBL:5 // at 8: DMA burst length
    3
    DBA:5 // at 0: DMA base address
  }

//---  Register DMAR: DMA address for full transfer
  DMAR @offset 0x4c $u32 {
    16
    DMAB:16 // at 0: DMA register for burst accesses
  }

//---  Register OR1: TIM16 option register 1
  OR1 @offset 0x50 $u32 {
    30
    TI1_RMP:2 // at 0: Input capture 1 remap
  }

//---  Register OR2: TIM17 option register 1
  OR2 @offset 0x60 $u32 {
    20
    BKCMP2P // at 11: BRK COMP2 input polarit
    BKCMP1P // at 10: BRK COMP1 input polarity
    BKINP // at 9: BRK BKIN input polarity
    BKDFBK1E // at 8: BRK DFSDM_BREAK1 enable
    5
    BKCMP2E // at 2: BRK COMP2 enable
    BKCMP1E // at 1: BRK COMP1 enable
    BKINE // at 0: BRK BKIN input enable
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM2: General-purpose-timers
//------------------------------------------------------------------------------

registers ©TIM2 @at 0x40000000 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    22
    CKD:2 // at 8: Clock division
    ARPE // at 7: Auto-reload preload enable
    CMS:2 // at 5: Center-aligned mode selection
    DIR // at 4: Direction
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    24
    TI1S // at 7: TI1 selection
    MMS:3 // at 4: Master mode selection
    CCDS // at 3: Capture/compare DMA selection
    3
  }

//---  Register SMCR: slave mode control register
  SMCR @offset 0x8 $u32 {
    16
    ETP // at 15: External trigger polarity
    ECE // at 14: External clock enable
    ETPS:2 // at 12: External trigger prescaler
    ETF:4 // at 8: External trigger filter
    MSM // at 7: Master/Slave mode
    TS:3 // at 4: Trigger selection
    1
    SMS:3 // at 0: Slave mode selection
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    17
    TDE // at 14: Trigger DMA request enable
    COMDE // at 13: COM DMA request enable
    CC4DE // at 12: Capture/Compare 4 DMA request enable
    CC3DE // at 11: Capture/Compare 3 DMA request enable
    CC2DE // at 10: Capture/Compare 2 DMA request enable
    CC1DE // at 9: Capture/Compare 1 DMA request enable
    UDE // at 8: Update DMA request enable
    1
    TIE // at 6: Trigger interrupt enable
    1
    CC4IE // at 4: Capture/Compare 4 interrupt enable
    CC3IE // at 3: Capture/Compare 3 interrupt enable
    CC2IE // at 2: Capture/Compare 2 interrupt enable
    CC1IE // at 1: Capture/Compare 1 interrupt enable
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    19
    CC4OF // at 12: Capture/Compare 4 overcapture flag
    CC3OF // at 11: Capture/Compare 3 overcapture flag
    CC2OF // at 10: Capture/compare 2 overcapture flag
    CC1OF // at 9: Capture/Compare 1 overcapture flag
    2
    TIF // at 6: Trigger interrupt flag
    1
    CC4IF // at 4: Capture/Compare 4 interrupt flag
    CC3IF // at 3: Capture/Compare 3 interrupt flag
    CC2IF // at 2: Capture/Compare 2 interrupt flag
    CC1IF // at 1: Capture/compare 1 interrupt flag
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    25
    TG // at 6: Trigger generation
    1
    CC4G // at 4: Capture/compare 4 generation
    CC3G // at 3: Capture/compare 3 generation
    CC2G // at 2: Capture/compare 2 generation
    CC1G // at 1: Capture/compare 1 generation
    UG // at 0: Update generation
  }

//---  Register CCMR1_Output: capture/compare mode register 1 (output           mode)
  CCMR1_Output @offset 0x18 $u32 {
    16
    OC2CE // at 15: Output compare 2 clear enable
    OC2M:3 // at 12: Output compare 2 mode
    OC2PE // at 11: Output compare 2 preload enable
    OC2FE // at 10: Output compare 2 fast enable
    CC2S:2 // at 8: Capture/Compare 2 selection
    OC1CE // at 7: Output compare 1 clear enable
    OC1M:3 // at 4: Output compare 1 mode
    OC1PE // at 3: Output compare 1 preload enable
    OC1FE // at 2: Output compare 1 fast enable
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR1_Input: capture/compare mode register 1 (input           mode)
  CCMR1_Input @offset 0x18 $u32 {
    16
    IC2F:4 // at 12: Input capture 2 filter
    IC2PSC:2 // at 10: Input capture 2 prescaler
    CC2S:2 // at 8: Capture/compare 2 selection
    IC1F:4 // at 4: Input capture 1 filter
    IC1PSC:2 // at 2: Input capture 1 prescaler
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR2_Output: capture/compare mode register 2 (output           mode)
  CCMR2_Output @offset 0x1c $u32 {
    16
    OC4CE // at 15: Output compare 4 clear enable
    OC4M:3 // at 12: Output compare 4 mode
    OC4PE // at 11: Output compare 4 preload enable
    OC4FE // at 10: Output compare 4 fast enable
    CC4S:2 // at 8: Capture/Compare 4 selection
    OC3CE // at 7: Output compare 3 clear enable
    OC3M:3 // at 4: Output compare 3 mode
    OC3PE // at 3: Output compare 3 preload enable
    OC3FE // at 2: Output compare 3 fast enable
    CC3S:2 // at 0: Capture/Compare 3 selection
  }

//---  Register CCMR2_Input: capture/compare mode register 2 (input           mode)
  CCMR2_Input @offset 0x1c $u32 {
    16
    IC4F:4 // at 12: Input capture 4 filter
    IC4PSC:2 // at 10: Input capture 4 prescaler
    CC4S:2 // at 8: Capture/Compare 4 selection
    IC3F:4 // at 4: Input capture 3 filter
    IC3PSC:2 // at 2: Input capture 3 prescaler
    CC3S:2 // at 0: Capture/Compare 3 selection
  }

//---  Register CCER: capture/compare enable           register
  CCER @offset 0x20 $u32 {
    16
    CC4NP // at 15: Capture/Compare 4 output Polarity
    1
    CC4P // at 13: Capture/Compare 3 output Polarity
    CC4E // at 12: Capture/Compare 4 output enable
    CC3NP // at 11: Capture/Compare 3 output Polarity
    1
    CC3P // at 9: Capture/Compare 3 output Polarity
    CC3E // at 8: Capture/Compare 3 output enable
    CC2NP // at 7: Capture/Compare 2 output Polarity
    1
    CC2P // at 5: Capture/Compare 2 output Polarity
    CC2E // at 4: Capture/Compare 2 output enable
    CC1NP // at 3: Capture/Compare 1 output Polarity
    1
    CC1P // at 1: Capture/Compare 1 output Polarity
    CC1E // at 0: Capture/Compare 1 output enable
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    CNT_H:16 // at 16: High counter value (TIM2 only)
    CNT_L:16 // at 0: Low counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    ARR_H:16 // at 16: High Auto-reload value (TIM2 only)
    ARR_L:16 // at 0: Low Auto-reload value
  }

//---  Register CCR1: capture/compare register 1
  CCR1 @offset 0x34 $u32 {
    CCR1_H:16 // at 16: High Capture/Compare 1 value (TIM2 only)
    CCR1_L:16 // at 0: Low Capture/Compare 1 value
  }

//---  Register CCR2: capture/compare register 2
  CCR2 @offset 0x38 $u32 {
    CCR2_H:16 // at 16: High Capture/Compare 2 value (TIM2 only)
    CCR2_L:16 // at 0: Low Capture/Compare 2 value
  }

//---  Register CCR3: capture/compare register 3
  CCR3 @offset 0x3c $u32 {
    CCR3_H:16 // at 16: High Capture/Compare value (TIM2 only)
    CCR3_L:16 // at 0: Low Capture/Compare value
  }

//---  Register CCR4: capture/compare register 4
  CCR4 @offset 0x40 $u32 {
    CCR4_H:16 // at 16: High Capture/Compare value (TIM2 only)
    CCR4_L:16 // at 0: Low Capture/Compare value
  }

//---  Register DCR: DMA control register
  DCR @offset 0x48 $u32 {
    19
    DBL:5 // at 8: DMA burst length
    3
    DBA:5 // at 0: DMA base address
  }

//---  Register DMAR: DMA address for full transfer
  DMAR @offset 0x4c $u32 {
    16
    DMAB:16 // at 0: DMA register for burst accesses
  }

//---  Register OR: TIM2 option register
  OR @offset 0x50 $u32 {
    27
    TI4_RMP:2 // at 3: Internal trigger
    ETR_RMP:3 // at 0: Timer2 ETR remap
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM3
//------------------------------------------------------------------------------

registers ©TIM3 @at 0x40000400 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    22
    CKD:2 // at 8: Clock division
    ARPE // at 7: Auto-reload preload enable
    CMS:2 // at 5: Center-aligned mode selection
    DIR // at 4: Direction
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    24
    TI1S // at 7: TI1 selection
    MMS:3 // at 4: Master mode selection
    CCDS // at 3: Capture/compare DMA selection
    3
  }

//---  Register SMCR: slave mode control register
  SMCR @offset 0x8 $u32 {
    16
    ETP // at 15: External trigger polarity
    ECE // at 14: External clock enable
    ETPS:2 // at 12: External trigger prescaler
    ETF:4 // at 8: External trigger filter
    MSM // at 7: Master/Slave mode
    TS:3 // at 4: Trigger selection
    1
    SMS:3 // at 0: Slave mode selection
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    17
    TDE // at 14: Trigger DMA request enable
    COMDE // at 13: COM DMA request enable
    CC4DE // at 12: Capture/Compare 4 DMA request enable
    CC3DE // at 11: Capture/Compare 3 DMA request enable
    CC2DE // at 10: Capture/Compare 2 DMA request enable
    CC1DE // at 9: Capture/Compare 1 DMA request enable
    UDE // at 8: Update DMA request enable
    1
    TIE // at 6: Trigger interrupt enable
    1
    CC4IE // at 4: Capture/Compare 4 interrupt enable
    CC3IE // at 3: Capture/Compare 3 interrupt enable
    CC2IE // at 2: Capture/Compare 2 interrupt enable
    CC1IE // at 1: Capture/Compare 1 interrupt enable
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    19
    CC4OF // at 12: Capture/Compare 4 overcapture flag
    CC3OF // at 11: Capture/Compare 3 overcapture flag
    CC2OF // at 10: Capture/compare 2 overcapture flag
    CC1OF // at 9: Capture/Compare 1 overcapture flag
    2
    TIF // at 6: Trigger interrupt flag
    1
    CC4IF // at 4: Capture/Compare 4 interrupt flag
    CC3IF // at 3: Capture/Compare 3 interrupt flag
    CC2IF // at 2: Capture/Compare 2 interrupt flag
    CC1IF // at 1: Capture/compare 1 interrupt flag
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    25
    TG // at 6: Trigger generation
    1
    CC4G // at 4: Capture/compare 4 generation
    CC3G // at 3: Capture/compare 3 generation
    CC2G // at 2: Capture/compare 2 generation
    CC1G // at 1: Capture/compare 1 generation
    UG // at 0: Update generation
  }

//---  Register CCMR1_Output: capture/compare mode register 1 (output           mode)
  CCMR1_Output @offset 0x18 $u32 {
    16
    OC2CE // at 15: Output compare 2 clear enable
    OC2M:3 // at 12: Output compare 2 mode
    OC2PE // at 11: Output compare 2 preload enable
    OC2FE // at 10: Output compare 2 fast enable
    CC2S:2 // at 8: Capture/Compare 2 selection
    OC1CE // at 7: Output compare 1 clear enable
    OC1M:3 // at 4: Output compare 1 mode
    OC1PE // at 3: Output compare 1 preload enable
    OC1FE // at 2: Output compare 1 fast enable
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR1_Input: capture/compare mode register 1 (input           mode)
  CCMR1_Input @offset 0x18 $u32 {
    16
    IC2F:4 // at 12: Input capture 2 filter
    IC2PSC:2 // at 10: Input capture 2 prescaler
    CC2S:2 // at 8: Capture/compare 2 selection
    IC1F:4 // at 4: Input capture 1 filter
    IC1PSC:2 // at 2: Input capture 1 prescaler
    CC1S:2 // at 0: Capture/Compare 1 selection
  }

//---  Register CCMR2_Output: capture/compare mode register 2 (output           mode)
  CCMR2_Output @offset 0x1c $u32 {
    16
    OC4CE // at 15: Output compare 4 clear enable
    OC4M:3 // at 12: Output compare 4 mode
    OC4PE // at 11: Output compare 4 preload enable
    OC4FE // at 10: Output compare 4 fast enable
    CC4S:2 // at 8: Capture/Compare 4 selection
    OC3CE // at 7: Output compare 3 clear enable
    OC3M:3 // at 4: Output compare 3 mode
    OC3PE // at 3: Output compare 3 preload enable
    OC3FE // at 2: Output compare 3 fast enable
    CC3S:2 // at 0: Capture/Compare 3 selection
  }

//---  Register CCMR2_Input: capture/compare mode register 2 (input           mode)
  CCMR2_Input @offset 0x1c $u32 {
    16
    IC4F:4 // at 12: Input capture 4 filter
    IC4PSC:2 // at 10: Input capture 4 prescaler
    CC4S:2 // at 8: Capture/Compare 4 selection
    IC3F:4 // at 4: Input capture 3 filter
    IC3PSC:2 // at 2: Input capture 3 prescaler
    CC3S:2 // at 0: Capture/Compare 3 selection
  }

//---  Register CCER: capture/compare enable           register
  CCER @offset 0x20 $u32 {
    16
    CC4NP // at 15: Capture/Compare 4 output Polarity
    1
    CC4P // at 13: Capture/Compare 3 output Polarity
    CC4E // at 12: Capture/Compare 4 output enable
    CC3NP // at 11: Capture/Compare 3 output Polarity
    1
    CC3P // at 9: Capture/Compare 3 output Polarity
    CC3E // at 8: Capture/Compare 3 output enable
    CC2NP // at 7: Capture/Compare 2 output Polarity
    1
    CC2P // at 5: Capture/Compare 2 output Polarity
    CC2E // at 4: Capture/Compare 2 output enable
    CC1NP // at 3: Capture/Compare 1 output Polarity
    1
    CC1P // at 1: Capture/Compare 1 output Polarity
    CC1E // at 0: Capture/Compare 1 output enable
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    CNT_H:16 // at 16: High counter value (TIM2 only)
    CNT_L:16 // at 0: Low counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    ARR_H:16 // at 16: High Auto-reload value (TIM2 only)
    ARR_L:16 // at 0: Low Auto-reload value
  }

//---  Register CCR1: capture/compare register 1
  CCR1 @offset 0x34 $u32 {
    CCR1_H:16 // at 16: High Capture/Compare 1 value (TIM2 only)
    CCR1_L:16 // at 0: Low Capture/Compare 1 value
  }

//---  Register CCR2: capture/compare register 2
  CCR2 @offset 0x38 $u32 {
    CCR2_H:16 // at 16: High Capture/Compare 2 value (TIM2 only)
    CCR2_L:16 // at 0: Low Capture/Compare 2 value
  }

//---  Register CCR3: capture/compare register 3
  CCR3 @offset 0x3c $u32 {
    CCR3_H:16 // at 16: High Capture/Compare value (TIM2 only)
    CCR3_L:16 // at 0: Low Capture/Compare value
  }

//---  Register CCR4: capture/compare register 4
  CCR4 @offset 0x40 $u32 {
    CCR4_H:16 // at 16: High Capture/Compare value (TIM2 only)
    CCR4_L:16 // at 0: Low Capture/Compare value
  }

//---  Register DCR: DMA control register
  DCR @offset 0x48 $u32 {
    19
    DBL:5 // at 8: DMA burst length
    3
    DBA:5 // at 0: DMA base address
  }

//---  Register DMAR: DMA address for full transfer
  DMAR @offset 0x4c $u32 {
    16
    DMAB:16 // at 0: DMA register for burst accesses
  }

//---  Register OR: TIM2 option register
  OR @offset 0x50 $u32 {
    27
    TI4_RMP:2 // at 3: Internal trigger
    ETR_RMP:3 // at 0: Timer2 ETR remap
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM6: Basic-timers
//------------------------------------------------------------------------------

registers ©TIM6 @at 0x40001000 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    24
    ARPE // at 7: Auto-reload preload enable
    3
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    25
    MMS:3 // at 4: Master mode selection
    4
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    23
    UDE // at 8: Update DMA request enable
    7
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    31
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    31
    UG // at 0: Update generation
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    16
    CNT:16 // at 0: Low counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    16
    ARR:16 // at 0: Low Auto-reload value
  }

}

//------------------------------------------------------------------------------
// Peripheral TIM7
//------------------------------------------------------------------------------

registers ©TIM7 @at 0x40001400 {
//---  Register CR1: control register 1
  CR1 @offset 0x0 $u32 {
    24
    ARPE // at 7: Auto-reload preload enable
    3
    OPM // at 3: One-pulse mode
    URS // at 2: Update request source
    UDIS // at 1: Update disable
    CEN // at 0: Counter enable
  }

//---  Register CR2: control register 2
  CR2 @offset 0x4 $u32 {
    25
    MMS:3 // at 4: Master mode selection
    4
  }

//---  Register DIER: DMA/Interrupt enable register
  DIER @offset 0xc $u32 {
    23
    UDE // at 8: Update DMA request enable
    7
    UIE // at 0: Update interrupt enable
  }

//---  Register SR: status register
  SR @offset 0x10 $u32 {
    31
    UIF // at 0: Update interrupt flag
  }

//---  Register EGR: event generation register
  EGR @offset 0x14 $u32 {
    31
    UG // at 0: Update generation
  }

//---  Register CNT: counter
  CNT @offset 0x24 $u32 {
    16
    CNT:16 // at 0: Low counter value
  }

//---  Register PSC: prescaler
  PSC @offset 0x28 $u32 {
    16
    PSC:16 // at 0: Prescaler value
  }

//---  Register ARR: auto-reload register
  ARR @offset 0x2c $u32 {
    16
    ARR:16 // at 0: Low Auto-reload value
  }

}

//------------------------------------------------------------------------------
// Peripheral TSC: Touch sensing controller
//------------------------------------------------------------------------------

registers ©TSC @at 0x40024000 {
//---  Register CR: control register
  CR @offset 0x0 $u32 {
    CTPH:4 // at 28: Charge transfer pulse high
    CTPL:4 // at 24: Charge transfer pulse low
    SSD:7 // at 17: Spread spectrum deviation
    SSE // at 16: Spread spectrum enable
    SSPSC // at 15: Spread spectrum prescaler
    PGPSC:3 // at 12: pulse generator prescaler
    4
    MCV:3 // at 5: Max count value
    IODEF // at 4: I/O Default mode
    SYNCPOL // at 3: Synchronization pin polarity
    AM // at 2: Acquisition mode
    START // at 1: Start a new acquisition
    TSCE // at 0: Touch sensing controller enable
  }

//---  Register IER: interrupt enable register
  IER @offset 0x4 $u32 {
    30
    MCEIE // at 1: Max count error interrupt enable
    EOAIE // at 0: End of acquisition interrupt enable
  }

//---  Register ICR: interrupt clear register
  ICR @offset 0x8 $u32 {
    30
    MCEIC // at 1: Max count error interrupt clear
    EOAIC // at 0: End of acquisition interrupt clear
  }

//---  Register ISR: interrupt status register
  ISR @offset 0xc $u32 {
    30
    MCEF // at 1: Max count error flag
    EOAF // at 0: End of acquisition flag
  }

//---  Register IOHCR: I/O hysteresis control           register
  IOHCR @offset 0x10 $u32 {
    G8_IO4 // at 31: G8_IO4
    G8_IO3 // at 30: G8_IO3
    G8_IO2 // at 29: G8_IO2
    G8_IO1 // at 28: G8_IO1
    G7_IO4 // at 27: G7_IO4
    G7_IO3 // at 26: G7_IO3
    G7_IO2 // at 25: G7_IO2
    G7_IO1 // at 24: G7_IO1
    G6_IO4 // at 23: G6_IO4
    G6_IO3 // at 22: G6_IO3
    G6_IO2 // at 21: G6_IO2
    G6_IO1 // at 20: G6_IO1
    G5_IO4 // at 19: G5_IO4
    G5_IO3 // at 18: G5_IO3
    G5_IO2 // at 17: G5_IO2
    G5_IO1 // at 16: G5_IO1
    G4_IO4 // at 15: G4_IO4
    G4_IO3 // at 14: G4_IO3
    G4_IO2 // at 13: G4_IO2
    G4_IO1 // at 12: G4_IO1
    G3_IO4 // at 11: G3_IO4
    G3_IO3 // at 10: G3_IO3
    G3_IO2 // at 9: G3_IO2
    G3_IO1 // at 8: G3_IO1
    G2_IO4 // at 7: G2_IO4
    G2_IO3 // at 6: G2_IO3
    G2_IO2 // at 5: G2_IO2
    G2_IO1 // at 4: G2_IO1
    G1_IO4 // at 3: G1_IO4
    G1_IO3 // at 2: G1_IO3
    G1_IO2 // at 1: G1_IO2
    G1_IO1 // at 0: G1_IO1
  }

//---  Register IOASCR: I/O analog switch control           register
  IOASCR @offset 0x18 $u32 {
    G8_IO4 // at 31: G8_IO4
    G8_IO3 // at 30: G8_IO3
    G8_IO2 // at 29: G8_IO2
    G8_IO1 // at 28: G8_IO1
    G7_IO4 // at 27: G7_IO4
    G7_IO3 // at 26: G7_IO3
    G7_IO2 // at 25: G7_IO2
    G7_IO1 // at 24: G7_IO1
    G6_IO4 // at 23: G6_IO4
    G6_IO3 // at 22: G6_IO3
    G6_IO2 // at 21: G6_IO2
    G6_IO1 // at 20: G6_IO1
    G5_IO4 // at 19: G5_IO4
    G5_IO3 // at 18: G5_IO3
    G5_IO2 // at 17: G5_IO2
    G5_IO1 // at 16: G5_IO1
    G4_IO4 // at 15: G4_IO4
    G4_IO3 // at 14: G4_IO3
    G4_IO2 // at 13: G4_IO2
    G4_IO1 // at 12: G4_IO1
    G3_IO4 // at 11: G3_IO4
    G3_IO3 // at 10: G3_IO3
    G3_IO2 // at 9: G3_IO2
    G3_IO1 // at 8: G3_IO1
    G2_IO4 // at 7: G2_IO4
    G2_IO3 // at 6: G2_IO3
    G2_IO2 // at 5: G2_IO2
    G2_IO1 // at 4: G2_IO1
    G1_IO4 // at 3: G1_IO4
    G1_IO3 // at 2: G1_IO3
    G1_IO2 // at 1: G1_IO2
    G1_IO1 // at 0: G1_IO1
  }

//---  Register IOSCR: I/O sampling control register
  IOSCR @offset 0x20 $u32 {
    G8_IO4 // at 31: G8_IO4
    G8_IO3 // at 30: G8_IO3
    G8_IO2 // at 29: G8_IO2
    G8_IO1 // at 28: G8_IO1
    G7_IO4 // at 27: G7_IO4
    G7_IO3 // at 26: G7_IO3
    G7_IO2 // at 25: G7_IO2
    G7_IO1 // at 24: G7_IO1
    G6_IO4 // at 23: G6_IO4
    G6_IO3 // at 22: G6_IO3
    G6_IO2 // at 21: G6_IO2
    G6_IO1 // at 20: G6_IO1
    G5_IO4 // at 19: G5_IO4
    G5_IO3 // at 18: G5_IO3
    G5_IO2 // at 17: G5_IO2
    G5_IO1 // at 16: G5_IO1
    G4_IO4 // at 15: G4_IO4
    G4_IO3 // at 14: G4_IO3
    G4_IO2 // at 13: G4_IO2
    G4_IO1 // at 12: G4_IO1
    G3_IO4 // at 11: G3_IO4
    G3_IO3 // at 10: G3_IO3
    G3_IO2 // at 9: G3_IO2
    G3_IO1 // at 8: G3_IO1
    G2_IO4 // at 7: G2_IO4
    G2_IO3 // at 6: G2_IO3
    G2_IO2 // at 5: G2_IO2
    G2_IO1 // at 4: G2_IO1
    G1_IO4 // at 3: G1_IO4
    G1_IO3 // at 2: G1_IO3
    G1_IO2 // at 1: G1_IO2
    G1_IO1 // at 0: G1_IO1
  }

//---  Register IOCCR: I/O channel control register
  IOCCR @offset 0x28 $u32 {
    G8_IO4 // at 31: G8_IO4
    G8_IO3 // at 30: G8_IO3
    G8_IO2 // at 29: G8_IO2
    G8_IO1 // at 28: G8_IO1
    G7_IO4 // at 27: G7_IO4
    G7_IO3 // at 26: G7_IO3
    G7_IO2 // at 25: G7_IO2
    G7_IO1 // at 24: G7_IO1
    G6_IO4 // at 23: G6_IO4
    G6_IO3 // at 22: G6_IO3
    G6_IO2 // at 21: G6_IO2
    G6_IO1 // at 20: G6_IO1
    G5_IO4 // at 19: G5_IO4
    G5_IO3 // at 18: G5_IO3
    G5_IO2 // at 17: G5_IO2
    G5_IO1 // at 16: G5_IO1
    G4_IO4 // at 15: G4_IO4
    G4_IO3 // at 14: G4_IO3
    G4_IO2 // at 13: G4_IO2
    G4_IO1 // at 12: G4_IO1
    G3_IO4 // at 11: G3_IO4
    G3_IO3 // at 10: G3_IO3
    G3_IO2 // at 9: G3_IO2
    G3_IO1 // at 8: G3_IO1
    G2_IO4 // at 7: G2_IO4
    G2_IO3 // at 6: G2_IO3
    G2_IO2 // at 5: G2_IO2
    G2_IO1 // at 4: G2_IO1
    G1_IO4 // at 3: G1_IO4
    G1_IO3 // at 2: G1_IO3
    G1_IO2 // at 1: G1_IO2
    G1_IO1 // at 0: G1_IO1
  }

//---  Register IOGCSR: I/O group control status           register
  IOGCSR @offset 0x30 $u32 {
    8
    G8S // at 23: Analog I/O group x status
    G7S // at 22: Analog I/O group x status
    G6S // at 21: Analog I/O group x status
    G5S // at 20: Analog I/O group x status
    G4S // at 19: Analog I/O group x status
    G3S // at 18: Analog I/O group x status
    G2S // at 17: Analog I/O group x status
    G1S // at 16: Analog I/O group x status
    8
    G8E // at 7: Analog I/O group x enable
    G7E // at 6: Analog I/O group x enable
    G6E // at 5: Analog I/O group x enable
    G5E // at 4: Analog I/O group x enable
    G4E // at 3: Analog I/O group x enable
    G3E // at 2: Analog I/O group x enable
    G2E // at 1: Analog I/O group x enable
    G1E // at 0: Analog I/O group x enable
  }

//---  Register IOG1CR: I/O group x counter register
  IOG1CR @offset 0x34 @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG2CR: I/O group x counter register
  IOG2CR @offset 0x38 @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG3CR: I/O group x counter register
  IOG3CR @offset 0x3c @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG4CR: I/O group x counter register
  IOG4CR @offset 0x40 @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG5CR: I/O group x counter register
  IOG5CR @offset 0x44 @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG6CR: I/O group x counter register
  IOG6CR @offset 0x48 @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG7CR: I/O group x counter register
  IOG7CR @offset 0x4c @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

//---  Register IOG8CR: I/O group x counter register
  IOG8CR @offset 0x50 @ro $u32 {
    18
    CNT:14 // at 0: Counter value
  }

}

//------------------------------------------------------------------------------
// Peripheral UART4
//------------------------------------------------------------------------------

registers ©UART4 @at 0x40004c00 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    3
    M1 // at 28: Word length
    EOBIE // at 27: End of Block interrupt enable
    RTOIE // at 26: Receiver timeout interrupt enable
    DEAT4 // at 25: Driver Enable assertion time
    DEAT3 // at 24: DEAT3
    DEAT2 // at 23: DEAT2
    DEAT1 // at 22: DEAT1
    DEAT0 // at 21: DEAT0
    DEDT4 // at 20: Driver Enable de-assertion time
    DEDT3 // at 19: DEDT3
    DEDT2 // at 18: DEDT2
    DEDT1 // at 17: DEDT1
    DEDT0 // at 16: DEDT0
    OVER8 // at 15: Oversampling mode
    CMIE // at 14: Character match interrupt enable
    MME // at 13: Mute mode enable
    M0 // at 12: Word length
    WAKE // at 11: Receiver wakeup method
    PCE // at 10: Parity control enable
    PS // at 9: Parity selection
    PEIE // at 8: PE interrupt enable
    TXEIE // at 7: interrupt enable
    TCIE // at 6: Transmission complete interrupt enable
    RXNEIE // at 5: RXNE interrupt enable
    IDLEIE // at 4: IDLE interrupt enable
    TE // at 3: Transmitter enable
    RE // at 2: Receiver enable
    UESM // at 1: USART enable in Stop mode
    UE // at 0: USART enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    ADD4_7:4 // at 28: Address of the USART node
    ADD0_3:4 // at 24: Address of the USART node
    RTOEN // at 23: Receiver timeout enable
    ABRMOD1 // at 22: Auto baud rate mode
    ABRMOD0 // at 21: ABRMOD0
    ABREN // at 20: Auto baud rate enable
    MSBFIRST // at 19: Most significant bit first
    TAINV // at 18: Binary data inversion
    TXINV // at 17: TX pin active level inversion
    RXINV // at 16: RX pin active level inversion
    SWAP // at 15: Swap TX/RX pins
    LINEN // at 14: LIN mode enable
    STOP:2 // at 12: STOP bits
    CLKEN // at 11: Clock enable
    CPOL // at 10: Clock polarity
    CPHA // at 9: Clock phase
    LBCL // at 8: Last bit clock pulse
    1
    LBDIE // at 6: LIN break detection interrupt enable
    LBDL // at 5: LIN break detection length
    ADDM7 // at 4: 7-bit Address Detection/4-bit Address Detection
    4
  }

//---  Register CR3: Control register 3
  CR3 @offset 0x8 $u32 {
    9
    WUFIE // at 22: Wakeup from Stop mode interrupt enable
    WUS:2 // at 20: Wakeup from Stop mode interrupt flag selection
    SCARCNT:3 // at 17: Smartcard auto-retry count
    1
    DEP // at 15: Driver enable polarity selection
    DEM // at 14: Driver enable mode
    DDRE // at 13: DMA Disable on Reception Error
    OVRDIS // at 12: Overrun Disable
    ONEBIT // at 11: One sample bit method enable
    CTSIE // at 10: CTS interrupt enable
    CTSE // at 9: CTS enable
    RTSE // at 8: RTS enable
    DMAT // at 7: DMA enable transmitter
    DMAR // at 6: DMA enable receiver
    SCEN // at 5: Smartcard mode enable
    NACK // at 4: Smartcard NACK enable
    HDSEL // at 3: Half-duplex selection
    IRLP // at 2: Ir low-power
    IREN // at 1: Ir mode enable
    EIE // at 0: Error interrupt enable
  }

//---  Register BRR: Baud rate register
  BRR @offset 0xc $u32 {
    16
    DIV_Mantissa:12 // at 4: DIV_Mantissa
    DIV_Fraction:4 // at 0: DIV_Fraction
  }

//---  Register GTPR: Guard time and prescaler           register
  GTPR @offset 0x10 $u32 {
    16
    GT:8 // at 8: Guard time value
    PSC:8 // at 0: Prescaler value
  }

//---  Register RTOR: Receiver timeout register
  RTOR @offset 0x14 $u32 {
    BLEN:8 // at 24: Block Length
    RTO:24 // at 0: Receiver timeout value
  }

//---  Register RQR: Request register
  RQR @offset 0x18 $u32 {
    27
    TXFRQ // at 4: Transmit data flush request
    RXFRQ // at 3: Receive data flush request
    MMRQ // at 2: Mute mode request
    SBKRQ // at 1: Send break request
    ABRRQ // at 0: Auto baud rate request
  }

//---  Register ISR: Interrupt & status           register
  ISR @offset 0x1c @ro $u32 {
    9
    REACK // at 22: REACK
    TEACK // at 21: TEACK
    WUF // at 20: WUF
    RWU // at 19: RWU
    SBKF // at 18: SBKF
    CMF // at 17: CMF
    BUSY // at 16: BUSY
    ABRF // at 15: ABRF
    ABRE // at 14: ABRE
    1
    EOBF // at 12: EOBF
    RTOF // at 11: RTOF
    CTS // at 10: CTS
    CTSIF // at 9: CTSIF
    LBDF // at 8: LBDF
    TXE // at 7: TXE
    TC // at 6: TC
    RXNE // at 5: RXNE
    IDLE // at 4: IDLE
    ORE // at 3: ORE
    NF // at 2: NF
    FE // at 1: FE
    PE // at 0: PE
  }

//---  Register ICR: Interrupt flag clear register
  ICR @offset 0x20 $u32 {
    11
    WUCF // at 20: Wakeup from Stop mode clear flag
    2
    CMCF // at 17: Character match clear flag
    4
    EOBCF // at 12: End of block clear flag
    RTOCF // at 11: Receiver timeout clear flag
    1
    CTSCF // at 9: CTS clear flag
    LBDCF // at 8: LIN break detection clear flag
    1
    TCCF // at 6: Transmission complete clear flag
    1
    IDLECF // at 4: Idle line detected clear flag
    ORECF // at 3: Overrun error clear flag
    NCF // at 2: Noise detected clear flag
    FECF // at 1: Framing error clear flag
    PECF // at 0: Parity error clear flag
  }

//---  Register RDR: Receive data register
  RDR @offset 0x24 @ro $u32 {
    23
    RDR:9 // at 0: Receive data value
  }

//---  Register TDR: Transmit data register
  TDR @offset 0x28 $u32 {
    23
    TDR:9 // at 0: Transmit data value
  }

}

//------------------------------------------------------------------------------
// Peripheral USART1: Universal synchronous asynchronous receiver       transmitter
//------------------------------------------------------------------------------

registers ©USART1 @at 0x40013800 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    3
    M1 // at 28: Word length
    EOBIE // at 27: End of Block interrupt enable
    RTOIE // at 26: Receiver timeout interrupt enable
    DEAT4 // at 25: Driver Enable assertion time
    DEAT3 // at 24: DEAT3
    DEAT2 // at 23: DEAT2
    DEAT1 // at 22: DEAT1
    DEAT0 // at 21: DEAT0
    DEDT4 // at 20: Driver Enable de-assertion time
    DEDT3 // at 19: DEDT3
    DEDT2 // at 18: DEDT2
    DEDT1 // at 17: DEDT1
    DEDT0 // at 16: DEDT0
    OVER8 // at 15: Oversampling mode
    CMIE // at 14: Character match interrupt enable
    MME // at 13: Mute mode enable
    M0 // at 12: Word length
    WAKE // at 11: Receiver wakeup method
    PCE // at 10: Parity control enable
    PS // at 9: Parity selection
    PEIE // at 8: PE interrupt enable
    TXEIE // at 7: interrupt enable
    TCIE // at 6: Transmission complete interrupt enable
    RXNEIE // at 5: RXNE interrupt enable
    IDLEIE // at 4: IDLE interrupt enable
    TE // at 3: Transmitter enable
    RE // at 2: Receiver enable
    UESM // at 1: USART enable in Stop mode
    UE // at 0: USART enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    ADD4_7:4 // at 28: Address of the USART node
    ADD0_3:4 // at 24: Address of the USART node
    RTOEN // at 23: Receiver timeout enable
    ABRMOD1 // at 22: Auto baud rate mode
    ABRMOD0 // at 21: ABRMOD0
    ABREN // at 20: Auto baud rate enable
    MSBFIRST // at 19: Most significant bit first
    TAINV // at 18: Binary data inversion
    TXINV // at 17: TX pin active level inversion
    RXINV // at 16: RX pin active level inversion
    SWAP // at 15: Swap TX/RX pins
    LINEN // at 14: LIN mode enable
    STOP:2 // at 12: STOP bits
    CLKEN // at 11: Clock enable
    CPOL // at 10: Clock polarity
    CPHA // at 9: Clock phase
    LBCL // at 8: Last bit clock pulse
    1
    LBDIE // at 6: LIN break detection interrupt enable
    LBDL // at 5: LIN break detection length
    ADDM7 // at 4: 7-bit Address Detection/4-bit Address Detection
    4
  }

//---  Register CR3: Control register 3
  CR3 @offset 0x8 $u32 {
    9
    WUFIE // at 22: Wakeup from Stop mode interrupt enable
    WUS:2 // at 20: Wakeup from Stop mode interrupt flag selection
    SCARCNT:3 // at 17: Smartcard auto-retry count
    1
    DEP // at 15: Driver enable polarity selection
    DEM // at 14: Driver enable mode
    DDRE // at 13: DMA Disable on Reception Error
    OVRDIS // at 12: Overrun Disable
    ONEBIT // at 11: One sample bit method enable
    CTSIE // at 10: CTS interrupt enable
    CTSE // at 9: CTS enable
    RTSE // at 8: RTS enable
    DMAT // at 7: DMA enable transmitter
    DMAR // at 6: DMA enable receiver
    SCEN // at 5: Smartcard mode enable
    NACK // at 4: Smartcard NACK enable
    HDSEL // at 3: Half-duplex selection
    IRLP // at 2: Ir low-power
    IREN // at 1: Ir mode enable
    EIE // at 0: Error interrupt enable
  }

//---  Register BRR: Baud rate register
  BRR @offset 0xc $u32 {
    16
    DIV_Mantissa:12 // at 4: DIV_Mantissa
    DIV_Fraction:4 // at 0: DIV_Fraction
  }

//---  Register GTPR: Guard time and prescaler           register
  GTPR @offset 0x10 $u32 {
    16
    GT:8 // at 8: Guard time value
    PSC:8 // at 0: Prescaler value
  }

//---  Register RTOR: Receiver timeout register
  RTOR @offset 0x14 $u32 {
    BLEN:8 // at 24: Block Length
    RTO:24 // at 0: Receiver timeout value
  }

//---  Register RQR: Request register
  RQR @offset 0x18 $u32 {
    27
    TXFRQ // at 4: Transmit data flush request
    RXFRQ // at 3: Receive data flush request
    MMRQ // at 2: Mute mode request
    SBKRQ // at 1: Send break request
    ABRRQ // at 0: Auto baud rate request
  }

//---  Register ISR: Interrupt & status           register
  ISR @offset 0x1c @ro $u32 {
    9
    REACK // at 22: REACK
    TEACK // at 21: TEACK
    WUF // at 20: WUF
    RWU // at 19: RWU
    SBKF // at 18: SBKF
    CMF // at 17: CMF
    BUSY // at 16: BUSY
    ABRF // at 15: ABRF
    ABRE // at 14: ABRE
    1
    EOBF // at 12: EOBF
    RTOF // at 11: RTOF
    CTS // at 10: CTS
    CTSIF // at 9: CTSIF
    LBDF // at 8: LBDF
    TXE // at 7: TXE
    TC // at 6: TC
    RXNE // at 5: RXNE
    IDLE // at 4: IDLE
    ORE // at 3: ORE
    NF // at 2: NF
    FE // at 1: FE
    PE // at 0: PE
  }

//---  Register ICR: Interrupt flag clear register
  ICR @offset 0x20 $u32 {
    11
    WUCF // at 20: Wakeup from Stop mode clear flag
    2
    CMCF // at 17: Character match clear flag
    4
    EOBCF // at 12: End of block clear flag
    RTOCF // at 11: Receiver timeout clear flag
    1
    CTSCF // at 9: CTS clear flag
    LBDCF // at 8: LIN break detection clear flag
    1
    TCCF // at 6: Transmission complete clear flag
    1
    IDLECF // at 4: Idle line detected clear flag
    ORECF // at 3: Overrun error clear flag
    NCF // at 2: Noise detected clear flag
    FECF // at 1: Framing error clear flag
    PECF // at 0: Parity error clear flag
  }

//---  Register RDR: Receive data register
  RDR @offset 0x24 @ro $u32 {
    23
    RDR:9 // at 0: Receive data value
  }

//---  Register TDR: Transmit data register
  TDR @offset 0x28 $u32 {
    23
    TDR:9 // at 0: Transmit data value
  }

}

//------------------------------------------------------------------------------
// Peripheral USART2
//------------------------------------------------------------------------------

registers ©USART2 @at 0x40004400 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    3
    M1 // at 28: Word length
    EOBIE // at 27: End of Block interrupt enable
    RTOIE // at 26: Receiver timeout interrupt enable
    DEAT4 // at 25: Driver Enable assertion time
    DEAT3 // at 24: DEAT3
    DEAT2 // at 23: DEAT2
    DEAT1 // at 22: DEAT1
    DEAT0 // at 21: DEAT0
    DEDT4 // at 20: Driver Enable de-assertion time
    DEDT3 // at 19: DEDT3
    DEDT2 // at 18: DEDT2
    DEDT1 // at 17: DEDT1
    DEDT0 // at 16: DEDT0
    OVER8 // at 15: Oversampling mode
    CMIE // at 14: Character match interrupt enable
    MME // at 13: Mute mode enable
    M0 // at 12: Word length
    WAKE // at 11: Receiver wakeup method
    PCE // at 10: Parity control enable
    PS // at 9: Parity selection
    PEIE // at 8: PE interrupt enable
    TXEIE // at 7: interrupt enable
    TCIE // at 6: Transmission complete interrupt enable
    RXNEIE // at 5: RXNE interrupt enable
    IDLEIE // at 4: IDLE interrupt enable
    TE // at 3: Transmitter enable
    RE // at 2: Receiver enable
    UESM // at 1: USART enable in Stop mode
    UE // at 0: USART enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    ADD4_7:4 // at 28: Address of the USART node
    ADD0_3:4 // at 24: Address of the USART node
    RTOEN // at 23: Receiver timeout enable
    ABRMOD1 // at 22: Auto baud rate mode
    ABRMOD0 // at 21: ABRMOD0
    ABREN // at 20: Auto baud rate enable
    MSBFIRST // at 19: Most significant bit first
    TAINV // at 18: Binary data inversion
    TXINV // at 17: TX pin active level inversion
    RXINV // at 16: RX pin active level inversion
    SWAP // at 15: Swap TX/RX pins
    LINEN // at 14: LIN mode enable
    STOP:2 // at 12: STOP bits
    CLKEN // at 11: Clock enable
    CPOL // at 10: Clock polarity
    CPHA // at 9: Clock phase
    LBCL // at 8: Last bit clock pulse
    1
    LBDIE // at 6: LIN break detection interrupt enable
    LBDL // at 5: LIN break detection length
    ADDM7 // at 4: 7-bit Address Detection/4-bit Address Detection
    4
  }

//---  Register CR3: Control register 3
  CR3 @offset 0x8 $u32 {
    9
    WUFIE // at 22: Wakeup from Stop mode interrupt enable
    WUS:2 // at 20: Wakeup from Stop mode interrupt flag selection
    SCARCNT:3 // at 17: Smartcard auto-retry count
    1
    DEP // at 15: Driver enable polarity selection
    DEM // at 14: Driver enable mode
    DDRE // at 13: DMA Disable on Reception Error
    OVRDIS // at 12: Overrun Disable
    ONEBIT // at 11: One sample bit method enable
    CTSIE // at 10: CTS interrupt enable
    CTSE // at 9: CTS enable
    RTSE // at 8: RTS enable
    DMAT // at 7: DMA enable transmitter
    DMAR // at 6: DMA enable receiver
    SCEN // at 5: Smartcard mode enable
    NACK // at 4: Smartcard NACK enable
    HDSEL // at 3: Half-duplex selection
    IRLP // at 2: Ir low-power
    IREN // at 1: Ir mode enable
    EIE // at 0: Error interrupt enable
  }

//---  Register BRR: Baud rate register
  BRR @offset 0xc $u32 {
    16
    DIV_Mantissa:12 // at 4: DIV_Mantissa
    DIV_Fraction:4 // at 0: DIV_Fraction
  }

//---  Register GTPR: Guard time and prescaler           register
  GTPR @offset 0x10 $u32 {
    16
    GT:8 // at 8: Guard time value
    PSC:8 // at 0: Prescaler value
  }

//---  Register RTOR: Receiver timeout register
  RTOR @offset 0x14 $u32 {
    BLEN:8 // at 24: Block Length
    RTO:24 // at 0: Receiver timeout value
  }

//---  Register RQR: Request register
  RQR @offset 0x18 $u32 {
    27
    TXFRQ // at 4: Transmit data flush request
    RXFRQ // at 3: Receive data flush request
    MMRQ // at 2: Mute mode request
    SBKRQ // at 1: Send break request
    ABRRQ // at 0: Auto baud rate request
  }

//---  Register ISR: Interrupt & status           register
  ISR @offset 0x1c @ro $u32 {
    9
    REACK // at 22: REACK
    TEACK // at 21: TEACK
    WUF // at 20: WUF
    RWU // at 19: RWU
    SBKF // at 18: SBKF
    CMF // at 17: CMF
    BUSY // at 16: BUSY
    ABRF // at 15: ABRF
    ABRE // at 14: ABRE
    1
    EOBF // at 12: EOBF
    RTOF // at 11: RTOF
    CTS // at 10: CTS
    CTSIF // at 9: CTSIF
    LBDF // at 8: LBDF
    TXE // at 7: TXE
    TC // at 6: TC
    RXNE // at 5: RXNE
    IDLE // at 4: IDLE
    ORE // at 3: ORE
    NF // at 2: NF
    FE // at 1: FE
    PE // at 0: PE
  }

//---  Register ICR: Interrupt flag clear register
  ICR @offset 0x20 $u32 {
    11
    WUCF // at 20: Wakeup from Stop mode clear flag
    2
    CMCF // at 17: Character match clear flag
    4
    EOBCF // at 12: End of block clear flag
    RTOCF // at 11: Receiver timeout clear flag
    1
    CTSCF // at 9: CTS clear flag
    LBDCF // at 8: LIN break detection clear flag
    1
    TCCF // at 6: Transmission complete clear flag
    1
    IDLECF // at 4: Idle line detected clear flag
    ORECF // at 3: Overrun error clear flag
    NCF // at 2: Noise detected clear flag
    FECF // at 1: Framing error clear flag
    PECF // at 0: Parity error clear flag
  }

//---  Register RDR: Receive data register
  RDR @offset 0x24 @ro $u32 {
    23
    RDR:9 // at 0: Receive data value
  }

//---  Register TDR: Transmit data register
  TDR @offset 0x28 $u32 {
    23
    TDR:9 // at 0: Transmit data value
  }

}

//------------------------------------------------------------------------------
// Peripheral USART3: Universal synchronous asynchronous receiver       transmitter
//------------------------------------------------------------------------------

registers ©USART3 @at 0x40004800 {
//---  Register CR1: Control register 1
  CR1 @offset 0x0 $u32 {
    3
    M1 // at 28: Word length
    EOBIE // at 27: End of Block interrupt enable
    RTOIE // at 26: Receiver timeout interrupt enable
    DEAT4 // at 25: Driver Enable assertion time
    DEAT3 // at 24: DEAT3
    DEAT2 // at 23: DEAT2
    DEAT1 // at 22: DEAT1
    DEAT0 // at 21: DEAT0
    DEDT4 // at 20: Driver Enable de-assertion time
    DEDT3 // at 19: DEDT3
    DEDT2 // at 18: DEDT2
    DEDT1 // at 17: DEDT1
    DEDT0 // at 16: DEDT0
    OVER8 // at 15: Oversampling mode
    CMIE // at 14: Character match interrupt enable
    MME // at 13: Mute mode enable
    M0 // at 12: Word length
    WAKE // at 11: Receiver wakeup method
    PCE // at 10: Parity control enable
    PS // at 9: Parity selection
    PEIE // at 8: PE interrupt enable
    TXEIE // at 7: interrupt enable
    TCIE // at 6: Transmission complete interrupt enable
    RXNEIE // at 5: RXNE interrupt enable
    IDLEIE // at 4: IDLE interrupt enable
    TE // at 3: Transmitter enable
    RE // at 2: Receiver enable
    UESM // at 1: USART enable in Stop mode
    UE // at 0: USART enable
  }

//---  Register CR2: Control register 2
  CR2 @offset 0x4 $u32 {
    ADD4_7:4 // at 28: Address of the USART node
    ADD0_3:4 // at 24: Address of the USART node
    RTOEN // at 23: Receiver timeout enable
    ABRMOD1 // at 22: Auto baud rate mode
    ABRMOD0 // at 21: ABRMOD0
    ABREN // at 20: Auto baud rate enable
    MSBFIRST // at 19: Most significant bit first
    TAINV // at 18: Binary data inversion
    TXINV // at 17: TX pin active level inversion
    RXINV // at 16: RX pin active level inversion
    SWAP // at 15: Swap TX/RX pins
    LINEN // at 14: LIN mode enable
    STOP:2 // at 12: STOP bits
    CLKEN // at 11: Clock enable
    CPOL // at 10: Clock polarity
    CPHA // at 9: Clock phase
    LBCL // at 8: Last bit clock pulse
    1
    LBDIE // at 6: LIN break detection interrupt enable
    LBDL // at 5: LIN break detection length
    ADDM7 // at 4: 7-bit Address Detection/4-bit Address Detection
    4
  }

//---  Register CR3: Control register 3
  CR3 @offset 0x8 $u32 {
    7
    TCBGTIE // at 24: Transmission complete before guard time interrupt enable
    UCESM // at 23: USART Clock Enable in Stop mode
    WUFIE // at 22: Wakeup from Stop mode interrupt enable
    WUS:2 // at 20: Wakeup from Stop mode interrupt flag selection
    SCARCNT:3 // at 17: Smartcard auto-retry count
    1
    DEP // at 15: Driver enable polarity selection
    DEM // at 14: Driver enable mode
    DDRE // at 13: DMA Disable on Reception Error
    OVRDIS // at 12: Overrun Disable
    ONEBIT // at 11: One sample bit method enable
    CTSIE // at 10: CTS interrupt enable
    CTSE // at 9: CTS enable
    RTSE // at 8: RTS enable
    DMAT // at 7: DMA enable transmitter
    DMAR // at 6: DMA enable receiver
    SCEN // at 5: Smartcard mode enable
    NACK // at 4: Smartcard NACK enable
    HDSEL // at 3: Half-duplex selection
    IRLP // at 2: Ir low-power
    IREN // at 1: Ir mode enable
    EIE // at 0: Error interrupt enable
  }

//---  Register BRR: Baud rate register
  BRR @offset 0xc $u32 {
    20
    BRR:12 // at 0: USARTDIV
  }

//---  Register GTPR: Guard time and prescaler           register
  GTPR @offset 0x10 $u32 {
    16
    GT:8 // at 8: Guard time value
    PSC:8 // at 0: Prescaler value
  }

//---  Register RTOR: Receiver timeout register
  RTOR @offset 0x14 $u32 {
    BLEN:8 // at 24: Block Length
    RTO:24 // at 0: Receiver timeout value
  }

//---  Register RQR: Request register
  RQR @offset 0x18 $u32 {
    27
    TXFRQ // at 4: Transmit data flush request
    RXFRQ // at 3: Receive data flush request
    MMRQ // at 2: Mute mode request
    SBKRQ // at 1: Send break request
    ABRRQ // at 0: Auto baud rate request
  }

//---  Register ISR: Interrupt & status           register
  ISR @offset 0x1c @ro $u32 {
    6
    TCBGT // at 25: Transmission complete before guard time completion
    2
    REACK // at 22: REACK
    TEACK // at 21: TEACK
    WUF // at 20: WUF
    RWU // at 19: RWU
    SBKF // at 18: SBKF
    CMF // at 17: CMF
    BUSY // at 16: BUSY
    ABRF // at 15: ABRF
    ABRE // at 14: ABRE
    1
    EOBF // at 12: EOBF
    RTOF // at 11: RTOF
    CTS // at 10: CTS
    CTSIF // at 9: CTSIF
    LBDF // at 8: LBDF
    TXE // at 7: TXE
    TC // at 6: TC
    RXNE // at 5: RXNE
    IDLE // at 4: IDLE
    ORE // at 3: ORE
    NF // at 2: NF
    FE // at 1: FE
    PE // at 0: PE
  }

//---  Register ICR: Interrupt flag clear register
  ICR @offset 0x20 $u32 {
    11
    WUCF // at 20: Wakeup from Stop mode clear flag
    2
    CMCF // at 17: Character match clear flag
    4
    EOBCF // at 12: End of block clear flag
    RTOCF // at 11: Receiver timeout clear flag
    1
    CTSCF // at 9: CTS clear flag
    LBDCF // at 8: LIN break detection clear flag
    1
    TCCF // at 6: Transmission complete clear flag
    1
    IDLECF // at 4: Idle line detected clear flag
    ORECF // at 3: Overrun error clear flag
    NCF // at 2: Noise detected clear flag
    FECF // at 1: Framing error clear flag
    PECF // at 0: Parity error clear flag
  }

//---  Register RDR: Receive data register
  RDR @offset 0x24 @ro $u32 {
    23
    RDR:9 // at 0: Receive data value
  }

//---  Register TDR: Transmit data register
  TDR @offset 0x28 $u32 {
    23
    TDR:9 // at 0: Transmit data value
  }

}

//------------------------------------------------------------------------------
// Peripheral USB_FS
//------------------------------------------------------------------------------

registers ©USB_FS @at 0x40006800 {
//---  Register EP0R: endpoint 0 register
  EP0R @offset 0x0 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP1R: endpoint 1 register
  EP1R @offset 0x4 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP2R: endpoint 2 register
  EP2R @offset 0x8 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP3R: endpoint 3 register
  EP3R @offset 0xc $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP4R: endpoint 4 register
  EP4R @offset 0x10 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP5R: endpoint 5 register
  EP5R @offset 0x14 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP6R: endpoint 6 register
  EP6R @offset 0x18 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP7R: endpoint 7 register
  EP7R @offset 0x1c $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register CNTR: control register
  CNTR @offset 0x40 $u32 {
    16
    CTRM // at 15: Correct transfer interrupt mask
    PMAOVRM // at 14: Packet memory area over / underrun interrupt mask
    ERRM // at 13: Error interrupt mask
    WKUPM // at 12: Wakeup interrupt mask
    SUSPM // at 11: Suspend mode interrupt mask
    RESETM // at 10: USB reset interrupt mask
    SOFM // at 9: Start of frame interrupt mask
    ESOFM // at 8: Expected start of frame interrupt mask
    L1REQM // at 7: LPM L1 state request interrupt mask
    1
    L1RESUME // at 5: LPM L1 Resume request
    RESUME // at 4: Resume request
    FSUSP // at 3: Force suspend
    LPMODE // at 2: Low-power mode
    PDWN // at 1: Power down
    FRES // at 0: Force USB Reset
  }

//---  Register ISTR: interrupt status register
  ISTR @offset 0x44 $u32 {
    16
    CTR // at 15: Correct transfer
    PMAOVR // at 14: Packet memory area over / underrun
    ERR // at 13: Error
    WKUP // at 12: Wakeup
    SUSP // at 11: Suspend mode request
    RESET // at 10: reset request
    SOF // at 9: start of frame
    ESOF // at 8: Expected start frame
    L1REQ // at 7: LPM L1 state request
    2
    DIR // at 4: Direction of transaction
    EP_ID:4 // at 0: Endpoint Identifier
  }

//---  Register FNR: frame number register
  FNR @offset 0x48 @ro $u32 {
    16
    RXDP // at 15: Receive data + line status
    RXDM // at 14: Receive data - line status
    LCK // at 13: Locked
    LSOF:2 // at 11: Lost SOF
    FN:11 // at 0: Frame number
  }

//---  Register DADDR: device address
  DADDR @offset 0x4c $u32 {
    24
    EF // at 7: Enable function
    ADD:7 // at 0: Device address
  }

//---  Register BTABLE: Buffer table address
  BTABLE @offset 0x50 $u32 {
    16
    BTABLE:13 // at 3: Buffer table
    3
  }

//---  Register LPMCSR: LPM control and status           register
  LPMCSR @offset 0x54 $u32 {
    24
    BESL:4 // at 4: BESL value
    REMWAKE // at 3: bRemoteWake value
    1
    LPMACK // at 1: LPM Token acknowledge enable
    LPMEN // at 0: LPM support enable
  }

//---  Register BCDR: Battery charging detector
  BCDR @offset 0x58 $u32 {
    16
    DPPU // at 15: DP pull-up control
    7
    PS2DET // at 7: DM pull-up detection status
    SDET // at 6: Secondary detection
    PDET // at 5: Primary detection
    DCDET // at 4: Data contact detection
    SDEN // at 3: Secondary detection
    PDEN // at 2: Primary detection
    DCDEN // at 1: Data contact detection
    BCDEN // at 0: Battery charging detector
  }

}

//------------------------------------------------------------------------------
// Peripheral USB_SRAM: Universal serial bus full-speed device       interface
//------------------------------------------------------------------------------

registers ©USB_SRAM @at 0x40006c00 {
//---  Register EP0R: endpoint 0 register
  EP0R @offset 0x0 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP1R: endpoint 1 register
  EP1R @offset 0x4 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP2R: endpoint 2 register
  EP2R @offset 0x8 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP3R: endpoint 3 register
  EP3R @offset 0xc $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP4R: endpoint 4 register
  EP4R @offset 0x10 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP5R: endpoint 5 register
  EP5R @offset 0x14 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP6R: endpoint 6 register
  EP6R @offset 0x18 $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register EP7R: endpoint 7 register
  EP7R @offset 0x1c $u32 {
    16
    CTR_RX // at 15: Correct transfer for reception
    DTOG_RX // at 14: Data Toggle, for reception transfers
    STAT_RX:2 // at 12: Status bits, for reception transfers
    SETUP // at 11: Setup transaction completed
    EP_TYPE:2 // at 9: Endpoint type
    EP_KIND // at 8: Endpoint kind
    CTR_TX // at 7: Correct Transfer for transmission
    DTOG_TX // at 6: Data Toggle, for transmission transfers
    STAT_TX:2 // at 4: Status bits, for transmission transfers
    EA:4 // at 0: Endpoint address
  }

//---  Register CNTR: control register
  CNTR @offset 0x40 $u32 {
    16
    CTRM // at 15: Correct transfer interrupt mask
    PMAOVRM // at 14: Packet memory area over / underrun interrupt mask
    ERRM // at 13: Error interrupt mask
    WKUPM // at 12: Wakeup interrupt mask
    SUSPM // at 11: Suspend mode interrupt mask
    RESETM // at 10: USB reset interrupt mask
    SOFM // at 9: Start of frame interrupt mask
    ESOFM // at 8: Expected start of frame interrupt mask
    L1REQM // at 7: LPM L1 state request interrupt mask
    1
    L1RESUME // at 5: LPM L1 Resume request
    RESUME // at 4: Resume request
    FSUSP // at 3: Force suspend
    LPMODE // at 2: Low-power mode
    PDWN // at 1: Power down
    FRES // at 0: Force USB Reset
  }

//---  Register ISTR: interrupt status register
  ISTR @offset 0x44 $u32 {
    16
    CTR // at 15: Correct transfer
    PMAOVR // at 14: Packet memory area over / underrun
    ERR // at 13: Error
    WKUP // at 12: Wakeup
    SUSP // at 11: Suspend mode request
    RESET // at 10: reset request
    SOF // at 9: start of frame
    ESOF // at 8: Expected start frame
    L1REQ // at 7: LPM L1 state request
    2
    DIR // at 4: Direction of transaction
    EP_ID:4 // at 0: Endpoint Identifier
  }

//---  Register FNR: frame number register
  FNR @offset 0x48 @ro $u32 {
    16
    RXDP // at 15: Receive data + line status
    RXDM // at 14: Receive data - line status
    LCK // at 13: Locked
    LSOF:2 // at 11: Lost SOF
    FN:11 // at 0: Frame number
  }

//---  Register DADDR: device address
  DADDR @offset 0x4c $u32 {
    24
    EF // at 7: Enable function
    ADD:7 // at 0: Device address
  }

//---  Register BTABLE: Buffer table address
  BTABLE @offset 0x50 $u32 {
    16
    BTABLE:13 // at 3: Buffer table
    3
  }

//---  Register LPMCSR: LPM control and status           register
  LPMCSR @offset 0x54 $u32 {
    24
    BESL:4 // at 4: BESL value
    REMWAKE // at 3: bRemoteWake value
    1
    LPMACK // at 1: LPM Token acknowledge enable
    LPMEN // at 0: LPM support enable
  }

//---  Register BCDR: Battery charging detector
  BCDR @offset 0x58 $u32 {
    16
    DPPU // at 15: DP pull-up control
    7
    PS2DET // at 7: DM pull-up detection status
    SDET // at 6: Secondary detection
    PDET // at 5: Primary detection
    DCDET // at 4: Data contact detection
    SDEN // at 3: Secondary detection
    PDEN // at 2: Primary detection
    DCDEN // at 1: Data contact detection
    BCDEN // at 0: Battery charging detector
  }

}

//------------------------------------------------------------------------------
// Peripheral VREFBUF: Voltage reference buffer
//------------------------------------------------------------------------------

registers ©VREFBUF @at 0x40010030 {
//---  Register CSR: VREF control and status           register
  CSR @offset 0x0 $u32 {
    28
    VRR // at 3: Voltage reference buffer ready
    VRS // at 2: Voltage reference scale
    HIZ // at 1: High impedance mode
    ENVR // at 0: Voltage reference buffer enable
  }

//---  Register CCR: calibration control register
  CCR @offset 0x4 $u32 {
    26
    TRIM:6 // at 0: Trimming code
  }

}

//------------------------------------------------------------------------------
// Peripheral WWDG: System window watchdog
//------------------------------------------------------------------------------

registers ©WWDG @at 0x40002c00 {
//---  Register CR: Control register
  CR @offset 0x0 $u32 {
    24
    WDGA // at 7: Activation bit
    T:7 // at 0: 7-bit counter (MSB to LSB)
  }

//---  Register CFR: Configuration register
  CFR @offset 0x4 $u32 {
    22
    EWI // at 9: Early wakeup interrupt
    WDGTB:2 // at 7: Timer base
    W:7 // at 0: 7-bit window value
  }

//---  Register SR: Status register
  SR @offset 0x8 $u32 {
    31
    EWIF // at 0: Early wakeup interrupt flag
  }

}

