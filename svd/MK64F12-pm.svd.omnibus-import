//------------------------------------------------------------------------------
// MK64F12: MK64F12 Freescale Microcontroller
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©ADC [2]
//        ADC0 at 0x4003b000
//        ADC1 at 0x400bb000
//------------------------------------------------------------------------------

registers ©ADC [2 @at 0x4003b000 0x400bb000]
          ©ADC0 @at 0x4003b000
          ©ADC1 @at 0x400bb000
{
//---  Registers SC1(A,B): ADC Status and Control Registers 1
  SC1A @offset 0x0 $u32
  SC1B @offset 0x4 $u32 {
    24
    COCO // at 7: Conversion Complete Flag
    AIEN // at 6: Interrupt Enable
    DIFF // at 5: Differential Mode Enable
    ADCH:5 // at 0: Input channel select
  }

//---  Register CFG1: ADC Configuration Register 1
  CFG1 @offset 0x8 $u32 {
    24
    ADLPC // at 7: Low-Power Configuration
    ADIV:2 // at 5: Clock Divide Select
    ADLSMP // at 4: Sample Time Configuration
    MODE:2 // at 2: Conversion mode selection
    ADICLK:2 // at 0: Input Clock Select
  }

//---  Register CFG2: ADC Configuration Register 2
  CFG2 @offset 0xc $u32 {
    27
    MUXSEL // at 4: ADC Mux Select
    ADACKEN // at 3: Asynchronous Clock Output Enable
    ADHSC // at 2: High-Speed Configuration
    ADLSTS:2 // at 0: Long Sample Time Select
  }

//---  Registers R(A,B): ADC Data Result Register
  RA @offset 0x10 @ro $u32
  RB @offset 0x14 @ro $u32 {
    16
    D:16 // at 0: Data result
  }

//---  Registers CV(1,2): Compare Value Registers
  CV1 @offset 0x18 $u32
  CV2 @offset 0x1c $u32 {
    16
    CV:16 // at 0: Compare Value.
  }

//---  Register SC2: Status and Control Register 2
  SC2 @offset 0x20 $u32 {
    24
    ADACT // at 7: Conversion Active
    ADTRG // at 6: Conversion Trigger Select
    ACFE // at 5: Compare Function Enable
    ACFGT // at 4: Compare Function Greater Than Enable
    ACREN // at 3: Compare Function Range Enable
    DMAEN // at 2: DMA Enable
    REFSEL:2 // at 0: Voltage Reference Selection
  }

//---  Register SC3: Status and Control Register 3
  SC3 @offset 0x24 $u32 {
    24
    CAL // at 7: Calibration
    CALF // at 6: Calibration Failed Flag
    2
    ADCO // at 3: Continuous Conversion Enable
    AVGE // at 2: Hardware Average Enable
    AVGS:2 // at 0: Hardware Average Select
  }

//---  Register OFS: ADC Offset Correction Register
  OFS @offset 0x28 $u32 {
    16
    OFS:16 // at 0: Offset Error Correction Value
  }

//---  Register PG: ADC Plus-Side Gain Register
  PG @offset 0x2c $u32 {
    16
    PG:16 // at 0: Plus-Side Gain
  }

//---  Register MG: ADC Minus-Side Gain Register
  MG @offset 0x30 $u32 {
    16
    MG:16 // at 0: Minus-Side Gain
  }

//---  Register CLPD: ADC Plus-Side General Calibration Value Register
  CLPD @offset 0x34 $u32 {
    26
    CLPD:6 // at 0: Calibration Value
  }

//---  Register CLPS: ADC Plus-Side General Calibration Value Register
  CLPS @offset 0x38 $u32 {
    26
    CLPS:6 // at 0: Calibration Value
  }

//---  Register CLP4: ADC Plus-Side General Calibration Value Register
  CLP4 @offset 0x3c $u32 {
    22
    CLP4:10 // at 0: Calibration Value
  }

//---  Register CLP3: ADC Plus-Side General Calibration Value Register
  CLP3 @offset 0x40 $u32 {
    23
    CLP3:9 // at 0: Calibration Value
  }

//---  Register CLP2: ADC Plus-Side General Calibration Value Register
  CLP2 @offset 0x44 $u32 {
    24
    CLP2:8 // at 0: Calibration Value
  }

//---  Register CLP1: ADC Plus-Side General Calibration Value Register
  CLP1 @offset 0x48 $u32 {
    25
    CLP1:7 // at 0: Calibration Value
  }

//---  Register CLP0: ADC Plus-Side General Calibration Value Register
  CLP0 @offset 0x4c $u32 {
    26
    CLP0:6 // at 0: Calibration Value
  }

//---  Register CLMD: ADC Minus-Side General Calibration Value Register
  CLMD @offset 0x54 $u32 {
    26
    CLMD:6 // at 0: Calibration Value
  }

//---  Register CLMS: ADC Minus-Side General Calibration Value Register
  CLMS @offset 0x58 $u32 {
    26
    CLMS:6 // at 0: Calibration Value
  }

//---  Register CLM4: ADC Minus-Side General Calibration Value Register
  CLM4 @offset 0x5c $u32 {
    22
    CLM4:10 // at 0: Calibration Value
  }

//---  Register CLM3: ADC Minus-Side General Calibration Value Register
  CLM3 @offset 0x60 $u32 {
    23
    CLM3:9 // at 0: Calibration Value
  }

//---  Register CLM2: ADC Minus-Side General Calibration Value Register
  CLM2 @offset 0x64 $u32 {
    24
    CLM2:8 // at 0: Calibration Value
  }

//---  Register CLM1: ADC Minus-Side General Calibration Value Register
  CLM1 @offset 0x68 $u32 {
    25
    CLM1:7 // at 0: Calibration Value
  }

//---  Register CLM0: ADC Minus-Side General Calibration Value Register
  CLM0 @offset 0x6c $u32 {
    26
    CLM0:6 // at 0: Calibration Value
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©AIPS [2]
//        AIPS0 at 0x40000000
//        AIPS1 at 0x40080000
//------------------------------------------------------------------------------

registers ©AIPS [2 @at 0x40000000 0x40080000]
          ©AIPS0 @at 0x40000000
          ©AIPS1 @at 0x40080000
{
//---  Register MPRA: Master Privilege Register A
  MPRA @offset 0x0 $u32 {
    1
    MTR0 // at 30: Master 0 Trusted For Read
    MTW0 // at 29: Master 0 Trusted For Writes
    MPL0 // at 28: Master 0 Privilege Level
    1
    MTR1 // at 26: Master 1 Trusted for Read
    MTW1 // at 25: Master 1 Trusted for Writes
    MPL1 // at 24: Master 1 Privilege Level
    1
    MTR2 // at 22: Master 2 Trusted For Read
    MTW2 // at 21: Master 2 Trusted For Writes
    MPL2 // at 20: Master 2 Privilege Level
    1
    MTR3 // at 18: Master 3 Trusted For Read
    MTW3 // at 17: Master 3 Trusted For Writes
    MPL3 // at 16: Master 3 Privilege Level
    1
    MTR4 // at 14: Master 4 Trusted For Read
    MTW4 // at 13: Master 4 Trusted For Writes
    MPL4 // at 12: Master 4 Privilege Level
    1
    MTR5 // at 10: Master 5 Trusted For Read
    MTW5 // at 9: Master 5 Trusted For Writes
    MPL5 // at 8: Master 5 Privilege Level
    8
  }

//---  Register PACRA: Peripheral Access Control Register
  PACRA @offset 0x20 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRB: Peripheral Access Control Register
  PACRB @offset 0x24 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRC: Peripheral Access Control Register
  PACRC @offset 0x28 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRD: Peripheral Access Control Register
  PACRD @offset 0x2c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRE: Peripheral Access Control Register
  PACRE @offset 0x40 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRF: Peripheral Access Control Register
  PACRF @offset 0x44 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRG: Peripheral Access Control Register
  PACRG @offset 0x48 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRH: Peripheral Access Control Register
  PACRH @offset 0x4c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRI: Peripheral Access Control Register
  PACRI @offset 0x50 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRJ: Peripheral Access Control Register
  PACRJ @offset 0x54 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRK: Peripheral Access Control Register
  PACRK @offset 0x58 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRL: Peripheral Access Control Register
  PACRL @offset 0x5c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRM: Peripheral Access Control Register
  PACRM @offset 0x60 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRN: Peripheral Access Control Register
  PACRN @offset 0x64 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRO: Peripheral Access Control Register
  PACRO @offset 0x68 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRP: Peripheral Access Control Register
  PACRP @offset 0x6c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRU: Peripheral Access Control Register
  PACRU @offset 0x80 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    24
  }

}

//------------------------------------------------------------------------------
// Peripheral AXBS: Crossbar switch
//------------------------------------------------------------------------------

registers ©AXBS @at 0x40004000 {
//---  Registers PRS(0,1,2,3,4): Priority Registers Slave
  #define AXBS_PRS(idx) (* ((volatile uint32_t *) (0x40004000 + 0x0 + (idx) * 0x100)))
  #define AXBS_PRS0 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 0 * 0x100)))
  #define AXBS_PRS1 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 1 * 0x100)))
  #define AXBS_PRS2 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 2 * 0x100)))
  #define AXBS_PRS3 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 3 * 0x100)))
  #define AXBS_PRS4 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 4 * 0x100)))
 {
    9
    M5:3 // at 20: Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M4:3 // at 16: Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M3:3 // at 12: Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M2:3 // at 8: Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M1:3 // at 4: Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M0:3 // at 0: Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
  }

//---  Registers CRS(0,1,2,3,4): Control Register
  #define AXBS_CRS(idx) (* ((volatile uint32_t *) (0x40004000 + 0x10 + (idx) * 0x100)))
  #define AXBS_CRS0 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 0 * 0x100)))
  #define AXBS_CRS1 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 1 * 0x100)))
  #define AXBS_CRS2 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 2 * 0x100)))
  #define AXBS_CRS3 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 3 * 0x100)))
  #define AXBS_CRS4 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 4 * 0x100)))
 {
    RO // at 31: Read Only
    HLP // at 30: Halt Low Priority
    20
    ARB:2 // at 8: Arbitration Mode
    2
    PCTL:2 // at 4: Parking Control
    1
    PARK:3 // at 0: Park
  }

//---  Registers MGPCR(0,1,2,3,4,5): Master General Purpose Control Register
  #define AXBS_MGPCR(idx) (* ((volatile uint32_t *) (0x40004000 + 0x800 + (idx) * 0x100)))
  #define AXBS_MGPCR0 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 0 * 0x100)))
  #define AXBS_MGPCR1 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 1 * 0x100)))
  #define AXBS_MGPCR2 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 2 * 0x100)))
  #define AXBS_MGPCR3 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 3 * 0x100)))
  #define AXBS_MGPCR4 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 4 * 0x100)))
  #define AXBS_MGPCR5 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 5 * 0x100)))
 {
    29
    AULB:3 // at 0: Arbitrates On Undefined Length Bursts
  }

}

//------------------------------------------------------------------------------
// Peripheral CAN0: Flex Controller Area Network module
//------------------------------------------------------------------------------

registers ©CAN0 @at 0x40024000 {
//---  Register MCR: Module Configuration Register
  MCR @offset 0x0 $u32 {
    MDIS // at 31: Module Disable
    FRZ // at 30: Freeze Enable
    RFEN // at 29: Rx FIFO Enable
    HALT // at 28: Halt FlexCAN
    NOTRDY // at 27: FlexCAN Not Ready
    WAKMSK // at 26: Wake Up Interrupt Mask
    SOFTRST // at 25: Soft Reset
    FRZACK // at 24: Freeze Mode Acknowledge
    SUPV // at 23: Supervisor Mode
    SLFWAK // at 22: Self Wake Up
    WRNEN // at 21: Warning Interrupt Enable
    LPMACK // at 20: Low-Power Mode Acknowledge
    WAKSRC // at 19: Wake Up Source
    1
    SRXDIS // at 17: Self Reception Disable
    IRMQ // at 16: Individual Rx Masking And Queue Enable
    2
    LPRIOEN // at 13: Local Priority Enable
    AEN // at 12: Abort Enable
    2
    IDAM:2 // at 8: ID Acceptance Mode
    1
    MAXMB:7 // at 0: Number Of The Last Message Buffer
  }

//---  Register CTRL1: Control 1 register
  CTRL1 @offset 0x4 $u32 {
    PRESDIV:8 // at 24: Prescaler Division Factor
    RJW:2 // at 22: Resync Jump Width
    PSEG1:3 // at 19: Phase Segment 1
    PSEG2:3 // at 16: Phase Segment 2
    BOFFMSK // at 15: Bus Off Mask
    ERRMSK // at 14: Error Mask
    CLKSRC // at 13: CAN Engine Clock Source
    LPB // at 12: Loop Back Mode
    TWRNMSK // at 11: Tx Warning Interrupt Mask
    RWRNMSK // at 10: Rx Warning Interrupt Mask
    2
    SMP // at 7: CAN Bit Sampling
    BOFFREC // at 6: Bus Off Recovery
    TSYN // at 5: Timer Sync
    LBUF // at 4: Lowest Buffer Transmitted First
    LOM // at 3: Listen-Only Mode
    PROPSEG:3 // at 0: Propagation Segment
  }

//---  Register TIMER: Free Running Timer
  TIMER @offset 0x8 $u32 {
    16
    TIMER:16 // at 0: Timer Value
  }

//---  Register RXMGMASK: Rx Mailboxes Global Mask Register
  RXMGMASK @offset 0x10 $u32 {
    MG:32 // at 0: Rx Mailboxes Global Mask Bits
  }

//---  Register RX14MASK: Rx 14 Mask register
  RX14MASK @offset 0x14 $u32 {
    RX14M:32 // at 0: Rx Buffer 14 Mask Bits
  }

//---  Register RX15MASK: Rx 15 Mask register
  RX15MASK @offset 0x18 $u32 {
    RX15M:32 // at 0: Rx Buffer 15 Mask Bits
  }

//---  Register ECR: Error Counter
  ECR @offset 0x1c $u32 {
    16
    RXERRCNT:8 // at 8: Receive Error Counter
    TXERRCNT:8 // at 0: Transmit Error Counter
  }

//---  Register ESR1: Error and Status 1 register
  ESR1 @offset 0x20 $u32 {
    13
    SYNCH // at 18: CAN Synchronization Status
    TWRNINT // at 17: Tx Warning Interrupt Flag
    RWRNINT // at 16: Rx Warning Interrupt Flag
    BIT1ERR // at 15: Bit1 Error
    BIT0ERR // at 14: Bit0 Error
    ACKERR // at 13: Acknowledge Error
    CRCERR // at 12: Cyclic Redundancy Check Error
    FRMERR // at 11: Form Error
    STFERR // at 10: Stuffing Error
    TXWRN // at 9: TX Error Warning
    RXWRN // at 8: Rx Error Warning
    IDLE // at 7: This bit indicates when CAN bus is in IDLE state
    TX // at 6: FlexCAN In Transmission
    FLTCONF:2 // at 4: Fault Confinement State
    RX // at 3: FlexCAN In Reception
    BOFFINT // at 2: Bus Off Interrupt
    ERRINT // at 1: Error Interrupt
    WAKINT // at 0: Wake-Up Interrupt
  }

//---  Register IMASK1: Interrupt Masks 1 register
  IMASK1 @offset 0x28 $u32 {
    BUFLM:32 // at 0: Buffer MB i Mask
  }

//---  Register IFLAG1: Interrupt Flags 1 register
  IFLAG1 @offset 0x30 $u32 {
    BUF31TO8I:24 // at 8: Buffer MBi Interrupt
    BUF7I // at 7: Buffer MB7 Interrupt Or "Rx FIFO Overflow"
    BUF6I // at 6: Buffer MB6 Interrupt Or "Rx FIFO Warning"
    BUF5I // at 5: Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
    BUF4TO1I:4 // at 1: Buffer MB i Interrupt Or "reserved"
    BUF0I // at 0: Buffer MB0 Interrupt Or "reserved"
  }

//---  Register CTRL2: Control 2 register
  CTRL2 @offset 0x34 $u32 {
    3
    WRMFRZ // at 28: Write-Access To Memory In Freeze Mode
    RFFN:4 // at 24: Number Of Rx FIFO Filters
    TASD:5 // at 19: Tx Arbitration Start Delay
    MRP // at 18: Mailboxes Reception Priority
    RRS // at 17: Remote Request Storing
    EACEN // at 16: Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
    16
  }

//---  Register ESR2: Error and Status 2 register
  ESR2 @offset 0x38 @ro $u32 {
    9
    LPTM:7 // at 16: Lowest Priority Tx Mailbox
    1
    VPS // at 14: Valid Priority Status
    IMB // at 13: Inactive Mailbox
    13
  }

//---  Register CRCR: CRC Register
  CRCR @offset 0x44 @ro $u32 {
    9
    MBCRC:7 // at 16: CRC Mailbox
    1
    TXCRC:15 // at 0: CRC Transmitted
  }

//---  Register RXFGMASK: Rx FIFO Global Mask register
  RXFGMASK @offset 0x48 $u32 {
    FGM:32 // at 0: Rx FIFO Global Mask Bits
  }

//---  Register RXFIR: Rx FIFO Information Register
  RXFIR @offset 0x4c @ro $u32 {
    23
    IDHIT:9 // at 0: Identifier Acceptance Filter Hit Indicator
  }

//---  Register CS0: Message Buffer 0 CS Register
  CS0 @offset 0x80 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID0: Message Buffer 0 ID Register
  ID0 @offset 0x84 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD00: Message Buffer 0 WORD0 Register
  WORD00 @offset 0x88 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD10: Message Buffer 0 WORD1 Register
  WORD10 @offset 0x8c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS1: Message Buffer 1 CS Register
  CS1 @offset 0x90 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID1: Message Buffer 1 ID Register
  ID1 @offset 0x94 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD01: Message Buffer 1 WORD0 Register
  WORD01 @offset 0x98 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD11: Message Buffer 1 WORD1 Register
  WORD11 @offset 0x9c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS2: Message Buffer 2 CS Register
  CS2 @offset 0xa0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID2: Message Buffer 2 ID Register
  ID2 @offset 0xa4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD02: Message Buffer 2 WORD0 Register
  WORD02 @offset 0xa8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD12: Message Buffer 2 WORD1 Register
  WORD12 @offset 0xac $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS3: Message Buffer 3 CS Register
  CS3 @offset 0xb0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID3: Message Buffer 3 ID Register
  ID3 @offset 0xb4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD03: Message Buffer 3 WORD0 Register
  WORD03 @offset 0xb8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD13: Message Buffer 3 WORD1 Register
  WORD13 @offset 0xbc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS4: Message Buffer 4 CS Register
  CS4 @offset 0xc0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID4: Message Buffer 4 ID Register
  ID4 @offset 0xc4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD04: Message Buffer 4 WORD0 Register
  WORD04 @offset 0xc8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD14: Message Buffer 4 WORD1 Register
  WORD14 @offset 0xcc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS5: Message Buffer 5 CS Register
  CS5 @offset 0xd0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID5: Message Buffer 5 ID Register
  ID5 @offset 0xd4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD05: Message Buffer 5 WORD0 Register
  WORD05 @offset 0xd8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD15: Message Buffer 5 WORD1 Register
  WORD15 @offset 0xdc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS6: Message Buffer 6 CS Register
  CS6 @offset 0xe0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID6: Message Buffer 6 ID Register
  ID6 @offset 0xe4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD06: Message Buffer 6 WORD0 Register
  WORD06 @offset 0xe8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD16: Message Buffer 6 WORD1 Register
  WORD16 @offset 0xec $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS7: Message Buffer 7 CS Register
  CS7 @offset 0xf0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID7: Message Buffer 7 ID Register
  ID7 @offset 0xf4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD07: Message Buffer 7 WORD0 Register
  WORD07 @offset 0xf8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD17: Message Buffer 7 WORD1 Register
  WORD17 @offset 0xfc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS8: Message Buffer 8 CS Register
  CS8 @offset 0x100 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID8: Message Buffer 8 ID Register
  ID8 @offset 0x104 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD08: Message Buffer 8 WORD0 Register
  WORD08 @offset 0x108 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD18: Message Buffer 8 WORD1 Register
  WORD18 @offset 0x10c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS9: Message Buffer 9 CS Register
  CS9 @offset 0x110 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID9: Message Buffer 9 ID Register
  ID9 @offset 0x114 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD09: Message Buffer 9 WORD0 Register
  WORD09 @offset 0x118 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD19: Message Buffer 9 WORD1 Register
  WORD19 @offset 0x11c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS10: Message Buffer 10 CS Register
  CS10 @offset 0x120 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID10: Message Buffer 10 ID Register
  ID10 @offset 0x124 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD010: Message Buffer 10 WORD0 Register
  WORD010 @offset 0x128 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD110: Message Buffer 10 WORD1 Register
  WORD110 @offset 0x12c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS11: Message Buffer 11 CS Register
  CS11 @offset 0x130 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID11: Message Buffer 11 ID Register
  ID11 @offset 0x134 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD011: Message Buffer 11 WORD0 Register
  WORD011 @offset 0x138 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD111: Message Buffer 11 WORD1 Register
  WORD111 @offset 0x13c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS12: Message Buffer 12 CS Register
  CS12 @offset 0x140 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID12: Message Buffer 12 ID Register
  ID12 @offset 0x144 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD012: Message Buffer 12 WORD0 Register
  WORD012 @offset 0x148 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD112: Message Buffer 12 WORD1 Register
  WORD112 @offset 0x14c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS13: Message Buffer 13 CS Register
  CS13 @offset 0x150 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID13: Message Buffer 13 ID Register
  ID13 @offset 0x154 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD013: Message Buffer 13 WORD0 Register
  WORD013 @offset 0x158 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD113: Message Buffer 13 WORD1 Register
  WORD113 @offset 0x15c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS14: Message Buffer 14 CS Register
  CS14 @offset 0x160 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID14: Message Buffer 14 ID Register
  ID14 @offset 0x164 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD014: Message Buffer 14 WORD0 Register
  WORD014 @offset 0x168 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD114: Message Buffer 14 WORD1 Register
  WORD114 @offset 0x16c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS15: Message Buffer 15 CS Register
  CS15 @offset 0x170 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID15: Message Buffer 15 ID Register
  ID15 @offset 0x174 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD015: Message Buffer 15 WORD0 Register
  WORD015 @offset 0x178 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD115: Message Buffer 15 WORD1 Register
  WORD115 @offset 0x17c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Registers RXIMR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Rx Individual Mask Registers
  #define CAN0_RXIMR(idx) (* ((volatile uint32_t *) (0x40024000 + 0x880 + (idx) * 0x4)))
  #define CAN0_RXIMR0 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 0 * 0x4)))
  #define CAN0_RXIMR1 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 1 * 0x4)))
  #define CAN0_RXIMR2 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 2 * 0x4)))
  #define CAN0_RXIMR3 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 3 * 0x4)))
  #define CAN0_RXIMR4 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 4 * 0x4)))
  #define CAN0_RXIMR5 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 5 * 0x4)))
  #define CAN0_RXIMR6 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 6 * 0x4)))
  #define CAN0_RXIMR7 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 7 * 0x4)))
  #define CAN0_RXIMR8 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 8 * 0x4)))
  #define CAN0_RXIMR9 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 9 * 0x4)))
  #define CAN0_RXIMR10 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 10 * 0x4)))
  #define CAN0_RXIMR11 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 11 * 0x4)))
  #define CAN0_RXIMR12 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 12 * 0x4)))
  #define CAN0_RXIMR13 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 13 * 0x4)))
  #define CAN0_RXIMR14 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 14 * 0x4)))
  #define CAN0_RXIMR15 (* ((volatile uint32_t *) (0x40024000 + 0x880 + 15 * 0x4)))
 {
    MI:32 // at 0: Individual Mask Bits
  }

}

//------------------------------------------------------------------------------
// Peripheral CAU: Memory Mapped Cryptographic Acceleration Unit (MMCAU)
//------------------------------------------------------------------------------

registers ©CAU @at 0xe0081000 {
//---  Register CAU_DIRECT0: Direct access register 0
  CAU_DIRECT0 @offset 0x0 $u32 {
    CAU_DIRECT0:32 // at 0: Direct register 0
  }

//---  Register CAU_DIRECT1: Direct access register 1
  CAU_DIRECT1 @offset 0x4 $u32 {
    CAU_DIRECT1:32 // at 0: Direct register 1
  }

//---  Register CAU_DIRECT2: Direct access register 2
  CAU_DIRECT2 @offset 0x8 $u32 {
    CAU_DIRECT2:32 // at 0: Direct register 2
  }

//---  Register CAU_DIRECT3: Direct access register 3
  CAU_DIRECT3 @offset 0xc $u32 {
    CAU_DIRECT3:32 // at 0: Direct register 3
  }

//---  Register CAU_DIRECT4: Direct access register 4
  CAU_DIRECT4 @offset 0x10 $u32 {
    CAU_DIRECT4:32 // at 0: Direct register 4
  }

//---  Register CAU_DIRECT5: Direct access register 5
  CAU_DIRECT5 @offset 0x14 $u32 {
    CAU_DIRECT5:32 // at 0: Direct register 5
  }

//---  Register CAU_DIRECT6: Direct access register 6
  CAU_DIRECT6 @offset 0x18 $u32 {
    CAU_DIRECT6:32 // at 0: Direct register 6
  }

//---  Register CAU_DIRECT7: Direct access register 7
  CAU_DIRECT7 @offset 0x1c $u32 {
    CAU_DIRECT7:32 // at 0: Direct register 7
  }

//---  Register CAU_DIRECT8: Direct access register 8
  CAU_DIRECT8 @offset 0x20 $u32 {
    CAU_DIRECT8:32 // at 0: Direct register 8
  }

//---  Register CAU_DIRECT9: Direct access register 9
  CAU_DIRECT9 @offset 0x24 $u32 {
    CAU_DIRECT9:32 // at 0: Direct register 9
  }

//---  Register CAU_DIRECT10: Direct access register 10
  CAU_DIRECT10 @offset 0x28 $u32 {
    CAU_DIRECT10:32 // at 0: Direct register 10
  }

//---  Register CAU_DIRECT11: Direct access register 11
  CAU_DIRECT11 @offset 0x2c $u32 {
    CAU_DIRECT11:32 // at 0: Direct register 11
  }

//---  Register CAU_DIRECT12: Direct access register 12
  CAU_DIRECT12 @offset 0x30 $u32 {
    CAU_DIRECT12:32 // at 0: Direct register 12
  }

//---  Register CAU_DIRECT13: Direct access register 13
  CAU_DIRECT13 @offset 0x34 $u32 {
    CAU_DIRECT13:32 // at 0: Direct register 13
  }

//---  Register CAU_DIRECT14: Direct access register 14
  CAU_DIRECT14 @offset 0x38 $u32 {
    CAU_DIRECT14:32 // at 0: Direct register 14
  }

//---  Register CAU_DIRECT15: Direct access register 15
  CAU_DIRECT15 @offset 0x3c $u32 {
    CAU_DIRECT15:32 // at 0: Direct register 15
  }

//---  Register CAU_LDR_CASR: Status register - Load Register command
  CAU_LDR_CASR @offset 0x840 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_LDR_CAA: Accumulator register - Load Register command
  CAU_LDR_CAA @offset 0x844 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_LDR_CA0: General Purpose Register 0 - Load Register command
  CAU_LDR_CA0 @offset 0x848 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_LDR_CA1: General Purpose Register 1 - Load Register command
  CAU_LDR_CA1 @offset 0x84c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_LDR_CA2: General Purpose Register 2 - Load Register command
  CAU_LDR_CA2 @offset 0x850 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_LDR_CA3: General Purpose Register 3 - Load Register command
  CAU_LDR_CA3 @offset 0x854 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_LDR_CA4: General Purpose Register 4 - Load Register command
  CAU_LDR_CA4 @offset 0x858 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_LDR_CA5: General Purpose Register 5 - Load Register command
  CAU_LDR_CA5 @offset 0x85c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_LDR_CA6: General Purpose Register 6 - Load Register command
  CAU_LDR_CA6 @offset 0x860 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_LDR_CA7: General Purpose Register 7 - Load Register command
  CAU_LDR_CA7 @offset 0x864 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_LDR_CA8: General Purpose Register 8 - Load Register command
  CAU_LDR_CA8 @offset 0x868 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_STR_CASR: Status register - Store Register command
  CAU_STR_CASR @offset 0x880 @ro $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_STR_CAA: Accumulator register - Store Register command
  CAU_STR_CAA @offset 0x884 @ro $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_STR_CA0: General Purpose Register 0 - Store Register command
  CAU_STR_CA0 @offset 0x888 @ro $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_STR_CA1: General Purpose Register 1 - Store Register command
  CAU_STR_CA1 @offset 0x88c @ro $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_STR_CA2: General Purpose Register 2 - Store Register command
  CAU_STR_CA2 @offset 0x890 @ro $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_STR_CA3: General Purpose Register 3 - Store Register command
  CAU_STR_CA3 @offset 0x894 @ro $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_STR_CA4: General Purpose Register 4 - Store Register command
  CAU_STR_CA4 @offset 0x898 @ro $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_STR_CA5: General Purpose Register 5 - Store Register command
  CAU_STR_CA5 @offset 0x89c @ro $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_STR_CA6: General Purpose Register 6 - Store Register command
  CAU_STR_CA6 @offset 0x8a0 @ro $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_STR_CA7: General Purpose Register 7 - Store Register command
  CAU_STR_CA7 @offset 0x8a4 @ro $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_STR_CA8: General Purpose Register 8 - Store Register command
  CAU_STR_CA8 @offset 0x8a8 @ro $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_ADR_CASR: Status register - Add Register command
  CAU_ADR_CASR @offset 0x8c0 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_ADR_CAA: Accumulator register - Add to register command
  CAU_ADR_CAA @offset 0x8c4 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_ADR_CA0: General Purpose Register 0 - Add to register command
  CAU_ADR_CA0 @offset 0x8c8 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_ADR_CA1: General Purpose Register 1 - Add to register command
  CAU_ADR_CA1 @offset 0x8cc $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_ADR_CA2: General Purpose Register 2 - Add to register command
  CAU_ADR_CA2 @offset 0x8d0 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_ADR_CA3: General Purpose Register 3 - Add to register command
  CAU_ADR_CA3 @offset 0x8d4 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_ADR_CA4: General Purpose Register 4 - Add to register command
  CAU_ADR_CA4 @offset 0x8d8 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_ADR_CA5: General Purpose Register 5 - Add to register command
  CAU_ADR_CA5 @offset 0x8dc $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_ADR_CA6: General Purpose Register 6 - Add to register command
  CAU_ADR_CA6 @offset 0x8e0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_ADR_CA7: General Purpose Register 7 - Add to register command
  CAU_ADR_CA7 @offset 0x8e4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_ADR_CA8: General Purpose Register 8 - Add to register command
  CAU_ADR_CA8 @offset 0x8e8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_RADR_CASR: Status register - Reverse and Add to Register command
  CAU_RADR_CASR @offset 0x900 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
  CAU_RADR_CAA @offset 0x904 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
  CAU_RADR_CA0 @offset 0x908 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
  CAU_RADR_CA1 @offset 0x90c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
  CAU_RADR_CA2 @offset 0x910 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
  CAU_RADR_CA3 @offset 0x914 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
  CAU_RADR_CA4 @offset 0x918 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
  CAU_RADR_CA5 @offset 0x91c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
  CAU_RADR_CA6 @offset 0x920 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
  CAU_RADR_CA7 @offset 0x924 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
  CAU_RADR_CA8 @offset 0x928 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_XOR_CASR: Status register - Exclusive Or command
  CAU_XOR_CASR @offset 0x980 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_XOR_CAA: Accumulator register - Exclusive Or command
  CAU_XOR_CAA @offset 0x984 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
  CAU_XOR_CA0 @offset 0x988 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
  CAU_XOR_CA1 @offset 0x98c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
  CAU_XOR_CA2 @offset 0x990 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
  CAU_XOR_CA3 @offset 0x994 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
  CAU_XOR_CA4 @offset 0x998 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
  CAU_XOR_CA5 @offset 0x99c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
  CAU_XOR_CA6 @offset 0x9a0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
  CAU_XOR_CA7 @offset 0x9a4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
  CAU_XOR_CA8 @offset 0x9a8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_ROTL_CASR: Status register - Rotate Left command
  CAU_ROTL_CASR @offset 0x9c0 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_ROTL_CAA: Accumulator register - Rotate Left command
  CAU_ROTL_CAA @offset 0x9c4 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
  CAU_ROTL_CA0 @offset 0x9c8 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
  CAU_ROTL_CA1 @offset 0x9cc $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
  CAU_ROTL_CA2 @offset 0x9d0 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
  CAU_ROTL_CA3 @offset 0x9d4 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
  CAU_ROTL_CA4 @offset 0x9d8 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
  CAU_ROTL_CA5 @offset 0x9dc $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
  CAU_ROTL_CA6 @offset 0x9e0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
  CAU_ROTL_CA7 @offset 0x9e4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
  CAU_ROTL_CA8 @offset 0x9e8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_AESC_CASR: Status register - AES Column Operation command
  CAU_AESC_CASR @offset 0xb00 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_AESC_CAA: Accumulator register - AES Column Operation command
  CAU_AESC_CAA @offset 0xb04 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
  CAU_AESC_CA0 @offset 0xb08 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
  CAU_AESC_CA1 @offset 0xb0c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
  CAU_AESC_CA2 @offset 0xb10 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
  CAU_AESC_CA3 @offset 0xb14 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
  CAU_AESC_CA4 @offset 0xb18 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
  CAU_AESC_CA5 @offset 0xb1c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
  CAU_AESC_CA6 @offset 0xb20 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
  CAU_AESC_CA7 @offset 0xb24 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
  CAU_AESC_CA8 @offset 0xb28 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
  CAU_AESIC_CASR @offset 0xb40 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
  CAU_AESIC_CAA @offset 0xb44 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
  CAU_AESIC_CA0 @offset 0xb48 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
  CAU_AESIC_CA1 @offset 0xb4c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
  CAU_AESIC_CA2 @offset 0xb50 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
  CAU_AESIC_CA3 @offset 0xb54 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
  CAU_AESIC_CA4 @offset 0xb58 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
  CAU_AESIC_CA5 @offset 0xb5c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
  CAU_AESIC_CA6 @offset 0xb60 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
  CAU_AESIC_CA7 @offset 0xb64 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
  CAU_AESIC_CA8 @offset 0xb68 $u32 {
    CA8:32 // at 0: CA8
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©CMP [3]
//        CMP0 at 0x40073000
//        CMP1 at 0x40073008
//        CMP2 at 0x40073010
//------------------------------------------------------------------------------

registers ©CMP [3 @at 0x40073000 0x40073008 0x40073010]
          ©CMP0 @at 0x40073000
          ©CMP1 @at 0x40073008
          ©CMP2 @at 0x40073010
{
//---  Register CR0: CMP Control Register 0
  CR0 @offset 0x0 $u8 {
    1
    FILTER_CNT:3 // at 4: Filter Sample Count
    2
    HYSTCTR:2 // at 0: Comparator hard block hysteresis control
  }

//---  Register CR1: CMP Control Register 1
  CR1 @offset 0x1 $u8 {
    SE // at 7: Sample Enable
    WE // at 6: Windowing Enable
    1
    PMODE // at 4: Power Mode Select
    INV // at 3: Comparator INVERT
    COS // at 2: Comparator Output Select
    OPE // at 1: Comparator Output Pin Enable
    EN // at 0: Comparator Module Enable
  }

//---  Register FPR: CMP Filter Period Register
  FPR @offset 0x2 $u8 {
    FILT_PER:8 // at 0: Filter Sample Period
  }

//---  Register SCR: CMP Status and Control Register
  SCR @offset 0x3 $u8 {
    1
    DMAEN // at 6: DMA Enable Control
    1
    IER // at 4: Comparator Interrupt Enable Rising
    IEF // at 3: Comparator Interrupt Enable Falling
    CFR // at 2: Analog Comparator Flag Rising
    CFF // at 1: Analog Comparator Flag Falling
    COUT // at 0: Analog Comparator Output
  }

//---  Register DACCR: DAC Control Register
  DACCR @offset 0x4 $u8 {
    DACEN // at 7: DAC Enable
    VRSEL // at 6: Supply Voltage Reference Source Select
    VOSEL:6 // at 0: DAC Output Voltage Select
  }

//---  Register MUXCR: MUX Control Register
  MUXCR @offset 0x5 $u8 {
    PSTM // at 7: Pass Through Mode Enable
    1
    PSEL:3 // at 3: Plus Input Mux Control
    MSEL:3 // at 0: Minus Input Mux Control
  }

}

//------------------------------------------------------------------------------
// Peripheral CMT: Carrier Modulator Transmitter
//------------------------------------------------------------------------------

registers ©CMT @at 0x40062000 {
//---  Register CGH1: CMT Carrier Generator High Data Register 1
  CGH1 @offset 0x0 $u8 {
    PH:8 // at 0: Primary Carrier High Time Data Value
  }

//---  Register CGL1: CMT Carrier Generator Low Data Register 1
  CGL1 @offset 0x1 $u8 {
    PL:8 // at 0: Primary Carrier Low Time Data Value
  }

//---  Register CGH2: CMT Carrier Generator High Data Register 2
  CGH2 @offset 0x2 $u8 {
    SH:8 // at 0: Secondary Carrier High Time Data Value
  }

//---  Register CGL2: CMT Carrier Generator Low Data Register 2
  CGL2 @offset 0x3 $u8 {
    SL:8 // at 0: Secondary Carrier Low Time Data Value
  }

//---  Register OC: CMT Output Control Register
  OC @offset 0x4 $u8 {
    IROL // at 7: IRO Latch Control
    CMTPOL // at 6: CMT Output Polarity
    IROPEN // at 5: IRO Pin Enable
    5
  }

//---  Register MSC: CMT Modulator Status and Control Register
  MSC @offset 0x5 $u8 {
    EOCF // at 7: End Of Cycle Status Flag
    CMTDIV:2 // at 5: CMT Clock Divide Prescaler
    EXSPC // at 4: Extended Space Enable
    BASE // at 3: Baseband Enable
    FSK // at 2: FSK Mode Select
    EOCIE // at 1: End of Cycle Interrupt Enable
    MCGEN // at 0: Modulator and Carrier Generator Enable
  }

//---  Register CMD1: CMT Modulator Data Register Mark High
  CMD1 @offset 0x6 $u8 {
    MB:8 // at 0: Controls the upper mark periods of the modulator for all modes.
  }

//---  Register CMD2: CMT Modulator Data Register Mark Low
  CMD2 @offset 0x7 $u8 {
    MB:8 // at 0: Controls the lower mark periods of the modulator for all modes.
  }

//---  Register CMD3: CMT Modulator Data Register Space High
  CMD3 @offset 0x8 $u8 {
    SB:8 // at 0: Controls the upper space periods of the modulator for all modes.
  }

//---  Register CMD4: CMT Modulator Data Register Space Low
  CMD4 @offset 0x9 $u8 {
    SB:8 // at 0: Controls the lower space periods of the modulator for all modes.
  }

//---  Register PPS: CMT Primary Prescaler Register
  PPS @offset 0xa $u8 {
    4
    PPSDIV:4 // at 0: Primary Prescaler Divider
  }

//---  Register DMA: CMT Direct Memory Access Register
  DMA @offset 0xb $u8 {
    7
    DMA // at 0: DMA Enable
  }

}

//------------------------------------------------------------------------------
// Peripheral CRC: Cyclic Redundancy Check
//------------------------------------------------------------------------------

registers ©CRC @at 0x40032000 {
//---  Register DATA: CRC Data register
  DATA @offset 0x0 $u32 {
    HU:8 // at 24: CRC High Upper Byte
    HL:8 // at 16: CRC High Lower Byte
    LU:8 // at 8: CRC Low Upper Byte
    LL:8 // at 0: CRC Low Lower Byte
  }

//---  Register DATAL: CRC_DATAL register.
  DATAL @offset 0x0 $u16 {
    DATAL:16 // at 0: DATAL stores the lower 16 bits of the 16/32 bit CRC
  }

//---  Register DATALL: CRC_DATALL register.
  DATALL @offset 0x0 $u8 {
    DATALL:8 // at 0: CRCLL stores the first 8 bits of the 32 bit DATA
  }

//---  Register DATALU: CRC_DATALU register.
  DATALU @offset 0x1 $u8 {
    DATALU:8 // at 0: DATALL stores the second 8 bits of the 32 bit CRC
  }

//---  Register DATAH: CRC_DATAH register.
  DATAH @offset 0x2 $u16 {
    DATAH:16 // at 0: DATAH stores the high 16 bits of the 16/32 bit CRC
  }

//---  Register DATAHL: CRC_DATAHL register.
  DATAHL @offset 0x2 $u8 {
    DATAHL:8 // at 0: DATAHL stores the third 8 bits of the 32 bit CRC
  }

//---  Register DATAHU: CRC_DATAHU register.
  DATAHU @offset 0x3 $u8 {
    DATAHU:8 // at 0: DATAHU stores the fourth 8 bits of the 32 bit CRC
  }

//---  Register GPOLY: CRC Polynomial register
  GPOLY @offset 0x4 $u32 {
    HIGH:16 // at 16: High Polynominal Half-word
    LOW:16 // at 0: Low Polynominal Half-word
  }

//---  Register GPOLYL: CRC_GPOLYL register.
  GPOLYL @offset 0x4 $u16 {
    GPOLYL:16 // at 0: POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
  }

//---  Register GPOLYLL: CRC_GPOLYLL register.
  GPOLYLL @offset 0x4 $u8 {
    GPOLYLL:8 // at 0: POLYLL stores the first 8 bits of the 32 bit CRC
  }

//---  Register GPOLYLU: CRC_GPOLYLU register.
  GPOLYLU @offset 0x5 $u8 {
    GPOLYLU:8 // at 0: POLYLL stores the second 8 bits of the 32 bit CRC
  }

//---  Register GPOLYH: CRC_GPOLYH register.
  GPOLYH @offset 0x6 $u16 {
    GPOLYH:16 // at 0: POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
  }

//---  Register GPOLYHL: CRC_GPOLYHL register.
  GPOLYHL @offset 0x6 $u8 {
    GPOLYHL:8 // at 0: POLYHL stores the third 8 bits of the 32 bit CRC
  }

//---  Register GPOLYHU: CRC_GPOLYHU register.
  GPOLYHU @offset 0x7 $u8 {
    GPOLYHU:8 // at 0: POLYHU stores the fourth 8 bits of the 32 bit CRC
  }

//---  Register CTRL: CRC Control register
  CTRL @offset 0x8 $u32 {
    TOT:2 // at 30: Type Of Transpose For Writes
    TOTR:2 // at 28: Type Of Transpose For Read
    1
    FXOR // at 26: Complement Read Of CRC Data Register
    WAS // at 25: Write CRC Data Register As Seed
    TCRC // at 24: Width of CRC protocol.
    24
  }

//---  Register CTRLHU: CRC_CTRLHU register.
  CTRLHU @offset 0xb $u8 {
    TOT:2 // at 6: no description available
    TOTR:2 // at 4: no description available
    1
    FXOR // at 2: no description available
    WAS // at 1: no description available
    TCRC // at 0: no description available
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©DAC [2]
//        DAC0 at 0x400cc000
//        DAC1 at 0x400cd000
//------------------------------------------------------------------------------

registers ©DAC [2 @at 0x400cc000 0x400cd000]
          ©DAC0 @at 0x400cc000
          ©DAC1 @at 0x400cd000
{
//---  Registers DATL(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data Low Register
  DAT0L @offset 0x0 $u8
  DAT1L @offset 0x2 $u8
  DAT2L @offset 0x4 $u8
  DAT3L @offset 0x6 $u8
  DAT4L @offset 0x8 $u8
  DAT5L @offset 0xa $u8
  DAT6L @offset 0xc $u8
  DAT7L @offset 0xe $u8
  DAT8L @offset 0x10 $u8
  DAT9L @offset 0x12 $u8
  DAT10L @offset 0x14 $u8
  DAT11L @offset 0x16 $u8
  DAT12L @offset 0x18 $u8
  DAT13L @offset 0x1a $u8
  DAT14L @offset 0x1c $u8
  DAT15L @offset 0x1e $u8 {
    DATA0:8 // at 0: When the DAC buffer is not enabled, DATA[11:0] controls the output voltage based on the following formula: V out = V in * (1 + DACDAT0[11:0])/4096 When the DAC buffer is enabled, DATA is mapped to the 16-word buffer
  }

//---  Registers DATH(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data High Register
  DAT0H @offset 0x1 $u8
  DAT1H @offset 0x3 $u8
  DAT2H @offset 0x5 $u8
  DAT3H @offset 0x7 $u8
  DAT4H @offset 0x9 $u8
  DAT5H @offset 0xb $u8
  DAT6H @offset 0xd $u8
  DAT7H @offset 0xf $u8
  DAT8H @offset 0x11 $u8
  DAT9H @offset 0x13 $u8
  DAT10H @offset 0x15 $u8
  DAT11H @offset 0x17 $u8
  DAT12H @offset 0x19 $u8
  DAT13H @offset 0x1b $u8
  DAT14H @offset 0x1d $u8
  DAT15H @offset 0x1f $u8 {
    4
    DATA1:4 // at 0: When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage based on the following formula
  }

//---  Register SR: DAC Status Register
  SR @offset 0x20 $u8 {
    5
    DACBFWMF // at 2: DAC Buffer Watermark Flag
    DACBFRPTF // at 1: DAC Buffer Read Pointer Top Position Flag
    DACBFRPBF // at 0: DAC Buffer Read Pointer Bottom Position Flag
  }

//---  Register C0: DAC Control Register
  C0 @offset 0x21 $u8 {
    DACEN // at 7: DAC Enable
    DACRFS // at 6: DAC Reference Select
    DACTRGSEL // at 5: DAC Trigger Select
    DACSWTRG // at 4: DAC Software Trigger
    LPEN // at 3: DAC Low Power Control
    DACBWIEN // at 2: DAC Buffer Watermark Interrupt Enable
    DACBTIEN // at 1: DAC Buffer Read Pointer Top Flag Interrupt Enable
    DACBBIEN // at 0: DAC Buffer Read Pointer Bottom Flag Interrupt Enable
  }

//---  Register C1: DAC Control Register 1
  C1 @offset 0x22 $u8 {
    DMAEN // at 7: DMA Enable Select
    2
    DACBFWM:2 // at 3: DAC Buffer Watermark Select
    DACBFMD:2 // at 1: DAC Buffer Work Mode Select
    DACBFEN // at 0: DAC Buffer Enable
  }

//---  Register C2: DAC Control Register 2
  C2 @offset 0x23 $u8 {
    DACBFRP:4 // at 4: DAC Buffer Read Pointer
    DACBFUP:4 // at 0: DAC Buffer Upper Limit
  }

}

//------------------------------------------------------------------------------
// Peripheral DMA: Enhanced direct memory access controller
//------------------------------------------------------------------------------

registers ©DMA @at 0x40008000 {
//---  Register CR: Control Register
  CR @offset 0x0 $u32 {
    14
    CX // at 17: Cancel Transfer
    ECX // at 16: Error Cancel Transfer
    8
    EMLM // at 7: Enable Minor Loop Mapping
    CLM // at 6: Continuous Link Mode
    HALT // at 5: Halt DMA Operations
    HOE // at 4: Halt On Error
    1
    ERCA // at 2: Enable Round Robin Channel Arbitration
    EDBG // at 1: Enable Debug
    1
  }

//---  Register ES: Error Status Register
  ES @offset 0x4 @ro $u32 {
    VLD // at 31: Logical OR of all ERR status bits
    14
    ECX // at 16: Transfer Canceled
    1
    CPE // at 14: Channel Priority Error
    2
    ERRCHN:4 // at 8: Error Channel Number or Canceled Channel Number
    SAE // at 7: Source Address Error
    SOE // at 6: Source Offset Error
    DAE // at 5: Destination Address Error
    DOE // at 4: Destination Offset Error
    NCE // at 3: NBYTES/CITER Configuration Error
    SGE // at 2: Scatter/Gather Configuration Error
    SBE // at 1: Source Bus Error
    DBE // at 0: Destination Bus Error
  }

//---  Register ERQ: Enable Request Register
  ERQ @offset 0xc $u32 {
    16
    ERQ15 // at 15: Enable DMA Request 15
    ERQ14 // at 14: Enable DMA Request 14
    ERQ13 // at 13: Enable DMA Request 13
    ERQ12 // at 12: Enable DMA Request 12
    ERQ11 // at 11: Enable DMA Request 11
    ERQ10 // at 10: Enable DMA Request 10
    ERQ9 // at 9: Enable DMA Request 9
    ERQ8 // at 8: Enable DMA Request 8
    ERQ7 // at 7: Enable DMA Request 7
    ERQ6 // at 6: Enable DMA Request 6
    ERQ5 // at 5: Enable DMA Request 5
    ERQ4 // at 4: Enable DMA Request 4
    ERQ3 // at 3: Enable DMA Request 3
    ERQ2 // at 2: Enable DMA Request 2
    ERQ1 // at 1: Enable DMA Request 1
    ERQ0 // at 0: Enable DMA Request 0
  }

//---  Register EEI: Enable Error Interrupt Register
  EEI @offset 0x14 $u32 {
    16
    EEI15 // at 15: Enable Error Interrupt 15
    EEI14 // at 14: Enable Error Interrupt 14
    EEI13 // at 13: Enable Error Interrupt 13
    EEI12 // at 12: Enable Error Interrupt 12
    EEI11 // at 11: Enable Error Interrupt 11
    EEI10 // at 10: Enable Error Interrupt 10
    EEI9 // at 9: Enable Error Interrupt 9
    EEI8 // at 8: Enable Error Interrupt 8
    EEI7 // at 7: Enable Error Interrupt 7
    EEI6 // at 6: Enable Error Interrupt 6
    EEI5 // at 5: Enable Error Interrupt 5
    EEI4 // at 4: Enable Error Interrupt 4
    EEI3 // at 3: Enable Error Interrupt 3
    EEI2 // at 2: Enable Error Interrupt 2
    EEI1 // at 1: Enable Error Interrupt 1
    EEI0 // at 0: Enable Error Interrupt 0
  }

//---  Register CEEI: Clear Enable Error Interrupt Register
  CEEI @offset 0x18 $u8 {
    NOP // at 7: No Op enable
    CAEE // at 6: Clear All Enable Error Interrupts
    2
    CEEI:4 // at 0: Clear Enable Error Interrupt
  }

//---  Register SEEI: Set Enable Error Interrupt Register
  SEEI @offset 0x19 $u8 {
    NOP // at 7: No Op enable
    SAEE // at 6: Sets All Enable Error Interrupts
    2
    SEEI:4 // at 0: Set Enable Error Interrupt
  }

//---  Register CERQ: Clear Enable Request Register
  CERQ @offset 0x1a $u8 {
    NOP // at 7: No Op enable
    CAER // at 6: Clear All Enable Requests
    2
    CERQ:4 // at 0: Clear Enable Request
  }

//---  Register SERQ: Set Enable Request Register
  SERQ @offset 0x1b $u8 {
    NOP // at 7: No Op enable
    SAER // at 6: Set All Enable Requests
    2
    SERQ:4 // at 0: Set enable request
  }

//---  Register CDNE: Clear DONE Status Bit Register
  CDNE @offset 0x1c $u8 {
    NOP // at 7: No Op enable
    CADN // at 6: Clears All DONE Bits
    2
    CDNE:4 // at 0: Clear DONE Bit
  }

//---  Register SSRT: Set START Bit Register
  SSRT @offset 0x1d $u8 {
    NOP // at 7: No Op enable
    SAST // at 6: Set All START Bits (activates all channels)
    2
    SSRT:4 // at 0: Set START Bit
  }

//---  Register CERR: Clear Error Register
  CERR @offset 0x1e $u8 {
    NOP // at 7: No Op enable
    CAEI // at 6: Clear All Error Indicators
    2
    CERR:4 // at 0: Clear Error Indicator
  }

//---  Register CINT: Clear Interrupt Request Register
  CINT @offset 0x1f $u8 {
    NOP // at 7: No Op enable
    CAIR // at 6: Clear All Interrupt Requests
    2
    CINT:4 // at 0: Clear Interrupt Request
  }

//---  Register INT: Interrupt Request Register
  INT @offset 0x24 $u32 {
    16
    INT15 // at 15: Interrupt Request 15
    INT14 // at 14: Interrupt Request 14
    INT13 // at 13: Interrupt Request 13
    INT12 // at 12: Interrupt Request 12
    INT11 // at 11: Interrupt Request 11
    INT10 // at 10: Interrupt Request 10
    INT9 // at 9: Interrupt Request 9
    INT8 // at 8: Interrupt Request 8
    INT7 // at 7: Interrupt Request 7
    INT6 // at 6: Interrupt Request 6
    INT5 // at 5: Interrupt Request 5
    INT4 // at 4: Interrupt Request 4
    INT3 // at 3: Interrupt Request 3
    INT2 // at 2: Interrupt Request 2
    INT1 // at 1: Interrupt Request 1
    INT0 // at 0: Interrupt Request 0
  }

//---  Register ERR: Error Register
  ERR @offset 0x2c $u32 {
    16
    ERR15 // at 15: Error In Channel 15
    ERR14 // at 14: Error In Channel 14
    ERR13 // at 13: Error In Channel 13
    ERR12 // at 12: Error In Channel 12
    ERR11 // at 11: Error In Channel 11
    ERR10 // at 10: Error In Channel 10
    ERR9 // at 9: Error In Channel 9
    ERR8 // at 8: Error In Channel 8
    ERR7 // at 7: Error In Channel 7
    ERR6 // at 6: Error In Channel 6
    ERR5 // at 5: Error In Channel 5
    ERR4 // at 4: Error In Channel 4
    ERR3 // at 3: Error In Channel 3
    ERR2 // at 2: Error In Channel 2
    ERR1 // at 1: Error In Channel 1
    ERR0 // at 0: Error In Channel 0
  }

//---  Register HRS: Hardware Request Status Register
  HRS @offset 0x34 @ro $u32 {
    16
    HRS15 // at 15: Hardware Request Status Channel 15
    HRS14 // at 14: Hardware Request Status Channel 14
    HRS13 // at 13: Hardware Request Status Channel 13
    HRS12 // at 12: Hardware Request Status Channel 12
    HRS11 // at 11: Hardware Request Status Channel 11
    HRS10 // at 10: Hardware Request Status Channel 10
    HRS9 // at 9: Hardware Request Status Channel 9
    HRS8 // at 8: Hardware Request Status Channel 8
    HRS7 // at 7: Hardware Request Status Channel 7
    HRS6 // at 6: Hardware Request Status Channel 6
    HRS5 // at 5: Hardware Request Status Channel 5
    HRS4 // at 4: Hardware Request Status Channel 4
    HRS3 // at 3: Hardware Request Status Channel 3
    HRS2 // at 2: Hardware Request Status Channel 2
    HRS1 // at 1: Hardware Request Status Channel 1
    HRS0 // at 0: Hardware Request Status Channel 0
  }

//---  Registers DCHPRI(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12): Channel n Priority Register
  #define DMA_DCHPRI(idx) (* ((volatile uint8_t *) (0x40008000 + 0x100 + (idx) * 0x1)))
  #define DMA_DCHPRI3 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 0 * 0x1)))
  #define DMA_DCHPRI2 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 1 * 0x1)))
  #define DMA_DCHPRI1 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 2 * 0x1)))
  #define DMA_DCHPRI0 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 3 * 0x1)))
  #define DMA_DCHPRI7 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 4 * 0x1)))
  #define DMA_DCHPRI6 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 5 * 0x1)))
  #define DMA_DCHPRI5 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 6 * 0x1)))
  #define DMA_DCHPRI4 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 7 * 0x1)))
  #define DMA_DCHPRI11 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 8 * 0x1)))
  #define DMA_DCHPRI10 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 9 * 0x1)))
  #define DMA_DCHPRI9 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 10 * 0x1)))
  #define DMA_DCHPRI8 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 11 * 0x1)))
  #define DMA_DCHPRI15 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 12 * 0x1)))
  #define DMA_DCHPRI14 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 13 * 0x1)))
  #define DMA_DCHPRI13 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 14 * 0x1)))
  #define DMA_DCHPRI12 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 15 * 0x1)))
 {
    ECP // at 7: Enable Channel Preemption
    DPA // at 6: Disable Preempt Ability
    2
    CHPRI:4 // at 0: Channel n Arbitration Priority
  }

//---  Registers TCD_SADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Source Address
  #define DMA_TCD_SADDR(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1000 + (idx) * 0x20)))
  #define DMA_TCD0_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 0 * 0x20)))
  #define DMA_TCD1_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 1 * 0x20)))
  #define DMA_TCD2_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 2 * 0x20)))
  #define DMA_TCD3_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 3 * 0x20)))
  #define DMA_TCD4_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 4 * 0x20)))
  #define DMA_TCD5_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 5 * 0x20)))
  #define DMA_TCD6_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 6 * 0x20)))
  #define DMA_TCD7_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 7 * 0x20)))
  #define DMA_TCD8_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 8 * 0x20)))
  #define DMA_TCD9_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 9 * 0x20)))
  #define DMA_TCD10_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 10 * 0x20)))
  #define DMA_TCD11_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 11 * 0x20)))
  #define DMA_TCD12_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 12 * 0x20)))
  #define DMA_TCD13_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 13 * 0x20)))
  #define DMA_TCD14_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 14 * 0x20)))
  #define DMA_TCD15_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 15 * 0x20)))
 {
    SADDR:32 // at 0: Source Address
  }

//---  Registers TCD_SOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Source Address Offset
  #define DMA_TCD_SOFF(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1004 + (idx) * 0x20)))
  #define DMA_TCD0_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 0 * 0x20)))
  #define DMA_TCD1_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 1 * 0x20)))
  #define DMA_TCD2_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 2 * 0x20)))
  #define DMA_TCD3_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 3 * 0x20)))
  #define DMA_TCD4_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 4 * 0x20)))
  #define DMA_TCD5_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 5 * 0x20)))
  #define DMA_TCD6_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 6 * 0x20)))
  #define DMA_TCD7_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 7 * 0x20)))
  #define DMA_TCD8_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 8 * 0x20)))
  #define DMA_TCD9_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 9 * 0x20)))
  #define DMA_TCD10_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 10 * 0x20)))
  #define DMA_TCD11_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 11 * 0x20)))
  #define DMA_TCD12_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 12 * 0x20)))
  #define DMA_TCD13_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 13 * 0x20)))
  #define DMA_TCD14_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 14 * 0x20)))
  #define DMA_TCD15_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 15 * 0x20)))
 {
    SOFF:16 // at 0: Source address signed offset
  }

//---  Registers TCD_ATTR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Transfer Attributes
  #define DMA_TCD_ATTR(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1006 + (idx) * 0x20)))
  #define DMA_TCD0_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 0 * 0x20)))
  #define DMA_TCD1_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 1 * 0x20)))
  #define DMA_TCD2_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 2 * 0x20)))
  #define DMA_TCD3_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 3 * 0x20)))
  #define DMA_TCD4_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 4 * 0x20)))
  #define DMA_TCD5_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 5 * 0x20)))
  #define DMA_TCD6_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 6 * 0x20)))
  #define DMA_TCD7_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 7 * 0x20)))
  #define DMA_TCD8_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 8 * 0x20)))
  #define DMA_TCD9_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 9 * 0x20)))
  #define DMA_TCD10_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 10 * 0x20)))
  #define DMA_TCD11_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 11 * 0x20)))
  #define DMA_TCD12_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 12 * 0x20)))
  #define DMA_TCD13_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 13 * 0x20)))
  #define DMA_TCD14_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 14 * 0x20)))
  #define DMA_TCD15_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 15 * 0x20)))
 {
    SMOD:5 // at 11: Source Address Modulo.
    SSIZE:3 // at 8: Source data transfer size
    DMOD:5 // at 3: Destination Address Modulo
    DSIZE:3 // at 0: Destination Data Transfer Size
  }

//---  Registers TCD_NBYTES_MLNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Minor Byte Count (Minor Loop Disabled)
  #define DMA_TCD_NBYTES_MLNO(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1008 + (idx) * 0x20)))
  #define DMA_TCD0_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 0 * 0x20)))
  #define DMA_TCD1_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 1 * 0x20)))
  #define DMA_TCD2_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 2 * 0x20)))
  #define DMA_TCD3_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 3 * 0x20)))
  #define DMA_TCD4_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 4 * 0x20)))
  #define DMA_TCD5_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 5 * 0x20)))
  #define DMA_TCD6_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 6 * 0x20)))
  #define DMA_TCD7_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 7 * 0x20)))
  #define DMA_TCD8_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 8 * 0x20)))
  #define DMA_TCD9_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 9 * 0x20)))
  #define DMA_TCD10_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 10 * 0x20)))
  #define DMA_TCD11_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 11 * 0x20)))
  #define DMA_TCD12_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 12 * 0x20)))
  #define DMA_TCD13_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 13 * 0x20)))
  #define DMA_TCD14_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 14 * 0x20)))
  #define DMA_TCD15_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 15 * 0x20)))
 {
    NBYTES:32 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_NBYTES_MLOFFNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
  #define DMA_TCD_NBYTES_MLOFFNO(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1008 + (idx) * 0x20)))
  #define DMA_TCD0_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 0 * 0x20)))
  #define DMA_TCD1_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 1 * 0x20)))
  #define DMA_TCD2_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 2 * 0x20)))
  #define DMA_TCD3_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 3 * 0x20)))
  #define DMA_TCD4_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 4 * 0x20)))
  #define DMA_TCD5_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 5 * 0x20)))
  #define DMA_TCD6_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 6 * 0x20)))
  #define DMA_TCD7_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 7 * 0x20)))
  #define DMA_TCD8_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 8 * 0x20)))
  #define DMA_TCD9_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 9 * 0x20)))
  #define DMA_TCD10_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 10 * 0x20)))
  #define DMA_TCD11_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 11 * 0x20)))
  #define DMA_TCD12_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 12 * 0x20)))
  #define DMA_TCD13_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 13 * 0x20)))
  #define DMA_TCD14_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 14 * 0x20)))
  #define DMA_TCD15_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 15 * 0x20)))
 {
    SMLOE // at 31: Source Minor Loop Offset Enable
    DMLOE // at 30: Destination Minor Loop Offset enable
    NBYTES:30 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_NBYTES_MLOFFYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
  #define DMA_TCD_NBYTES_MLOFFYES(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1008 + (idx) * 0x20)))
  #define DMA_TCD0_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 0 * 0x20)))
  #define DMA_TCD1_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 1 * 0x20)))
  #define DMA_TCD2_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 2 * 0x20)))
  #define DMA_TCD3_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 3 * 0x20)))
  #define DMA_TCD4_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 4 * 0x20)))
  #define DMA_TCD5_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 5 * 0x20)))
  #define DMA_TCD6_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 6 * 0x20)))
  #define DMA_TCD7_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 7 * 0x20)))
  #define DMA_TCD8_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 8 * 0x20)))
  #define DMA_TCD9_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 9 * 0x20)))
  #define DMA_TCD10_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 10 * 0x20)))
  #define DMA_TCD11_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 11 * 0x20)))
  #define DMA_TCD12_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 12 * 0x20)))
  #define DMA_TCD13_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 13 * 0x20)))
  #define DMA_TCD14_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 14 * 0x20)))
  #define DMA_TCD15_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 15 * 0x20)))
 {
    SMLOE // at 31: Source Minor Loop Offset Enable
    DMLOE // at 30: Destination Minor Loop Offset enable
    MLOFF:20 // at 10: If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
    NBYTES:10 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_SLAST(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Last Source Address Adjustment
  #define DMA_TCD_SLAST(idx) (* ((volatile uint32_t *) (0x40008000 + 0x100c + (idx) * 0x20)))
  #define DMA_TCD0_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 0 * 0x20)))
  #define DMA_TCD1_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 1 * 0x20)))
  #define DMA_TCD2_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 2 * 0x20)))
  #define DMA_TCD3_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 3 * 0x20)))
  #define DMA_TCD4_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 4 * 0x20)))
  #define DMA_TCD5_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 5 * 0x20)))
  #define DMA_TCD6_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 6 * 0x20)))
  #define DMA_TCD7_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 7 * 0x20)))
  #define DMA_TCD8_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 8 * 0x20)))
  #define DMA_TCD9_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 9 * 0x20)))
  #define DMA_TCD10_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 10 * 0x20)))
  #define DMA_TCD11_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 11 * 0x20)))
  #define DMA_TCD12_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 12 * 0x20)))
  #define DMA_TCD13_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 13 * 0x20)))
  #define DMA_TCD14_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 14 * 0x20)))
  #define DMA_TCD15_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 15 * 0x20)))
 {
    SLAST:32 // at 0: Last source Address Adjustment
  }

//---  Registers TCD_DADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Destination Address
  #define DMA_TCD_DADDR(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1010 + (idx) * 0x20)))
  #define DMA_TCD0_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 0 * 0x20)))
  #define DMA_TCD1_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 1 * 0x20)))
  #define DMA_TCD2_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 2 * 0x20)))
  #define DMA_TCD3_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 3 * 0x20)))
  #define DMA_TCD4_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 4 * 0x20)))
  #define DMA_TCD5_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 5 * 0x20)))
  #define DMA_TCD6_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 6 * 0x20)))
  #define DMA_TCD7_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 7 * 0x20)))
  #define DMA_TCD8_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 8 * 0x20)))
  #define DMA_TCD9_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 9 * 0x20)))
  #define DMA_TCD10_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 10 * 0x20)))
  #define DMA_TCD11_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 11 * 0x20)))
  #define DMA_TCD12_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 12 * 0x20)))
  #define DMA_TCD13_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 13 * 0x20)))
  #define DMA_TCD14_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 14 * 0x20)))
  #define DMA_TCD15_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 15 * 0x20)))
 {
    DADDR:32 // at 0: Destination Address
  }

//---  Registers TCD_DOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Destination Address Offset
  #define DMA_TCD_DOFF(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1014 + (idx) * 0x20)))
  #define DMA_TCD0_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 0 * 0x20)))
  #define DMA_TCD1_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 1 * 0x20)))
  #define DMA_TCD2_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 2 * 0x20)))
  #define DMA_TCD3_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 3 * 0x20)))
  #define DMA_TCD4_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 4 * 0x20)))
  #define DMA_TCD5_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 5 * 0x20)))
  #define DMA_TCD6_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 6 * 0x20)))
  #define DMA_TCD7_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 7 * 0x20)))
  #define DMA_TCD8_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 8 * 0x20)))
  #define DMA_TCD9_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 9 * 0x20)))
  #define DMA_TCD10_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 10 * 0x20)))
  #define DMA_TCD11_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 11 * 0x20)))
  #define DMA_TCD12_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 12 * 0x20)))
  #define DMA_TCD13_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 13 * 0x20)))
  #define DMA_TCD14_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 14 * 0x20)))
  #define DMA_TCD15_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 15 * 0x20)))
 {
    DOFF:16 // at 0: Destination Address Signed offset
  }

//---  Registers TCD_CITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  #define DMA_TCD_CITER_ELINKNO(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1016 + (idx) * 0x20)))
  #define DMA_TCD0_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 0 * 0x20)))
  #define DMA_TCD1_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 1 * 0x20)))
  #define DMA_TCD2_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 2 * 0x20)))
  #define DMA_TCD3_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 3 * 0x20)))
  #define DMA_TCD4_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 4 * 0x20)))
  #define DMA_TCD5_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 5 * 0x20)))
  #define DMA_TCD6_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 6 * 0x20)))
  #define DMA_TCD7_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 7 * 0x20)))
  #define DMA_TCD8_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 8 * 0x20)))
  #define DMA_TCD9_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 9 * 0x20)))
  #define DMA_TCD10_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 10 * 0x20)))
  #define DMA_TCD11_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 11 * 0x20)))
  #define DMA_TCD12_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 12 * 0x20)))
  #define DMA_TCD13_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 13 * 0x20)))
  #define DMA_TCD14_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 14 * 0x20)))
  #define DMA_TCD15_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 15 * 0x20)))
 {
    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete
    CITER:15 // at 0: Current Major Iteration Count
  }

//---  Registers TCD_CITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
  #define DMA_TCD_CITER_ELINKYES(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1016 + (idx) * 0x20)))
  #define DMA_TCD0_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 0 * 0x20)))
  #define DMA_TCD1_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 1 * 0x20)))
  #define DMA_TCD2_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 2 * 0x20)))
  #define DMA_TCD3_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 3 * 0x20)))
  #define DMA_TCD4_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 4 * 0x20)))
  #define DMA_TCD5_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 5 * 0x20)))
  #define DMA_TCD6_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 6 * 0x20)))
  #define DMA_TCD7_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 7 * 0x20)))
  #define DMA_TCD8_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 8 * 0x20)))
  #define DMA_TCD9_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 9 * 0x20)))
  #define DMA_TCD10_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 10 * 0x20)))
  #define DMA_TCD11_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 11 * 0x20)))
  #define DMA_TCD12_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 12 * 0x20)))
  #define DMA_TCD13_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 13 * 0x20)))
  #define DMA_TCD14_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 14 * 0x20)))
  #define DMA_TCD15_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 15 * 0x20)))
 {
    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete
    2
    LINKCH:4 // at 9: Link Channel Number
    CITER:9 // at 0: Current Major Iteration Count
  }

//---  Registers TCD_DLASTSGA(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Last Destination Address Adjustment/Scatter Gather Address
  #define DMA_TCD_DLASTSGA(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1018 + (idx) * 0x20)))
  #define DMA_TCD0_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 0 * 0x20)))
  #define DMA_TCD1_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 1 * 0x20)))
  #define DMA_TCD2_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 2 * 0x20)))
  #define DMA_TCD3_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 3 * 0x20)))
  #define DMA_TCD4_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 4 * 0x20)))
  #define DMA_TCD5_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 5 * 0x20)))
  #define DMA_TCD6_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 6 * 0x20)))
  #define DMA_TCD7_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 7 * 0x20)))
  #define DMA_TCD8_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 8 * 0x20)))
  #define DMA_TCD9_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 9 * 0x20)))
  #define DMA_TCD10_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 10 * 0x20)))
  #define DMA_TCD11_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 11 * 0x20)))
  #define DMA_TCD12_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 12 * 0x20)))
  #define DMA_TCD13_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 13 * 0x20)))
  #define DMA_TCD14_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 14 * 0x20)))
  #define DMA_TCD15_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 15 * 0x20)))
 {
    DLASTSGA:32 // at 0: Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
  }

//---  Registers TCD_CSR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Control and Status
  #define DMA_TCD_CSR(idx) (* ((volatile uint16_t *) (0x40008000 + 0x101c + (idx) * 0x20)))
  #define DMA_TCD0_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 0 * 0x20)))
  #define DMA_TCD1_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 1 * 0x20)))
  #define DMA_TCD2_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 2 * 0x20)))
  #define DMA_TCD3_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 3 * 0x20)))
  #define DMA_TCD4_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 4 * 0x20)))
  #define DMA_TCD5_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 5 * 0x20)))
  #define DMA_TCD6_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 6 * 0x20)))
  #define DMA_TCD7_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 7 * 0x20)))
  #define DMA_TCD8_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 8 * 0x20)))
  #define DMA_TCD9_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 9 * 0x20)))
  #define DMA_TCD10_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 10 * 0x20)))
  #define DMA_TCD11_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 11 * 0x20)))
  #define DMA_TCD12_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 12 * 0x20)))
  #define DMA_TCD13_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 13 * 0x20)))
  #define DMA_TCD14_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 14 * 0x20)))
  #define DMA_TCD15_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 15 * 0x20)))
 {
    BWC:2 // at 14: Bandwidth Control
    2
    MAJORLINKCH:4 // at 8: Link Channel Number
    DONE // at 7: Channel Done
    ACTIVE // at 6: Channel Active
    MAJORELINK // at 5: Enable channel-to-channel linking on major loop complete
    ESG // at 4: Enable Scatter/Gather Processing
    DREQ // at 3: Disable Request
    INTHALF // at 2: Enable an interrupt when major counter is half complete.
    INTMAJOR // at 1: Enable an interrupt when major iteration count completes
    START // at 0: Channel Start
  }

//---  Registers TCD_BITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  #define DMA_TCD_BITER_ELINKNO(idx) (* ((volatile uint16_t *) (0x40008000 + 0x101e + (idx) * 0x20)))
  #define DMA_TCD0_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 0 * 0x20)))
  #define DMA_TCD1_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 1 * 0x20)))
  #define DMA_TCD2_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 2 * 0x20)))
  #define DMA_TCD3_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 3 * 0x20)))
  #define DMA_TCD4_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 4 * 0x20)))
  #define DMA_TCD5_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 5 * 0x20)))
  #define DMA_TCD6_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 6 * 0x20)))
  #define DMA_TCD7_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 7 * 0x20)))
  #define DMA_TCD8_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 8 * 0x20)))
  #define DMA_TCD9_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 9 * 0x20)))
  #define DMA_TCD10_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 10 * 0x20)))
  #define DMA_TCD11_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 11 * 0x20)))
  #define DMA_TCD12_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 12 * 0x20)))
  #define DMA_TCD13_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 13 * 0x20)))
  #define DMA_TCD14_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 14 * 0x20)))
  #define DMA_TCD15_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 15 * 0x20)))
 {
    ELINK // at 15: Enables channel-to-channel linking on minor loop complete
    BITER:15 // at 0: Starting Major Iteration Count
  }

//---  Registers TCD_BITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
  #define DMA_TCD_BITER_ELINKYES(idx) (* ((volatile uint16_t *) (0x40008000 + 0x101e + (idx) * 0x20)))
  #define DMA_TCD0_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 0 * 0x20)))
  #define DMA_TCD1_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 1 * 0x20)))
  #define DMA_TCD2_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 2 * 0x20)))
  #define DMA_TCD3_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 3 * 0x20)))
  #define DMA_TCD4_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 4 * 0x20)))
  #define DMA_TCD5_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 5 * 0x20)))
  #define DMA_TCD6_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 6 * 0x20)))
  #define DMA_TCD7_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 7 * 0x20)))
  #define DMA_TCD8_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 8 * 0x20)))
  #define DMA_TCD9_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 9 * 0x20)))
  #define DMA_TCD10_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 10 * 0x20)))
  #define DMA_TCD11_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 11 * 0x20)))
  #define DMA_TCD12_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 12 * 0x20)))
  #define DMA_TCD13_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 13 * 0x20)))
  #define DMA_TCD14_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 14 * 0x20)))
  #define DMA_TCD15_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 15 * 0x20)))
 {
    ELINK // at 15: Enables channel-to-channel linking on minor loop complete
    2
    LINKCH:4 // at 9: Link Channel Number
    BITER:9 // at 0: Starting Major Iteration Count
  }

}

//------------------------------------------------------------------------------
// Peripheral DMAMUX: DMA channel multiplexor
//------------------------------------------------------------------------------

registers ©DMAMUX @at 0x40021000 {
//---  Registers CHCFG(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Channel Configuration register
  #define DMAMUX_CHCFG(idx) (* ((volatile uint8_t *) (0x40021000 + 0x0 + (idx) * 0x1)))
  #define DMAMUX_CHCFG0 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 0 * 0x1)))
  #define DMAMUX_CHCFG1 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 1 * 0x1)))
  #define DMAMUX_CHCFG2 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 2 * 0x1)))
  #define DMAMUX_CHCFG3 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 3 * 0x1)))
  #define DMAMUX_CHCFG4 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 4 * 0x1)))
  #define DMAMUX_CHCFG5 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 5 * 0x1)))
  #define DMAMUX_CHCFG6 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 6 * 0x1)))
  #define DMAMUX_CHCFG7 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 7 * 0x1)))
  #define DMAMUX_CHCFG8 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 8 * 0x1)))
  #define DMAMUX_CHCFG9 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 9 * 0x1)))
  #define DMAMUX_CHCFG10 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 10 * 0x1)))
  #define DMAMUX_CHCFG11 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 11 * 0x1)))
  #define DMAMUX_CHCFG12 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 12 * 0x1)))
  #define DMAMUX_CHCFG13 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 13 * 0x1)))
  #define DMAMUX_CHCFG14 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 14 * 0x1)))
  #define DMAMUX_CHCFG15 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 15 * 0x1)))
 {
    ENBL // at 7: DMA Channel Enable
    TRIG // at 6: DMA Channel Trigger Enable
    SOURCE:6 // at 0: DMA Channel Source (Slot)
  }

}

//------------------------------------------------------------------------------
// Peripheral ENET: Ethernet MAC-NET Core
//------------------------------------------------------------------------------

registers ©ENET @at 0x400c0000 {
//---  Register EIR: Interrupt Event Register
  EIR @offset 0x4 $u32 {
    1
    BABR // at 30: Babbling Receive Error
    BABT // at 29: Babbling Transmit Error
    GRA // at 28: Graceful Stop Complete
    TXF // at 27: Transmit Frame Interrupt
    TXB // at 26: Transmit Buffer Interrupt
    RXF // at 25: Receive Frame Interrupt
    RXB // at 24: Receive Buffer Interrupt
    MII // at 23: MII Interrupt.
    EBERR // at 22: Ethernet Bus Error
    LC // at 21: Late Collision
    RL // at 20: Collision Retry Limit
    UN // at 19: Transmit FIFO Underrun
    PLR // at 18: Payload Receive Error
    WAKEUP // at 17: Node Wakeup Request Indication
    TS_AVAIL // at 16: Transmit Timestamp Available
    TS_TIMER // at 15: Timestamp Timer
    15
  }

//---  Register EIMR: Interrupt Mask Register
  EIMR @offset 0x8 $u32 {
    1
    BABR // at 30: BABR Interrupt Mask
    BABT // at 29: BABT Interrupt Mask
    GRA // at 28: GRA Interrupt Mask
    TXF // at 27: TXF Interrupt Mask
    TXB // at 26: TXB Interrupt Mask
    RXF // at 25: RXF Interrupt Mask
    RXB // at 24: RXB Interrupt Mask
    MII // at 23: MII Interrupt Mask
    EBERR // at 22: EBERR Interrupt Mask
    LC // at 21: LC Interrupt Mask
    RL // at 20: RL Interrupt Mask
    UN // at 19: UN Interrupt Mask
    PLR // at 18: PLR Interrupt Mask
    WAKEUP // at 17: WAKEUP Interrupt Mask
    TS_AVAIL // at 16: TS_AVAIL Interrupt Mask
    TS_TIMER // at 15: TS_TIMER Interrupt Mask
    15
  }

//---  Register RDAR: Receive Descriptor Active Register
  RDAR @offset 0x10 $u32 {
    7
    RDAR // at 24: Receive Descriptor Active
    24
  }

//---  Register TDAR: Transmit Descriptor Active Register
  TDAR @offset 0x14 $u32 {
    7
    TDAR // at 24: Transmit Descriptor Active
    24
  }

//---  Register ECR: Ethernet Control Register
  ECR @offset 0x24 $u32 {
    23
    DBSWP // at 8: Descriptor Byte Swapping Enable
    STOPEN // at 7: STOPEN Signal Control
    DBGEN // at 6: Debug Enable
    1
    EN1588 // at 4: EN1588 Enable
    SLEEP // at 3: Sleep Mode Enable
    MAGICEN // at 2: Magic Packet Detection Enable
    ETHEREN // at 1: Ethernet Enable
    RESET // at 0: Ethernet MAC Reset
  }

//---  Register MMFR: MII Management Frame Register
  MMFR @offset 0x40 $u32 {
    ST:2 // at 30: Start Of Frame Delimiter
    OP:2 // at 28: Operation Code
    PA:5 // at 23: PHY Address
    RA:5 // at 18: Register Address
    TA:2 // at 16: Turn Around
    DATA:16 // at 0: Management Frame Data
  }

//---  Register MSCR: MII Speed Control Register
  MSCR @offset 0x44 $u32 {
    21
    HOLDTIME:3 // at 8: Hold time On MDIO Output
    DIS_PRE // at 7: Disable Preamble
    MII_SPEED:6 // at 1: MII Speed
    1
  }

//---  Register MIBC: MIB Control Register
  MIBC @offset 0x64 $u32 {
    MIB_DIS // at 31: Disable MIB Logic
    MIB_IDLE // at 30: MIB Idle
    MIB_CLEAR // at 29: MIB Clear
    29
  }

//---  Register RCR: Receive Control Register
  RCR @offset 0x84 $u32 {
    GRS // at 31: Graceful Receive Stopped
    NLC // at 30: Payload Length Check Disable
    MAX_FL:14 // at 16: Maximum Frame Length
    CFEN // at 15: MAC Control Frame Enable
    CRCFWD // at 14: Terminate/Forward Received CRC
    PAUFWD // at 13: Terminate/Forward Pause Frames
    PADEN // at 12: Enable Frame Padding Remove On Receive
    2
    RMII_10T // at 9: Enables 10-Mbps mode of the RMII .
    RMII_MODE // at 8: RMII Mode Enable
    2
    FCE // at 5: Flow Control Enable
    BC_REJ // at 4: Broadcast Frame Reject
    PROM // at 3: Promiscuous Mode
    MII_MODE // at 2: Media Independent Interface Mode
    DRT // at 1: Disable Receive On Transmit
    LOOP // at 0: Internal Loopback
  }

//---  Register TCR: Transmit Control Register
  TCR @offset 0xc4 $u32 {
    22
    CRCFWD // at 9: Forward Frame From Application With CRC
    ADDINS // at 8: Set MAC Address On Transmit
    ADDSEL:3 // at 5: Source MAC Address Select On Transmit
    RFC_PAUSE // at 4: Receive Frame Control Pause
    TFC_PAUSE // at 3: Transmit Frame Control Pause
    FDEN // at 2: Full-Duplex Enable
    1
    GTS // at 0: Graceful Transmit Stop
  }

//---  Register PALR: Physical Address Lower Register
  PALR @offset 0xe4 $u32 {
    PADDR1:32 // at 0: Pause Address
  }

//---  Register PAUR: Physical Address Upper Register
  PAUR @offset 0xe8 $u32 {
    PADDR2:16 // at 16: Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames
    TYPE:16 // at 0: Type Field In PAUSE Frames
  }

//---  Register OPD: Opcode/Pause Duration Register
  OPD @offset 0xec $u32 {
    OPCODE:16 // at 16: Opcode Field In PAUSE Frames
    PAUSE_DUR:16 // at 0: Pause Duration
  }

//---  Register IAUR: Descriptor Individual Upper Address Register
  IAUR @offset 0x118 $u32 {
    IADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
  }

//---  Register IALR: Descriptor Individual Lower Address Register
  IALR @offset 0x11c $u32 {
    IADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
  }

//---  Register GAUR: Descriptor Group Upper Address Register
  GAUR @offset 0x120 $u32 {
    GADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
  }

//---  Register GALR: Descriptor Group Lower Address Register
  GALR @offset 0x124 $u32 {
    GADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
  }

//---  Register TFWR: Transmit FIFO Watermark Register
  TFWR @offset 0x144 $u32 {
    23
    STRFWD // at 8: Store And Forward Enable
    2
    TFWR:6 // at 0: Transmit FIFO Write
  }

//---  Register RDSR: Receive Descriptor Ring Start Register
  RDSR @offset 0x180 $u32 {
    R_DES_START:29 // at 3: Pointer to the beginning of the receive buffer descriptor queue.
    3
  }

//---  Register TDSR: Transmit Buffer Descriptor Ring Start Register
  TDSR @offset 0x184 $u32 {
    X_DES_START:29 // at 3: Pointer to the beginning of the transmit buffer descriptor queue.
    3
  }

//---  Register MRBR: Maximum Receive Buffer Size Register
  MRBR @offset 0x188 $u32 {
    18
    R_BUF_SIZE:10 // at 4: Receive buffer size in bytes.
    4
  }

//---  Register RSFL: Receive FIFO Section Full Threshold
  RSFL @offset 0x190 $u32 {
    24
    RX_SECTION_FULL:8 // at 0: Value Of Receive FIFO Section Full Threshold
  }

//---  Register RSEM: Receive FIFO Section Empty Threshold
  RSEM @offset 0x194 $u32 {
    11
    STAT_SECTION_EMPTY:5 // at 16: RX Status FIFO Section Empty Threshold
    8
    RX_SECTION_EMPTY:8 // at 0: Value Of The Receive FIFO Section Empty Threshold
  }

//---  Register RAEM: Receive FIFO Almost Empty Threshold
  RAEM @offset 0x198 $u32 {
    24
    RX_ALMOST_EMPTY:8 // at 0: Value Of The Receive FIFO Almost Empty Threshold
  }

//---  Register RAFL: Receive FIFO Almost Full Threshold
  RAFL @offset 0x19c $u32 {
    24
    RX_ALMOST_FULL:8 // at 0: Value Of The Receive FIFO Almost Full Threshold
  }

//---  Register TSEM: Transmit FIFO Section Empty Threshold
  TSEM @offset 0x1a0 $u32 {
    24
    TX_SECTION_EMPTY:8 // at 0: Value Of The Transmit FIFO Section Empty Threshold
  }

//---  Register TAEM: Transmit FIFO Almost Empty Threshold
  TAEM @offset 0x1a4 $u32 {
    24
    TX_ALMOST_EMPTY:8 // at 0: Value of Transmit FIFO Almost Empty Threshold
  }

//---  Register TAFL: Transmit FIFO Almost Full Threshold
  TAFL @offset 0x1a8 $u32 {
    24
    TX_ALMOST_FULL:8 // at 0: Value Of The Transmit FIFO Almost Full Threshold
  }

//---  Register TIPG: Transmit Inter-Packet Gap
  TIPG @offset 0x1ac $u32 {
    27
    IPG:5 // at 0: Transmit Inter-Packet Gap
  }

//---  Register FTRL: Frame Truncation Length
  FTRL @offset 0x1b0 $u32 {
    18
    TRUNC_FL:14 // at 0: Frame Truncation Length
  }

//---  Register TACC: Transmit Accelerator Function Configuration
  TACC @offset 0x1c0 $u32 {
    27
    PROCHK // at 4: Enables insertion of protocol checksum.
    IPCHK // at 3: Enables insertion of IP header checksum.
    2
    SHIFT16 // at 0: TX FIFO Shift-16
  }

//---  Register RACC: Receive Accelerator Function Configuration
  RACC @offset 0x1c4 $u32 {
    24
    SHIFT16 // at 7: RX FIFO Shift-16
    LINEDIS // at 6: Enable Discard Of Frames With MAC Layer Errors
    3
    PRODIS // at 2: Enable Discard Of Frames With Wrong Protocol Checksum
    IPDIS // at 1: Enable Discard Of Frames With Wrong IPv4 Header Checksum
    PADREM // at 0: Enable Padding Removal For Short IP Frames
  }

//---  Register RMON_T_PACKETS: Tx Packet Count Statistic Register
  RMON_T_PACKETS @offset 0x204 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
  RMON_T_BC_PKT @offset 0x208 @ro $u32 {
    16
    TXPKTS:16 // at 0: Broadcast packets
  }

//---  Register RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
  RMON_T_MC_PKT @offset 0x20c @ro $u32 {
    16
    TXPKTS:16 // at 0: Multicast packets
  }

//---  Register RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
  RMON_T_CRC_ALIGN @offset 0x210 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packets with CRC/align error
  }

//---  Register RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
  RMON_T_UNDERSIZE @offset 0x214 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
  RMON_T_OVERSIZE @offset 0x218 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
  RMON_T_FRAG @offset 0x21c @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
  RMON_T_JAB @offset 0x220 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_COL: Tx Collision Count Statistic Register
  RMON_T_COL @offset 0x224 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P64: Tx 64-Byte Packets Statistic Register
  RMON_T_P64 @offset 0x228 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
  RMON_T_P65TO127 @offset 0x22c @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
  RMON_T_P128TO255 @offset 0x230 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
  RMON_T_P256TO511 @offset 0x234 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
  RMON_T_P512TO1023 @offset 0x238 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
  RMON_T_P1024TO2047 @offset 0x23c @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
  RMON_T_P_GTE2048 @offset 0x240 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_OCTETS: Tx Octets Statistic Register
  RMON_T_OCTETS @offset 0x244 @ro $u32 {
    TXOCTS:32 // at 0: Octet count
  }

//---  Register IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
  IEEE_T_FRAME_OK @offset 0x24c @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
  IEEE_T_1COL @offset 0x250 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
  IEEE_T_MCOL @offset 0x254 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
  IEEE_T_DEF @offset 0x258 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
  IEEE_T_LCOL @offset 0x25c @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
  IEEE_T_EXCOL @offset 0x260 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
  IEEE_T_MACERR @offset 0x264 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
  IEEE_T_CSERR @offset 0x268 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
  IEEE_T_FDXFC @offset 0x270 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
  IEEE_T_OCTETS_OK @offset 0x274 @ro $u32 {
    COUNT:32 // at 0: Octet count
  }

//---  Register RMON_R_PACKETS: Rx Packet Count Statistic Register
  RMON_R_PACKETS @offset 0x284 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
  RMON_R_BC_PKT @offset 0x288 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
  RMON_R_MC_PKT @offset 0x28c @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
  RMON_R_CRC_ALIGN @offset 0x290 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
  RMON_R_UNDERSIZE @offset 0x294 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
  RMON_R_OVERSIZE @offset 0x298 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
  RMON_R_FRAG @offset 0x29c @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
  RMON_R_JAB @offset 0x2a0 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P64: Rx 64-Byte Packets Statistic Register
  RMON_R_P64 @offset 0x2a8 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
  RMON_R_P65TO127 @offset 0x2ac @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
  RMON_R_P128TO255 @offset 0x2b0 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
  RMON_R_P256TO511 @offset 0x2b4 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
  RMON_R_P512TO1023 @offset 0x2b8 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
  RMON_R_P1024TO2047 @offset 0x2bc @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
  RMON_R_P_GTE2048 @offset 0x2c0 @ro $u32 {
    16
    COUNT:16 // at 0: Packet count
  }

//---  Register RMON_R_OCTETS: Rx Octets Statistic Register
  RMON_R_OCTETS @offset 0x2c4 @ro $u32 {
    COUNT:32 // at 0: Octet count
  }

//---  Register IEEE_R_DROP: Frames not Counted Correctly Statistic Register
  IEEE_R_DROP @offset 0x2c8 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_R_FRAME_OK: Frames Received OK Statistic Register
  IEEE_R_FRAME_OK @offset 0x2cc @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_R_CRC: Frames Received with CRC Error Statistic Register
  IEEE_R_CRC @offset 0x2d0 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
  IEEE_R_ALIGN @offset 0x2d4 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
  IEEE_R_MACERR @offset 0x2d8 @ro $u32 {
    16
    COUNT:16 // at 0: Count
  }

//---  Register IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
  IEEE_R_FDXFC @offset 0x2dc @ro $u32 {
    16
    COUNT:16 // at 0: Pause frame count
  }

//---  Register IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
  IEEE_R_OCTETS_OK @offset 0x2e0 @ro $u32 {
    COUNT:32 // at 0: Octet count
  }

//---  Register ATCR: Adjustable Timer Control Register
  ATCR @offset 0x400 $u32 {
    18
    SLAVE // at 13: Enable Timer Slave Mode
    1
    CAPTURE // at 11: Capture Timer Value
    1
    RESTART // at 9: Reset Timer
    1
    PINPER // at 7: Enables event signal output assertion on period event
    2
    PEREN // at 4: Enable Periodical Event
    OFFRST // at 3: Reset Timer On Offset Event
    OFFEN // at 2: Enable One-Shot Offset Event
    1
    EN // at 0: Enable Timer
  }

//---  Register ATVR: Timer Value Register
  ATVR @offset 0x404 $u32 {
    ATIME:32 // at 0: A write sets the timer
  }

//---  Register ATOFF: Timer Offset Register
  ATOFF @offset 0x408 $u32 {
    OFFSET:32 // at 0: Offset value for one-shot event generation
  }

//---  Register ATPER: Timer Period Register
  ATPER @offset 0x40c $u32 {
    PERIOD:32 // at 0: Value for generating periodic events
  }

//---  Register ATCOR: Timer Correction Register
  ATCOR @offset 0x410 $u32 {
    1
    COR:31 // at 0: Correction Counter Wrap-Around Value
  }

//---  Register ATINC: Time-Stamping Clock Period Register
  ATINC @offset 0x414 $u32 {
    17
    INC_CORR:7 // at 8: Correction Increment Value
    1
    INC:7 // at 0: Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
  }

//---  Register ATSTMP: Timestamp of Last Transmitted Frame
  ATSTMP @offset 0x418 @ro $u32 {
    TIMESTAMP:32 // at 0: Timestamp of the last frame transmitted by the core that had TxBD[TS] set
  }

//---  Register TGSR: Timer Global Status Register
  TGSR @offset 0x604 $u32 {
    28
    TF3 // at 3: Copy Of Timer Flag For Channel 3
    TF2 // at 2: Copy Of Timer Flag For Channel 2
    TF1 // at 1: Copy Of Timer Flag For Channel 1
    TF0 // at 0: Copy Of Timer Flag For Channel 0
  }

//---  Registers TCSR(0,1,2,3): Timer Control Status Register
  #define ENET_TCSR(idx) (* ((volatile uint32_t *) (0x400c0000 + 0x608 + (idx) * 0x8)))
  #define ENET_TCSR0 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 0 * 0x8)))
  #define ENET_TCSR1 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 1 * 0x8)))
  #define ENET_TCSR2 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 2 * 0x8)))
  #define ENET_TCSR3 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 3 * 0x8)))
 {
    24
    TF // at 7: Timer Flag
    TIE // at 6: Timer Interrupt Enable
    TMODE:4 // at 2: Timer Mode
    1
    TDRE // at 0: Timer DMA Request Enable
  }

//---  Registers TCCR(0,1,2,3): Timer Compare Capture Register
  #define ENET_TCCR(idx) (* ((volatile uint32_t *) (0x400c0000 + 0x60c + (idx) * 0x8)))
  #define ENET_TCCR0 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 0 * 0x8)))
  #define ENET_TCCR1 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 1 * 0x8)))
  #define ENET_TCCR2 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 2 * 0x8)))
  #define ENET_TCCR3 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 3 * 0x8)))
 {
    TCC:32 // at 0: Timer Capture Compare
  }

}

//------------------------------------------------------------------------------
// Peripheral EWM: External Watchdog Monitor
//------------------------------------------------------------------------------

registers ©EWM @at 0x40061000 {
//---  Register CTRL: Control Register
  CTRL @offset 0x0 $u8 {
    4
    INTEN // at 3: Interrupt Enable.
    INEN // at 2: Input Enable.
    ASSIN // at 1: EWM_in's Assertion State Select.
    EWMEN // at 0: EWM enable.
  }

//---  Register SERV: Service Register
  SERV @offset 0x1 $u8 {
    SERVICE:8 // at 0: The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
  }

//---  Register CMPL: Compare Low Register
  CMPL @offset 0x2 $u8 {
    COMPAREL:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
  }

//---  Register CMPH: Compare High Register
  CMPH @offset 0x3 $u8 {
    COMPAREH:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
  }

}

//------------------------------------------------------------------------------
// Peripheral FB: FlexBus external bus interface
//------------------------------------------------------------------------------

registers ©FB @at 0x4000c000 {
//---  Registers CSAR(0,1,2,3,4,5): Chip Select Address Register
  #define FB_CSAR(idx) (* ((volatile uint32_t *) (0x4000c000 + 0x0 + (idx) * 0xc)))
  #define FB_CSAR0 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 0 * 0xc)))
  #define FB_CSAR1 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 1 * 0xc)))
  #define FB_CSAR2 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 2 * 0xc)))
  #define FB_CSAR3 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 3 * 0xc)))
  #define FB_CSAR4 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 4 * 0xc)))
  #define FB_CSAR5 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 5 * 0xc)))
 {
    BA:16 // at 16: Base Address
    16
  }

//---  Registers CSMR(0,1,2,3,4,5): Chip Select Mask Register
  #define FB_CSMR(idx) (* ((volatile uint32_t *) (0x4000c000 + 0x4 + (idx) * 0xc)))
  #define FB_CSMR0 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 0 * 0xc)))
  #define FB_CSMR1 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 1 * 0xc)))
  #define FB_CSMR2 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 2 * 0xc)))
  #define FB_CSMR3 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 3 * 0xc)))
  #define FB_CSMR4 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 4 * 0xc)))
  #define FB_CSMR5 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 5 * 0xc)))
 {
    BAM:16 // at 16: Base Address Mask
    7
    WP // at 8: Write Protect
    7
    V // at 0: Valid
  }

//---  Registers CSCR(0,1,2,3,4,5): Chip Select Control Register
  #define FB_CSCR(idx) (* ((volatile uint32_t *) (0x4000c000 + 0x8 + (idx) * 0xc)))
  #define FB_CSCR0 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 0 * 0xc)))
  #define FB_CSCR1 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 1 * 0xc)))
  #define FB_CSCR2 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 2 * 0xc)))
  #define FB_CSCR3 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 3 * 0xc)))
  #define FB_CSCR4 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 4 * 0xc)))
  #define FB_CSCR5 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 5 * 0xc)))
 {
    SWS:6 // at 26: Secondary Wait States
    2
    SWSEN // at 23: Secondary Wait State Enable
    EXTS // at 22: Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
    ASET:2 // at 20: Address Setup
    RDAH:2 // at 18: Read Address Hold or Deselect
    WRAH:2 // at 16: Write Address Hold or Deselect
    WS:6 // at 10: Wait States
    BLS // at 9: Byte-Lane Shift
    AA // at 8: Auto-Acknowledge Enable
    PS:2 // at 6: Port Size
    BEM // at 5: Byte-Enable Mode
    BSTR // at 4: Burst-Read Enable
    BSTW // at 3: Burst-Write Enable
    3
  }

//---  Register CSPMCR: Chip Select port Multiplexing Control Register
  CSPMCR @offset 0x60 $u32 {
    GROUP1:4 // at 28: FlexBus Signal Group 1 Multiplex control
    GROUP2:4 // at 24: FlexBus Signal Group 2 Multiplex control
    GROUP3:4 // at 20: FlexBus Signal Group 3 Multiplex control
    GROUP4:4 // at 16: FlexBus Signal Group 4 Multiplex control
    GROUP5:4 // at 12: FlexBus Signal Group 5 Multiplex control
    12
  }

}

//------------------------------------------------------------------------------
// Peripheral FMC: Flash Memory Controller
//------------------------------------------------------------------------------

registers ©FMC @at 0x4001f000 {
//---  Register PFAPR: Flash Access Protection Register
  PFAPR @offset 0x0 $u32 {
    8
    M7PFD // at 23: Master 7 Prefetch Disable
    M6PFD // at 22: Master 6 Prefetch Disable
    M5PFD // at 21: Master 5 Prefetch Disable
    M4PFD // at 20: Master 4 Prefetch Disable
    M3PFD // at 19: Master 3 Prefetch Disable
    M2PFD // at 18: Master 2 Prefetch Disable
    M1PFD // at 17: Master 1 Prefetch Disable
    M0PFD // at 16: Master 0 Prefetch Disable
    M7AP:2 // at 14: Master 7 Access Protection
    M6AP:2 // at 12: Master 6 Access Protection
    M5AP:2 // at 10: Master 5 Access Protection
    M4AP:2 // at 8: Master 4 Access Protection
    M3AP:2 // at 6: Master 3 Access Protection
    M2AP:2 // at 4: Master 2 Access Protection
    M1AP:2 // at 2: Master 1 Access Protection
    M0AP:2 // at 0: Master 0 Access Protection
  }

//---  Register PFB0CR: Flash Bank 0 Control Register
  PFB0CR @offset 0x4 $u32 {
    B0RWSC:4 // at 28: Bank 0 Read Wait State Control
    CLCK_WAY:4 // at 24: Cache Lock Way x
    CINV_WAY:4 // at 20: Cache Invalidate Way x
    S_B_INV // at 19: Invalidate Prefetch Speculation Buffer
    B0MW:2 // at 17: Bank 0 Memory Width
    9
    CRC:3 // at 5: Cache Replacement Control
    B0DCE // at 4: Bank 0 Data Cache Enable
    B0ICE // at 3: Bank 0 Instruction Cache Enable
    B0DPE // at 2: Bank 0 Data Prefetch Enable
    B0IPE // at 1: Bank 0 Instruction Prefetch Enable
    B0SEBE // at 0: Bank 0 Single Entry Buffer Enable
  }

//---  Register PFB1CR: Flash Bank 1 Control Register
  PFB1CR @offset 0x8 $u32 {
    B1RWSC:4 // at 28: Bank 1 Read Wait State Control
    9
    B1MW:2 // at 17: Bank 1 Memory Width
    12
    B1DCE // at 4: Bank 1 Data Cache Enable
    B1ICE // at 3: Bank 1 Instruction Cache Enable
    B1DPE // at 2: Bank 1 Data Prefetch Enable
    B1IPE // at 1: Bank 1 Instruction Prefetch Enable
    B1SEBE // at 0: Bank 1 Single Entry Buffer Enable
  }

//---  Registers TAGVDW0S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW0S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x100 + (idx) * 0x4)))
  #define FMC_TAGVDW0S0 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 0 * 0x4)))
  #define FMC_TAGVDW0S1 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 1 * 0x4)))
  #define FMC_TAGVDW0S2 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 2 * 0x4)))
  #define FMC_TAGVDW0S3 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 3 * 0x4)))
 {
    13
    tag:14 // at 5: 14-bit tag for cache entry
    4
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW1S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW1S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x110 + (idx) * 0x4)))
  #define FMC_TAGVDW1S0 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 0 * 0x4)))
  #define FMC_TAGVDW1S1 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 1 * 0x4)))
  #define FMC_TAGVDW1S2 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 2 * 0x4)))
  #define FMC_TAGVDW1S3 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 3 * 0x4)))
 {
    13
    tag:14 // at 5: 14-bit tag for cache entry
    4
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW2S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW2S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x120 + (idx) * 0x4)))
  #define FMC_TAGVDW2S0 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 0 * 0x4)))
  #define FMC_TAGVDW2S1 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 1 * 0x4)))
  #define FMC_TAGVDW2S2 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 2 * 0x4)))
  #define FMC_TAGVDW2S3 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 3 * 0x4)))
 {
    13
    tag:14 // at 5: 14-bit tag for cache entry
    4
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW3S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW3S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x130 + (idx) * 0x4)))
  #define FMC_TAGVDW3S0 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 0 * 0x4)))
  #define FMC_TAGVDW3S1 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 1 * 0x4)))
  #define FMC_TAGVDW3S2 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 2 * 0x4)))
  #define FMC_TAGVDW3S3 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 3 * 0x4)))
 {
    13
    tag:14 // at 5: 14-bit tag for cache entry
    4
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers DATAW0SU(0,1,2,3): Cache Data Storage (upper word)
  #define FMC_DATAW0SU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x200 + (idx) * 0x8)))
  #define FMC_DATAW0S0U (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 0 * 0x8)))
  #define FMC_DATAW0S1U (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 1 * 0x8)))
  #define FMC_DATAW0S2U (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 2 * 0x8)))
  #define FMC_DATAW0S3U (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW0SL(0,1,2,3): Cache Data Storage (lower word)
  #define FMC_DATAW0SL(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x204 + (idx) * 0x8)))
  #define FMC_DATAW0S0L (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 0 * 0x8)))
  #define FMC_DATAW0S1L (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 1 * 0x8)))
  #define FMC_DATAW0S2L (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 2 * 0x8)))
  #define FMC_DATAW0S3L (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW1SU(0,1,2,3): Cache Data Storage (upper word)
  #define FMC_DATAW1SU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x220 + (idx) * 0x8)))
  #define FMC_DATAW1S0U (* ((volatile uint32_t *) (0x4001f000 + 0x220 + 0 * 0x8)))
  #define FMC_DATAW1S1U (* ((volatile uint32_t *) (0x4001f000 + 0x220 + 1 * 0x8)))
  #define FMC_DATAW1S2U (* ((volatile uint32_t *) (0x4001f000 + 0x220 + 2 * 0x8)))
  #define FMC_DATAW1S3U (* ((volatile uint32_t *) (0x4001f000 + 0x220 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW1SL(0,1,2,3): Cache Data Storage (lower word)
  #define FMC_DATAW1SL(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x224 + (idx) * 0x8)))
  #define FMC_DATAW1S0L (* ((volatile uint32_t *) (0x4001f000 + 0x224 + 0 * 0x8)))
  #define FMC_DATAW1S1L (* ((volatile uint32_t *) (0x4001f000 + 0x224 + 1 * 0x8)))
  #define FMC_DATAW1S2L (* ((volatile uint32_t *) (0x4001f000 + 0x224 + 2 * 0x8)))
  #define FMC_DATAW1S3L (* ((volatile uint32_t *) (0x4001f000 + 0x224 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW2SU(0,1,2,3): Cache Data Storage (upper word)
  #define FMC_DATAW2SU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x240 + (idx) * 0x8)))
  #define FMC_DATAW2S0U (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 0 * 0x8)))
  #define FMC_DATAW2S1U (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 1 * 0x8)))
  #define FMC_DATAW2S2U (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 2 * 0x8)))
  #define FMC_DATAW2S3U (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW2SL(0,1,2,3): Cache Data Storage (lower word)
  #define FMC_DATAW2SL(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x244 + (idx) * 0x8)))
  #define FMC_DATAW2S0L (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 0 * 0x8)))
  #define FMC_DATAW2S1L (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 1 * 0x8)))
  #define FMC_DATAW2S2L (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 2 * 0x8)))
  #define FMC_DATAW2S3L (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW3SU(0,1,2,3): Cache Data Storage (upper word)
  #define FMC_DATAW3SU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x260 + (idx) * 0x8)))
  #define FMC_DATAW3S0U (* ((volatile uint32_t *) (0x4001f000 + 0x260 + 0 * 0x8)))
  #define FMC_DATAW3S1U (* ((volatile uint32_t *) (0x4001f000 + 0x260 + 1 * 0x8)))
  #define FMC_DATAW3S2U (* ((volatile uint32_t *) (0x4001f000 + 0x260 + 2 * 0x8)))
  #define FMC_DATAW3S3U (* ((volatile uint32_t *) (0x4001f000 + 0x260 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW3SL(0,1,2,3): Cache Data Storage (lower word)
  #define FMC_DATAW3SL(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x264 + (idx) * 0x8)))
  #define FMC_DATAW3S0L (* ((volatile uint32_t *) (0x4001f000 + 0x264 + 0 * 0x8)))
  #define FMC_DATAW3S1L (* ((volatile uint32_t *) (0x4001f000 + 0x264 + 1 * 0x8)))
  #define FMC_DATAW3S2L (* ((volatile uint32_t *) (0x4001f000 + 0x264 + 2 * 0x8)))
  #define FMC_DATAW3S3L (* ((volatile uint32_t *) (0x4001f000 + 0x264 + 3 * 0x8)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

}

//------------------------------------------------------------------------------
// Peripheral FTFE: Flash Memory Interface
//------------------------------------------------------------------------------

registers ©FTFE @at 0x40020000 {
//---  Register FSTAT: Flash Status Register
  FSTAT @offset 0x0 $u8 {
    CCIF // at 7: Command Complete Interrupt Flag
    RDCOLERR // at 6: FTFE Read Collision Error Flag
    ACCERR // at 5: Flash Access Error Flag
    FPVIOL // at 4: Flash Protection Violation Flag
    3
    MGSTAT0 // at 0: Memory Controller Command Completion Status Flag
  }

//---  Register FCNFG: Flash Configuration Register
  FCNFG @offset 0x1 $u8 {
    CCIE // at 7: Command Complete Interrupt Enable
    RDCOLLIE // at 6: Read Collision Error Interrupt Enable
    ERSAREQ // at 5: Erase All Request
    ERSSUSP // at 4: Erase Suspend
    SWAP // at 3: Swap
    PFLSH // at 2: FTFE configuration
    RAMRDY // at 1: RAM Ready
    EEERDY // at 0: For devices with FlexNVM: This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
  }

//---  Register FSEC: Flash Security Register
  FSEC @offset 0x2 @ro $u8 {
    KEYEN:2 // at 6: Backdoor Key Security Enable
    MEEN:2 // at 4: Mass Erase Enable Bits
    FSLACC:2 // at 2: Freescale Failure Analysis Access Code
    SEC:2 // at 0: Flash Security
  }

//---  Register FOPT: Flash Option Register
  FOPT @offset 0x3 @ro $u8 {
    OPT:8 // at 0: Nonvolatile Option
  }

//---  Register FCCOB_0_3: Flash Common Command Object Registers (0 ... 3)
  FCCOB_0_3 @offset 0x4 $u32
//---  Register FCCOB_4_7: Flash Common Command Object Registers (4 ... 7)
  FCCOB_4_7 @offset 0x8 $u32
//---  Register FCCOB_8_11: Flash Common Command Object Registers (8 ... 11)
  FCCOB_8_11 @offset 0xc $u32
//---  Registers FPROT(3,2,1,0): Program Flash Protection Registers
  #define FTFE_FPROT(idx) (* ((volatile uint8_t *) (0x40020000 + 0x10 + (idx) * 0x1)))
  #define FTFE_FPROT3 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 0 * 0x1)))
  #define FTFE_FPROT2 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 1 * 0x1)))
  #define FTFE_FPROT1 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 2 * 0x1)))
  #define FTFE_FPROT0 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 3 * 0x1)))
 {
    PROT:8 // at 0: Program Flash Region Protect
  }

//---  Register FEPROT: EEPROM Protection Register
  FEPROT @offset 0x16 $u8 {
    EPROT:8 // at 0: EEPROM Region Protect
  }

//---  Register FDPROT: Data Flash Protection Register
  FDPROT @offset 0x17 $u8 {
    DPROT:8 // at 0: Data Flash Region Protect
  }

}

//------------------------------------------------------------------------------
// Peripheral FTFE_FlashConfig: Flash configuration field
//------------------------------------------------------------------------------

registers ©FTFE_FlashConfig @at 0x400 {
//---  Register BACKKEY3: Backdoor Comparison Key 3.
  BACKKEY3 @offset 0x0 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY2: Backdoor Comparison Key 2.
  BACKKEY2 @offset 0x1 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY1: Backdoor Comparison Key 1.
  BACKKEY1 @offset 0x2 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY0: Backdoor Comparison Key 0.
  BACKKEY0 @offset 0x3 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY7: Backdoor Comparison Key 7.
  BACKKEY7 @offset 0x4 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY6: Backdoor Comparison Key 6.
  BACKKEY6 @offset 0x5 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY5: Backdoor Comparison Key 5.
  BACKKEY5 @offset 0x6 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY4: Backdoor Comparison Key 4.
  BACKKEY4 @offset 0x7 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register FPROT3: Non-volatile P-Flash Protection 1 - Low Register
  FPROT3 @offset 0x8 @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT2: Non-volatile P-Flash Protection 1 - High Register
  FPROT2 @offset 0x9 @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT1: Non-volatile P-Flash Protection 0 - Low Register
  FPROT1 @offset 0xa @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT0: Non-volatile P-Flash Protection 0 - High Register
  FPROT0 @offset 0xb @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FSEC: Non-volatile Flash Security Register
  FSEC @offset 0xc @ro $u8 {
    KEYEN:2 // at 6: Backdoor Key Security Enable
    MEEN:2 // at 4: no description available
    FSLACC:2 // at 2: Freescale Failure Analysis Access Code
    SEC:2 // at 0: Flash Security
  }

//---  Register FOPT: Non-volatile Flash Option Register
  FOPT @offset 0xd @ro $u8 {
    6
    EZPORT_DIS // at 1: no description available
    LPBOOT // at 0: no description available
  }

//---  Register FEPROT: Non-volatile EERAM Protection Register
  FEPROT @offset 0xe @ro $u8 {
    EPROT:8 // at 0: no description available
  }

//---  Register FDPROT: Non-volatile D-Flash Protection Register
  FDPROT @offset 0xf @ro $u8 {
    DPROT:8 // at 0: D-Flash Region Protect
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©FTM [4]
//        FTM0 at 0x40038000
//        FTM1 at 0x40039000
//        FTM2 at 0x4003a000
//        FTM3 at 0x400b9000
//------------------------------------------------------------------------------

registers ©FTM [4 @at 0x40038000 0x40039000 0x4003a000 0x400b9000]
          ©FTM0 @at 0x40038000
          ©FTM1 @at 0x40039000
          ©FTM2 @at 0x4003a000
          ©FTM3 @at 0x400b9000
{
//---  Register SC: Status And Control
  SC @offset 0x0 $u32 {
    24
    TOF // at 7: Timer Overflow Flag
    TOIE // at 6: Timer Overflow Interrupt Enable
    CPWMS // at 5: Center-Aligned PWM Select
    CLKS:2 // at 3: Clock Source Selection
    PS:3 // at 0: Prescale Factor Selection
  }

//---  Register CNT: Counter
  CNT @offset 0x4 $u32 {
    16
    COUNT:16 // at 0: Counter Value
  }

//---  Register MOD: Modulo
  MOD @offset 0x8 $u32 {
    16
    MOD:16 // at 0: Modulo Value
  }

//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status And Control
  C0SC @offset 0xc $u32
  C1SC @offset 0x14 $u32
  C2SC @offset 0x1c $u32
  C3SC @offset 0x24 $u32
  C4SC @offset 0x2c $u32
  C5SC @offset 0x34 $u32
  C6SC @offset 0x3c $u32
  C7SC @offset 0x44 $u32 {
    24
    CHF // at 7: Channel Flag
    CHIE // at 6: Channel Interrupt Enable
    MSB // at 5: Channel Mode Select
    MSA // at 4: Channel Mode Select
    ELSB // at 3: Edge or Level Select
    ELSA // at 2: Edge or Level Select
    1
    DMA // at 0: DMA Enable
  }

//---  Registers CV(0,1,2,3,4,5,6,7): Channel (n) Value
  C0V @offset 0x10 $u32
  C1V @offset 0x18 $u32
  C2V @offset 0x20 $u32
  C3V @offset 0x28 $u32
  C4V @offset 0x30 $u32
  C5V @offset 0x38 $u32
  C6V @offset 0x40 $u32
  C7V @offset 0x48 $u32 {
    16
    VAL:16 // at 0: Channel Value
  }

//---  Register CNTIN: Counter Initial Value
  CNTIN @offset 0x4c $u32 {
    16
    INIT:16 // at 0: Initial Value Of The FTM Counter
  }

//---  Register STATUS: Capture And Compare Status
  STATUS @offset 0x50 $u32 {
    24
    CH7F // at 7: Channel 7 Flag
    CH6F // at 6: Channel 6 Flag
    CH5F // at 5: Channel 5 Flag
    CH4F // at 4: Channel 4 Flag
    CH3F // at 3: Channel 3 Flag
    CH2F // at 2: Channel 2 Flag
    CH1F // at 1: Channel 1 Flag
    CH0F // at 0: Channel 0 Flag
  }

//---  Register MODE: Features Mode Selection
  MODE @offset 0x54 $u32 {
    24
    FAULTIE // at 7: Fault Interrupt Enable
    FAULTM:2 // at 5: Fault Control Mode
    CAPTEST // at 4: Capture Test Mode Enable
    PWMSYNC // at 3: PWM Synchronization Mode
    WPDIS // at 2: Write Protection Disable
    INIT // at 1: Initialize The Channels Output
    FTMEN // at 0: FTM Enable
  }

//---  Register SYNC: Synchronization
  SYNC @offset 0x58 $u32 {
    24
    SWSYNC // at 7: PWM Synchronization Software Trigger
    TRIG2 // at 6: PWM Synchronization Hardware Trigger 2
    TRIG1 // at 5: PWM Synchronization Hardware Trigger 1
    TRIG0 // at 4: PWM Synchronization Hardware Trigger 0
    SYNCHOM // at 3: Output Mask Synchronization
    REINIT // at 2: FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
    CNTMAX // at 1: Maximum Loading Point Enable
    CNTMIN // at 0: Minimum Loading Point Enable
  }

//---  Register OUTINIT: Initial State For Channels Output
  OUTINIT @offset 0x5c $u32 {
    24
    CH7OI // at 7: Channel 7 Output Initialization Value
    CH6OI // at 6: Channel 6 Output Initialization Value
    CH5OI // at 5: Channel 5 Output Initialization Value
    CH4OI // at 4: Channel 4 Output Initialization Value
    CH3OI // at 3: Channel 3 Output Initialization Value
    CH2OI // at 2: Channel 2 Output Initialization Value
    CH1OI // at 1: Channel 1 Output Initialization Value
    CH0OI // at 0: Channel 0 Output Initialization Value
  }

//---  Register OUTMASK: Output Mask
  OUTMASK @offset 0x60 $u32 {
    24
    CH7OM // at 7: Channel 7 Output Mask
    CH6OM // at 6: Channel 6 Output Mask
    CH5OM // at 5: Channel 5 Output Mask
    CH4OM // at 4: Channel 4 Output Mask
    CH3OM // at 3: Channel 3 Output Mask
    CH2OM // at 2: Channel 2 Output Mask
    CH1OM // at 1: Channel 1 Output Mask
    CH0OM // at 0: Channel 0 Output Mask
  }

//---  Register COMBINE: Function For Linked Channels
  COMBINE @offset 0x64 $u32 {
    1
    FAULTEN3 // at 30: Fault Control Enable For n = 6
    SYNCEN3 // at 29: Synchronization Enable For n = 6
    DTEN3 // at 28: Deadtime Enable For n = 6
    DECAP3 // at 27: Dual Edge Capture Mode Captures For n = 6
    DECAPEN3 // at 26: Dual Edge Capture Mode Enable For n = 6
    COMP3 // at 25: Complement Of Channel (n) for n = 6
    COMBINE3 // at 24: Combine Channels For n = 6
    1
    FAULTEN2 // at 22: Fault Control Enable For n = 4
    SYNCEN2 // at 21: Synchronization Enable For n = 4
    DTEN2 // at 20: Deadtime Enable For n = 4
    DECAP2 // at 19: Dual Edge Capture Mode Captures For n = 4
    DECAPEN2 // at 18: Dual Edge Capture Mode Enable For n = 4
    COMP2 // at 17: Complement Of Channel (n) For n = 4
    COMBINE2 // at 16: Combine Channels For n = 4
    1
    FAULTEN1 // at 14: Fault Control Enable For n = 2
    SYNCEN1 // at 13: Synchronization Enable For n = 2
    DTEN1 // at 12: Deadtime Enable For n = 2
    DECAP1 // at 11: Dual Edge Capture Mode Captures For n = 2
    DECAPEN1 // at 10: Dual Edge Capture Mode Enable For n = 2
    COMP1 // at 9: Complement Of Channel (n) For n = 2
    COMBINE1 // at 8: Combine Channels For n = 2
    1
    FAULTEN0 // at 6: Fault Control Enable For n = 0
    SYNCEN0 // at 5: Synchronization Enable For n = 0
    DTEN0 // at 4: Deadtime Enable For n = 0
    DECAP0 // at 3: Dual Edge Capture Mode Captures For n = 0
    DECAPEN0 // at 2: Dual Edge Capture Mode Enable For n = 0
    COMP0 // at 1: Complement Of Channel (n) For n = 0
    COMBINE0 // at 0: Combine Channels For n = 0
  }

//---  Register DEADTIME: Deadtime Insertion Control
  DEADTIME @offset 0x68 $u32 {
    24
    DTPS:2 // at 6: Deadtime Prescaler Value
    DTVAL:6 // at 0: Deadtime Value
  }

//---  Register EXTTRIG: FTM External Trigger
  EXTTRIG @offset 0x6c $u32 {
    24
    TRIGF // at 7: Channel Trigger Flag
    INITTRIGEN // at 6: Initialization Trigger Enable
    CH1TRIG // at 5: Channel 1 Trigger Enable
    CH0TRIG // at 4: Channel 0 Trigger Enable
    CH5TRIG // at 3: Channel 5 Trigger Enable
    CH4TRIG // at 2: Channel 4 Trigger Enable
    CH3TRIG // at 1: Channel 3 Trigger Enable
    CH2TRIG // at 0: Channel 2 Trigger Enable
  }

//---  Register POL: Channels Polarity
  POL @offset 0x70 $u32 {
    24
    POL7 // at 7: Channel 7 Polarity
    POL6 // at 6: Channel 6 Polarity
    POL5 // at 5: Channel 5 Polarity
    POL4 // at 4: Channel 4 Polarity
    POL3 // at 3: Channel 3 Polarity
    POL2 // at 2: Channel 2 Polarity
    POL1 // at 1: Channel 1 Polarity
    POL0 // at 0: Channel 0 Polarity
  }

//---  Register FMS: Fault Mode Status
  FMS @offset 0x74 $u32 {
    24
    FAULTF // at 7: Fault Detection Flag
    WPEN // at 6: Write Protection Enable
    FAULTIN // at 5: Fault Inputs
    1
    FAULTF3 // at 3: Fault Detection Flag 3
    FAULTF2 // at 2: Fault Detection Flag 2
    FAULTF1 // at 1: Fault Detection Flag 1
    FAULTF0 // at 0: Fault Detection Flag 0
  }

//---  Register FILTER: Input Capture Filter Control
  FILTER @offset 0x78 $u32 {
    16
    CH3FVAL:4 // at 12: Channel 3 Input Filter
    CH2FVAL:4 // at 8: Channel 2 Input Filter
    CH1FVAL:4 // at 4: Channel 1 Input Filter
    CH0FVAL:4 // at 0: Channel 0 Input Filter
  }

//---  Register FLTCTRL: Fault Control
  FLTCTRL @offset 0x7c $u32 {
    20
    FFVAL:4 // at 8: Fault Input Filter
    FFLTR3EN // at 7: Fault Input 3 Filter Enable
    FFLTR2EN // at 6: Fault Input 2 Filter Enable
    FFLTR1EN // at 5: Fault Input 1 Filter Enable
    FFLTR0EN // at 4: Fault Input 0 Filter Enable
    FAULT3EN // at 3: Fault Input 3 Enable
    FAULT2EN // at 2: Fault Input 2 Enable
    FAULT1EN // at 1: Fault Input 1 Enable
    FAULT0EN // at 0: Fault Input 0 Enable
  }

//---  Register QDCTRL: Quadrature Decoder Control And Status
  QDCTRL @offset 0x80 $u32 {
    24
    PHAFLTREN // at 7: Phase A Input Filter Enable
    PHBFLTREN // at 6: Phase B Input Filter Enable
    PHAPOL // at 5: Phase A Input Polarity
    PHBPOL // at 4: Phase B Input Polarity
    QUADMODE // at 3: Quadrature Decoder Mode
    QUADIR // at 2: FTM Counter Direction In Quadrature Decoder Mode
    TOFDIR // at 1: Timer Overflow Direction In Quadrature Decoder Mode
    QUADEN // at 0: Quadrature Decoder Mode Enable
  }

//---  Register CONF: Configuration
  CONF @offset 0x84 $u32 {
    21
    GTBEOUT // at 10: Global Time Base Output
    GTBEEN // at 9: Global Time Base Enable
    1
    BDMMODE:2 // at 6: BDM Mode
    1
    NUMTOF:5 // at 0: TOF Frequency
  }

//---  Register FLTPOL: FTM Fault Input Polarity
  FLTPOL @offset 0x88 $u32 {
    28
    FLT3POL // at 3: Fault Input 3 Polarity
    FLT2POL // at 2: Fault Input 2 Polarity
    FLT1POL // at 1: Fault Input 1 Polarity
    FLT0POL // at 0: Fault Input 0 Polarity
  }

//---  Register SYNCONF: Synchronization Configuration
  SYNCONF @offset 0x8c $u32 {
    11
    HWSOC // at 20: Software output control synchronization is activated by a hardware trigger.
    HWINVC // at 19: Inverting control synchronization is activated by a hardware trigger.
    HWOM // at 18: Output mask synchronization is activated by a hardware trigger.
    HWWRBUF // at 17: MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
    HWRSTCNT // at 16: FTM counter synchronization is activated by a hardware trigger.
    3
    SWSOC // at 12: Software output control synchronization is activated by the software trigger.
    SWINVC // at 11: Inverting control synchronization is activated by the software trigger.
    SWOM // at 10: Output mask synchronization is activated by the software trigger.
    SWWRBUF // at 9: MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
    SWRSTCNT // at 8: FTM counter synchronization is activated by the software trigger.
    SYNCMODE // at 7: Synchronization Mode
    1
    SWOC // at 5: SWOCTRL Register Synchronization
    INVC // at 4: INVCTRL Register Synchronization
    1
    CNTINC // at 2: CNTIN Register Synchronization
    1
    HWTRIGMODE // at 0: Hardware Trigger Mode
  }

//---  Register INVCTRL: FTM Inverting Control
  INVCTRL @offset 0x90 $u32 {
    28
    INV3EN // at 3: Pair Channels 3 Inverting Enable
    INV2EN // at 2: Pair Channels 2 Inverting Enable
    INV1EN // at 1: Pair Channels 1 Inverting Enable
    INV0EN // at 0: Pair Channels 0 Inverting Enable
  }

//---  Register SWOCTRL: FTM Software Output Control
  SWOCTRL @offset 0x94 $u32 {
    16
    CH7OCV // at 15: Channel 7 Software Output Control Value
    CH6OCV // at 14: Channel 6 Software Output Control Value
    CH5OCV // at 13: Channel 5 Software Output Control Value
    CH4OCV // at 12: Channel 4 Software Output Control Value
    CH3OCV // at 11: Channel 3 Software Output Control Value
    CH2OCV // at 10: Channel 2 Software Output Control Value
    CH1OCV // at 9: Channel 1 Software Output Control Value
    CH0OCV // at 8: Channel 0 Software Output Control Value
    CH7OC // at 7: Channel 7 Software Output Control Enable
    CH6OC // at 6: Channel 6 Software Output Control Enable
    CH5OC // at 5: Channel 5 Software Output Control Enable
    CH4OC // at 4: Channel 4 Software Output Control Enable
    CH3OC // at 3: Channel 3 Software Output Control Enable
    CH2OC // at 2: Channel 2 Software Output Control Enable
    CH1OC // at 1: Channel 1 Software Output Control Enable
    CH0OC // at 0: Channel 0 Software Output Control Enable
  }

//---  Register PWMLOAD: FTM PWM Load
  PWMLOAD @offset 0x98 $u32 {
    22
    LDOK // at 9: Load Enable
    1
    CH7SEL // at 7: Channel 7 Select
    CH6SEL // at 6: Channel 6 Select
    CH5SEL // at 5: Channel 5 Select
    CH4SEL // at 4: Channel 4 Select
    CH3SEL // at 3: Channel 3 Select
    CH2SEL // at 2: Channel 2 Select
    CH1SEL // at 1: Channel 1 Select
    CH0SEL // at 0: Channel 0 Select
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©GPIO [5]
//        GPIOA at 0x400ff000
//        GPIOB at 0x400ff040
//        GPIOC at 0x400ff080
//        GPIOD at 0x400ff0c0
//        GPIOE at 0x400ff100
//------------------------------------------------------------------------------

registers ©GPIO [5 @at 0x400ff000 0x400ff040 0x400ff080 0x400ff0c0 0x400ff100]
          ©GPIOA @at 0x400ff000
          ©GPIOB @at 0x400ff040
          ©GPIOC @at 0x400ff080
          ©GPIOD @at 0x400ff0c0
          ©GPIOE @at 0x400ff100
{
//---  Register PDOR: Port Data Output Register
  PDOR @offset 0x0 $u32 {
    PDO:32 // at 0: Port Data Output
  }

//---  Register PSOR: Port Set Output Register
  PSOR @offset 0x4 $u32 {
    PTSO:32 // at 0: Port Set Output
  }

//---  Register PCOR: Port Clear Output Register
  PCOR @offset 0x8 $u32 {
    PTCO:32 // at 0: Port Clear Output
  }

//---  Register PTOR: Port Toggle Output Register
  PTOR @offset 0xc $u32 {
    PTTO:32 // at 0: Port Toggle Output
  }

//---  Register PDIR: Port Data Input Register
  PDIR @offset 0x10 @ro $u32 {
    PDI:32 // at 0: Port Data Input
  }

//---  Register PDDR: Port Data Direction Register
  PDDR @offset 0x14 $u32 {
    PDD:32 // at 0: Port Data Direction
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©I2C [3]
//        I2C0 at 0x40066000
//        I2C1 at 0x40067000
//        I2C2 at 0x400e6000
//------------------------------------------------------------------------------

registers ©I2C [3 @at 0x40066000 0x40067000 0x400e6000]
          ©I2C0 @at 0x40066000
          ©I2C1 @at 0x40067000
          ©I2C2 @at 0x400e6000
{
//---  Register A1: I2C Address Register 1
  A1 @offset 0x0 $u8 {
    AD:7 // at 1: Address
    1
  }

//---  Register F: I2C Frequency Divider register
  F @offset 0x1 $u8 {
    MULT:2 // at 6: Multiplier Factor
    ICR:6 // at 0: ClockRate
  }

//---  Register C1: I2C Control Register 1
  C1 @offset 0x2 $u8 {
    IICEN // at 7: I2C Enable
    IICIE // at 6: I2C Interrupt Enable
    MST // at 5: Master Mode Select
    TX // at 4: Transmit Mode Select
    TXAK // at 3: Transmit Acknowledge Enable
    RSTA // at 2: Repeat START
    WUEN // at 1: Wakeup Enable
    DMAEN // at 0: DMA Enable
  }

//---  Register S: I2C Status register
  S @offset 0x3 $u8 {
    TCF // at 7: Transfer Complete Flag
    IAAS // at 6: Addressed As A Slave
    BUSY // at 5: Bus Busy
    ARBL // at 4: Arbitration Lost
    RAM // at 3: Range Address Match
    SRW // at 2: Slave Read/Write
    IICIF // at 1: Interrupt Flag
    RXAK // at 0: Receive Acknowledge
  }

//---  Register D: I2C Data I/O register
  D @offset 0x4 $u8 {
    DATA:8 // at 0: Data
  }

//---  Register C2: I2C Control Register 2
  C2 @offset 0x5 $u8 {
    GCAEN // at 7: General Call Address Enable
    ADEXT // at 6: Address Extension
    HDRS // at 5: High Drive Select
    SBRC // at 4: Slave Baud Rate Control
    RMEN // at 3: Range Address Matching Enable
    AD:3 // at 0: Slave Address
  }

//---  Register FLT: I2C Programmable Input Glitch Filter register
  FLT @offset 0x6 $u8 {
    SHEN // at 7: Stop Hold Enable
    STOPF // at 6: I2C Bus Stop Detect Flag
    SSIE // at 5: I2C Bus Stop or Start Interrupt Enable
    STARTF // at 4: I2C Bus Start Detect Flag
    FLT:4 // at 0: I2C Programmable Filter Factor
  }

//---  Register RA: I2C Range Address register
  RA @offset 0x7 $u8 {
    RAD:7 // at 1: Range Slave Address
    1
  }

//---  Register SMB: I2C SMBus Control and Status register
  SMB @offset 0x8 $u8 {
    FACK // at 7: Fast NACK/ACK Enable
    ALERTEN // at 6: SMBus Alert Response Address Enable
    SIICAEN // at 5: Second I2C Address Enable
    TCKSEL // at 4: Timeout Counter Clock Select
    SLTF // at 3: SCL Low Timeout Flag
    SHTF1 // at 2: SCL High Timeout Flag 1
    SHTF2 // at 1: SCL High Timeout Flag 2
    SHTF2IE // at 0: SHTF2 Interrupt Enable
  }

//---  Register A2: I2C Address Register 2
  A2 @offset 0x9 $u8 {
    SAD:7 // at 1: SMBus Address
    1
  }

//---  Register SLTH: I2C SCL Low Timeout Register High
  SLTH @offset 0xa $u8 {
    SSLT:8 // at 0: Most significant byte of SCL low timeout value that determines the timeout period of SCL low.
  }

//---  Register SLTL: I2C SCL Low Timeout Register Low
  SLTL @offset 0xb $u8 {
    SSLT:8 // at 0: Least significant byte of SCL low timeout value that determines the timeout period of SCL low.
  }

}

//------------------------------------------------------------------------------
// Peripheral I2S0: Inter-IC Sound / Synchronous Audio Interface
//------------------------------------------------------------------------------

registers ©I2S0 @at 0x4002f000 {
//---  Register TCSR: SAI Transmit Control Register
  TCSR @offset 0x0 $u32 {
    TE // at 31: Transmitter Enable
    STOPE // at 30: Stop Enable
    DBGE // at 29: Debug Enable
    BCE // at 28: Bit Clock Enable
    2
    FR // at 25: FIFO Reset
    SR // at 24: Software Reset
    3
    WSF // at 20: Word Start Flag
    SEF // at 19: Sync Error Flag
    FEF // at 18: FIFO Error Flag
    FWF // at 17: FIFO Warning Flag
    FRF // at 16: FIFO Request Flag
    3
    WSIE // at 12: Word Start Interrupt Enable
    SEIE // at 11: Sync Error Interrupt Enable
    FEIE // at 10: FIFO Error Interrupt Enable
    FWIE // at 9: FIFO Warning Interrupt Enable
    FRIE // at 8: FIFO Request Interrupt Enable
    6
    FWDE // at 1: FIFO Warning DMA Enable
    FRDE // at 0: FIFO Request DMA Enable
  }

//---  Register TCR1: SAI Transmit Configuration 1 Register
  TCR1 @offset 0x4 $u32 {
    29
    TFW:3 // at 0: Transmit FIFO Watermark
  }

//---  Register TCR2: SAI Transmit Configuration 2 Register
  TCR2 @offset 0x8 $u32 {
    SYNC:2 // at 30: Synchronous Mode
    BCS // at 29: Bit Clock Swap
    BCI // at 28: Bit Clock Input
    MSEL:2 // at 26: MCLK Select
    BCP // at 25: Bit Clock Polarity
    BCD // at 24: Bit Clock Direction
    16
    DIV:8 // at 0: Bit Clock Divide
  }

//---  Register TCR3: SAI Transmit Configuration 3 Register
  TCR3 @offset 0xc $u32 {
    14
    TCE:2 // at 16: Transmit Channel Enable
    11
    WDFL:5 // at 0: Word Flag Configuration
  }

//---  Register TCR4: SAI Transmit Configuration 4 Register
  TCR4 @offset 0x10 $u32 {
    11
    FRSZ:5 // at 16: Frame size
    3
    SYWD:5 // at 8: Sync Width
    3
    MF // at 4: MSB First
    FSE // at 3: Frame Sync Early
    1
    FSP // at 1: Frame Sync Polarity
    FSD // at 0: Frame Sync Direction
  }

//---  Register TCR5: SAI Transmit Configuration 5 Register
  TCR5 @offset 0x14 $u32 {
    3
    WNW:5 // at 24: Word N Width
    3
    W0W:5 // at 16: Word 0 Width
    3
    FBT:5 // at 8: First Bit Shifted
    8
  }

//---  Registers TDR(0,1): SAI Transmit Data Register
  #define I2S0_TDR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0x20 + (idx) * 0x4)))
  #define I2S0_TDR0 (* ((volatile uint32_t *) (0x4002f000 + 0x20 + 0 * 0x4)))
  #define I2S0_TDR1 (* ((volatile uint32_t *) (0x4002f000 + 0x20 + 1 * 0x4)))
 {
    TDR:32 // at 0: Transmit Data Register
  }

//---  Registers TFR(0,1): SAI Transmit FIFO Register
  #define I2S0_TFR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0x40 + (idx) * 0x4)))
  #define I2S0_TFR0 (* ((const volatile uint32_t *) (0x4002f000 + 0x40 + 0 * 0x4)))
  #define I2S0_TFR1 (* ((const volatile uint32_t *) (0x4002f000 + 0x40 + 1 * 0x4)))
 {
    12
    WFP:4 // at 16: Write FIFO Pointer
    12
    RFP:4 // at 0: Read FIFO Pointer
  }

//---  Register TMR: SAI Transmit Mask Register
  TMR @offset 0x60 $u32 {
    TWM:32 // at 0: Transmit Word Mask
  }

//---  Register RCSR: SAI Receive Control Register
  RCSR @offset 0x80 $u32 {
    RE // at 31: Receiver Enable
    STOPE // at 30: Stop Enable
    DBGE // at 29: Debug Enable
    BCE // at 28: Bit Clock Enable
    2
    FR // at 25: FIFO Reset
    SR // at 24: Software Reset
    3
    WSF // at 20: Word Start Flag
    SEF // at 19: Sync Error Flag
    FEF // at 18: FIFO Error Flag
    FWF // at 17: FIFO Warning Flag
    FRF // at 16: FIFO Request Flag
    3
    WSIE // at 12: Word Start Interrupt Enable
    SEIE // at 11: Sync Error Interrupt Enable
    FEIE // at 10: FIFO Error Interrupt Enable
    FWIE // at 9: FIFO Warning Interrupt Enable
    FRIE // at 8: FIFO Request Interrupt Enable
    6
    FWDE // at 1: FIFO Warning DMA Enable
    FRDE // at 0: FIFO Request DMA Enable
  }

//---  Register RCR1: SAI Receive Configuration 1 Register
  RCR1 @offset 0x84 $u32 {
    29
    RFW:3 // at 0: Receive FIFO Watermark
  }

//---  Register RCR2: SAI Receive Configuration 2 Register
  RCR2 @offset 0x88 $u32 {
    SYNC:2 // at 30: Synchronous Mode
    BCS // at 29: Bit Clock Swap
    BCI // at 28: Bit Clock Input
    MSEL:2 // at 26: MCLK Select
    BCP // at 25: Bit Clock Polarity
    BCD // at 24: Bit Clock Direction
    16
    DIV:8 // at 0: Bit Clock Divide
  }

//---  Register RCR3: SAI Receive Configuration 3 Register
  RCR3 @offset 0x8c $u32 {
    14
    RCE:2 // at 16: Receive Channel Enable
    11
    WDFL:5 // at 0: Word Flag Configuration
  }

//---  Register RCR4: SAI Receive Configuration 4 Register
  RCR4 @offset 0x90 $u32 {
    11
    FRSZ:5 // at 16: Frame Size
    3
    SYWD:5 // at 8: Sync Width
    3
    MF // at 4: MSB First
    FSE // at 3: Frame Sync Early
    1
    FSP // at 1: Frame Sync Polarity
    FSD // at 0: Frame Sync Direction
  }

//---  Register RCR5: SAI Receive Configuration 5 Register
  RCR5 @offset 0x94 $u32 {
    3
    WNW:5 // at 24: Word N Width
    3
    W0W:5 // at 16: Word 0 Width
    3
    FBT:5 // at 8: First Bit Shifted
    8
  }

//---  Registers RDR(0,1): SAI Receive Data Register
  #define I2S0_RDR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0xa0 + (idx) * 0x4)))
  #define I2S0_RDR0 (* ((const volatile uint32_t *) (0x4002f000 + 0xa0 + 0 * 0x4)))
  #define I2S0_RDR1 (* ((const volatile uint32_t *) (0x4002f000 + 0xa0 + 1 * 0x4)))
 {
    RDR:32 // at 0: Receive Data Register
  }

//---  Registers RFR(0,1): SAI Receive FIFO Register
  #define I2S0_RFR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0xc0 + (idx) * 0x4)))
  #define I2S0_RFR0 (* ((const volatile uint32_t *) (0x4002f000 + 0xc0 + 0 * 0x4)))
  #define I2S0_RFR1 (* ((const volatile uint32_t *) (0x4002f000 + 0xc0 + 1 * 0x4)))
 {
    12
    WFP:4 // at 16: Write FIFO Pointer
    12
    RFP:4 // at 0: Read FIFO Pointer
  }

//---  Register RMR: SAI Receive Mask Register
  RMR @offset 0xe0 $u32 {
    RWM:32 // at 0: Receive Word Mask
  }

//---  Register MCR: SAI MCLK Control Register
  MCR @offset 0x100 $u32 {
    DUF // at 31: Divider Update Flag
    MOE // at 30: MCLK Output Enable
    4
    MICS:2 // at 24: MCLK Input Clock Select
    24
  }

//---  Register MDR: SAI MCLK Divide Register
  MDR @offset 0x104 $u32 {
    12
    FRACT:8 // at 12: MCLK Fraction
    DIVIDE:12 // at 0: MCLK Divide
  }

}

//------------------------------------------------------------------------------
// Peripheral LLWU: Low leakage wakeup unit
//------------------------------------------------------------------------------

registers ©LLWU @at 0x4007c000 {
//---  Register PE1: LLWU Pin Enable 1 register
  PE1 @offset 0x0 $u8 {
    WUPE3:2 // at 6: Wakeup Pin Enable For LLWU_P3
    WUPE2:2 // at 4: Wakeup Pin Enable For LLWU_P2
    WUPE1:2 // at 2: Wakeup Pin Enable For LLWU_P1
    WUPE0:2 // at 0: Wakeup Pin Enable For LLWU_P0
  }

//---  Register PE2: LLWU Pin Enable 2 register
  PE2 @offset 0x1 $u8 {
    WUPE7:2 // at 6: Wakeup Pin Enable For LLWU_P7
    WUPE6:2 // at 4: Wakeup Pin Enable For LLWU_P6
    WUPE5:2 // at 2: Wakeup Pin Enable For LLWU_P5
    WUPE4:2 // at 0: Wakeup Pin Enable For LLWU_P4
  }

//---  Register PE3: LLWU Pin Enable 3 register
  PE3 @offset 0x2 $u8 {
    WUPE11:2 // at 6: Wakeup Pin Enable For LLWU_P11
    WUPE10:2 // at 4: Wakeup Pin Enable For LLWU_P10
    WUPE9:2 // at 2: Wakeup Pin Enable For LLWU_P9
    WUPE8:2 // at 0: Wakeup Pin Enable For LLWU_P8
  }

//---  Register PE4: LLWU Pin Enable 4 register
  PE4 @offset 0x3 $u8 {
    WUPE15:2 // at 6: Wakeup Pin Enable For LLWU_P15
    WUPE14:2 // at 4: Wakeup Pin Enable For LLWU_P14
    WUPE13:2 // at 2: Wakeup Pin Enable For LLWU_P13
    WUPE12:2 // at 0: Wakeup Pin Enable For LLWU_P12
  }

//---  Register ME: LLWU Module Enable register
  ME @offset 0x4 $u8 {
    WUME7 // at 7: Wakeup Module Enable For Module 7
    WUME6 // at 6: Wakeup Module Enable For Module 6
    WUME5 // at 5: Wakeup Module Enable For Module 5
    WUME4 // at 4: Wakeup Module Enable For Module 4
    WUME3 // at 3: Wakeup Module Enable For Module 3
    WUME2 // at 2: Wakeup Module Enable For Module 2
    WUME1 // at 1: Wakeup Module Enable for Module 1
    WUME0 // at 0: Wakeup Module Enable For Module 0
  }

//---  Register F1: LLWU Flag 1 register
  F1 @offset 0x5 $u8 {
    WUF7 // at 7: Wakeup Flag For LLWU_P7
    WUF6 // at 6: Wakeup Flag For LLWU_P6
    WUF5 // at 5: Wakeup Flag For LLWU_P5
    WUF4 // at 4: Wakeup Flag For LLWU_P4
    WUF3 // at 3: Wakeup Flag For LLWU_P3
    WUF2 // at 2: Wakeup Flag For LLWU_P2
    WUF1 // at 1: Wakeup Flag For LLWU_P1
    WUF0 // at 0: Wakeup Flag For LLWU_P0
  }

//---  Register F2: LLWU Flag 2 register
  F2 @offset 0x6 $u8 {
    WUF15 // at 7: Wakeup Flag For LLWU_P15
    WUF14 // at 6: Wakeup Flag For LLWU_P14
    WUF13 // at 5: Wakeup Flag For LLWU_P13
    WUF12 // at 4: Wakeup Flag For LLWU_P12
    WUF11 // at 3: Wakeup Flag For LLWU_P11
    WUF10 // at 2: Wakeup Flag For LLWU_P10
    WUF9 // at 1: Wakeup Flag For LLWU_P9
    WUF8 // at 0: Wakeup Flag For LLWU_P8
  }

//---  Register F3: LLWU Flag 3 register
  F3 @offset 0x7 @ro $u8 {
    MWUF7 // at 7: Wakeup flag For module 7
    MWUF6 // at 6: Wakeup flag For module 6
    MWUF5 // at 5: Wakeup flag For module 5
    MWUF4 // at 4: Wakeup flag For module 4
    MWUF3 // at 3: Wakeup flag For module 3
    MWUF2 // at 2: Wakeup flag For module 2
    MWUF1 // at 1: Wakeup flag For module 1
    MWUF0 // at 0: Wakeup flag For module 0
  }

//---  Register FILT1: LLWU Pin Filter 1 register
  FILT1 @offset 0x8 $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    1
    FILTSEL:4 // at 0: Filter Pin Select
  }

//---  Register FILT2: LLWU Pin Filter 2 register
  FILT2 @offset 0x9 $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    1
    FILTSEL:4 // at 0: Filter Pin Select
  }

//---  Register RST: LLWU Reset Enable register
  RST @offset 0xa $u8 {
    6
    LLRSTE // at 1: Low-Leakage Mode RESET Enable
    RSTFILT // at 0: Digital Filter On RESET Pin
  }

}

//------------------------------------------------------------------------------
// Peripheral LPTMR0: Low Power Timer
//------------------------------------------------------------------------------

registers ©LPTMR0 @at 0x40040000 {
//---  Register CSR: Low Power Timer Control Status Register
  CSR @offset 0x0 $u32 {
    24
    TCF // at 7: Timer Compare Flag
    TIE // at 6: Timer Interrupt Enable
    TPS:2 // at 4: Timer Pin Select
    TPP // at 3: Timer Pin Polarity
    TFC // at 2: Timer Free-Running Counter
    TMS // at 1: Timer Mode Select
    TEN // at 0: Timer Enable
  }

//---  Register PSR: Low Power Timer Prescale Register
  PSR @offset 0x4 $u32 {
    25
    PRESCALE:4 // at 3: Prescale Value
    PBYP // at 2: Prescaler Bypass
    PCS:2 // at 0: Prescaler Clock Select
  }

//---  Register CMR: Low Power Timer Compare Register
  CMR @offset 0x8 $u32 {
    16
    COMPARE:16 // at 0: Compare Value
  }

//---  Register CNR: Low Power Timer Counter Register
  CNR @offset 0xc $u32 {
    16
    COUNTER:16 // at 0: Counter Value
  }

}

//------------------------------------------------------------------------------
// Peripheral MCG: Multipurpose Clock Generator module
//------------------------------------------------------------------------------

registers ©MCG @at 0x40064000 {
//---  Register C1: MCG Control 1 Register
  C1 @offset 0x0 $u8 {
    CLKS:2 // at 6: Clock Source Select
    FRDIV:3 // at 3: FLL External Reference Divider
    IREFS // at 2: Internal Reference Select
    IRCLKEN // at 1: Internal Reference Clock Enable
    IREFSTEN // at 0: Internal Reference Stop Enable
  }

//---  Register C2: MCG Control 2 Register
  C2 @offset 0x1 $u8 {
    LOCRE0 // at 7: Loss of Clock Reset Enable
    FCFTRIM // at 6: Fast Internal Reference Clock Fine Trim
    RANGE:2 // at 4: Frequency Range Select
    HGO // at 3: High Gain Oscillator Select
    EREFS // at 2: External Reference Select
    LP // at 1: Low Power Select
    IRCS // at 0: Internal Reference Clock Select
  }

//---  Register C3: MCG Control 3 Register
  C3 @offset 0x2 $u8 {
    SCTRIM:8 // at 0: Slow Internal Reference Clock Trim Setting
  }

//---  Register C4: MCG Control 4 Register
  C4 @offset 0x3 $u8 {
    DMX32 // at 7: DCO Maximum Frequency with 32.768 kHz Reference
    DRST_DRS:2 // at 5: DCO Range Select
    FCTRIM:4 // at 1: Fast Internal Reference Clock Trim Setting
    SCFTRIM // at 0: Slow Internal Reference Clock Fine Trim
  }

//---  Register C5: MCG Control 5 Register
  C5 @offset 0x4 $u8 {
    1
    PLLCLKEN0 // at 6: PLL Clock Enable
    PLLSTEN0 // at 5: PLL Stop Enable
    PRDIV0:5 // at 0: PLL External Reference Divider
  }

//---  Register C6: MCG Control 6 Register
  C6 @offset 0x5 $u8 {
    LOLIE0 // at 7: Loss of Lock Interrrupt Enable
    PLLS // at 6: PLL Select
    CME0 // at 5: Clock Monitor Enable
    VDIV0:5 // at 0: VCO 0 Divider
  }

//---  Register S: MCG Status Register
  S @offset 0x6 $u8 {
    LOLS0 // at 7: Loss of Lock Status
    LOCK0 // at 6: Lock Status
    PLLST // at 5: PLL Select Status
    IREFST // at 4: Internal Reference Status
    CLKST:2 // at 2: Clock Mode Status
    OSCINIT0 // at 1: OSC Initialization
    IRCST // at 0: Internal Reference Clock Status
  }

//---  Register SC: MCG Status and Control Register
  SC @offset 0x8 $u8 {
    ATME // at 7: Automatic Trim Machine Enable
    ATMS // at 6: Automatic Trim Machine Select
    ATMF // at 5: Automatic Trim Machine Fail Flag
    FLTPRSRV // at 4: FLL Filter Preserve Enable
    FCRDIV:3 // at 1: Fast Clock Internal Reference Divider
    LOCS0 // at 0: OSC0 Loss of Clock Status
  }

//---  Register ATCVH: MCG Auto Trim Compare Value High Register
  ATCVH @offset 0xa $u8 {
    ATCVH:8 // at 0: ATM Compare Value High
  }

//---  Register ATCVL: MCG Auto Trim Compare Value Low Register
  ATCVL @offset 0xb $u8 {
    ATCVL:8 // at 0: ATM Compare Value Low
  }

//---  Register C7: MCG Control 7 Register
  C7 @offset 0xc $u8 {
    6
    OSCSEL:2 // at 0: MCG OSC Clock Select
  }

//---  Register C8: MCG Control 8 Register
  C8 @offset 0xd $u8 {
    LOCRE1 // at 7: Loss of Clock Reset Enable
    LOLRE // at 6: PLL Loss of Lock Reset Enable
    CME1 // at 5: Clock Monitor Enable1
    4
    LOCS1 // at 0: RTC Loss of Clock Status
  }

}

//------------------------------------------------------------------------------
// Peripheral MCM: Core Platform Miscellaneous Control Module
//------------------------------------------------------------------------------

registers ©MCM @at 0xe0080000 {
//---  Register PLASC: Crossbar Switch (AXBS) Slave Configuration
  PLASC @offset 0x8 @ro $u16 {
    8
    ASC:8 // at 0: Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
  }

//---  Register PLAMC: Crossbar Switch (AXBS) Master Configuration
  PLAMC @offset 0xa @ro $u16 {
    8
    AMC:8 // at 0: Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
  }

//---  Register CR: Control Register
  CR @offset 0xc $u32 {
    1
    SRAMLWP // at 30: SRAM_L Write Protect
    SRAMLAP:2 // at 28: SRAM_L arbitration priority
    1
    SRAMUWP // at 26: SRAM_U write protect
    SRAMUAP:2 // at 24: SRAM_U arbitration priority
    24
  }

//---  Register ISCR: Interrupt Status Register
  ISCR @offset 0x10 $u32 {
    FIDCE // at 31: FPU input denormal interrupt enable
    2
    FIXCE // at 28: FPU inexact interrupt enable
    FUFCE // at 27: FPU underflow interrupt enable
    FOFCE // at 26: FPU overflow interrupt enable
    FDZCE // at 25: FPU divide-by-zero interrupt enable
    FIOCE // at 24: FPU invalid operation interrupt enable
    8
    FIDC // at 15: FPU input denormal interrupt status
    2
    FIXC // at 12: FPU inexact interrupt status
    FUFC // at 11: FPU underflow interrupt status
    FOFC // at 10: FPU overflow interrupt status
    FDZC // at 9: FPU divide-by-zero interrupt status
    FIOC // at 8: FPU invalid operation interrupt status
    4
    DHREQ // at 3: Debug Halt Request Indicator
    NMI // at 2: Non-maskable Interrupt Pending
    IRQ // at 1: Normal Interrupt Pending
    1
  }

//---  Register ETBCC: ETB Counter Control register
  ETBCC @offset 0x14 $u32 {
    26
    ITDIS // at 5: ITM-To-TPIU Disable
    ETDIS // at 4: ETM-To-TPIU Disable
    RLRQ // at 3: Reload Request
    RSPT:2 // at 1: Response Type
    CNTEN // at 0: Counter Enable
  }

//---  Register ETBRL: ETB Reload register
  ETBRL @offset 0x18 $u32 {
    21
    RELOAD:11 // at 0: Byte Count Reload Value
  }

//---  Register ETBCNT: ETB Counter Value register
  ETBCNT @offset 0x1c @ro $u32 {
    21
    COUNTER:11 // at 0: Byte Count Counter Value
  }

//---  Register PID: Process ID register
  PID @offset 0x30 $u32 {
    24
    PID:8 // at 0: M0_PID And M1_PID For MPU
  }

}

//------------------------------------------------------------------------------
// Peripheral MPU: Memory protection unit
//------------------------------------------------------------------------------

registers ©MPU @at 0x4000d000 {
//---  Register CESR: Control/Error Status Register
  CESR @offset 0x0 $u32 {
    SPERR:5 // at 27: Slave Port n Error
    7
    HRL:4 // at 16: Hardware Revision Level
    NSP:4 // at 12: Number Of Slave Ports
    NRGD:4 // at 8: Number Of Region Descriptors
    7
    VLD // at 0: Valid
  }

//---  Registers EAR(0,1,2,3,4): Error Address Register, slave port n
  #define MPU_EAR(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x10 + (idx) * 0x8)))
  #define MPU_EAR0 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 0 * 0x8)))
  #define MPU_EAR1 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 1 * 0x8)))
  #define MPU_EAR2 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 2 * 0x8)))
  #define MPU_EAR3 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 3 * 0x8)))
  #define MPU_EAR4 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 4 * 0x8)))
 {
    EADDR:32 // at 0: Error Address
  }

//---  Registers EDR(0,1,2,3,4): Error Detail Register, slave port n
  #define MPU_EDR(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x14 + (idx) * 0x8)))
  #define MPU_EDR0 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 0 * 0x8)))
  #define MPU_EDR1 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 1 * 0x8)))
  #define MPU_EDR2 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 2 * 0x8)))
  #define MPU_EDR3 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 3 * 0x8)))
  #define MPU_EDR4 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 4 * 0x8)))
 {
    EACD:16 // at 16: Error Access Control Detail
    EPID:8 // at 8: Error Process Identification
    EMN:4 // at 4: Error Master Number
    EATTR:3 // at 1: Error Attributes
    ERW // at 0: Error Read/Write
  }

//---  Registers RGD_WORD0(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 0
  #define MPU_RGD_WORD0(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x400 + (idx) * 0x10)))
  #define MPU_RGD0_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 0 * 0x10)))
  #define MPU_RGD1_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 1 * 0x10)))
  #define MPU_RGD2_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 2 * 0x10)))
  #define MPU_RGD3_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 3 * 0x10)))
  #define MPU_RGD4_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 4 * 0x10)))
  #define MPU_RGD5_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 5 * 0x10)))
  #define MPU_RGD6_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 6 * 0x10)))
  #define MPU_RGD7_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 7 * 0x10)))
  #define MPU_RGD8_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 8 * 0x10)))
  #define MPU_RGD9_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 9 * 0x10)))
  #define MPU_RGD10_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 10 * 0x10)))
  #define MPU_RGD11_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 11 * 0x10)))
 {
    SRTADDR:27 // at 5: Start Address
    5
  }

//---  Registers RGD_WORD1(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 1
  #define MPU_RGD_WORD1(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x404 + (idx) * 0x10)))
  #define MPU_RGD0_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 0 * 0x10)))
  #define MPU_RGD1_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 1 * 0x10)))
  #define MPU_RGD2_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 2 * 0x10)))
  #define MPU_RGD3_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 3 * 0x10)))
  #define MPU_RGD4_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 4 * 0x10)))
  #define MPU_RGD5_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 5 * 0x10)))
  #define MPU_RGD6_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 6 * 0x10)))
  #define MPU_RGD7_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 7 * 0x10)))
  #define MPU_RGD8_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 8 * 0x10)))
  #define MPU_RGD9_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 9 * 0x10)))
  #define MPU_RGD10_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 10 * 0x10)))
  #define MPU_RGD11_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 11 * 0x10)))
 {
    ENDADDR:27 // at 5: End Address
    5
  }

//---  Registers RGD_WORD2(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 2
  #define MPU_RGD_WORD2(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x408 + (idx) * 0x10)))
  #define MPU_RGD0_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 0 * 0x10)))
  #define MPU_RGD1_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 1 * 0x10)))
  #define MPU_RGD2_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 2 * 0x10)))
  #define MPU_RGD3_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 3 * 0x10)))
  #define MPU_RGD4_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 4 * 0x10)))
  #define MPU_RGD5_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 5 * 0x10)))
  #define MPU_RGD6_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 6 * 0x10)))
  #define MPU_RGD7_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 7 * 0x10)))
  #define MPU_RGD8_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 8 * 0x10)))
  #define MPU_RGD9_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 9 * 0x10)))
  #define MPU_RGD10_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 10 * 0x10)))
  #define MPU_RGD11_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 11 * 0x10)))
 {
    M7RE // at 31: Bus Master 7 Read Enable
    M7WE // at 30: Bus Master 7 Write Enable
    M6RE // at 29: Bus Master 6 Read Enable
    M6WE // at 28: Bus Master 6 Write Enable
    M5RE // at 27: Bus Master 5 Read Enable
    M5WE // at 26: Bus Master 5 Write Enable
    M4RE // at 25: Bus Master 4 Read Enable
    M4WE // at 24: Bus Master 4 Write Enable
    M3PE // at 23: Bus Master 3 Process Identifier Enable
    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control
    M3UM:3 // at 18: Bus Master 3 User Mode Access Control
    M2PE // at 17: Bus Master 2 Process Identifier Enable
    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control
    M2UM:3 // at 12: Bus Master 2 User Mode Access control
    M1PE // at 11: Bus Master 1 Process Identifier enable
    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control
    M1UM:3 // at 6: Bus Master 1 User Mode Access Control
    M0PE // at 5: Bus Master 0 Process Identifier enable
    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control
    M0UM:3 // at 0: Bus Master 0 User Mode Access Control
  }

//---  Registers RGD_WORD3(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 3
  #define MPU_RGD_WORD3(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x40c + (idx) * 0x10)))
  #define MPU_RGD0_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 0 * 0x10)))
  #define MPU_RGD1_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 1 * 0x10)))
  #define MPU_RGD2_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 2 * 0x10)))
  #define MPU_RGD3_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 3 * 0x10)))
  #define MPU_RGD4_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 4 * 0x10)))
  #define MPU_RGD5_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 5 * 0x10)))
  #define MPU_RGD6_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 6 * 0x10)))
  #define MPU_RGD7_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 7 * 0x10)))
  #define MPU_RGD8_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 8 * 0x10)))
  #define MPU_RGD9_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 9 * 0x10)))
  #define MPU_RGD10_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 10 * 0x10)))
  #define MPU_RGD11_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 11 * 0x10)))
 {
    PID:8 // at 24: Process Identifier
    PIDMASK:8 // at 16: Process Identifier Mask
    15
    VLD // at 0: Valid
  }

//---  Registers RGDAAC(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor Alternate Access Control n
  #define MPU_RGDAAC(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x800 + (idx) * 0x4)))
  #define MPU_RGDAAC0 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 0 * 0x4)))
  #define MPU_RGDAAC1 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 1 * 0x4)))
  #define MPU_RGDAAC2 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 2 * 0x4)))
  #define MPU_RGDAAC3 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 3 * 0x4)))
  #define MPU_RGDAAC4 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 4 * 0x4)))
  #define MPU_RGDAAC5 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 5 * 0x4)))
  #define MPU_RGDAAC6 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 6 * 0x4)))
  #define MPU_RGDAAC7 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 7 * 0x4)))
  #define MPU_RGDAAC8 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 8 * 0x4)))
  #define MPU_RGDAAC9 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 9 * 0x4)))
  #define MPU_RGDAAC10 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 10 * 0x4)))
  #define MPU_RGDAAC11 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 11 * 0x4)))
 {
    M7RE // at 31: Bus Master 7 Read Enable
    M7WE // at 30: Bus Master 7 Write Enable
    M6RE // at 29: Bus Master 6 Read Enable
    M6WE // at 28: Bus Master 6 Write Enable
    M5RE // at 27: Bus Master 5 Read Enable
    M5WE // at 26: Bus Master 5 Write Enable
    M4RE // at 25: Bus Master 4 Read Enable
    M4WE // at 24: Bus Master 4 Write Enable
    M3PE // at 23: Bus Master 3 Process Identifier Enable
    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control
    M3UM:3 // at 18: Bus Master 3 User Mode Access Control
    M2PE // at 17: Bus Master 2 Process Identifier Enable
    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control
    M2UM:3 // at 12: Bus Master 2 User Mode Access Control
    M1PE // at 11: Bus Master 1 Process Identifier Enable
    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control
    M1UM:3 // at 6: Bus Master 1 User Mode Access Control
    M0PE // at 5: Bus Master 0 Process Identifier Enable
    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control
    M0UM:3 // at 0: Bus Master 0 User Mode Access Control
  }

}

//------------------------------------------------------------------------------
// Peripheral OSC: Oscillator
//------------------------------------------------------------------------------

registers ©OSC @at 0x40065000 {
//---  Register CR: OSC Control Register
  CR @offset 0x0 $u8 {
    ERCLKEN // at 7: External Reference Enable
    1
    EREFSTEN // at 5: External Reference Stop Enable
    1
    SC2P // at 3: Oscillator 2 pF Capacitor Load Configure
    SC4P // at 2: Oscillator 4 pF Capacitor Load Configure
    SC8P // at 1: Oscillator 8 pF Capacitor Load Configure
    SC16P // at 0: Oscillator 16 pF Capacitor Load Configure
  }

}

//------------------------------------------------------------------------------
// Peripheral PDB0: Programmable Delay Block
//------------------------------------------------------------------------------

registers ©PDB0 @at 0x40036000 {
//---  Register SC: Status and Control register
  SC @offset 0x0 $u32 {
    12
    LDMOD:2 // at 18: Load Mode Select
    PDBEIE // at 17: PDB Sequence Error Interrupt Enable
    SWTRIG // at 16: Software Trigger
    DMAEN // at 15: DMA Enable
    PRESCALER:3 // at 12: Prescaler Divider Select
    TRGSEL:4 // at 8: Trigger Input Source Select
    PDBEN // at 7: PDB Enable
    PDBIF // at 6: PDB Interrupt Flag
    PDBIE // at 5: PDB Interrupt Enable
    1
    MULT:2 // at 2: Multiplication Factor Select for Prescaler
    CONT // at 1: Continuous Mode Enable
    LDOK // at 0: Load OK
  }

//---  Register MOD: Modulus register
  MOD @offset 0x4 $u32 {
    16
    MOD:16 // at 0: PDB Modulus
  }

//---  Register CNT: Counter register
  CNT @offset 0x8 @ro $u32 {
    16
    CNT:16 // at 0: PDB Counter
  }

//---  Register IDLY: Interrupt Delay register
  IDLY @offset 0xc $u32 {
    16
    IDLY:16 // at 0: PDB Interrupt Delay
  }

//---  Registers CHC1(0,1): Channel n Control register 1
  #define PDB0_CHC1(idx) (* ((volatile uint32_t *) (0x40036000 + 0x10 + (idx) * 0x28)))
  #define PDB0_CH0C1 (* ((volatile uint32_t *) (0x40036000 + 0x10 + 0 * 0x28)))
  #define PDB0_CH1C1 (* ((volatile uint32_t *) (0x40036000 + 0x10 + 1 * 0x28)))
 {
    8
    BB:8 // at 16: PDB Channel Pre-Trigger Back-to-Back Operation Enable
    TOS:8 // at 8: PDB Channel Pre-Trigger Output Select
    EN:8 // at 0: PDB Channel Pre-Trigger Enable
  }

//---  Registers CHS(0,1): Channel n Status register
  #define PDB0_CHS(idx) (* ((volatile uint32_t *) (0x40036000 + 0x14 + (idx) * 0x28)))
  #define PDB0_CH0S (* ((volatile uint32_t *) (0x40036000 + 0x14 + 0 * 0x28)))
  #define PDB0_CH1S (* ((volatile uint32_t *) (0x40036000 + 0x14 + 1 * 0x28)))
 {
    8
    CF:8 // at 16: PDB Channel Flags
    8
    ERR:8 // at 0: PDB Channel Sequence Error Flags
  }

//---  Registers CHDLY0(0,1): Channel n Delay 0 register
  #define PDB0_CHDLY0(idx) (* ((volatile uint32_t *) (0x40036000 + 0x18 + (idx) * 0x28)))
  #define PDB0_CH0DLY0 (* ((volatile uint32_t *) (0x40036000 + 0x18 + 0 * 0x28)))
  #define PDB0_CH1DLY0 (* ((volatile uint32_t *) (0x40036000 + 0x18 + 1 * 0x28)))
 {
    16
    DLY:16 // at 0: PDB Channel Delay
  }

//---  Registers CHDLY1(0,1): Channel n Delay 1 register
  #define PDB0_CHDLY1(idx) (* ((volatile uint32_t *) (0x40036000 + 0x1c + (idx) * 0x28)))
  #define PDB0_CH0DLY1 (* ((volatile uint32_t *) (0x40036000 + 0x1c + 0 * 0x28)))
  #define PDB0_CH1DLY1 (* ((volatile uint32_t *) (0x40036000 + 0x1c + 1 * 0x28)))
 {
    16
    DLY:16 // at 0: PDB Channel Delay
  }

//---  Registers DACINTC(0,1): DAC Interval Trigger n Control register
  #define PDB0_DACINTC(idx) (* ((volatile uint32_t *) (0x40036000 + 0x150 + (idx) * 0x8)))
  #define PDB0_DACINTC0 (* ((volatile uint32_t *) (0x40036000 + 0x150 + 0 * 0x8)))
  #define PDB0_DACINTC1 (* ((volatile uint32_t *) (0x40036000 + 0x150 + 1 * 0x8)))
 {
    30
    EXT // at 1: DAC External Trigger Input Enable
    TOE // at 0: DAC Interval Trigger Enable
  }

//---  Registers DACINT(0,1): DAC Interval n register
  #define PDB0_DACINT(idx) (* ((volatile uint32_t *) (0x40036000 + 0x154 + (idx) * 0x8)))
  #define PDB0_DACINT0 (* ((volatile uint32_t *) (0x40036000 + 0x154 + 0 * 0x8)))
  #define PDB0_DACINT1 (* ((volatile uint32_t *) (0x40036000 + 0x154 + 1 * 0x8)))
 {
    16
    INT:16 // at 0: DAC Interval
  }

//---  Register POEN: Pulse-Out n Enable register
  POEN @offset 0x190 $u32 {
    24
    POEN:8 // at 0: PDB Pulse-Out Enable
  }

//---  Registers PODLY(0,1,2): Pulse-Out n Delay register
  #define PDB0_PODLY(idx) (* ((volatile uint32_t *) (0x40036000 + 0x194 + (idx) * 0x4)))
  #define PDB0_PO0DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 0 * 0x4)))
  #define PDB0_PO1DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 1 * 0x4)))
  #define PDB0_PO2DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 2 * 0x4)))
 {
    DLY1:16 // at 16: PDB Pulse-Out Delay 1
    DLY2:16 // at 0: PDB Pulse-Out Delay 2
  }

}

//------------------------------------------------------------------------------
// Peripheral PIT: Periodic Interrupt Timer
//------------------------------------------------------------------------------

registers ©PIT @at 0x40037000 {
//---  Register MCR: PIT Module Control Register
  MCR @offset 0x0 $u32 {
    30
    MDIS // at 1: Module Disable - (PIT section)
    FRZ // at 0: Freeze
  }

//---  Registers LDVAL(0,1,2,3): Timer Load Value Register
  #define PIT_LDVAL(idx) (* ((volatile uint32_t *) (0x40037000 + 0x100 + (idx) * 0x10)))
  #define PIT_LDVAL0 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 0 * 0x10)))
  #define PIT_LDVAL1 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 1 * 0x10)))
  #define PIT_LDVAL2 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 2 * 0x10)))
  #define PIT_LDVAL3 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 3 * 0x10)))
 {
    TSV:32 // at 0: Timer Start Value
  }

//---  Registers CVAL(0,1,2,3): Current Timer Value Register
  #define PIT_CVAL(idx) (* ((volatile uint32_t *) (0x40037000 + 0x104 + (idx) * 0x10)))
  #define PIT_CVAL0 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 0 * 0x10)))
  #define PIT_CVAL1 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 1 * 0x10)))
  #define PIT_CVAL2 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 2 * 0x10)))
  #define PIT_CVAL3 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 3 * 0x10)))
 {
    TVL:32 // at 0: Current Timer Value
  }

//---  Registers TCTRL(0,1,2,3): Timer Control Register
  #define PIT_TCTRL(idx) (* ((volatile uint32_t *) (0x40037000 + 0x108 + (idx) * 0x10)))
  #define PIT_TCTRL0 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 0 * 0x10)))
  #define PIT_TCTRL1 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 1 * 0x10)))
  #define PIT_TCTRL2 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 2 * 0x10)))
  #define PIT_TCTRL3 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 3 * 0x10)))
 {
    29
    CHN // at 2: Chain Mode
    TIE // at 1: Timer Interrupt Enable
    TEN // at 0: Timer Enable
  }

//---  Registers TFLG(0,1,2,3): Timer Flag Register
  #define PIT_TFLG(idx) (* ((volatile uint32_t *) (0x40037000 + 0x10c + (idx) * 0x10)))
  #define PIT_TFLG0 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 0 * 0x10)))
  #define PIT_TFLG1 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 1 * 0x10)))
  #define PIT_TFLG2 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 2 * 0x10)))
  #define PIT_TFLG3 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 3 * 0x10)))
 {
    31
    TIF // at 0: Timer Interrupt Flag
  }

}

//------------------------------------------------------------------------------
// Peripheral PMC: Power Management Controller
//------------------------------------------------------------------------------

registers ©PMC @at 0x4007d000 {
//---  Register LVDSC1: Low Voltage Detect Status And Control 1 register
  LVDSC1 @offset 0x0 $u8 {
    LVDF // at 7: Low-Voltage Detect Flag
    LVDACK // at 6: Low-Voltage Detect Acknowledge
    LVDIE // at 5: Low-Voltage Detect Interrupt Enable
    LVDRE // at 4: Low-Voltage Detect Reset Enable
    2
    LVDV:2 // at 0: Low-Voltage Detect Voltage Select
  }

//---  Register LVDSC2: Low Voltage Detect Status And Control 2 register
  LVDSC2 @offset 0x1 $u8 {
    LVWF // at 7: Low-Voltage Warning Flag
    LVWACK // at 6: Low-Voltage Warning Acknowledge
    LVWIE // at 5: Low-Voltage Warning Interrupt Enable
    3
    LVWV:2 // at 0: Low-Voltage Warning Voltage Select
  }

//---  Register REGSC: Regulator Status And Control register
  REGSC @offset 0x2 $u8 {
    3
    BGEN // at 4: Bandgap Enable In VLPx Operation
    ACKISO // at 3: Acknowledge Isolation
    REGONS // at 2: Regulator In Run Regulation Status
    1
    BGBE // at 0: Bandgap Buffer Enable
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©PORT [5]
//        PORTA at 0x40049000
//        PORTB at 0x4004a000
//        PORTC at 0x4004b000
//        PORTD at 0x4004c000
//        PORTE at 0x4004d000
//------------------------------------------------------------------------------

registers ©PORT [5 @at 0x40049000 0x4004a000 0x4004b000 0x4004c000 0x4004d000]
          ©PORTA @at 0x40049000
          ©PORTB @at 0x4004a000
          ©PORTC @at 0x4004b000
          ©PORTD @at 0x4004c000
          ©PORTE @at 0x4004d000
{
//---  Registers PCR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Pin Control Register n
  PCR0 @offset 0x0 $u32
  PCR1 @offset 0x4 $u32
  PCR2 @offset 0x8 $u32
  PCR3 @offset 0xc $u32
  PCR4 @offset 0x10 $u32
  PCR5 @offset 0x14 $u32
  PCR6 @offset 0x18 $u32
  PCR7 @offset 0x1c $u32
  PCR8 @offset 0x20 $u32
  PCR9 @offset 0x24 $u32
  PCR10 @offset 0x28 $u32
  PCR11 @offset 0x2c $u32
  PCR12 @offset 0x30 $u32
  PCR13 @offset 0x34 $u32
  PCR14 @offset 0x38 $u32
  PCR15 @offset 0x3c $u32
  PCR16 @offset 0x40 $u32
  PCR17 @offset 0x44 $u32
  PCR18 @offset 0x48 $u32
  PCR19 @offset 0x4c $u32
  PCR20 @offset 0x50 $u32
  PCR21 @offset 0x54 $u32
  PCR22 @offset 0x58 $u32
  PCR23 @offset 0x5c $u32
  PCR24 @offset 0x60 $u32
  PCR25 @offset 0x64 $u32
  PCR26 @offset 0x68 $u32
  PCR27 @offset 0x6c $u32
  PCR28 @offset 0x70 $u32
  PCR29 @offset 0x74 $u32
  PCR30 @offset 0x78 $u32
  PCR31 @offset 0x7c $u32 {
    7
    ISF // at 24: Interrupt Status Flag
    4
    IRQC:4 // at 16: Interrupt Configuration
    LK // at 15: Lock Register
    4
    MUX:3 // at 8: Pin Mux Control
    1
    DSE // at 6: Drive Strength Enable
    ODE // at 5: Open Drain Enable
    PFE // at 4: Passive Filter Enable
    1
    SRE // at 2: Slew Rate Enable
    PE // at 1: Pull Enable
    PS // at 0: Pull Select
  }

//---  Register GPCLR: Global Pin Control Low Register
  GPCLR @offset 0x80 $u32 {
    GPWE:16 // at 16: Global Pin Write Enable
    GPWD:16 // at 0: Global Pin Write Data
  }

//---  Register GPCHR: Global Pin Control High Register
  GPCHR @offset 0x84 $u32 {
    GPWE:16 // at 16: Global Pin Write Enable
    GPWD:16 // at 0: Global Pin Write Data
  }

//---  Register ISFR: Interrupt Status Flag Register
  ISFR @offset 0xa0 $u32 {
    ISF:32 // at 0: Interrupt Status Flag
  }

//---  Register DFER: Digital Filter Enable Register
  DFER @offset 0xc0 $u32 {
    DFE:32 // at 0: Digital Filter Enable
  }

//---  Register DFCR: Digital Filter Clock Register
  DFCR @offset 0xc4 $u32 {
    31
    CS // at 0: Clock Source
  }

//---  Register DFWR: Digital Filter Width Register
  DFWR @offset 0xc8 $u32 {
    27
    FILT:5 // at 0: Filter Length
  }

}

//------------------------------------------------------------------------------
// Peripheral RCM: Reset Control Module
//------------------------------------------------------------------------------

registers ©RCM @at 0x4007f000 {
//---  Register SRS0: System Reset Status Register 0
  SRS0 @offset 0x0 @ro $u8 {
    POR // at 7: Power-On Reset
    PIN // at 6: External Reset Pin
    WDOG // at 5: Watchdog
    1
    LOL // at 3: Loss-of-Lock Reset
    LOC // at 2: Loss-of-Clock Reset
    LVD // at 1: Low-Voltage Detect Reset
    WAKEUP // at 0: Low Leakage Wakeup Reset
  }

//---  Register SRS1: System Reset Status Register 1
  SRS1 @offset 0x1 @ro $u8 {
    2
    SACKERR // at 5: Stop Mode Acknowledge Error Reset
    EZPT // at 4: EzPort Reset
    MDM_AP // at 3: MDM-AP System Reset Request
    SW // at 2: Software
    LOCKUP // at 1: Core Lockup
    JTAG // at 0: JTAG Generated Reset
  }

//---  Register RPFC: Reset Pin Filter Control register
  RPFC @offset 0x4 $u8 {
    5
    RSTFLTSS // at 2: Reset Pin Filter Select in Stop Mode
    RSTFLTSRW:2 // at 0: Reset Pin Filter Select in Run and Wait Modes
  }

//---  Register RPFW: Reset Pin Filter Width register
  RPFW @offset 0x5 $u8 {
    3
    RSTFLTSEL:5 // at 0: Reset Pin Filter Bus Clock Select
  }

//---  Register MR: Mode Register
  MR @offset 0x7 @ro $u8 {
    6
    EZP_MS // at 1: EZP_MS_B pin state
    1
  }

}

//------------------------------------------------------------------------------
// Peripheral RFSYS: System register file
//------------------------------------------------------------------------------

registers ©RFSYS @at 0x40041000 {
//---  Registers REG(0,1,2,3,4,5,6,7): Register file register
  #define RFSYS_REG(idx) (* ((volatile uint32_t *) (0x40041000 + 0x0 + (idx) * 0x4)))
  #define RFSYS_REG0 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 0 * 0x4)))
  #define RFSYS_REG1 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 1 * 0x4)))
  #define RFSYS_REG2 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 2 * 0x4)))
  #define RFSYS_REG3 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 3 * 0x4)))
  #define RFSYS_REG4 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 4 * 0x4)))
  #define RFSYS_REG5 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 5 * 0x4)))
  #define RFSYS_REG6 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 6 * 0x4)))
  #define RFSYS_REG7 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 7 * 0x4)))
 {
    HH:8 // at 24: High higher byte
    HL:8 // at 16: High lower byte
    LH:8 // at 8: Low higher byte
    LL:8 // at 0: Low lower byte
  }

}

//------------------------------------------------------------------------------
// Peripheral RFVBAT: VBAT register file
//------------------------------------------------------------------------------

registers ©RFVBAT @at 0x4003e000 {
//---  Registers REG(0,1,2,3,4,5,6,7): VBAT register file register
  #define RFVBAT_REG(idx) (* ((volatile uint32_t *) (0x4003e000 + 0x0 + (idx) * 0x4)))
  #define RFVBAT_REG0 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 0 * 0x4)))
  #define RFVBAT_REG1 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 1 * 0x4)))
  #define RFVBAT_REG2 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 2 * 0x4)))
  #define RFVBAT_REG3 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 3 * 0x4)))
  #define RFVBAT_REG4 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 4 * 0x4)))
  #define RFVBAT_REG5 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 5 * 0x4)))
  #define RFVBAT_REG6 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 6 * 0x4)))
  #define RFVBAT_REG7 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 7 * 0x4)))
 {
    HH:8 // at 24: High higher byte
    HL:8 // at 16: High lower byte
    LH:8 // at 8: Low higher byte
    LL:8 // at 0: Low lower byte
  }

}

//------------------------------------------------------------------------------
// Peripheral RNG: Random Number Generator Accelerator
//------------------------------------------------------------------------------

registers ©RNG @at 0x40029000 {
//---  Register CR: RNGA Control Register
  CR @offset 0x0 $u32 {
    27
    SLP // at 4: Sleep
    CLRI // at 3: Clear Interrupt
    INTM // at 2: Interrupt Mask
    HA // at 1: High Assurance
    GO // at 0: Go
  }

//---  Register SR: RNGA Status Register
  SR @offset 0x4 @ro $u32 {
    8
    OREG_SIZE:8 // at 16: Output Register Size
    OREG_LVL:8 // at 8: Output Register Level
    3
    SLP // at 4: Sleep
    ERRI // at 3: Error Interrupt
    ORU // at 2: Output Register Underflow
    LRS // at 1: Last Read Status
    SECV // at 0: Security Violation
  }

//---  Register ER: RNGA Entropy Register
  ER @offset 0x8 $u32 {
    EXT_ENT:32 // at 0: External Entropy
  }

//---  Register OR: RNGA Output Register
  OR @offset 0xc @ro $u32 {
    RANDOUT:32 // at 0: Random Output
  }

}

//------------------------------------------------------------------------------
// Peripheral RTC: Secure Real Time Clock
//------------------------------------------------------------------------------

registers ©RTC @at 0x4003d000 {
//---  Register TSR: RTC Time Seconds Register
  TSR @offset 0x0 $u32 {
    TSR:32 // at 0: Time Seconds Register
  }

//---  Register TPR: RTC Time Prescaler Register
  TPR @offset 0x4 $u32 {
    16
    TPR:16 // at 0: Time Prescaler Register
  }

//---  Register TAR: RTC Time Alarm Register
  TAR @offset 0x8 $u32 {
    TAR:32 // at 0: Time Alarm Register
  }

//---  Register TCR: RTC Time Compensation Register
  TCR @offset 0xc $u32 {
    CIC:8 // at 24: Compensation Interval Counter
    TCV:8 // at 16: Time Compensation Value
    CIR:8 // at 8: Compensation Interval Register
    TCR:8 // at 0: Time Compensation Register
  }

//---  Register CR: RTC Control Register
  CR @offset 0x10 $u32 {
    18
    SC2P // at 13: Oscillator 2pF Load Configure
    SC4P // at 12: Oscillator 4pF Load Configure
    SC8P // at 11: Oscillator 8pF Load Configure
    SC16P // at 10: Oscillator 16pF Load Configure
    CLKO // at 9: Clock Output
    OSCE // at 8: Oscillator Enable
    3
    WPS // at 4: Wakeup Pin Select
    UM // at 3: Update Mode
    SUP // at 2: Supervisor Access
    WPE // at 1: Wakeup Pin Enable
    SWR // at 0: Software Reset
  }

//---  Register SR: RTC Status Register
  SR @offset 0x14 $u32 {
    27
    TCE // at 4: Time Counter Enable
    1
    TAF // at 2: Time Alarm Flag
    TOF // at 1: Time Overflow Flag
    TIF // at 0: Time Invalid Flag
  }

//---  Register LR: RTC Lock Register
  LR @offset 0x18 $u32 {
    25
    LRL // at 6: Lock Register Lock
    SRL // at 5: Status Register Lock
    CRL // at 4: Control Register Lock
    TCL // at 3: Time Compensation Lock
    3
  }

//---  Register IER: RTC Interrupt Enable Register
  IER @offset 0x1c $u32 {
    24
    WPON // at 7: Wakeup Pin On
    2
    TSIE // at 4: Time Seconds Interrupt Enable
    1
    TAIE // at 2: Time Alarm Interrupt Enable
    TOIE // at 1: Time Overflow Interrupt Enable
    TIIE // at 0: Time Invalid Interrupt Enable
  }

//---  Register WAR: RTC Write Access Register
  WAR @offset 0x800 $u32 {
    24
    IERW // at 7: Interrupt Enable Register Write
    LRW // at 6: Lock Register Write
    SRW // at 5: Status Register Write
    CRW // at 4: Control Register Write
    TCRW // at 3: Time Compensation Register Write
    TARW // at 2: Time Alarm Register Write
    TPRW // at 1: Time Prescaler Register Write
    TSRW // at 0: Time Seconds Register Write
  }

//---  Register RAR: RTC Read Access Register
  RAR @offset 0x804 $u32 {
    24
    IERR // at 7: Interrupt Enable Register Read
    LRR // at 6: Lock Register Read
    SRR // at 5: Status Register Read
    CRR // at 4: Control Register Read
    TCRR // at 3: Time Compensation Register Read
    TARR // at 2: Time Alarm Register Read
    TPRR // at 1: Time Prescaler Register Read
    TSRR // at 0: Time Seconds Register Read
  }

}

//------------------------------------------------------------------------------
// Peripheral SDHC: Secured Digital Host Controller
//------------------------------------------------------------------------------

registers ©SDHC @at 0x400b1000 {
//---  Register DSADDR: DMA System Address register
  DSADDR @offset 0x0 $u32 {
    DSADDR:30 // at 2: DMA System Address
    2
  }

//---  Register BLKATTR: Block Attributes register
  BLKATTR @offset 0x4 $u32 {
    BLKCNT:16 // at 16: Blocks Count For Current Transfer
    3
    BLKSIZE:13 // at 0: Transfer Block Size
  }

//---  Register CMDARG: Command Argument register
  CMDARG @offset 0x8 $u32 {
    CMDARG:32 // at 0: Command Argument
  }

//---  Register XFERTYP: Transfer Type register
  XFERTYP @offset 0xc $u32 {
    2
    CMDINX:6 // at 24: Command Index
    CMDTYP:2 // at 22: Command Type
    DPSEL // at 21: Data Present Select
    CICEN // at 20: Command Index Check Enable
    CCCEN // at 19: Command CRC Check Enable
    1
    RSPTYP:2 // at 16: Response Type Select
    10
    MSBSEL // at 5: Multi/Single Block Select
    DTDSEL // at 4: Data Transfer Direction Select
    1
    AC12EN // at 2: Auto CMD12 Enable
    BCEN // at 1: Block Count Enable
    DMAEN // at 0: DMA Enable
  }

//---  Register CMDRSP0: Command Response 0
  CMDRSP0 @offset 0x10 @ro $u32 {
    CMDRSP0:32 // at 0: Command Response 0
  }

//---  Register CMDRSP1: Command Response 1
  CMDRSP1 @offset 0x14 @ro $u32 {
    CMDRSP1:32 // at 0: Command Response 1
  }

//---  Register CMDRSP2: Command Response 2
  CMDRSP2 @offset 0x18 @ro $u32 {
    CMDRSP2:32 // at 0: Command Response 2
  }

//---  Register CMDRSP3: Command Response 3
  CMDRSP3 @offset 0x1c @ro $u32 {
    CMDRSP3:32 // at 0: Command Response 3
  }

//---  Register DATPORT: Buffer Data Port register
  DATPORT @offset 0x20 $u32 {
    DATCONT:32 // at 0: Data Content
  }

//---  Register PRSSTAT: Present State register
  PRSSTAT @offset 0x24 @ro $u32 {
    DLSL:8 // at 24: DAT Line Signal Level
    CLSL // at 23: CMD Line Signal Level
    6
    CINS // at 16: Card Inserted
    4
    BREN // at 11: Buffer Read Enable
    BWEN // at 10: Buffer Write Enable
    RTA // at 9: Read Transfer Active
    WTA // at 8: Write Transfer Active
    SDOFF // at 7: SD Clock Gated Off Internally
    PEROFF // at 6: SDHC clock Gated Off Internally
    HCKOFF // at 5: System Clock Gated Off Internally
    IPGOFF // at 4: Bus Clock Gated Off Internally
    SDSTB // at 3: SD Clock Stable
    DLA // at 2: Data Line Active
    CDIHB // at 1: Command Inhibit (DAT)
    CIHB // at 0: Command Inhibit (CMD)
  }

//---  Register PROCTL: Protocol Control register
  PROCTL @offset 0x28 $u32 {
    5
    WECRM // at 26: Wakeup Event Enable On SD Card Removal
    WECINS // at 25: Wakeup Event Enable On SD Card Insertion
    WECINT // at 24: Wakeup Event Enable On Card Interrupt
    4
    IABG // at 19: Interrupt At Block Gap
    RWCTL // at 18: Read Wait Control
    CREQ // at 17: Continue Request
    SABGREQ // at 16: Stop At Block Gap Request
    6
    DMAS:2 // at 8: DMA Select
    CDSS // at 7: Card Detect Signal Selection
    CDTL // at 6: Card Detect Test Level
    EMODE:2 // at 4: Endian Mode
    D3CD // at 3: DAT3 As Card Detection Pin
    DTW:2 // at 1: Data Transfer Width
    LCTL // at 0: LED Control
  }

//---  Register SYSCTL: System Control register
  SYSCTL @offset 0x2c $u32 {
    4
    INITA // at 27: Initialization Active
    RSTD // at 26: Software Reset For DAT Line
    RSTC // at 25: Software Reset For CMD Line
    RSTA // at 24: Software Reset For ALL
    4
    DTOCV:4 // at 16: Data Timeout Counter Value
    SDCLKFS:8 // at 8: SDCLK Frequency Select
    DVS:4 // at 4: Divisor
    SDCLKEN // at 3: SD Clock Enable
    PEREN // at 2: Peripheral Clock Enable
    HCKEN // at 1: System Clock Enable
    IPGEN // at 0: IPG Clock Enable
  }

//---  Register IRQSTAT: Interrupt Status register
  IRQSTAT @offset 0x30 $u32 {
    3
    DMAE // at 28: DMA Error
    3
    AC12E // at 24: Auto CMD12 Error
    1
    DEBE // at 22: Data End Bit Error
    DCE // at 21: Data CRC Error
    DTOE // at 20: Data Timeout Error
    CIE // at 19: Command Index Error
    CEBE // at 18: Command End Bit Error
    CCE // at 17: Command CRC Error
    CTOE // at 16: Command Timeout Error
    7
    CINT // at 8: Card Interrupt
    CRM // at 7: Card Removal
    CINS // at 6: Card Insertion
    BRR // at 5: Buffer Read Ready
    BWR // at 4: Buffer Write Ready
    DINT // at 3: DMA Interrupt
    BGE // at 2: Block Gap Event
    TC // at 1: Transfer Complete
    CC // at 0: Command Complete
  }

//---  Register IRQSTATEN: Interrupt Status Enable register
  IRQSTATEN @offset 0x34 $u32 {
    3
    DMAESEN // at 28: DMA Error Status Enable
    3
    AC12ESEN // at 24: Auto CMD12 Error Status Enable
    1
    DEBESEN // at 22: Data End Bit Error Status Enable
    DCESEN // at 21: Data CRC Error Status Enable
    DTOESEN // at 20: Data Timeout Error Status Enable
    CIESEN // at 19: Command Index Error Status Enable
    CEBESEN // at 18: Command End Bit Error Status Enable
    CCESEN // at 17: Command CRC Error Status Enable
    CTOESEN // at 16: Command Timeout Error Status Enable
    7
    CINTSEN // at 8: Card Interrupt Status Enable
    CRMSEN // at 7: Card Removal Status Enable
    CINSEN // at 6: Card Insertion Status Enable
    BRRSEN // at 5: Buffer Read Ready Status Enable
    BWRSEN // at 4: Buffer Write Ready Status Enable
    DINTSEN // at 3: DMA Interrupt Status Enable
    BGESEN // at 2: Block Gap Event Status Enable
    TCSEN // at 1: Transfer Complete Status Enable
    CCSEN // at 0: Command Complete Status Enable
  }

//---  Register IRQSIGEN: Interrupt Signal Enable register
  IRQSIGEN @offset 0x38 $u32 {
    3
    DMAEIEN // at 28: DMA Error Interrupt Enable
    3
    AC12EIEN // at 24: Auto CMD12 Error Interrupt Enable
    1
    DEBEIEN // at 22: Data End Bit Error Interrupt Enable
    DCEIEN // at 21: Data CRC Error Interrupt Enable
    DTOEIEN // at 20: Data Timeout Error Interrupt Enable
    CIEIEN // at 19: Command Index Error Interrupt Enable
    CEBEIEN // at 18: Command End Bit Error Interrupt Enable
    CCEIEN // at 17: Command CRC Error Interrupt Enable
    CTOEIEN // at 16: Command Timeout Error Interrupt Enable
    7
    CINTIEN // at 8: Card Interrupt Enable
    CRMIEN // at 7: Card Removal Interrupt Enable
    CINSIEN // at 6: Card Insertion Interrupt Enable
    BRRIEN // at 5: Buffer Read Ready Interrupt Enable
    BWRIEN // at 4: Buffer Write Ready Interrupt Enable
    DINTIEN // at 3: DMA Interrupt Enable
    BGEIEN // at 2: Block Gap Event Interrupt Enable
    TCIEN // at 1: Transfer Complete Interrupt Enable
    CCIEN // at 0: Command Complete Interrupt Enable
  }

//---  Register AC12ERR: Auto CMD12 Error Status Register
  AC12ERR @offset 0x3c @ro $u32 {
    24
    CNIBAC12E // at 7: Command Not Issued By Auto CMD12 Error
    2
    AC12IE // at 4: Auto CMD12 Index Error
    AC12CE // at 3: Auto CMD12 CRC Error
    AC12EBE // at 2: Auto CMD12 End Bit Error
    AC12TOE // at 1: Auto CMD12 Timeout Error
    AC12NE // at 0: Auto CMD12 Not Executed
  }

//---  Register HTCAPBLT: Host Controller Capabilities
  HTCAPBLT @offset 0x40 @ro $u32 {
    7
    VS33 // at 24: Voltage Support 3.3 V
    SRS // at 23: Suspend/Resume Support
    DMAS // at 22: DMA Support
    HSS // at 21: High Speed Support
    ADMAS // at 20: ADMA Support
    1
    MBL:3 // at 16: Max Block Length
    16
  }

//---  Register WML: Watermark Level Register
  WML @offset 0x44 $u32 {
    8
    WRWML:8 // at 16: Write Watermark Level
    8
    RDWML:8 // at 0: Read Watermark Level
  }

//---  Register FEVT: Force Event register
  FEVT @offset 0x50 $u32 {
    CINT // at 31: Force Event Card Interrupt
    2
    DMAE // at 28: Force Event DMA Error
    3
    AC12E // at 24: Force Event Auto Command 12 Error
    1
    DEBE // at 22: Force Event Data End Bit Error
    DCE // at 21: Force Event Data CRC Error
    DTOE // at 20: Force Event Data Time Out Error
    CIE // at 19: Force Event Command Index Error
    CEBE // at 18: Force Event Command End Bit Error
    CCE // at 17: Force Event Command CRC Error
    CTOE // at 16: Force Event Command Time Out Error
    8
    CNIBAC12E // at 7: Force Event Command Not Executed By Auto Command 12 Error
    2
    AC12IE // at 4: Force Event Auto Command 12 Index Error
    AC12EBE // at 3: Force Event Auto Command 12 End Bit Error
    AC12CE // at 2: Force Event Auto Command 12 CRC Error
    AC12TOE // at 1: Force Event Auto Command 12 Time Out Error
    AC12NE // at 0: Force Event Auto Command 12 Not Executed
  }

//---  Register ADMAES: ADMA Error Status register
  ADMAES @offset 0x54 @ro $u32 {
    28
    ADMADCE // at 3: ADMA Descriptor Error
    ADMALME // at 2: ADMA Length Mismatch Error
    ADMAES:2 // at 0: ADMA Error State (When ADMA Error Is Occurred.)
  }

//---  Register ADSADDR: ADMA System Addressregister
  ADSADDR @offset 0x58 $u32 {
    ADSADDR:30 // at 2: ADMA System Address
    2
  }

//---  Register VENDOR: Vendor Specific register
  VENDOR @offset 0xc0 $u32 {
    8
    INTSTVAL:8 // at 16: Internal State Value
    14
    EXBLKNU // at 1: Exact Block Number Block Read Enable For SDIO CMD53
    EXTDMAEN // at 0: External DMA Request Enable
  }

//---  Register MMCBOOT: MMC Boot register
  MMCBOOT @offset 0xc4 $u32 {
    BOOTBLKCNT:16 // at 16: Defines the stop at block gap value of automatic mode
    8
    AUTOSABGEN // at 7: When boot, enable auto stop at block gap function
    BOOTEN // at 6: Boot Mode Enable
    BOOTMODE // at 5: Boot Mode Select
    BOOTACK // at 4: Boot Ack Mode Select
    DTOCVACK:4 // at 0: Boot ACK Time Out Counter Value
  }

//---  Register HOSTVER: Host Controller Version
  HOSTVER @offset 0xfc @ro $u32 {
    16
    VVN:8 // at 8: Vendor Version Number
    SVN:8 // at 0: Specification Version Number
  }

}

//------------------------------------------------------------------------------
// Peripheral SIM: System Integration Module
//------------------------------------------------------------------------------

registers ©SIM @at 0x40047000 {
//---  Register SOPT1: System Options Register 1
  SOPT1 @offset 0x0 $u32 {
    USBREGEN // at 31: USB voltage regulator enable
    USBSSTBY // at 30: USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
    USBVSTBY // at 29: USB voltage regulator in standby mode during VLPR and VLPW modes
    9
    OSC32KSEL:2 // at 18: 32K oscillator clock select
    2
    RAMSIZE:4 // at 12: RAM size
    12
  }

//---  Register SOPT1CFG: SOPT1 Configuration Register
  SOPT1CFG @offset 0x4 $u32 {
    5
    USSWE // at 26: USB voltage regulator stop standby write enable
    UVSWE // at 25: USB voltage regulator VLP standby write enable
    URWE // at 24: USB voltage regulator enable write enable
    24
  }

//---  Register SOPT2: System Options Register 2
  SOPT2 @offset 0x1004 $u32 {
    2
    SDHCSRC:2 // at 28: SDHC clock source select
    6
    TIMESRC:2 // at 20: IEEE 1588 timestamp clock source select
    RMIISRC // at 19: RMII clock source select
    USBSRC // at 18: USB clock source select
    PLLFLLSEL:2 // at 16: PLL/FLL clock select
    3
    TRACECLKSEL // at 12: Debug trace clock select
    PTD7PAD // at 11: PTD7 pad drive strength
    1
    FBSL:2 // at 8: FlexBus security level
    CLKOUTSEL:3 // at 5: CLKOUT select
    RTCCLKOUTSEL // at 4: RTC clock out select
    4
  }

//---  Register SOPT4: System Options Register 4
  SOPT4 @offset 0x100c $u32 {
    FTM3TRG1SRC // at 31: FlexTimer 3 Hardware Trigger 1 Source Select
    FTM3TRG0SRC // at 30: FlexTimer 3 Hardware Trigger 0 Source Select
    FTM0TRG1SRC // at 29: FlexTimer 0 Hardware Trigger 1 Source Select
    FTM0TRG0SRC // at 28: FlexTimer 0 Hardware Trigger 0 Source Select
    FTM3CLKSEL // at 27: FlexTimer 3 External Clock Pin Select
    FTM2CLKSEL // at 26: FlexTimer 2 External Clock Pin Select
    FTM1CLKSEL // at 25: FTM1 External Clock Pin Select
    FTM0CLKSEL // at 24: FlexTimer 0 External Clock Pin Select
    2
    FTM2CH0SRC:2 // at 20: FTM2 channel 0 input capture source select
    FTM1CH0SRC:2 // at 18: FTM1 channel 0 input capture source select
    5
    FTM3FLT0 // at 12: FTM3 Fault 0 Select
    3
    FTM2FLT0 // at 8: FTM2 Fault 0 Select
    3
    FTM1FLT0 // at 4: FTM1 Fault 0 Select
    1
    FTM0FLT2 // at 2: FTM0 Fault 2 Select
    FTM0FLT1 // at 1: FTM0 Fault 1 Select
    FTM0FLT0 // at 0: FTM0 Fault 0 Select
  }

//---  Register SOPT5: System Options Register 5
  SOPT5 @offset 0x1010 $u32 {
    24
    UART1RXSRC:2 // at 6: UART 1 receive data source select
    UART1TXSRC:2 // at 4: UART 1 transmit data source select
    UART0RXSRC:2 // at 2: UART 0 receive data source select
    UART0TXSRC:2 // at 0: UART 0 transmit data source select
  }

//---  Register SOPT7: System Options Register 7
  SOPT7 @offset 0x1018 $u32 {
    16
    ADC1ALTTRGEN // at 15: ADC1 alternate trigger enable
    2
    ADC1PRETRGSEL // at 12: ADC1 pre-trigger select
    ADC1TRGSEL:4 // at 8: ADC1 trigger select
    ADC0ALTTRGEN // at 7: ADC0 alternate trigger enable
    2
    ADC0PRETRGSEL // at 4: ADC0 pretrigger select
    ADC0TRGSEL:4 // at 0: ADC0 trigger select
  }

//---  Register SDID: System Device Identification Register
  SDID @offset 0x1024 @ro $u32 {
    FAMILYID:4 // at 28: Kinetis Family ID
    SUBFAMID:4 // at 24: Kinetis Sub-Family ID
    SERIESID:4 // at 20: Kinetis Series ID
    4
    REVID:4 // at 12: Device revision number
    DIEID:5 // at 7: Device Die ID
    FAMID:3 // at 4: Kinetis family identification
    PINID:4 // at 0: Pincount identification
  }

//---  Register SCGC1: System Clock Gating Control Register 1
  SCGC1 @offset 0x1028 $u32 {
    20
    UART5 // at 11: UART5 Clock Gate Control
    UART4 // at 10: UART4 Clock Gate Control
    3
    I2C2 // at 6: I2C2 Clock Gate Control
    6
  }

//---  Register SCGC2: System Clock Gating Control Register 2
  SCGC2 @offset 0x102c $u32 {
    18
    DAC1 // at 13: DAC1 Clock Gate Control
    DAC0 // at 12: DAC0 Clock Gate Control
    11
    ENET // at 0: ENET Clock Gate Control
  }

//---  Register SCGC3: System Clock Gating Control Register 3
  SCGC3 @offset 0x1030 $u32 {
    4
    ADC1 // at 27: ADC1 Clock Gate Control
    1
    FTM3 // at 25: FTM3 Clock Gate Control
    FTM2 // at 24: FTM2 Clock Gate Control
    6
    SDHC // at 17: SDHC Clock Gate Control
    4
    SPI2 // at 12: SPI2 Clock Gate Control
    11
    RNGA // at 0: RNGA Clock Gate Control
  }

//---  Register SCGC4: System Clock Gating Control Register 4
  SCGC4 @offset 0x1034 $u32 {
    11
    VREF // at 20: VREF Clock Gate Control
    CMP // at 19: Comparator Clock Gate Control
    USBOTG // at 18: USB Clock Gate Control
    4
    UART3 // at 13: UART3 Clock Gate Control
    UART2 // at 12: UART2 Clock Gate Control
    UART1 // at 11: UART1 Clock Gate Control
    UART0 // at 10: UART0 Clock Gate Control
    2
    I2C1 // at 7: I2C1 Clock Gate Control
    I2C0 // at 6: I2C0 Clock Gate Control
    3
    CMT // at 2: CMT Clock Gate Control
    EWM // at 1: EWM Clock Gate Control
    1
  }

//---  Register SCGC5: System Clock Gating Control Register 5
  SCGC5 @offset 0x1038 $u32 {
    18
    PORTE // at 13: Port E Clock Gate Control
    PORTD // at 12: Port D Clock Gate Control
    PORTC // at 11: Port C Clock Gate Control
    PORTB // at 10: Port B Clock Gate Control
    PORTA // at 9: Port A Clock Gate Control
    8
    LPTMR // at 0: Low Power Timer Access Control
  }

//---  Register SCGC6: System Clock Gating Control Register 6
  SCGC6 @offset 0x103c $u32 {
    DAC0 // at 31: DAC0 Clock Gate Control
    1
    RTC // at 29: RTC Access Control
    1
    ADC0 // at 27: ADC0 Clock Gate Control
    FTM2 // at 26: FTM2 Clock Gate Control
    FTM1 // at 25: FTM1 Clock Gate Control
    FTM0 // at 24: FTM0 Clock Gate Control
    PIT // at 23: PIT Clock Gate Control
    PDB // at 22: PDB Clock Gate Control
    USBDCD // at 21: USB DCD Clock Gate Control
    2
    CRC // at 18: CRC Clock Gate Control
    2
    I2S // at 15: I2S Clock Gate Control
    1
    SPI1 // at 13: SPI1 Clock Gate Control
    SPI0 // at 12: SPI0 Clock Gate Control
    2
    RNGA // at 9: RNGA Clock Gate Control
    4
    FLEXCAN0 // at 4: FlexCAN0 Clock Gate Control
    2
    DMAMUX // at 1: DMA Mux Clock Gate Control
    FTF // at 0: Flash Memory Clock Gate Control
  }

//---  Register SCGC7: System Clock Gating Control Register 7
  SCGC7 @offset 0x1040 $u32 {
    29
    MPU // at 2: MPU Clock Gate Control
    DMA // at 1: DMA Clock Gate Control
    FLEXBUS // at 0: FlexBus Clock Gate Control
  }

//---  Register CLKDIV1: System Clock Divider Register 1
  CLKDIV1 @offset 0x1044 $u32 {
    OUTDIV1:4 // at 28: Clock 1 output divider value
    OUTDIV2:4 // at 24: Clock 2 output divider value
    OUTDIV3:4 // at 20: Clock 3 output divider value
    OUTDIV4:4 // at 16: Clock 4 output divider value
    16
  }

//---  Register CLKDIV2: System Clock Divider Register 2
  CLKDIV2 @offset 0x1048 $u32 {
    28
    USBDIV:3 // at 1: USB clock divider divisor
    USBFRAC // at 0: USB clock divider fraction
  }

//---  Register FCFG1: Flash Configuration Register 1
  FCFG1 @offset 0x104c $u32 {
    NVMSIZE:4 // at 28: FlexNVM size
    PFSIZE:4 // at 24: Program flash size
    4
    EESIZE:4 // at 16: EEPROM size
    4
    DEPART:4 // at 8: FlexNVM partition
    6
    FLASHDOZE // at 1: Flash Doze
    FLASHDIS // at 0: Flash Disable
  }

//---  Register FCFG2: Flash Configuration Register 2
  FCFG2 @offset 0x1050 @ro $u32 {
    1
    MAXADDR0:7 // at 24: Max address block 0
    PFLSH // at 23: Program flash only
    MAXADDR1:7 // at 16: Max address block 1
    16
  }

//---  Register UIDH: Unique Identification Register High
  UIDH @offset 0x1054 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDMH: Unique Identification Register Mid-High
  UIDMH @offset 0x1058 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDML: Unique Identification Register Mid Low
  UIDML @offset 0x105c @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDL: Unique Identification Register Low
  UIDL @offset 0x1060 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

}

//------------------------------------------------------------------------------
// Peripheral SMC: System Mode Controller
//------------------------------------------------------------------------------

registers ©SMC @at 0x4007e000 {
//---  Register PMPROT: Power Mode Protection register
  PMPROT @offset 0x0 $u8 {
    2
    AVLP // at 5: Allow Very-Low-Power Modes
    1
    ALLS // at 3: Allow Low-Leakage Stop Mode
    1
    AVLLS // at 1: Allow Very-Low-Leakage Stop Mode
    1
  }

//---  Register PMCTRL: Power Mode Control register
  PMCTRL @offset 0x1 $u8 {
    LPWUI // at 7: Low-Power Wake Up On Interrupt
    RUNM:2 // at 5: Run Mode Control
    1
    STOPA // at 3: Stop Aborted
    STOPM:3 // at 0: Stop Mode Control
  }

//---  Register VLLSCTRL: VLLS Control register
  VLLSCTRL @offset 0x2 $u8 {
    2
    PORPO // at 5: POR Power Option
    2
    VLLSM:3 // at 0: VLLS Mode Control
  }

//---  Register PMSTAT: Power Mode Status register
  PMSTAT @offset 0x3 @ro $u8 {
    1
    PMSTAT:7 // at 0: When debug is enabled, the PMSTAT will not update to STOP or VLPS
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©SPI [3]
//        SPI0 at 0x4002c000
//        SPI1 at 0x4002d000
//        SPI2 at 0x400ac000
//------------------------------------------------------------------------------

registers ©SPI [3 @at 0x4002c000 0x4002d000 0x400ac000]
          ©SPI0 @at 0x4002c000
          ©SPI1 @at 0x4002d000
          ©SPI2 @at 0x400ac000
{
//---  Register MCR: Module Configuration Register
  MCR @offset 0x0 $u32 {
    MSTR // at 31: Master/Slave Mode Select
    CONT_SCKE // at 30: Continuous SCK Enable
    DCONF:2 // at 28: SPI Configuration.
    FRZ // at 27: Freeze
    MTFE // at 26: Modified Timing Format Enable
    PCSSE // at 25: Peripheral Chip Select Strobe Enable
    ROOE // at 24: Receive FIFO Overflow Overwrite Enable
    2
    PCSIS:6 // at 16: Peripheral Chip Select x Inactive State
    DOZE // at 15: Doze Enable
    MDIS // at 14: Module Disable
    DIS_TXF // at 13: Disable Transmit FIFO
    DIS_RXF // at 12: Disable Receive FIFO
    CLR_TXF // at 11: Clear TX FIFO
    CLR_RXF // at 10: Flushes the RX FIFO
    SMPL_PT:2 // at 8: Sample Point
    7
    HALT // at 0: Halt
  }

//---  Register TCR: Transfer Count Register
  TCR @offset 0x8 $u32 {
    SPI_TCNT:16 // at 16: SPI Transfer Counter
    16
  }

//---  Registers CTAR(0,1): Clock and Transfer Attributes Register (In Master Mode)
  CTAR0 @offset 0xc $u32
  CTAR1 @offset 0x10 $u32 {
    DBR // at 31: Double Baud Rate
    FMSZ:4 // at 27: Frame Size
    CPOL // at 26: Clock Polarity
    CPHA // at 25: Clock Phase
    LSBFE // at 24: LSB First
    PCSSCK:2 // at 22: PCS to SCK Delay Prescaler
    PASC:2 // at 20: After SCK Delay Prescaler
    PDT:2 // at 18: Delay after Transfer Prescaler
    PBR:2 // at 16: Baud Rate Prescaler
    CSSCK:4 // at 12: PCS to SCK Delay Scaler
    ASC:4 // at 8: After SCK Delay Scaler
    DT:4 // at 4: Delay After Transfer Scaler
    BR:4 // at 0: Baud Rate Scaler
  }

//---  Register CTAR_SLAVE: Clock and Transfer Attributes Register (In Slave Mode)
  CTAR_SLAVE @offset 0xc $u32 {
    FMSZ:5 // at 27: Frame Size
    CPOL // at 26: Clock Polarity
    CPHA // at 25: Clock Phase
    25
  }

//---  Register SR: Status Register
  SR @offset 0x2c $u32 {
    TCF // at 31: Transfer Complete Flag
    TXRXS // at 30: TX and RX Status
    1
    EOQF // at 28: End of Queue Flag
    TFUF // at 27: Transmit FIFO Underflow Flag
    1
    TFFF // at 25: Transmit FIFO Fill Flag
    5
    RFOF // at 19: Receive FIFO Overflow Flag
    1
    RFDF // at 17: Receive FIFO Drain Flag
    1
    TXCTR:4 // at 12: TX FIFO Counter
    TXNXTPTR:4 // at 8: Transmit Next Pointer
    RXCTR:4 // at 4: RX FIFO Counter
    POPNXTPTR:4 // at 0: Pop Next Pointer
  }

//---  Register RSER: DMA/Interrupt Request Select and Enable Register
  RSER @offset 0x30 $u32 {
    TCF_RE // at 31: Transmission Complete Request Enable
    2
    EOQF_RE // at 28: Finished Request Enable
    TFUF_RE // at 27: Transmit FIFO Underflow Request Enable
    1
    TFFF_RE // at 25: Transmit FIFO Fill Request Enable
    TFFF_DIRS // at 24: Transmit FIFO Fill DMA or Interrupt Request Select
    4
    RFOF_RE // at 19: Receive FIFO Overflow Request Enable
    1
    RFDF_RE // at 17: Receive FIFO Drain Request Enable
    RFDF_DIRS // at 16: Receive FIFO Drain DMA or Interrupt Request Select
    16
  }

//---  Register PUSHR: PUSH TX FIFO Register In Master Mode
  PUSHR @offset 0x34 $u32 {
    CONT // at 31: Continuous Peripheral Chip Select Enable
    CTAS:3 // at 28: Clock and Transfer Attributes Select
    EOQ // at 27: End Of Queue
    CTCNT // at 26: Clear Transfer Counter
    4
    PCS:6 // at 16: Select which PCS signals are to be asserted for the transfer
    TXDATA:16 // at 0: Transmit Data
  }

//---  Register PUSHR_SLAVE: PUSH TX FIFO Register In Slave Mode
  PUSHR_SLAVE @offset 0x34 $u32 {
    TXDATA:32 // at 0: Transmit Data
  }

//---  Register POPR: POP RX FIFO Register
  POPR @offset 0x38 @ro $u32 {
    RXDATA:32 // at 0: Received Data
  }

//---  Registers TXFR(0,1,2,3): Transmit FIFO Registers
  TXFR0 @offset 0x3c @ro $u32
  TXFR1 @offset 0x40 @ro $u32
  TXFR2 @offset 0x44 @ro $u32
  TXFR3 @offset 0x48 @ro $u32 {
    TXCMD_TXDATA:16 // at 16: Transmit Command or Transmit Data
    TXDATA:16 // at 0: Transmit Data
  }

//---  Registers RXFR(0,1,2,3): Receive FIFO Registers
  RXFR0 @offset 0x7c @ro $u32
  RXFR1 @offset 0x80 @ro $u32
  RXFR2 @offset 0x84 @ro $u32
  RXFR3 @offset 0x88 @ro $u32 {
    RXDATA:32 // at 0: Receive Data
  }

}

//------------------------------------------------------------------------------
// Peripheral SYST: System Timer
//------------------------------------------------------------------------------

registers ©SYST @at 0xe000e000 {
//---  Register CSR: SysTick Control and Status
  CSR @offset 0x10 $u32 {
    15
    COUNTFLAG // at 16: Returns 1 if timer counted to 0 since last time this was read
    13
    CLKSOURCE // at 2: Clock Source Selection
    TICKINT // at 1: Enables SysTick exception request
    ENABLE // at 0: Enable the Counter
  }

//---  Register RVR: SysTick Reload Value Register
  RVR @offset 0x14 $u32
//---  Register CVR: SysTick Current Value Register
  CVR @offset 0x18 $u32
//---  Register CALIB: SysTick Calibration Value Register
  CALIB @offset 0x1c @ro $u32
}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©UART [6]
//        UART0 at 0x4006a000
//        UART1 at 0x4006b000
//        UART2 at 0x4006c000
//        UART3 at 0x4006d000
//        UART4 at 0x400ea000
//        UART5 at 0x400eb000
//------------------------------------------------------------------------------

registers ©UART [6 @at 0x4006a000 0x4006b000 0x4006c000 0x4006d000 0x400ea000 0x400eb000]
          ©UART0 @at 0x4006a000
          ©UART1 @at 0x4006b000
          ©UART2 @at 0x4006c000
          ©UART3 @at 0x4006d000
          ©UART4 @at 0x400ea000
          ©UART5 @at 0x400eb000
{
//---  Register BDH: UART Baud Rate Registers: High
  BDH @offset 0x0 $u8 {
    LBKDIE // at 7: LIN Break Detect Interrupt or DMA Request Enable
    RXEDGIE // at 6: RxD Input Active Edge Interrupt Enable
    SBNS // at 5: Stop Bit Number Select
    SBR:5 // at 0: UART Baud Rate Bits
  }

//---  Register BDL: UART Baud Rate Registers: Low
  BDL @offset 0x1 $u8 {
    SBR:8 // at 0: UART Baud Rate Bits
  }

//---  Register C1: UART Control Register 1
  C1 @offset 0x2 $u8 {
    LOOPS // at 7: Loop Mode Select
    UARTSWAI // at 6: UART Stops in Wait Mode
    RSRC // at 5: Receiver Source Select
    M // at 4: 9-bit or 8-bit Mode Select
    WAKE // at 3: Receiver Wakeup Method Select
    ILT // at 2: Idle Line Type Select
    PE // at 1: Parity Enable
    PT // at 0: Parity Type
  }

//---  Register C2: UART Control Register 2
  C2 @offset 0x3 $u8 {
    TIE // at 7: Transmitter Interrupt or DMA Transfer Enable.
    TCIE // at 6: Transmission Complete Interrupt or DMA Transfer Enable
    RIE // at 5: Receiver Full Interrupt or DMA Transfer Enable
    ILIE // at 4: Idle Line Interrupt DMA Transfer Enable
    TE // at 3: Transmitter Enable
    RE // at 2: Receiver Enable
    RWU // at 1: Receiver Wakeup Control
    SBK // at 0: Send Break
  }

//---  Register S1: UART Status Register 1
  S1 @offset 0x4 @ro $u8 {
    TDRE // at 7: Transmit Data Register Empty Flag
    TC // at 6: Transmit Complete Flag
    RDRF // at 5: Receive Data Register Full Flag
    IDLE // at 4: Idle Line Flag
    OR // at 3: Receiver Overrun Flag
    NF // at 2: Noise Flag
    FE // at 1: Framing Error Flag
    PF // at 0: Parity Error Flag
  }

//---  Register S2: UART Status Register 2
  S2 @offset 0x5 $u8 {
    LBKDIF // at 7: LIN Break Detect Interrupt Flag
    RXEDGIF // at 6: RxD Pin Active Edge Interrupt Flag
    MSBF // at 5: Most Significant Bit First
    RXINV // at 4: Receive Data Inversion
    RWUID // at 3: Receive Wakeup Idle Detect
    BRK13 // at 2: Break Transmit Character Length
    LBKDE // at 1: LIN Break Detection Enable
    RAF // at 0: Receiver Active Flag
  }

//---  Register C3: UART Control Register 3
  C3 @offset 0x6 $u8 {
    R8 // at 7: Received Bit 8
    T8 // at 6: Transmit Bit 8
    TXDIR // at 5: Transmitter Pin Data Direction in Single-Wire mode
    TXINV // at 4: Transmit Data Inversion.
    ORIE // at 3: Overrun Error Interrupt Enable
    NEIE // at 2: Noise Error Interrupt Enable
    FEIE // at 1: Framing Error Interrupt Enable
    PEIE // at 0: Parity Error Interrupt Enable
  }

//---  Register D: UART Data Register
  D @offset 0x7 $u8 {
    RT:8 // at 0: Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
  }

//---  Register MA1: UART Match Address Registers 1
  MA1 @offset 0x8 $u8 {
    MA:8 // at 0: Match Address
  }

//---  Register MA2: UART Match Address Registers 2
  MA2 @offset 0x9 $u8 {
    MA:8 // at 0: Match Address
  }

//---  Register C4: UART Control Register 4
  C4 @offset 0xa $u8 {
    MAEN1 // at 7: Match Address Mode Enable 1
    MAEN2 // at 6: Match Address Mode Enable 2
    M10 // at 5: 10-bit Mode select
    BRFA:5 // at 0: Baud Rate Fine Adjust
  }

//---  Register C5: UART Control Register 5
  C5 @offset 0xb $u8 {
    TDMAS // at 7: Transmitter DMA Select
    TCDMAS // at 6: Transmission Complete DMA Select
    RDMAS // at 5: Receiver Full DMA Select
    ILDMAS // at 4: Idle Line DMA Select
    LBKDDMAS // at 3: LIN Break Detect DMA Select Bit
    3
  }

//---  Register ED: UART Extended Data Register
  ED @offset 0xc @ro $u8 {
    NOISY // at 7: The current received dataword contained in D and C3[R8] was received with noise.
    PARITYE // at 6: The current received dataword contained in D and C3[R8] was received with a parity error.
    6
  }

//---  Register MODEM: UART Modem Register
  MODEM @offset 0xd $u8 {
    4
    RXRTSE // at 3: Receiver request-to-send enable
    TXRTSPOL // at 2: Transmitter request-to-send polarity
    TXRTSE // at 1: Transmitter request-to-send enable
    TXCTSE // at 0: Transmitter clear-to-send enable
  }

//---  Register IR: UART Infrared Register
  IR @offset 0xe $u8 {
    5
    IREN // at 2: Infrared enable
    TNP:2 // at 0: Transmitter narrow pulse
  }

//---  Register PFIFO: UART FIFO Parameters
  PFIFO @offset 0x10 $u8 {
    TXFE // at 7: Transmit FIFO Enable
    TXFIFOSIZE:3 // at 4: Transmit FIFO. Buffer Depth
    RXFE // at 3: Receive FIFO Enable
    RXFIFOSIZE:3 // at 0: Receive FIFO. Buffer Depth
  }

//---  Register CFIFO: UART FIFO Control Register
  CFIFO @offset 0x11 $u8 {
    TXFLUSH // at 7: Transmit FIFO/Buffer Flush
    RXFLUSH // at 6: Receive FIFO/Buffer Flush
    3
    RXOFE // at 2: Receive FIFO Overflow Interrupt Enable
    TXOFE // at 1: Transmit FIFO Overflow Interrupt Enable
    RXUFE // at 0: Receive FIFO Underflow Interrupt Enable
  }

//---  Register SFIFO: UART FIFO Status Register
  SFIFO @offset 0x12 $u8 {
    TXEMPT // at 7: Transmit Buffer/FIFO Empty
    RXEMPT // at 6: Receive Buffer/FIFO Empty
    3
    RXOF // at 2: Receiver Buffer Overflow Flag
    TXOF // at 1: Transmitter Buffer Overflow Flag
    RXUF // at 0: Receiver Buffer Underflow Flag
  }

//---  Register TWFIFO: UART FIFO Transmit Watermark
  TWFIFO @offset 0x13 $u8 {
    TXWATER:8 // at 0: Transmit Watermark
  }

//---  Register TCFIFO: UART FIFO Transmit Count
  TCFIFO @offset 0x14 @ro $u8 {
    TXCOUNT:8 // at 0: Transmit Counter
  }

//---  Register RWFIFO: UART FIFO Receive Watermark
  RWFIFO @offset 0x15 $u8 {
    RXWATER:8 // at 0: Receive Watermark
  }

//---  Register RCFIFO: UART FIFO Receive Count
  RCFIFO @offset 0x16 @ro $u8 {
    RXCOUNT:8 // at 0: Receive Counter
  }

//---  Register C7816: UART 7816 Control Register
  C7816 @offset 0x18 $u8 {
    3
    ONACK // at 4: Generate NACK on Overflow
    ANACK // at 3: Generate NACK on Error
    INIT // at 2: Detect Initial Character
    TTYPE // at 1: Transfer Type
    ISO_7816E // at 0: ISO-7816 Functionality Enabled
  }

//---  Register IE7816: UART 7816 Interrupt Enable Register
  IE7816 @offset 0x19 $u8 {
    WTE // at 7: Wait Timer Interrupt Enable
    CWTE // at 6: Character Wait Timer Interrupt Enable
    BWTE // at 5: Block Wait Timer Interrupt Enable
    INITDE // at 4: Initial Character Detected Interrupt Enable
    1
    GTVE // at 2: Guard Timer Violated Interrupt Enable
    TXTE // at 1: Transmit Threshold Exceeded Interrupt Enable
    RXTE // at 0: Receive Threshold Exceeded Interrupt Enable
  }

//---  Register IS7816: UART 7816 Interrupt Status Register
  IS7816 @offset 0x1a $u8 {
    WT // at 7: Wait Timer Interrupt
    CWT // at 6: Character Wait Timer Interrupt
    BWT // at 5: Block Wait Timer Interrupt
    INITD // at 4: Initial Character Detected Interrupt
    1
    GTV // at 2: Guard Timer Violated Interrupt
    TXT // at 1: Transmit Threshold Exceeded Interrupt
    RXT // at 0: Receive Threshold Exceeded Interrupt
  }

//---  Register WP7816T0: UART 7816 Wait Parameter Register
  WP7816T0 @offset 0x1b $u8 {
    WI:8 // at 0: Wait Time Integer (C7816[TTYPE] = 0)
  }

//---  Register WP7816T1: UART 7816 Wait Parameter Register
  WP7816T1 @offset 0x1b $u8 {
    CWI:4 // at 4: Character Wait Time Integer (C7816[TTYPE] = 1)
    BWI:4 // at 0: Block Wait Time Integer(C7816[TTYPE] = 1)
  }

//---  Register WN7816: UART 7816 Wait N Register
  WN7816 @offset 0x1c $u8 {
    GTN:8 // at 0: Guard Band N
  }

//---  Register WF7816: UART 7816 Wait FD Register
  WF7816 @offset 0x1d $u8 {
    GTFD:8 // at 0: FD Multiplier
  }

//---  Register ET7816: UART 7816 Error Threshold Register
  ET7816 @offset 0x1e $u8 {
    TXTHRESHOLD:4 // at 4: Transmit NACK Threshold
    RXTHRESHOLD:4 // at 0: Receive NACK Threshold
  }

//---  Register TL7816: UART 7816 Transmit Length Register
  TL7816 @offset 0x1f $u8 {
    TLEN:8 // at 0: Transmit Length
  }

}

//------------------------------------------------------------------------------
// Peripheral USB0: Universal Serial Bus, OTG Capable Controller
//------------------------------------------------------------------------------

registers ©USB0 @at 0x40072000 {
//---  Register PERID: Peripheral ID register
  PERID @offset 0x0 @ro $u8 {
    2
    ID:6 // at 0: Peripheral Identification
  }

//---  Register IDCOMP: Peripheral ID Complement register
  IDCOMP @offset 0x4 @ro $u8 {
    2
    NID:6 // at 0: Ones' complement of PERID[ID]. bits.
  }

//---  Register REV: Peripheral Revision register
  REV @offset 0x8 @ro $u8 {
    REV:8 // at 0: Revision
  }

//---  Register ADDINFO: Peripheral Additional Info register
  ADDINFO @offset 0xc @ro $u8 {
    IRQNUM:5 // at 3: Assigned Interrupt Request Number
    2
    IEHOST // at 0: This bit is set if host mode is enabled.
  }

//---  Register OTGISTAT: OTG Interrupt Status register
  OTGISTAT @offset 0x10 $u8 {
    IDCHG // at 7: This bit is set when a change in the ID Signal from the USB connector is sensed.
    ONEMSEC // at 6: This bit is set when the 1 millisecond timer expires
    LINE_STATE_CHG // at 5: This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits) are stable without change for 1 millisecond, and the value of the line state is different from the last time when the line state was stable
    1
    SESSVLDCHG // at 3: This bit is set when a change in VBUS is detected indicating a session valid or a session no longer valid
    B_SESS_CHG // at 2: This bit is set when a change in VBUS is detected on a B device.
    1
    AVBUSCHG // at 0: This bit is set when a change in VBUS is detected on an A device.
  }

//---  Register OTGICR: OTG Interrupt Control register
  OTGICR @offset 0x14 $u8 {
    IDEN // at 7: ID Interrupt Enable
    ONEMSECEN // at 6: One Millisecond Interrupt Enable
    LINESTATEEN // at 5: Line State Change Interrupt Enable
    1
    SESSVLDEN // at 3: Session Valid Interrupt Enable
    BSESSEN // at 2: B Session END Interrupt Enable
    1
    AVBUSEN // at 0: A VBUS Valid Interrupt Enable
  }

//---  Register OTGSTAT: OTG Status register
  OTGSTAT @offset 0x18 $u8 {
    ID // at 7: Indicates the current state of the ID pin on the USB connector
    ONEMSECEN // at 6: This bit is reserved for the 1ms count, but it is not useful to software.
    LINESTATESTABLE // at 5: Indicates that the internal signals that control the LINE_STATE_CHG field of OTGISTAT are stable for at least 1 millisecond
    1
    SESS_VLD // at 3: Session Valid
    BSESSEND // at 2: B Session End
    1
    AVBUSVLD // at 0: A VBUS Valid
  }

//---  Register OTGCTL: OTG Control register
  OTGCTL @offset 0x1c $u8 {
    DPHIGH // at 7: D+ Data Line pullup resistor enable
    1
    DPLOW // at 5: D+ Data Line pull-down resistor enable
    DMLOW // at 4: D- Data Line pull-down resistor enable
    1
    OTGEN // at 2: On-The-Go pullup/pulldown resistor enable
    2
  }

//---  Register ISTAT: Interrupt Status register
  ISTAT @offset 0x80 $u8 {
    STALL // at 7: Stall Interrupt
    ATTACH // at 6: Attach Interrupt
    RESUME // at 5: This bit is set when a K-state is observed on the DP/DM signals for 2
    SLEEP // at 4: This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms
    TOKDNE // at 3: This bit is set when the current token being processed has completed
    SOFTOK // at 2: This bit is set when the USB Module receives a Start Of Frame (SOF) token
    ERROR // at 1: This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur
    USBRST // at 0: This bit is set when the USB Module has decoded a valid USB reset
  }

//---  Register INTEN: Interrupt Enable register
  INTEN @offset 0x84 $u8 {
    STALLEN // at 7: STALL Interrupt Enable
    ATTACHEN // at 6: ATTACH Interrupt Enable
    RESUMEEN // at 5: RESUME Interrupt Enable
    SLEEPEN // at 4: SLEEP Interrupt Enable
    TOKDNEEN // at 3: TOKDNE Interrupt Enable
    SOFTOKEN // at 2: SOFTOK Interrupt Enable
    ERROREN // at 1: ERROR Interrupt Enable
    USBRSTEN // at 0: USBRST Interrupt Enable
  }

//---  Register ERRSTAT: Error Interrupt Status register
  ERRSTAT @offset 0x88 $u8 {
    BTSERR // at 7: This bit is set when a bit stuff error is detected
    1
    DMAERR // at 5: This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data
    BTOERR // at 4: This bit is set when a bus turnaround timeout error occurs
    DFN8 // at 3: This bit is set if the data field received was not 8 bits in length
    CRC16 // at 2: This bit is set when a data packet is rejected due to a CRC16 error.
    CRC5EOF // at 1: This error interrupt has two functions
    PIDERR // at 0: This bit is set when the PID check field fails.
  }

//---  Register ERREN: Error Interrupt Enable register
  ERREN @offset 0x8c $u8 {
    BTSERREN // at 7: BTSERR Interrupt Enable
    1
    DMAERREN // at 5: DMAERR Interrupt Enable
    BTOERREN // at 4: BTOERR Interrupt Enable
    DFN8EN // at 3: DFN8 Interrupt Enable
    CRC16EN // at 2: CRC16 Interrupt Enable
    CRC5EOFEN // at 1: CRC5/EOF Interrupt Enable
    PIDERREN // at 0: PIDERR Interrupt Enable
  }

//---  Register STAT: Status register
  STAT @offset 0x90 @ro $u8 {
    ENDP:4 // at 4: This four-bit field encodes the endpoint address that received or transmitted the previous token
    TX // at 3: Transmit Indicator
    ODD // at 2: This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.
    2
  }

//---  Register CTL: Control register
  CTL @offset 0x94 $u8 {
    JSTATE // at 7: Live USB differential receiver JSTATE signal
    SE0 // at 6: Live USB Single Ended Zero signal
    TXSUSPENDTOKENBUSY // at 5: In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token
    RESET // at 4: Setting this bit enables the USB Module to generate USB reset signaling
    HOSTMODEEN // at 3: When set to 1, this bit enables the USB Module to operate in Host mode
    RESUME // at 2: When set to 1 this bit enables the USB Module to execute resume signaling
    ODDRST // at 1: Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank
    USBENSOFEN // at 0: USB Enable
  }

//---  Register ADDR: Address register
  ADDR @offset 0x98 $u8 {
    LSEN // at 7: Low Speed Enable bit
    ADDR:7 // at 0: USB Address
  }

//---  Register BDTPAGE1: BDT Page register 1
  BDTPAGE1 @offset 0x9c $u8 {
    BDTBA:7 // at 1: Provides address bits 15 through 9 of the BDT base address.
    1
  }

//---  Register FRMNUML: Frame Number register Low
  FRMNUML @offset 0xa0 $u8 {
    FRM:8 // at 0: This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
  }

//---  Register FRMNUMH: Frame Number register High
  FRMNUMH @offset 0xa4 $u8 {
    5
    FRM:3 // at 0: This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
  }

//---  Register TOKEN: Token register
  TOKEN @offset 0xa8 $u8 {
    TOKENPID:4 // at 4: Contains the token type executed by the USB module.
    TOKENENDPT:4 // at 0: Holds the Endpoint address for the token command
  }

//---  Register SOFTHLD: SOF Threshold register
  SOFTHLD @offset 0xac $u8 {
    CNT:8 // at 0: Represents the SOF count threshold in byte times.
  }

//---  Register BDTPAGE2: BDT Page Register 2
  BDTPAGE2 @offset 0xb0 $u8 {
    BDTBA:8 // at 0: Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
  }

//---  Register BDTPAGE3: BDT Page Register 3
  BDTPAGE3 @offset 0xb4 $u8 {
    BDTBA:8 // at 0: Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
  }

//---  Registers ENDPT(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Endpoint Control register
  #define USB0_ENDPT(idx) (* ((volatile uint8_t *) (0x40072000 + 0xc0 + (idx) * 0x4)))
  #define USB0_ENDPT0 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 0 * 0x4)))
  #define USB0_ENDPT1 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 1 * 0x4)))
  #define USB0_ENDPT2 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 2 * 0x4)))
  #define USB0_ENDPT3 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 3 * 0x4)))
  #define USB0_ENDPT4 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 4 * 0x4)))
  #define USB0_ENDPT5 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 5 * 0x4)))
  #define USB0_ENDPT6 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 6 * 0x4)))
  #define USB0_ENDPT7 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 7 * 0x4)))
  #define USB0_ENDPT8 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 8 * 0x4)))
  #define USB0_ENDPT9 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 9 * 0x4)))
  #define USB0_ENDPT10 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 10 * 0x4)))
  #define USB0_ENDPT11 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 11 * 0x4)))
  #define USB0_ENDPT12 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 12 * 0x4)))
  #define USB0_ENDPT13 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 13 * 0x4)))
  #define USB0_ENDPT14 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 14 * 0x4)))
  #define USB0_ENDPT15 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 15 * 0x4)))
 {
    HOSTWOHUB // at 7: This is a Host mode only field and is present in the control register for endpoint 0 (ENDPT0) only
    RETRYDIS // at 6: This is a Host mode only bit and is present in the control register for endpoint 0 (ENDPT0) only
    1
    EPCTLDIS // at 4: This bit, when set, disables control (SETUP) transfers
    EPRXEN // at 3: This bit, when set, enables the endpoint for RX transfers.
    EPTXEN // at 2: This bit, when set, enables the endpoint for TX transfers.
    EPSTALL // at 1: When set this bit indicates that the endpoint is called
    EPHSHK // at 0: When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint
  }

//---  Register USBCTRL: USB Control register
  USBCTRL @offset 0x100 $u8 {
    SUSP // at 7: Places the USB transceiver into the suspend state.
    PDE // at 6: Enables the weak pulldowns on the USB transceiver.
    6
  }

//---  Register OBSERVE: USB OTG Observe register
  OBSERVE @offset 0x104 @ro $u8 {
    DPPU // at 7: Provides observability of the D+ Pullup enable at the USB transceiver.
    DPPD // at 6: Provides observability of the D+ Pulldown enable at the USB transceiver.
    1
    DMPD // at 4: Provides observability of the D- Pulldown enable at the USB transceiver.
    4
  }

//---  Register CONTROL: USB OTG Control register
  CONTROL @offset 0x108 $u8 {
    3
    DPPULLUPNONOTG // at 4: Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG device mode.
    4
  }

//---  Register USBTRC0: USB Transceiver Control register 0
  USBTRC0 @offset 0x10c $u8 {
    USBRESET // at 7: USB Reset
    1
    USBRESMEN // at 5: Asynchronous Resume Interrupt Enable
    2
    USB_CLK_RECOVERY_INT // at 2: Combined USB Clock Recovery interrupt status
    SYNC_DET // at 1: Synchronous USB Interrupt Detect
    USB_RESUME_INT // at 0: USB Asynchronous Interrupt
  }

//---  Register USBFRMADJUST: Frame Adjust Register
  USBFRMADJUST @offset 0x114 $u8 {
    ADJ:8 // at 0: Frame Adjustment
  }

//---  Register CLK_RECOVER_CTRL: USB Clock recovery control
  CLK_RECOVER_CTRL @offset 0x140 $u8 {
    CLOCK_RECOVER_EN // at 7: Crystal-less USB enable
    RESET_RESUME_ROUGH_EN // at 6: Reset/resume to rough phase enable
    RESTART_IFRTRIM_EN // at 5: Restart from IFR trim value
    5
  }

//---  Register CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
  CLK_RECOVER_IRC_EN @offset 0x144 $u8 {
    6
    IRC_EN // at 1: IRC48M enable
    REG_EN // at 0: IRC48M regulator enable
  }

//---  Register CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
  CLK_RECOVER_INT_STATUS @offset 0x15c $u8 {
    3
    OVF_ERROR // at 4: Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M module
    4
  }

}

//------------------------------------------------------------------------------
// Peripheral USBDCD: USB Device Charger Detection module
//------------------------------------------------------------------------------

registers ©USBDCD @at 0x40035000 {
//---  Register CONTROL: Control register
  CONTROL @offset 0x0 $u32 {
    6
    SR // at 25: Software Reset
    START // at 24: Start Change Detection Sequence
    6
    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.
    IE // at 16: Interrupt Enable
    7
    IF // at 8: Interrupt Flag
    7
    IACK // at 0: Interrupt Acknowledge
  }

//---  Register CLOCK: Clock register
  CLOCK @offset 0x4 $u32 {
    20
    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary
    1
    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed
  }

//---  Register STATUS: Status register
  STATUS @offset 0x8 @ro $u32 {
    9
    ACTIVE // at 22: Active Status Indicator
    TO // at 21: Timeout Flag
    ERR // at 20: Error Flag
    SEQ_STAT:2 // at 18: Charger Detection Sequence Status
    SEQ_RES:2 // at 16: Charger Detection Sequence Results
    16
  }

//---  Register TIMER0: TIMER0 register
  TIMER0 @offset 0x10 $u32 {
    6
    TSEQ_INIT:10 // at 16: Sequence Initiation Time
    4
    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)
  }

//---  Register TIMER1: TIMER1 register
  TIMER1 @offset 0x14 $u32 {
    6
    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal
    6
    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled
  }

//---  Register TIMER2_BC11: TIMER2_BC11 register
  TIMER2_BC11 @offset 0x18 $u32 {
    6
    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup
    12
    CHECK_DM:4 // at 0: Time Before Check of D- Line
  }

//---  Register TIMER2_BC12: TIMER2_BC12 register
  TIMER2_BC12 @offset 0x18 $u32 {
    6
    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    6
    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
  }

}

//------------------------------------------------------------------------------
// Peripheral VREF: Voltage Reference
//------------------------------------------------------------------------------

registers ©VREF @at 0x40074000 {
//---  Register TRM: VREF Trim Register
  TRM @offset 0x0 $u8 {
    1
    CHOPEN // at 6: Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    TRIM:6 // at 0: Trim bits
  }

//---  Register SC: VREF Status and Control Register
  SC @offset 0x1 $u8 {
    VREFEN // at 7: Internal Voltage Reference enable
    REGEN // at 6: Regulator enable
    ICOMPEN // at 5: Second order curvature compensation enable
    2
    VREFST // at 2: Internal Voltage Reference stable
    MODE_LV:2 // at 0: Buffer Mode selection
  }

}

//------------------------------------------------------------------------------
// Peripheral WDOG: Generation 2008 Watchdog Timer
//------------------------------------------------------------------------------

registers ©WDOG @at 0x40052000 {
//---  Register STCTRLH: Watchdog Status and Control Register High
  STCTRLH @offset 0x0 $u16 {
    1
    DISTESTWDOG // at 14: Allows the WDOG's functional test mode to be disabled permanently
    BYTESEL:2 // at 12: This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
    TESTSEL // at 11: Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
    TESTWDOG // at 10: Puts the watchdog in the functional test mode
    2
    WAITEN // at 7: Enables or disables WDOG in Wait mode.
    STOPEN // at 6: Enables or disables WDOG in Stop mode.
    DBGEN // at 5: Enables or disables WDOG in Debug mode.
    ALLOWUPDATE // at 4: Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
    WINEN // at 3: Enables Windowing mode.
    IRQRSTEN // at 2: Used to enable the debug breadcrumbs feature
    CLKSRC // at 1: Selects clock source for the WDOG timer and other internal timing operations.
    WDOGEN // at 0: Enables or disables the WDOG's operation
  }

//---  Register STCTRLL: Watchdog Status and Control Register Low
  STCTRLL @offset 0x2 $u16 {
    INTFLG // at 15: Interrupt flag
    15
  }

//---  Register TOVALH: Watchdog Time-out Value Register High
  TOVALH @offset 0x4 $u16 {
    TOVALHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
  }

//---  Register TOVALL: Watchdog Time-out Value Register Low
  TOVALL @offset 0x6 $u16 {
    TOVALLOW:16 // at 0: Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
  }

//---  Register WINH: Watchdog Window Register High
  WINH @offset 0x8 $u16 {
    WINHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
  }

//---  Register WINL: Watchdog Window Register Low
  WINL @offset 0xa $u16 {
    WINLOW:16 // at 0: Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
  }

//---  Register REFRESH: Watchdog Refresh register
  REFRESH @offset 0xc $u16 {
    WDOGREFRESH:16 // at 0: Watchdog refresh register
  }

//---  Register UNLOCK: Watchdog Unlock register
  UNLOCK @offset 0xe $u16 {
    WDOGUNLOCK:16 // at 0: Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
  }

//---  Register TMROUTH: Watchdog Timer Output Register High
  TMROUTH @offset 0x10 $u16 {
    TIMEROUTHIGH:16 // at 0: Shows the value of the upper 16 bits of the watchdog timer.
  }

//---  Register TMROUTL: Watchdog Timer Output Register Low
  TMROUTL @offset 0x12 $u16 {
    TIMEROUTLOW:16 // at 0: Shows the value of the lower 16 bits of the watchdog timer.
  }

//---  Register RSTCNT: Watchdog Reset Count register
  RSTCNT @offset 0x14 $u16 {
    RSTCNT:16 // at 0: Counts the number of times the watchdog resets the system
  }

//---  Register PRESC: Watchdog Prescaler register
  PRESC @offset 0x16 $u16 {
    5
    PRESCVAL:3 // at 8: 3-bit prescaler for the watchdog clock source
    8
  }

}

//------------------------------------------------------------------------------
// INTERRUPTS
//------------------------------------------------------------------------------

enum class ISRSlot : uint8_t {
  DMA0 = 0,
  DMA1 = 1,
  DMA2 = 2,
  DMA3 = 3,
  DMA4 = 4,
  DMA5 = 5,
  DMA6 = 6,
  DMA7 = 7,
  DMA8 = 8,
  DMA9 = 9,
  DMA10 = 10,
  DMA11 = 11,
  DMA12 = 12,
  DMA13 = 13,
  DMA14 = 14,
  DMA15 = 15,
  DMA_Error = 16,
  MCM = 17,
  FTFE = 18,
  Read_Collision = 19,
  LVD_LVW = 20,
  LLWU = 21,
  WDOG_EWM = 22,
  RNG = 23,
  I2C0 = 24,
  I2C1 = 25,
  SPI0 = 26,
  SPI1 = 27,
  I2S0_Tx = 28,
  I2S0_Rx = 29,
  UART0_LON = 30,
  UART0_RX_TX = 31,
  UART0_ERR = 32,
  UART1_RX_TX = 33,
  UART1_ERR = 34,
  UART2_RX_TX = 35,
  UART2_ERR = 36,
  UART3_RX_TX = 37,
  UART3_ERR = 38,
  ADC0 = 39,
  CMP0 = 40,
  CMP1 = 41,
  FTM0 = 42,
  FTM1 = 43,
  FTM2 = 44,
  CMT = 45,
  RTC = 46,
  RTC_Seconds = 47,
  PIT0 = 48,
  PIT1 = 49,
  PIT2 = 50,
  PIT3 = 51,
  PDB0 = 52,
  USB0 = 53,
  USBDCD = 54,
  DAC0 = 56,
  LPTMR0 = 58,
  PORTA = 59,
  PORTB = 60,
  PORTC = 61,
  PORTD = 62,
  PORTE = 63,
  SPI2 = 65,
  UART4_RX_TX = 66,
  UART4_ERR = 67,
  UART5_RX_TX = 68,
  UART5_ERR = 69,
  CMP2 = 70,
  FTM3 = 71,
  DAC1 = 72,
  ADC1 = 73,
  I2C2 = 74,
  CAN0_ORed_Message_buffer = 75,
  CAN0_Bus_Off = 76,
  CAN0_Error = 77,
  CAN0_Tx_Warning = 78,
  CAN0_Rx_Warning = 79,
  CAN0_Wake_Up = 80,
  SDHC = 81,
  ENET_1588_Timer = 82,
  ENET_Transmit = 83,
  ENET_Receive = 84,
  ENET_Error = 85,
} ;

//------------------------------------------------------------------------------

inline void NVIC_ENABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E100 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------

inline void NVIC_DISABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E180 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------
// BITBAND
//------------------------------------------------------------------------------

inline void bitband32 (const volatile uint32_t & inRegister, const uint8_t inBit, const bool inValue) {
  const uint32_t address = ((uint32_t) &inRegister - 0x40000000) * 32 + ((uint32_t) inBit) * 4 + 0x42000000 ;
  volatile uint32_t * ptr = (volatile uint32_t *) address ;
  *ptr = (uint32_t) inValue ;
}

//------------------------------------------------------------------------------
