//------------------------------------------------------------------------------
// MK66F18: MK66F18 Freescale Microcontroller
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©ADC [2]
//        ADC0 at 0x4003b000
//        ADC1 at 0x400bb000
//------------------------------------------------------------------------------

registers ©ADC [2 @at 0x4003b000 0x400bb000]
          ©ADC0 @at 0x4003b000
          ©ADC1 @at 0x400bb000
{
//---  Registers SC1(A,B): ADC Status and Control Registers 1
  SC1A @offset 0x0 $u32
  SC1B @offset 0x4 $u32 {
    24
    COCO // at 7: Conversion Complete Flag
    AIEN // at 6: Interrupt Enable
    DIFF // at 5: Differential Mode Enable
    ADCH:5 // at 0: Input channel select
  }

//---  Register CFG1: ADC Configuration Register 1
  CFG1 @offset 0x8 $u32 {
    24
    ADLPC // at 7: Low-Power Configuration
    ADIV:2 // at 5: Clock Divide Select
    ADLSMP // at 4: Sample Time Configuration
    MODE:2 // at 2: Conversion mode selection
    ADICLK:2 // at 0: Input Clock Select
  }

//---  Register CFG2: ADC Configuration Register 2
  CFG2 @offset 0xc $u32 {
    27
    MUXSEL // at 4: ADC Mux Select
    ADACKEN // at 3: Asynchronous Clock Output Enable
    ADHSC // at 2: High-Speed Configuration
    ADLSTS:2 // at 0: Long Sample Time Select
  }

//---  Registers R(A,B): ADC Data Result Register
  RA @offset 0x10 @ro $u32
  RB @offset 0x14 @ro $u32 {
    16
    D:16 // at 0: Data result
  }

//---  Registers CV(1,2): Compare Value Registers
  CV1 @offset 0x18 $u32
  CV2 @offset 0x1c $u32 {
    16
    CV:16 // at 0: Compare Value.
  }

//---  Register SC2: Status and Control Register 2
  SC2 @offset 0x20 $u32 {
    24
    ADACT // at 7: Conversion Active
    ADTRG // at 6: Conversion Trigger Select
    ACFE // at 5: Compare Function Enable
    ACFGT // at 4: Compare Function Greater Than Enable
    ACREN // at 3: Compare Function Range Enable
    DMAEN // at 2: DMA Enable
    REFSEL:2 // at 0: Voltage Reference Selection
  }

//---  Register SC3: Status and Control Register 3
  SC3 @offset 0x24 $u32 {
    24
    CAL // at 7: Calibration
    CALF // at 6: Calibration Failed Flag
    2
    ADCO // at 3: Continuous Conversion Enable
    AVGE // at 2: Hardware Average Enable
    AVGS:2 // at 0: Hardware Average Select
  }

//---  Register OFS: ADC Offset Correction Register
  OFS @offset 0x28 $u32 {
    16
    OFS:16 // at 0: Offset Error Correction Value
  }

//---  Register PG: ADC Plus-Side Gain Register
  PG @offset 0x2c $u32 {
    16
    PG:16 // at 0: Plus-Side Gain
  }

//---  Register MG: ADC Minus-Side Gain Register
  MG @offset 0x30 $u32 {
    16
    MG:16 // at 0: Minus-Side Gain
  }

//---  Register CLPD: ADC Plus-Side General Calibration Value Register
  CLPD @offset 0x34 $u32 {
    26
    CLPD:6 // at 0: Calibration Value
  }

//---  Register CLPS: ADC Plus-Side General Calibration Value Register
  CLPS @offset 0x38 $u32 {
    26
    CLPS:6 // at 0: Calibration Value
  }

//---  Register CLP4: ADC Plus-Side General Calibration Value Register
  CLP4 @offset 0x3c $u32 {
    22
    CLP4:10 // at 0: Calibration Value
  }

//---  Register CLP3: ADC Plus-Side General Calibration Value Register
  CLP3 @offset 0x40 $u32 {
    23
    CLP3:9 // at 0: Calibration Value
  }

//---  Register CLP2: ADC Plus-Side General Calibration Value Register
  CLP2 @offset 0x44 $u32 {
    24
    CLP2:8 // at 0: Calibration Value
  }

//---  Register CLP1: ADC Plus-Side General Calibration Value Register
  CLP1 @offset 0x48 $u32 {
    25
    CLP1:7 // at 0: Calibration Value
  }

//---  Register CLP0: ADC Plus-Side General Calibration Value Register
  CLP0 @offset 0x4c $u32 {
    26
    CLP0:6 // at 0: Calibration Value
  }

//---  Register CLMD: ADC Minus-Side General Calibration Value Register
  CLMD @offset 0x54 $u32 {
    26
    CLMD:6 // at 0: Calibration Value
  }

//---  Register CLMS: ADC Minus-Side General Calibration Value Register
  CLMS @offset 0x58 $u32 {
    26
    CLMS:6 // at 0: Calibration Value
  }

//---  Register CLM4: ADC Minus-Side General Calibration Value Register
  CLM4 @offset 0x5c $u32 {
    22
    CLM4:10 // at 0: Calibration Value
  }

//---  Register CLM3: ADC Minus-Side General Calibration Value Register
  CLM3 @offset 0x60 $u32 {
    23
    CLM3:9 // at 0: Calibration Value
  }

//---  Register CLM2: ADC Minus-Side General Calibration Value Register
  CLM2 @offset 0x64 $u32 {
    24
    CLM2:8 // at 0: Calibration Value
  }

//---  Register CLM1: ADC Minus-Side General Calibration Value Register
  CLM1 @offset 0x68 $u32 {
    25
    CLM1:7 // at 0: Calibration Value
  }

//---  Register CLM0: ADC Minus-Side General Calibration Value Register
  CLM0 @offset 0x6c $u32 {
    26
    CLM0:6 // at 0: Calibration Value
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©AIPS [2]
//        AIPS0 at 0x40000000
//        AIPS1 at 0x40080000
//------------------------------------------------------------------------------

registers ©AIPS [2 @at 0x40000000 0x40080000]
          ©AIPS0 @at 0x40000000
          ©AIPS1 @at 0x40080000
{
//---  Register MPRA: Master Privilege Register A
  MPRA @offset 0x0 $u32 {
    1
    MTR0 // at 30: Master 0 Trusted For Read
    MTW0 // at 29: Master 0 Trusted For Writes
    MPL0 // at 28: Master 0 Privilege Level
    1
    MTR1 // at 26: Master 1 Trusted for Read
    MTW1 // at 25: Master 1 Trusted for Writes
    MPL1 // at 24: Master 1 Privilege Level
    1
    MTR2 // at 22: Master 2 Trusted For Read
    MTW2 // at 21: Master 2 Trusted For Writes
    MPL2 // at 20: Master 2 Privilege Level
    1
    MTR3 // at 18: Master 3 Trusted For Read
    MTW3 // at 17: Master 3 Trusted For Writes
    MPL3 // at 16: Master 3 Privilege Level
    1
    MTR4 // at 14: Master 4 Trusted For Read
    MTW4 // at 13: Master 4 Trusted For Writes
    MPL4 // at 12: Master 4 Privilege Level
    1
    MTR5 // at 10: Master 5 Trusted For Read
    MTW5 // at 9: Master 5 Trusted For Writes
    MPL5 // at 8: Master 5 Privilege Level
    1
    MTR6 // at 6: Master 6 Trusted for Read
    MTW6 // at 5: Master 6 Trusted for Writes
    MPL6 // at 4: Master 6 Privilege Level
    4
  }

//---  Register PACRA: Peripheral Access Control Register
  PACRA @offset 0x20 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRB: Peripheral Access Control Register
  PACRB @offset 0x24 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRC: Peripheral Access Control Register
  PACRC @offset 0x28 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRD: Peripheral Access Control Register
  PACRD @offset 0x2c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRE: Peripheral Access Control Register
  PACRE @offset 0x40 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRF: Peripheral Access Control Register
  PACRF @offset 0x44 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRG: Peripheral Access Control Register
  PACRG @offset 0x48 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRH: Peripheral Access Control Register
  PACRH @offset 0x4c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRI: Peripheral Access Control Register
  PACRI @offset 0x50 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRJ: Peripheral Access Control Register
  PACRJ @offset 0x54 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRK: Peripheral Access Control Register
  PACRK @offset 0x58 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRL: Peripheral Access Control Register
  PACRL @offset 0x5c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRM: Peripheral Access Control Register
  PACRM @offset 0x60 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRN: Peripheral Access Control Register
  PACRN @offset 0x64 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRO: Peripheral Access Control Register
  PACRO @offset 0x68 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRP: Peripheral Access Control Register
  PACRP @offset 0x6c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

}

//------------------------------------------------------------------------------
// Peripheral AXBS: Crossbar switch
//------------------------------------------------------------------------------

registers ©AXBS @at 0x40004000 {
//---  Registers PRS(0,1,2,3,4): Priority Registers Slave
  #define AXBS_PRS(idx) (* ((volatile uint32_t *) (0x40004000 + 0x0 + (idx) * 0x100)))
  #define AXBS_PRS0 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 0 * 0x100)))
  #define AXBS_PRS1 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 1 * 0x100)))
  #define AXBS_PRS2 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 2 * 0x100)))
  #define AXBS_PRS3 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 3 * 0x100)))
  #define AXBS_PRS4 (* ((volatile uint32_t *) (0x40004000 + 0x0 + 4 * 0x100)))
 {
    5
    M6:3 // at 24: Master 6 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M5:3 // at 20: Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M4:3 // at 16: Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M3:3 // at 12: Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M2:3 // at 8: Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M1:3 // at 4: Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M0:3 // at 0: Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
  }

//---  Registers CRS(0,1,2,3,4): Control Register
  #define AXBS_CRS(idx) (* ((volatile uint32_t *) (0x40004000 + 0x10 + (idx) * 0x100)))
  #define AXBS_CRS0 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 0 * 0x100)))
  #define AXBS_CRS1 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 1 * 0x100)))
  #define AXBS_CRS2 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 2 * 0x100)))
  #define AXBS_CRS3 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 3 * 0x100)))
  #define AXBS_CRS4 (* ((volatile uint32_t *) (0x40004000 + 0x10 + 4 * 0x100)))
 {
    RO // at 31: Read Only
    HLP // at 30: Halt Low Priority
    20
    ARB:2 // at 8: Arbitration Mode
    2
    PCTL:2 // at 4: Parking Control
    1
    PARK:3 // at 0: Park
  }

//---  Registers MGPCR(0,1,2,3,4,5,6): Master General Purpose Control Register
  #define AXBS_MGPCR(idx) (* ((volatile uint32_t *) (0x40004000 + 0x800 + (idx) * 0x100)))
  #define AXBS_MGPCR0 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 0 * 0x100)))
  #define AXBS_MGPCR1 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 1 * 0x100)))
  #define AXBS_MGPCR2 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 2 * 0x100)))
  #define AXBS_MGPCR3 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 3 * 0x100)))
  #define AXBS_MGPCR4 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 4 * 0x100)))
  #define AXBS_MGPCR5 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 5 * 0x100)))
  #define AXBS_MGPCR6 (* ((volatile uint32_t *) (0x40004000 + 0x800 + 6 * 0x100)))
 {
    29
    AULB:3 // at 0: Arbitrates On Undefined Length Bursts
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©CAN [2]
//        CAN0 at 0x40024000
//        CAN1 at 0x400a4000
//------------------------------------------------------------------------------

registers ©CAN [2 @at 0x40024000 0x400a4000]
          ©CAN0 @at 0x40024000
          ©CAN1 @at 0x400a4000
{
//---  Register MCR: Module Configuration Register
  MCR @offset 0x0 $u32 {
    MDIS // at 31: Module Disable
    FRZ // at 30: Freeze Enable
    RFEN // at 29: Rx FIFO Enable
    HALT // at 28: Halt FlexCAN
    NOTRDY // at 27: FlexCAN Not Ready
    WAKMSK // at 26: Wake Up Interrupt Mask
    SOFTRST // at 25: Soft Reset
    FRZACK // at 24: Freeze Mode Acknowledge
    SUPV // at 23: Supervisor Mode
    SLFWAK // at 22: Self Wake Up
    WRNEN // at 21: Warning Interrupt Enable
    LPMACK // at 20: Low-Power Mode Acknowledge
    WAKSRC // at 19: Wake Up Source
    1
    SRXDIS // at 17: Self Reception Disable
    IRMQ // at 16: Individual Rx Masking And Queue Enable
    2
    LPRIOEN // at 13: Local Priority Enable
    AEN // at 12: Abort Enable
    2
    IDAM:2 // at 8: ID Acceptance Mode
    1
    MAXMB:7 // at 0: Number Of The Last Message Buffer
  }

//---  Register CTRL1: Control 1 register
  CTRL1 @offset 0x4 $u32 {
    PRESDIV:8 // at 24: Prescaler Division Factor
    RJW:2 // at 22: Resync Jump Width
    PSEG1:3 // at 19: Phase Segment 1
    PSEG2:3 // at 16: Phase Segment 2
    BOFFMSK // at 15: Bus Off Mask
    ERRMSK // at 14: Error Mask
    CLKSRC // at 13: CAN Engine Clock Source
    LPB // at 12: Loop Back Mode
    TWRNMSK // at 11: Tx Warning Interrupt Mask
    RWRNMSK // at 10: Rx Warning Interrupt Mask
    2
    SMP // at 7: CAN Bit Sampling
    BOFFREC // at 6: Bus Off Recovery
    TSYN // at 5: Timer Sync
    LBUF // at 4: Lowest Buffer Transmitted First
    LOM // at 3: Listen-Only Mode
    PROPSEG:3 // at 0: Propagation Segment
  }

//---  Register TIMER: Free Running Timer
  TIMER @offset 0x8 $u32 {
    16
    TIMER:16 // at 0: Timer Value
  }

//---  Register RXMGMASK: Rx Mailboxes Global Mask Register
  RXMGMASK @offset 0x10 $u32 {
    MG:32 // at 0: Rx Mailboxes Global Mask Bits
  }

//---  Register RX14MASK: Rx 14 Mask register
  RX14MASK @offset 0x14 $u32 {
    RX14M:32 // at 0: Rx Buffer 14 Mask Bits
  }

//---  Register RX15MASK: Rx 15 Mask register
  RX15MASK @offset 0x18 $u32 {
    RX15M:32 // at 0: Rx Buffer 15 Mask Bits
  }

//---  Register ECR: Error Counter
  ECR @offset 0x1c $u32 {
    16
    RXERRCNT:8 // at 8: Receive Error Counter
    TXERRCNT:8 // at 0: Transmit Error Counter
  }

//---  Register ESR1: Error and Status 1 register
  ESR1 @offset 0x20 $u32 {
    13
    SYNCH // at 18: CAN Synchronization Status
    TWRNINT // at 17: Tx Warning Interrupt Flag
    RWRNINT // at 16: Rx Warning Interrupt Flag
    BIT1ERR // at 15: Bit1 Error
    BIT0ERR // at 14: Bit0 Error
    ACKERR // at 13: Acknowledge Error
    CRCERR // at 12: Cyclic Redundancy Check Error
    FRMERR // at 11: Form Error
    STFERR // at 10: Stuffing Error
    TXWRN // at 9: TX Error Warning
    RXWRN // at 8: Rx Error Warning
    IDLE // at 7: This bit indicates when CAN bus is in IDLE state
    TX // at 6: FlexCAN In Transmission
    FLTCONF:2 // at 4: Fault Confinement State
    RX // at 3: FlexCAN In Reception
    BOFFINT // at 2: Bus Off Interrupt
    ERRINT // at 1: Error Interrupt
    WAKINT // at 0: Wake-Up Interrupt
  }

//---  Register IMASK1: Interrupt Masks 1 register
  IMASK1 @offset 0x28 $u32 {
    BUFLM:32 // at 0: Buffer MB i Mask
  }

//---  Register IFLAG1: Interrupt Flags 1 register
  IFLAG1 @offset 0x30 $u32 {
    BUF31TO8I:24 // at 8: Buffer MBi Interrupt
    BUF7I // at 7: Buffer MB7 Interrupt Or "Rx FIFO Overflow"
    BUF6I // at 6: Buffer MB6 Interrupt Or "Rx FIFO Warning"
    BUF5I // at 5: Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
    BUF4TO1I:4 // at 1: Buffer MB i Interrupt Or "reserved"
    BUF0I // at 0: Buffer MB0 Interrupt Or "reserved"
  }

//---  Register CTRL2: Control 2 register
  CTRL2 @offset 0x34 $u32 {
    3
    WRMFRZ // at 28: Write-Access To Memory In Freeze Mode
    RFFN:4 // at 24: Number Of Rx FIFO Filters
    TASD:5 // at 19: Tx Arbitration Start Delay
    MRP // at 18: Mailboxes Reception Priority
    RRS // at 17: Remote Request Storing
    EACEN // at 16: Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
    16
  }

//---  Register ESR2: Error and Status 2 register
  ESR2 @offset 0x38 @ro $u32 {
    9
    LPTM:7 // at 16: Lowest Priority Tx Mailbox
    1
    VPS // at 14: Valid Priority Status
    IMB // at 13: Inactive Mailbox
    13
  }

//---  Register CRCR: CRC Register
  CRCR @offset 0x44 @ro $u32 {
    9
    MBCRC:7 // at 16: CRC Mailbox
    1
    TXCRC:15 // at 0: CRC Transmitted
  }

//---  Register RXFGMASK: Rx FIFO Global Mask register
  RXFGMASK @offset 0x48 $u32 {
    FGM:32 // at 0: Rx FIFO Global Mask Bits
  }

//---  Register RXFIR: Rx FIFO Information Register
  RXFIR @offset 0x4c @ro $u32 {
    23
    IDHIT:9 // at 0: Identifier Acceptance Filter Hit Indicator
  }

//---  Register CS0: Message Buffer 0 CS Register
  CS0 @offset 0x80 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID0: Message Buffer 0 ID Register
  ID0 @offset 0x84 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD00: Message Buffer 0 WORD0 Register
  WORD00 @offset 0x88 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD10: Message Buffer 0 WORD1 Register
  WORD10 @offset 0x8c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS1: Message Buffer 1 CS Register
  CS1 @offset 0x90 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID1: Message Buffer 1 ID Register
  ID1 @offset 0x94 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD01: Message Buffer 1 WORD0 Register
  WORD01 @offset 0x98 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD11: Message Buffer 1 WORD1 Register
  WORD11 @offset 0x9c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS2: Message Buffer 2 CS Register
  CS2 @offset 0xa0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID2: Message Buffer 2 ID Register
  ID2 @offset 0xa4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD02: Message Buffer 2 WORD0 Register
  WORD02 @offset 0xa8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD12: Message Buffer 2 WORD1 Register
  WORD12 @offset 0xac $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS3: Message Buffer 3 CS Register
  CS3 @offset 0xb0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID3: Message Buffer 3 ID Register
  ID3 @offset 0xb4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD03: Message Buffer 3 WORD0 Register
  WORD03 @offset 0xb8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD13: Message Buffer 3 WORD1 Register
  WORD13 @offset 0xbc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS4: Message Buffer 4 CS Register
  CS4 @offset 0xc0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID4: Message Buffer 4 ID Register
  ID4 @offset 0xc4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD04: Message Buffer 4 WORD0 Register
  WORD04 @offset 0xc8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD14: Message Buffer 4 WORD1 Register
  WORD14 @offset 0xcc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS5: Message Buffer 5 CS Register
  CS5 @offset 0xd0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID5: Message Buffer 5 ID Register
  ID5 @offset 0xd4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD05: Message Buffer 5 WORD0 Register
  WORD05 @offset 0xd8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD15: Message Buffer 5 WORD1 Register
  WORD15 @offset 0xdc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS6: Message Buffer 6 CS Register
  CS6 @offset 0xe0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID6: Message Buffer 6 ID Register
  ID6 @offset 0xe4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD06: Message Buffer 6 WORD0 Register
  WORD06 @offset 0xe8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD16: Message Buffer 6 WORD1 Register
  WORD16 @offset 0xec $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS7: Message Buffer 7 CS Register
  CS7 @offset 0xf0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID7: Message Buffer 7 ID Register
  ID7 @offset 0xf4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD07: Message Buffer 7 WORD0 Register
  WORD07 @offset 0xf8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD17: Message Buffer 7 WORD1 Register
  WORD17 @offset 0xfc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS8: Message Buffer 8 CS Register
  CS8 @offset 0x100 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID8: Message Buffer 8 ID Register
  ID8 @offset 0x104 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD08: Message Buffer 8 WORD0 Register
  WORD08 @offset 0x108 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD18: Message Buffer 8 WORD1 Register
  WORD18 @offset 0x10c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS9: Message Buffer 9 CS Register
  CS9 @offset 0x110 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID9: Message Buffer 9 ID Register
  ID9 @offset 0x114 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD09: Message Buffer 9 WORD0 Register
  WORD09 @offset 0x118 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD19: Message Buffer 9 WORD1 Register
  WORD19 @offset 0x11c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS10: Message Buffer 10 CS Register
  CS10 @offset 0x120 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID10: Message Buffer 10 ID Register
  ID10 @offset 0x124 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD010: Message Buffer 10 WORD0 Register
  WORD010 @offset 0x128 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD110: Message Buffer 10 WORD1 Register
  WORD110 @offset 0x12c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS11: Message Buffer 11 CS Register
  CS11 @offset 0x130 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID11: Message Buffer 11 ID Register
  ID11 @offset 0x134 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD011: Message Buffer 11 WORD0 Register
  WORD011 @offset 0x138 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD111: Message Buffer 11 WORD1 Register
  WORD111 @offset 0x13c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS12: Message Buffer 12 CS Register
  CS12 @offset 0x140 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID12: Message Buffer 12 ID Register
  ID12 @offset 0x144 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD012: Message Buffer 12 WORD0 Register
  WORD012 @offset 0x148 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD112: Message Buffer 12 WORD1 Register
  WORD112 @offset 0x14c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS13: Message Buffer 13 CS Register
  CS13 @offset 0x150 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID13: Message Buffer 13 ID Register
  ID13 @offset 0x154 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD013: Message Buffer 13 WORD0 Register
  WORD013 @offset 0x158 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD113: Message Buffer 13 WORD1 Register
  WORD113 @offset 0x15c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS14: Message Buffer 14 CS Register
  CS14 @offset 0x160 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID14: Message Buffer 14 ID Register
  ID14 @offset 0x164 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD014: Message Buffer 14 WORD0 Register
  WORD014 @offset 0x168 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD114: Message Buffer 14 WORD1 Register
  WORD114 @offset 0x16c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS15: Message Buffer 15 CS Register
  CS15 @offset 0x170 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID15: Message Buffer 15 ID Register
  ID15 @offset 0x174 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD015: Message Buffer 15 WORD0 Register
  WORD015 @offset 0x178 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD115: Message Buffer 15 WORD1 Register
  WORD115 @offset 0x17c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Registers RXIMR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Rx Individual Mask Registers
  RXIMR0 @offset 0x880 $u32
  RXIMR1 @offset 0x884 $u32
  RXIMR2 @offset 0x888 $u32
  RXIMR3 @offset 0x88c $u32
  RXIMR4 @offset 0x890 $u32
  RXIMR5 @offset 0x894 $u32
  RXIMR6 @offset 0x898 $u32
  RXIMR7 @offset 0x89c $u32
  RXIMR8 @offset 0x8a0 $u32
  RXIMR9 @offset 0x8a4 $u32
  RXIMR10 @offset 0x8a8 $u32
  RXIMR11 @offset 0x8ac $u32
  RXIMR12 @offset 0x8b0 $u32
  RXIMR13 @offset 0x8b4 $u32
  RXIMR14 @offset 0x8b8 $u32
  RXIMR15 @offset 0x8bc $u32 {
    MI:32 // at 0: Individual Mask Bits
  }

}

//------------------------------------------------------------------------------
// Peripheral CAU: Memory Mapped Cryptographic Acceleration Unit (MMCAU)
//------------------------------------------------------------------------------

registers ©CAU @at 0xe0081000 {
//---  Register CAU_DIRECT0: Direct access register 0
  CAU_DIRECT0 @offset 0x0 $u32 {
    CAU_DIRECT0:32 // at 0: Direct register 0
  }

//---  Register CAU_DIRECT1: Direct access register 1
  CAU_DIRECT1 @offset 0x4 $u32 {
    CAU_DIRECT1:32 // at 0: Direct register 1
  }

//---  Register CAU_DIRECT2: Direct access register 2
  CAU_DIRECT2 @offset 0x8 $u32 {
    CAU_DIRECT2:32 // at 0: Direct register 2
  }

//---  Register CAU_DIRECT3: Direct access register 3
  CAU_DIRECT3 @offset 0xc $u32 {
    CAU_DIRECT3:32 // at 0: Direct register 3
  }

//---  Register CAU_DIRECT4: Direct access register 4
  CAU_DIRECT4 @offset 0x10 $u32 {
    CAU_DIRECT4:32 // at 0: Direct register 4
  }

//---  Register CAU_DIRECT5: Direct access register 5
  CAU_DIRECT5 @offset 0x14 $u32 {
    CAU_DIRECT5:32 // at 0: Direct register 5
  }

//---  Register CAU_DIRECT6: Direct access register 6
  CAU_DIRECT6 @offset 0x18 $u32 {
    CAU_DIRECT6:32 // at 0: Direct register 6
  }

//---  Register CAU_DIRECT7: Direct access register 7
  CAU_DIRECT7 @offset 0x1c $u32 {
    CAU_DIRECT7:32 // at 0: Direct register 7
  }

//---  Register CAU_DIRECT8: Direct access register 8
  CAU_DIRECT8 @offset 0x20 $u32 {
    CAU_DIRECT8:32 // at 0: Direct register 8
  }

//---  Register CAU_DIRECT9: Direct access register 9
  CAU_DIRECT9 @offset 0x24 $u32 {
    CAU_DIRECT9:32 // at 0: Direct register 9
  }

//---  Register CAU_DIRECT10: Direct access register 10
  CAU_DIRECT10 @offset 0x28 $u32 {
    CAU_DIRECT10:32 // at 0: Direct register 10
  }

//---  Register CAU_DIRECT11: Direct access register 11
  CAU_DIRECT11 @offset 0x2c $u32 {
    CAU_DIRECT11:32 // at 0: Direct register 11
  }

//---  Register CAU_DIRECT12: Direct access register 12
  CAU_DIRECT12 @offset 0x30 $u32 {
    CAU_DIRECT12:32 // at 0: Direct register 12
  }

//---  Register CAU_DIRECT13: Direct access register 13
  CAU_DIRECT13 @offset 0x34 $u32 {
    CAU_DIRECT13:32 // at 0: Direct register 13
  }

//---  Register CAU_DIRECT14: Direct access register 14
  CAU_DIRECT14 @offset 0x38 $u32 {
    CAU_DIRECT14:32 // at 0: Direct register 14
  }

//---  Register CAU_DIRECT15: Direct access register 15
  CAU_DIRECT15 @offset 0x3c $u32 {
    CAU_DIRECT15:32 // at 0: Direct register 15
  }

//---  Register CAU_LDR_CASR: Status register - Load Register command
  CAU_LDR_CASR @offset 0x840 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_LDR_CAA: Accumulator register - Load Register command
  CAU_LDR_CAA @offset 0x844 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_LDR_CA0: General Purpose Register 0 - Load Register command
  CAU_LDR_CA0 @offset 0x848 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_LDR_CA1: General Purpose Register 1 - Load Register command
  CAU_LDR_CA1 @offset 0x84c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_LDR_CA2: General Purpose Register 2 - Load Register command
  CAU_LDR_CA2 @offset 0x850 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_LDR_CA3: General Purpose Register 3 - Load Register command
  CAU_LDR_CA3 @offset 0x854 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_LDR_CA4: General Purpose Register 4 - Load Register command
  CAU_LDR_CA4 @offset 0x858 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_LDR_CA5: General Purpose Register 5 - Load Register command
  CAU_LDR_CA5 @offset 0x85c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_LDR_CA6: General Purpose Register 6 - Load Register command
  CAU_LDR_CA6 @offset 0x860 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_LDR_CA7: General Purpose Register 7 - Load Register command
  CAU_LDR_CA7 @offset 0x864 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_LDR_CA8: General Purpose Register 8 - Load Register command
  CAU_LDR_CA8 @offset 0x868 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_STR_CASR: Status register - Store Register command
  CAU_STR_CASR @offset 0x880 @ro $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_STR_CAA: Accumulator register - Store Register command
  CAU_STR_CAA @offset 0x884 @ro $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_STR_CA0: General Purpose Register 0 - Store Register command
  CAU_STR_CA0 @offset 0x888 @ro $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_STR_CA1: General Purpose Register 1 - Store Register command
  CAU_STR_CA1 @offset 0x88c @ro $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_STR_CA2: General Purpose Register 2 - Store Register command
  CAU_STR_CA2 @offset 0x890 @ro $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_STR_CA3: General Purpose Register 3 - Store Register command
  CAU_STR_CA3 @offset 0x894 @ro $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_STR_CA4: General Purpose Register 4 - Store Register command
  CAU_STR_CA4 @offset 0x898 @ro $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_STR_CA5: General Purpose Register 5 - Store Register command
  CAU_STR_CA5 @offset 0x89c @ro $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_STR_CA6: General Purpose Register 6 - Store Register command
  CAU_STR_CA6 @offset 0x8a0 @ro $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_STR_CA7: General Purpose Register 7 - Store Register command
  CAU_STR_CA7 @offset 0x8a4 @ro $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_STR_CA8: General Purpose Register 8 - Store Register command
  CAU_STR_CA8 @offset 0x8a8 @ro $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_ADR_CASR: Status register - Add Register command
  CAU_ADR_CASR @offset 0x8c0 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_ADR_CAA: Accumulator register - Add to register command
  CAU_ADR_CAA @offset 0x8c4 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_ADR_CA0: General Purpose Register 0 - Add to register command
  CAU_ADR_CA0 @offset 0x8c8 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_ADR_CA1: General Purpose Register 1 - Add to register command
  CAU_ADR_CA1 @offset 0x8cc $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_ADR_CA2: General Purpose Register 2 - Add to register command
  CAU_ADR_CA2 @offset 0x8d0 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_ADR_CA3: General Purpose Register 3 - Add to register command
  CAU_ADR_CA3 @offset 0x8d4 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_ADR_CA4: General Purpose Register 4 - Add to register command
  CAU_ADR_CA4 @offset 0x8d8 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_ADR_CA5: General Purpose Register 5 - Add to register command
  CAU_ADR_CA5 @offset 0x8dc $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_ADR_CA6: General Purpose Register 6 - Add to register command
  CAU_ADR_CA6 @offset 0x8e0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_ADR_CA7: General Purpose Register 7 - Add to register command
  CAU_ADR_CA7 @offset 0x8e4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_ADR_CA8: General Purpose Register 8 - Add to register command
  CAU_ADR_CA8 @offset 0x8e8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_RADR_CASR: Status register - Reverse and Add to Register command
  CAU_RADR_CASR @offset 0x900 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
  CAU_RADR_CAA @offset 0x904 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
  CAU_RADR_CA0 @offset 0x908 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
  CAU_RADR_CA1 @offset 0x90c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
  CAU_RADR_CA2 @offset 0x910 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
  CAU_RADR_CA3 @offset 0x914 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
  CAU_RADR_CA4 @offset 0x918 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
  CAU_RADR_CA5 @offset 0x91c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
  CAU_RADR_CA6 @offset 0x920 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
  CAU_RADR_CA7 @offset 0x924 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
  CAU_RADR_CA8 @offset 0x928 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_XOR_CASR: Status register - Exclusive Or command
  CAU_XOR_CASR @offset 0x980 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_XOR_CAA: Accumulator register - Exclusive Or command
  CAU_XOR_CAA @offset 0x984 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
  CAU_XOR_CA0 @offset 0x988 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
  CAU_XOR_CA1 @offset 0x98c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
  CAU_XOR_CA2 @offset 0x990 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
  CAU_XOR_CA3 @offset 0x994 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
  CAU_XOR_CA4 @offset 0x998 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
  CAU_XOR_CA5 @offset 0x99c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
  CAU_XOR_CA6 @offset 0x9a0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
  CAU_XOR_CA7 @offset 0x9a4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
  CAU_XOR_CA8 @offset 0x9a8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_ROTL_CASR: Status register - Rotate Left command
  CAU_ROTL_CASR @offset 0x9c0 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_ROTL_CAA: Accumulator register - Rotate Left command
  CAU_ROTL_CAA @offset 0x9c4 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
  CAU_ROTL_CA0 @offset 0x9c8 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
  CAU_ROTL_CA1 @offset 0x9cc $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
  CAU_ROTL_CA2 @offset 0x9d0 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
  CAU_ROTL_CA3 @offset 0x9d4 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
  CAU_ROTL_CA4 @offset 0x9d8 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
  CAU_ROTL_CA5 @offset 0x9dc $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
  CAU_ROTL_CA6 @offset 0x9e0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
  CAU_ROTL_CA7 @offset 0x9e4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
  CAU_ROTL_CA8 @offset 0x9e8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_AESC_CASR: Status register - AES Column Operation command
  CAU_AESC_CASR @offset 0xb00 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_AESC_CAA: Accumulator register - AES Column Operation command
  CAU_AESC_CAA @offset 0xb04 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
  CAU_AESC_CA0 @offset 0xb08 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
  CAU_AESC_CA1 @offset 0xb0c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
  CAU_AESC_CA2 @offset 0xb10 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
  CAU_AESC_CA3 @offset 0xb14 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
  CAU_AESC_CA4 @offset 0xb18 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
  CAU_AESC_CA5 @offset 0xb1c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
  CAU_AESC_CA6 @offset 0xb20 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
  CAU_AESC_CA7 @offset 0xb24 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
  CAU_AESC_CA8 @offset 0xb28 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
  CAU_AESIC_CASR @offset 0xb40 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
  CAU_AESIC_CAA @offset 0xb44 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
  CAU_AESIC_CA0 @offset 0xb48 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
  CAU_AESIC_CA1 @offset 0xb4c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
  CAU_AESIC_CA2 @offset 0xb50 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
  CAU_AESIC_CA3 @offset 0xb54 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
  CAU_AESIC_CA4 @offset 0xb58 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
  CAU_AESIC_CA5 @offset 0xb5c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
  CAU_AESIC_CA6 @offset 0xb60 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
  CAU_AESIC_CA7 @offset 0xb64 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
  CAU_AESIC_CA8 @offset 0xb68 $u32 {
    CA8:32 // at 0: CA8
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©CMP [4]
//        CMP0 at 0x40073000
//        CMP1 at 0x40073008
//        CMP2 at 0x40073010
//        CMP3 at 0x40073018
//------------------------------------------------------------------------------

registers ©CMP [4 @at 0x40073000 0x40073008 0x40073010 0x40073018]
          ©CMP0 @at 0x40073000
          ©CMP1 @at 0x40073008
          ©CMP2 @at 0x40073010
          ©CMP3 @at 0x40073018
{
//---  Register CR0: CMP Control Register 0
  CR0 @offset 0x0 $u8 {
    1
    FILTER_CNT:3 // at 4: Filter Sample Count
    2
    HYSTCTR:2 // at 0: Comparator hard block hysteresis control
  }

//---  Register CR1: CMP Control Register 1
  CR1 @offset 0x1 $u8 {
    SE // at 7: Sample Enable
    WE // at 6: Windowing Enable
    TRIGM // at 5: Trigger Mode Enable
    PMODE // at 4: Power Mode Select
    INV // at 3: Comparator INVERT
    COS // at 2: Comparator Output Select
    OPE // at 1: Comparator Output Pin Enable
    EN // at 0: Comparator Module Enable
  }

//---  Register FPR: CMP Filter Period Register
  FPR @offset 0x2 $u8 {
    FILT_PER:8 // at 0: Filter Sample Period
  }

//---  Register SCR: CMP Status and Control Register
  SCR @offset 0x3 $u8 {
    1
    DMAEN // at 6: DMA Enable Control
    1
    IER // at 4: Comparator Interrupt Enable Rising
    IEF // at 3: Comparator Interrupt Enable Falling
    CFR // at 2: Analog Comparator Flag Rising
    CFF // at 1: Analog Comparator Flag Falling
    COUT // at 0: Analog Comparator Output
  }

//---  Register DACCR: DAC Control Register
  DACCR @offset 0x4 $u8 {
    DACEN // at 7: DAC Enable
    VRSEL // at 6: Supply Voltage Reference Source Select
    VOSEL:6 // at 0: DAC Output Voltage Select
  }

//---  Register MUXCR: MUX Control Register
  MUXCR @offset 0x5 $u8 {
    PSTM // at 7: Pass Through Mode Enable
    1
    PSEL:3 // at 3: Plus Input Mux Control
    MSEL:3 // at 0: Minus Input Mux Control
  }

}

//------------------------------------------------------------------------------
// Peripheral CMT: Carrier Modulator Transmitter
//------------------------------------------------------------------------------

registers ©CMT @at 0x40062000 {
//---  Register CGH1: CMT Carrier Generator High Data Register 1
  CGH1 @offset 0x0 $u8 {
    PH:8 // at 0: Primary Carrier High Time Data Value
  }

//---  Register CGL1: CMT Carrier Generator Low Data Register 1
  CGL1 @offset 0x1 $u8 {
    PL:8 // at 0: Primary Carrier Low Time Data Value
  }

//---  Register CGH2: CMT Carrier Generator High Data Register 2
  CGH2 @offset 0x2 $u8 {
    SH:8 // at 0: Secondary Carrier High Time Data Value
  }

//---  Register CGL2: CMT Carrier Generator Low Data Register 2
  CGL2 @offset 0x3 $u8 {
    SL:8 // at 0: Secondary Carrier Low Time Data Value
  }

//---  Register OC: CMT Output Control Register
  OC @offset 0x4 $u8 {
    IROL // at 7: IRO Latch Control
    CMTPOL // at 6: CMT Output Polarity
    IROPEN // at 5: IRO Pin Enable
    5
  }

//---  Register MSC: CMT Modulator Status and Control Register
  MSC @offset 0x5 $u8 {
    EOCF // at 7: End Of Cycle Status Flag
    CMTDIV:2 // at 5: CMT Clock Divide Prescaler
    EXSPC // at 4: Extended Space Enable
    BASE // at 3: Baseband Enable
    FSK // at 2: FSK Mode Select
    EOCIE // at 1: End of Cycle Interrupt Enable
    MCGEN // at 0: Modulator and Carrier Generator Enable
  }

//---  Register CMD1: CMT Modulator Data Register Mark High
  CMD1 @offset 0x6 $u8 {
    MB:8 // at 0: MB[15:8]
  }

//---  Register CMD2: CMT Modulator Data Register Mark Low
  CMD2 @offset 0x7 $u8 {
    MB:8 // at 0: MB[7:0]
  }

//---  Register CMD3: CMT Modulator Data Register Space High
  CMD3 @offset 0x8 $u8 {
    SB:8 // at 0: SB[15:8]
  }

//---  Register CMD4: CMT Modulator Data Register Space Low
  CMD4 @offset 0x9 $u8 {
    SB:8 // at 0: SB[7:0]
  }

//---  Register PPS: CMT Primary Prescaler Register
  PPS @offset 0xa $u8 {
    4
    PPSDIV:4 // at 0: Primary Prescaler Divider
  }

//---  Register DMA: CMT Direct Memory Access Register
  DMA @offset 0xb $u8 {
    7
    DMA // at 0: DMA Enable
  }

}

//------------------------------------------------------------------------------
// Peripheral CRC: Cyclic Redundancy Check
//------------------------------------------------------------------------------

registers ©CRC @at 0x40032000 {
//---  Register DATA: CRC Data register
  DATA @offset 0x0 $u32 {
    HU:8 // at 24: CRC High Upper Byte
    HL:8 // at 16: CRC High Lower Byte
    LU:8 // at 8: CRC Low Upper Byte
    LL:8 // at 0: CRC Low Lower Byte
  }

//---  Register DATAL: CRC_DATAL register.
  DATAL @offset 0x0 $u16 {
    DATAL:16 // at 0: DATAL stores the lower 16 bits of the 16/32 bit CRC
  }

//---  Register DATALL: CRC_DATALL register.
  DATALL @offset 0x0 $u8 {
    DATALL:8 // at 0: CRCLL stores the first 8 bits of the 32 bit DATA
  }

//---  Register DATALU: CRC_DATALU register.
  DATALU @offset 0x1 $u8 {
    DATALU:8 // at 0: DATALL stores the second 8 bits of the 32 bit CRC
  }

//---  Register DATAH: CRC_DATAH register.
  DATAH @offset 0x2 $u16 {
    DATAH:16 // at 0: DATAH stores the high 16 bits of the 16/32 bit CRC
  }

//---  Register DATAHL: CRC_DATAHL register.
  DATAHL @offset 0x2 $u8 {
    DATAHL:8 // at 0: DATAHL stores the third 8 bits of the 32 bit CRC
  }

//---  Register DATAHU: CRC_DATAHU register.
  DATAHU @offset 0x3 $u8 {
    DATAHU:8 // at 0: DATAHU stores the fourth 8 bits of the 32 bit CRC
  }

//---  Register GPOLY: CRC Polynomial register
  GPOLY @offset 0x4 $u32 {
    HIGH:16 // at 16: High Polynominal Half-word
    LOW:16 // at 0: Low Polynominal Half-word
  }

//---  Register GPOLYL: CRC_GPOLYL register.
  GPOLYL @offset 0x4 $u16 {
    GPOLYL:16 // at 0: POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
  }

//---  Register GPOLYLL: CRC_GPOLYLL register.
  GPOLYLL @offset 0x4 $u8 {
    GPOLYLL:8 // at 0: POLYLL stores the first 8 bits of the 32 bit CRC
  }

//---  Register GPOLYLU: CRC_GPOLYLU register.
  GPOLYLU @offset 0x5 $u8 {
    GPOLYLU:8 // at 0: POLYLL stores the second 8 bits of the 32 bit CRC
  }

//---  Register GPOLYH: CRC_GPOLYH register.
  GPOLYH @offset 0x6 $u16 {
    GPOLYH:16 // at 0: POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
  }

//---  Register GPOLYHL: CRC_GPOLYHL register.
  GPOLYHL @offset 0x6 $u8 {
    GPOLYHL:8 // at 0: POLYHL stores the third 8 bits of the 32 bit CRC
  }

//---  Register GPOLYHU: CRC_GPOLYHU register.
  GPOLYHU @offset 0x7 $u8 {
    GPOLYHU:8 // at 0: POLYHU stores the fourth 8 bits of the 32 bit CRC
  }

//---  Register CTRL: CRC Control register
  CTRL @offset 0x8 $u32 {
    TOT:2 // at 30: Type Of Transpose For Writes
    TOTR:2 // at 28: Type Of Transpose For Read
    1
    FXOR // at 26: Complement Read Of CRC Data Register
    WAS // at 25: Write CRC Data Register As Seed
    TCRC // at 24: Width of CRC protocol.
    24
  }

//---  Register CTRLHU: CRC_CTRLHU register.
  CTRLHU @offset 0xb $u8 {
    TOT:2 // at 6: no description available
    TOTR:2 // at 4: no description available
    1
    FXOR // at 2: no description available
    WAS // at 1: no description available
    TCRC // at 0: no description available
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©DAC [2]
//        DAC0 at 0x400cc000
//        DAC1 at 0x400cd000
//------------------------------------------------------------------------------

registers ©DAC [2 @at 0x400cc000 0x400cd000]
          ©DAC0 @at 0x400cc000
          ©DAC1 @at 0x400cd000
{
//---  Registers DATL(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data Low Register
  DAT0L @offset 0x0 $u8
  DAT1L @offset 0x2 $u8
  DAT2L @offset 0x4 $u8
  DAT3L @offset 0x6 $u8
  DAT4L @offset 0x8 $u8
  DAT5L @offset 0xa $u8
  DAT6L @offset 0xc $u8
  DAT7L @offset 0xe $u8
  DAT8L @offset 0x10 $u8
  DAT9L @offset 0x12 $u8
  DAT10L @offset 0x14 $u8
  DAT11L @offset 0x16 $u8
  DAT12L @offset 0x18 $u8
  DAT13L @offset 0x1a $u8
  DAT14L @offset 0x1c $u8
  DAT15L @offset 0x1e $u8 {
    DATA0:8 // at 0: DATA0
  }

//---  Registers DATH(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data High Register
  DAT0H @offset 0x1 $u8
  DAT1H @offset 0x3 $u8
  DAT2H @offset 0x5 $u8
  DAT3H @offset 0x7 $u8
  DAT4H @offset 0x9 $u8
  DAT5H @offset 0xb $u8
  DAT6H @offset 0xd $u8
  DAT7H @offset 0xf $u8
  DAT8H @offset 0x11 $u8
  DAT9H @offset 0x13 $u8
  DAT10H @offset 0x15 $u8
  DAT11H @offset 0x17 $u8
  DAT12H @offset 0x19 $u8
  DAT13H @offset 0x1b $u8
  DAT14H @offset 0x1d $u8
  DAT15H @offset 0x1f $u8 {
    4
    DATA1:4 // at 0: DATA1
  }

//---  Register SR: DAC Status Register
  SR @offset 0x20 $u8 {
    5
    DACBFWMF // at 2: DAC Buffer Watermark Flag
    DACBFRPTF // at 1: DAC Buffer Read Pointer Top Position Flag
    DACBFRPBF // at 0: DAC Buffer Read Pointer Bottom Position Flag
  }

//---  Register C0: DAC Control Register
  C0 @offset 0x21 $u8 {
    DACEN // at 7: DAC Enable
    DACRFS // at 6: DAC Reference Select
    DACTRGSEL // at 5: DAC Trigger Select
    DACSWTRG // at 4: DAC Software Trigger
    LPEN // at 3: DAC Low Power Control
    DACBWIEN // at 2: DAC Buffer Watermark Interrupt Enable
    DACBTIEN // at 1: DAC Buffer Read Pointer Top Flag Interrupt Enable
    DACBBIEN // at 0: DAC Buffer Read Pointer Bottom Flag Interrupt Enable
  }

//---  Register C1: DAC Control Register 1
  C1 @offset 0x22 $u8 {
    DMAEN // at 7: DMA Enable Select
    2
    DACBFWM:2 // at 3: DAC Buffer Watermark Select
    DACBFMD:2 // at 1: DAC Buffer Work Mode Select
    DACBFEN // at 0: DAC Buffer Enable
  }

//---  Register C2: DAC Control Register 2
  C2 @offset 0x23 $u8 {
    DACBFRP:4 // at 4: DAC Buffer Read Pointer
    DACBFUP:4 // at 0: DAC Buffer Upper Limit
  }

}

//------------------------------------------------------------------------------
// Peripheral DMA: Enhanced direct memory access controller
//------------------------------------------------------------------------------

registers ©DMA @at 0x40008000 {
//---  Register CR: Control Register
  CR @offset 0x0 $u32 {
    14
    CX // at 17: Cancel Transfer
    ECX // at 16: Error Cancel Transfer
    5
    GRP1PRI // at 10: Channel Group 1 Priority
    1
    GRP0PRI // at 8: Channel Group 0 Priority
    EMLM // at 7: Enable Minor Loop Mapping
    CLM // at 6: Continuous Link Mode
    HALT // at 5: Halt DMA Operations
    HOE // at 4: Halt On Error
    ERGA // at 3: Enable Round Robin Group Arbitration
    ERCA // at 2: Enable Round Robin Channel Arbitration
    EDBG // at 1: Enable Debug
    1
  }

//---  Register ES: Error Status Register
  ES @offset 0x4 @ro $u32 {
    VLD // at 31: Logical OR of all ERR status bits
    14
    ECX // at 16: Transfer Canceled
    GPE // at 15: Group Priority Error
    CPE // at 14: Channel Priority Error
    1
    ERRCHN:5 // at 8: Error Channel Number or Canceled Channel Number
    SAE // at 7: Source Address Error
    SOE // at 6: Source Offset Error
    DAE // at 5: Destination Address Error
    DOE // at 4: Destination Offset Error
    NCE // at 3: NBYTES/CITER Configuration Error
    SGE // at 2: Scatter/Gather Configuration Error
    SBE // at 1: Source Bus Error
    DBE // at 0: Destination Bus Error
  }

//---  Register ERQ: Enable Request Register
  ERQ @offset 0xc $u32 {
    ERQ31 // at 31: Enable DMA Request 31
    ERQ30 // at 30: Enable DMA Request 30
    ERQ29 // at 29: Enable DMA Request 29
    ERQ28 // at 28: Enable DMA Request 28
    ERQ27 // at 27: Enable DMA Request 27
    ERQ26 // at 26: Enable DMA Request 26
    ERQ25 // at 25: Enable DMA Request 25
    ERQ24 // at 24: Enable DMA Request 24
    ERQ23 // at 23: Enable DMA Request 23
    ERQ22 // at 22: Enable DMA Request 22
    ERQ21 // at 21: Enable DMA Request 21
    ERQ20 // at 20: Enable DMA Request 20
    ERQ19 // at 19: Enable DMA Request 19
    ERQ18 // at 18: Enable DMA Request 18
    ERQ17 // at 17: Enable DMA Request 17
    ERQ16 // at 16: Enable DMA Request 16
    ERQ15 // at 15: Enable DMA Request 15
    ERQ14 // at 14: Enable DMA Request 14
    ERQ13 // at 13: Enable DMA Request 13
    ERQ12 // at 12: Enable DMA Request 12
    ERQ11 // at 11: Enable DMA Request 11
    ERQ10 // at 10: Enable DMA Request 10
    ERQ9 // at 9: Enable DMA Request 9
    ERQ8 // at 8: Enable DMA Request 8
    ERQ7 // at 7: Enable DMA Request 7
    ERQ6 // at 6: Enable DMA Request 6
    ERQ5 // at 5: Enable DMA Request 5
    ERQ4 // at 4: Enable DMA Request 4
    ERQ3 // at 3: Enable DMA Request 3
    ERQ2 // at 2: Enable DMA Request 2
    ERQ1 // at 1: Enable DMA Request 1
    ERQ0 // at 0: Enable DMA Request 0
  }

//---  Register EEI: Enable Error Interrupt Register
  EEI @offset 0x14 $u32 {
    EEI31 // at 31: Enable Error Interrupt 31
    EEI30 // at 30: Enable Error Interrupt 30
    EEI29 // at 29: Enable Error Interrupt 29
    EEI28 // at 28: Enable Error Interrupt 28
    EEI27 // at 27: Enable Error Interrupt 27
    EEI26 // at 26: Enable Error Interrupt 26
    EEI25 // at 25: Enable Error Interrupt 25
    EEI24 // at 24: Enable Error Interrupt 24
    EEI23 // at 23: Enable Error Interrupt 23
    EEI22 // at 22: Enable Error Interrupt 22
    EEI21 // at 21: Enable Error Interrupt 21
    EEI20 // at 20: Enable Error Interrupt 20
    EEI19 // at 19: Enable Error Interrupt 19
    EEI18 // at 18: Enable Error Interrupt 18
    EEI17 // at 17: Enable Error Interrupt 17
    EEI16 // at 16: Enable Error Interrupt 16
    EEI15 // at 15: Enable Error Interrupt 15
    EEI14 // at 14: Enable Error Interrupt 14
    EEI13 // at 13: Enable Error Interrupt 13
    EEI12 // at 12: Enable Error Interrupt 12
    EEI11 // at 11: Enable Error Interrupt 11
    EEI10 // at 10: Enable Error Interrupt 10
    EEI9 // at 9: Enable Error Interrupt 9
    EEI8 // at 8: Enable Error Interrupt 8
    EEI7 // at 7: Enable Error Interrupt 7
    EEI6 // at 6: Enable Error Interrupt 6
    EEI5 // at 5: Enable Error Interrupt 5
    EEI4 // at 4: Enable Error Interrupt 4
    EEI3 // at 3: Enable Error Interrupt 3
    EEI2 // at 2: Enable Error Interrupt 2
    EEI1 // at 1: Enable Error Interrupt 1
    EEI0 // at 0: Enable Error Interrupt 0
  }

//---  Register CEEI: Clear Enable Error Interrupt Register
  CEEI @offset 0x18 $u8 {
    NOP // at 7: No Op enable
    CAEE // at 6: Clear All Enable Error Interrupts
    1
    CEEI:5 // at 0: Clear Enable Error Interrupt
  }

//---  Register SEEI: Set Enable Error Interrupt Register
  SEEI @offset 0x19 $u8 {
    NOP // at 7: No Op enable
    SAEE // at 6: Sets All Enable Error Interrupts
    1
    SEEI:5 // at 0: Set Enable Error Interrupt
  }

//---  Register CERQ: Clear Enable Request Register
  CERQ @offset 0x1a $u8 {
    NOP // at 7: No Op enable
    CAER // at 6: Clear All Enable Requests
    1
    CERQ:5 // at 0: Clear Enable Request
  }

//---  Register SERQ: Set Enable Request Register
  SERQ @offset 0x1b $u8 {
    NOP // at 7: No Op enable
    SAER // at 6: Set All Enable Requests
    1
    SERQ:5 // at 0: Set Enable Request
  }

//---  Register CDNE: Clear DONE Status Bit Register
  CDNE @offset 0x1c $u8 {
    NOP // at 7: No Op enable
    CADN // at 6: Clears All DONE Bits
    1
    CDNE:5 // at 0: Clear DONE Bit
  }

//---  Register SSRT: Set START Bit Register
  SSRT @offset 0x1d $u8 {
    NOP // at 7: No Op enable
    SAST // at 6: Set All START Bits (activates all channels)
    1
    SSRT:5 // at 0: Set START Bit
  }

//---  Register CERR: Clear Error Register
  CERR @offset 0x1e $u8 {
    NOP // at 7: No Op enable
    CAEI // at 6: Clear All Error Indicators
    1
    CERR:5 // at 0: Clear Error Indicator
  }

//---  Register CINT: Clear Interrupt Request Register
  CINT @offset 0x1f $u8 {
    NOP // at 7: No Op enable
    CAIR // at 6: Clear All Interrupt Requests
    1
    CINT:5 // at 0: Clear Interrupt Request
  }

//---  Register INT: Interrupt Request Register
  INT @offset 0x24 $u32 {
    INT31 // at 31: Interrupt Request 31
    INT30 // at 30: Interrupt Request 30
    INT29 // at 29: Interrupt Request 29
    INT28 // at 28: Interrupt Request 28
    INT27 // at 27: Interrupt Request 27
    INT26 // at 26: Interrupt Request 26
    INT25 // at 25: Interrupt Request 25
    INT24 // at 24: Interrupt Request 24
    INT23 // at 23: Interrupt Request 23
    INT22 // at 22: Interrupt Request 22
    INT21 // at 21: Interrupt Request 21
    INT20 // at 20: Interrupt Request 20
    INT19 // at 19: Interrupt Request 19
    INT18 // at 18: Interrupt Request 18
    INT17 // at 17: Interrupt Request 17
    INT16 // at 16: Interrupt Request 16
    INT15 // at 15: Interrupt Request 15
    INT14 // at 14: Interrupt Request 14
    INT13 // at 13: Interrupt Request 13
    INT12 // at 12: Interrupt Request 12
    INT11 // at 11: Interrupt Request 11
    INT10 // at 10: Interrupt Request 10
    INT9 // at 9: Interrupt Request 9
    INT8 // at 8: Interrupt Request 8
    INT7 // at 7: Interrupt Request 7
    INT6 // at 6: Interrupt Request 6
    INT5 // at 5: Interrupt Request 5
    INT4 // at 4: Interrupt Request 4
    INT3 // at 3: Interrupt Request 3
    INT2 // at 2: Interrupt Request 2
    INT1 // at 1: Interrupt Request 1
    INT0 // at 0: Interrupt Request 0
  }

//---  Register ERR: Error Register
  ERR @offset 0x2c $u32 {
    ERR31 // at 31: Error In Channel 31
    ERR30 // at 30: Error In Channel 30
    ERR29 // at 29: Error In Channel 29
    ERR28 // at 28: Error In Channel 28
    ERR27 // at 27: Error In Channel 27
    ERR26 // at 26: Error In Channel 26
    ERR25 // at 25: Error In Channel 25
    ERR24 // at 24: Error In Channel 24
    ERR23 // at 23: Error In Channel 23
    ERR22 // at 22: Error In Channel 22
    ERR21 // at 21: Error In Channel 21
    ERR20 // at 20: Error In Channel 20
    ERR19 // at 19: Error In Channel 19
    ERR18 // at 18: Error In Channel 18
    ERR17 // at 17: Error In Channel 17
    ERR16 // at 16: Error In Channel 16
    ERR15 // at 15: Error In Channel 15
    ERR14 // at 14: Error In Channel 14
    ERR13 // at 13: Error In Channel 13
    ERR12 // at 12: Error In Channel 12
    ERR11 // at 11: Error In Channel 11
    ERR10 // at 10: Error In Channel 10
    ERR9 // at 9: Error In Channel 9
    ERR8 // at 8: Error In Channel 8
    ERR7 // at 7: Error In Channel 7
    ERR6 // at 6: Error In Channel 6
    ERR5 // at 5: Error In Channel 5
    ERR4 // at 4: Error In Channel 4
    ERR3 // at 3: Error In Channel 3
    ERR2 // at 2: Error In Channel 2
    ERR1 // at 1: Error In Channel 1
    ERR0 // at 0: Error In Channel 0
  }

//---  Register HRS: Hardware Request Status Register
  HRS @offset 0x34 @ro $u32 {
    HRS31 // at 31: Hardware Request Status Channel 31
    HRS30 // at 30: Hardware Request Status Channel 30
    HRS29 // at 29: Hardware Request Status Channel 29
    HRS28 // at 28: Hardware Request Status Channel 28
    HRS27 // at 27: Hardware Request Status Channel 27
    HRS26 // at 26: Hardware Request Status Channel 26
    HRS25 // at 25: Hardware Request Status Channel 25
    HRS24 // at 24: Hardware Request Status Channel 24
    HRS23 // at 23: Hardware Request Status Channel 23
    HRS22 // at 22: Hardware Request Status Channel 22
    HRS21 // at 21: Hardware Request Status Channel 21
    HRS20 // at 20: Hardware Request Status Channel 20
    HRS19 // at 19: Hardware Request Status Channel 19
    HRS18 // at 18: Hardware Request Status Channel 18
    HRS17 // at 17: Hardware Request Status Channel 17
    HRS16 // at 16: Hardware Request Status Channel 16
    HRS15 // at 15: Hardware Request Status Channel 15
    HRS14 // at 14: Hardware Request Status Channel 14
    HRS13 // at 13: Hardware Request Status Channel 13
    HRS12 // at 12: Hardware Request Status Channel 12
    HRS11 // at 11: Hardware Request Status Channel 11
    HRS10 // at 10: Hardware Request Status Channel 10
    HRS9 // at 9: Hardware Request Status Channel 9
    HRS8 // at 8: Hardware Request Status Channel 8
    HRS7 // at 7: Hardware Request Status Channel 7
    HRS6 // at 6: Hardware Request Status Channel 6
    HRS5 // at 5: Hardware Request Status Channel 5
    HRS4 // at 4: Hardware Request Status Channel 4
    HRS3 // at 3: Hardware Request Status Channel 3
    HRS2 // at 2: Hardware Request Status Channel 2
    HRS1 // at 1: Hardware Request Status Channel 1
    HRS0 // at 0: Hardware Request Status Channel 0
  }

//---  Register EARS: Enable Asynchronous Request in Stop Register
  EARS @offset 0x44 $u32 {
    EDREQ_31 // at 31: Enable asynchronous DMA request in stop mode for channel 31
    EDREQ_30 // at 30: Enable asynchronous DMA request in stop mode for channel 30
    EDREQ_29 // at 29: Enable asynchronous DMA request in stop mode for channel 29
    EDREQ_28 // at 28: Enable asynchronous DMA request in stop mode for channel 28
    EDREQ_27 // at 27: Enable asynchronous DMA request in stop mode for channel 27
    EDREQ_26 // at 26: Enable asynchronous DMA request in stop mode for channel 26
    EDREQ_25 // at 25: Enable asynchronous DMA request in stop mode for channel 25
    EDREQ_24 // at 24: Enable asynchronous DMA request in stop mode for channel 24
    EDREQ_23 // at 23: Enable asynchronous DMA request in stop mode for channel 23
    EDREQ_22 // at 22: Enable asynchronous DMA request in stop mode for channel 22
    EDREQ_21 // at 21: Enable asynchronous DMA request in stop mode for channel 21
    EDREQ_20 // at 20: Enable asynchronous DMA request in stop mode for channel 20
    EDREQ_19 // at 19: Enable asynchronous DMA request in stop mode for channel 19
    EDREQ_18 // at 18: Enable asynchronous DMA request in stop mode for channel 18
    EDREQ_17 // at 17: Enable asynchronous DMA request in stop mode for channel 17
    EDREQ_16 // at 16: Enable asynchronous DMA request in stop mode for channel 16
    EDREQ_15 // at 15: Enable asynchronous DMA request in stop mode for channel 15
    EDREQ_14 // at 14: Enable asynchronous DMA request in stop mode for channel 14
    EDREQ_13 // at 13: Enable asynchronous DMA request in stop mode for channel 13
    EDREQ_12 // at 12: Enable asynchronous DMA request in stop mode for channel 12
    EDREQ_11 // at 11: Enable asynchronous DMA request in stop mode for channel 11
    EDREQ_10 // at 10: Enable asynchronous DMA request in stop mode for channel 10
    EDREQ_9 // at 9: Enable asynchronous DMA request in stop mode for channel 9
    EDREQ_8 // at 8: Enable asynchronous DMA request in stop mode for channel 8
    EDREQ_7 // at 7: Enable asynchronous DMA request in stop mode for channel 7
    EDREQ_6 // at 6: Enable asynchronous DMA request in stop mode for channel 6
    EDREQ_5 // at 5: Enable asynchronous DMA request in stop mode for channel 5
    EDREQ_4 // at 4: Enable asynchronous DMA request in stop mode for channel 4
    EDREQ_3 // at 3: Enable asynchronous DMA request in stop mode for channel 3.
    EDREQ_2 // at 2: Enable asynchronous DMA request in stop mode for channel 2.
    EDREQ_1 // at 1: Enable asynchronous DMA request in stop mode for channel 1.
    EDREQ_0 // at 0: Enable asynchronous DMA request in stop mode for channel 0.
  }

//---  Registers DCHPRI(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12,19,18,17,16,23,22,21,20,27,26,25,24,31,30,29,28): Channel n Priority Register
  #define DMA_DCHPRI(idx) (* ((volatile uint8_t *) (0x40008000 + 0x100 + (idx) * 0x1)))
  #define DMA_DCHPRI3 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 0 * 0x1)))
  #define DMA_DCHPRI2 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 1 * 0x1)))
  #define DMA_DCHPRI1 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 2 * 0x1)))
  #define DMA_DCHPRI0 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 3 * 0x1)))
  #define DMA_DCHPRI7 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 4 * 0x1)))
  #define DMA_DCHPRI6 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 5 * 0x1)))
  #define DMA_DCHPRI5 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 6 * 0x1)))
  #define DMA_DCHPRI4 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 7 * 0x1)))
  #define DMA_DCHPRI11 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 8 * 0x1)))
  #define DMA_DCHPRI10 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 9 * 0x1)))
  #define DMA_DCHPRI9 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 10 * 0x1)))
  #define DMA_DCHPRI8 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 11 * 0x1)))
  #define DMA_DCHPRI15 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 12 * 0x1)))
  #define DMA_DCHPRI14 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 13 * 0x1)))
  #define DMA_DCHPRI13 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 14 * 0x1)))
  #define DMA_DCHPRI12 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 15 * 0x1)))
  #define DMA_DCHPRI19 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 16 * 0x1)))
  #define DMA_DCHPRI18 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 17 * 0x1)))
  #define DMA_DCHPRI17 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 18 * 0x1)))
  #define DMA_DCHPRI16 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 19 * 0x1)))
  #define DMA_DCHPRI23 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 20 * 0x1)))
  #define DMA_DCHPRI22 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 21 * 0x1)))
  #define DMA_DCHPRI21 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 22 * 0x1)))
  #define DMA_DCHPRI20 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 23 * 0x1)))
  #define DMA_DCHPRI27 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 24 * 0x1)))
  #define DMA_DCHPRI26 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 25 * 0x1)))
  #define DMA_DCHPRI25 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 26 * 0x1)))
  #define DMA_DCHPRI24 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 27 * 0x1)))
  #define DMA_DCHPRI31 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 28 * 0x1)))
  #define DMA_DCHPRI30 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 29 * 0x1)))
  #define DMA_DCHPRI29 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 30 * 0x1)))
  #define DMA_DCHPRI28 (* ((volatile uint8_t *) (0x40008000 + 0x100 + 31 * 0x1)))
 {
    ECP // at 7: Enable Channel Preemption.
    DPA // at 6: Disable Preempt Ability.
    GRPPRI:2 // at 4: Channel n Current Group Priority
    CHPRI:4 // at 0: Channel n Arbitration Priority
  }

//---  Registers TCD_SADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Source Address
  #define DMA_TCD_SADDR(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1000 + (idx) * 0x20)))
  #define DMA_TCD0_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 0 * 0x20)))
  #define DMA_TCD1_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 1 * 0x20)))
  #define DMA_TCD2_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 2 * 0x20)))
  #define DMA_TCD3_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 3 * 0x20)))
  #define DMA_TCD4_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 4 * 0x20)))
  #define DMA_TCD5_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 5 * 0x20)))
  #define DMA_TCD6_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 6 * 0x20)))
  #define DMA_TCD7_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 7 * 0x20)))
  #define DMA_TCD8_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 8 * 0x20)))
  #define DMA_TCD9_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 9 * 0x20)))
  #define DMA_TCD10_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 10 * 0x20)))
  #define DMA_TCD11_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 11 * 0x20)))
  #define DMA_TCD12_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 12 * 0x20)))
  #define DMA_TCD13_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 13 * 0x20)))
  #define DMA_TCD14_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 14 * 0x20)))
  #define DMA_TCD15_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 15 * 0x20)))
  #define DMA_TCD16_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 16 * 0x20)))
  #define DMA_TCD17_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 17 * 0x20)))
  #define DMA_TCD18_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 18 * 0x20)))
  #define DMA_TCD19_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 19 * 0x20)))
  #define DMA_TCD20_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 20 * 0x20)))
  #define DMA_TCD21_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 21 * 0x20)))
  #define DMA_TCD22_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 22 * 0x20)))
  #define DMA_TCD23_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 23 * 0x20)))
  #define DMA_TCD24_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 24 * 0x20)))
  #define DMA_TCD25_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 25 * 0x20)))
  #define DMA_TCD26_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 26 * 0x20)))
  #define DMA_TCD27_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 27 * 0x20)))
  #define DMA_TCD28_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 28 * 0x20)))
  #define DMA_TCD29_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 29 * 0x20)))
  #define DMA_TCD30_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 30 * 0x20)))
  #define DMA_TCD31_SADDR (* ((volatile uint32_t *) (0x40008000 + 0x1000 + 31 * 0x20)))
 {
    SADDR:32 // at 0: Source Address
  }

//---  Registers TCD_SOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Source Address Offset
  #define DMA_TCD_SOFF(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1004 + (idx) * 0x20)))
  #define DMA_TCD0_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 0 * 0x20)))
  #define DMA_TCD1_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 1 * 0x20)))
  #define DMA_TCD2_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 2 * 0x20)))
  #define DMA_TCD3_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 3 * 0x20)))
  #define DMA_TCD4_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 4 * 0x20)))
  #define DMA_TCD5_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 5 * 0x20)))
  #define DMA_TCD6_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 6 * 0x20)))
  #define DMA_TCD7_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 7 * 0x20)))
  #define DMA_TCD8_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 8 * 0x20)))
  #define DMA_TCD9_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 9 * 0x20)))
  #define DMA_TCD10_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 10 * 0x20)))
  #define DMA_TCD11_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 11 * 0x20)))
  #define DMA_TCD12_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 12 * 0x20)))
  #define DMA_TCD13_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 13 * 0x20)))
  #define DMA_TCD14_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 14 * 0x20)))
  #define DMA_TCD15_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 15 * 0x20)))
  #define DMA_TCD16_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 16 * 0x20)))
  #define DMA_TCD17_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 17 * 0x20)))
  #define DMA_TCD18_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 18 * 0x20)))
  #define DMA_TCD19_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 19 * 0x20)))
  #define DMA_TCD20_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 20 * 0x20)))
  #define DMA_TCD21_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 21 * 0x20)))
  #define DMA_TCD22_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 22 * 0x20)))
  #define DMA_TCD23_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 23 * 0x20)))
  #define DMA_TCD24_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 24 * 0x20)))
  #define DMA_TCD25_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 25 * 0x20)))
  #define DMA_TCD26_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 26 * 0x20)))
  #define DMA_TCD27_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 27 * 0x20)))
  #define DMA_TCD28_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 28 * 0x20)))
  #define DMA_TCD29_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 29 * 0x20)))
  #define DMA_TCD30_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 30 * 0x20)))
  #define DMA_TCD31_SOFF (* ((volatile uint16_t *) (0x40008000 + 0x1004 + 31 * 0x20)))
 {
    SOFF:16 // at 0: Source address signed offset
  }

//---  Registers TCD_ATTR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Transfer Attributes
  #define DMA_TCD_ATTR(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1006 + (idx) * 0x20)))
  #define DMA_TCD0_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 0 * 0x20)))
  #define DMA_TCD1_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 1 * 0x20)))
  #define DMA_TCD2_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 2 * 0x20)))
  #define DMA_TCD3_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 3 * 0x20)))
  #define DMA_TCD4_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 4 * 0x20)))
  #define DMA_TCD5_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 5 * 0x20)))
  #define DMA_TCD6_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 6 * 0x20)))
  #define DMA_TCD7_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 7 * 0x20)))
  #define DMA_TCD8_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 8 * 0x20)))
  #define DMA_TCD9_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 9 * 0x20)))
  #define DMA_TCD10_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 10 * 0x20)))
  #define DMA_TCD11_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 11 * 0x20)))
  #define DMA_TCD12_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 12 * 0x20)))
  #define DMA_TCD13_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 13 * 0x20)))
  #define DMA_TCD14_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 14 * 0x20)))
  #define DMA_TCD15_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 15 * 0x20)))
  #define DMA_TCD16_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 16 * 0x20)))
  #define DMA_TCD17_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 17 * 0x20)))
  #define DMA_TCD18_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 18 * 0x20)))
  #define DMA_TCD19_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 19 * 0x20)))
  #define DMA_TCD20_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 20 * 0x20)))
  #define DMA_TCD21_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 21 * 0x20)))
  #define DMA_TCD22_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 22 * 0x20)))
  #define DMA_TCD23_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 23 * 0x20)))
  #define DMA_TCD24_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 24 * 0x20)))
  #define DMA_TCD25_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 25 * 0x20)))
  #define DMA_TCD26_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 26 * 0x20)))
  #define DMA_TCD27_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 27 * 0x20)))
  #define DMA_TCD28_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 28 * 0x20)))
  #define DMA_TCD29_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 29 * 0x20)))
  #define DMA_TCD30_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 30 * 0x20)))
  #define DMA_TCD31_ATTR (* ((volatile uint16_t *) (0x40008000 + 0x1006 + 31 * 0x20)))
 {
    SMOD:5 // at 11: Source Address Modulo
    SSIZE:3 // at 8: Source data transfer size
    DMOD:5 // at 3: Destination Address Modulo
    DSIZE:3 // at 0: Destination data transfer size
  }

//---  Registers TCD_NBYTES_MLNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Minor Byte Count (Minor Loop Mapping Disabled)
  #define DMA_TCD_NBYTES_MLNO(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1008 + (idx) * 0x20)))
  #define DMA_TCD0_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 0 * 0x20)))
  #define DMA_TCD1_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 1 * 0x20)))
  #define DMA_TCD2_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 2 * 0x20)))
  #define DMA_TCD3_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 3 * 0x20)))
  #define DMA_TCD4_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 4 * 0x20)))
  #define DMA_TCD5_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 5 * 0x20)))
  #define DMA_TCD6_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 6 * 0x20)))
  #define DMA_TCD7_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 7 * 0x20)))
  #define DMA_TCD8_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 8 * 0x20)))
  #define DMA_TCD9_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 9 * 0x20)))
  #define DMA_TCD10_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 10 * 0x20)))
  #define DMA_TCD11_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 11 * 0x20)))
  #define DMA_TCD12_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 12 * 0x20)))
  #define DMA_TCD13_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 13 * 0x20)))
  #define DMA_TCD14_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 14 * 0x20)))
  #define DMA_TCD15_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 15 * 0x20)))
  #define DMA_TCD16_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 16 * 0x20)))
  #define DMA_TCD17_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 17 * 0x20)))
  #define DMA_TCD18_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 18 * 0x20)))
  #define DMA_TCD19_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 19 * 0x20)))
  #define DMA_TCD20_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 20 * 0x20)))
  #define DMA_TCD21_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 21 * 0x20)))
  #define DMA_TCD22_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 22 * 0x20)))
  #define DMA_TCD23_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 23 * 0x20)))
  #define DMA_TCD24_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 24 * 0x20)))
  #define DMA_TCD25_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 25 * 0x20)))
  #define DMA_TCD26_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 26 * 0x20)))
  #define DMA_TCD27_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 27 * 0x20)))
  #define DMA_TCD28_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 28 * 0x20)))
  #define DMA_TCD29_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 29 * 0x20)))
  #define DMA_TCD30_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 30 * 0x20)))
  #define DMA_TCD31_NBYTES_MLNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 31 * 0x20)))
 {
    NBYTES:32 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_NBYTES_MLOFFNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
  #define DMA_TCD_NBYTES_MLOFFNO(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1008 + (idx) * 0x20)))
  #define DMA_TCD0_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 0 * 0x20)))
  #define DMA_TCD1_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 1 * 0x20)))
  #define DMA_TCD2_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 2 * 0x20)))
  #define DMA_TCD3_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 3 * 0x20)))
  #define DMA_TCD4_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 4 * 0x20)))
  #define DMA_TCD5_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 5 * 0x20)))
  #define DMA_TCD6_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 6 * 0x20)))
  #define DMA_TCD7_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 7 * 0x20)))
  #define DMA_TCD8_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 8 * 0x20)))
  #define DMA_TCD9_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 9 * 0x20)))
  #define DMA_TCD10_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 10 * 0x20)))
  #define DMA_TCD11_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 11 * 0x20)))
  #define DMA_TCD12_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 12 * 0x20)))
  #define DMA_TCD13_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 13 * 0x20)))
  #define DMA_TCD14_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 14 * 0x20)))
  #define DMA_TCD15_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 15 * 0x20)))
  #define DMA_TCD16_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 16 * 0x20)))
  #define DMA_TCD17_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 17 * 0x20)))
  #define DMA_TCD18_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 18 * 0x20)))
  #define DMA_TCD19_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 19 * 0x20)))
  #define DMA_TCD20_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 20 * 0x20)))
  #define DMA_TCD21_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 21 * 0x20)))
  #define DMA_TCD22_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 22 * 0x20)))
  #define DMA_TCD23_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 23 * 0x20)))
  #define DMA_TCD24_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 24 * 0x20)))
  #define DMA_TCD25_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 25 * 0x20)))
  #define DMA_TCD26_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 26 * 0x20)))
  #define DMA_TCD27_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 27 * 0x20)))
  #define DMA_TCD28_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 28 * 0x20)))
  #define DMA_TCD29_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 29 * 0x20)))
  #define DMA_TCD30_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 30 * 0x20)))
  #define DMA_TCD31_NBYTES_MLOFFNO (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 31 * 0x20)))
 {
    SMLOE // at 31: Source Minor Loop Offset Enable
    DMLOE // at 30: Destination Minor Loop Offset enable
    NBYTES:30 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_NBYTES_MLOFFYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
  #define DMA_TCD_NBYTES_MLOFFYES(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1008 + (idx) * 0x20)))
  #define DMA_TCD0_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 0 * 0x20)))
  #define DMA_TCD1_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 1 * 0x20)))
  #define DMA_TCD2_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 2 * 0x20)))
  #define DMA_TCD3_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 3 * 0x20)))
  #define DMA_TCD4_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 4 * 0x20)))
  #define DMA_TCD5_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 5 * 0x20)))
  #define DMA_TCD6_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 6 * 0x20)))
  #define DMA_TCD7_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 7 * 0x20)))
  #define DMA_TCD8_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 8 * 0x20)))
  #define DMA_TCD9_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 9 * 0x20)))
  #define DMA_TCD10_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 10 * 0x20)))
  #define DMA_TCD11_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 11 * 0x20)))
  #define DMA_TCD12_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 12 * 0x20)))
  #define DMA_TCD13_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 13 * 0x20)))
  #define DMA_TCD14_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 14 * 0x20)))
  #define DMA_TCD15_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 15 * 0x20)))
  #define DMA_TCD16_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 16 * 0x20)))
  #define DMA_TCD17_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 17 * 0x20)))
  #define DMA_TCD18_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 18 * 0x20)))
  #define DMA_TCD19_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 19 * 0x20)))
  #define DMA_TCD20_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 20 * 0x20)))
  #define DMA_TCD21_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 21 * 0x20)))
  #define DMA_TCD22_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 22 * 0x20)))
  #define DMA_TCD23_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 23 * 0x20)))
  #define DMA_TCD24_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 24 * 0x20)))
  #define DMA_TCD25_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 25 * 0x20)))
  #define DMA_TCD26_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 26 * 0x20)))
  #define DMA_TCD27_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 27 * 0x20)))
  #define DMA_TCD28_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 28 * 0x20)))
  #define DMA_TCD29_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 29 * 0x20)))
  #define DMA_TCD30_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 30 * 0x20)))
  #define DMA_TCD31_NBYTES_MLOFFYES (* ((volatile uint32_t *) (0x40008000 + 0x1008 + 31 * 0x20)))
 {
    SMLOE // at 31: Source Minor Loop Offset Enable
    DMLOE // at 30: Destination Minor Loop Offset enable
    MLOFF:20 // at 10: If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
    NBYTES:10 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_SLAST(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Last Source Address Adjustment
  #define DMA_TCD_SLAST(idx) (* ((volatile uint32_t *) (0x40008000 + 0x100c + (idx) * 0x20)))
  #define DMA_TCD0_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 0 * 0x20)))
  #define DMA_TCD1_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 1 * 0x20)))
  #define DMA_TCD2_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 2 * 0x20)))
  #define DMA_TCD3_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 3 * 0x20)))
  #define DMA_TCD4_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 4 * 0x20)))
  #define DMA_TCD5_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 5 * 0x20)))
  #define DMA_TCD6_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 6 * 0x20)))
  #define DMA_TCD7_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 7 * 0x20)))
  #define DMA_TCD8_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 8 * 0x20)))
  #define DMA_TCD9_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 9 * 0x20)))
  #define DMA_TCD10_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 10 * 0x20)))
  #define DMA_TCD11_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 11 * 0x20)))
  #define DMA_TCD12_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 12 * 0x20)))
  #define DMA_TCD13_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 13 * 0x20)))
  #define DMA_TCD14_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 14 * 0x20)))
  #define DMA_TCD15_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 15 * 0x20)))
  #define DMA_TCD16_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 16 * 0x20)))
  #define DMA_TCD17_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 17 * 0x20)))
  #define DMA_TCD18_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 18 * 0x20)))
  #define DMA_TCD19_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 19 * 0x20)))
  #define DMA_TCD20_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 20 * 0x20)))
  #define DMA_TCD21_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 21 * 0x20)))
  #define DMA_TCD22_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 22 * 0x20)))
  #define DMA_TCD23_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 23 * 0x20)))
  #define DMA_TCD24_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 24 * 0x20)))
  #define DMA_TCD25_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 25 * 0x20)))
  #define DMA_TCD26_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 26 * 0x20)))
  #define DMA_TCD27_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 27 * 0x20)))
  #define DMA_TCD28_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 28 * 0x20)))
  #define DMA_TCD29_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 29 * 0x20)))
  #define DMA_TCD30_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 30 * 0x20)))
  #define DMA_TCD31_SLAST (* ((volatile uint32_t *) (0x40008000 + 0x100c + 31 * 0x20)))
 {
    SLAST:32 // at 0: Last Source Address Adjustment
  }

//---  Registers TCD_DADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Destination Address
  #define DMA_TCD_DADDR(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1010 + (idx) * 0x20)))
  #define DMA_TCD0_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 0 * 0x20)))
  #define DMA_TCD1_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 1 * 0x20)))
  #define DMA_TCD2_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 2 * 0x20)))
  #define DMA_TCD3_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 3 * 0x20)))
  #define DMA_TCD4_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 4 * 0x20)))
  #define DMA_TCD5_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 5 * 0x20)))
  #define DMA_TCD6_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 6 * 0x20)))
  #define DMA_TCD7_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 7 * 0x20)))
  #define DMA_TCD8_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 8 * 0x20)))
  #define DMA_TCD9_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 9 * 0x20)))
  #define DMA_TCD10_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 10 * 0x20)))
  #define DMA_TCD11_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 11 * 0x20)))
  #define DMA_TCD12_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 12 * 0x20)))
  #define DMA_TCD13_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 13 * 0x20)))
  #define DMA_TCD14_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 14 * 0x20)))
  #define DMA_TCD15_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 15 * 0x20)))
  #define DMA_TCD16_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 16 * 0x20)))
  #define DMA_TCD17_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 17 * 0x20)))
  #define DMA_TCD18_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 18 * 0x20)))
  #define DMA_TCD19_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 19 * 0x20)))
  #define DMA_TCD20_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 20 * 0x20)))
  #define DMA_TCD21_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 21 * 0x20)))
  #define DMA_TCD22_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 22 * 0x20)))
  #define DMA_TCD23_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 23 * 0x20)))
  #define DMA_TCD24_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 24 * 0x20)))
  #define DMA_TCD25_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 25 * 0x20)))
  #define DMA_TCD26_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 26 * 0x20)))
  #define DMA_TCD27_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 27 * 0x20)))
  #define DMA_TCD28_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 28 * 0x20)))
  #define DMA_TCD29_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 29 * 0x20)))
  #define DMA_TCD30_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 30 * 0x20)))
  #define DMA_TCD31_DADDR (* ((volatile uint32_t *) (0x40008000 + 0x1010 + 31 * 0x20)))
 {
    DADDR:32 // at 0: Destination Address
  }

//---  Registers TCD_DOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Destination Address Offset
  #define DMA_TCD_DOFF(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1014 + (idx) * 0x20)))
  #define DMA_TCD0_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 0 * 0x20)))
  #define DMA_TCD1_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 1 * 0x20)))
  #define DMA_TCD2_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 2 * 0x20)))
  #define DMA_TCD3_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 3 * 0x20)))
  #define DMA_TCD4_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 4 * 0x20)))
  #define DMA_TCD5_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 5 * 0x20)))
  #define DMA_TCD6_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 6 * 0x20)))
  #define DMA_TCD7_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 7 * 0x20)))
  #define DMA_TCD8_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 8 * 0x20)))
  #define DMA_TCD9_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 9 * 0x20)))
  #define DMA_TCD10_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 10 * 0x20)))
  #define DMA_TCD11_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 11 * 0x20)))
  #define DMA_TCD12_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 12 * 0x20)))
  #define DMA_TCD13_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 13 * 0x20)))
  #define DMA_TCD14_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 14 * 0x20)))
  #define DMA_TCD15_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 15 * 0x20)))
  #define DMA_TCD16_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 16 * 0x20)))
  #define DMA_TCD17_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 17 * 0x20)))
  #define DMA_TCD18_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 18 * 0x20)))
  #define DMA_TCD19_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 19 * 0x20)))
  #define DMA_TCD20_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 20 * 0x20)))
  #define DMA_TCD21_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 21 * 0x20)))
  #define DMA_TCD22_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 22 * 0x20)))
  #define DMA_TCD23_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 23 * 0x20)))
  #define DMA_TCD24_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 24 * 0x20)))
  #define DMA_TCD25_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 25 * 0x20)))
  #define DMA_TCD26_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 26 * 0x20)))
  #define DMA_TCD27_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 27 * 0x20)))
  #define DMA_TCD28_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 28 * 0x20)))
  #define DMA_TCD29_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 29 * 0x20)))
  #define DMA_TCD30_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 30 * 0x20)))
  #define DMA_TCD31_DOFF (* ((volatile uint16_t *) (0x40008000 + 0x1014 + 31 * 0x20)))
 {
    DOFF:16 // at 0: Destination Address Signed Offset
  }

//---  Registers TCD_CITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  #define DMA_TCD_CITER_ELINKNO(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1016 + (idx) * 0x20)))
  #define DMA_TCD0_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 0 * 0x20)))
  #define DMA_TCD1_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 1 * 0x20)))
  #define DMA_TCD2_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 2 * 0x20)))
  #define DMA_TCD3_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 3 * 0x20)))
  #define DMA_TCD4_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 4 * 0x20)))
  #define DMA_TCD5_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 5 * 0x20)))
  #define DMA_TCD6_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 6 * 0x20)))
  #define DMA_TCD7_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 7 * 0x20)))
  #define DMA_TCD8_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 8 * 0x20)))
  #define DMA_TCD9_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 9 * 0x20)))
  #define DMA_TCD10_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 10 * 0x20)))
  #define DMA_TCD11_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 11 * 0x20)))
  #define DMA_TCD12_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 12 * 0x20)))
  #define DMA_TCD13_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 13 * 0x20)))
  #define DMA_TCD14_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 14 * 0x20)))
  #define DMA_TCD15_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 15 * 0x20)))
  #define DMA_TCD16_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 16 * 0x20)))
  #define DMA_TCD17_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 17 * 0x20)))
  #define DMA_TCD18_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 18 * 0x20)))
  #define DMA_TCD19_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 19 * 0x20)))
  #define DMA_TCD20_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 20 * 0x20)))
  #define DMA_TCD21_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 21 * 0x20)))
  #define DMA_TCD22_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 22 * 0x20)))
  #define DMA_TCD23_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 23 * 0x20)))
  #define DMA_TCD24_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 24 * 0x20)))
  #define DMA_TCD25_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 25 * 0x20)))
  #define DMA_TCD26_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 26 * 0x20)))
  #define DMA_TCD27_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 27 * 0x20)))
  #define DMA_TCD28_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 28 * 0x20)))
  #define DMA_TCD29_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 29 * 0x20)))
  #define DMA_TCD30_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 30 * 0x20)))
  #define DMA_TCD31_CITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 31 * 0x20)))
 {
    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete
    CITER:15 // at 0: Current Major Iteration Count
  }

//---  Registers TCD_CITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
  #define DMA_TCD_CITER_ELINKYES(idx) (* ((volatile uint16_t *) (0x40008000 + 0x1016 + (idx) * 0x20)))
  #define DMA_TCD0_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 0 * 0x20)))
  #define DMA_TCD1_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 1 * 0x20)))
  #define DMA_TCD2_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 2 * 0x20)))
  #define DMA_TCD3_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 3 * 0x20)))
  #define DMA_TCD4_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 4 * 0x20)))
  #define DMA_TCD5_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 5 * 0x20)))
  #define DMA_TCD6_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 6 * 0x20)))
  #define DMA_TCD7_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 7 * 0x20)))
  #define DMA_TCD8_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 8 * 0x20)))
  #define DMA_TCD9_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 9 * 0x20)))
  #define DMA_TCD10_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 10 * 0x20)))
  #define DMA_TCD11_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 11 * 0x20)))
  #define DMA_TCD12_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 12 * 0x20)))
  #define DMA_TCD13_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 13 * 0x20)))
  #define DMA_TCD14_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 14 * 0x20)))
  #define DMA_TCD15_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 15 * 0x20)))
  #define DMA_TCD16_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 16 * 0x20)))
  #define DMA_TCD17_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 17 * 0x20)))
  #define DMA_TCD18_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 18 * 0x20)))
  #define DMA_TCD19_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 19 * 0x20)))
  #define DMA_TCD20_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 20 * 0x20)))
  #define DMA_TCD21_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 21 * 0x20)))
  #define DMA_TCD22_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 22 * 0x20)))
  #define DMA_TCD23_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 23 * 0x20)))
  #define DMA_TCD24_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 24 * 0x20)))
  #define DMA_TCD25_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 25 * 0x20)))
  #define DMA_TCD26_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 26 * 0x20)))
  #define DMA_TCD27_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 27 * 0x20)))
  #define DMA_TCD28_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 28 * 0x20)))
  #define DMA_TCD29_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 29 * 0x20)))
  #define DMA_TCD30_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 30 * 0x20)))
  #define DMA_TCD31_CITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x1016 + 31 * 0x20)))
 {
    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete
    1
    LINKCH:5 // at 9: Minor Loop Link Channel Number
    CITER:9 // at 0: Current Major Iteration Count
  }

//---  Registers TCD_DLASTSGA(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Last Destination Address Adjustment/Scatter Gather Address
  #define DMA_TCD_DLASTSGA(idx) (* ((volatile uint32_t *) (0x40008000 + 0x1018 + (idx) * 0x20)))
  #define DMA_TCD0_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 0 * 0x20)))
  #define DMA_TCD1_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 1 * 0x20)))
  #define DMA_TCD2_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 2 * 0x20)))
  #define DMA_TCD3_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 3 * 0x20)))
  #define DMA_TCD4_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 4 * 0x20)))
  #define DMA_TCD5_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 5 * 0x20)))
  #define DMA_TCD6_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 6 * 0x20)))
  #define DMA_TCD7_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 7 * 0x20)))
  #define DMA_TCD8_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 8 * 0x20)))
  #define DMA_TCD9_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 9 * 0x20)))
  #define DMA_TCD10_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 10 * 0x20)))
  #define DMA_TCD11_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 11 * 0x20)))
  #define DMA_TCD12_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 12 * 0x20)))
  #define DMA_TCD13_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 13 * 0x20)))
  #define DMA_TCD14_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 14 * 0x20)))
  #define DMA_TCD15_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 15 * 0x20)))
  #define DMA_TCD16_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 16 * 0x20)))
  #define DMA_TCD17_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 17 * 0x20)))
  #define DMA_TCD18_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 18 * 0x20)))
  #define DMA_TCD19_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 19 * 0x20)))
  #define DMA_TCD20_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 20 * 0x20)))
  #define DMA_TCD21_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 21 * 0x20)))
  #define DMA_TCD22_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 22 * 0x20)))
  #define DMA_TCD23_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 23 * 0x20)))
  #define DMA_TCD24_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 24 * 0x20)))
  #define DMA_TCD25_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 25 * 0x20)))
  #define DMA_TCD26_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 26 * 0x20)))
  #define DMA_TCD27_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 27 * 0x20)))
  #define DMA_TCD28_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 28 * 0x20)))
  #define DMA_TCD29_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 29 * 0x20)))
  #define DMA_TCD30_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 30 * 0x20)))
  #define DMA_TCD31_DLASTSGA (* ((volatile uint32_t *) (0x40008000 + 0x1018 + 31 * 0x20)))
 {
    DLASTSGA:32 // at 0: Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
  }

//---  Registers TCD_CSR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Control and Status
  #define DMA_TCD_CSR(idx) (* ((volatile uint16_t *) (0x40008000 + 0x101c + (idx) * 0x20)))
  #define DMA_TCD0_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 0 * 0x20)))
  #define DMA_TCD1_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 1 * 0x20)))
  #define DMA_TCD2_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 2 * 0x20)))
  #define DMA_TCD3_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 3 * 0x20)))
  #define DMA_TCD4_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 4 * 0x20)))
  #define DMA_TCD5_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 5 * 0x20)))
  #define DMA_TCD6_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 6 * 0x20)))
  #define DMA_TCD7_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 7 * 0x20)))
  #define DMA_TCD8_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 8 * 0x20)))
  #define DMA_TCD9_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 9 * 0x20)))
  #define DMA_TCD10_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 10 * 0x20)))
  #define DMA_TCD11_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 11 * 0x20)))
  #define DMA_TCD12_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 12 * 0x20)))
  #define DMA_TCD13_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 13 * 0x20)))
  #define DMA_TCD14_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 14 * 0x20)))
  #define DMA_TCD15_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 15 * 0x20)))
  #define DMA_TCD16_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 16 * 0x20)))
  #define DMA_TCD17_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 17 * 0x20)))
  #define DMA_TCD18_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 18 * 0x20)))
  #define DMA_TCD19_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 19 * 0x20)))
  #define DMA_TCD20_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 20 * 0x20)))
  #define DMA_TCD21_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 21 * 0x20)))
  #define DMA_TCD22_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 22 * 0x20)))
  #define DMA_TCD23_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 23 * 0x20)))
  #define DMA_TCD24_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 24 * 0x20)))
  #define DMA_TCD25_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 25 * 0x20)))
  #define DMA_TCD26_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 26 * 0x20)))
  #define DMA_TCD27_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 27 * 0x20)))
  #define DMA_TCD28_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 28 * 0x20)))
  #define DMA_TCD29_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 29 * 0x20)))
  #define DMA_TCD30_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 30 * 0x20)))
  #define DMA_TCD31_CSR (* ((volatile uint16_t *) (0x40008000 + 0x101c + 31 * 0x20)))
 {
    BWC:2 // at 14: Bandwidth Control
    1
    MAJORLINKCH:5 // at 8: Major Loop Link Channel Number
    DONE // at 7: Channel Done
    ACTIVE // at 6: Channel Active
    MAJORELINK // at 5: Enable channel-to-channel linking on major loop complete
    ESG // at 4: Enable Scatter/Gather Processing
    DREQ // at 3: Disable Request
    INTHALF // at 2: Enable an interrupt when major counter is half complete.
    INTMAJOR // at 1: Enable an interrupt when major iteration count completes.
    START // at 0: Channel Start
  }

//---  Registers TCD_BITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  #define DMA_TCD_BITER_ELINKNO(idx) (* ((volatile uint16_t *) (0x40008000 + 0x101e + (idx) * 0x20)))
  #define DMA_TCD0_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 0 * 0x20)))
  #define DMA_TCD1_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 1 * 0x20)))
  #define DMA_TCD2_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 2 * 0x20)))
  #define DMA_TCD3_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 3 * 0x20)))
  #define DMA_TCD4_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 4 * 0x20)))
  #define DMA_TCD5_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 5 * 0x20)))
  #define DMA_TCD6_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 6 * 0x20)))
  #define DMA_TCD7_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 7 * 0x20)))
  #define DMA_TCD8_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 8 * 0x20)))
  #define DMA_TCD9_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 9 * 0x20)))
  #define DMA_TCD10_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 10 * 0x20)))
  #define DMA_TCD11_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 11 * 0x20)))
  #define DMA_TCD12_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 12 * 0x20)))
  #define DMA_TCD13_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 13 * 0x20)))
  #define DMA_TCD14_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 14 * 0x20)))
  #define DMA_TCD15_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 15 * 0x20)))
  #define DMA_TCD16_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 16 * 0x20)))
  #define DMA_TCD17_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 17 * 0x20)))
  #define DMA_TCD18_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 18 * 0x20)))
  #define DMA_TCD19_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 19 * 0x20)))
  #define DMA_TCD20_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 20 * 0x20)))
  #define DMA_TCD21_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 21 * 0x20)))
  #define DMA_TCD22_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 22 * 0x20)))
  #define DMA_TCD23_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 23 * 0x20)))
  #define DMA_TCD24_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 24 * 0x20)))
  #define DMA_TCD25_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 25 * 0x20)))
  #define DMA_TCD26_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 26 * 0x20)))
  #define DMA_TCD27_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 27 * 0x20)))
  #define DMA_TCD28_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 28 * 0x20)))
  #define DMA_TCD29_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 29 * 0x20)))
  #define DMA_TCD30_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 30 * 0x20)))
  #define DMA_TCD31_BITER_ELINKNO (* ((volatile uint16_t *) (0x40008000 + 0x101e + 31 * 0x20)))
 {
    ELINK // at 15: Enables channel-to-channel linking on minor loop complete
    BITER:15 // at 0: Starting Major Iteration Count
  }

//---  Registers TCD_BITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
  #define DMA_TCD_BITER_ELINKYES(idx) (* ((volatile uint16_t *) (0x40008000 + 0x101e + (idx) * 0x20)))
  #define DMA_TCD0_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 0 * 0x20)))
  #define DMA_TCD1_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 1 * 0x20)))
  #define DMA_TCD2_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 2 * 0x20)))
  #define DMA_TCD3_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 3 * 0x20)))
  #define DMA_TCD4_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 4 * 0x20)))
  #define DMA_TCD5_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 5 * 0x20)))
  #define DMA_TCD6_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 6 * 0x20)))
  #define DMA_TCD7_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 7 * 0x20)))
  #define DMA_TCD8_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 8 * 0x20)))
  #define DMA_TCD9_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 9 * 0x20)))
  #define DMA_TCD10_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 10 * 0x20)))
  #define DMA_TCD11_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 11 * 0x20)))
  #define DMA_TCD12_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 12 * 0x20)))
  #define DMA_TCD13_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 13 * 0x20)))
  #define DMA_TCD14_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 14 * 0x20)))
  #define DMA_TCD15_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 15 * 0x20)))
  #define DMA_TCD16_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 16 * 0x20)))
  #define DMA_TCD17_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 17 * 0x20)))
  #define DMA_TCD18_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 18 * 0x20)))
  #define DMA_TCD19_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 19 * 0x20)))
  #define DMA_TCD20_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 20 * 0x20)))
  #define DMA_TCD21_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 21 * 0x20)))
  #define DMA_TCD22_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 22 * 0x20)))
  #define DMA_TCD23_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 23 * 0x20)))
  #define DMA_TCD24_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 24 * 0x20)))
  #define DMA_TCD25_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 25 * 0x20)))
  #define DMA_TCD26_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 26 * 0x20)))
  #define DMA_TCD27_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 27 * 0x20)))
  #define DMA_TCD28_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 28 * 0x20)))
  #define DMA_TCD29_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 29 * 0x20)))
  #define DMA_TCD30_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 30 * 0x20)))
  #define DMA_TCD31_BITER_ELINKYES (* ((volatile uint16_t *) (0x40008000 + 0x101e + 31 * 0x20)))
 {
    ELINK // at 15: Enables channel-to-channel linking on minor loop complete
    1
    LINKCH:5 // at 9: Link Channel Number
    BITER:9 // at 0: Starting major iteration count
  }

}

//------------------------------------------------------------------------------
// Peripheral DMAMUX: DMA channel multiplexor
//------------------------------------------------------------------------------

registers ©DMAMUX @at 0x40021000 {
//---  Registers CHCFG(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Channel Configuration register
  #define DMAMUX_CHCFG(idx) (* ((volatile uint8_t *) (0x40021000 + 0x0 + (idx) * 0x1)))
  #define DMAMUX_CHCFG0 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 0 * 0x1)))
  #define DMAMUX_CHCFG1 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 1 * 0x1)))
  #define DMAMUX_CHCFG2 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 2 * 0x1)))
  #define DMAMUX_CHCFG3 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 3 * 0x1)))
  #define DMAMUX_CHCFG4 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 4 * 0x1)))
  #define DMAMUX_CHCFG5 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 5 * 0x1)))
  #define DMAMUX_CHCFG6 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 6 * 0x1)))
  #define DMAMUX_CHCFG7 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 7 * 0x1)))
  #define DMAMUX_CHCFG8 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 8 * 0x1)))
  #define DMAMUX_CHCFG9 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 9 * 0x1)))
  #define DMAMUX_CHCFG10 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 10 * 0x1)))
  #define DMAMUX_CHCFG11 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 11 * 0x1)))
  #define DMAMUX_CHCFG12 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 12 * 0x1)))
  #define DMAMUX_CHCFG13 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 13 * 0x1)))
  #define DMAMUX_CHCFG14 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 14 * 0x1)))
  #define DMAMUX_CHCFG15 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 15 * 0x1)))
  #define DMAMUX_CHCFG16 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 16 * 0x1)))
  #define DMAMUX_CHCFG17 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 17 * 0x1)))
  #define DMAMUX_CHCFG18 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 18 * 0x1)))
  #define DMAMUX_CHCFG19 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 19 * 0x1)))
  #define DMAMUX_CHCFG20 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 20 * 0x1)))
  #define DMAMUX_CHCFG21 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 21 * 0x1)))
  #define DMAMUX_CHCFG22 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 22 * 0x1)))
  #define DMAMUX_CHCFG23 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 23 * 0x1)))
  #define DMAMUX_CHCFG24 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 24 * 0x1)))
  #define DMAMUX_CHCFG25 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 25 * 0x1)))
  #define DMAMUX_CHCFG26 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 26 * 0x1)))
  #define DMAMUX_CHCFG27 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 27 * 0x1)))
  #define DMAMUX_CHCFG28 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 28 * 0x1)))
  #define DMAMUX_CHCFG29 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 29 * 0x1)))
  #define DMAMUX_CHCFG30 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 30 * 0x1)))
  #define DMAMUX_CHCFG31 (* ((volatile uint8_t *) (0x40021000 + 0x0 + 31 * 0x1)))
 {
    ENBL // at 7: DMA Channel Enable
    TRIG // at 6: DMA Channel Trigger Enable
    SOURCE:6 // at 0: DMA Channel Source (Slot)
  }

}

//------------------------------------------------------------------------------
// Peripheral ENET: Ethernet MAC-NET Core
//------------------------------------------------------------------------------

registers ©ENET @at 0x400c0000 {
//---  Register EIR: Interrupt Event Register
  EIR @offset 0x4 $u32 {
    1
    BABR // at 30: Babbling Receive Error
    BABT // at 29: Babbling Transmit Error
    GRA // at 28: Graceful Stop Complete
    TXF // at 27: Transmit Frame Interrupt
    TXB // at 26: Transmit Buffer Interrupt
    RXF // at 25: Receive Frame Interrupt
    RXB // at 24: Receive Buffer Interrupt
    MII // at 23: MII Interrupt.
    EBERR // at 22: Ethernet Bus Error
    LC // at 21: Late Collision
    RL // at 20: Collision Retry Limit
    UN // at 19: Transmit FIFO Underrun
    PLR // at 18: Payload Receive Error
    WAKEUP // at 17: Node Wakeup Request Indication
    TS_AVAIL // at 16: Transmit Timestamp Available
    TS_TIMER // at 15: Timestamp Timer
    15
  }

//---  Register EIMR: Interrupt Mask Register
  EIMR @offset 0x8 $u32 {
    1
    BABR // at 30: BABR Interrupt Mask
    BABT // at 29: BABT Interrupt Mask
    GRA // at 28: GRA Interrupt Mask
    TXF // at 27: TXF Interrupt Mask
    TXB // at 26: TXB Interrupt Mask
    RXF // at 25: RXF Interrupt Mask
    RXB // at 24: RXB Interrupt Mask
    MII // at 23: MII Interrupt Mask
    EBERR // at 22: EBERR Interrupt Mask
    LC // at 21: LC Interrupt Mask
    RL // at 20: RL Interrupt Mask
    UN // at 19: UN Interrupt Mask
    PLR // at 18: PLR Interrupt Mask
    WAKEUP // at 17: WAKEUP Interrupt Mask
    TS_AVAIL // at 16: TS_AVAIL Interrupt Mask
    TS_TIMER // at 15: TS_TIMER Interrupt Mask
    15
  }

//---  Register RDAR: Receive Descriptor Active Register
  RDAR @offset 0x10 $u32 {
    7
    RDAR // at 24: Receive Descriptor Active
    24
  }

//---  Register TDAR: Transmit Descriptor Active Register
  TDAR @offset 0x14 $u32 {
    7
    TDAR // at 24: Transmit Descriptor Active
    24
  }

//---  Register ECR: Ethernet Control Register
  ECR @offset 0x24 $u32 {
    23
    DBSWP // at 8: Descriptor Byte Swapping Enable
    STOPEN // at 7: STOPEN Signal Control
    DBGEN // at 6: Debug Enable
    1
    EN1588 // at 4: EN1588 Enable
    SLEEP // at 3: Sleep Mode Enable
    MAGICEN // at 2: Magic Packet Detection Enable
    ETHEREN // at 1: Ethernet Enable
    RESET // at 0: Ethernet MAC Reset
  }

//---  Register MMFR: MII Management Frame Register
  MMFR @offset 0x40 $u32 {
    ST:2 // at 30: Start Of Frame Delimiter
    OP:2 // at 28: Operation Code
    PA:5 // at 23: PHY Address
    RA:5 // at 18: Register Address
    TA:2 // at 16: Turn Around
    DATA:16 // at 0: Management Frame Data
  }

//---  Register MSCR: MII Speed Control Register
  MSCR @offset 0x44 $u32 {
    21
    HOLDTIME:3 // at 8: Hold time On MDIO Output
    DIS_PRE // at 7: Disable Preamble
    MII_SPEED:6 // at 1: MII Speed
    1
  }

//---  Register MIBC: MIB Control Register
  MIBC @offset 0x64 $u32 {
    MIB_DIS // at 31: Disable MIB Logic
    MIB_IDLE // at 30: MIB Idle
    MIB_CLEAR // at 29: MIB Clear
    29
  }

//---  Register RCR: Receive Control Register
  RCR @offset 0x84 $u32 {
    GRS // at 31: Graceful Receive Stopped
    NLC // at 30: Payload Length Check Disable
    MAX_FL:14 // at 16: Maximum Frame Length
    CFEN // at 15: MAC Control Frame Enable
    CRCFWD // at 14: Terminate/Forward Received CRC
    PAUFWD // at 13: Terminate/Forward Pause Frames
    PADEN // at 12: Enable Frame Padding Remove On Receive
    2
    RMII_10T // at 9: Enables 10-Mbps mode of the RMII .
    RMII_MODE // at 8: RMII Mode Enable
    2
    FCE // at 5: Flow Control Enable
    BC_REJ // at 4: Broadcast Frame Reject
    PROM // at 3: Promiscuous Mode
    MII_MODE // at 2: Media Independent Interface Mode
    DRT // at 1: Disable Receive On Transmit
    LOOP // at 0: Internal Loopback
  }

//---  Register TCR: Transmit Control Register
  TCR @offset 0xc4 $u32 {
    22
    CRCFWD // at 9: Forward Frame From Application With CRC
    ADDINS // at 8: Set MAC Address On Transmit
    ADDSEL:3 // at 5: Source MAC Address Select On Transmit
    RFC_PAUSE // at 4: Receive Frame Control Pause
    TFC_PAUSE // at 3: Transmit Frame Control Pause
    FDEN // at 2: Full-Duplex Enable
    1
    GTS // at 0: Graceful Transmit Stop
  }

//---  Register PALR: Physical Address Lower Register
  PALR @offset 0xe4 $u32 {
    PADDR1:32 // at 0: Pause Address
  }

//---  Register PAUR: Physical Address Upper Register
  PAUR @offset 0xe8 $u32 {
    PADDR2:16 // at 16: Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames
    TYPE:16 // at 0: Type Field In PAUSE Frames
  }

//---  Register OPD: Opcode/Pause Duration Register
  OPD @offset 0xec $u32 {
    OPCODE:16 // at 16: Opcode Field In PAUSE Frames
    PAUSE_DUR:16 // at 0: Pause Duration
  }

//---  Register IAUR: Descriptor Individual Upper Address Register
  IAUR @offset 0x118 $u32 {
    IADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
  }

//---  Register IALR: Descriptor Individual Lower Address Register
  IALR @offset 0x11c $u32 {
    IADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
  }

//---  Register GAUR: Descriptor Group Upper Address Register
  GAUR @offset 0x120 $u32 {
    GADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
  }

//---  Register GALR: Descriptor Group Lower Address Register
  GALR @offset 0x124 $u32 {
    GADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
  }

//---  Register TFWR: Transmit FIFO Watermark Register
  TFWR @offset 0x144 $u32 {
    23
    STRFWD // at 8: Store And Forward Enable
    2
    TFWR:6 // at 0: Transmit FIFO Write
  }

//---  Register RDSR: Receive Descriptor Ring Start Register
  RDSR @offset 0x180 $u32 {
    R_DES_START:29 // at 3: Pointer to the beginning of the receive buffer descriptor queue.
    3
  }

//---  Register TDSR: Transmit Buffer Descriptor Ring Start Register
  TDSR @offset 0x184 $u32 {
    X_DES_START:29 // at 3: Pointer to the beginning of the transmit buffer descriptor queue.
    3
  }

//---  Register MRBR: Maximum Receive Buffer Size Register
  MRBR @offset 0x188 $u32 {
    21
    R_BUF_SIZE:7 // at 4: Receive buffer size in bytes
    4
  }

//---  Register RSFL: Receive FIFO Section Full Threshold
  RSFL @offset 0x190 $u32 {
    24
    RX_SECTION_FULL:8 // at 0: Value Of Receive FIFO Section Full Threshold
  }

//---  Register RSEM: Receive FIFO Section Empty Threshold
  RSEM @offset 0x194 $u32 {
    11
    STAT_SECTION_EMPTY:5 // at 16: RX Status FIFO Section Empty Threshold
    8
    RX_SECTION_EMPTY:8 // at 0: Value Of The Receive FIFO Section Empty Threshold
  }

//---  Register RAEM: Receive FIFO Almost Empty Threshold
  RAEM @offset 0x198 $u32 {
    24
    RX_ALMOST_EMPTY:8 // at 0: Value Of The Receive FIFO Almost Empty Threshold
  }

//---  Register RAFL: Receive FIFO Almost Full Threshold
  RAFL @offset 0x19c $u32 {
    24
    RX_ALMOST_FULL:8 // at 0: Value Of The Receive FIFO Almost Full Threshold
  }

//---  Register TSEM: Transmit FIFO Section Empty Threshold
  TSEM @offset 0x1a0 $u32 {
    24
    TX_SECTION_EMPTY:8 // at 0: Value Of The Transmit FIFO Section Empty Threshold
  }

//---  Register TAEM: Transmit FIFO Almost Empty Threshold
  TAEM @offset 0x1a4 $u32 {
    24
    TX_ALMOST_EMPTY:8 // at 0: Value of Transmit FIFO Almost Empty Threshold
  }

//---  Register TAFL: Transmit FIFO Almost Full Threshold
  TAFL @offset 0x1a8 $u32 {
    24
    TX_ALMOST_FULL:8 // at 0: Value Of The Transmit FIFO Almost Full Threshold
  }

//---  Register TIPG: Transmit Inter-Packet Gap
  TIPG @offset 0x1ac $u32 {
    27
    IPG:5 // at 0: Transmit Inter-Packet Gap
  }

//---  Register FTRL: Frame Truncation Length
  FTRL @offset 0x1b0 $u32 {
    18
    TRUNC_FL:14 // at 0: Frame Truncation Length
  }

//---  Register TACC: Transmit Accelerator Function Configuration
  TACC @offset 0x1c0 $u32 {
    27
    PROCHK // at 4: Enables insertion of protocol checksum.
    IPCHK // at 3: Enables insertion of IP header checksum.
    2
    SHIFT16 // at 0: TX FIFO Shift-16
  }

//---  Register RACC: Receive Accelerator Function Configuration
  RACC @offset 0x1c4 $u32 {
    24
    SHIFT16 // at 7: RX FIFO Shift-16
    LINEDIS // at 6: Enable Discard Of Frames With MAC Layer Errors
    3
    PRODIS // at 2: Enable Discard Of Frames With Wrong Protocol Checksum
    IPDIS // at 1: Enable Discard Of Frames With Wrong IPv4 Header Checksum
    PADREM // at 0: Enable Padding Removal For Short IP Frames
  }

//---  Register RMON_T_DROP: Reserved Statistic Register
  RMON_T_DROP @offset 0x200 @ro $u32
//---  Register RMON_T_PACKETS: Tx Packet Count Statistic Register
  RMON_T_PACKETS @offset 0x204 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
  RMON_T_BC_PKT @offset 0x208 @ro $u32 {
    16
    TXPKTS:16 // at 0: Broadcast packets
  }

//---  Register RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
  RMON_T_MC_PKT @offset 0x20c @ro $u32 {
    16
    TXPKTS:16 // at 0: Multicast packets
  }

//---  Register RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
  RMON_T_CRC_ALIGN @offset 0x210 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packets with CRC/align error
  }

//---  Register RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
  RMON_T_UNDERSIZE @offset 0x214 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets less than 64 bytes with good CRC
  }

//---  Register RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
  RMON_T_OVERSIZE @offset 0x218 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets greater than MAX_FL bytes with good CRC
  }

//---  Register RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
  RMON_T_FRAG @offset 0x21c @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of packets less than 64 bytes with bad CRC
  }

//---  Register RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
  RMON_T_JAB @offset 0x220 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets greater than MAX_FL bytes and bad CRC
  }

//---  Register RMON_T_COL: Tx Collision Count Statistic Register
  RMON_T_COL @offset 0x224 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit collisions
  }

//---  Register RMON_T_P64: Tx 64-Byte Packets Statistic Register
  RMON_T_P64 @offset 0x228 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 64-byte transmit packets
  }

//---  Register RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
  RMON_T_P65TO127 @offset 0x22c @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 65- to 127-byte transmit packets
  }

//---  Register RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
  RMON_T_P128TO255 @offset 0x230 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 128- to 255-byte transmit packets
  }

//---  Register RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
  RMON_T_P256TO511 @offset 0x234 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 256- to 511-byte transmit packets
  }

//---  Register RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
  RMON_T_P512TO1023 @offset 0x238 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 512- to 1023-byte transmit packets
  }

//---  Register RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
  RMON_T_P1024TO2047 @offset 0x23c @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 1024- to 2047-byte transmit packets
  }

//---  Register RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
  RMON_T_P_GTE2048 @offset 0x240 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets greater than 2048 bytes
  }

//---  Register RMON_T_OCTETS: Tx Octets Statistic Register
  RMON_T_OCTETS @offset 0x244 @ro $u32 {
    TXOCTS:32 // at 0: Number of transmit octets
  }

//---  Register IEEE_T_DROP: IEEE_T_DROP Reserved Statistic Register
  IEEE_T_DROP @offset 0x248 @ro $u32
//---  Register IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
  IEEE_T_FRAME_OK @offset 0x24c @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted OK
  }

//---  Register IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
  IEEE_T_1COL @offset 0x250 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with one collision
  }

//---  Register IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
  IEEE_T_MCOL @offset 0x254 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with multiple collisions
  }

//---  Register IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
  IEEE_T_DEF @offset 0x258 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with deferral delay
  }

//---  Register IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
  IEEE_T_LCOL @offset 0x25c @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with late collision
  }

//---  Register IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
  IEEE_T_EXCOL @offset 0x260 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with excessive collisions
  }

//---  Register IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
  IEEE_T_MACERR @offset 0x264 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with transmit FIFO underrun
  }

//---  Register IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
  IEEE_T_CSERR @offset 0x268 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with carrier sense error
  }

//---  Register IEEE_T_SQE: no description available
  IEEE_T_SQE @offset 0x26c @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with SQE error
  }

//---  Register IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
  IEEE_T_FDXFC @offset 0x270 @ro $u32 {
    16
    COUNT:16 // at 0: Number of flow-control pause frames transmitted
  }

//---  Register IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
  IEEE_T_OCTETS_OK @offset 0x274 @ro $u32 {
    COUNT:32 // at 0: Octet count for frames transmitted without error Counts total octets (includes header and FCS fields).
  }

//---  Register RMON_R_PACKETS: Rx Packet Count Statistic Register
  RMON_R_PACKETS @offset 0x284 @ro $u32 {
    16
    COUNT:16 // at 0: Number of packets received
  }

//---  Register RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
  RMON_R_BC_PKT @offset 0x288 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive broadcast packets
  }

//---  Register RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
  RMON_R_MC_PKT @offset 0x28c @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive multicast packets
  }

//---  Register RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
  RMON_R_CRC_ALIGN @offset 0x290 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets with CRC or align error
  }

//---  Register RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
  RMON_R_UNDERSIZE @offset 0x294 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets with less than 64 bytes and good CRC
  }

//---  Register RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
  RMON_R_OVERSIZE @offset 0x298 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets greater than MAX_FL and good CRC
  }

//---  Register RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
  RMON_R_FRAG @offset 0x29c @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets with less than 64 bytes and bad CRC
  }

//---  Register RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
  RMON_R_JAB @offset 0x2a0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets greater than MAX_FL and bad CRC
  }

//---  Register RMON_R_RESVD_0: Reserved Statistic Register
  RMON_R_RESVD_0 @offset 0x2a4 @ro $u32
//---  Register RMON_R_P64: Rx 64-Byte Packets Statistic Register
  RMON_R_P64 @offset 0x2a8 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 64-byte receive packets
  }

//---  Register RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
  RMON_R_P65TO127 @offset 0x2ac @ro $u32 {
    16
    COUNT:16 // at 0: Number of 65- to 127-byte recieve packets
  }

//---  Register RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
  RMON_R_P128TO255 @offset 0x2b0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 128- to 255-byte recieve packets
  }

//---  Register RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
  RMON_R_P256TO511 @offset 0x2b4 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 256- to 511-byte recieve packets
  }

//---  Register RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
  RMON_R_P512TO1023 @offset 0x2b8 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 512- to 1023-byte recieve packets
  }

//---  Register RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
  RMON_R_P1024TO2047 @offset 0x2bc @ro $u32 {
    16
    COUNT:16 // at 0: Number of 1024- to 2047-byte recieve packets
  }

//---  Register RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
  RMON_R_P_GTE2048 @offset 0x2c0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of greater-than-2048-byte recieve packets
  }

//---  Register RMON_R_OCTETS: Rx Octets Statistic Register
  RMON_R_OCTETS @offset 0x2c4 @ro $u32 {
    COUNT:32 // at 0: Number of receive octets
  }

//---  Register IEEE_R_DROP: Frames not Counted Correctly Statistic Register
  IEEE_R_DROP @offset 0x2c8 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_R_FRAME_OK: Frames Received OK Statistic Register
  IEEE_R_FRAME_OK @offset 0x2cc @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames received OK
  }

//---  Register IEEE_R_CRC: Frames Received with CRC Error Statistic Register
  IEEE_R_CRC @offset 0x2d0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames received with CRC error
  }

//---  Register IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
  IEEE_R_ALIGN @offset 0x2d4 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames received with alignment error
  }

//---  Register IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
  IEEE_R_MACERR @offset 0x2d8 @ro $u32 {
    16
    COUNT:16 // at 0: Receive FIFO overflow count
  }

//---  Register IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
  IEEE_R_FDXFC @offset 0x2dc @ro $u32 {
    16
    COUNT:16 // at 0: Number of flow-control pause frames received
  }

//---  Register IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
  IEEE_R_OCTETS_OK @offset 0x2e0 @ro $u32 {
    COUNT:32 // at 0: Number of octets for frames received without error
  }

//---  Register ATCR: Adjustable Timer Control Register
  ATCR @offset 0x400 $u32 {
    18
    SLAVE // at 13: Enable Timer Slave Mode
    1
    CAPTURE // at 11: Capture Timer Value
    1
    RESTART // at 9: Reset Timer
    1
    PINPER // at 7: Enables event signal output assertion on period event
    2
    PEREN // at 4: Enable Periodical Event
    OFFRST // at 3: Reset Timer On Offset Event
    OFFEN // at 2: Enable One-Shot Offset Event
    1
    EN // at 0: Enable Timer
  }

//---  Register ATVR: Timer Value Register
  ATVR @offset 0x404 $u32 {
    ATIME:32 // at 0: A write sets the timer
  }

//---  Register ATOFF: Timer Offset Register
  ATOFF @offset 0x408 $u32 {
    OFFSET:32 // at 0: Offset value for one-shot event generation
  }

//---  Register ATPER: Timer Period Register
  ATPER @offset 0x40c $u32 {
    PERIOD:32 // at 0: Value for generating periodic events
  }

//---  Register ATCOR: Timer Correction Register
  ATCOR @offset 0x410 $u32 {
    1
    COR:31 // at 0: Correction Counter Wrap-Around Value
  }

//---  Register ATINC: Time-Stamping Clock Period Register
  ATINC @offset 0x414 $u32 {
    17
    INC_CORR:7 // at 8: Correction Increment Value
    1
    INC:7 // at 0: Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
  }

//---  Register ATSTMP: Timestamp of Last Transmitted Frame
  ATSTMP @offset 0x418 @ro $u32 {
    TIMESTAMP:32 // at 0: Timestamp of the last frame transmitted by the core that had TxBD[TS] set
  }

//---  Register TGSR: Timer Global Status Register
  TGSR @offset 0x604 $u32 {
    28
    TF3 // at 3: Copy Of Timer Flag For Channel 3
    TF2 // at 2: Copy Of Timer Flag For Channel 2
    TF1 // at 1: Copy Of Timer Flag For Channel 1
    TF0 // at 0: Copy Of Timer Flag For Channel 0
  }

//---  Registers TCSR(0,1,2,3): Timer Control Status Register
  #define ENET_TCSR(idx) (* ((volatile uint32_t *) (0x400c0000 + 0x608 + (idx) * 0x8)))
  #define ENET_TCSR0 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 0 * 0x8)))
  #define ENET_TCSR1 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 1 * 0x8)))
  #define ENET_TCSR2 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 2 * 0x8)))
  #define ENET_TCSR3 (* ((volatile uint32_t *) (0x400c0000 + 0x608 + 3 * 0x8)))
 {
    24
    TF // at 7: Timer Flag
    TIE // at 6: Timer Interrupt Enable
    TMODE:4 // at 2: Timer Mode
    1
    TDRE // at 0: Timer DMA Request Enable
  }

//---  Registers TCCR(0,1,2,3): Timer Compare Capture Register
  #define ENET_TCCR(idx) (* ((volatile uint32_t *) (0x400c0000 + 0x60c + (idx) * 0x8)))
  #define ENET_TCCR0 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 0 * 0x8)))
  #define ENET_TCCR1 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 1 * 0x8)))
  #define ENET_TCCR2 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 2 * 0x8)))
  #define ENET_TCCR3 (* ((volatile uint32_t *) (0x400c0000 + 0x60c + 3 * 0x8)))
 {
    TCC:32 // at 0: Timer Capture Compare
  }

}

//------------------------------------------------------------------------------
// Peripheral EWM: External Watchdog Monitor
//------------------------------------------------------------------------------

registers ©EWM @at 0x40061000 {
//---  Register CTRL: Control Register
  CTRL @offset 0x0 $u8 {
    4
    INTEN // at 3: Interrupt Enable.
    INEN // at 2: Input Enable.
    ASSIN // at 1: EWM_in's Assertion State Select.
    EWMEN // at 0: EWM enable.
  }

//---  Register SERV: Service Register
  SERV @offset 0x1 $u8 {
    SERVICE:8 // at 0: The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
  }

//---  Register CMPL: Compare Low Register
  CMPL @offset 0x2 $u8 {
    COMPAREL:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
  }

//---  Register CMPH: Compare High Register
  CMPH @offset 0x3 $u8 {
    COMPAREH:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
  }

}

//------------------------------------------------------------------------------
// Peripheral FB: FlexBus external bus interface
//------------------------------------------------------------------------------

registers ©FB @at 0x4000c000 {
//---  Registers CSAR(0,1,2,3,4,5): Chip Select Address Register
  #define FB_CSAR(idx) (* ((volatile uint32_t *) (0x4000c000 + 0x0 + (idx) * 0xc)))
  #define FB_CSAR0 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 0 * 0xc)))
  #define FB_CSAR1 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 1 * 0xc)))
  #define FB_CSAR2 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 2 * 0xc)))
  #define FB_CSAR3 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 3 * 0xc)))
  #define FB_CSAR4 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 4 * 0xc)))
  #define FB_CSAR5 (* ((volatile uint32_t *) (0x4000c000 + 0x0 + 5 * 0xc)))
 {
    BA:16 // at 16: Base Address
    16
  }

//---  Registers CSMR(0,1,2,3,4,5): Chip Select Mask Register
  #define FB_CSMR(idx) (* ((volatile uint32_t *) (0x4000c000 + 0x4 + (idx) * 0xc)))
  #define FB_CSMR0 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 0 * 0xc)))
  #define FB_CSMR1 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 1 * 0xc)))
  #define FB_CSMR2 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 2 * 0xc)))
  #define FB_CSMR3 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 3 * 0xc)))
  #define FB_CSMR4 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 4 * 0xc)))
  #define FB_CSMR5 (* ((volatile uint32_t *) (0x4000c000 + 0x4 + 5 * 0xc)))
 {
    BAM:16 // at 16: Base Address Mask
    7
    WP // at 8: Write Protect
    7
    V // at 0: Valid
  }

//---  Registers CSCR(0,1,2,3,4,5): Chip Select Control Register
  #define FB_CSCR(idx) (* ((volatile uint32_t *) (0x4000c000 + 0x8 + (idx) * 0xc)))
  #define FB_CSCR0 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 0 * 0xc)))
  #define FB_CSCR1 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 1 * 0xc)))
  #define FB_CSCR2 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 2 * 0xc)))
  #define FB_CSCR3 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 3 * 0xc)))
  #define FB_CSCR4 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 4 * 0xc)))
  #define FB_CSCR5 (* ((volatile uint32_t *) (0x4000c000 + 0x8 + 5 * 0xc)))
 {
    SWS:6 // at 26: Secondary Wait States
    2
    SWSEN // at 23: Secondary Wait State Enable
    EXTS // at 22: Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
    ASET:2 // at 20: Address Setup
    RDAH:2 // at 18: Read Address Hold or Deselect
    WRAH:2 // at 16: Write Address Hold or Deselect
    WS:6 // at 10: Wait States
    BLS // at 9: Byte-Lane Shift
    AA // at 8: Auto-Acknowledge Enable
    PS:2 // at 6: Port Size
    BEM // at 5: Byte-Enable Mode
    BSTR // at 4: Burst-Read Enable
    BSTW // at 3: Burst-Write Enable
    3
  }

//---  Register CSPMCR: Chip Select port Multiplexing Control Register
  CSPMCR @offset 0x60 $u32 {
    GROUP1:4 // at 28: FlexBus Signal Group 1 Multiplex control
    GROUP2:4 // at 24: FlexBus Signal Group 2 Multiplex control
    GROUP3:4 // at 20: FlexBus Signal Group 3 Multiplex control
    GROUP4:4 // at 16: FlexBus Signal Group 4 Multiplex control
    GROUP5:4 // at 12: FlexBus Signal Group 5 Multiplex control
    12
  }

}

//------------------------------------------------------------------------------
// Peripheral FMC: Flash Memory Controller-greg
//------------------------------------------------------------------------------

registers ©FMC @at 0x4001f000 {
//---  Register PFAPR: Flash Access Protection Register
  PFAPR @offset 0x0 $u32 {
    8
    M7PFD // at 23: Master 7 Prefetch Disable
    M6PFD // at 22: Master 6 Prefetch Disable
    M5PFD // at 21: Master 5 Prefetch Disable
    M4PFD // at 20: Master 4 Prefetch Disable
    M3PFD // at 19: Master 3 Prefetch Disable
    M2PFD // at 18: Master 2 Prefetch Disable
    M1PFD // at 17: Master 1 Prefetch Disable
    M0PFD // at 16: Master 0 Prefetch Disable
    M7AP:2 // at 14: Master 7 Access Protection
    M6AP:2 // at 12: Master 6 Access Protection
    M5AP:2 // at 10: Master 5 Access Protection
    M4AP:2 // at 8: Master 4 Access Protection
    M3AP:2 // at 6: Master 3 Access Protection
    M2AP:2 // at 4: Master 2 Access Protection
    M1AP:2 // at 2: Master 1 Access Protection
    M0AP:2 // at 0: Master 0 Access Protection
  }

//---  Register PFB01CR: Flash Bank 0-1 Control Register
  PFB01CR @offset 0x4 $u32 {
    B0RWSC:4 // at 28: Bank 0 Read Wait State Control
    CLCK_WAY:4 // at 24: Cache Lock Way x
    CINV_WAY:4 // at 20: Cache Invalidate Way x
    S_B_INV // at 19: Invalidate Prefetch Speculation Buffer
    B0MW:2 // at 17: Bank 0 Memory Width
    9
    CRC:3 // at 5: Cache Replacement Control
    B0DCE // at 4: Bank 0 Data Cache Enable
    B0ICE // at 3: Bank 0 Instruction Cache Enable
    B0DPE // at 2: Bank 0 Data Prefetch Enable
    B0IPE // at 1: Bank 0 Instruction Prefetch Enable
    RFU // at 0: Reserved for future use
  }

//---  Register PFB23CR: Flash Bank 2-3 Control Register
  PFB23CR @offset 0x8 $u32 {
    B1RWSC:4 // at 28: Bank 1 Read Wait State Control
    9
    B1MW:2 // at 17: Bank 1 Memory Width
    12
    B1DCE // at 4: Bank 1 Data Cache Enable
    B1ICE // at 3: Bank 1 Instruction Cache Enable
    B1DPE // at 2: Bank 1 Data Prefetch Enable
    B1IPE // at 1: Bank 1 Instruction Prefetch Enable
    RFU // at 0: Reserved for future use
  }

//---  Registers TAGVDW0S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW0S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x100 + (idx) * 0x4)))
  #define FMC_TAGVDW0S0 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 0 * 0x4)))
  #define FMC_TAGVDW0S1 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 1 * 0x4)))
  #define FMC_TAGVDW0S2 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 2 * 0x4)))
  #define FMC_TAGVDW0S3 (* ((volatile uint32_t *) (0x4001f000 + 0x100 + 3 * 0x4)))
 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW1S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW1S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x110 + (idx) * 0x4)))
  #define FMC_TAGVDW1S0 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 0 * 0x4)))
  #define FMC_TAGVDW1S1 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 1 * 0x4)))
  #define FMC_TAGVDW1S2 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 2 * 0x4)))
  #define FMC_TAGVDW1S3 (* ((volatile uint32_t *) (0x4001f000 + 0x110 + 3 * 0x4)))
 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW2S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW2S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x120 + (idx) * 0x4)))
  #define FMC_TAGVDW2S0 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 0 * 0x4)))
  #define FMC_TAGVDW2S1 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 1 * 0x4)))
  #define FMC_TAGVDW2S2 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 2 * 0x4)))
  #define FMC_TAGVDW2S3 (* ((volatile uint32_t *) (0x4001f000 + 0x120 + 3 * 0x4)))
 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW3S(0,1,2,3): Cache Tag Storage
  #define FMC_TAGVDW3S(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x130 + (idx) * 0x4)))
  #define FMC_TAGVDW3S0 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 0 * 0x4)))
  #define FMC_TAGVDW3S1 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 1 * 0x4)))
  #define FMC_TAGVDW3S2 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 2 * 0x4)))
  #define FMC_TAGVDW3S3 (* ((volatile uint32_t *) (0x4001f000 + 0x130 + 3 * 0x4)))
 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers DATAW0SUM(0,1,2,3): Cache Data Storage (uppermost word)
  #define FMC_DATAW0SUM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x200 + (idx) * 0x10)))
  #define FMC_DATAW0S0UM (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 0 * 0x10)))
  #define FMC_DATAW0S1UM (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 1 * 0x10)))
  #define FMC_DATAW0S2UM (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 2 * 0x10)))
  #define FMC_DATAW0S3UM (* ((volatile uint32_t *) (0x4001f000 + 0x200 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW0SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  #define FMC_DATAW0SMU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x204 + (idx) * 0x10)))
  #define FMC_DATAW0S0MU (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 0 * 0x10)))
  #define FMC_DATAW0S1MU (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 1 * 0x10)))
  #define FMC_DATAW0S2MU (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 2 * 0x10)))
  #define FMC_DATAW0S3MU (* ((volatile uint32_t *) (0x4001f000 + 0x204 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW0SML(0,1,2,3): Cache Data Storage (mid-lower word)
  #define FMC_DATAW0SML(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x208 + (idx) * 0x10)))
  #define FMC_DATAW0S0ML (* ((volatile uint32_t *) (0x4001f000 + 0x208 + 0 * 0x10)))
  #define FMC_DATAW0S1ML (* ((volatile uint32_t *) (0x4001f000 + 0x208 + 1 * 0x10)))
  #define FMC_DATAW0S2ML (* ((volatile uint32_t *) (0x4001f000 + 0x208 + 2 * 0x10)))
  #define FMC_DATAW0S3ML (* ((volatile uint32_t *) (0x4001f000 + 0x208 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW0SLM(0,1,2,3): Cache Data Storage (lowermost word)
  #define FMC_DATAW0SLM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x20c + (idx) * 0x10)))
  #define FMC_DATAW0S0LM (* ((volatile uint32_t *) (0x4001f000 + 0x20c + 0 * 0x10)))
  #define FMC_DATAW0S1LM (* ((volatile uint32_t *) (0x4001f000 + 0x20c + 1 * 0x10)))
  #define FMC_DATAW0S2LM (* ((volatile uint32_t *) (0x4001f000 + 0x20c + 2 * 0x10)))
  #define FMC_DATAW0S3LM (* ((volatile uint32_t *) (0x4001f000 + 0x20c + 3 * 0x10)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW1SUM(0,1,2,3): Cache Data Storage (uppermost word)
  #define FMC_DATAW1SUM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x240 + (idx) * 0x10)))
  #define FMC_DATAW1S0UM (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 0 * 0x10)))
  #define FMC_DATAW1S1UM (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 1 * 0x10)))
  #define FMC_DATAW1S2UM (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 2 * 0x10)))
  #define FMC_DATAW1S3UM (* ((volatile uint32_t *) (0x4001f000 + 0x240 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW1SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  #define FMC_DATAW1SMU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x244 + (idx) * 0x10)))
  #define FMC_DATAW1S0MU (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 0 * 0x10)))
  #define FMC_DATAW1S1MU (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 1 * 0x10)))
  #define FMC_DATAW1S2MU (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 2 * 0x10)))
  #define FMC_DATAW1S3MU (* ((volatile uint32_t *) (0x4001f000 + 0x244 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW1SML(0,1,2,3): Cache Data Storage (mid-lower word)
  #define FMC_DATAW1SML(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x248 + (idx) * 0x10)))
  #define FMC_DATAW1S0ML (* ((volatile uint32_t *) (0x4001f000 + 0x248 + 0 * 0x10)))
  #define FMC_DATAW1S1ML (* ((volatile uint32_t *) (0x4001f000 + 0x248 + 1 * 0x10)))
  #define FMC_DATAW1S2ML (* ((volatile uint32_t *) (0x4001f000 + 0x248 + 2 * 0x10)))
  #define FMC_DATAW1S3ML (* ((volatile uint32_t *) (0x4001f000 + 0x248 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW1SLM(0,1,2,3): Cache Data Storage (lowermost word)
  #define FMC_DATAW1SLM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x24c + (idx) * 0x10)))
  #define FMC_DATAW1S0LM (* ((volatile uint32_t *) (0x4001f000 + 0x24c + 0 * 0x10)))
  #define FMC_DATAW1S1LM (* ((volatile uint32_t *) (0x4001f000 + 0x24c + 1 * 0x10)))
  #define FMC_DATAW1S2LM (* ((volatile uint32_t *) (0x4001f000 + 0x24c + 2 * 0x10)))
  #define FMC_DATAW1S3LM (* ((volatile uint32_t *) (0x4001f000 + 0x24c + 3 * 0x10)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW2SUM(0,1,2,3): Cache Data Storage (uppermost word)
  #define FMC_DATAW2SUM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x280 + (idx) * 0x10)))
  #define FMC_DATAW2S0UM (* ((volatile uint32_t *) (0x4001f000 + 0x280 + 0 * 0x10)))
  #define FMC_DATAW2S1UM (* ((volatile uint32_t *) (0x4001f000 + 0x280 + 1 * 0x10)))
  #define FMC_DATAW2S2UM (* ((volatile uint32_t *) (0x4001f000 + 0x280 + 2 * 0x10)))
  #define FMC_DATAW2S3UM (* ((volatile uint32_t *) (0x4001f000 + 0x280 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW2SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  #define FMC_DATAW2SMU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x284 + (idx) * 0x10)))
  #define FMC_DATAW2S0MU (* ((volatile uint32_t *) (0x4001f000 + 0x284 + 0 * 0x10)))
  #define FMC_DATAW2S1MU (* ((volatile uint32_t *) (0x4001f000 + 0x284 + 1 * 0x10)))
  #define FMC_DATAW2S2MU (* ((volatile uint32_t *) (0x4001f000 + 0x284 + 2 * 0x10)))
  #define FMC_DATAW2S3MU (* ((volatile uint32_t *) (0x4001f000 + 0x284 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW2SML(0,1,2,3): Cache Data Storage (mid-lower word)
  #define FMC_DATAW2SML(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x288 + (idx) * 0x10)))
  #define FMC_DATAW2S0ML (* ((volatile uint32_t *) (0x4001f000 + 0x288 + 0 * 0x10)))
  #define FMC_DATAW2S1ML (* ((volatile uint32_t *) (0x4001f000 + 0x288 + 1 * 0x10)))
  #define FMC_DATAW2S2ML (* ((volatile uint32_t *) (0x4001f000 + 0x288 + 2 * 0x10)))
  #define FMC_DATAW2S3ML (* ((volatile uint32_t *) (0x4001f000 + 0x288 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW2SLM(0,1,2,3): Cache Data Storage (lowermost word)
  #define FMC_DATAW2SLM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x28c + (idx) * 0x10)))
  #define FMC_DATAW2S0LM (* ((volatile uint32_t *) (0x4001f000 + 0x28c + 0 * 0x10)))
  #define FMC_DATAW2S1LM (* ((volatile uint32_t *) (0x4001f000 + 0x28c + 1 * 0x10)))
  #define FMC_DATAW2S2LM (* ((volatile uint32_t *) (0x4001f000 + 0x28c + 2 * 0x10)))
  #define FMC_DATAW2S3LM (* ((volatile uint32_t *) (0x4001f000 + 0x28c + 3 * 0x10)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW3SUM(0,1,2,3): Cache Data Storage (uppermost word)
  #define FMC_DATAW3SUM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x2c0 + (idx) * 0x10)))
  #define FMC_DATAW3S0UM (* ((volatile uint32_t *) (0x4001f000 + 0x2c0 + 0 * 0x10)))
  #define FMC_DATAW3S1UM (* ((volatile uint32_t *) (0x4001f000 + 0x2c0 + 1 * 0x10)))
  #define FMC_DATAW3S2UM (* ((volatile uint32_t *) (0x4001f000 + 0x2c0 + 2 * 0x10)))
  #define FMC_DATAW3S3UM (* ((volatile uint32_t *) (0x4001f000 + 0x2c0 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW3SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  #define FMC_DATAW3SMU(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x2c4 + (idx) * 0x10)))
  #define FMC_DATAW3S0MU (* ((volatile uint32_t *) (0x4001f000 + 0x2c4 + 0 * 0x10)))
  #define FMC_DATAW3S1MU (* ((volatile uint32_t *) (0x4001f000 + 0x2c4 + 1 * 0x10)))
  #define FMC_DATAW3S2MU (* ((volatile uint32_t *) (0x4001f000 + 0x2c4 + 2 * 0x10)))
  #define FMC_DATAW3S3MU (* ((volatile uint32_t *) (0x4001f000 + 0x2c4 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW3SML(0,1,2,3): Cache Data Storage (mid-lower word)
  #define FMC_DATAW3SML(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x2c8 + (idx) * 0x10)))
  #define FMC_DATAW3S0ML (* ((volatile uint32_t *) (0x4001f000 + 0x2c8 + 0 * 0x10)))
  #define FMC_DATAW3S1ML (* ((volatile uint32_t *) (0x4001f000 + 0x2c8 + 1 * 0x10)))
  #define FMC_DATAW3S2ML (* ((volatile uint32_t *) (0x4001f000 + 0x2c8 + 2 * 0x10)))
  #define FMC_DATAW3S3ML (* ((volatile uint32_t *) (0x4001f000 + 0x2c8 + 3 * 0x10)))
 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW3SLM(0,1,2,3): Cache Data Storage (lowermost word)
  #define FMC_DATAW3SLM(idx) (* ((volatile uint32_t *) (0x4001f000 + 0x2cc + (idx) * 0x10)))
  #define FMC_DATAW3S0LM (* ((volatile uint32_t *) (0x4001f000 + 0x2cc + 0 * 0x10)))
  #define FMC_DATAW3S1LM (* ((volatile uint32_t *) (0x4001f000 + 0x2cc + 1 * 0x10)))
  #define FMC_DATAW3S2LM (* ((volatile uint32_t *) (0x4001f000 + 0x2cc + 2 * 0x10)))
  #define FMC_DATAW3S3LM (* ((volatile uint32_t *) (0x4001f000 + 0x2cc + 3 * 0x10)))
 {
    data:32 // at 0: Bits [31:0] of data entry
  }

}

//------------------------------------------------------------------------------
// Peripheral FTFE: Flash Memory Interface
//------------------------------------------------------------------------------

registers ©FTFE @at 0x40020000 {
//---  Register FSTAT: Flash Status Register
  FSTAT @offset 0x0 $u8 {
    CCIF // at 7: Command Complete Interrupt Flag
    RDCOLERR // at 6: FTFE Read Collision Error Flag
    ACCERR // at 5: Flash Access Error Flag
    FPVIOL // at 4: Flash Protection Violation Flag
    3
    MGSTAT0 // at 0: Memory Controller Command Completion Status Flag
  }

//---  Register FCNFG: Flash Configuration Register
  FCNFG @offset 0x1 $u8 {
    CCIE // at 7: Command Complete Interrupt Enable
    RDCOLLIE // at 6: Read Collision Error Interrupt Enable
    ERSAREQ // at 5: Erase All Request
    ERSSUSP // at 4: Erase Suspend
    SWAP // at 3: Swap
    PFLSH // at 2: FTFE configuration
    RAMRDY // at 1: RAM Ready
    EEERDY // at 0: For devices with FlexNVM: This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
  }

//---  Register FSEC: Flash Security Register
  FSEC @offset 0x2 @ro $u8 {
    KEYEN:2 // at 6: Backdoor Key Security Enable
    MEEN:2 // at 4: Mass Erase Enable Bits
    FSLACC:2 // at 2: Freescale Failure Analysis Access Code
    SEC:2 // at 0: Flash Security
  }

//---  Register FOPT: Flash Option Register
  FOPT @offset 0x3 @ro $u8 {
    OPT:8 // at 0: Nonvolatile Option
  }

//---  Register FCCOB_0_3: Flash Common Command Object Registers (0 ... 3)
  FCCOB_0_3 @offset 0x4 $u32
//---  Register FCCOB_4_7: Flash Common Command Object Registers (4 ... 7)
  FCCOB_4_7 @offset 0x8 $u32
//---  Register FCCOB_8_11: Flash Common Command Object Registers (8 ... 11)
  FCCOB_8_11 @offset 0xc $u32
//---  Registers FPROT(3,2,1,0): Program Flash Protection Registers
  #define FTFE_FPROT(idx) (* ((volatile uint8_t *) (0x40020000 + 0x10 + (idx) * 0x1)))
  #define FTFE_FPROT3 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 0 * 0x1)))
  #define FTFE_FPROT2 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 1 * 0x1)))
  #define FTFE_FPROT1 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 2 * 0x1)))
  #define FTFE_FPROT0 (* ((volatile uint8_t *) (0x40020000 + 0x10 + 3 * 0x1)))
 {
    PROT:8 // at 0: Program Flash Region Protect
  }

//---  Register FEPROT: EEPROM Protection Register
  FEPROT @offset 0x16 $u8 {
    EPROT:8 // at 0: EEPROM Region Protect
  }

//---  Register FDPROT: Data Flash Protection Register
  FDPROT @offset 0x17 $u8 {
    DPROT:8 // at 0: Data Flash Region Protect
  }

//---  Registers XACC(H3,H2,H1,H0,L3,L2,L1,L0): Execute-only Access Registers
  #define FTFE_XACC(idx) (* ((volatile uint8_t *) (0x40020000 + 0x18 + (idx) * 0x1)))
  #define FTFE_XACCH3 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 0 * 0x1)))
  #define FTFE_XACCH2 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 1 * 0x1)))
  #define FTFE_XACCH1 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 2 * 0x1)))
  #define FTFE_XACCH0 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 3 * 0x1)))
  #define FTFE_XACCL3 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 4 * 0x1)))
  #define FTFE_XACCL2 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 5 * 0x1)))
  #define FTFE_XACCL1 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 6 * 0x1)))
  #define FTFE_XACCL0 (* ((const volatile uint8_t *) (0x40020000 + 0x18 + 7 * 0x1)))
 {
    XA:8 // at 0: Execute-only access control
  }

//---  Registers SACC(H3,H2,H1,H0,L3,L2,L1,L0): Supervisor-only Access Registers
  #define FTFE_SACC(idx) (* ((volatile uint8_t *) (0x40020000 + 0x20 + (idx) * 0x1)))
  #define FTFE_SACCH3 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 0 * 0x1)))
  #define FTFE_SACCH2 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 1 * 0x1)))
  #define FTFE_SACCH1 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 2 * 0x1)))
  #define FTFE_SACCH0 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 3 * 0x1)))
  #define FTFE_SACCL3 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 4 * 0x1)))
  #define FTFE_SACCL2 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 5 * 0x1)))
  #define FTFE_SACCL1 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 6 * 0x1)))
  #define FTFE_SACCL0 (* ((const volatile uint8_t *) (0x40020000 + 0x20 + 7 * 0x1)))
 {
    SA:8 // at 0: Supervisor-only access control
  }

//---  Register FACSS: Flash Access Segment Size Register
  FACSS @offset 0x28 @ro $u8 {
    SGSIZE:8 // at 0: Segment Size
  }

//---  Register FACSN: Flash Access Segment Number Register
  FACSN @offset 0x2b @ro $u8 {
    NUMSG:8 // at 0: Number of Segments Indicator
  }

}

//------------------------------------------------------------------------------
// Peripheral FTFE_FlashConfig: Flash configuration field
//------------------------------------------------------------------------------

registers ©FTFE_FlashConfig @at 0x400 {
//---  Register BACKKEY3: Backdoor Comparison Key 3.
  BACKKEY3 @offset 0x0 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY2: Backdoor Comparison Key 2.
  BACKKEY2 @offset 0x1 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY1: Backdoor Comparison Key 1.
  BACKKEY1 @offset 0x2 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY0: Backdoor Comparison Key 0.
  BACKKEY0 @offset 0x3 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY7: Backdoor Comparison Key 7.
  BACKKEY7 @offset 0x4 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY6: Backdoor Comparison Key 6.
  BACKKEY6 @offset 0x5 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY5: Backdoor Comparison Key 5.
  BACKKEY5 @offset 0x6 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY4: Backdoor Comparison Key 4.
  BACKKEY4 @offset 0x7 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register FPROT3: Non-volatile P-Flash Protection 1 - Low Register
  FPROT3 @offset 0x8 @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT2: Non-volatile P-Flash Protection 1 - High Register
  FPROT2 @offset 0x9 @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT1: Non-volatile P-Flash Protection 0 - Low Register
  FPROT1 @offset 0xa @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT0: Non-volatile P-Flash Protection 0 - High Register
  FPROT0 @offset 0xb @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FSEC: Non-volatile Flash Security Register
  FSEC @offset 0xc @ro $u8 {
    KEYEN:2 // at 6: Backdoor Key Security Enable
    MEEN:2 // at 4: no description available
    FSLACC:2 // at 2: Freescale Failure Analysis Access Code
    SEC:2 // at 0: Flash Security
  }

//---  Register FOPT: Non-volatile Flash Option Register
  FOPT @offset 0xd @ro $u8 {
    5
    NMI_DIS // at 2: no description available
    EZPORT_DIS // at 1: no description available
    LPBOOT // at 0: no description available
  }

//---  Register FEPROT: Non-volatile EERAM Protection Register
  FEPROT @offset 0xe @ro $u8 {
    EPROT:8 // at 0: no description available
  }

//---  Register FDPROT: Non-volatile D-Flash Protection Register
  FDPROT @offset 0xf @ro $u8 {
    DPROT:8 // at 0: D-Flash Region Protect
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©FTM [4]
//        FTM0 at 0x40038000
//        FTM1 at 0x40039000
//        FTM2 at 0x4003a000
//        FTM3 at 0x400b9000
//------------------------------------------------------------------------------

registers ©FTM [4 @at 0x40038000 0x40039000 0x4003a000 0x400b9000]
          ©FTM0 @at 0x40038000
          ©FTM1 @at 0x40039000
          ©FTM2 @at 0x4003a000
          ©FTM3 @at 0x400b9000
{
//---  Register SC: Status And Control
  SC @offset 0x0 $u32 {
    24
    TOF // at 7: Timer Overflow Flag
    TOIE // at 6: Timer Overflow Interrupt Enable
    CPWMS // at 5: Center-Aligned PWM Select
    CLKS:2 // at 3: Clock Source Selection
    PS:3 // at 0: Prescale Factor Selection
  }

//---  Register CNT: Counter
  CNT @offset 0x4 $u32 {
    16
    COUNT:16 // at 0: Counter Value
  }

//---  Register MOD: Modulo
  MOD @offset 0x8 $u32 {
    16
    MOD:16 // at 0: Modulo Value
  }

//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status And Control
  C0SC @offset 0xc $u32
  C1SC @offset 0x14 $u32
  C2SC @offset 0x1c $u32
  C3SC @offset 0x24 $u32
  C4SC @offset 0x2c $u32
  C5SC @offset 0x34 $u32
  C6SC @offset 0x3c $u32
  C7SC @offset 0x44 $u32 {
    24
    CHF // at 7: Channel Flag
    CHIE // at 6: Channel Interrupt Enable
    MSB // at 5: Channel Mode Select
    MSA // at 4: Channel Mode Select
    ELSB // at 3: Edge or Level Select
    ELSA // at 2: Edge or Level Select
    1
    DMA // at 0: DMA Enable
  }

//---  Registers CV(0,1,2,3,4,5,6,7): Channel (n) Value
  C0V @offset 0x10 $u32
  C1V @offset 0x18 $u32
  C2V @offset 0x20 $u32
  C3V @offset 0x28 $u32
  C4V @offset 0x30 $u32
  C5V @offset 0x38 $u32
  C6V @offset 0x40 $u32
  C7V @offset 0x48 $u32 {
    16
    VAL:16 // at 0: Channel Value
  }

//---  Register CNTIN: Counter Initial Value
  CNTIN @offset 0x4c $u32 {
    16
    INIT:16 // at 0: Initial Value Of The FTM Counter
  }

//---  Register STATUS: Capture And Compare Status
  STATUS @offset 0x50 $u32 {
    24
    CH7F // at 7: Channel 7 Flag
    CH6F // at 6: Channel 6 Flag
    CH5F // at 5: Channel 5 Flag
    CH4F // at 4: Channel 4 Flag
    CH3F // at 3: Channel 3 Flag
    CH2F // at 2: Channel 2 Flag
    CH1F // at 1: Channel 1 Flag
    CH0F // at 0: Channel 0 Flag
  }

//---  Register MODE: Features Mode Selection
  MODE @offset 0x54 $u32 {
    24
    FAULTIE // at 7: Fault Interrupt Enable
    FAULTM:2 // at 5: Fault Control Mode
    CAPTEST // at 4: Capture Test Mode Enable
    PWMSYNC // at 3: PWM Synchronization Mode
    WPDIS // at 2: Write Protection Disable
    INIT // at 1: Initialize The Channels Output
    FTMEN // at 0: FTM Enable
  }

//---  Register SYNC: Synchronization
  SYNC @offset 0x58 $u32 {
    24
    SWSYNC // at 7: PWM Synchronization Software Trigger
    TRIG2 // at 6: PWM Synchronization Hardware Trigger 2
    TRIG1 // at 5: PWM Synchronization Hardware Trigger 1
    TRIG0 // at 4: PWM Synchronization Hardware Trigger 0
    SYNCHOM // at 3: Output Mask Synchronization
    REINIT // at 2: FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
    CNTMAX // at 1: Maximum Loading Point Enable
    CNTMIN // at 0: Minimum Loading Point Enable
  }

//---  Register OUTINIT: Initial State For Channels Output
  OUTINIT @offset 0x5c $u32 {
    24
    CH7OI // at 7: Channel 7 Output Initialization Value
    CH6OI // at 6: Channel 6 Output Initialization Value
    CH5OI // at 5: Channel 5 Output Initialization Value
    CH4OI // at 4: Channel 4 Output Initialization Value
    CH3OI // at 3: Channel 3 Output Initialization Value
    CH2OI // at 2: Channel 2 Output Initialization Value
    CH1OI // at 1: Channel 1 Output Initialization Value
    CH0OI // at 0: Channel 0 Output Initialization Value
  }

//---  Register OUTMASK: Output Mask
  OUTMASK @offset 0x60 $u32 {
    24
    CH7OM // at 7: Channel 7 Output Mask
    CH6OM // at 6: Channel 6 Output Mask
    CH5OM // at 5: Channel 5 Output Mask
    CH4OM // at 4: Channel 4 Output Mask
    CH3OM // at 3: Channel 3 Output Mask
    CH2OM // at 2: Channel 2 Output Mask
    CH1OM // at 1: Channel 1 Output Mask
    CH0OM // at 0: Channel 0 Output Mask
  }

//---  Register COMBINE: Function For Linked Channels
  COMBINE @offset 0x64 $u32 {
    1
    FAULTEN3 // at 30: Fault Control Enable For n = 6
    SYNCEN3 // at 29: Synchronization Enable For n = 6
    DTEN3 // at 28: Deadtime Enable For n = 6
    DECAP3 // at 27: Dual Edge Capture Mode Captures For n = 6
    DECAPEN3 // at 26: Dual Edge Capture Mode Enable For n = 6
    COMP3 // at 25: Complement Of Channel (n) for n = 6
    COMBINE3 // at 24: Combine Channels For n = 6
    1
    FAULTEN2 // at 22: Fault Control Enable For n = 4
    SYNCEN2 // at 21: Synchronization Enable For n = 4
    DTEN2 // at 20: Deadtime Enable For n = 4
    DECAP2 // at 19: Dual Edge Capture Mode Captures For n = 4
    DECAPEN2 // at 18: Dual Edge Capture Mode Enable For n = 4
    COMP2 // at 17: Complement Of Channel (n) For n = 4
    COMBINE2 // at 16: Combine Channels For n = 4
    1
    FAULTEN1 // at 14: Fault Control Enable For n = 2
    SYNCEN1 // at 13: Synchronization Enable For n = 2
    DTEN1 // at 12: Deadtime Enable For n = 2
    DECAP1 // at 11: Dual Edge Capture Mode Captures For n = 2
    DECAPEN1 // at 10: Dual Edge Capture Mode Enable For n = 2
    COMP1 // at 9: Complement Of Channel (n) For n = 2
    COMBINE1 // at 8: Combine Channels For n = 2
    1
    FAULTEN0 // at 6: Fault Control Enable For n = 0
    SYNCEN0 // at 5: Synchronization Enable For n = 0
    DTEN0 // at 4: Deadtime Enable For n = 0
    DECAP0 // at 3: Dual Edge Capture Mode Captures For n = 0
    DECAPEN0 // at 2: Dual Edge Capture Mode Enable For n = 0
    COMP0 // at 1: Complement Of Channel (n) For n = 0
    COMBINE0 // at 0: Combine Channels For n = 0
  }

//---  Register DEADTIME: Deadtime Insertion Control
  DEADTIME @offset 0x68 $u32 {
    24
    DTPS:2 // at 6: Deadtime Prescaler Value
    DTVAL:6 // at 0: Deadtime Value
  }

//---  Register EXTTRIG: FTM External Trigger
  EXTTRIG @offset 0x6c $u32 {
    24
    TRIGF // at 7: Channel Trigger Flag
    INITTRIGEN // at 6: Initialization Trigger Enable
    CH1TRIG // at 5: Channel 1 Trigger Enable
    CH0TRIG // at 4: Channel 0 Trigger Enable
    CH5TRIG // at 3: Channel 5 Trigger Enable
    CH4TRIG // at 2: Channel 4 Trigger Enable
    CH3TRIG // at 1: Channel 3 Trigger Enable
    CH2TRIG // at 0: Channel 2 Trigger Enable
  }

//---  Register POL: Channels Polarity
  POL @offset 0x70 $u32 {
    24
    POL7 // at 7: Channel 7 Polarity
    POL6 // at 6: Channel 6 Polarity
    POL5 // at 5: Channel 5 Polarity
    POL4 // at 4: Channel 4 Polarity
    POL3 // at 3: Channel 3 Polarity
    POL2 // at 2: Channel 2 Polarity
    POL1 // at 1: Channel 1 Polarity
    POL0 // at 0: Channel 0 Polarity
  }

//---  Register FMS: Fault Mode Status
  FMS @offset 0x74 $u32 {
    24
    FAULTF // at 7: Fault Detection Flag
    WPEN // at 6: Write Protection Enable
    FAULTIN // at 5: Fault Inputs
    1
    FAULTF3 // at 3: Fault Detection Flag 3
    FAULTF2 // at 2: Fault Detection Flag 2
    FAULTF1 // at 1: Fault Detection Flag 1
    FAULTF0 // at 0: Fault Detection Flag 0
  }

//---  Register FILTER: Input Capture Filter Control
  FILTER @offset 0x78 $u32 {
    16
    CH3FVAL:4 // at 12: Channel 3 Input Filter
    CH2FVAL:4 // at 8: Channel 2 Input Filter
    CH1FVAL:4 // at 4: Channel 1 Input Filter
    CH0FVAL:4 // at 0: Channel 0 Input Filter
  }

//---  Register FLTCTRL: Fault Control
  FLTCTRL @offset 0x7c $u32 {
    20
    FFVAL:4 // at 8: Fault Input Filter
    FFLTR3EN // at 7: Fault Input 3 Filter Enable
    FFLTR2EN // at 6: Fault Input 2 Filter Enable
    FFLTR1EN // at 5: Fault Input 1 Filter Enable
    FFLTR0EN // at 4: Fault Input 0 Filter Enable
    FAULT3EN // at 3: Fault Input 3 Enable
    FAULT2EN // at 2: Fault Input 2 Enable
    FAULT1EN // at 1: Fault Input 1 Enable
    FAULT0EN // at 0: Fault Input 0 Enable
  }

//---  Register QDCTRL: Quadrature Decoder Control And Status
  QDCTRL @offset 0x80 $u32 {
    24
    PHAFLTREN // at 7: Phase A Input Filter Enable
    PHBFLTREN // at 6: Phase B Input Filter Enable
    PHAPOL // at 5: Phase A Input Polarity
    PHBPOL // at 4: Phase B Input Polarity
    QUADMODE // at 3: Quadrature Decoder Mode
    QUADIR // at 2: FTM Counter Direction In Quadrature Decoder Mode
    TOFDIR // at 1: Timer Overflow Direction In Quadrature Decoder Mode
    QUADEN // at 0: Quadrature Decoder Mode Enable
  }

//---  Register CONF: Configuration
  CONF @offset 0x84 $u32 {
    21
    GTBEOUT // at 10: Global Time Base Output
    GTBEEN // at 9: Global Time Base Enable
    1
    BDMMODE:2 // at 6: BDM Mode
    1
    NUMTOF:5 // at 0: TOF Frequency
  }

//---  Register FLTPOL: FTM Fault Input Polarity
  FLTPOL @offset 0x88 $u32 {
    28
    FLT3POL // at 3: Fault Input 3 Polarity
    FLT2POL // at 2: Fault Input 2 Polarity
    FLT1POL // at 1: Fault Input 1 Polarity
    FLT0POL // at 0: Fault Input 0 Polarity
  }

//---  Register SYNCONF: Synchronization Configuration
  SYNCONF @offset 0x8c $u32 {
    11
    HWSOC // at 20: Software output control synchronization is activated by a hardware trigger.
    HWINVC // at 19: Inverting control synchronization is activated by a hardware trigger.
    HWOM // at 18: Output mask synchronization is activated by a hardware trigger.
    HWWRBUF // at 17: MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
    HWRSTCNT // at 16: FTM counter synchronization is activated by a hardware trigger.
    3
    SWSOC // at 12: Software output control synchronization is activated by the software trigger.
    SWINVC // at 11: Inverting control synchronization is activated by the software trigger.
    SWOM // at 10: Output mask synchronization is activated by the software trigger.
    SWWRBUF // at 9: MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
    SWRSTCNT // at 8: FTM counter synchronization is activated by the software trigger.
    SYNCMODE // at 7: Synchronization Mode
    1
    SWOC // at 5: SWOCTRL Register Synchronization
    INVC // at 4: INVCTRL Register Synchronization
    1
    CNTINC // at 2: CNTIN Register Synchronization
    1
    HWTRIGMODE // at 0: Hardware Trigger Mode
  }

//---  Register INVCTRL: FTM Inverting Control
  INVCTRL @offset 0x90 $u32 {
    28
    INV3EN // at 3: Pair Channels 3 Inverting Enable
    INV2EN // at 2: Pair Channels 2 Inverting Enable
    INV1EN // at 1: Pair Channels 1 Inverting Enable
    INV0EN // at 0: Pair Channels 0 Inverting Enable
  }

//---  Register SWOCTRL: FTM Software Output Control
  SWOCTRL @offset 0x94 $u32 {
    16
    CH7OCV // at 15: Channel 7 Software Output Control Value
    CH6OCV // at 14: Channel 6 Software Output Control Value
    CH5OCV // at 13: Channel 5 Software Output Control Value
    CH4OCV // at 12: Channel 4 Software Output Control Value
    CH3OCV // at 11: Channel 3 Software Output Control Value
    CH2OCV // at 10: Channel 2 Software Output Control Value
    CH1OCV // at 9: Channel 1 Software Output Control Value
    CH0OCV // at 8: Channel 0 Software Output Control Value
    CH7OC // at 7: Channel 7 Software Output Control Enable
    CH6OC // at 6: Channel 6 Software Output Control Enable
    CH5OC // at 5: Channel 5 Software Output Control Enable
    CH4OC // at 4: Channel 4 Software Output Control Enable
    CH3OC // at 3: Channel 3 Software Output Control Enable
    CH2OC // at 2: Channel 2 Software Output Control Enable
    CH1OC // at 1: Channel 1 Software Output Control Enable
    CH0OC // at 0: Channel 0 Software Output Control Enable
  }

//---  Register PWMLOAD: FTM PWM Load
  PWMLOAD @offset 0x98 $u32 {
    22
    LDOK // at 9: Load Enable
    1
    CH7SEL // at 7: Channel 7 Select
    CH6SEL // at 6: Channel 6 Select
    CH5SEL // at 5: Channel 5 Select
    CH4SEL // at 4: Channel 4 Select
    CH3SEL // at 3: Channel 3 Select
    CH2SEL // at 2: Channel 2 Select
    CH1SEL // at 1: Channel 1 Select
    CH0SEL // at 0: Channel 0 Select
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©GPIO [5]
//        GPIOA at 0x400ff000
//        GPIOB at 0x400ff040
//        GPIOC at 0x400ff080
//        GPIOD at 0x400ff0c0
//        GPIOE at 0x400ff100
//------------------------------------------------------------------------------

registers ©GPIO [5 @at 0x400ff000 0x400ff040 0x400ff080 0x400ff0c0 0x400ff100]
          ©GPIOA @at 0x400ff000
          ©GPIOB @at 0x400ff040
          ©GPIOC @at 0x400ff080
          ©GPIOD @at 0x400ff0c0
          ©GPIOE @at 0x400ff100
{
//---  Register PDOR: Port Data Output Register
  PDOR @offset 0x0 $u32 {
    PDO:32 // at 0: Port Data Output
  }

//---  Register PSOR: Port Set Output Register
  PSOR @offset 0x4 $u32 {
    PTSO:32 // at 0: Port Set Output
  }

//---  Register PCOR: Port Clear Output Register
  PCOR @offset 0x8 $u32 {
    PTCO:32 // at 0: Port Clear Output
  }

//---  Register PTOR: Port Toggle Output Register
  PTOR @offset 0xc $u32 {
    PTTO:32 // at 0: Port Toggle Output
  }

//---  Register PDIR: Port Data Input Register
  PDIR @offset 0x10 @ro $u32 {
    PDI:32 // at 0: Port Data Input
  }

//---  Register PDDR: Port Data Direction Register
  PDDR @offset 0x14 $u32 {
    PDD:32 // at 0: Port Data Direction
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©I2C [4]
//        I2C0 at 0x40066000
//        I2C1 at 0x40067000
//        I2C2 at 0x400e6000
//        I2C3 at 0x400e7000
//------------------------------------------------------------------------------

registers ©I2C [4 @at 0x40066000 0x40067000 0x400e6000 0x400e7000]
          ©I2C0 @at 0x40066000
          ©I2C1 @at 0x40067000
          ©I2C2 @at 0x400e6000
          ©I2C3 @at 0x400e7000
{
//---  Register A1: I2C Address Register 1
  A1 @offset 0x0 $u8 {
    AD:7 // at 1: Address
    1
  }

//---  Register F: I2C Frequency Divider register
  F @offset 0x1 $u8 {
    MULT:2 // at 6: Multiplier Factor
    ICR:6 // at 0: ClockRate
  }

//---  Register C1: I2C Control Register 1
  C1 @offset 0x2 $u8 {
    IICEN // at 7: I2C Enable
    IICIE // at 6: I2C Interrupt Enable
    MST // at 5: Master Mode Select
    TX // at 4: Transmit Mode Select
    TXAK // at 3: Transmit Acknowledge Enable
    RSTA // at 2: Repeat START
    WUEN // at 1: Wakeup Enable
    DMAEN // at 0: DMA Enable
  }

//---  Register S: I2C Status register
  S @offset 0x3 $u8 {
    TCF // at 7: Transfer Complete Flag
    IAAS // at 6: Addressed As A Slave
    BUSY // at 5: Bus Busy
    ARBL // at 4: Arbitration Lost
    RAM // at 3: Range Address Match
    SRW // at 2: Slave Read/Write
    IICIF // at 1: Interrupt Flag
    RXAK // at 0: Receive Acknowledge
  }

//---  Register D: I2C Data I/O register
  D @offset 0x4 $u8 {
    DATA:8 // at 0: Data
  }

//---  Register C2: I2C Control Register 2
  C2 @offset 0x5 $u8 {
    GCAEN // at 7: General Call Address Enable
    ADEXT // at 6: Address Extension
    HDRS // at 5: High Drive Select
    SBRC // at 4: Slave Baud Rate Control
    RMEN // at 3: Range Address Matching Enable
    AD:3 // at 0: Slave Address
  }

//---  Register FLT: I2C Programmable Input Glitch Filter Register
  FLT @offset 0x6 $u8 {
    SHEN // at 7: Stop Hold Enable
    STOPF // at 6: I2C Bus Stop Detect Flag
    SSIE // at 5: I2C Bus Stop or Start Interrupt Enable
    STARTF // at 4: I2C Bus Start Detect Flag
    FLT:4 // at 0: I2C Programmable Filter Factor
  }

//---  Register RA: I2C Range Address register
  RA @offset 0x7 $u8 {
    RAD:7 // at 1: Range Slave Address
    1
  }

//---  Register SMB: I2C SMBus Control and Status register
  SMB @offset 0x8 $u8 {
    FACK // at 7: Fast NACK/ACK Enable
    ALERTEN // at 6: SMBus Alert Response Address Enable
    SIICAEN // at 5: Second I2C Address Enable
    TCKSEL // at 4: Timeout Counter Clock Select
    SLTF // at 3: SCL Low Timeout Flag
    SHTF1 // at 2: SCL High Timeout Flag 1
    SHTF2 // at 1: SCL High Timeout Flag 2
    SHTF2IE // at 0: SHTF2 Interrupt Enable
  }

//---  Register A2: I2C Address Register 2
  A2 @offset 0x9 $u8 {
    SAD:7 // at 1: SMBus Address
    1
  }

//---  Register SLTH: I2C SCL Low Timeout Register High
  SLTH @offset 0xa $u8 {
    SSLT:8 // at 0: SSLT[15:8]
  }

//---  Register SLTL: I2C SCL Low Timeout Register Low
  SLTL @offset 0xb $u8 {
    SSLT:8 // at 0: SSLT[7:0]
  }

}

//------------------------------------------------------------------------------
// Peripheral I2S0: Inter-IC Sound / Synchronous Audio Interface
//------------------------------------------------------------------------------

registers ©I2S0 @at 0x4002f000 {
//---  Register TCSR: SAI Transmit Control Register
  TCSR @offset 0x0 $u32 {
    TE // at 31: Transmitter Enable
    STOPE // at 30: Stop Enable
    DBGE // at 29: Debug Enable
    BCE // at 28: Bit Clock Enable
    2
    FR // at 25: FIFO Reset
    SR // at 24: Software Reset
    3
    WSF // at 20: Word Start Flag
    SEF // at 19: Sync Error Flag
    FEF // at 18: FIFO Error Flag
    FWF // at 17: FIFO Warning Flag
    FRF // at 16: FIFO Request Flag
    3
    WSIE // at 12: Word Start Interrupt Enable
    SEIE // at 11: Sync Error Interrupt Enable
    FEIE // at 10: FIFO Error Interrupt Enable
    FWIE // at 9: FIFO Warning Interrupt Enable
    FRIE // at 8: FIFO Request Interrupt Enable
    6
    FWDE // at 1: FIFO Warning DMA Enable
    FRDE // at 0: FIFO Request DMA Enable
  }

//---  Register TCR1: SAI Transmit Configuration 1 Register
  TCR1 @offset 0x4 $u32 {
    29
    TFW:3 // at 0: Transmit FIFO Watermark
  }

//---  Register TCR2: SAI Transmit Configuration 2 Register
  TCR2 @offset 0x8 $u32 {
    SYNC:2 // at 30: Synchronous Mode
    BCS // at 29: Bit Clock Swap
    BCI // at 28: Bit Clock Input
    MSEL:2 // at 26: MCLK Select
    BCP // at 25: Bit Clock Polarity
    BCD // at 24: Bit Clock Direction
    16
    DIV:8 // at 0: Bit Clock Divide
  }

//---  Register TCR3: SAI Transmit Configuration 3 Register
  TCR3 @offset 0xc $u32 {
    6
    CFR:2 // at 24: Channel FIFO Reset
    6
    TCE:2 // at 16: Transmit Channel Enable
    11
    WDFL:5 // at 0: Word Flag Configuration
  }

//---  Register TCR4: SAI Transmit Configuration 4 Register
  TCR4 @offset 0x10 $u32 {
    3
    FCONT // at 28: FIFO Continue on Error
    FCOMB:2 // at 26: FIFO Combine Mode
    FPACK:2 // at 24: FIFO Packing Mode
    3
    FRSZ:5 // at 16: Frame size
    3
    SYWD:5 // at 8: Sync Width
    3
    MF // at 4: MSB First
    FSE // at 3: Frame Sync Early
    ONDEM // at 2: On Demand Mode
    FSP // at 1: Frame Sync Polarity
    FSD // at 0: Frame Sync Direction
  }

//---  Register TCR5: SAI Transmit Configuration 5 Register
  TCR5 @offset 0x14 $u32 {
    3
    WNW:5 // at 24: Word N Width
    3
    W0W:5 // at 16: Word 0 Width
    3
    FBT:5 // at 8: First Bit Shifted
    8
  }

//---  Registers TDR(0,1): SAI Transmit Data Register
  #define I2S0_TDR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0x20 + (idx) * 0x4)))
  #define I2S0_TDR0 (* ((volatile uint32_t *) (0x4002f000 + 0x20 + 0 * 0x4)))
  #define I2S0_TDR1 (* ((volatile uint32_t *) (0x4002f000 + 0x20 + 1 * 0x4)))
 {
    TDR:32 // at 0: Transmit Data Register
  }

//---  Registers TFR(0,1): SAI Transmit FIFO Register
  #define I2S0_TFR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0x40 + (idx) * 0x4)))
  #define I2S0_TFR0 (* ((const volatile uint32_t *) (0x4002f000 + 0x40 + 0 * 0x4)))
  #define I2S0_TFR1 (* ((const volatile uint32_t *) (0x4002f000 + 0x40 + 1 * 0x4)))
 {
    WCP // at 31: Write Channel Pointer
    11
    WFP:4 // at 16: Write FIFO Pointer
    12
    RFP:4 // at 0: Read FIFO Pointer
  }

//---  Register TMR: SAI Transmit Mask Register
  TMR @offset 0x60 $u32 {
    TWM:32 // at 0: Transmit Word Mask
  }

//---  Register RCSR: SAI Receive Control Register
  RCSR @offset 0x80 $u32 {
    RE // at 31: Receiver Enable
    STOPE // at 30: Stop Enable
    DBGE // at 29: Debug Enable
    BCE // at 28: Bit Clock Enable
    2
    FR // at 25: FIFO Reset
    SR // at 24: Software Reset
    3
    WSF // at 20: Word Start Flag
    SEF // at 19: Sync Error Flag
    FEF // at 18: FIFO Error Flag
    FWF // at 17: FIFO Warning Flag
    FRF // at 16: FIFO Request Flag
    3
    WSIE // at 12: Word Start Interrupt Enable
    SEIE // at 11: Sync Error Interrupt Enable
    FEIE // at 10: FIFO Error Interrupt Enable
    FWIE // at 9: FIFO Warning Interrupt Enable
    FRIE // at 8: FIFO Request Interrupt Enable
    6
    FWDE // at 1: FIFO Warning DMA Enable
    FRDE // at 0: FIFO Request DMA Enable
  }

//---  Register RCR1: SAI Receive Configuration 1 Register
  RCR1 @offset 0x84 $u32 {
    29
    RFW:3 // at 0: Receive FIFO Watermark
  }

//---  Register RCR2: SAI Receive Configuration 2 Register
  RCR2 @offset 0x88 $u32 {
    SYNC:2 // at 30: Synchronous Mode
    BCS // at 29: Bit Clock Swap
    BCI // at 28: Bit Clock Input
    MSEL:2 // at 26: MCLK Select
    BCP // at 25: Bit Clock Polarity
    BCD // at 24: Bit Clock Direction
    16
    DIV:8 // at 0: Bit Clock Divide
  }

//---  Register RCR3: SAI Receive Configuration 3 Register
  RCR3 @offset 0x8c $u32 {
    6
    CFR:2 // at 24: Channel FIFO Reset
    6
    RCE:2 // at 16: Receive Channel Enable
    11
    WDFL:5 // at 0: Word Flag Configuration
  }

//---  Register RCR4: SAI Receive Configuration 4 Register
  RCR4 @offset 0x90 $u32 {
    3
    FCONT // at 28: FIFO Continue on Error
    FCOMB:2 // at 26: FIFO Combine Mode
    FPACK:2 // at 24: FIFO Packing Mode
    3
    FRSZ:5 // at 16: Frame Size
    3
    SYWD:5 // at 8: Sync Width
    3
    MF // at 4: MSB First
    FSE // at 3: Frame Sync Early
    ONDEM // at 2: On Demand Mode
    FSP // at 1: Frame Sync Polarity
    FSD // at 0: Frame Sync Direction
  }

//---  Register RCR5: SAI Receive Configuration 5 Register
  RCR5 @offset 0x94 $u32 {
    3
    WNW:5 // at 24: Word N Width
    3
    W0W:5 // at 16: Word 0 Width
    3
    FBT:5 // at 8: First Bit Shifted
    8
  }

//---  Registers RDR(0,1): SAI Receive Data Register
  #define I2S0_RDR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0xa0 + (idx) * 0x4)))
  #define I2S0_RDR0 (* ((const volatile uint32_t *) (0x4002f000 + 0xa0 + 0 * 0x4)))
  #define I2S0_RDR1 (* ((const volatile uint32_t *) (0x4002f000 + 0xa0 + 1 * 0x4)))
 {
    RDR:32 // at 0: Receive Data Register
  }

//---  Registers RFR(0,1): SAI Receive FIFO Register
  #define I2S0_RFR(idx) (* ((volatile uint32_t *) (0x4002f000 + 0xc0 + (idx) * 0x4)))
  #define I2S0_RFR0 (* ((const volatile uint32_t *) (0x4002f000 + 0xc0 + 0 * 0x4)))
  #define I2S0_RFR1 (* ((const volatile uint32_t *) (0x4002f000 + 0xc0 + 1 * 0x4)))
 {
    12
    WFP:4 // at 16: Write FIFO Pointer
    RCP // at 15: Receive Channel Pointer
    11
    RFP:4 // at 0: Read FIFO Pointer
  }

//---  Register RMR: SAI Receive Mask Register
  RMR @offset 0xe0 $u32 {
    RWM:32 // at 0: Receive Word Mask
  }

//---  Register MCR: SAI MCLK Control Register
  MCR @offset 0x100 $u32 {
    DUF // at 31: Divider Update Flag
    MOE // at 30: MCLK Output Enable
    4
    MICS:2 // at 24: MCLK Input Clock Select
    24
  }

//---  Register MDR: SAI MCLK Divide Register
  MDR @offset 0x104 $u32 {
    12
    FRACT:8 // at 12: MCLK Fraction
    DIVIDE:12 // at 0: MCLK Divide
  }

}

//------------------------------------------------------------------------------
// Peripheral LLWU: Low leakage wakeup unit
//------------------------------------------------------------------------------

registers ©LLWU @at 0x4007c000 {
//---  Register PE1: LLWU Pin Enable 1 register
  PE1 @offset 0x0 $u8 {
    WUPE3:2 // at 6: Wakeup Pin Enable For LLWU_P3
    WUPE2:2 // at 4: Wakeup Pin Enable For LLWU_P2
    WUPE1:2 // at 2: Wakeup Pin Enable For LLWU_P1
    WUPE0:2 // at 0: Wakeup Pin Enable For LLWU_P0
  }

//---  Register PE2: LLWU Pin Enable 2 register
  PE2 @offset 0x1 $u8 {
    WUPE7:2 // at 6: Wakeup Pin Enable For LLWU_P7
    WUPE6:2 // at 4: Wakeup Pin Enable For LLWU_P6
    WUPE5:2 // at 2: Wakeup Pin Enable For LLWU_P5
    WUPE4:2 // at 0: Wakeup Pin Enable For LLWU_P4
  }

//---  Register PE3: LLWU Pin Enable 3 register
  PE3 @offset 0x2 $u8 {
    WUPE11:2 // at 6: Wakeup Pin Enable For LLWU_P11
    WUPE10:2 // at 4: Wakeup Pin Enable For LLWU_P10
    WUPE9:2 // at 2: Wakeup Pin Enable For LLWU_P9
    WUPE8:2 // at 0: Wakeup Pin Enable For LLWU_P8
  }

//---  Register PE4: LLWU Pin Enable 4 register
  PE4 @offset 0x3 $u8 {
    WUPE15:2 // at 6: Wakeup Pin Enable For LLWU_P15
    WUPE14:2 // at 4: Wakeup Pin Enable For LLWU_P14
    WUPE13:2 // at 2: Wakeup Pin Enable For LLWU_P13
    WUPE12:2 // at 0: Wakeup Pin Enable For LLWU_P12
  }

//---  Register PE5: LLWU Pin Enable 5 register
  PE5 @offset 0x4 $u8 {
    WUPE19:2 // at 6: Wakeup Pin Enable For LLWU_P19
    WUPE18:2 // at 4: Wakeup Pin Enable For LLWU_P18
    WUPE17:2 // at 2: Wakeup Pin Enable For LLWU_P17
    WUPE16:2 // at 0: Wakeup Pin Enable For LLWU_P16
  }

//---  Register PE6: LLWU Pin Enable 6 register
  PE6 @offset 0x5 $u8 {
    WUPE23:2 // at 6: Wakeup Pin Enable For LLWU_P23
    WUPE22:2 // at 4: Wakeup Pin Enable For LLWU_P22
    WUPE21:2 // at 2: Wakeup Pin Enable For LLWU_P21
    WUPE20:2 // at 0: Wakeup Pin Enable For LLWU_P20
  }

//---  Register PE7: LLWU Pin Enable 7 register
  PE7 @offset 0x6 $u8 {
    WUPE27:2 // at 6: Wakeup Pin Enable For LLWU_P27
    WUPE26:2 // at 4: Wakeup Pin Enable For LLWU_P26
    WUPE25:2 // at 2: Wakeup Pin Enable For LLWU_P25
    WUPE24:2 // at 0: Wakeup Pin Enable For LLWU_P24
  }

//---  Register PE8: LLWU Pin Enable 8 register
  PE8 @offset 0x7 $u8 {
    WUPE31:2 // at 6: Wakeup Pin Enable For LLWU_P31
    WUPE30:2 // at 4: Wakeup Pin Enable For LLWU_P30
    WUPE29:2 // at 2: Wakeup Pin Enable For LLWU_P29
    WUPE28:2 // at 0: Wakeup Pin Enable For LLWU_P28
  }

//---  Register ME: LLWU Module Enable register
  ME @offset 0x8 $u8 {
    WUME7 // at 7: Wakeup Module Enable For Module 7
    WUME6 // at 6: Wakeup Module Enable For Module 6
    WUME5 // at 5: Wakeup Module Enable For Module 5
    WUME4 // at 4: Wakeup Module Enable For Module 4
    WUME3 // at 3: Wakeup Module Enable For Module 3
    WUME2 // at 2: Wakeup Module Enable For Module 2
    WUME1 // at 1: Wakeup Module Enable for Module 1
    WUME0 // at 0: Wakeup Module Enable For Module 0
  }

//---  Register PF1: LLWU Pin Flag 1 register
  PF1 @offset 0x9 $u8 {
    WUF7 // at 7: Wakeup Flag For LLWU_P7
    WUF6 // at 6: Wakeup Flag For LLWU_P6
    WUF5 // at 5: Wakeup Flag For LLWU_P5
    WUF4 // at 4: Wakeup Flag For LLWU_P4
    WUF3 // at 3: Wakeup Flag For LLWU_P3
    WUF2 // at 2: Wakeup Flag For LLWU_P2
    WUF1 // at 1: Wakeup Flag For LLWU_P1
    WUF0 // at 0: Wakeup Flag For LLWU_P0
  }

//---  Register PF2: LLWU Pin Flag 2 register
  PF2 @offset 0xa $u8 {
    WUF15 // at 7: Wakeup Flag For LLWU_P15
    WUF14 // at 6: Wakeup Flag For LLWU_P14
    WUF13 // at 5: Wakeup Flag For LLWU_P13
    WUF12 // at 4: Wakeup Flag For LLWU_P12
    WUF11 // at 3: Wakeup Flag For LLWU_P11
    WUF10 // at 2: Wakeup Flag For LLWU_P10
    WUF9 // at 1: Wakeup Flag For LLWU_P9
    WUF8 // at 0: Wakeup Flag For LLWU_P8
  }

//---  Register PF3: LLWU Pin Flag 3 register
  PF3 @offset 0xb $u8 {
    WUF23 // at 7: Wakeup Flag For LLWU_P23
    WUF22 // at 6: Wakeup Flag For LLWU_P22
    WUF21 // at 5: Wakeup Flag For LLWU_P21
    WUF20 // at 4: Wakeup Flag For LLWU_P20
    WUF19 // at 3: Wakeup Flag For LLWU_P19
    WUF18 // at 2: Wakeup Flag For LLWU_P18
    WUF17 // at 1: Wakeup Flag For LLWU_P17
    WUF16 // at 0: Wakeup Flag For LLWU_P16
  }

//---  Register PF4: LLWU Pin Flag 4 register
  PF4 @offset 0xc $u8 {
    WUF31 // at 7: Wakeup Flag For LLWU_P31
    WUF30 // at 6: Wakeup Flag For LLWU_P30
    WUF29 // at 5: Wakeup Flag For LLWU_P29
    WUF28 // at 4: Wakeup Flag For LLWU_P28
    WUF27 // at 3: Wakeup Flag For LLWU_P27
    WUF26 // at 2: Wakeup Flag For LLWU_P26
    WUF25 // at 1: Wakeup Flag For LLWU_P25
    WUF24 // at 0: Wakeup Flag For LLWU_P24
  }

//---  Register MF5: LLWU Module Flag 5 register
  MF5 @offset 0xd @ro $u8 {
    MWUF7 // at 7: Wakeup flag For module 7
    MWUF6 // at 6: Wakeup flag For module 6
    MWUF5 // at 5: Wakeup flag For module 5
    MWUF4 // at 4: Wakeup flag For module 4
    MWUF3 // at 3: Wakeup flag For module 3
    MWUF2 // at 2: Wakeup flag For module 2
    MWUF1 // at 1: Wakeup flag For module 1
    MWUF0 // at 0: Wakeup flag For module 0
  }

//---  Register FILT1: LLWU Pin Filter 1 register
  FILT1 @offset 0xe $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

//---  Register FILT2: LLWU Pin Filter 2 register
  FILT2 @offset 0xf $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

//---  Register FILT3: LLWU Pin Filter 3 register
  FILT3 @offset 0x10 $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

//---  Register FILT4: LLWU Pin Filter 4 register
  FILT4 @offset 0x11 $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

}

//------------------------------------------------------------------------------
// Peripheral LMEM: Local Memory Controller
//------------------------------------------------------------------------------

registers ©LMEM @at 0xe0082000 {
//---  Register PCCCR: Cache control register
  PCCCR @offset 0x0 $u32 {
    GO // at 31: Initiate Cache Command
    3
    PUSHW1 // at 27: Push Way 1
    INVW1 // at 26: Invalidate Way 1
    PUSHW0 // at 25: Push Way 0
    INVW0 // at 24: Invalidate Way 0
    20
    PCCR3 // at 3: Forces no allocation on cache misses (must also have PCCR2 asserted)
    PCCR2 // at 2: Forces all cacheable spaces to write through
    ENWRBUF // at 1: Enable Write Buffer
    ENCACHE // at 0: Cache enable
  }

//---  Register PCCLCR: Cache line control register
  PCCLCR @offset 0x4 $u32 {
    4
    LACC // at 27: Line access type
    LADSEL // at 26: Line Address Select
    LCMD:2 // at 24: Line Command
    1
    LCWAY // at 22: Line Command Way
    LCIMB // at 21: Line Command Initial Modified Bit
    LCIVB // at 20: Line Command Initial Valid Bit
    3
    TDSEL // at 16: Tag/Data Select
    1
    WSEL // at 14: Way select
    2
    CACHEADDR:10 // at 2: Cache address
    1
    LGO // at 0: Initiate Cache Line Command
  }

//---  Register PCCSAR: Cache search address register
  PCCSAR @offset 0x8 $u32 {
    PHYADDR:30 // at 2: Physical Address
    1
    LGO // at 0: Initiate Cache Line Command
  }

//---  Register PCCCVR: Cache read/write value register
  PCCCVR @offset 0xc $u32 {
    DATA:32 // at 0: Cache read/write Data
  }

//---  Register PCCRMR: Cache regions mode register
  PCCRMR @offset 0x20 $u32 {
    R0:2 // at 30: Region 0 mode
    R1:2 // at 28: Region 1 mode
    R2:2 // at 26: Region 2 mode
    R3:2 // at 24: Region 3 mode
    R4:2 // at 22: Region 4 mode
    R5:2 // at 20: Region 5 mode
    R6:2 // at 18: Region 6 mode
    R7:2 // at 16: Region 7 mode
    R8:2 // at 14: Region 8 mode
    R9:2 // at 12: Region 9 mode
    R10:2 // at 10: Region 10 mode
    R11:2 // at 8: Region 11 mode
    R12:2 // at 6: Region 12 mode
    R13:2 // at 4: Region 13 mode
    R14:2 // at 2: Region 14 mode
    R15:2 // at 0: Region 15 mode
  }

}

//------------------------------------------------------------------------------
// Peripheral LPTMR0: Low Power Timer
//------------------------------------------------------------------------------

registers ©LPTMR0 @at 0x40040000 {
//---  Register CSR: Low Power Timer Control Status Register
  CSR @offset 0x0 $u32 {
    24
    TCF // at 7: Timer Compare Flag
    TIE // at 6: Timer Interrupt Enable
    TPS:2 // at 4: Timer Pin Select
    TPP // at 3: Timer Pin Polarity
    TFC // at 2: Timer Free-Running Counter
    TMS // at 1: Timer Mode Select
    TEN // at 0: Timer Enable
  }

//---  Register PSR: Low Power Timer Prescale Register
  PSR @offset 0x4 $u32 {
    25
    PRESCALE:4 // at 3: Prescale Value
    PBYP // at 2: Prescaler Bypass
    PCS:2 // at 0: Prescaler Clock Select
  }

//---  Register CMR: Low Power Timer Compare Register
  CMR @offset 0x8 $u32 {
    16
    COMPARE:16 // at 0: Compare Value
  }

//---  Register CNR: Low Power Timer Counter Register
  CNR @offset 0xc $u32 {
    16
    COUNTER:16 // at 0: Counter Value
  }

}

//------------------------------------------------------------------------------
// Peripheral LPUART0: Universal Asynchronous Receiver/Transmitter
//------------------------------------------------------------------------------

registers ©LPUART0 @at 0x400c4000 {
//---  Register BAUD: LPUART Baud Rate Register
  BAUD @offset 0x0 $u32 {
    MAEN1 // at 31: Match Address Mode Enable 1
    MAEN2 // at 30: Match Address Mode Enable 2
    M10 // at 29: 10-bit Mode select
    OSR:5 // at 24: Over Sampling Ratio
    TDMAE // at 23: Transmitter DMA Enable
    1
    RDMAE // at 21: Receiver Full DMA Enable
    1
    MATCFG:2 // at 18: Match Configuration
    BOTHEDGE // at 17: Both Edge Sampling
    RESYNCDIS // at 16: Resynchronization Disable
    LBKDIE // at 15: LIN Break Detect Interrupt Enable
    RXEDGIE // at 14: RX Input Active Edge Interrupt Enable
    SBNS // at 13: Stop Bit Number Select
    SBR:13 // at 0: Baud Rate Modulo Divisor.
  }

//---  Register STAT: LPUART Status Register
  STAT @offset 0x4 $u32 {
    LBKDIF // at 31: LIN Break Detect Interrupt Flag
    RXEDGIF // at 30: LPUART_RX Pin Active Edge Interrupt Flag
    MSBF // at 29: MSB First
    RXINV // at 28: Receive Data Inversion
    RWUID // at 27: Receive Wake Up Idle Detect
    BRK13 // at 26: Break Character Generation Length
    LBKDE // at 25: LIN Break Detection Enable
    RAF // at 24: Receiver Active Flag
    TDRE // at 23: Transmit Data Register Empty Flag
    TC // at 22: Transmission Complete Flag
    RDRF // at 21: Receive Data Register Full Flag
    IDLE // at 20: Idle Line Flag
    OR // at 19: Receiver Overrun Flag
    NF // at 18: Noise Flag
    FE // at 17: Framing Error Flag
    PF // at 16: Parity Error Flag
    MA1F // at 15: Match 1 Flag
    MA2F // at 14: Match 2 Flag
    14
  }

//---  Register CTRL: LPUART Control Register
  CTRL @offset 0x8 $u32 {
    R8T9 // at 31: Receive Bit 8 / Transmit Bit 9
    R9T8 // at 30: Receive Bit 9 / Transmit Bit 8
    TXDIR // at 29: LPUART_TX Pin Direction in Single-Wire Mode
    TXINV // at 28: Transmit Data Inversion
    ORIE // at 27: Overrun Interrupt Enable
    NEIE // at 26: Noise Error Interrupt Enable
    FEIE // at 25: Framing Error Interrupt Enable
    PEIE // at 24: Parity Error Interrupt Enable
    TIE // at 23: Transmit Interrupt Enable
    TCIE // at 22: Transmission Complete Interrupt Enable for
    RIE // at 21: Receiver Interrupt Enable
    ILIE // at 20: Idle Line Interrupt Enable
    TE // at 19: Transmitter Enable
    RE // at 18: Receiver Enable
    RWU // at 17: Receiver Wakeup Control
    SBK // at 16: Send Break
    MA1IE // at 15: Match 1 Interrupt Enable
    MA2IE // at 14: Match 2 Interrupt Enable
    3
    IDLECFG:3 // at 8: Idle Configuration
    LOOPS // at 7: Loop Mode Select
    DOZEEN // at 6: Doze Enable
    RSRC // at 5: Receiver Source Select
    M // at 4: 9-Bit or 8-Bit Mode Select
    WAKE // at 3: Receiver Wakeup Method Select
    ILT // at 2: Idle Line Type Select
    PE // at 1: Parity Enable
    PT // at 0: Parity Type
  }

//---  Register DATA: LPUART Data Register
  DATA @offset 0xc $u32 {
    16
    NOISY // at 15: The current received dataword contained in DATA[R9:R0] was received with noise.
    PARITYE // at 14: The current received dataword contained in DATA[R9:R0] was received with a parity error.
    FRETSC // at 13: Frame Error / Transmit Special Character
    RXEMPT // at 12: Receive Buffer Empty
    IDLINE // at 11: Idle Line
    1
    R9T9 // at 9: Read receive data buffer 9 or write transmit data buffer 9.
    R8T8 // at 8: Read receive data buffer 8 or write transmit data buffer 8.
    R7T7 // at 7: Read receive data buffer 7 or write transmit data buffer 7.
    R6T6 // at 6: Read receive data buffer 6 or write transmit data buffer 6.
    R5T5 // at 5: Read receive data buffer 5 or write transmit data buffer 5.
    R4T4 // at 4: Read receive data buffer 4 or write transmit data buffer 4.
    R3T3 // at 3: Read receive data buffer 3 or write transmit data buffer 3.
    R2T2 // at 2: Read receive data buffer 2 or write transmit data buffer 2.
    R1T1 // at 1: Read receive data buffer 1 or write transmit data buffer 1.
    R0T0 // at 0: Read receive data buffer 0 or write transmit data buffer 0.
  }

//---  Register MATCH: LPUART Match Address Register
  MATCH @offset 0x10 $u32 {
    6
    MA2:10 // at 16: Match Address 2
    6
    MA1:10 // at 0: Match Address 1
  }

//---  Register MODIR: LPUART Modem IrDA Register
  MODIR @offset 0x14 $u32 {
    13
    IREN // at 18: Infrared enable
    TNP:2 // at 16: Transmitter narrow pulse
    10
    TXCTSSRC // at 5: Transmit CTS Source
    TXCTSC // at 4: Transmit CTS Configuration
    RXRTSE // at 3: Receiver request-to-send enable
    TXRTSPOL // at 2: Transmitter request-to-send polarity
    TXRTSE // at 1: Transmitter request-to-send enable
    TXCTSE // at 0: Transmitter clear-to-send enable
  }

}

//------------------------------------------------------------------------------
// Peripheral MCG: Multipurpose Clock Generator module
//------------------------------------------------------------------------------

registers ©MCG @at 0x40064000 {
//---  Register C1: MCG Control 1 Register
  C1 @offset 0x0 $u8 {
    CLKS:2 // at 6: Clock Source Select
    FRDIV:3 // at 3: FLL External Reference Divider
    IREFS // at 2: Internal Reference Select
    IRCLKEN // at 1: Internal Reference Clock Enable
    IREFSTEN // at 0: Internal Reference Stop Enable
  }

//---  Register C2: MCG Control 2 Register
  C2 @offset 0x1 $u8 {
    LOCRE0 // at 7: Loss of Clock Reset Enable
    FCFTRIM // at 6: Fast Internal Reference Clock Fine Trim
    RANGE:2 // at 4: Frequency Range Select
    HGO // at 3: High Gain Oscillator Select
    EREFS // at 2: External Reference Select
    LP // at 1: Low Power Select
    IRCS // at 0: Internal Reference Clock Select
  }

//---  Register C3: MCG Control 3 Register
  C3 @offset 0x2 $u8 {
    SCTRIM:8 // at 0: Slow Internal Reference Clock Trim Setting
  }

//---  Register C4: MCG Control 4 Register
  C4 @offset 0x3 $u8 {
    DMX32 // at 7: DCO Maximum Frequency with 32.768 kHz Reference
    DRST_DRS:2 // at 5: DCO Range Select
    FCTRIM:4 // at 1: Fast Internal Reference Clock Trim Setting
    SCFTRIM // at 0: Slow Internal Reference Clock Fine Trim
  }

//---  Register C5: MCG Control 5 Register
  C5 @offset 0x4 $u8 {
    1
    PLLCLKEN // at 6: PLL Clock Enable
    PLLSTEN // at 5: PLL Stop Enable
    2
    PRDIV:3 // at 0: PLL External Reference Divider
  }

//---  Register C6: MCG Control 6 Register
  C6 @offset 0x5 $u8 {
    LOLIE0 // at 7: Loss of Lock Interrrupt Enable
    PLLS // at 6: PLL Select
    CME0 // at 5: Clock Monitor Enable
    VDIV:5 // at 0: VCO Divider
  }

//---  Register S: MCG Status Register
  S @offset 0x6 $u8 {
    LOLS0 // at 7: Loss of Lock Status
    LOCK0 // at 6: Lock Status
    PLLST // at 5: PLL Select Status
    IREFST // at 4: Internal Reference Status
    CLKST:2 // at 2: Clock Mode Status
    OSCINIT0 // at 1: OSC Initialization
    IRCST // at 0: Internal Reference Clock Status
  }

//---  Register SC: MCG Status and Control Register
  SC @offset 0x8 $u8 {
    ATME // at 7: Automatic Trim Machine Enable
    ATMS // at 6: Automatic Trim Machine Select
    ATMF // at 5: Automatic Trim Machine Fail Flag
    FLTPRSRV // at 4: FLL Filter Preserve Enable
    FCRDIV:3 // at 1: Fast Clock Internal Reference Divider
    LOCS0 // at 0: OSC0 Loss of Clock Status
  }

//---  Register ATCVH: MCG Auto Trim Compare Value High Register
  ATCVH @offset 0xa $u8 {
    ATCVH:8 // at 0: ATM Compare Value High
  }

//---  Register ATCVL: MCG Auto Trim Compare Value Low Register
  ATCVL @offset 0xb $u8 {
    ATCVL:8 // at 0: ATM Compare Value Low
  }

//---  Register C7: MCG Control 7 Register
  C7 @offset 0xc $u8 {
    6
    OSCSEL:2 // at 0: MCG OSC Clock Select
  }

//---  Register C8: MCG Control 8 Register
  C8 @offset 0xd $u8 {
    LOCRE1 // at 7: Loss of Clock Reset Enable
    LOLRE // at 6: PLL Loss of Lock Reset Enable
    CME1 // at 5: Clock Monitor Enable1
    4
    LOCS1 // at 0: RTC Loss of Clock Status
  }

//---  Register C9: MCG Control 9 Register
  C9 @offset 0xe $u8 {
    2
    PLL_CME // at 5: MCG External PLL Clock Monitor Enable
    PLL_LOCRE // at 4: MCG External PLL Loss of Clock Reset Enable
    3
    EXT_PLL_LOCS // at 0: External PLL Loss of Clock Status
  }

//---  Register C11: MCG Control 11 Register
  C11 @offset 0x10 $u8 {
    3
    PLLCS // at 4: PLL Clock Select
    4
  }

//---  Register S2: MCG Status 2 Register
  S2 @offset 0x12 @ro $u8 {
    3
    PLLCST // at 4: PLL Clock Select Status
    4
  }

}

//------------------------------------------------------------------------------
// Peripheral MCM: Core Platform Miscellaneous Control Module
//------------------------------------------------------------------------------

registers ©MCM @at 0xe0080000 {
//---  Register PLASC: Crossbar Switch (AXBS) Slave Configuration
  PLASC @offset 0x8 @ro $u16 {
    8
    ASC:8 // at 0: Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
  }

//---  Register PLAMC: Crossbar Switch (AXBS) Master Configuration
  PLAMC @offset 0xa @ro $u16 {
    8
    AMC:8 // at 0: Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
  }

//---  Register CR: Control Register
  CR @offset 0xc $u32 {
    1
    SRAMLWP // at 30: SRAM_L Write Protect
    SRAMLAP:2 // at 28: SRAM_L arbitration priority
    1
    SRAMUWP // at 26: SRAM_U write protect
    SRAMUAP:2 // at 24: SRAM_U arbitration priority
    24
  }

//---  Register ISCR: Interrupt Status Register
  ISCR @offset 0x10 $u32 {
    FIDCE // at 31: FPU input denormal interrupt enable
    2
    FIXCE // at 28: FPU inexact interrupt enable
    FUFCE // at 27: FPU underflow interrupt enable
    FOFCE // at 26: FPU overflow interrupt enable
    FDZCE // at 25: FPU divide-by-zero interrupt enable
    FIOCE // at 24: FPU invalid operation interrupt enable
    8
    FIDC // at 15: FPU input denormal interrupt status
    2
    FIXC // at 12: FPU inexact interrupt status
    FUFC // at 11: FPU underflow interrupt status
    FOFC // at 10: FPU overflow interrupt status
    FDZC // at 9: FPU divide-by-zero interrupt status
    FIOC // at 8: FPU invalid operation interrupt status
    4
    DHREQ // at 3: Debug Halt Request Indicator
    NMI // at 2: Non-maskable Interrupt Pending
    IRQ // at 1: Normal Interrupt Pending
    1
  }

//---  Register ETBCC: ETB Counter Control register
  ETBCC @offset 0x14 $u32 {
    26
    ITDIS // at 5: ITM-To-TPIU Disable
    ETDIS // at 4: ETM-To-TPIU Disable
    RLRQ // at 3: Reload Request
    RSPT:2 // at 1: Response Type
    CNTEN // at 0: Counter Enable
  }

//---  Register ETBRL: ETB Reload register
  ETBRL @offset 0x18 $u32 {
    21
    RELOAD:11 // at 0: Byte Count Reload Value
  }

//---  Register ETBCNT: ETB Counter Value register
  ETBCNT @offset 0x1c @ro $u32 {
    21
    COUNTER:11 // at 0: Byte Count Counter Value
  }

//---  Register FADR: Fault address register
  FADR @offset 0x20 @ro $u32 {
    ADDRESS:32 // at 0: Fault address
  }

//---  Register FATR: Fault attributes register
  FATR @offset 0x24 @ro $u32 {
    BEOVR // at 31: Bus error overrun
    19
    BEMN:4 // at 8: Bus error master number
    BEWT // at 7: Bus error write
    1
    BESZ:2 // at 4: Bus error size
    2
    BEMD // at 1: Bus error privilege level
    BEDA // at 0: Bus error access type
  }

//---  Register FDR: Fault data register
  FDR @offset 0x28 @ro $u32 {
    DATA:32 // at 0: Fault data
  }

//---  Register PID: Process ID register
  PID @offset 0x30 $u32 {
    24
    PID:8 // at 0: M0_PID And M1_PID For MPU
  }

//---  Register CPO: Compute Operation Control Register
  CPO @offset 0x40 $u32 {
    29
    CPOWOI // at 2: Compute Operation wakeup on interrupt
    CPOACK // at 1: Compute Operation acknowledge
    CPOREQ // at 0: Compute Operation request
  }

}

//------------------------------------------------------------------------------
// Peripheral MPU: Memory protection unit
//------------------------------------------------------------------------------

registers ©MPU @at 0x4000d000 {
//---  Register CESR: Control/Error Status Register
  CESR @offset 0x0 $u32 {
    SPERR:5 // at 27: Slave Port n Error
    7
    HRL:4 // at 16: Hardware Revision Level
    NSP:4 // at 12: Number Of Slave Ports
    NRGD:4 // at 8: Number Of Region Descriptors
    7
    VLD // at 0: Valid
  }

//---  Registers EAR(0,1,2,3,4): Error Address Register, slave port n
  #define MPU_EAR(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x10 + (idx) * 0x8)))
  #define MPU_EAR0 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 0 * 0x8)))
  #define MPU_EAR1 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 1 * 0x8)))
  #define MPU_EAR2 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 2 * 0x8)))
  #define MPU_EAR3 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 3 * 0x8)))
  #define MPU_EAR4 (* ((const volatile uint32_t *) (0x4000d000 + 0x10 + 4 * 0x8)))
 {
    EADDR:32 // at 0: Error Address
  }

//---  Registers EDR(0,1,2,3,4): Error Detail Register, slave port n
  #define MPU_EDR(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x14 + (idx) * 0x8)))
  #define MPU_EDR0 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 0 * 0x8)))
  #define MPU_EDR1 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 1 * 0x8)))
  #define MPU_EDR2 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 2 * 0x8)))
  #define MPU_EDR3 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 3 * 0x8)))
  #define MPU_EDR4 (* ((const volatile uint32_t *) (0x4000d000 + 0x14 + 4 * 0x8)))
 {
    EACD:16 // at 16: Error Access Control Detail
    EPID:8 // at 8: Error Process Identification
    EMN:4 // at 4: Error Master Number
    EATTR:3 // at 1: Error Attributes
    ERW // at 0: Error Read/Write
  }

//---  Registers RGD_WORD0(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 0
  #define MPU_RGD_WORD0(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x400 + (idx) * 0x10)))
  #define MPU_RGD0_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 0 * 0x10)))
  #define MPU_RGD1_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 1 * 0x10)))
  #define MPU_RGD2_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 2 * 0x10)))
  #define MPU_RGD3_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 3 * 0x10)))
  #define MPU_RGD4_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 4 * 0x10)))
  #define MPU_RGD5_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 5 * 0x10)))
  #define MPU_RGD6_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 6 * 0x10)))
  #define MPU_RGD7_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 7 * 0x10)))
  #define MPU_RGD8_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 8 * 0x10)))
  #define MPU_RGD9_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 9 * 0x10)))
  #define MPU_RGD10_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 10 * 0x10)))
  #define MPU_RGD11_WORD0 (* ((volatile uint32_t *) (0x4000d000 + 0x400 + 11 * 0x10)))
 {
    SRTADDR:27 // at 5: Start Address
    5
  }

//---  Registers RGD_WORD1(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 1
  #define MPU_RGD_WORD1(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x404 + (idx) * 0x10)))
  #define MPU_RGD0_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 0 * 0x10)))
  #define MPU_RGD1_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 1 * 0x10)))
  #define MPU_RGD2_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 2 * 0x10)))
  #define MPU_RGD3_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 3 * 0x10)))
  #define MPU_RGD4_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 4 * 0x10)))
  #define MPU_RGD5_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 5 * 0x10)))
  #define MPU_RGD6_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 6 * 0x10)))
  #define MPU_RGD7_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 7 * 0x10)))
  #define MPU_RGD8_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 8 * 0x10)))
  #define MPU_RGD9_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 9 * 0x10)))
  #define MPU_RGD10_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 10 * 0x10)))
  #define MPU_RGD11_WORD1 (* ((volatile uint32_t *) (0x4000d000 + 0x404 + 11 * 0x10)))
 {
    ENDADDR:27 // at 5: End Address
    5
  }

//---  Registers RGD_WORD2(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 2
  #define MPU_RGD_WORD2(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x408 + (idx) * 0x10)))
  #define MPU_RGD0_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 0 * 0x10)))
  #define MPU_RGD1_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 1 * 0x10)))
  #define MPU_RGD2_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 2 * 0x10)))
  #define MPU_RGD3_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 3 * 0x10)))
  #define MPU_RGD4_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 4 * 0x10)))
  #define MPU_RGD5_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 5 * 0x10)))
  #define MPU_RGD6_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 6 * 0x10)))
  #define MPU_RGD7_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 7 * 0x10)))
  #define MPU_RGD8_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 8 * 0x10)))
  #define MPU_RGD9_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 9 * 0x10)))
  #define MPU_RGD10_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 10 * 0x10)))
  #define MPU_RGD11_WORD2 (* ((volatile uint32_t *) (0x4000d000 + 0x408 + 11 * 0x10)))
 {
    M7RE // at 31: Bus Master 7 Read Enable
    M7WE // at 30: Bus Master 7 Write Enable
    M6RE // at 29: Bus Master 6 Read Enable
    M6WE // at 28: Bus Master 6 Write Enable
    M5RE // at 27: Bus Master 5 Read Enable
    M5WE // at 26: Bus Master 5 Write Enable
    M4RE // at 25: Bus Master 4 Read Enable
    M4WE // at 24: Bus Master 4 Write Enable
    M3PE // at 23: Bus Master 3 Process Identifier Enable
    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control
    M3UM:3 // at 18: Bus Master 3 User Mode Access Control
    M2PE // at 17: Bus Master 2 Process Identifier Enable
    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control
    M2UM:3 // at 12: Bus Master 2 User Mode Access control
    M1PE // at 11: Bus Master 1 Process Identifier enable
    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control
    M1UM:3 // at 6: Bus Master 1 User Mode Access Control
    M0PE // at 5: Bus Master 0 Process Identifier enable
    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control
    M0UM:3 // at 0: Bus Master 0 User Mode Access Control
  }

//---  Registers RGD_WORD3(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 3
  #define MPU_RGD_WORD3(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x40c + (idx) * 0x10)))
  #define MPU_RGD0_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 0 * 0x10)))
  #define MPU_RGD1_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 1 * 0x10)))
  #define MPU_RGD2_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 2 * 0x10)))
  #define MPU_RGD3_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 3 * 0x10)))
  #define MPU_RGD4_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 4 * 0x10)))
  #define MPU_RGD5_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 5 * 0x10)))
  #define MPU_RGD6_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 6 * 0x10)))
  #define MPU_RGD7_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 7 * 0x10)))
  #define MPU_RGD8_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 8 * 0x10)))
  #define MPU_RGD9_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 9 * 0x10)))
  #define MPU_RGD10_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 10 * 0x10)))
  #define MPU_RGD11_WORD3 (* ((volatile uint32_t *) (0x4000d000 + 0x40c + 11 * 0x10)))
 {
    PID:8 // at 24: Process Identifier
    PIDMASK:8 // at 16: Process Identifier Mask
    15
    VLD // at 0: Valid
  }

//---  Registers RGDAAC(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor Alternate Access Control n
  #define MPU_RGDAAC(idx) (* ((volatile uint32_t *) (0x4000d000 + 0x800 + (idx) * 0x4)))
  #define MPU_RGDAAC0 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 0 * 0x4)))
  #define MPU_RGDAAC1 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 1 * 0x4)))
  #define MPU_RGDAAC2 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 2 * 0x4)))
  #define MPU_RGDAAC3 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 3 * 0x4)))
  #define MPU_RGDAAC4 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 4 * 0x4)))
  #define MPU_RGDAAC5 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 5 * 0x4)))
  #define MPU_RGDAAC6 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 6 * 0x4)))
  #define MPU_RGDAAC7 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 7 * 0x4)))
  #define MPU_RGDAAC8 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 8 * 0x4)))
  #define MPU_RGDAAC9 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 9 * 0x4)))
  #define MPU_RGDAAC10 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 10 * 0x4)))
  #define MPU_RGDAAC11 (* ((volatile uint32_t *) (0x4000d000 + 0x800 + 11 * 0x4)))
 {
    M7RE // at 31: Bus Master 7 Read Enable
    M7WE // at 30: Bus Master 7 Write Enable
    M6RE // at 29: Bus Master 6 Read Enable
    M6WE // at 28: Bus Master 6 Write Enable
    M5RE // at 27: Bus Master 5 Read Enable
    M5WE // at 26: Bus Master 5 Write Enable
    M4RE // at 25: Bus Master 4 Read Enable
    M4WE // at 24: Bus Master 4 Write Enable
    M3PE // at 23: Bus Master 3 Process Identifier Enable
    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control
    M3UM:3 // at 18: Bus Master 3 User Mode Access Control
    M2PE // at 17: Bus Master 2 Process Identifier Enable
    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control
    M2UM:3 // at 12: Bus Master 2 User Mode Access Control
    M1PE // at 11: Bus Master 1 Process Identifier Enable
    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control
    M1UM:3 // at 6: Bus Master 1 User Mode Access Control
    M0PE // at 5: Bus Master 0 Process Identifier Enable
    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control
    M0UM:3 // at 0: Bus Master 0 User Mode Access Control
  }

}

//------------------------------------------------------------------------------
// Peripheral OSC: Oscillator
//------------------------------------------------------------------------------

registers ©OSC @at 0x40065000 {
//---  Register CR: OSC Control Register
  CR @offset 0x0 $u8 {
    ERCLKEN // at 7: External Reference Enable
    1
    EREFSTEN // at 5: External Reference Stop Enable
    1
    SC2P // at 3: Oscillator 2 pF Capacitor Load Configure
    SC4P // at 2: Oscillator 4 pF Capacitor Load Configure
    SC8P // at 1: Oscillator 8 pF Capacitor Load Configure
    SC16P // at 0: Oscillator 16 pF Capacitor Load Configure
  }

//---  Register DIV: OSC_DIV
  DIV @offset 0x2 $u8 {
    ERPS:2 // at 6: ERCLK prescaler
    6
  }

}

//------------------------------------------------------------------------------
// Peripheral PDB0: Programmable Delay Block
//------------------------------------------------------------------------------

registers ©PDB0 @at 0x40036000 {
//---  Register SC: Status and Control register
  SC @offset 0x0 $u32 {
    12
    LDMOD:2 // at 18: Load Mode Select
    PDBEIE // at 17: PDB Sequence Error Interrupt Enable
    SWTRIG // at 16: Software Trigger
    DMAEN // at 15: DMA Enable
    PRESCALER:3 // at 12: Prescaler Divider Select
    TRGSEL:4 // at 8: Trigger Input Source Select
    PDBEN // at 7: PDB Enable
    PDBIF // at 6: PDB Interrupt Flag
    PDBIE // at 5: PDB Interrupt Enable
    1
    MULT:2 // at 2: Multiplication Factor Select for Prescaler
    CONT // at 1: Continuous Mode Enable
    LDOK // at 0: Load OK
  }

//---  Register MOD: Modulus register
  MOD @offset 0x4 $u32 {
    16
    MOD:16 // at 0: PDB Modulus
  }

//---  Register CNT: Counter register
  CNT @offset 0x8 @ro $u32 {
    16
    CNT:16 // at 0: PDB Counter
  }

//---  Register IDLY: Interrupt Delay register
  IDLY @offset 0xc $u32 {
    16
    IDLY:16 // at 0: PDB Interrupt Delay
  }

//---  Registers CHC1(0,1): Channel n Control register 1
  #define PDB0_CHC1(idx) (* ((volatile uint32_t *) (0x40036000 + 0x10 + (idx) * 0x28)))
  #define PDB0_CH0C1 (* ((volatile uint32_t *) (0x40036000 + 0x10 + 0 * 0x28)))
  #define PDB0_CH1C1 (* ((volatile uint32_t *) (0x40036000 + 0x10 + 1 * 0x28)))
 {
    8
    BB:8 // at 16: PDB Channel Pre-Trigger Back-to-Back Operation Enable
    TOS:8 // at 8: PDB Channel Pre-Trigger Output Select
    EN:8 // at 0: PDB Channel Pre-Trigger Enable
  }

//---  Registers CHS(0,1): Channel n Status register
  #define PDB0_CHS(idx) (* ((volatile uint32_t *) (0x40036000 + 0x14 + (idx) * 0x28)))
  #define PDB0_CH0S (* ((volatile uint32_t *) (0x40036000 + 0x14 + 0 * 0x28)))
  #define PDB0_CH1S (* ((volatile uint32_t *) (0x40036000 + 0x14 + 1 * 0x28)))
 {
    8
    CF:8 // at 16: PDB Channel Flags
    8
    ERR:8 // at 0: PDB Channel Sequence Error Flags
  }

//---  Registers CHDLY0(0,1): Channel n Delay 0 register
  #define PDB0_CHDLY0(idx) (* ((volatile uint32_t *) (0x40036000 + 0x18 + (idx) * 0x28)))
  #define PDB0_CH0DLY0 (* ((volatile uint32_t *) (0x40036000 + 0x18 + 0 * 0x28)))
  #define PDB0_CH1DLY0 (* ((volatile uint32_t *) (0x40036000 + 0x18 + 1 * 0x28)))
 {
    16
    DLY:16 // at 0: PDB Channel Delay
  }

//---  Registers CHDLY1(0,1): Channel n Delay 1 register
  #define PDB0_CHDLY1(idx) (* ((volatile uint32_t *) (0x40036000 + 0x1c + (idx) * 0x28)))
  #define PDB0_CH0DLY1 (* ((volatile uint32_t *) (0x40036000 + 0x1c + 0 * 0x28)))
  #define PDB0_CH1DLY1 (* ((volatile uint32_t *) (0x40036000 + 0x1c + 1 * 0x28)))
 {
    16
    DLY:16 // at 0: PDB Channel Delay
  }

//---  Registers DACINTC(0,1): DAC Interval Trigger n Control register
  #define PDB0_DACINTC(idx) (* ((volatile uint32_t *) (0x40036000 + 0x150 + (idx) * 0x8)))
  #define PDB0_DACINTC0 (* ((volatile uint32_t *) (0x40036000 + 0x150 + 0 * 0x8)))
  #define PDB0_DACINTC1 (* ((volatile uint32_t *) (0x40036000 + 0x150 + 1 * 0x8)))
 {
    30
    EXT // at 1: DAC External Trigger Input Enable
    TOE // at 0: DAC Interval Trigger Enable
  }

//---  Registers DACINT(0,1): DAC Interval n register
  #define PDB0_DACINT(idx) (* ((volatile uint32_t *) (0x40036000 + 0x154 + (idx) * 0x8)))
  #define PDB0_DACINT0 (* ((volatile uint32_t *) (0x40036000 + 0x154 + 0 * 0x8)))
  #define PDB0_DACINT1 (* ((volatile uint32_t *) (0x40036000 + 0x154 + 1 * 0x8)))
 {
    16
    INT:16 // at 0: DAC Interval
  }

//---  Register POEN: Pulse-Out n Enable register
  POEN @offset 0x190 $u32 {
    24
    POEN:8 // at 0: PDB Pulse-Out Enable
  }

//---  Registers PODLY(0,1,2,3): Pulse-Out n Delay register
  #define PDB0_PODLY(idx) (* ((volatile uint32_t *) (0x40036000 + 0x194 + (idx) * 0x4)))
  #define PDB0_PO0DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 0 * 0x4)))
  #define PDB0_PO1DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 1 * 0x4)))
  #define PDB0_PO2DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 2 * 0x4)))
  #define PDB0_PO3DLY (* ((volatile uint32_t *) (0x40036000 + 0x194 + 3 * 0x4)))
 {
    DLY1:16 // at 16: PDB Pulse-Out Delay 1
    DLY2:16 // at 0: PDB Pulse-Out Delay 2
  }

}

//------------------------------------------------------------------------------
// Peripheral PIT: Periodic Interrupt Timer
//------------------------------------------------------------------------------

registers ©PIT @at 0x40037000 {
//---  Register MCR: PIT Module Control Register
  MCR @offset 0x0 $u32 {
    30
    MDIS // at 1: Module Disable - (PIT section)
    FRZ // at 0: Freeze
  }

//---  Register LTMR64H: PIT Upper Lifetime Timer Register
  LTMR64H @offset 0xe0 @ro $u32 {
    LTH:32 // at 0: Life Timer value
  }

//---  Register LTMR64L: PIT Lower Lifetime Timer Register
  LTMR64L @offset 0xe4 @ro $u32 {
    LTL:32 // at 0: Life Timer value
  }

//---  Registers LDVAL(0,1,2,3): Timer Load Value Register
  #define PIT_LDVAL(idx) (* ((volatile uint32_t *) (0x40037000 + 0x100 + (idx) * 0x10)))
  #define PIT_LDVAL0 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 0 * 0x10)))
  #define PIT_LDVAL1 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 1 * 0x10)))
  #define PIT_LDVAL2 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 2 * 0x10)))
  #define PIT_LDVAL3 (* ((volatile uint32_t *) (0x40037000 + 0x100 + 3 * 0x10)))
 {
    TSV:32 // at 0: Timer Start Value
  }

//---  Registers CVAL(0,1,2,3): Current Timer Value Register
  #define PIT_CVAL(idx) (* ((volatile uint32_t *) (0x40037000 + 0x104 + (idx) * 0x10)))
  #define PIT_CVAL0 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 0 * 0x10)))
  #define PIT_CVAL1 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 1 * 0x10)))
  #define PIT_CVAL2 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 2 * 0x10)))
  #define PIT_CVAL3 (* ((const volatile uint32_t *) (0x40037000 + 0x104 + 3 * 0x10)))
 {
    TVL:32 // at 0: Current Timer Value
  }

//---  Registers TCTRL(0,1,2,3): Timer Control Register
  #define PIT_TCTRL(idx) (* ((volatile uint32_t *) (0x40037000 + 0x108 + (idx) * 0x10)))
  #define PIT_TCTRL0 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 0 * 0x10)))
  #define PIT_TCTRL1 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 1 * 0x10)))
  #define PIT_TCTRL2 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 2 * 0x10)))
  #define PIT_TCTRL3 (* ((volatile uint32_t *) (0x40037000 + 0x108 + 3 * 0x10)))
 {
    29
    CHN // at 2: Chain Mode
    TIE // at 1: Timer Interrupt Enable
    TEN // at 0: Timer Enable
  }

//---  Registers TFLG(0,1,2,3): Timer Flag Register
  #define PIT_TFLG(idx) (* ((volatile uint32_t *) (0x40037000 + 0x10c + (idx) * 0x10)))
  #define PIT_TFLG0 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 0 * 0x10)))
  #define PIT_TFLG1 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 1 * 0x10)))
  #define PIT_TFLG2 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 2 * 0x10)))
  #define PIT_TFLG3 (* ((volatile uint32_t *) (0x40037000 + 0x10c + 3 * 0x10)))
 {
    31
    TIF // at 0: Timer Interrupt Flag
  }

}

//------------------------------------------------------------------------------
// Peripheral PMC: Power Management Controller
//------------------------------------------------------------------------------

registers ©PMC @at 0x4007d000 {
//---  Register LVDSC1: Low Voltage Detect Status And Control 1 register
  LVDSC1 @offset 0x0 $u8 {
    LVDF // at 7: Low-Voltage Detect Flag
    LVDACK // at 6: Low-Voltage Detect Acknowledge
    LVDIE // at 5: Low-Voltage Detect Interrupt Enable
    LVDRE // at 4: Low-Voltage Detect Reset Enable
    2
    LVDV:2 // at 0: Low-Voltage Detect Voltage Select
  }

//---  Register LVDSC2: Low Voltage Detect Status And Control 2 register
  LVDSC2 @offset 0x1 $u8 {
    LVWF // at 7: Low-Voltage Warning Flag
    LVWACK // at 6: Low-Voltage Warning Acknowledge
    LVWIE // at 5: Low-Voltage Warning Interrupt Enable
    3
    LVWV:2 // at 0: Low-Voltage Warning Voltage Select
  }

//---  Register REGSC: Regulator Status And Control register
  REGSC @offset 0x2 $u8 {
    3
    BGEN // at 4: Bandgap Enable In VLPx Operation
    ACKISO // at 3: Acknowledge Isolation
    REGONS // at 2: Regulator In Run Regulation Status
    1
    BGBE // at 0: Bandgap Buffer Enable
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©PORT [5]
//        PORTA at 0x40049000
//        PORTB at 0x4004a000
//        PORTC at 0x4004b000
//        PORTD at 0x4004c000
//        PORTE at 0x4004d000
//------------------------------------------------------------------------------

registers ©PORT [5 @at 0x40049000 0x4004a000 0x4004b000 0x4004c000 0x4004d000]
          ©PORTA @at 0x40049000
          ©PORTB @at 0x4004a000
          ©PORTC @at 0x4004b000
          ©PORTD @at 0x4004c000
          ©PORTE @at 0x4004d000
{
//---  Registers PCR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Pin Control Register n
  PCR0 @offset 0x0 $u32
  PCR1 @offset 0x4 $u32
  PCR2 @offset 0x8 $u32
  PCR3 @offset 0xc $u32
  PCR4 @offset 0x10 $u32
  PCR5 @offset 0x14 $u32
  PCR6 @offset 0x18 $u32
  PCR7 @offset 0x1c $u32
  PCR8 @offset 0x20 $u32
  PCR9 @offset 0x24 $u32
  PCR10 @offset 0x28 $u32
  PCR11 @offset 0x2c $u32
  PCR12 @offset 0x30 $u32
  PCR13 @offset 0x34 $u32
  PCR14 @offset 0x38 $u32
  PCR15 @offset 0x3c $u32
  PCR16 @offset 0x40 $u32
  PCR17 @offset 0x44 $u32
  PCR18 @offset 0x48 $u32
  PCR19 @offset 0x4c $u32
  PCR20 @offset 0x50 $u32
  PCR21 @offset 0x54 $u32
  PCR22 @offset 0x58 $u32
  PCR23 @offset 0x5c $u32
  PCR24 @offset 0x60 $u32
  PCR25 @offset 0x64 $u32
  PCR26 @offset 0x68 $u32
  PCR27 @offset 0x6c $u32
  PCR28 @offset 0x70 $u32
  PCR29 @offset 0x74 $u32
  PCR30 @offset 0x78 $u32
  PCR31 @offset 0x7c $u32 {
    7
    ISF // at 24: Interrupt Status Flag
    4
    IRQC:4 // at 16: Interrupt Configuration
    LK // at 15: Lock Register
    4
    MUX:3 // at 8: Pin Mux Control
    1
    DSE // at 6: Drive Strength Enable
    ODE // at 5: Open Drain Enable
    PFE // at 4: Passive Filter Enable
    1
    SRE // at 2: Slew Rate Enable
    PE // at 1: Pull Enable
    PS // at 0: Pull Select
  }

//---  Register GPCLR: Global Pin Control Low Register
  GPCLR @offset 0x80 $u32 {
    GPWE:16 // at 16: Global Pin Write Enable
    GPWD:16 // at 0: Global Pin Write Data
  }

//---  Register GPCHR: Global Pin Control High Register
  GPCHR @offset 0x84 $u32 {
    GPWE:16 // at 16: Global Pin Write Enable
    GPWD:16 // at 0: Global Pin Write Data
  }

//---  Register ISFR: Interrupt Status Flag Register
  ISFR @offset 0xa0 $u32 {
    ISF:32 // at 0: Interrupt Status Flag
  }

//---  Register DFER: Digital Filter Enable Register
  DFER @offset 0xc0 $u32 {
    DFE:32 // at 0: Digital Filter Enable
  }

//---  Register DFCR: Digital Filter Clock Register
  DFCR @offset 0xc4 $u32 {
    31
    CS // at 0: Clock Source
  }

//---  Register DFWR: Digital Filter Width Register
  DFWR @offset 0xc8 $u32 {
    27
    FILT:5 // at 0: Filter Length
  }

}

//------------------------------------------------------------------------------
// Peripheral RCM: Reset Control Module
//------------------------------------------------------------------------------

registers ©RCM @at 0x4007f000 {
//---  Register SRS0: System Reset Status Register 0
  SRS0 @offset 0x0 @ro $u8 {
    POR // at 7: Power-On Reset
    PIN // at 6: External Reset Pin
    WDOG // at 5: Watchdog
    1
    LOL // at 3: Loss-of-Lock Reset
    LOC // at 2: Loss-of-Clock Reset
    LVD // at 1: Low-Voltage Detect Reset
    WAKEUP // at 0: Low Leakage Wakeup Reset
  }

//---  Register SRS1: System Reset Status Register 1
  SRS1 @offset 0x1 @ro $u8 {
    2
    SACKERR // at 5: Stop Mode Acknowledge Error Reset
    EZPT // at 4: EzPort Reset
    MDM_AP // at 3: MDM-AP System Reset Request
    SW // at 2: Software
    LOCKUP // at 1: Core Lockup
    JTAG // at 0: JTAG Generated Reset
  }

//---  Register RPFC: Reset Pin Filter Control register
  RPFC @offset 0x4 $u8 {
    5
    RSTFLTSS // at 2: Reset Pin Filter Select in Stop Mode
    RSTFLTSRW:2 // at 0: Reset Pin Filter Select in Run and Wait Modes
  }

//---  Register RPFW: Reset Pin Filter Width register
  RPFW @offset 0x5 $u8 {
    3
    RSTFLTSEL:5 // at 0: Reset Pin Filter Bus Clock Select
  }

//---  Register MR: Mode Register
  MR @offset 0x7 @ro $u8 {
    6
    EZP_MS // at 1: EZP_MS_B pin state
    1
  }

//---  Register SSRS0: Sticky System Reset Status Register 0
  SSRS0 @offset 0x8 $u8 {
    SPOR // at 7: Sticky Power-On Reset
    SPIN // at 6: Sticky External Reset Pin
    SWDOG // at 5: Sticky Watchdog
    1
    SLOL // at 3: Sticky Loss-of-Lock Reset
    SLOC // at 2: Sticky Loss-of-Clock Reset
    SLVD // at 1: Sticky Low-Voltage Detect Reset
    SWAKEUP // at 0: Sticky Low Leakage Wakeup Reset
  }

//---  Register SSRS1: Sticky System Reset Status Register 1
  SSRS1 @offset 0x9 $u8 {
    2
    SSACKERR // at 5: Sticky Stop Mode Acknowledge Error Reset
    SEZPT // at 4: Sticky EzPort Reset
    SMDM_AP // at 3: Sticky MDM-AP System Reset Request
    SSW // at 2: Sticky Software
    SLOCKUP // at 1: Sticky Core Lockup
    SJTAG // at 0: Sticky JTAG Generated Reset
  }

}

//------------------------------------------------------------------------------
// Peripheral RFSYS: System register file
//------------------------------------------------------------------------------

registers ©RFSYS @at 0x40041000 {
//---  Registers REG(0,1,2,3,4,5,6,7): Register file register
  #define RFSYS_REG(idx) (* ((volatile uint32_t *) (0x40041000 + 0x0 + (idx) * 0x4)))
  #define RFSYS_REG0 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 0 * 0x4)))
  #define RFSYS_REG1 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 1 * 0x4)))
  #define RFSYS_REG2 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 2 * 0x4)))
  #define RFSYS_REG3 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 3 * 0x4)))
  #define RFSYS_REG4 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 4 * 0x4)))
  #define RFSYS_REG5 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 5 * 0x4)))
  #define RFSYS_REG6 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 6 * 0x4)))
  #define RFSYS_REG7 (* ((volatile uint32_t *) (0x40041000 + 0x0 + 7 * 0x4)))
 {
    HH:8 // at 24: High higher byte
    HL:8 // at 16: High lower byte
    LH:8 // at 8: Low higher byte
    LL:8 // at 0: Low lower byte
  }

}

//------------------------------------------------------------------------------
// Peripheral RFVBAT: VBAT register file
//------------------------------------------------------------------------------

registers ©RFVBAT @at 0x4003e000 {
//---  Registers REG(0,1,2,3,4,5,6,7): VBAT register file register
  #define RFVBAT_REG(idx) (* ((volatile uint32_t *) (0x4003e000 + 0x0 + (idx) * 0x4)))
  #define RFVBAT_REG0 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 0 * 0x4)))
  #define RFVBAT_REG1 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 1 * 0x4)))
  #define RFVBAT_REG2 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 2 * 0x4)))
  #define RFVBAT_REG3 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 3 * 0x4)))
  #define RFVBAT_REG4 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 4 * 0x4)))
  #define RFVBAT_REG5 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 5 * 0x4)))
  #define RFVBAT_REG6 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 6 * 0x4)))
  #define RFVBAT_REG7 (* ((volatile uint32_t *) (0x4003e000 + 0x0 + 7 * 0x4)))
 {
    HH:8 // at 24: High higher byte
    HL:8 // at 16: High lower byte
    LH:8 // at 8: Low higher byte
    LL:8 // at 0: Low lower byte
  }

}

//------------------------------------------------------------------------------
// Peripheral RNG: Random Number Generator Accelerator
//------------------------------------------------------------------------------

registers ©RNG @at 0x400a0000 {
//---  Register CR: RNGA Control Register
  CR @offset 0x0 $u32 {
    27
    SLP // at 4: Sleep
    CLRI // at 3: Clear Interrupt
    INTM // at 2: Interrupt Mask
    HA // at 1: High Assurance
    GO // at 0: Go
  }

//---  Register SR: RNGA Status Register
  SR @offset 0x4 @ro $u32 {
    8
    OREG_SIZE:8 // at 16: Output Register Size
    OREG_LVL:8 // at 8: Output Register Level
    3
    SLP // at 4: Sleep
    ERRI // at 3: Error Interrupt
    ORU // at 2: Output Register Underflow
    LRS // at 1: Last Read Status
    SECV // at 0: Security Violation
  }

//---  Register ER: RNGA Entropy Register
  ER @offset 0x8 $u32 {
    EXT_ENT:32 // at 0: External Entropy
  }

//---  Register OR: RNGA Output Register
  OR @offset 0xc @ro $u32 {
    RANDOUT:32 // at 0: Random Output
  }

}

//------------------------------------------------------------------------------
// Peripheral RTC: Secure Real Time Clock
//------------------------------------------------------------------------------

registers ©RTC @at 0x4003d000 {
//---  Register TSR: RTC Time Seconds Register
  TSR @offset 0x0 $u32 {
    TSR:32 // at 0: Time Seconds Register
  }

//---  Register TPR: RTC Time Prescaler Register
  TPR @offset 0x4 $u32 {
    16
    TPR:16 // at 0: Time Prescaler Register
  }

//---  Register TAR: RTC Time Alarm Register
  TAR @offset 0x8 $u32 {
    TAR:32 // at 0: Time Alarm Register
  }

//---  Register TCR: RTC Time Compensation Register
  TCR @offset 0xc $u32 {
    CIC:8 // at 24: Compensation Interval Counter
    TCV:8 // at 16: Time Compensation Value
    CIR:8 // at 8: Compensation Interval Register
    TCR:8 // at 0: Time Compensation Register
  }

//---  Register CR: RTC Control Register
  CR @offset 0x10 $u32 {
    18
    SC2P // at 13: Oscillator 2pF Load Configure
    SC4P // at 12: Oscillator 4pF Load Configure
    SC8P // at 11: Oscillator 8pF Load Configure
    SC16P // at 10: Oscillator 16pF Load Configure
    CLKO // at 9: Clock Output
    OSCE // at 8: Oscillator Enable
    3
    WPS // at 4: Wakeup Pin Select
    UM // at 3: Update Mode
    SUP // at 2: Supervisor Access
    WPE // at 1: Wakeup Pin Enable
    SWR // at 0: Software Reset
  }

//---  Register SR: RTC Status Register
  SR @offset 0x14 $u32 {
    27
    TCE // at 4: Time Counter Enable
    MOF // at 3: Monotonic Overflow Flag
    TAF // at 2: Time Alarm Flag
    TOF // at 1: Time Overflow Flag
    TIF // at 0: Time Invalid Flag
  }

//---  Register LR: RTC Lock Register
  LR @offset 0x18 $u32 {
    20
    MCHL // at 11: Monotonic Counter High Lock
    MCLL // at 10: Monotonic Counter Low Lock
    MEL // at 9: Monotonic Enable Lock
    TTSL // at 8: Tamper Time Seconds Lock
    1
    LRL // at 6: Lock Register Lock
    SRL // at 5: Status Register Lock
    CRL // at 4: Control Register Lock
    TCL // at 3: Time Compensation Lock
    3
  }

//---  Register IER: RTC Interrupt Enable Register
  IER @offset 0x1c $u32 {
    24
    WPON // at 7: Wakeup Pin On
    2
    TSIE // at 4: Time Seconds Interrupt Enable
    MOIE // at 3: Monotonic Overflow Interrupt Enable
    TAIE // at 2: Time Alarm Interrupt Enable
    TOIE // at 1: Time Overflow Interrupt Enable
    TIIE // at 0: Time Invalid Interrupt Enable
  }

//---  Register TTSR: RTC Tamper Time Seconds Register
  TTSR @offset 0x20 @ro $u32 {
    TTS:32 // at 0: Tamper Time Seconds
  }

//---  Register MER: RTC Monotonic Enable Register
  MER @offset 0x24 $u32 {
    27
    MCE // at 4: Monotonic Counter Enable
    4
  }

//---  Register MCLR: RTC Monotonic Counter Low Register
  MCLR @offset 0x28 $u32 {
    MCL:32 // at 0: Monotonic Counter Low
  }

//---  Register MCHR: RTC Monotonic Counter High Register
  MCHR @offset 0x2c $u32 {
    MCH:32 // at 0: Monotonic Counter High
  }

//---  Register WAR: RTC Write Access Register
  WAR @offset 0x800 $u32 {
    20
    MCHW // at 11: Monotonic Counter High Write
    MCLW // at 10: Monotonic Counter Low Write
    MERW // at 9: Monotonic Enable Register Write
    TTSW // at 8: Tamper Time Seconds Write
    IERW // at 7: Interrupt Enable Register Write
    LRW // at 6: Lock Register Write
    SRW // at 5: Status Register Write
    CRW // at 4: Control Register Write
    TCRW // at 3: Time Compensation Register Write
    TARW // at 2: Time Alarm Register Write
    TPRW // at 1: Time Prescaler Register Write
    TSRW // at 0: Time Seconds Register Write
  }

//---  Register RAR: RTC Read Access Register
  RAR @offset 0x804 $u32 {
    20
    MCHR // at 11: Monotonic Counter High Read
    MCLR // at 10: Monotonic Counter Low Read
    MERR // at 9: Monotonic Enable Register Read
    TTSR // at 8: Tamper Time Seconds Read
    IERR // at 7: Interrupt Enable Register Read
    LRR // at 6: Lock Register Read
    SRR // at 5: Status Register Read
    CRR // at 4: Control Register Read
    TCRR // at 3: Time Compensation Register Read
    TARR // at 2: Time Alarm Register Read
    TPRR // at 1: Time Prescaler Register Read
    TSRR // at 0: Time Seconds Register Read
  }

}

//------------------------------------------------------------------------------
// Peripheral SDHC: Secured Digital Host Controller
//------------------------------------------------------------------------------

registers ©SDHC @at 0x400b1000 {
//---  Register DSADDR: DMA System Address register
  DSADDR @offset 0x0 $u32 {
    DSADDR:30 // at 2: DMA System Address
    2
  }

//---  Register BLKATTR: Block Attributes register
  BLKATTR @offset 0x4 $u32 {
    BLKCNT:16 // at 16: Blocks Count For Current Transfer
    3
    BLKSIZE:13 // at 0: Transfer Block Size
  }

//---  Register CMDARG: Command Argument register
  CMDARG @offset 0x8 $u32 {
    CMDARG:32 // at 0: Command Argument
  }

//---  Register XFERTYP: Transfer Type register
  XFERTYP @offset 0xc $u32 {
    2
    CMDINX:6 // at 24: Command Index
    CMDTYP:2 // at 22: Command Type
    DPSEL // at 21: Data Present Select
    CICEN // at 20: Command Index Check Enable
    CCCEN // at 19: Command CRC Check Enable
    1
    RSPTYP:2 // at 16: Response Type Select
    10
    MSBSEL // at 5: Multi/Single Block Select
    DTDSEL // at 4: Data Transfer Direction Select
    1
    AC12EN // at 2: Auto CMD12 Enable
    BCEN // at 1: Block Count Enable
    DMAEN // at 0: DMA Enable
  }

//---  Register CMDRSP0: Command Response 0
  CMDRSP0 @offset 0x10 @ro $u32 {
    CMDRSP0:32 // at 0: Command Response 0
  }

//---  Register CMDRSP1: Command Response 1
  CMDRSP1 @offset 0x14 @ro $u32 {
    CMDRSP1:32 // at 0: Command Response 1
  }

//---  Register CMDRSP2: Command Response 2
  CMDRSP2 @offset 0x18 @ro $u32 {
    CMDRSP2:32 // at 0: Command Response 2
  }

//---  Register CMDRSP3: Command Response 3
  CMDRSP3 @offset 0x1c @ro $u32 {
    CMDRSP3:32 // at 0: Command Response 3
  }

//---  Register DATPORT: Buffer Data Port register
  DATPORT @offset 0x20 $u32 {
    DATCONT:32 // at 0: Data Content
  }

//---  Register PRSSTAT: Present State register
  PRSSTAT @offset 0x24 @ro $u32 {
    DLSL:8 // at 24: DAT Line Signal Level
    CLSL // at 23: CMD Line Signal Level
    6
    CINS // at 16: Card Inserted
    4
    BREN // at 11: Buffer Read Enable
    BWEN // at 10: Buffer Write Enable
    RTA // at 9: Read Transfer Active
    WTA // at 8: Write Transfer Active
    SDOFF // at 7: SD Clock Gated Off Internally
    PEROFF // at 6: SDHC clock Gated Off Internally
    HCKOFF // at 5: System Clock Gated Off Internally
    IPGOFF // at 4: Bus Clock Gated Off Internally
    SDSTB // at 3: SD Clock Stable
    DLA // at 2: Data Line Active
    CDIHB // at 1: Command Inhibit (DAT)
    CIHB // at 0: Command Inhibit (CMD)
  }

//---  Register PROCTL: Protocol Control register
  PROCTL @offset 0x28 $u32 {
    5
    WECRM // at 26: Wakeup Event Enable On SD Card Removal
    WECINS // at 25: Wakeup Event Enable On SD Card Insertion
    WECINT // at 24: Wakeup Event Enable On Card Interrupt
    4
    IABG // at 19: Interrupt At Block Gap
    RWCTL // at 18: Read Wait Control
    CREQ // at 17: Continue Request
    SABGREQ // at 16: Stop At Block Gap Request
    6
    DMAS:2 // at 8: DMA Select
    CDSS // at 7: Card Detect Signal Selection
    CDTL // at 6: Card Detect Test Level
    EMODE:2 // at 4: Endian Mode
    D3CD // at 3: DAT3 As Card Detection Pin
    DTW:2 // at 1: Data Transfer Width
    LCTL // at 0: LED Control
  }

//---  Register SYSCTL: System Control register
  SYSCTL @offset 0x2c $u32 {
    4
    INITA // at 27: Initialization Active
    RSTD // at 26: Software Reset For DAT Line
    RSTC // at 25: Software Reset For CMD Line
    RSTA // at 24: Software Reset For ALL
    4
    DTOCV:4 // at 16: Data Timeout Counter Value
    SDCLKFS:8 // at 8: SDCLK Frequency Select
    DVS:4 // at 4: Divisor
    SDCLKEN // at 3: SD Clock Enable
    PEREN // at 2: Peripheral Clock Enable
    HCKEN // at 1: System Clock Enable
    IPGEN // at 0: IPG Clock Enable
  }

//---  Register IRQSTAT: Interrupt Status register
  IRQSTAT @offset 0x30 $u32 {
    3
    DMAE // at 28: DMA Error
    3
    AC12E // at 24: Auto CMD12 Error
    1
    DEBE // at 22: Data End Bit Error
    DCE // at 21: Data CRC Error
    DTOE // at 20: Data Timeout Error
    CIE // at 19: Command Index Error
    CEBE // at 18: Command End Bit Error
    CCE // at 17: Command CRC Error
    CTOE // at 16: Command Timeout Error
    7
    CINT // at 8: Card Interrupt
    CRM // at 7: Card Removal
    CINS // at 6: Card Insertion
    BRR // at 5: Buffer Read Ready
    BWR // at 4: Buffer Write Ready
    DINT // at 3: DMA Interrupt
    BGE // at 2: Block Gap Event
    TC // at 1: Transfer Complete
    CC // at 0: Command Complete
  }

//---  Register IRQSTATEN: Interrupt Status Enable register
  IRQSTATEN @offset 0x34 $u32 {
    3
    DMAESEN // at 28: DMA Error Status Enable
    3
    AC12ESEN // at 24: Auto CMD12 Error Status Enable
    1
    DEBESEN // at 22: Data End Bit Error Status Enable
    DCESEN // at 21: Data CRC Error Status Enable
    DTOESEN // at 20: Data Timeout Error Status Enable
    CIESEN // at 19: Command Index Error Status Enable
    CEBESEN // at 18: Command End Bit Error Status Enable
    CCESEN // at 17: Command CRC Error Status Enable
    CTOESEN // at 16: Command Timeout Error Status Enable
    7
    CINTSEN // at 8: Card Interrupt Status Enable
    CRMSEN // at 7: Card Removal Status Enable
    CINSEN // at 6: Card Insertion Status Enable
    BRRSEN // at 5: Buffer Read Ready Status Enable
    BWRSEN // at 4: Buffer Write Ready Status Enable
    DINTSEN // at 3: DMA Interrupt Status Enable
    BGESEN // at 2: Block Gap Event Status Enable
    TCSEN // at 1: Transfer Complete Status Enable
    CCSEN // at 0: Command Complete Status Enable
  }

//---  Register IRQSIGEN: Interrupt Signal Enable register
  IRQSIGEN @offset 0x38 $u32 {
    3
    DMAEIEN // at 28: DMA Error Interrupt Enable
    3
    AC12EIEN // at 24: Auto CMD12 Error Interrupt Enable
    1
    DEBEIEN // at 22: Data End Bit Error Interrupt Enable
    DCEIEN // at 21: Data CRC Error Interrupt Enable
    DTOEIEN // at 20: Data Timeout Error Interrupt Enable
    CIEIEN // at 19: Command Index Error Interrupt Enable
    CEBEIEN // at 18: Command End Bit Error Interrupt Enable
    CCEIEN // at 17: Command CRC Error Interrupt Enable
    CTOEIEN // at 16: Command Timeout Error Interrupt Enable
    7
    CINTIEN // at 8: Card Interrupt Enable
    CRMIEN // at 7: Card Removal Interrupt Enable
    CINSIEN // at 6: Card Insertion Interrupt Enable
    BRRIEN // at 5: Buffer Read Ready Interrupt Enable
    BWRIEN // at 4: Buffer Write Ready Interrupt Enable
    DINTIEN // at 3: DMA Interrupt Enable
    BGEIEN // at 2: Block Gap Event Interrupt Enable
    TCIEN // at 1: Transfer Complete Interrupt Enable
    CCIEN // at 0: Command Complete Interrupt Enable
  }

//---  Register AC12ERR: Auto CMD12 Error Status Register
  AC12ERR @offset 0x3c @ro $u32 {
    24
    CNIBAC12E // at 7: Command Not Issued By Auto CMD12 Error
    2
    AC12IE // at 4: Auto CMD12 Index Error
    AC12CE // at 3: Auto CMD12 CRC Error
    AC12EBE // at 2: Auto CMD12 End Bit Error
    AC12TOE // at 1: Auto CMD12 Timeout Error
    AC12NE // at 0: Auto CMD12 Not Executed
  }

//---  Register HTCAPBLT: Host Controller Capabilities
  HTCAPBLT @offset 0x40 @ro $u32 {
    7
    VS33 // at 24: Voltage Support 3.3 V
    SRS // at 23: Suspend/Resume Support
    DMAS // at 22: DMA Support
    HSS // at 21: High Speed Support
    ADMAS // at 20: ADMA Support
    1
    MBL:3 // at 16: Max Block Length
    16
  }

//---  Register WML: Watermark Level Register
  WML @offset 0x44 $u32 {
    8
    WRWML:8 // at 16: Write Watermark Level
    8
    RDWML:8 // at 0: Read Watermark Level
  }

//---  Register FEVT: Force Event register
  FEVT @offset 0x50 $u32 {
    CINT // at 31: Force Event Card Interrupt
    2
    DMAE // at 28: Force Event DMA Error
    3
    AC12E // at 24: Force Event Auto Command 12 Error
    1
    DEBE // at 22: Force Event Data End Bit Error
    DCE // at 21: Force Event Data CRC Error
    DTOE // at 20: Force Event Data Time Out Error
    CIE // at 19: Force Event Command Index Error
    CEBE // at 18: Force Event Command End Bit Error
    CCE // at 17: Force Event Command CRC Error
    CTOE // at 16: Force Event Command Time Out Error
    8
    CNIBAC12E // at 7: Force Event Command Not Executed By Auto Command 12 Error
    2
    AC12IE // at 4: Force Event Auto Command 12 Index Error
    AC12EBE // at 3: Force Event Auto Command 12 End Bit Error
    AC12CE // at 2: Force Event Auto Command 12 CRC Error
    AC12TOE // at 1: Force Event Auto Command 12 Time Out Error
    AC12NE // at 0: Force Event Auto Command 12 Not Executed
  }

//---  Register ADMAES: ADMA Error Status register
  ADMAES @offset 0x54 @ro $u32 {
    28
    ADMADCE // at 3: ADMA Descriptor Error
    ADMALME // at 2: ADMA Length Mismatch Error
    ADMAES:2 // at 0: ADMA Error State (When ADMA Error Is Occurred.)
  }

//---  Register ADSADDR: ADMA System Addressregister
  ADSADDR @offset 0x58 $u32 {
    ADSADDR:30 // at 2: ADMA System Address
    2
  }

//---  Register VENDOR: Vendor Specific register
  VENDOR @offset 0xc0 $u32 {
    8
    INTSTVAL:8 // at 16: Internal State Value
    14
    EXBLKNU // at 1: Exact Block Number Block Read Enable For SDIO CMD53
    1
  }

//---  Register MMCBOOT: MMC Boot register
  MMCBOOT @offset 0xc4 $u32 {
    BOOTBLKCNT:16 // at 16: Defines the stop at block gap value of automatic mode
    8
    AUTOSABGEN // at 7: When boot, enable auto stop at block gap function
    BOOTEN // at 6: Boot Mode Enable
    BOOTMODE // at 5: Boot Mode Select
    BOOTACK // at 4: Boot Ack Mode Select
    DTOCVACK:4 // at 0: Boot ACK Time Out Counter Value
  }

//---  Register HOSTVER: Host Controller Version
  HOSTVER @offset 0xfc @ro $u32 {
    16
    VVN:8 // at 8: Vendor Version Number
    SVN:8 // at 0: Specification Version Number
  }

}

//------------------------------------------------------------------------------
// Peripheral SDRAM: Synchronous DRAM Controller
//------------------------------------------------------------------------------

registers ©SDRAM @at 0x4000f000 {
//---  Register CTRL: Control Register
  CTRL @offset 0x42 $u16 {
    4
    IS // at 11: Initiate self-refresh command.
    RTIM:2 // at 9: Refresh timing
    RC:9 // at 0: Refresh count
  }

//---  Registers AC(0,1): Address and Control Register
  #define SDRAM_AC(idx) (* ((volatile uint32_t *) (0x4000f000 + 0x48 + (idx) * 0x8)))
  #define SDRAM_AC0 (* ((volatile uint32_t *) (0x4000f000 + 0x48 + 0 * 0x8)))
  #define SDRAM_AC1 (* ((volatile uint32_t *) (0x4000f000 + 0x48 + 1 * 0x8)))
 {
    BA:14 // at 18: Base address register.
    2
    RE // at 15: Refresh enable
    1
    CASL:2 // at 12: CAS Latency
    1
    CBM:3 // at 8: Command bit location
    1
    IMRS // at 6: Initiate mode register set (mrs) command.
    PS:2 // at 4: Port size.
    IP // at 3: Initiate precharge all (pall) command.
    3
  }

//---  Registers CM(0,1): Control Mask
  #define SDRAM_CM(idx) (* ((volatile uint32_t *) (0x4000f000 + 0x4c + (idx) * 0x8)))
  #define SDRAM_CM0 (* ((volatile uint32_t *) (0x4000f000 + 0x4c + 0 * 0x8)))
  #define SDRAM_CM1 (* ((volatile uint32_t *) (0x4000f000 + 0x4c + 1 * 0x8)))
 {
    BAM:14 // at 18: Base address mask.
    9
    WP // at 8: Write protect.
    7
    V // at 0: Valid.
  }

}

//------------------------------------------------------------------------------
// Peripheral SIM: System Integration Module
//------------------------------------------------------------------------------

registers ©SIM @at 0x40047000 {
//---  Register SOPT1: System Options Register 1
  SOPT1 @offset 0x0 $u32 {
    USBREGEN // at 31: USB voltage regulator enable
    USBSSTBY // at 30: USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
    USBVSTBY // at 29: USB voltage regulator in standby mode during VLPR and VLPW modes
    9
    OSC32KSEL:2 // at 18: 32K oscillator clock select
    2
    RAMSIZE:4 // at 12: RAM size
    12
  }

//---  Register SOPT1CFG: SOPT1 Configuration Register
  SOPT1CFG @offset 0x4 $u32 {
    5
    USSWE // at 26: USB voltage regulator stop standby write enable
    UVSWE // at 25: USB voltage regulator VLP standby write enable
    URWE // at 24: USB voltage regulator enable write enable
    24
  }

//---  Register USBPHYCTL: USB PHY Control Register
  USBPHYCTL @offset 0x8 $u32 {
    8
    USBDISILIM // at 23: USB Disable Inrush Current Limit
    USB3VOUTTRG:3 // at 20: USB 3.3V Output Target
    10
    USBVREGPD // at 9: Enables the pulldown on the output of the USB Regulator.
    USBVREGSEL // at 8: Selects the default input voltage source to the USB Regulator in case both VREG_IN0 and VREG_IN1 are powered
    8
  }

//---  Register SOPT2: System Options Register 2
  SOPT2 @offset 0x1004 $u32 {
    2
    SDHCSRC:2 // at 28: SDHC clock source select
    LPUARTSRC:2 // at 26: LPUART clock source select
    TPMSRC:2 // at 24: TPM clock source select
    2
    TIMESRC:2 // at 20: IEEE 1588 timestamp clock source select
    RMIISRC // at 19: RMII clock source select
    USBSRC // at 18: USB clock source select
    PLLFLLSEL:2 // at 16: PLL/FLL clock select
    3
    TRACECLKSEL // at 12: Debug trace clock select
    2
    FBSL:2 // at 8: FlexBus security level
    CLKOUTSEL:3 // at 5: CLKOUT select
    RTCCLKOUTSEL // at 4: RTC clock out select
    2
    USBREGEN // at 1: USB PHY PLL Regulator Enable
    USBSLSRC // at 0: USB Slow Clock Source
  }

//---  Register SOPT4: System Options Register 4
  SOPT4 @offset 0x100c $u32 {
    FTM3TRG1SRC // at 31: FlexTimer 3 Hardware Trigger 1 Source Select
    FTM3TRG0SRC // at 30: FlexTimer 3 Hardware Trigger 0 Source Select
    FTM0TRG1SRC // at 29: FlexTimer 0 Hardware Trigger 1 Source Select
    FTM0TRG0SRC // at 28: FlexTimer 0 Hardware Trigger 0 Source Select
    FTM3CLKSEL // at 27: FlexTimer 3 External Clock Pin Select
    FTM2CLKSEL // at 26: FlexTimer 2 External Clock Pin Select
    FTM1CLKSEL // at 25: FTM1 External Clock Pin Select
    FTM0CLKSEL // at 24: FlexTimer 0 External Clock Pin Select
    1
    FTM2CH1SRC // at 22: FTM2 channel 1 input capture source select
    FTM2CH0SRC:2 // at 20: FTM2 channel 0 input capture source select
    FTM1CH0SRC:2 // at 18: FTM1 channel 0 input capture source select
    5
    FTM3FLT0 // at 12: FTM3 Fault 0 Select
    3
    FTM2FLT0 // at 8: FTM2 Fault 0 Select
    3
    FTM1FLT0 // at 4: FTM1 Fault 0 Select
    FTM0FLT3 // at 3: FTM0 Fault 3 Select
    FTM0FLT2 // at 2: FTM0 Fault 2 Select
    FTM0FLT1 // at 1: FTM0 Fault 1 Select
    FTM0FLT0 // at 0: FTM0 Fault 0 Select
  }

//---  Register SOPT5: System Options Register 5
  SOPT5 @offset 0x1010 $u32 {
    12
    LPUART0RXSRC:2 // at 18: LPUART0 receive data source select
    LPUART0TXSRC:2 // at 16: LPUART0 transmit data source select
    8
    UART1RXSRC:2 // at 6: UART 1 receive data source select
    UART1TXSRC:2 // at 4: UART 1 transmit data source select
    UART0RXSRC:2 // at 2: UART 0 receive data source select
    UART0TXSRC:2 // at 0: UART 0 transmit data source select
  }

//---  Register SOPT7: System Options Register 7
  SOPT7 @offset 0x1018 $u32 {
    16
    ADC1ALTTRGEN // at 15: ADC1 alternate trigger enable
    2
    ADC1PRETRGSEL // at 12: ADC1 pre-trigger select
    ADC1TRGSEL:4 // at 8: ADC1 trigger select
    ADC0ALTTRGEN // at 7: ADC0 alternate trigger enable
    2
    ADC0PRETRGSEL // at 4: ADC0 pretrigger select
    ADC0TRGSEL:4 // at 0: ADC0 trigger select
  }

//---  Register SOPT8: System Options Register 8
  SOPT8 @offset 0x101c $u32 {
    FTM3OCH7SRC // at 31: FTM3 channel 7 output source
    FTM3OCH6SRC // at 30: FTM3 channel 6 output source
    FTM3OCH5SRC // at 29: FTM3 channel 5 output source
    FTM3OCH4SRC // at 28: FTM3 channel 4 output source
    FTM3OCH3SRC // at 27: FTM3 channel 3 output source
    FTM3OCH2SRC // at 26: FTM3 channel 2 output source
    FTM3OCH1SRC // at 25: FTM3 channel 1 output source
    FTM3OCH0SRC // at 24: FTM3 channel 0 output source
    FTM0OCH7SRC // at 23: FTM0 channel 7 output source
    FTM0OCH6SRC // at 22: FTM0 channel 6 output source
    FTM0OCH5SRC // at 21: FTM0 channel 5 output source
    FTM0OCH4SRC // at 20: FTM0 channel 4 output source
    FTM0OCH3SRC // at 19: FTM0 channel 3 output source
    FTM0OCH2SRC // at 18: FTM0 channel 2 output source
    FTM0OCH1SRC // at 17: FTM0 channel 1 output source
    FTM0OCH0SRC // at 16: FTM0 channel 0 output source
    12
    FTM3SYNCBIT // at 3: FTM3 Hardware Trigger 0 Software Synchronization
    FTM2SYNCBIT // at 2: FTM2 Hardware Trigger 0 Software Synchronization
    FTM1SYNCBIT // at 1: FTM1 Hardware Trigger 0 Software Synchronization
    FTM0SYNCBIT // at 0: FTM0 Hardware Trigger 0 Software Synchronization
  }

//---  Register SOPT9: System Options Register 9
  SOPT9 @offset 0x1020 $u32 {
    5
    TPM2CLKSEL // at 26: TPM2 External Clock Pin Select
    TPM1CLKSEL // at 25: TPM1 External Clock Pin Select
    3
    TPM2CH0SRC:2 // at 20: TPM2 channel 0 input capture source select
    TPM1CH0SRC:2 // at 18: TPM1 channel 0 input capture source select
    18
  }

//---  Register SDID: System Device Identification Register
  SDID @offset 0x1024 @ro $u32 {
    FAMILYID:4 // at 28: Kinetis Family ID
    SUBFAMID:4 // at 24: Kinetis Sub-Family ID
    SERIESID:4 // at 20: Kinetis Series ID
    4
    REVID:4 // at 12: Device revision number
    DIEID:5 // at 7: Device Die ID
    FAMID:3 // at 4: Kinetis family identification
    PINID:4 // at 0: Pincount identification
  }

//---  Register SCGC1: System Clock Gating Control Register 1
  SCGC1 @offset 0x1028 $u32 {
    21
    UART4 // at 10: UART4 Clock Gate Control
    2
    I2C3 // at 7: I2C3 Clock Gate Control
    I2C2 // at 6: I2C2 Clock Gate Control
    6
  }

//---  Register SCGC2: System Clock Gating Control Register 2
  SCGC2 @offset 0x102c $u32 {
    18
    DAC1 // at 13: DAC1 Clock Gate Control
    DAC0 // at 12: DAC0 Clock Gate Control
    1
    TPM2 // at 10: TPM2 Clock Gate Control
    TPM1 // at 9: TPM1 Clock Gate Control
    4
    LPUART0 // at 4: LPUART0 Clock Gate Control
    3
    ENET // at 0: ENET Clock Gate Control
  }

//---  Register SCGC3: System Clock Gating Control Register 3
  SCGC3 @offset 0x1030 $u32 {
    4
    ADC1 // at 27: ADC1 Clock Gate Control
    1
    FTM3 // at 25: FTM3 Clock Gate Control
    FTM2 // at 24: FTM2 Clock Gate Control
    6
    SDHC // at 17: SDHC Clock Gate Control
    4
    SPI2 // at 12: SPI2 Clock Gate Control
    7
    FLEXCAN1 // at 4: FlexCAN1 Clock Gate Control
    USBHSDCD // at 3: USBHS DCD Clock Gate Control
    USBHSPHY // at 2: USBHS PHY Clock Gate Control
    USBHS // at 1: USBHS Clock Gate Control
    RNGA // at 0: RNGA Clock Gate Control
  }

//---  Register SCGC4: System Clock Gating Control Register 4
  SCGC4 @offset 0x1034 $u32 {
    11
    VREF // at 20: VREF Clock Gate Control
    CMP // at 19: Comparator Clock Gate Control
    USBOTG // at 18: USB Clock Gate Control
    4
    UART3 // at 13: UART3 Clock Gate Control
    UART2 // at 12: UART2 Clock Gate Control
    UART1 // at 11: UART1 Clock Gate Control
    UART0 // at 10: UART0 Clock Gate Control
    2
    I2C1 // at 7: I2C1 Clock Gate Control
    I2C0 // at 6: I2C0 Clock Gate Control
    3
    CMT // at 2: CMT Clock Gate Control
    EWM // at 1: EWM Clock Gate Control
    1
  }

//---  Register SCGC5: System Clock Gating Control Register 5
  SCGC5 @offset 0x1038 $u32 {
    18
    PORTE // at 13: Port E Clock Gate Control
    PORTD // at 12: Port D Clock Gate Control
    PORTC // at 11: Port C Clock Gate Control
    PORTB // at 10: Port B Clock Gate Control
    PORTA // at 9: Port A Clock Gate Control
    3
    TSI // at 5: TSI Clock Gate Control
    4
    LPTMR // at 0: Low Power Timer Access Control
  }

//---  Register SCGC6: System Clock Gating Control Register 6
  SCGC6 @offset 0x103c $u32 {
    DAC0 // at 31: DAC0 Clock Gate Control
    1
    RTC // at 29: RTC Access Control
    1
    ADC0 // at 27: ADC0 Clock Gate Control
    FTM2 // at 26: FTM2 Clock Gate Control
    FTM1 // at 25: FTM1 Clock Gate Control
    FTM0 // at 24: FTM0 Clock Gate Control
    PIT // at 23: PIT Clock Gate Control
    PDB // at 22: PDB Clock Gate Control
    USBDCD // at 21: USB DCD Clock Gate Control
    2
    CRC // at 18: CRC Clock Gate Control
    2
    I2S // at 15: I2S Clock Gate Control
    1
    SPI1 // at 13: SPI1 Clock Gate Control
    SPI0 // at 12: SPI0 Clock Gate Control
    2
    RNGA // at 9: RNGA Clock Gate Control
    4
    FLEXCAN0 // at 4: FlexCAN0 Clock Gate Control
    2
    DMAMUX // at 1: DMA Mux Clock Gate Control
    FTF // at 0: Flash Memory Clock Gate Control
  }

//---  Register SCGC7: System Clock Gating Control Register 7
  SCGC7 @offset 0x1040 $u32 {
    28
    SDRAMC // at 3: SDRAMC Clock Gate Control
    MPU // at 2: MPU Clock Gate Control
    DMA // at 1: DMA Clock Gate Control
    FLEXBUS // at 0: FlexBus Clock Gate Control
  }

//---  Register CLKDIV1: System Clock Divider Register 1
  CLKDIV1 @offset 0x1044 $u32 {
    OUTDIV1:4 // at 28: Clock 1 output divider value
    OUTDIV2:4 // at 24: Clock 2 output divider value
    OUTDIV3:4 // at 20: Clock 3 output divider value
    OUTDIV4:4 // at 16: Clock 4 output divider value
    16
  }

//---  Register CLKDIV2: System Clock Divider Register 2
  CLKDIV2 @offset 0x1048 $u32 {
    28
    USBDIV:3 // at 1: USB clock divider divisor
    USBFRAC // at 0: USB clock divider fraction
  }

//---  Register FCFG1: Flash Configuration Register 1
  FCFG1 @offset 0x104c $u32 {
    NVMSIZE:4 // at 28: FlexNVM size
    PFSIZE:4 // at 24: Program flash size
    4
    EESIZE:4 // at 16: EEPROM size
    4
    DEPART:4 // at 8: FlexNVM partition
    6
    FLASHDOZE // at 1: Flash Doze
    FLASHDIS // at 0: Flash Disable
  }

//---  Register FCFG2: Flash Configuration Register 2
  FCFG2 @offset 0x1050 @ro $u32 {
    SWAPPFLSH // at 31: Swap program flash
    MAXADDR0:7 // at 24: Max address block 0
    PFLSH // at 23: Program flash only
    MAXADDR1:7 // at 16: Max address block 1
    16
  }

//---  Register UIDH: Unique Identification Register High
  UIDH @offset 0x1054 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDMH: Unique Identification Register Mid-High
  UIDMH @offset 0x1058 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDML: Unique Identification Register Mid Low
  UIDML @offset 0x105c @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDL: Unique Identification Register Low
  UIDL @offset 0x1060 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register CLKDIV3: System Clock Divider Register 3
  CLKDIV3 @offset 0x1064 $u32 {
    28
    PLLFLLDIV:3 // at 1: PLLFLL clock divider divisor
    PLLFLLFRAC // at 0: PLLFLL clock divider fraction
  }

//---  Register CLKDIV4: System Clock Divider Register 4
  CLKDIV4 @offset 0x1068 $u32 {
    28
    TRACEDIV:3 // at 1: Trace clock divider divisor
    TRACEFRAC // at 0: Trace clock divider fraction
  }

}

//------------------------------------------------------------------------------
// Peripheral SMC: System Mode Controller
//------------------------------------------------------------------------------

registers ©SMC @at 0x4007e000 {
//---  Register PMPROT: Power Mode Protection register
  PMPROT @offset 0x0 $u8 {
    AHSRUN // at 7: Allow High Speed Run mode
    1
    AVLP // at 5: Allow Very-Low-Power Modes
    1
    ALLS // at 3: Allow Low-Leakage Stop Mode
    1
    AVLLS // at 1: Allow Very-Low-Leakage Stop Mode
    1
  }

//---  Register PMCTRL: Power Mode Control register
  PMCTRL @offset 0x1 $u8 {
    1
    RUNM:2 // at 5: Run Mode Control
    1
    STOPA // at 3: Stop Aborted
    STOPM:3 // at 0: Stop Mode Control
  }

//---  Register STOPCTRL: Stop Control Register
  STOPCTRL @offset 0x2 $u8 {
    PSTOPO:2 // at 6: Partial Stop Option
    PORPO // at 5: POR Power Option
    RAM2PO // at 4: RAM2 Power Option
    1
    LLSM:3 // at 0: LLS or VLLS Mode Control
  }

//---  Register PMSTAT: Power Mode Status register
  PMSTAT @offset 0x3 @ro $u8 {
    PMSTAT:8 // at 0: Power Mode Status
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©SPI [3]
//        SPI0 at 0x4002c000
//        SPI1 at 0x4002d000
//        SPI2 at 0x400ac000
//------------------------------------------------------------------------------

registers ©SPI [3 @at 0x4002c000 0x4002d000 0x400ac000]
          ©SPI0 @at 0x4002c000
          ©SPI1 @at 0x4002d000
          ©SPI2 @at 0x400ac000
{
//---  Register MCR: Module Configuration Register
  MCR @offset 0x0 $u32 {
    MSTR // at 31: Master/Slave Mode Select
    CONT_SCKE // at 30: Continuous SCK Enable
    DCONF:2 // at 28: SPI Configuration.
    FRZ // at 27: Freeze
    MTFE // at 26: Modified Transfer Format Enable
    PCSSE // at 25: Peripheral Chip Select Strobe Enable
    ROOE // at 24: Receive FIFO Overflow Overwrite Enable
    2
    PCSIS:6 // at 16: Peripheral Chip Select x Inactive State
    DOZE // at 15: Doze Enable
    MDIS // at 14: Module Disable
    DIS_TXF // at 13: Disable Transmit FIFO
    DIS_RXF // at 12: Disable Receive FIFO
    CLR_TXF // at 11: Clear TX FIFO
    CLR_RXF // at 10: CLR_RXF
    SMPL_PT:2 // at 8: Sample Point
    7
    HALT // at 0: Halt
  }

//---  Register TCR: Transfer Count Register
  TCR @offset 0x8 $u32 {
    SPI_TCNT:16 // at 16: SPI Transfer Counter
    16
  }

//---  Registers CTAR(0,1): Clock and Transfer Attributes Register (In Master Mode)
  CTAR0 @offset 0xc $u32
  CTAR1 @offset 0x10 $u32 {
    DBR // at 31: Double Baud Rate
    FMSZ:4 // at 27: Frame Size
    CPOL // at 26: Clock Polarity
    CPHA // at 25: Clock Phase
    LSBFE // at 24: LSB First
    PCSSCK:2 // at 22: PCS to SCK Delay Prescaler
    PASC:2 // at 20: After SCK Delay Prescaler
    PDT:2 // at 18: Delay after Transfer Prescaler
    PBR:2 // at 16: Baud Rate Prescaler
    CSSCK:4 // at 12: PCS to SCK Delay Scaler
    ASC:4 // at 8: After SCK Delay Scaler
    DT:4 // at 4: Delay After Transfer Scaler
    BR:4 // at 0: Baud Rate Scaler
  }

//---  Register CTAR_SLAVE: Clock and Transfer Attributes Register (In Slave Mode)
  CTAR_SLAVE @offset 0xc $u32 {
    1
    FMSZ:4 // at 27: Frame Size
    CPOL // at 26: Clock Polarity
    CPHA // at 25: Clock Phase
    25
  }

//---  Register SR: Status Register
  SR @offset 0x2c $u32 {
    TCF // at 31: Transfer Complete Flag
    TXRXS // at 30: TX and RX Status
    1
    EOQF // at 28: End of Queue Flag
    TFUF // at 27: Transmit FIFO Underflow Flag
    1
    TFFF // at 25: Transmit FIFO Fill Flag
    5
    RFOF // at 19: Receive FIFO Overflow Flag
    1
    RFDF // at 17: Receive FIFO Drain Flag
    1
    TXCTR:4 // at 12: TX FIFO Counter
    TXNXTPTR:4 // at 8: Transmit Next Pointer
    RXCTR:4 // at 4: RX FIFO Counter
    POPNXTPTR:4 // at 0: Pop Next Pointer
  }

//---  Register RSER: DMA/Interrupt Request Select and Enable Register
  RSER @offset 0x30 $u32 {
    TCF_RE // at 31: Transmission Complete Request Enable
    2
    EOQF_RE // at 28: Finished Request Enable
    TFUF_RE // at 27: Transmit FIFO Underflow Request Enable
    1
    TFFF_RE // at 25: Transmit FIFO Fill Request Enable
    TFFF_DIRS // at 24: Transmit FIFO Fill DMA or Interrupt Request Select
    4
    RFOF_RE // at 19: Receive FIFO Overflow Request Enable
    1
    RFDF_RE // at 17: Receive FIFO Drain Request Enable
    RFDF_DIRS // at 16: Receive FIFO Drain DMA or Interrupt Request Select
    16
  }

//---  Register PUSHR: PUSH TX FIFO Register In Master Mode
  PUSHR @offset 0x34 $u32 {
    CONT // at 31: Continuous Peripheral Chip Select Enable
    CTAS:3 // at 28: Clock and Transfer Attributes Select
    EOQ // at 27: End Of Queue
    CTCNT // at 26: Clear Transfer Counter
    4
    PCS:6 // at 16: Select which PCS signals are to be asserted for the transfer
    TXDATA:16 // at 0: Transmit Data
  }

//---  Register PUSHR_SLAVE: PUSH TX FIFO Register In Slave Mode
  PUSHR_SLAVE @offset 0x34 $u32 {
    TXDATA:32 // at 0: Transmit Data
  }

//---  Register POPR: POP RX FIFO Register
  POPR @offset 0x38 @ro $u32 {
    RXDATA:32 // at 0: Received Data
  }

//---  Registers TXFR(0,1,2,3): Transmit FIFO Registers
  TXFR0 @offset 0x3c @ro $u32
  TXFR1 @offset 0x40 @ro $u32
  TXFR2 @offset 0x44 @ro $u32
  TXFR3 @offset 0x48 @ro $u32 {
    TXCMD_TXDATA:16 // at 16: Transmit Command or Transmit Data
    TXDATA:16 // at 0: Transmit Data
  }

//---  Registers RXFR(0,1,2,3): Receive FIFO Registers
  RXFR0 @offset 0x7c @ro $u32
  RXFR1 @offset 0x80 @ro $u32
  RXFR2 @offset 0x84 @ro $u32
  RXFR3 @offset 0x88 @ro $u32 {
    RXDATA:32 // at 0: Receive Data
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©TPM [2]
//        TPM1 at 0x400c9000
//        TPM2 at 0x400ca000
//------------------------------------------------------------------------------

registers ©TPM [2 @at 0x400c9000 0x400ca000]
          ©TPM1 @at 0x400c9000
          ©TPM2 @at 0x400ca000
{
//---  Register SC: Status and Control
  SC @offset 0x0 $u32 {
    23
    DMA // at 8: DMA Enable
    TOF // at 7: Timer Overflow Flag
    TOIE // at 6: Timer Overflow Interrupt Enable
    CPWMS // at 5: Center-Aligned PWM Select
    CMOD:2 // at 3: Clock Mode Selection
    PS:3 // at 0: Prescale Factor Selection
  }

//---  Register CNT: Counter
  CNT @offset 0x4 $u32 {
    16
    COUNT:16 // at 0: Counter value
  }

//---  Register MOD: Modulo
  MOD @offset 0x8 $u32 {
    16
    MOD:16 // at 0: Modulo value
  }

//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status and Control
  C0SC @offset 0xc $u32
  C1SC @offset 0x14 $u32
  C2SC @offset 0x1c $u32
  C3SC @offset 0x24 $u32
  C4SC @offset 0x2c $u32
  C5SC @offset 0x34 $u32
  C6SC @offset 0x3c $u32
  C7SC @offset 0x44 $u32 {
    24
    CHF // at 7: Channel Flag
    CHIE // at 6: Channel Interrupt Enable
    MSB // at 5: Channel Mode Select
    MSA // at 4: Channel Mode Select
    ELSB // at 3: Edge or Level Select
    ELSA // at 2: Edge or Level Select
    1
    DMA // at 0: DMA Enable
  }

//---  Registers CV(0,1): Channel (n) Value
  C0V @offset 0x10 $u32
  C1V @offset 0x18 $u32 {
    16
    VAL:16 // at 0: Channel Value
  }

//---  Register STATUS: Capture and Compare Status
  STATUS @offset 0x50 $u32 {
    23
    TOF // at 8: Timer Overflow Flag
    6
    CH1F // at 1: Channel 1 Flag
    CH0F // at 0: Channel 0 Flag
  }

//---  Register COMBINE: Combine Channel Register
  COMBINE @offset 0x64 $u32 {
    30
    COMSWAP0 // at 1: Combine Channel 0 and 1 Swap
    COMBINE0 // at 0: Combine Channels 0 and 1
  }

//---  Register POL: Channel Polarity
  POL @offset 0x70 $u32 {
    30
    POL1 // at 1: Channel 1 Polarity
    POL0 // at 0: Channel 0 Polarity
  }

//---  Register FILTER: Filter Control
  FILTER @offset 0x78 $u32 {
    24
    CH1FVAL:4 // at 4: Channel 1 Filter Value
    CH0FVAL:4 // at 0: Channel 0 Filter Value
  }

//---  Register QDCTRL: Quadrature Decoder Control and Status
  QDCTRL @offset 0x80 $u32 {
    28
    QUADMODE // at 3: Quadrature Decoder Mode
    QUADIR // at 2: Counter Direction in Quadrature Decode Mode
    TOFDIR // at 1: Indicates if the TOF bit was set on the top or the bottom of counting.
    QUADEN // at 0: Enables the quadrature decoder mode
  }

//---  Register CONF: Configuration
  CONF @offset 0x84 $u32 {
    4
    TRGSEL:4 // at 24: Trigger Select
    TRGSRC // at 23: Trigger Source
    TRGPOL // at 22: Trigger Polarity
    2
    CPOT // at 19: Counter Pause On Trigger
    CROT // at 18: Counter Reload On Trigger
    CSOO // at 17: Counter Stop On Overflow
    CSOT // at 16: Counter Start on Trigger
    6
    GTBEEN // at 9: Global time base enable
    GTBSYNC // at 8: Global Time Base Synchronization
    DBGMODE:2 // at 6: Debug Mode
    DOZEEN // at 5: Doze Enable
    5
  }

}

//------------------------------------------------------------------------------
// Peripheral TSI0: Touch sense input
//------------------------------------------------------------------------------

registers ©TSI0 @at 0x40045000 {
//---  Register GENCS: TSI General Control and Status Register
  GENCS @offset 0x0 $u32 {
    OUTRGF // at 31: Out of Range Flag.
    2
    ESOR // at 28: End-of-scan or Out-of-Range Interrupt Selection
    MODE:4 // at 24: TSI analog modes setup and status bits.
    REFCHRG:3 // at 21: REFCHRG
    DVOLT:2 // at 19: DVOLT
    EXTCHRG:3 // at 16: EXTCHRG
    PS:3 // at 13: PS
    NSCN:5 // at 8: NSCN
    TSIEN // at 7: Touch Sensing Input Module Enable
    TSIIEN // at 6: Touch Sensing Input Interrupt Enable
    STPE // at 5: TSI STOP Enable
    STM // at 4: Scan Trigger Mode
    SCNIP // at 3: Scan In Progress Status
    EOSF // at 2: End of Scan Flag
    CURSW // at 1: CURSW
    EOSDMEO // at 0: End-of-Scan DMA Transfer Request Enable Only
  }

//---  Register DATA: TSI DATA Register
  DATA @offset 0x4 $u32 {
    TSICH:4 // at 28: TSICH
    4
    DMAEN // at 23: DMA Transfer Enabled
    SWTS // at 22: Software Trigger Start
    6
    TSICNT:16 // at 0: TSI Conversion Counter Value
  }

//---  Register TSHD: TSI Threshold Register
  TSHD @offset 0x8 $u32 {
    THRESH:16 // at 16: TSI Wakeup Channel High-threshold
    THRESL:16 // at 0: TSI Wakeup Channel Low-threshold
  }

}

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©UART [5]
//        UART0 at 0x4006a000
//        UART1 at 0x4006b000
//        UART2 at 0x4006c000
//        UART3 at 0x4006d000
//        UART4 at 0x400ea000
//------------------------------------------------------------------------------

registers ©UART [5 @at 0x4006a000 0x4006b000 0x4006c000 0x4006d000 0x400ea000]
          ©UART0 @at 0x4006a000
          ©UART1 @at 0x4006b000
          ©UART2 @at 0x4006c000
          ©UART3 @at 0x4006d000
          ©UART4 @at 0x400ea000
{
//---  Register BDH: UART Baud Rate Registers: High
  BDH @offset 0x0 $u8 {
    LBKDIE // at 7: LIN Break Detect Interrupt Enable
    RXEDGIE // at 6: RxD Input Active Edge Interrupt Enable
    SBNS // at 5: Stop Bit Number Select
    SBR:5 // at 0: UART Baud Rate Bits
  }

//---  Register BDL: UART Baud Rate Registers: Low
  BDL @offset 0x1 $u8 {
    SBR:8 // at 0: UART Baud Rate Bits
  }

//---  Register C1: UART Control Register 1
  C1 @offset 0x2 $u8 {
    LOOPS // at 7: Loop Mode Select
    UARTSWAI // at 6: UART Stops in Wait Mode
    RSRC // at 5: Receiver Source Select
    M // at 4: 9-bit or 8-bit Mode Select
    WAKE // at 3: Receiver Wakeup Method Select
    ILT // at 2: Idle Line Type Select
    PE // at 1: Parity Enable
    PT // at 0: Parity Type
  }

//---  Register C2: UART Control Register 2
  C2 @offset 0x3 $u8 {
    TIE // at 7: Transmitter Interrupt or DMA Transfer Enable.
    TCIE // at 6: Transmission Complete Interrupt Enable
    RIE // at 5: Receiver Full Interrupt or DMA Transfer Enable
    ILIE // at 4: Idle Line Interrupt Enable
    TE // at 3: Transmitter Enable
    RE // at 2: Receiver Enable
    RWU // at 1: Receiver Wakeup Control
    SBK // at 0: Send Break
  }

//---  Register S1: UART Status Register 1
  S1 @offset 0x4 @ro $u8 {
    TDRE // at 7: Transmit Data Register Empty Flag
    TC // at 6: Transmit Complete Flag
    RDRF // at 5: Receive Data Register Full Flag
    IDLE // at 4: Idle Line Flag
    OR // at 3: Receiver Overrun Flag
    NF // at 2: Noise Flag
    FE // at 1: Framing Error Flag
    PF // at 0: Parity Error Flag
  }

//---  Register S2: UART Status Register 2
  S2 @offset 0x5 $u8 {
    LBKDIF // at 7: LIN Break Detect Interrupt Flag
    RXEDGIF // at 6: RxD Pin Active Edge Interrupt Flag
    MSBF // at 5: Most Significant Bit First
    RXINV // at 4: Receive Data Inversion
    RWUID // at 3: Receive Wakeup Idle Detect
    BRK13 // at 2: Break Transmit Character Length
    LBKDE // at 1: LIN Break Detection Enable
    RAF // at 0: Receiver Active Flag
  }

//---  Register C3: UART Control Register 3
  C3 @offset 0x6 $u8 {
    R8 // at 7: Received Bit 8
    T8 // at 6: Transmit Bit 8
    TXDIR // at 5: Transmitter Pin Data Direction in Single-Wire mode
    TXINV // at 4: Transmit Data Inversion.
    ORIE // at 3: Overrun Error Interrupt Enable
    NEIE // at 2: Noise Error Interrupt Enable
    FEIE // at 1: Framing Error Interrupt Enable
    PEIE // at 0: Parity Error Interrupt Enable
  }

//---  Register D: UART Data Register
  D @offset 0x7 $u8 {
    RT:8 // at 0: Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
  }

//---  Register MA1: UART Match Address Registers 1
  MA1 @offset 0x8 $u8 {
    MA:8 // at 0: Match Address
  }

//---  Register MA2: UART Match Address Registers 2
  MA2 @offset 0x9 $u8 {
    MA:8 // at 0: Match Address
  }

//---  Register C4: UART Control Register 4
  C4 @offset 0xa $u8 {
    MAEN1 // at 7: Match Address Mode Enable 1
    MAEN2 // at 6: Match Address Mode Enable 2
    M10 // at 5: 10-bit Mode select
    BRFA:5 // at 0: Baud Rate Fine Adjust
  }

//---  Register C5: UART Control Register 5
  C5 @offset 0xb $u8 {
    TDMAS // at 7: Transmitter DMA Select
    1
    RDMAS // at 5: Receiver Full DMA Select
    5
  }

//---  Register ED: UART Extended Data Register
  ED @offset 0xc @ro $u8 {
    NOISY // at 7: The current received dataword contained in D and C3[R8] was received with noise.
    PARITYE // at 6: The current received dataword contained in D and C3[R8] was received with a parity error.
    6
  }

//---  Register MODEM: UART Modem Register
  MODEM @offset 0xd $u8 {
    4
    RXRTSE // at 3: Receiver request-to-send enable
    TXRTSPOL // at 2: Transmitter request-to-send polarity
    TXRTSE // at 1: Transmitter request-to-send enable
    TXCTSE // at 0: Transmitter clear-to-send enable
  }

//---  Register IR: UART Infrared Register
  IR @offset 0xe $u8 {
    5
    IREN // at 2: Infrared enable
    TNP:2 // at 0: Transmitter narrow pulse
  }

//---  Register PFIFO: UART FIFO Parameters
  PFIFO @offset 0x10 $u8 {
    TXFE // at 7: Transmit FIFO Enable
    TXFIFOSIZE:3 // at 4: Transmit FIFO. Buffer Depth
    RXFE // at 3: Receive FIFO Enable
    RXFIFOSIZE:3 // at 0: Receive FIFO. Buffer Depth
  }

//---  Register CFIFO: UART FIFO Control Register
  CFIFO @offset 0x11 $u8 {
    TXFLUSH // at 7: Transmit FIFO/Buffer Flush
    RXFLUSH // at 6: Receive FIFO/Buffer Flush
    3
    RXOFE // at 2: Receive FIFO Overflow Interrupt Enable
    TXOFE // at 1: Transmit FIFO Overflow Interrupt Enable
    RXUFE // at 0: Receive FIFO Underflow Interrupt Enable
  }

//---  Register SFIFO: UART FIFO Status Register
  SFIFO @offset 0x12 $u8 {
    TXEMPT // at 7: Transmit Buffer/FIFO Empty
    RXEMPT // at 6: Receive Buffer/FIFO Empty
    3
    RXOF // at 2: Receiver Buffer Overflow Flag
    TXOF // at 1: Transmitter Buffer Overflow Flag
    RXUF // at 0: Receiver Buffer Underflow Flag
  }

//---  Register TWFIFO: UART FIFO Transmit Watermark
  TWFIFO @offset 0x13 $u8 {
    TXWATER:8 // at 0: Transmit Watermark
  }

//---  Register TCFIFO: UART FIFO Transmit Count
  TCFIFO @offset 0x14 @ro $u8 {
    TXCOUNT:8 // at 0: Transmit Counter
  }

//---  Register RWFIFO: UART FIFO Receive Watermark
  RWFIFO @offset 0x15 $u8 {
    RXWATER:8 // at 0: Receive Watermark
  }

//---  Register RCFIFO: UART FIFO Receive Count
  RCFIFO @offset 0x16 @ro $u8 {
    RXCOUNT:8 // at 0: Receive Counter
  }

//---  Register C7816: UART 7816 Control Register
  C7816 @offset 0x18 $u8 {
    3
    ONACK // at 4: Generate NACK on Overflow
    ANACK // at 3: Generate NACK on Error
    INIT // at 2: Detect Initial Character
    TTYPE // at 1: Transfer Type
    ISO_7816E // at 0: ISO-7816 Functionality Enabled
  }

//---  Register IE7816: UART 7816 Interrupt Enable Register
  IE7816 @offset 0x19 $u8 {
    WTE // at 7: Wait Timer Interrupt Enable
    CWTE // at 6: Character Wait Timer Interrupt Enable
    BWTE // at 5: Block Wait Timer Interrupt Enable
    INITDE // at 4: Initial Character Detected Interrupt Enable
    ADTE // at 3: ATR Duration Timer Interrupt Enable
    GTVE // at 2: Guard Timer Violated Interrupt Enable
    TXTE // at 1: Transmit Threshold Exceeded Interrupt Enable
    RXTE // at 0: Receive Threshold Exceeded Interrupt Enable
  }

//---  Register IS7816: UART 7816 Interrupt Status Register
  IS7816 @offset 0x1a $u8 {
    WT // at 7: Wait Timer Interrupt
    CWT // at 6: Character Wait Timer Interrupt
    BWT // at 5: Block Wait Timer Interrupt
    INITD // at 4: Initial Character Detected Interrupt
    ADT // at 3: ATR Duration Time Interrupt
    GTV // at 2: Guard Timer Violated Interrupt
    TXT // at 1: Transmit Threshold Exceeded Interrupt
    RXT // at 0: Receive Threshold Exceeded Interrupt
  }

//---  Register WP7816: UART 7816 Wait Parameter Register
  WP7816 @offset 0x1b $u8 {
    WTX:8 // at 0: Wait Time Multiplier (C7816[TTYPE] = 1)
  }

//---  Register WN7816: UART 7816 Wait N Register
  WN7816 @offset 0x1c $u8 {
    GTN:8 // at 0: Guard Band N
  }

//---  Register WF7816: UART 7816 Wait FD Register
  WF7816 @offset 0x1d $u8 {
    GTFD:8 // at 0: FD Multiplier
  }

//---  Register ET7816: UART 7816 Error Threshold Register
  ET7816 @offset 0x1e $u8 {
    TXTHRESHOLD:4 // at 4: Transmit NACK Threshold
    RXTHRESHOLD:4 // at 0: Receive NACK Threshold
  }

//---  Register TL7816: UART 7816 Transmit Length Register
  TL7816 @offset 0x1f $u8 {
    TLEN:8 // at 0: Transmit Length
  }

//---  Register AP7816A_T0: UART 7816 ATR Duration Timer Register A
  AP7816A_T0 @offset 0x3a $u8 {
    ADTI_H:8 // at 0: ATR Duration Time Integer High (C7816[TTYPE] = 0)
  }

//---  Register AP7816B_T0: UART 7816 ATR Duration Timer Register B
  AP7816B_T0 @offset 0x3b $u8 {
    ADTI_L:8 // at 0: ATR Duration Time Integer Low (C7816[TTYPE] = 0)
  }

//---  Register WP7816A_T0: UART 7816 Wait Parameter Register A
  WP7816A_T0 @offset 0x3c $u8 {
    WI_H:8 // at 0: Wait Time Integer High (C7816[TTYPE] = 0)
  }

//---  Register WP7816A_T1: UART 7816 Wait Parameter Register A
  WP7816A_T1 @offset 0x3c $u8 {
    BWI_H:8 // at 0: Block Wait Time Integer High (C7816[TTYPE] = 1)
  }

//---  Register WP7816B_T0: UART 7816 Wait Parameter Register B
  WP7816B_T0 @offset 0x3d $u8 {
    WI_L:8 // at 0: Wait Time Integer Low (C7816[TTYPE] = 0)
  }

//---  Register WP7816B_T1: UART 7816 Wait Parameter Register B
  WP7816B_T1 @offset 0x3d $u8 {
    BWI_L:8 // at 0: Block Wait Time Integer Low (C7816[TTYPE] = 1)
  }

//---  Register WGP7816_T1: UART 7816 Wait and Guard Parameter Register
  WGP7816_T1 @offset 0x3e $u8 {
    CWI1:4 // at 4: Character Wait Time Integer 1 (C7816[TTYPE] = 1)
    BGI:4 // at 0: Block Guard Time Integer (C7816[TTYPE] = 1)
  }

//---  Register WP7816C_T1: UART 7816 Wait Parameter Register C
  WP7816C_T1 @offset 0x3f $u8 {
    3
    CWI2:5 // at 0: Character Wait Time Integer 2 (C7816[TTYPE] = 1)
  }

}

//------------------------------------------------------------------------------
// Peripheral USB0: Universal Serial Bus, OTG Capable Controller
//------------------------------------------------------------------------------

registers ©USB0 @at 0x40072000 {
//---  Register PERID: Peripheral ID register
  PERID @offset 0x0 @ro $u8 {
    2
    ID:6 // at 0: Peripheral Identification
  }

//---  Register IDCOMP: Peripheral ID Complement register
  IDCOMP @offset 0x4 @ro $u8 {
    2
    NID:6 // at 0: Ones' complement of PERID[ID]. bits.
  }

//---  Register REV: Peripheral Revision register
  REV @offset 0x8 @ro $u8 {
    REV:8 // at 0: Revision
  }

//---  Register ADDINFO: Peripheral Additional Info register
  ADDINFO @offset 0xc @ro $u8 {
    7
    IEHOST // at 0: This bit is set if host mode is enabled.
  }

//---  Register OTGISTAT: OTG Interrupt Status register
  OTGISTAT @offset 0x10 $u8 {
    IDCHG // at 7: This bit is set when a change in the ID Signal from the USB connector is sensed.
    ONEMSEC // at 6: This bit is set when the 1 millisecond timer expires
    LINE_STATE_CHG // at 5: This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits) are stable without change for 1 millisecond, and the value of the line state is different from the last time when the line state was stable
    1
    SESSVLDCHG // at 3: This bit is set when a change in VBUS is detected indicating a session valid or a session no longer valid
    B_SESS_CHG // at 2: This bit is set when a change in VBUS is detected on a B device.
    1
    AVBUSCHG // at 0: This bit is set when a change in VBUS is detected on an A device.
  }

//---  Register OTGICR: OTG Interrupt Control register
  OTGICR @offset 0x14 $u8 {
    IDEN // at 7: ID Interrupt Enable
    ONEMSECEN // at 6: One Millisecond Interrupt Enable
    LINESTATEEN // at 5: Line State Change Interrupt Enable
    1
    SESSVLDEN // at 3: Session Valid Interrupt Enable
    BSESSEN // at 2: B Session END Interrupt Enable
    1
    AVBUSEN // at 0: A VBUS Valid Interrupt Enable
  }

//---  Register OTGSTAT: OTG Status register
  OTGSTAT @offset 0x18 $u8 {
    ID // at 7: Indicates the current state of the ID pin on the USB connector
    ONEMSECEN // at 6: This bit is reserved for the 1ms count, but it is not useful to software.
    LINESTATESTABLE // at 5: Indicates that the internal signals that control the LINE_STATE_CHG field of OTGISTAT are stable for at least 1 ms
    1
    SESS_VLD // at 3: Session Valid
    BSESSEND // at 2: B Session End
    1
    AVBUSVLD // at 0: A VBUS Valid
  }

//---  Register OTGCTL: OTG Control register
  OTGCTL @offset 0x1c $u8 {
    DPHIGH // at 7: D+ Data Line pullup resistor enable
    1
    DPLOW // at 5: D+ Data Line pull-down resistor enable
    DMLOW // at 4: D- Data Line pull-down resistor enable
    1
    OTGEN // at 2: On-The-Go pullup/pulldown resistor enable
    2
  }

//---  Register ISTAT: Interrupt Status register
  ISTAT @offset 0x80 $u8 {
    STALL // at 7: Stall Interrupt
    ATTACH // at 6: Attach Interrupt
    RESUME // at 5: This bit is set when a K-state is observed on the DP/DM signals for 2
    SLEEP // at 4: This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms
    TOKDNE // at 3: This bit is set when the current token being processed has completed
    SOFTOK // at 2: This bit is set when the USB Module receives a Start Of Frame (SOF) token
    ERROR // at 1: This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur
    USBRST // at 0: This bit is set when the USB Module has decoded a valid USB reset
  }

//---  Register INTEN: Interrupt Enable register
  INTEN @offset 0x84 $u8 {
    STALLEN // at 7: STALL Interrupt Enable
    ATTACHEN // at 6: ATTACH Interrupt Enable
    RESUMEEN // at 5: RESUME Interrupt Enable
    SLEEPEN // at 4: SLEEP Interrupt Enable
    TOKDNEEN // at 3: TOKDNE Interrupt Enable
    SOFTOKEN // at 2: SOFTOK Interrupt Enable
    ERROREN // at 1: ERROR Interrupt Enable
    USBRSTEN // at 0: USBRST Interrupt Enable
  }

//---  Register ERRSTAT: Error Interrupt Status register
  ERRSTAT @offset 0x88 $u8 {
    BTSERR // at 7: This bit is set when a bit stuff error is detected
    1
    DMAERR // at 5: This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data
    BTOERR // at 4: This bit is set when a bus turnaround timeout error occurs
    DFN8 // at 3: This bit is set if the data field received was not 8 bits in length
    CRC16 // at 2: This bit is set when a data packet is rejected due to a CRC16 error.
    CRC5EOF // at 1: This error interrupt has two functions
    PIDERR // at 0: This bit is set when the PID check field fails.
  }

//---  Register ERREN: Error Interrupt Enable register
  ERREN @offset 0x8c $u8 {
    BTSERREN // at 7: BTSERR Interrupt Enable
    1
    DMAERREN // at 5: DMAERR Interrupt Enable
    BTOERREN // at 4: BTOERR Interrupt Enable
    DFN8EN // at 3: DFN8 Interrupt Enable
    CRC16EN // at 2: CRC16 Interrupt Enable
    CRC5EOFEN // at 1: CRC5/EOF Interrupt Enable
    PIDERREN // at 0: PIDERR Interrupt Enable
  }

//---  Register STAT: Status register
  STAT @offset 0x90 @ro $u8 {
    ENDP:4 // at 4: This four-bit field encodes the endpoint address that received or transmitted the previous token
    TX // at 3: Transmit Indicator
    ODD // at 2: This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.
    2
  }

//---  Register CTL: Control register
  CTL @offset 0x94 $u8 {
    JSTATE // at 7: Live USB differential receiver JSTATE signal
    SE0 // at 6: Live USB Single Ended Zero signal
    TXSUSPENDTOKENBUSY // at 5: In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token
    RESET // at 4: Setting this bit enables the USB Module to generate USB reset signaling
    HOSTMODEEN // at 3: When set to 1, this bit enables the USB Module to operate in Host mode
    RESUME // at 2: When set to 1 this bit enables the USB Module to execute resume signaling
    ODDRST // at 1: Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank
    USBENSOFEN // at 0: USB Enable
  }

//---  Register ADDR: Address register
  ADDR @offset 0x98 $u8 {
    LSEN // at 7: Low Speed Enable bit
    ADDR:7 // at 0: USB Address
  }

//---  Register BDTPAGE1: BDT Page register 1
  BDTPAGE1 @offset 0x9c $u8 {
    BDTBA:7 // at 1: Provides address bits 15 through 9 of the BDT base address.
    1
  }

//---  Register FRMNUML: Frame Number register Low
  FRMNUML @offset 0xa0 $u8 {
    FRM:8 // at 0: This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
  }

//---  Register FRMNUMH: Frame Number register High
  FRMNUMH @offset 0xa4 $u8 {
    5
    FRM:3 // at 0: This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
  }

//---  Register TOKEN: Token register
  TOKEN @offset 0xa8 $u8 {
    TOKENPID:4 // at 4: Contains the token type executed by the USB module.
    TOKENENDPT:4 // at 0: Holds the Endpoint address for the token command
  }

//---  Register SOFTHLD: SOF Threshold register
  SOFTHLD @offset 0xac $u8 {
    CNT:8 // at 0: Represents the SOF count threshold in byte times.
  }

//---  Register BDTPAGE2: BDT Page Register 2
  BDTPAGE2 @offset 0xb0 $u8 {
    BDTBA:8 // at 0: Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
  }

//---  Register BDTPAGE3: BDT Page Register 3
  BDTPAGE3 @offset 0xb4 $u8 {
    BDTBA:8 // at 0: Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
  }

//---  Registers ENDPT(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Endpoint Control register
  #define USB0_ENDPT(idx) (* ((volatile uint8_t *) (0x40072000 + 0xc0 + (idx) * 0x4)))
  #define USB0_ENDPT0 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 0 * 0x4)))
  #define USB0_ENDPT1 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 1 * 0x4)))
  #define USB0_ENDPT2 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 2 * 0x4)))
  #define USB0_ENDPT3 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 3 * 0x4)))
  #define USB0_ENDPT4 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 4 * 0x4)))
  #define USB0_ENDPT5 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 5 * 0x4)))
  #define USB0_ENDPT6 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 6 * 0x4)))
  #define USB0_ENDPT7 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 7 * 0x4)))
  #define USB0_ENDPT8 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 8 * 0x4)))
  #define USB0_ENDPT9 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 9 * 0x4)))
  #define USB0_ENDPT10 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 10 * 0x4)))
  #define USB0_ENDPT11 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 11 * 0x4)))
  #define USB0_ENDPT12 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 12 * 0x4)))
  #define USB0_ENDPT13 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 13 * 0x4)))
  #define USB0_ENDPT14 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 14 * 0x4)))
  #define USB0_ENDPT15 (* ((volatile uint8_t *) (0x40072000 + 0xc0 + 15 * 0x4)))
 {
    HOSTWOHUB // at 7: Host without a hub This is a Host mode only field and is present in the control register for endpoint 0 (ENDPT0) only
    RETRYDIS // at 6: This is a Host mode only bit and is present in the control register for endpoint 0 (ENDPT0) only
    1
    EPCTLDIS // at 4: This bit, when set, disables control (SETUP) transfers
    EPRXEN // at 3: This bit, when set, enables the endpoint for RX transfers. See
    EPTXEN // at 2: This bit, when set, enables the endpoint for TX transfers. See
    EPSTALL // at 1: When set this bit indicates that the endpoint is called
    EPHSHK // at 0: When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint
  }

//---  Register USBCTRL: USB Control register
  USBCTRL @offset 0x100 $u8 {
    SUSP // at 7: Places the USB transceiver into the suspend state.
    PDE // at 6: Enables the weak pulldowns on the USB transceiver.
    6
  }

//---  Register OBSERVE: USB OTG Observe register
  OBSERVE @offset 0x104 @ro $u8 {
    DPPU // at 7: Provides observability of the D+ Pullup enable at the USB transceiver.
    DPPD // at 6: Provides observability of the D+ Pulldown enable at the USB transceiver.
    1
    DMPD // at 4: Provides observability of the D- Pulldown enable at the USB transceiver.
    4
  }

//---  Register CONTROL: USB OTG Control register
  CONTROL @offset 0x108 $u8 {
    3
    DPPULLUPNONOTG // at 4: Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG device mode.
    4
  }

//---  Register USBTRC0: USB Transceiver Control register 0
  USBTRC0 @offset 0x10c $u8 {
    USBRESET // at 7: USB Reset
    1
    USBRESMEN // at 5: Asynchronous Resume Interrupt Enable
    2
    USB_CLK_RECOVERY_INT // at 2: Combined USB Clock Recovery interrupt status
    SYNC_DET // at 1: Synchronous USB Interrupt Detect
    USB_RESUME_INT // at 0: USB Asynchronous Interrupt
  }

//---  Register USBFRMADJUST: Frame Adjust Register
  USBFRMADJUST @offset 0x114 $u8 {
    ADJ:8 // at 0: Frame Adjustment
  }

//---  Register CLK_RECOVER_CTRL: USB Clock recovery control
  CLK_RECOVER_CTRL @offset 0x140 $u8 {
    CLOCK_RECOVER_EN // at 7: Crystal-less USB enable
    RESET_RESUME_ROUGH_EN // at 6: Reset/resume to rough phase enable
    RESTART_IFRTRIM_EN // at 5: Restart from IFR trim value
    5
  }

//---  Register CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
  CLK_RECOVER_IRC_EN @offset 0x144 $u8 {
    6
    IRC_EN // at 1: IRC48M enable
    REG_EN // at 0: IRC48M regulator enable
  }

//---  Register CLK_RECOVER_INT_EN: Clock recovery combined interrupt enable
  CLK_RECOVER_INT_EN @offset 0x154 $u8 {
    3
    OVF_ERROR_EN // at 4: Determines whether OVF_ERROR condition signal is used in generation of USB_CLK_RECOVERY_INT.
    4
  }

//---  Register CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
  CLK_RECOVER_INT_STATUS @offset 0x15c $u8 {
    3
    OVF_ERROR // at 4: Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M module
    4
  }

}

//------------------------------------------------------------------------------
// Peripheral USBDCD: USB Device Charger Detection module
//------------------------------------------------------------------------------

registers ©USBDCD @at 0x40035000 {
//---  Register CONTROL: Control register
  CONTROL @offset 0x0 $u32 {
    6
    SR // at 25: Software Reset
    START // at 24: Start Change Detection Sequence
    6
    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.
    IE // at 16: Interrupt Enable
    7
    IF // at 8: Interrupt Flag
    7
    IACK // at 0: Interrupt Acknowledge
  }

//---  Register CLOCK: Clock register
  CLOCK @offset 0x4 $u32 {
    20
    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary
    1
    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed
  }

//---  Register STATUS: Status register
  STATUS @offset 0x8 @ro $u32 {
    9
    ACTIVE // at 22: Active Status Indicator
    TO // at 21: Timeout Flag
    ERR // at 20: Error Flag
    SEQ_STAT:2 // at 18: Charger Detection Sequence Status
    SEQ_RES:2 // at 16: Charger Detection Sequence Results
    16
  }

//---  Register SIGNAL_OVERRIDE: Signal Override Register
  SIGNAL_OVERRIDE @offset 0xc $u32 {
    30
    PS:2 // at 0: Phase Selection
  }

//---  Register TIMER0: TIMER0 register
  TIMER0 @offset 0x10 $u32 {
    6
    TSEQ_INIT:10 // at 16: Sequence Initiation Time
    4
    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)
  }

//---  Register TIMER1: TIMER1 register
  TIMER1 @offset 0x14 $u32 {
    6
    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal
    6
    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled
  }

//---  Register TIMER2_BC11: TIMER2_BC11 register
  TIMER2_BC11 @offset 0x18 $u32 {
    6
    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup
    12
    CHECK_DM:4 // at 0: Time Before Check of D- Line
  }

//---  Register TIMER2_BC12: TIMER2_BC12 register
  TIMER2_BC12 @offset 0x18 $u32 {
    6
    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    6
    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
  }

}

//------------------------------------------------------------------------------
// Peripheral USBHS: USB HS/FS/LS OTG Controller
//------------------------------------------------------------------------------

registers ©USBHS @at 0x400a1000 {
//---  Register ID: Identification Register
  ID @offset 0x0 @ro $u32 {
    VERSIONID:3 // at 29: Version ID
    VERSION:4 // at 25: Version
    REVISION:4 // at 21: Revision
    TAG:5 // at 16: Tag
    2
    NID:6 // at 8: Ones complement version of ID.
    2
    ID:6 // at 0: Configuration number
  }

//---  Register HWGENERAL: General Hardware Parameters Register
  HWGENERAL @offset 0x4 @ro $u32 {
    21
    SM:2 // at 9: Serial mode
    PHYM:3 // at 6: PHY Mode
    PHYW:2 // at 4: PHY Width
    4
  }

//---  Register HWHOST: Host Hardware Parameters Register
  HWHOST @offset 0x8 @ro $u32 {
    TTPER:8 // at 24: Transaction translator periodic contexts.
    TTASY:8 // at 16: Transaction translator contexts.
    12
    NPORT:3 // at 1: Number of Ports
    HC // at 0: Host Capable
  }

//---  Register HWDEVICE: Device Hardware Parameters Register
  HWDEVICE @offset 0xc @ro $u32 {
    26
    DEVEP:5 // at 1: Device endpoints.
    DC // at 0: Device Capable
  }

//---  Register HWTXBUF: Transmit Buffer Hardware Parameters Register
  HWTXBUF @offset 0x10 @ro $u32 {
    TXLC // at 31: Transmit local Context Registers
    7
    TXCHANADD:8 // at 16: Transmit Channel Address
    TXADD:8 // at 8: Transmit Address.
    TXBURST:8 // at 0: Transmit Burst.
  }

//---  Register HWRXBUF: Receive Buffer Hardware Parameters Register
  HWRXBUF @offset 0x14 @ro $u32 {
    16
    RXADD:8 // at 8: Receive Address.
    RXBURST:8 // at 0: Receive Burst.
  }

//---  Registers GPTIMERLD(0,1): General Purpose Timer n Load Register
  #define USBHS_GPTIMERLD(idx) (* ((volatile uint32_t *) (0x400a1000 + 0x80 + (idx) * 0x8)))
  #define USBHS_GPTIMER0LD (* ((volatile uint32_t *) (0x400a1000 + 0x80 + 0 * 0x8)))
  #define USBHS_GPTIMER1LD (* ((volatile uint32_t *) (0x400a1000 + 0x80 + 1 * 0x8)))
 {
    8
    GPTLD:24 // at 0: Specifies the value to be loaded into the countdown timer on a reset
  }

//---  Registers GPTIMERCTL(0,1): General Purpose Timer n Control Register
  #define USBHS_GPTIMERCTL(idx) (* ((volatile uint32_t *) (0x400a1000 + 0x84 + (idx) * 0x8)))
  #define USBHS_GPTIMER0CTL (* ((volatile uint32_t *) (0x400a1000 + 0x84 + 0 * 0x8)))
  #define USBHS_GPTIMER1CTL (* ((volatile uint32_t *) (0x400a1000 + 0x84 + 1 * 0x8)))
 {
    RUN // at 31: Timer Run
    RST // at 30: Timer Reset
    5
    MODE // at 24: Timer Mode
    GPTCNT:24 // at 0: Timer Count
  }

//---  Register USB_SBUSCFG: System Bus Interface Configuration Register
  USB_SBUSCFG @offset 0x90 $u32 {
    29
    BURSTMODE:3 // at 0: Burst mode
  }

//---  Register HCIVERSION: Host Controller Interface Version and Capability Registers Length Register
  HCIVERSION @offset 0x100 @ro $u32 {
    HCIVERSION:16 // at 16: EHCI revision number
    8
    CAPLENGTH:8 // at 0: Capability registers length
  }

//---  Register HCSPARAMS: Host Controller Structural Parameters Register
  HCSPARAMS @offset 0x104 @ro $u32 {
    4
    N_TT:4 // at 24: Number of Transaction Translators.
    N_PTT:4 // at 20: Ports per Transaction Translator
    3
    PI // at 16: Port Indicators
    N_CC:4 // at 12: Number of Companion Controllers
    N_PCC:4 // at 8: Number Ports per CC
    3
    PPC // at 4: Power Port Control
    N_PORTS:4 // at 0: Number of Ports
  }

//---  Register HCCPARAMS: Host Controller Capability Parameters Register
  HCCPARAMS @offset 0x108 @ro $u32 {
    16
    EECP:8 // at 8: EHCI Extended Capabilities Pointer
    IST:4 // at 4: Isochronous Scheduling Threshold
    1
    ASP // at 2: Asynchronous Schedule Park capability
    PFL // at 1: Programmable Frame List flag
    ADC // at 0: 64-bit addressing capability.
  }

//---  Register DCIVERSION: Device Controller Interface Version
  DCIVERSION @offset 0x122 @ro $u16 {
    DCIVERSION:16 // at 0: Device interface revision number.
  }

//---  Register DCCPARAMS: Device Controller Capability Parameters
  DCCPARAMS @offset 0x124 @ro $u32 {
    23
    HC // at 8: Host Capable
    DC // at 7: Device Capable
    2
    DEN:5 // at 0: Device Endpoint Number
  }

//---  Register USBCMD: USB Command Register
  USBCMD @offset 0x140 $u32 {
    8
    ITC:8 // at 16: Interrupt Threshold Control
    FS2 // at 15: Frame list Size 2
    ATDTW // at 14: Add dTD TripWire
    SUTW // at 13: Setup TripWire
    1
    ASPE // at 11: Asynchronous Schedule Park mode Enable
    1
    ASP:2 // at 8: Asynchronous Schedule Park mode count
    1
    IAA // at 6: Interrupt on Async Advance doorbell
    ASE // at 5: Asynchronous Schedule Enable
    PSE // at 4: Periodic Schedule Enable
    FS:2 // at 2: Frame list Size
    RST // at 1: Controller Reset
    RS // at 0: Run/Stop
  }

//---  Register USBSTS: USB Status Register
  USBSTS @offset 0x144 $u32 {
    6
    TI1 // at 25: General purpose Timer 1 Interrupt
    TI0 // at 24: General purpose Timer 0 Interrupt
    4
    UPI // at 19: USB host Periodic Interrupt
    UAI // at 18: USB host Asynchronous Interrupt
    1
    NAKI // at 16: NAK Interrupt
    AS // at 15: Asynchronous schedule Status
    PS // at 14: Periodic schedule Status
    RCL // at 13: Reclamation
    HCH // at 12: Host Controller Halted
    3
    SLI // at 8: Device-controller suspend
    SRI // at 7: SOF Received
    URI // at 6: USB Reset received
    AAI // at 5: Interrupt on Async Advance
    SEI // at 4: System Error
    FRI // at 3: Frame-list Rollover
    PCI // at 2: Port Change detect
    UEI // at 1: USB Error Interrupt
    UI // at 0: USB Interrupt (USBINT)
  }

//---  Register USBINTR: USB Interrupt Enable Register
  USBINTR @offset 0x148 $u32 {
    6
    TIE1 // at 25: General purpose Timer 1 Interrupt Enable
    TIE0 // at 24: General purpose Timer 0 Interrupt Enable
    4
    UPIE // at 19: USB host Periodic Interrupt Enable
    UAIE // at 18: USB host Asynchronous Interrupt Enable
    1
    NAKE // at 16: NAK Interrupt Enable
    7
    SLE // at 8: Sleep (DC suspend) Enable
    SRE // at 7: SOF-Received Enable
    URE // at 6: USB-Reset Enable
    AAE // at 5: Interrupt on Async advance Enable
    SEE // at 4: System Error Enable
    FRE // at 3: Frame list Rollover Enable
    PCE // at 2: Port Change detect Enable
    UEE // at 1: USB Error interrupt Enable
    UE // at 0: USB interrupt Enable
  }

//---  Register FRINDEX: Frame Index Register
  FRINDEX @offset 0x14c $u32 {
    Reerved:18 // at 14: Reserved
    FRINDEX:14 // at 0: Frame Index
  }

//---  Register DEVICEADDR: Device Address Register
  DEVICEADDR @offset 0x154 $u32 {
    USBADR:7 // at 25: Device Address
    USBADRA // at 24: Device Address Advance
    24
  }

//---  Register PERIODICLISTBASE: Periodic Frame List Base Address Register
  PERIODICLISTBASE @offset 0x154 $u32 {
    PERBASE:20 // at 12: Base address
    12
  }

//---  Register ASYNCLISTADDR: Current Asynchronous List Address Register
  ASYNCLISTADDR @offset 0x158 $u32 {
    ASYBASE:27 // at 5: Link pointer low (LPL)
    5
  }

//---  Register EPLISTADDR: Endpoint List Address Register
  EPLISTADDR @offset 0x158 $u32 {
    EPBASE:21 // at 11: Endpoint list address
    11
  }

//---  Register TTCTRL: Host TT Asynchronous Buffer Control
  TTCTRL @offset 0x15c @ro $u32 {
    Reerved // at 31: Reserved
    TTHA:7 // at 24: TT Hub Address
    24
  }

//---  Register BURSTSIZE: Master Interface Data Burst Size Register
  BURSTSIZE @offset 0x160 $u32 {
    16
    TXPBURST:8 // at 8: Programable TX Burst length
    RXPBURST:8 // at 0: Programable RX Burst length
  }

//---  Register TXFILLTUNING: Transmit FIFO Tuning Control Register
  TXFILLTUNING @offset 0x164 $u32 {
    10
    TXFIFOTHRES:6 // at 16: FIFO burst Threshold
    3
    TXSCHHEALTH:5 // at 8: Scheduler Health counter
    1
    TXSCHOH:7 // at 0: Scheduler Overhead
  }

//---  Register ENDPTNAK: Endpoint NAK Register
  ENDPTNAK @offset 0x178 $u32 {
    12
    EPTN:4 // at 16: TX Endpoint NAK
    12
    EPRN:4 // at 0: RX Endpoint NAK
  }

//---  Register ENDPTNAKEN: Endpoint NAK Enable Register
  ENDPTNAKEN @offset 0x17c $u32 {
    12
    EPTNE:4 // at 16: TX Endpoint NAK
    12
    EPRNE:4 // at 0: RX Endpoint NAK
  }

//---  Register CONFIGFLAG: Configure Flag Register
  CONFIGFLAG @offset 0x180 @ro $u32
//---  Register PORTSC1: Port Status and Control Registers
  PORTSC1 @offset 0x184 $u32 {
    PTS:2 // at 30: Port Transceiver Select [1:0]
    2
    PSPD:2 // at 26: Port Speed
    PTS2 // at 25: Port Transceiver Select [2]
    PFSC // at 24: Port force Full-Speed Connect
    PHCD // at 23: PHY low power suspend
    WKOC // at 22: Wake on Over-Current enable
    WKDS // at 21: Wake on Disconnect enable
    WKCN // at 20: Wake on Connect enable
    PTC:4 // at 16: Port Test Control
    PIC:2 // at 14: Port Indicator Control
    PO // at 13: Port Owner
    PP // at 12: Port Power
    LS:2 // at 10: Line Status
    HSP // at 9: High Speed Port.
    PR // at 8: Port Reset
    SUSP // at 7: Suspend
    FPR // at 6: Force Port Resume
    OCC // at 5: Over-Current Change
    OCA // at 4: Over-current active
    PEC // at 3: Port Enable/disable Change
    PE // at 2: Port Enabled/disabled
    CSC // at 1: Connect Change Status
    CCS // at 0: Current Connect Status
  }

//---  Register OTGSC: On-the-Go Status and Control Register
  OTGSC @offset 0x1a4 $u32 {
    1
    DPIE // at 30: Data Pulse Interrupt Enable
    MSE // at 29: 1 Milli-Second timer interrupt Enable
    BSEIE // at 28: B Session End Interrupt Enable
    BSVIE // at 27: B Session Valid Interrupt Enable
    ASVIE // at 26: A Session Valid Interrupt Enable
    AVVIE // at 25: A VBUS Valid Interrupt Enable
    IDIE // at 24: USB ID Interrupt Enable
    1
    DPIS // at 22: Data Pulse interrupt Status
    MSS // at 21: 1 Milli-Second timer interrupt Status
    BSEIS // at 20: B Session End Interrupt Status
    BSVIS // at 19: B Session Valid Interrupt Status
    ASVIS // at 18: A Session Valid Interrupt Status
    AVVIS // at 17: A VBUS Valid Interrupt Status
    IDIS // at 16: USB ID Interrupt Status
    1
    DPS // at 14: Data bus Pulsing Status
    MST // at 13: 1 Milli-Second timer Toggle
    BSE // at 12: B Session End
    BSV // at 11: B Session Valid
    ASV // at 10: A Session Valid
    AVV // at 9: A VBus Valid
    ID // at 8: USB ID
    HABA // at 7: Hardware Assist B-Disconnect to A-connect
    1
    IDPU // at 5: ID Pull-Up
    DP // at 4: Data Pulsing
    OT // at 3: OTG Termination
    HAAR // at 2: Hardware Assist Auto-Reset
    VC // at 1: VBUS Charge
    VD // at 0: VBUS Discharge
  }

//---  Register USBMODE: USB Mode Register
  USBMODE @offset 0x1a8 $u32 {
    17
    TXHSD:3 // at 12: Tx to Tx HS Delay
    7
    SDIS // at 4: Stream DISable
    SLOM // at 3: Setup Lock-Out Mode
    ES // at 2: Endian Select
    CM:2 // at 0: Controller Mode
  }

//---  Register EPSETUPSR: Endpoint Setup Status Register
  EPSETUPSR @offset 0x1ac $u32 {
    28
    EPSETUPSTAT:4 // at 0: Setup Endpoint Status
  }

//---  Register EPPRIME: Endpoint Initialization Register
  EPPRIME @offset 0x1b0 $u32 {
    12
    PETB:4 // at 16: Prime Endpoint tTansmit Buffer
    12
    PERB:4 // at 0: Prime Endpoint Receive Buffer
  }

//---  Register EPFLUSH: Endpoint Flush Register
  EPFLUSH @offset 0x1b4 $u32 {
    12
    FETB:4 // at 16: Flush Endpoint Transmit Buffer
    12
    FERB:4 // at 0: Flush Endpoint Receive Buffer
  }

//---  Register EPSR: Endpoint Status Register
  EPSR @offset 0x1b8 @ro $u32 {
    12
    ETBR:4 // at 16: Endpoint Transmit Buffer Ready
    12
    ERBR:4 // at 0: Endpoint Receive Buffer Ready
  }

//---  Register EPCOMPLETE: Endpoint Complete Register
  EPCOMPLETE @offset 0x1bc $u32 {
    12
    ETCE:4 // at 16: Endpoint Transmit Complete Event
    12
    ERCE:4 // at 0: Endpoint Receive Complete Event
  }

//---  Register EPCR0: Endpoint Control Register 0
  EPCR0 @offset 0x1c0 $u32 {
    8
    TXE // at 23: TX Endpoint Enable
    3
    TXT:2 // at 18: TX Endpoint Type
    1
    TXS // at 16: TX Endpoint Stall
    8
    RXE // at 7: RX endpoint Enable
    3
    RXT:2 // at 2: RX endpoint Type
    1
    RXS // at 0: RX endpoint Stall
  }

//---  Registers EPCR(1,2,3,4,5,6,7): Endpoint Control Register n
  #define USBHS_EPCR(idx) (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + (idx) * 0x4)))
  #define USBHS_EPCR1 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 0 * 0x4)))
  #define USBHS_EPCR2 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 1 * 0x4)))
  #define USBHS_EPCR3 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 2 * 0x4)))
  #define USBHS_EPCR4 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 3 * 0x4)))
  #define USBHS_EPCR5 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 4 * 0x4)))
  #define USBHS_EPCR6 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 5 * 0x4)))
  #define USBHS_EPCR7 (* ((volatile uint32_t *) (0x400a1000 + 0x1c4 + 6 * 0x4)))
 {
    8
    TXE // at 23: TX endpoint Enable
    TXR // at 22: TX data toggle Reset
    TXI // at 21: TX data toggle Inhibit
    1
    TXT:2 // at 18: TX endpoint Type
    TXD // at 17: TX endpoint Data source
    TXS // at 16: TX endpoint Stall
    8
    RXE // at 7: RX endpoint Enable
    RXR // at 6: RX data toggle Reset
    RXI // at 5: RX data toggle Inhibit
    1
    RXT:2 // at 2: RX endpoint Type
    RXD // at 1: RX endpoint Data sink
    RXS // at 0: RX endpoint Stall
  }

//---  Register USBGENCTRL: USB General Control Register
  USBGENCTRL @offset 0x200 $u32 {
    26
    WU_INT_CLR // at 5: Wakeup Interrupt Clear
    4
    WU_IE // at 0: Wakeup Interrupt Enable
  }

}

//------------------------------------------------------------------------------
// Peripheral USBHSDCD: USB Device Charger Detection module
//------------------------------------------------------------------------------

registers ©USBHSDCD @at 0x400a3000 {
//---  Register CONTROL: Control register
  CONTROL @offset 0x0 $u32 {
    6
    SR // at 25: Software Reset
    START // at 24: Start Change Detection Sequence
    6
    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.
    IE // at 16: Interrupt Enable
    7
    IF // at 8: Interrupt Flag
    7
    IACK // at 0: Interrupt Acknowledge
  }

//---  Register CLOCK: Clock register
  CLOCK @offset 0x4 $u32 {
    20
    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary
    1
    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed
  }

//---  Register STATUS: Status register
  STATUS @offset 0x8 @ro $u32 {
    9
    ACTIVE // at 22: Active Status Indicator
    TO // at 21: Timeout Flag
    ERR // at 20: Error Flag
    SEQ_STAT:2 // at 18: Charger Detection Sequence Status
    SEQ_RES:2 // at 16: Charger Detection Sequence Results
    16
  }

//---  Register SIGNAL_OVERRIDE: Signal Override Register
  SIGNAL_OVERRIDE @offset 0xc $u32 {
    30
    PS:2 // at 0: Phase Selection
  }

//---  Register TIMER0: TIMER0 register
  TIMER0 @offset 0x10 $u32 {
    6
    TSEQ_INIT:10 // at 16: Sequence Initiation Time
    4
    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)
  }

//---  Register TIMER1: TIMER1 register
  TIMER1 @offset 0x14 $u32 {
    6
    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal
    6
    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled
  }

//---  Register TIMER2_BC11: TIMER2_BC11 register
  TIMER2_BC11 @offset 0x18 $u32 {
    6
    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup
    12
    CHECK_DM:4 // at 0: Time Before Check of D- Line
  }

//---  Register TIMER2_BC12: TIMER2_BC12 register
  TIMER2_BC12 @offset 0x18 $u32 {
    6
    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    6
    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
  }

}

//------------------------------------------------------------------------------
// Peripheral USBPHY: USBPHY Register Reference Index
//------------------------------------------------------------------------------

registers ©USBPHY @at 0x400a2000 {
//---  Register PWD: USB PHY Power-Down Register
  PWD @offset 0x0 $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register PWD_SET: USB PHY Power-Down Register
  PWD_SET @offset 0x4 $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register PWD_CLR: USB PHY Power-Down Register
  PWD_CLR @offset 0x8 $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register PWD_TOG: USB PHY Power-Down Register
  PWD_TOG @offset 0xc $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register TX: USB PHY Transmitter Control Register
  TX @offset 0x10 $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register TX_SET: USB PHY Transmitter Control Register
  TX_SET @offset 0x14 $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register TX_CLR: USB PHY Transmitter Control Register
  TX_CLR @offset 0x18 $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register TX_TOG: USB PHY Transmitter Control Register
  TX_TOG @offset 0x1c $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register RX: USB PHY Receiver Control Register
  RX @offset 0x20 $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register RX_SET: USB PHY Receiver Control Register
  RX_SET @offset 0x24 $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register RX_CLR: USB PHY Receiver Control Register
  RX_CLR @offset 0x28 $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register RX_TOG: USB PHY Receiver Control Register
  RX_TOG @offset 0x2c $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register CTRL: USB PHY General Control Register
  CTRL @offset 0x30 $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register CTRL_SET: USB PHY General Control Register
  CTRL_SET @offset 0x34 $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register CTRL_CLR: USB PHY General Control Register
  CTRL_CLR @offset 0x38 $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register CTRL_TOG: USB PHY General Control Register
  CTRL_TOG @offset 0x3c $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register STATUS: USB PHY Status Register
  STATUS @offset 0x40 $u32 {
    21
    RESUME_STATUS // at 10: Indicates that the host is sending a wake-up after Suspend and has triggered an interrupt.
    1
    OTGID_STATUS // at 8: Indicates the results of USB_ID pin on the USB cable plugged into the local Micro- or Mini-AB receptacle
    1
    DEVPLUGIN_STATUS // at 6: Status indicator for non-standard resistive plugged-in detection
    2
    HOSTDISCONDETECT_STATUS // at 3: Indicates at the local host (downstream) port that the remote device has disconnected while in High-Speed mode
    3
  }

//---  Register DEBUG: USB PHY Debug Register
  DEBUG @offset 0x50 $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG_SET: USB PHY Debug Register
  DEBUG_SET @offset 0x54 $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG_CLR: USB PHY Debug Register
  DEBUG_CLR @offset 0x58 $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG_TOG: USB PHY Debug Register
  DEBUG_TOG @offset 0x5c $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG0_STATUS: UTMI Debug Status Register 0
  DEBUG0_STATUS @offset 0x60 @ro $u32 {
    SQUELCH_COUNT:6 // at 26: Running count of the squelch reset instead of normal end for HS RX.
    UTMI_RXERROR_FAIL_COUNT:10 // at 16: Running count of the UTMI_RXERROR.
    LOOP_BACK_FAIL_COUNT:16 // at 0: Running count of the failed pseudo-random generator loopback
  }

//---  Register DEBUG1: UTMI Debug Status Register 1
  DEBUG1 @offset 0x70 $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register DEBUG1_SET: UTMI Debug Status Register 1
  DEBUG1_SET @offset 0x74 $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register DEBUG1_CLR: UTMI Debug Status Register 1
  DEBUG1_CLR @offset 0x78 $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register DEBUG1_TOG: UTMI Debug Status Register 1
  DEBUG1_TOG @offset 0x7c $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register VERSION: UTMI RTL Version
  VERSION @offset 0x80 @ro $u32 {
    MAJOR:8 // at 24: Fixed read-only value reflecting the MAJOR field of the RTL version.
    MINOR:8 // at 16: Fixed read-only value reflecting the MINOR field of the RTL version.
    STEP:16 // at 0: Fixed read-only value reflecting the stepping of the RTL version.
  }

//---  Register PLL_SIC: USB PHY PLL Control/Status Register
  PLL_SIC @offset 0xa0 $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register PLL_SIC_SET: USB PHY PLL Control/Status Register
  PLL_SIC_SET @offset 0xa4 $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register PLL_SIC_CLR: USB PHY PLL Control/Status Register
  PLL_SIC_CLR @offset 0xa8 $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register PLL_SIC_TOG: USB PHY PLL Control/Status Register
  PLL_SIC_TOG @offset 0xac $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register USB1_VBUS_DETECT: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT @offset 0xc0 $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DETECT_SET: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT_SET @offset 0xc4 $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DETECT_CLR: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT_CLR @offset 0xc8 $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DETECT_TOG: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT_TOG @offset 0xcc $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DET_STAT: USB PHY VBUS Detector Status Register
  USB1_VBUS_DET_STAT @offset 0xd0 @ro $u32 {
    27
    VBUS_VALID_3V // at 4: VBUS_VALID_3V detector status
    VBUS_VALID // at 3: VBUS voltage status
    AVALID // at 2: A-Device Session Valid status
    BVALID // at 1: B-Device Session Valid status
    SESSEND // at 0: Session End indicator
  }

//---  Register USB1_CHRG_DET_STAT: USB PHY Charger Detect Status Register
  USB1_CHRG_DET_STAT @offset 0xf0 @ro $u32 {
    27
    SECDET_DCP // at 4: Battery Charging Secondary Detection phase output
    DP_STATE // at 3: Single ended receiver output for the USB_DP pin, from charger detection circuits.
    DM_STATE // at 2: Single ended receiver output for the USB_DM pin, from charger detection circuits.
    CHRG_DETECTED // at 1: Battery Charging Primary Detection phase output
    PLUG_CONTACT // at 0: Battery Charging Data Contact Detection phase output
  }

//---  Register ANACTRL: USB PHY Analog Control Register
  ANACTRL @offset 0x100 $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register ANACTRL_SET: USB PHY Analog Control Register
  ANACTRL_SET @offset 0x104 $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register ANACTRL_CLR: USB PHY Analog Control Register
  ANACTRL_CLR @offset 0x108 $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register ANACTRL_TOG: USB PHY Analog Control Register
  ANACTRL_TOG @offset 0x10c $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register USB1_LOOPBACK: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK @offset 0x110 $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_SET: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK_SET @offset 0x114 $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_CLR: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK_CLR @offset 0x118 $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_TOG: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK_TOG @offset 0x11c $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_HSFSCNT: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT @offset 0x120 $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register USB1_LOOPBACK_HSFSCNT_SET: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT_SET @offset 0x124 $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register USB1_LOOPBACK_HSFSCNT_CLR: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT_CLR @offset 0x128 $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register USB1_LOOPBACK_HSFSCNT_TOG: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT_TOG @offset 0x12c $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register TRIM_OVERRIDE_EN: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN @offset 0x130 $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

//---  Register TRIM_OVERRIDE_EN_SET: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN_SET @offset 0x134 $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

//---  Register TRIM_OVERRIDE_EN_CLR: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN_CLR @offset 0x138 $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

//---  Register TRIM_OVERRIDE_EN_TOG: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN_TOG @offset 0x13c $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

}

//------------------------------------------------------------------------------
// Peripheral VREF: Voltage Reference
//------------------------------------------------------------------------------

registers ©VREF @at 0x40074000 {
//---  Register TRM: VREF Trim Register
  TRM @offset 0x0 $u8 {
    1
    CHOPEN // at 6: Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    TRIM:6 // at 0: Trim bits
  }

//---  Register SC: VREF Status and Control Register
  SC @offset 0x1 $u8 {
    VREFEN // at 7: Internal Voltage Reference enable
    REGEN // at 6: Regulator enable
    ICOMPEN // at 5: Second order curvature compensation enable
    2
    VREFST // at 2: Internal Voltage Reference stable
    MODE_LV:2 // at 0: Buffer Mode selection
  }

}

//------------------------------------------------------------------------------
// Peripheral WDOG: Generation 2008 Watchdog Timer
//------------------------------------------------------------------------------

registers ©WDOG @at 0x40052000 {
//---  Register STCTRLH: Watchdog Status and Control Register High
  STCTRLH @offset 0x0 $u16 {
    1
    DISTESTWDOG // at 14: Allows the WDOG's functional test mode to be disabled permanently
    BYTESEL:2 // at 12: This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
    TESTSEL // at 11: Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
    TESTWDOG // at 10: Puts the watchdog in the functional test mode
    2
    WAITEN // at 7: Enables or disables WDOG in Wait mode.
    STOPEN // at 6: Enables or disables WDOG in Stop mode.
    DBGEN // at 5: Enables or disables WDOG in Debug mode.
    ALLOWUPDATE // at 4: Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
    WINEN // at 3: Enables Windowing mode.
    IRQRSTEN // at 2: Used to enable the debug breadcrumbs feature
    CLKSRC // at 1: Selects clock source for the WDOG timer and other internal timing operations.
    WDOGEN // at 0: Enables or disables the WDOG's operation
  }

//---  Register STCTRLL: Watchdog Status and Control Register Low
  STCTRLL @offset 0x2 $u16 {
    INTFLG // at 15: Interrupt flag
    15
  }

//---  Register TOVALH: Watchdog Time-out Value Register High
  TOVALH @offset 0x4 $u16 {
    TOVALHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
  }

//---  Register TOVALL: Watchdog Time-out Value Register Low
  TOVALL @offset 0x6 $u16 {
    TOVALLOW:16 // at 0: Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
  }

//---  Register WINH: Watchdog Window Register High
  WINH @offset 0x8 $u16 {
    WINHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
  }

//---  Register WINL: Watchdog Window Register Low
  WINL @offset 0xa $u16 {
    WINLOW:16 // at 0: Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
  }

//---  Register REFRESH: Watchdog Refresh register
  REFRESH @offset 0xc $u16 {
    WDOGREFRESH:16 // at 0: Watchdog refresh register
  }

//---  Register UNLOCK: Watchdog Unlock register
  UNLOCK @offset 0xe $u16 {
    WDOGUNLOCK:16 // at 0: Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
  }

//---  Register TMROUTH: Watchdog Timer Output Register High
  TMROUTH @offset 0x10 $u16 {
    TIMEROUTHIGH:16 // at 0: Shows the value of the upper 16 bits of the watchdog timer.
  }

//---  Register TMROUTL: Watchdog Timer Output Register Low
  TMROUTL @offset 0x12 $u16 {
    TIMEROUTLOW:16 // at 0: Shows the value of the lower 16 bits of the watchdog timer.
  }

//---  Register RSTCNT: Watchdog Reset Count register
  RSTCNT @offset 0x14 $u16 {
    RSTCNT:16 // at 0: Counts the number of times the watchdog resets the system
  }

//---  Register PRESC: Watchdog Prescaler register
  PRESC @offset 0x16 $u16 {
    5
    PRESCVAL:3 // at 8: 3-bit prescaler for the watchdog clock source
    8
  }

}

//------------------------------------------------------------------------------
// INTERRUPTS
//------------------------------------------------------------------------------

enum class ISRSlot : uint8_t {
  DMA0_DMA16 = 0,
  DMA1_DMA17 = 1,
  DMA2_DMA18 = 2,
  DMA3_DMA19 = 3,
  DMA4_DMA20 = 4,
  DMA5_DMA21 = 5,
  DMA6_DMA22 = 6,
  DMA7_DMA23 = 7,
  DMA8_DMA24 = 8,
  DMA9_DMA25 = 9,
  DMA10_DMA26 = 10,
  DMA11_DMA27 = 11,
  DMA12_DMA28 = 12,
  DMA13_DMA29 = 13,
  DMA14_DMA30 = 14,
  DMA15_DMA31 = 15,
  DMA_Error = 16,
  MCM = 17,
  FTFE = 18,
  Read_Collision = 19,
  LVD_LVW = 20,
  LLWU = 21,
  WDOG_EWM = 22,
  RNG = 23,
  I2C0 = 24,
  I2C1 = 25,
  SPI0 = 26,
  SPI1 = 27,
  I2S0_Tx = 28,
  I2S0_Rx = 29,
  UART0_RX_TX = 31,
  UART0_ERR = 32,
  UART1_RX_TX = 33,
  UART1_ERR = 34,
  UART2_RX_TX = 35,
  UART2_ERR = 36,
  UART3_RX_TX = 37,
  UART3_ERR = 38,
  ADC0 = 39,
  CMP0 = 40,
  CMP1 = 41,
  FTM0 = 42,
  FTM1 = 43,
  FTM2 = 44,
  CMT = 45,
  RTC = 46,
  RTC_Seconds = 47,
  PIT0 = 48,
  PIT1 = 49,
  PIT2 = 50,
  PIT3 = 51,
  PDB0 = 52,
  USB0 = 53,
  USBDCD = 54,
  DAC0 = 56,
  MCG = 57,
  LPTMR0 = 58,
  PORTA = 59,
  PORTB = 60,
  PORTC = 61,
  PORTD = 62,
  PORTE = 63,
  SPI2 = 65,
  UART4_RX_TX = 66,
  UART4_ERR = 67,
  CMP2 = 70,
  FTM3 = 71,
  DAC1 = 72,
  ADC1 = 73,
  I2C2 = 74,
  CAN0_ORed_Message_buffer = 75,
  CAN0_Bus_Off = 76,
  CAN0_Error = 77,
  CAN0_Tx_Warning = 78,
  CAN0_Rx_Warning = 79,
  CAN0_Wake_Up = 80,
  SDHC = 81,
  ENET_1588_Timer = 82,
  ENET_Transmit = 83,
  ENET_Receive = 84,
  ENET_Error = 85,
  LPUART0 = 86,
  TSI0 = 87,
  TPM1 = 88,
  TPM2 = 89,
  USBHSDCD = 90,
  I2C3 = 91,
  CMP3 = 92,
  USBHS = 93,
  CAN1_ORed_Message_buffer = 94,
  CAN1_Bus_Off = 95,
  CAN1_Error = 96,
  CAN1_Tx_Warning = 97,
  CAN1_Rx_Warning = 98,
  CAN1_Wake_Up = 99,
} ;

//------------------------------------------------------------------------------

inline void NVIC_ENABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E100 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------

inline void NVIC_DISABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E180 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------
// BITBAND
//------------------------------------------------------------------------------

inline void bitband32 (const volatile uint32_t & inRegister, const uint8_t inBit, const bool inValue) {
  const uint32_t address = ((uint32_t) &inRegister - 0x40000000) * 32 + ((uint32_t) inBit) * 4 + 0x42000000 ;
  volatile uint32_t * ptr = (volatile uint32_t *) address ;
  *ptr = (uint32_t) inValue ;
}

//------------------------------------------------------------------------------
