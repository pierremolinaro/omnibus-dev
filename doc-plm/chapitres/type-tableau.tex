%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Les types tableau}

PLM implémente les tableaux de taille fixe. La déclaration d'un type tableau utilise obligatoirement la construction \plm=type= (\refSectionPage{DecTypeTableau}), il n'est pas possible de déclarer un type tableau anonyme.








\sectionLabel{Déclaration d'un type tableau}{DecTypeTableau}

La déclaration d'un type tableau est réalisée par la construction \plm=newtype=~:

\begin{PLM}
newtype MonTypeTableau : UInt32 [20]
\end{PLM}

Cette construction déclare le type \plm=MonTypeTableau= comme tableau de $20$ instances de \plm=UInt32=.

Tout type est acceptable comme élément de tableau (ici \plm=UInt32=), du moment qu'il est instanciable et copiable. Essayer de définir un type tableau avec un type non instanciable et/ou non copiable entraîne une erreur de compilation.

La taille du tableau est une expression statique, de type entier. Il est donc possible de faire référence à des constantes globales, comme par exemple :

\begin{PLM}
let SIZE = 20
typealias MonTypeTableau = [SIZE @x UInt32]
\end{PLM}


\sectionLabel{Construction d'un tableau}{ConstructionTableau}

Un tableau statique implémente deux constructeurs~:
\begin{itemize}
  \item un constructeur qui initialise tous les éléments du tableau à la même valeur (\refSubsectionPage{constructeurTableauRepeated})~;
  \item un constructeur qui initialise chaque élément du tableau à une valeur particulière (\refSubsectionPage{constructeurTableauValeurParticuliere}).
\end{itemize}




\subsectionLabel{Constructeur \texttt{(!repeated)}}{constructeurTableauRepeated}
L'expression \plm=MonTypeTableau (!repeated:exp)= est une instance du type \plm=MonTypeTableau=, dont tous les éléments sont initialisés avec la valeur de \plm=exp=. Par exemple~:
\begin{PLM}
let v : UInt32 = 0
var t : UInt32 [10] = UInt32 [10] (!repeated:v)
\end{PLM}


\subsectionLabel{Constructeur \texttt{(!!...)}}{constructeurTableauValeurParticuliere}
Ce constructeur possède autant d'arguments que d'éléments dans le tableau. Le premier est affecté à l'élément d'indice 0, le deuxième à celui d'indice 1, ... Par exemple~:
\begin{PLM}
var t UInt32 [3] = UInt32 [3] (!0 !1 !2)
\end{PLM}



\sectionLabel{Déclaration d'une instance de tableau}{DecInstanceTableau}

La déclaration d'une instance de tableau s'effectue en nommant le type tableau et l'expression de construction de ce tableau, où \plm=v= est une valeur du type de l'élément de tableau (ici, \plm=UInt32=)~:

\begin{PLM}
let v UInt32 = 0
var t : MonTypeTableau = MonTypeTableau (!repeated:v)
\end{PLM}

Et on peut omettre l'annotation de type~:

\begin{PLM}
var t = MonTypeTableau (!repeated:v)
\end{PLM}




\sectionLabel{Obtention de la taille d'un tableau}{ObtentionTailleTableau}

L'expression \plm=MonTypeTableau.count= renvoie la taille du tableau, sous la forme d'un entier statique (c'est-à-dire de type \plm=LiteralInt=, voir \refChapterPage{chapitreTypeEntierStatique}). Ou peut aussi appliquer \plm=count= à une instance de tableau.

On peut donc utiliser les expressions \plm=$t.count= et \plm=$monTypeTableau.count= pour itérer sur tous les élements d'un tableau~:
\begin{PLM}
var t = MonTypeTableau (!repeated:0)
for i UInt32 in 0 ..< t.count {
  t [i] = i
}
for i UInt32 in 0 ..< MonTypeTableau.count {
  t [i] = i
}
\end{PLM}


Une erreur de compilation est déclenchée si on écrit~:
\begin{PLM}
var s = MonTypeTableau.count // ERREUR
\end{PLM}

En effet, \plm=MonTypeTableau.count= est un entier statique et le type \emph{entier statique} ne peut pas être attribué à une variable. Il faut préciser obligatoirement un type d'entier~:

\begin{PLM}
var s UInt32 = MonTypeTableau.count // Ok
\end{PLM}

Ce type peut être signé ou non signé, du moment que sa plage de valeur permet de représenter la valeur statique.






\sectionLabel{Accès à un élément d'un tableau}{AccesElementTableau}

L'accès à un élément d'un tableau s'effectue par la notation classique \plm=[expression_indice]=. Les indices valides commencent à $0$ jusqu'à la taille du tableau moins $1$.

L'accès à un élément de tableau est valide dans les constructions suivantes~:
\begin{itemize}
  \item expression~: \plm!var x = t [1]! ;
  \item cible d'une affectation~: \plm!t [1] = x! ;
  \item cible d'un opérateur combiné à une affectation~: \plm!t [1] += x! ;
\end{itemize}

L'\plm=expression_indice= doit être une expression entière, signée ou non signée.

\subsection{Expression indice statique}

Si l'\plm=expression_indice= est statique, c'est-à-dire dont la valeur est calculée à la compilation, la vérification de sa validité est effectuée à la compilation. Par exemple, pour un tableau \plm=t= de $20$ éléments~:
\begin{PLM}
t [0] // Ok
t [19] // Ok
t [-1] // Erreur de compilation, indice négatif
t [20] // Erreur de compilation, indice trop grand
\end{PLM}

Comme la validité est effectuée à la compilation, aucune vérification de validité n'est effectuée à l'exécution.


\subsectionLabel{Expression indice non signée}{indiceNonSigne}

Si l'\plm=expression_indice= est une instance d'un type entier non signé, il y a deux possibilités.

Soit ce type entier non signé présente une valeur maximum supérieure ou égale à la taille du tableau~: alors le code engendré vérifie à l'exécution que l'\plm=expression_indice= a une valeur valide. Dans l'exemple ci-dessous, le tableau \plm=t= contient $20$ éléments, l'\plm=expression_indice= doit donc être inférieure ou égale à $19$ ; or la plage de valeurs de \plm=UInt32= dépasse cette borne, aussi la validité est vérifiée à l'exécution. En cas d'échec, la panique est déclenchée (\refTableauPage{tableauCodePanique}).
\begin{PLM}
var i UInt32 = ...
var x = t [i] // Vérification à l'exécution que i < 20
\end{PLM}



La seconde possibilité est que ce type entier non signé présente une valeur maximum strictement inférieure à la taille du tableau~: la compilation garantit que l'indice sera toujours valide, aucune vérification n'est effectuée à l'exécution. Par exemple~:
\begin{PLM}
var i UInt4 = ... // Donc 0 ≤ i ≤ 15
var x = t [i] // Aucune vérification à l'exécution car toujours i < 20
\end{PLM}



\subsectionLabel{Expression indice signée}{indiceSigne}

Quand l'\plm=expression_indice= est une expression entière signée, il faut vérifier~:
\begin{itemize}
  \item qu'elle est positive ou nulle ;
  \item qu'elle est strictement inférieure à la taille du tableau.
\end{itemize}

La première vérification est toujours réalisée à l'exécution ; la seconde dépend de la valeur maximum du type entier, de manière analogue à ce qui est fait pour un indice entier non signé. Donc, pour un tableau \plm=t= de $20$ éléments~:

\begin{PLM}
var i Int32 = ...
var x = t [i] // Vérification à l'exécution que 0 ≤ i < 20
\end{PLM}


\begin{PLM}
var i Int4 = ... // Donc -16 ≤ i < 15
var x = t [i] // Vérification à l'exécution que 0 ≤ i
\end{PLM}

En cas d'échec de la vérification à l'exécution, la panique est déclenchée (\refTableauPage{tableauCodePanique}).

\subsection{Accès à un élément en mode panique}

Dans une liste d'instructions devant être exécutée en mode panique, les instructions pouvant engendrer une panique sont interdites et leur présence entraîne une erreur de compilation.

Ainsi l'accès à un élément de tableau est donc accepté par le compilateur si l'\plm=expression_indice= est~:
\begin{itemize}
\item une expression statique ;
\item ou une expression entière non signée, dont la valeur maximum est strictement inférieure à la taille du tableau.
\end{itemize}


Donc l'accès à un élément de tableau est donc rejeté par le compilateur si l'\plm=expression_indice= est~:
\begin{itemize}
\item une expression entière signée ;
\item ou une expression entière non signée, dont la valeur maximum est supérieure ou égale à la taille du tableau.
\end{itemize}


