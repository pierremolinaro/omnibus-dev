%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Les types structure}


\section{Déclaration d'un type structure}

La déclaration d'un type structure est introduite par le mot réservé \plm!struct! :

\begin{PLM}
struct $point {
  var x $int32 = 0
  var y $int32 = 0
}
\end{PLM}

Dans la version actuelle de PLM, tous les champs doivent être initialisés.

Déclarer un type structure définit implicitement un initialiseur sans argument, qu'il faut appeler lorsque l'on initialise une variable ou une constante. Par exemple :
\begin{PLM}
var pt $point = $point ()
\end{PLM}

Et l'annotation de type peut être omise :
\begin{PLM}
var pt = $point ()
\end{PLM}

Tout type acceptable pour un champ. Par exemple : 
\begin{PLM}
struct $point3D {
  var p $point = $point ()
  var z $int32 = 0
}
\end{PLM}







\section{Procédures}

Il existe deux sortes de procédure de structure :
\begin{itemize}
  \item les procédures constantes (\plm!proc!), \refSubsectionTitlePage{procConstStructure} ;
  \item les procédures mutables (\plm!mutating proc!), \refSubsectionTitlePage{procMutableStructure}.
\end{itemize}


\subsectionLabel{Procédure constante}{procConstStructure}

Un type structure peut définir des procédures grâce à la construction \plm!proc! :

\begin{PLM}
struct $point {
  var x $int32 = 0
  var y $int32 = 0
  
  proc `user getX (!outX $uint32) {
    outX = self.x
  }
}
\end{PLM}

Trois remarques :
\begin{itemize}
  \item une telle procédure ne peut pas modifier l'objet auquel il s'applique (pour le faire, il faut définir une \plm!mutating proc!) ;
  \item l'accès à une variable globale est possible si cette dernière déclare la procédure comme routine autorisée (\refSectionPage{DecRoutinesAutoriseesVarGlobale}) ; l'accès peut être en lecture (par défaut), ou en lecture / écriture (attribut \plm!@rw!) ;
  \item préfixer l'accès à un champ par \plm!self.! est obligatoire. 
\end{itemize}




\subsectionLabel{Procédure mutable}{procMutableStructure}

Si on veut modifier un champ, il faut déclarer la procédure de structure avec le qualificatif \plm!mutating! :

\begin{PLM}
struct $point {
  var x $int32 = 0
  var y $int32 = 0
  
  mutating proc `user setX (?inX $uint32) {
    self.x = inX
  }
}
\end{PLM}

L'accès à une variable globale est possible si cette dernière déclare la procédure comme routine autorisée (\refSectionPage{DecRoutinesAutoriseesVarGlobale}) ; l'accès peut être en lecture (par défaut), ou en lecture / écriture (attribut \plm!@rm!). Préfixer l'accès à un champ par \plm!self.! est obligatoire. 

Il est possible de modifier l'objet courant en affectant \plm!self! :

\begin{PLM}
struct $point {
  var x $int32 = 0
  var y $int32 = 0
  
  mutating proc reset `user () {
    self = $point ()
  }
}
\end{PLM}

Ou encore :

\begin{PLM}
struct $point {
  var x $int32 = 0
  var y $int32 = 0
  
  mutating proc reset `user () {
    newPoint (?self)
  }
}

proc `user newPoint (!p $point) {
  p = $point ()
}
\end{PLM}







\section{Fonctions}

Une fonction de structure est constante, c'est-à-dire qu'elle ne peut pas modifier l'objet sur lequel elle s'applique.

Dans la version actuelle, les variables globales sont aussi inaccessibles.

Voici un exemple de fonction de structure :

\begin{PLM}
struct $point {
  var x $int32 = 0
  var y $int32 = 0
  
  func `user getX (?x $int32) -> $int32 {
    result = self.x + x
  }
}
\end{PLM}

Comme pour les procédures de structures, l'usage de \plm!self! est obligatoire pour accéder aux champs. La variable \plm!result! est implicitement déclarée du type renvoyé par la fonction (ici \plm!$int32!).










\section{Extensions}

Pour tout type de structure, un nombre quelconque d'extensions peut être défini. Une extension déclare champs, procédures et fonctions.

Voici un exemple d'extension qui déclare un champ, une fonction et une procédure.

\begin{PLM}
extension $point {
  var z $int32 = 0
  
  func `user getZ () -> $int32 {
    result = self.z
  }
  
  mutating proc `user setZ (?z $int32) {
    self.z = z
  }
}
\end{PLM}






\section{Visibilité des champs et des méthodes}

Dans la version actuelle, les champs et les méthodes sont publiques.


