%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Configuration d'une cible}{chapitreConfCible}






\sectionLabel{Exemple de définition de cible}{exempleDefinitionCible}








\sectionLabel{Déclaration \texttt{newUnsignedRepresentation}}{DefNewUnsignedRepresentation}
\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=!Definition@Définition}

La déclaration \plm=newUnsignedRepresentation= permet de définir une représentation entière non signée. Sa syntaxe est la suivante :


\begin{PLM}
newUnsignedRepresentation @nom "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@nom= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers non signés habituels peut être définie par :
\begin{PLM}
newUnsignedRepresentation @unsigned8  "uint8_t"   8
newUnsignedRepresentation @unsigned16 "uint16_t" 16
newUnsignedRepresentation @unsigned32 "uint32_t" 32
newUnsignedRepresentation @unsigned64 "uint64_t" 64
\end{PLM}








\sectionLabel{Déclaration \texttt{newSignedRepresentation}}{DefNewSignedRepresentation}
\index{newSignedRepresentation@\plm=newSignedRepresentation=!Definition@Définition}

La déclaration \plm=newSignedRepresentation= permet de définir une représentation entière signée. Sa syntaxe est la suivante :


\begin{PLM}
newSignedRepresentation @representation "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@representation= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers signés habituels peut être définie par :
\begin{PLM}
newSignedRepresentation @signed8  "int8_t"   8
newSignedRepresentation @signed16 "int16_t" 16
newSignedRepresentation @signed32 "int32_t" 32
newSignedRepresentation @signed64 "int64_t" 64
\end{PLM}











\sectionLabel{Déclaration \texttt{newIntegerType}}{DefNewIntegerType}
\index{newIntegerType@\plm=newIntegerType=!Definition@Définition}

La déclaration \plm=newIntegerType= permet de définir un nouveau type entier signé ou non signé. Elle a la syntaxe suivante :
\begin{PLM}
newIntegerType NomDeType @representation
\end{PLM}
Où :
\begin{itemize}
  \item \plm=NomDeType= est le nom donné au type entier.
  \item \plm=@representation= est le nom de la représentation, qui doit avoir été défini soit par une déclaration \plm=newUnsignedRepresentation= (\refSectionPage{DefNewUnsignedRepresentation})\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=}, soit par une déclaration \plm=newSignedRepresentation= (\refSectionPage{DefNewSignedRepresentation}\index{newSignedRepresentation@\plm=newSignedRepresentation=}).
\end{itemize}

Le type entier ainsi déclaré est non signé si la représentation est non signée (c'est-à-dire déclarée avec \plm=newUnsignedRepresentation=), et signé si la représentation est signée (c'est-à-dire déclarée avec \plm=newSignedRepresentation=). Les types usuels peuvent ainsi être déclarés :
\begin{PLM}
newIntegerType UInt8  @unsigned8
newIntegerType UInt16 @unsigned16
newIntegerType UInt32 @unsigned32
newIntegerType UInt64 @unsigned64
newIntegerType Int8  @signed8
newIntegerType Int16 @signed16
newIntegerType Int32 @signed32
newIntegerType Int64 @signed64
\end{PLM}





\sectionLabel{\texttt{boot} routines}{bootRoutine}
\index{boot@\plm=boot=!Routine}
\index{Routine!boot@\plm=boot=}

Une routine \plm=boot= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, avant que les variables globales ne soient initialisées. Elle a la syntaxe suivante :
\begin{PLM}
boot priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=boot= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=boot= n'ont pas la même priorité.

Les routines \plm=boot= s'exécutent dans le mode \plm=$boot=.\index{\$boot}

Comme les routines \plm=boot= s'exécutent avant que les variables globales soient initialisées, l'accès aux variables globales y est interdit. L'interdiction est mise en place de la façon suivante : il n'est pas possible d'associer le mode \plm=$boot= à une variable globale lors de sa déclaration (\refSectionPage{declarationVariableGlobale}).

Par contre, l'accès aux registres de contrôle est autorisé dans une routine \plm=boot= (d'ailleurs, elle sert à cela : configurer le micro-contrôleur au démarrage).







\sectionLabel{\texttt{init} routines}{initRoutine}
\index{init@\plm=init=!Routine}
\index{Routine!init@\plm=init=}

Une routine \plm=init= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, après l'initialisation des variables globales. Elle a la syntaxe suivante :
\begin{PLM}
init priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=init= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=init= n'ont pas la même priorité.

Les routines \plm=init= s'exécutent dans le mode \plm=$init=.\index{\$init}

Comme les routines \plm=init= s'exécutent après l'initialisation des variables globales, l'accès aux variables globales y est autorisé, du moment que la variable globale cite le mode \plm=$init= dans sa déclaration (\refSectionPage{declarationVariableGlobale}).


\sectionLabel{Séquence de démarrage du micro-contrôleur}{demarrageMicro}

\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=5mm
    ]
    \node [cloud] (start) {\textsc{Démarrage}} ;
    \node [block] (boot) [below=of start] {Routines \bf\texttt{boot}} ;
    \node [block] (raz) [below=of boot] {Initialisation des variables globales} ;
    \node [block] (init) [below=of raz] {Routines \bf\texttt{init}} ;
    \node [block] (setup) [below=of init] {Procédure \texttt{setup}} ;
    \node [block] (loop) [below=of setup] {Procédure \texttt{loop}} ;

    \draw [-stealth, thick] (start) -- (boot) ;
    \draw [-stealth, thick] (boot) -- (raz) ;
    \draw [-stealth, thick] (raz) -- (init) ;
    \draw [-stealth, thick] (init) -- (setup) ;
    \draw [-stealth, thick] (setup) -- (loop) ;
    \draw [-stealth, thick] (loop.south) -- +(0, -.25) -- +(1.7, -.25) -- +(1.7, 0.8)-- +(0, 0.8) ;
  \end{tikzpicture}
  \caption{Organigramme de la séquence de démarrage}
  \labelFigure{sequenceDemarrage}
  \ligne
\end{figure}


