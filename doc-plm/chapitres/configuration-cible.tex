%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Définition d'une cible}{chapitreConfCible}

Dans ce chapitre, nous allons voir comment est définie une cible, en prenant pour exemple la cible \texttt{teensy-3-1/unprivileged}. 

Si vous voulez définir votre propre cible, la lecture de ce chapitre est indispensable. 

Le compilateur recherche la cible citée~:
\begin{itemize}
  \item par défaut, parmi les fichiers embarqués dans le compilateur PLM~;
  \item si l'option \OPTION{-T=$repertoire$} (voir \refSectionPage{optionsCiblesEmbarquees}) est présente dans la ligne de commande, dans les fichiers du répertoire $cibles$.
\end{itemize}

Pour explorer les fichiers indispensables à la définition d'une cible, il est nécessaire de les placer dans le système de fichiers. La première section de ce chapitre (\refSectionPage{cibleDansSystemeFichiers}) va donc indiquer comment extraire de l'exécutable les fichiers de définition des cibles, et comment les exploiter.

%\minitoc

\sectionLabel{Utilisation d'une cible dans le système de fichiers}{cibleDansSystemeFichiers}

Une cible est définie par une arborescence de fichiers, soit embarquée dans le compilateur, soit située dans le système de fichiers. On va voir dans cette section comment est configurée une cible dans le système de fichiers, permettant ainsi de créer ses propres cibles. Pour cela, on commence par extraire de l'exécutable du compilateur les cibles qu'il embarque.

\subsection{Liste des cibles embarquées}
À titre d'information, on peut appeler l'option \OPTION{-L} pour obtenir la liste des cibles embarquées~:
\begin{SHELL}
{\bfseries plm -L}\\
Embedded targets:\\ 
\hspace*{1.2em}LPC-2294\\
\hspace*{1.2em}teensy-3-1/privileged\\
\hspace*{1.2em}teensy-3-1/unprivileged\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction des cibles embarquées}
L'option \OPTION{-X=cibles} permet d'extraire de l'exécutable du compilateur tous les fichiers de définition des cibles et de les placer dans le répertoire \texttt{cibles}\footnote{Ici, le répertoire destination \texttt{cibles} est un répertoire relatif au répertoire courant, mais un répertoire absolu peut aussi être utilisé.}~:
\begin{SHELL}
{\bfseries plm -X=cibles}\\
\hspace*{1.2em}...
\end{SHELL}





\subsection{Liste des fichiers d'exemple embarqués dans l'exécutable}
L'option \OPTION{-l} permet d'afficher la liste de tous les fichiers d'exemple embarqués dans l'exécutable du compilateur ~:
\begin{SHELL}
{\bfseries plm -l}\\
\hspace*{1.2em}LPC-L2294/01-blinkleds.plm\\
\hspace*{1.2em}LPC-L2294/02-control-register-array.plm\\
\hspace*{1.2em}teensy-3-1/00-structure-example.plm\\
\hspace*{1.2em}teensy-3-1/01-blink-led.plm\\
\hspace*{1.2em}...
\end{SHELL}




\subsection{Extraction d'un fichier d'exemple}
On extrait maintenant un fichier d'exemple \texttt{teensy-3-1/01-blink-led.plm}~:
\begin{SHELL}
\bfseries plm -x=teensy-3-1/01-blink-led.plm
\end{SHELL}

Le fichier extrait est recopié dans le répertoire courant.






\subsection{Compilation du fichier exemple}
Par défaut, le compilateur utilise les cibles qu'il embarque :
\begin{SHELL}
\bfseries plm 01-blink-led.plm
\end{SHELL}

Si on veut utiliser les cibles définies dans le répertoire $cibles$, on utilise l'option \OPTION{-T}~:
\begin{SHELL}
\bfseries plm -T=cibles 01-blink-led.plm
\end{SHELL}


\subsection{Changement du nom de la cible dans le système de fichiers}

Pour se convaincre que la cible nommée dans le fichier est bien celle située dans le répertoire $cibles$, nous allons changer son nom. Pour cela, nous devons modifier~:
\begin{itemize}
  \item la référence à la cible dans le fichier \texttt{01-blink-led.plm}~;
  \item le nom d'un fichier et d'un répertoire dans le répertoire \texttt{cibles}. 
\end{itemize}

Commençons par le fichier \texttt{01-blink-led.plm}. Sa première ligne est~:

\begin{PLM}
target "teensy-3-1/unprivileged"
\end{PLM}

Cette ligne signifie que la cible s'appelle \texttt{teensy-3-1/unprivileged}. Nous allons la renommer en \texttt{teensy-3-1/custom}. La première ligne du fichier \texttt{01-blink-led.plm} devient donc~:

\begin{PLM}
target "teensy-3-1/custom"
\end{PLM}

Maintenant, si on essaie de compiler le fichier \texttt{01-blink-led.plm}, une erreur se déclenche~: la cible \texttt{teensy-3-1/custom} n'est pas définie.
\begin{SHELL}
{\bfseries plm -T=cibles 01-blink-led.plm}\\
\textcolor{red}{semantic error \#1: This target is not defined in 'cibles' directory}\\
\textcolor{red}{target "teensy-3-1/custom"}\\
\textcolor{red}{-{}-{}-{}-{}-{}-{}-\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}}
\end{SHELL}


Pour définir la cible, il faut d'abord comprendre comment le répertoire \texttt{cibles} est organisé. Affichons la liste de ses sous répertoires~:
\begin{SHELL}
{\bfseries find cibles -type d}\\
cibles\\
cibles/LPC-L2294\\
cibles/teensy-3-1\\
cibles/teensy-3-1/privileged\\
cibles/teensy-3-1/unprivileged
\end{SHELL}

Chaque sous répertoire peut définir une cible\footnote{Pour cela, il doit en fait contenir un fichier \texttt{+config.plm-target}.}. Il suffit donc de dupliquer le répertoire \texttt{teensy-3-1/unprivileged} en le renommant \texttt{teensy-3-1/custom}~:
\begin{SHELL}
{\bfseries find cibles -type d}\\
cibles\\
cibles/LPC-L2294\\
cibles/teensy-3-1\\
cibles/teensy-3-1/custom\\
cibles/teensy-3-1/privileged\\
cibles/teensy-3-1/unprivileged
\end{SHELL}

Maintenant, la compilation s'effectue avec succès~:
\begin{SHELL}
{\bfseries plm -T=cibles 01-blink-led.plm}
\end{SHELL}

Si on essaie de compiler en utilisant les cibles embarquées dans le compilateur~:
\begin{SHELL}
{\bfseries plm 01-blink-led.plm}\\
\textcolor{red}{semantic error \#1: This target is not defined in embedded targets}\\
\textcolor{red}{target "teensy-3-1/custom"}\\
\textcolor{red}{-{}-{}-{}-{}-{}-{}-\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}}
\end{SHELL}

Une erreur se déclenche, la cible \texttt{teensy-3-1/custom} n'étant pas définie dans l'exécutable du compilateur.






\sectionLabel{Définition d'une cible : fichier \texttt{+config.plm-target}}{exempleDefinitionCible}

Nous allons décrire comment est définie une cible dans le système de fichiers. Nous prenons comme exemple la cible \texttt{teensy-3-1/custom} du répertoire \texttt{cibles} (voir la \refSectionPage{cibleDansSystemeFichiers}).

Un répertoire définit une cible si il contient un fichier nommé \texttt{+config.plm-target}. Le contenu de ce fichier configure la cible, en voici le début~:

\begin{PLM}
//--- Python tool list
PYTHON_UTILITIES:
   "../../py-toolpath.txt" -> "sources/toolpath.py",
   "../../py-makefile.txt" -> "sources/makefile.py",
   ...
\end{PLM}


Le contenu est une séquence de définitions, chacune d'elles ayant la syntaxe suivante~:
\begin{itemize}
  \item son nom (dans l'exemple ci-dessus, \plm=PYTHON_UTILITIES=)~;
  \item le délimiteur \plm=:=~;
  \item une liste d'items séparés par un virgule, ce qui signifie qu'un nombre quelconque d'items est accepté~;
  \item {\bf ou} une liste d'items séparés par un point-virgule, ce qui signifie qu'un nombre fixe d'items est accepté, et que chacun d'eux a une signification particulière~;
  \item {\bf ou} un simple item~;
  \item quand un item désigne un fichier par un chemin relatif, celui-ci est pris à partir du répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.
\end{itemize}

L'ordre des séquences est imposée.

Les sections qui suivent détaillent chaque définition, dans leur ordre d'apparition dans le fichier \texttt{+config.plm-target}.










\subsectionLabel{\texttt{PYTHON\_UTILITIES}}{configurationPythonUtilities}\index{PYTHON\_UTILITIES}

\begin{PLM}
PYTHON_UTILITIES:
   "../../py-toolpath.txt" -> "sources/toolpath.py",
   "../../py-makefile.txt" -> "sources/makefile.py",
   "../../py-check-stacks.txt" -> "sources/check-stacks.py",
   "../../py-plm.txt" -> "sources/plm.py",
   "../../py-build-verbose.txt" -> "build-verbose.py",
   "../../py-clean.txt" -> "clean.py",
   "../../py-objdump.txt" -> "objdump.py",
   "../../py-objsize.txt" -> "objsize.py",
   "../py-run.txt" -> "run.py"
\end{PLM}

Cette déclaration liste une liste de fichiers à recopier dans le répertoire engendré pour chaque projet :
\begin{itemize}
  \item le fichier source (par exemple \texttt{../../py-toolpath.txt}) est désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}~;
  \item le fichier destination (par exemple \texttt{sources/toolpath.py}) est désigné par un chemin relatif par rapport au répertoire du projet~;
  \item le fichier destination est rendu exécutable.
\end{itemize}





\subsectionLabel{\texttt{PYTHON\_BUILD}}{configurationPythonBuild}\index{PYTHON\_BUILD}

\begin{PLM}
PYTHON_BUILD:
   "../py-build.txt"
\end{PLM}

Le fichier source (ici \texttt{../py-build.txt}) est désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source~:
\begin{itemize}
  \item \texttt{<<OPT\_OPTIMIZATION\_OPTION>>} est remplacé par l'option d'optimisation choisie (\texttt{O0}, \texttt{O1}, \texttt{O2}, \texttt{O3}, \texttt{Os} ou \texttt{Oz})~;
  \item \texttt{<<LLC\_OPTIMIZATION\_OPTION>>} est remplacé par l'option d'optimisation correspondante pour l'utilitaire \texttt{llc} (\texttt{O0}, \texttt{O1}, \texttt{O2} ou \texttt{O3}).
\end{itemize}


La chaîne résultat est copiée dans le fichier \texttt{build.py} situé dans le répertoire du projet. Ce fichier est rendu exécutable.









\subsectionLabel{\texttt{LINKER\_SCRIPT}}{configurationLinkerScript}\index{LINKER\_SCRIPT}

\begin{PLM}
LINKER_SCRIPT:
  "../ld-linker.txt"
\end{PLM}

Le fichier source (ici \texttt{../ld-linker.txt}) est désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Une substitution est effectuée dans la chaîne obtenue par la lecture du fichier source~:
\begin{itemize}
  \item \texttt{!SYSTEMSTACKSIZE!} est remplacé par la taille allouée (en nombre d'octets) à la pile système~; cette valeur est fixée par la définition \texttt{SYSTEM\_STACK\_SIZE}, voir \refSubsectionPage{configurationSystemStackSize}.
\end{itemize}

La chaîne résultat est copiée dans le fichier \texttt{sources/linker.ld} situé dans le répertoire du projet.











\subsectionLabel{\texttt{PANIC}}{configurationPanic}\index{PANIC}

\begin{PLM}
PANIC:
  $int32 ; $uint32 ; "../target-panic.ll"
\end{PLM}

Trois arguments (séparés par un point-virgule) sont définis ici~:
\begin{itemize}
  \item le premier (ici \plm=$int32=) est le type PLM utilisé pour le code de panique~;
  \item le deuxième (ici \plm=$uint32=) est le type PLM utilisé pour coder le numéro de la ligne source du fichier contenant l'instruction qui peut engendrer une panique~;
  \item le dernier (ici \plm="../target-panic.ll"=) désigne un fichier source LLVM par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.
\end{itemize}

Deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{../target-panic.ll}~:
\begin{itemize}
  \item \texttt{!PANICCODE!} est remplacé par le type LLVM correspondant type PLM utilisé pour le code de panique (donc, ici \texttt{i32} qui est le type LLVM image de \plm=$int32=)~;
  \item \texttt{!PANICLINE!} est remplacé par le type PLM utilisé pour coder le numéro de la ligne source  (donc, ici \texttt{i32} qui est aussi le type LLVM image de \plm=$uint32=).
\end{itemize}


La chaîne résultat est ensuite ajoutée au fichier source LLVM \texttt{src.ll} du projet.







\subsectionLabel{\texttt{POINTER\_BIT\_COUNT}}{configurationPointerBitCount}\index{POINTER\_BIT\_COUNT}

\begin{PLM}
POINTER_BIT_COUNT:
  32
\end{PLM}

Le nombre de bits d'un pointeur. Le Cortex-M4 étant une machine 32 bits, sa valeur est 32.












\subsectionLabel{\texttt{SYSTEM\_STACK\_SIZE}}{configurationSystemStackSize}\index{SYSTEM\_STACK\_SIZE}

\begin{PLM}
SYSTEM_STACK_SIZE:
  1024
\end{PLM}

La taille en octets allouée à la pile système.







\subsectionLabel{\texttt{SERVICE}}{configurationService}\index{SERVICE}

\begin{PLM}
SERVICE:
  "service-handler.s" ;
  12 ; // as_svc_handler saves 3 registers on system stack
  "service-dispatcher-header.s" ;
  "service-dispatcher-entry.s" ;
  "service-entry.s"
\end{PLM}

Le premier argument (ici \plm="service-handler.s"=) est un fichier assembleur désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Son contenu est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ce fichier contient l'implémentation du \emph{svc handler}.

Le deuxième argument (ici \plm=12=) est le nombre d'octets de la pile système que l'exécution du \emph{svc handler} utilise.

Les troisième et quatrième arguments (ici les chaînes \plm="service-dispatcher-header.s"= et \plm="service-dispatcher-entry.s"=) désignent des fichiers assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ces deux fichiers permettent de construire la table des appels système. D'abord, le contenu du fichier \plm="service-dispatcher-header.s"= est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ensuite, l'opération suivante est effectuée pour chaque service défini dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{service-dispatcher-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine réalisant l'implémentation du service~;
    \item \texttt{!IDX!} est remplacé par l'indice du service (PLM numérote les services, à partir de $0$)~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}

Le dernier argument (ici \plm="service-entry.s"=) permet de construire la routine appelée par les tâches. Il désigne un fichier assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ensuite, l'opération suivante est effectuée pour chaque service défini dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{service-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine appelée par les tâches~;
    \item \texttt{!IDX!} est remplacé par l'indice du service~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}











\subsectionLabel{\texttt{SECTION}}{configurationSection}\index{SECTION}

Il y a deux possibilités -- selon les cibles -- pour paramétrer l'implémentation des sections~:
\begin{itemize}
  \item par un appel système (\refSubsubsection{configurationSectionAppelSysteme})~;
  \item par un masquage temporaire des interruptions (\refSubsubsectionPage{configurationSectionMasquageInterruption}).
\end{itemize}

\subsubsectionLabel{Implémentation via un appel système}{configurationSectionAppelSysteme}

\begin{PLM}
SECTION:
  "udfcoded-section-handler.s" ;
  8 ; // saves 2 registers on system stack
  "udfcoded-section-dispatcher-header.s" ;
  "udfcoded-section-dispatcher-entry.s" ;
  "udfcoded-section-invocation.s"
\end{PLM}

L'implémentation des sections via des appels système est détaillée à la \refSectionPage{schemaAppelSectionsViaSystemCall}.

Le premier argument (ici \plm="udfcoded-section-handler.s"=) est un fichier assembleur désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Son contenu est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ce fichier contient l'implémentation du \emph{handler} associé.

Le deuxième argument (ici \plm=8=) est le nombre d'octets de la pile système que l'exécution du \emph{handler} utilise.

Les troisième et quatrième arguments (ici les chaînes \plm="udfcoded-dispatcher-header.s"= et \plm="service-dispatcher-entry.s"=) désignent des fichiers assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ces deux fichiers permettent de construire la table des appels système. D'abord, le contenu du fichier \plm="udfcoded-dispatcher-header.s"= est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ensuite, l'opération suivante est effectuée pour chaque section définie dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{udfcoded-dispatcher-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine réalisant l'implémentation de la section~;
    \item \texttt{!IDX!} est remplacé par l'indice de la section (PLM numérote les sections, à partir de $0$)~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}

Le dernier argument (ici \plm="udfcoded-entry.s"=) permet de construire la routine appelée par les tâches. Il désigne un fichier assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ensuite, l'opération suivante est effectuée pour chaque section définie dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{udfcoded-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine appelée par les tâches~;
    \item \texttt{!IDX!} est remplacé par l'indice de la section~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}



\subsubsectionLabel{Implémentation via un masquage temporaire des interruptions}{configurationSectionMasquageInterruption}

\begin{PLM}
SECTION:
"call void asm sideeffect \"cpsid i\", \"\"() nounwind";// Disable interrupt
"call void asm sideeffect \"cpsie i\", \"\"() nounwind" // Enable interrupt
\end{PLM}

Cette implémentation exige que les tâches puissent masquer les interruptions, ce qui impose qu'elles s'exécutent en mode privilégié. C'est par exemple le cas de la cible \texttt{teensy-3-1/privileged}.

Dans ce cas, l'implémentation est complètement réalisée en LLVM, sans avoir besoin de fichier assembleur. Il faut simplement fournir les instructions LLVM de \emph{masquage} et \emph{démasquage} des interruptions. C'est le rôle des deux arguments. Ils expriment les instructions LLVM qui embarquent les instructions assembleur correspondantes.




\subsectionLabel{\texttt{C\_FILES}}{configurationFichiersC}\index{C\_FILES}

\begin{PLM}
C_FILES:
  "../c-cortex-m4-context.c",
  "../../c-real-time-kernel.c",
  "../c-countTrainingZeros.c"
\end{PLM}








\subsectionLabel{\texttt{S\_FILES}}{configurationFichiersAssembleur}\index{S\_FILES}

\begin{PLM}
S_FILES:
  "../s-cortex-m4-header.s",
  "../s-endloop-for-unhandled-interrupt.s",
  "s-interrupt-vectors.s",
  "s-reset-handler.s"
\end{PLM}








\subsectionLabel{\texttt{LL\_FILES}}{configurationFichiersLLVM}\index{LL\_FILES}

\begin{PLM}
LL_FILES:
  "../ll-cortex-m4.ll",
  "../../ll-clear-bss.ll",
  "../../ll-copy-data-section.ll",
  "../../ll-configuration-on-boot.ll",
  "../../ll-create-task.ll"
\end{PLM}








\subsectionLabel{\texttt{PLM\_FILES}}{configurationFichiersPLM}\index{PLM\_FILES}

\begin{PLM}
PLM_FILES:
  "../plm-registers-mk20dx256.plm",
  "../plm-teensy-3-1-boot.plm",
  "../plm-teensy-3-1-xtr.plm",
  "../plm-teensy-3-1-digital-io.plm",
  "../plm-teensy-3-1-lcd.plm",
  "../plm-teensy-3-1-panic.plm",
  "../../plm-semaphore.plm"
\end{PLM}








\subsectionLabel{\texttt{INTERRUPT\_HANDLER}}{configurationInterruptHandler}\index{INTERRUPT\_HANDLER}

\begin{PLM}
INTERRUPT_HANDLER:
  "../xtr-interrupt-handler.s" ;
  "../undefined-interrupt.s" ;
  32 // Cortex M4 saves 8 regs in user stack on interrupt
\end{PLM}








\subsectionLabel{\texttt{INTERRUPTS}}{configurationInterrupts}\index{INTERRUPTS}

\begin{PLM}
INTERRUPTS:
  NMI -> 2,
  MemManage -> 4,
  BusFault -> 5,
  UsageFault -> 6,
  DebugMonitor -> 12,
  PendSV -> 14,
  systick -> 15,
  DMAChannel0TranfertComplete -> 16,
  DMAChannel1TranfertComplete -> 17,
  ...
  pinDetectPortD -> 106,
  pinDetectPortE -> 107,
  softwareInterrupt -> 110
\end{PLM}








{\bf Interruption vectors.} La liste de toutes les interruptions, chacune d'elle étant accompagnée de son numéro. Celui-ci est utilisé lors de la panique, si une interruption se déclenche alors qu'aucune routine de réponse à cette interruption n'est installée.






\sectionLabel{Schéma d'appel des sections}{schemaAppelSectionsViaSystemCall}

Quand le code d'une tâche appelle une section, celui-ci doit s'effectuer à travers un \emph{system call}\footnote{Quand une section est appelée à partir d'un mode privilégié, l'appel est un simple appel de routine.}.

L'implémentation de cette opération est paramètrable grâce à quatre fichiers assembleurs, placés dans le répertoire \texttt{teensy-3-1/custom}. Le nom de ces fichiers est préfixé par la chaîne spécifiée dans le champ \emph{Section invocation scheme} de la \plm=configuration= (voir \refSubsectionPage{configurationSection}), ce qui autorise de disposer de plusieurs implémentations possibles. Pour le schéma nommé \plm="udfcoded"=, ces quatre fichiers sont~:
\begin{itemize}
  \item \texttt{udfcoded-section-dispatcher-code.s}~: implémentation du code exécuté par l'appel système invoqué par l'appel à une section~;
  \item \texttt{udfcoded-section-dispatcher-entry.s}~: entrée du tableau définissant le nom de la fonction implémentant la section~;
  \item \texttt{udfcoded-section-dispatcher-header.s}~: en-tête du tableau contenant les noms de la fonction implémentant la section~;
  \item \texttt{udfcoded-section-invocation.s}~: implémentation de l'appel à une section. 
\end{itemize}

Trois schémas sont proposés, \plm="udfcoded"=, \plm="r12idx"= et \plm="r12direct"=, et sont décrits dans les sections suivantes. Le \refTableauPage{dureeSchemasServices} résume les caractéristiques de chacun. Les durées sont estimées grâce au projet \texttt{04-section-service-duration.plm}. 

\begin{table}[t]
\centering
\begin{tabular}{llll}
  \textbf{Nom du schéma} & \textbf{Par entrée} & \textbf{\texttt{as\_section\_handler}} & \textbf{Durée estimée} \\
   & (octets) & (octets) & (en cycles d'horloge) \\
  \plm="udfcoded"= & 4 + 4 & 40 & 64 \\
  \plm="r12idx"= & 8 + 4 & 36 & 65 \\
  \plm="r12direct"= & 12 + 0 & 24 & 61 \\
\end{tabular}
\caption{Caractéristiques de différents schémas d'appel de section}
\labelTableau{dureeSchemasServices}
\ligne
\end{table}


\subsubsection{Schéma \texttt{udfcoded} d'appel des sections}

Dans ce schéma, l'instruction indéfinie \texttt{UDF} est utilisée. Le code de cette instruction est \texttt{0xDE$xx$}, où $xx$ est une valeur que le Cortex ignore. On utilise ce champ pour coder l'indice du service appelé.

Pour coder l'appel relatif à une section, PLM va utiliser le fichier \texttt{udfcoded-section-invocation.s}. Le contenu de fichier est~:
\begin{SHELL}\small
\hspace*{1.2em}.section  ".text.!USER\_ROUTINE!","ax",\%progbits\\
\hspace*{1.2em}.global !USER\_ROUTINE!\\
\hspace*{1.2em}.type  !USER\_ROUTINE!,\%function\\
\hspace*{1.2em}.align  1\\
\hspace*{1.2em}.code  16\\
\hspace*{1.2em}.thumb\_func\\
\\
!USER\_ROUTINE!:\\
\hspace*{1.2em}.fnstart\\
\hspace*{1.2em}udf !IDX!\\
\hspace*{1.2em}bx  lr\\
\\
.Lfunc\_end\_!USER\_ROUTINE!:\\
\hspace*{1.2em}.size  !USER\_ROUTINE!, .Lfunc\_end\_!USER\_ROUTINE! - !USER\_ROUTINE!\\
\hspace*{1.2em}.cantunwind\\
\hspace*{1.2em}.fnend
\end{SHELL}

Trois séquences sont remplacées par le compilateur PLM~:
\begin{itemize}
\item \nospace{!USER\_ROUTINE!}, par le nom assembleur de la fonction qui implémente l'appel de la section en mode utilisateur~;
\item \nospace{!IMPLEMENTATION\_ROUTINE!}, par le nom assembleur de la fonction qui implémente la section (inutilisée dans ce shéma)~;
\item \nospace{!IDX!}, par l'indice de la section\footnote{Lorsqu'il analyse un projet, PLM numérote les sections qu'il rencontre (à partir de $0$). C'est ce numéro qui remplace la séquence \nospace{!IDX!}.}.
\end{itemize}

PLM effectue donc cette opération pour chaque section, par ordre croissant de l'indice, et accumule le texte produit dans le fichier assembleur \texttt{src.s}.

Donc, quand une instruction \texttt{UDF} est rencontrée, le Cortex exécute l'exception n°3, qui renvoie vers \texttt{as\_section\_handler}, défini par le fichier \texttt{udfcoded-section-dispatcher-code.s}~:

\begin{SHELL}\small
\hspace*{1.2em}.section	".text.as\_section\_handler","ax",\%progbits\\
\hspace*{1.2em}.global as\_section\_handler\\
\hspace*{1.2em}.type as\_section\_handler, \%function\\
\\
as\_section\_handler:\\
@--------------------- Save preserved registers\\
\hspace*{1.2em}push  {r5, lr}\\
@--------------------- R5 <- thread SP\\
\hspace*{1.2em}mrs   r5, psp           @ r5 <- thread SP\\
@--------------------- LR <- Address of UDF instruction\\
\hspace*{1.2em}ldr   lr, [r5, \#24]     @ 24 : 6 stacked registers before saved PC\\
@--------------------- Set return address to instruction following UDF\\
\hspace*{1.2em}adds  lr, \#2\\
\hspace*{1.2em}str   lr, [r5, \#24]\\
@--------------------- R12 <- address of dispatcher\\
\hspace*{1.2em}ldr   r12, =\_\_udf\_dispatcher\_table\\
@--------------------- LR <- bits 0-7 of UDF instruction\\
\hspace*{1.2em}ldrb  lr, [lr, \#-2]            @ LR is service call index\\
@--------------------- r12 <- address of routine to call\\
\hspace*{1.2em}ldr   r12, [r12, lr, lsl \#2]   @ Address R12 + LR << 2\\
@--------------------- Call service routine\\
\hspace*{1.2em}blx   r12                      @ R5: thread PSP\\
@--------------------- Set return code (from R0 to R3) in stacked registers\\
\hspace*{1.2em}stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\\
@--------------------- Restore preserved registers, return from interrupt\\
\hspace*{1.2em}pop   {r5, pc}
\end{SHELL}

Ce code va rechercher dans l'instruction \texttt{UDF} la valeur $xx$ de l'octet de poids faible, et l'utilise pour construire l'adresse d'une entrée du tableau \texttt{\_\_udf\_dispatcher\_table}. Cette entrée contient l'adresse de la routine à exécuter.

Remarquer ce code empile deux registres (soit 8 octets) dans la pile système~; il faut s'assurer que cette valeur correspond à la valeur du paramètre \emph{Section handler system stack byte count footprint} déclaré dans la \plm=configuration=.

Remarquer aussi que lorsque l'instruction \texttt{UDF} est exécutée, l'adresse de retour empilée est l'adresse de l'instruction \texttt{UDF}, et non pas l'adresse de l'instruction suivante. Il faut donc manuellement ajouter $2$ à l'adresse de retour.

Il faut donc construire ce tableau. Le fichier \texttt{udfcoded-section-dispatcher-header.s} définit son en-tête~:

\begin{SHELL}\small
\_\_udf\_dispatcher\_table:
\end{SHELL}

Ce texte est ajouté à la fin du fichier assembleur \texttt{src.s}.

Ensuite, PLM va utiliser le fichier \texttt{udfcoded-section-dispatcher-entry.s} pour définir chaque entrée du tableau~:
\begin{SHELL}\small
\hspace*{1.2em}.word !IMPLEMENTATION\_ROUTINE! @ !IDX!, user routine !USER\_ROUTINE!

\end{SHELL}

PLM effectue pour chaque section les substitutions de \nospace{!IMPLEMENTATION\_ROUTINE!}, de \nospace{!USER\_ROUTINE!} et de \nospace{!IDX!}, par ordre croissant de l'indice, en ajoutant le texte produit à la fin du fichier assembleur \texttt{src.s}.










\subsubsection{Schéma \texttt{r12idx} d'appel des sections}

Dans ce schéma, l'instruction indéfinie \texttt{UDF} est utilisée.  Le code de cette instruction est \texttt{0xDE$xx$}, où $xx$ est une valeur que le Cortex ignore. Contrairement au shéma précédent, le champ $xx$ est toujours à $0$, l'indice de la section est entré dans le registre \texttt{r12}.

Pour coder l'appel relatif à une section, PLM va utiliser le fichier \texttt{r12idx-section-invocation.s}. Le contenu de fichier est~:
\begin{SHELL}\small
\hspace*{1.2em}.section  ".text.!USER\_ROUTINE!","ax",\%progbits\\
\hspace*{1.2em}.global !USER\_ROUTINE!\\
\hspace*{1.2em}.type  !USER\_ROUTINE!,\%function\\
\hspace*{1.2em}.align  1\\
\hspace*{1.2em}.code  16\\
\hspace*{1.2em}.thumb\_func\\
\\
!USER\_ROUTINE!:\\
\hspace*{1.2em}.fnstart\\
\hspace*{1.2em}mov r12, !IDX!\\
\hspace*{1.2em}udf 0\\
\hspace*{1.2em}bx  lr\\
\\
.Lfunc\_end\_!USER\_ROUTINE!:\\
\hspace*{1.2em}.size  !USER\_ROUTINE!, .Lfunc\_end\_!USER\_ROUTINE! - !USER\_ROUTINE!\\
\hspace*{1.2em}.cantunwind\\
\hspace*{1.2em}.fnend
\end{SHELL}

Trois séquences sont remplacées par le compilateur PLM~:
\begin{itemize}
\item \nospace{!USER\_ROUTINE!}, par le nom assembleur de la fonction qui implémente l'appel de la section en mode utilisateur~;
\item \nospace{!IMPLEMENTATION\_ROUTINE!}, par le nom assembleur de la fonction qui implémente la section (inutilisée dans ce shéma)~;
\item \nospace{!IDX!}, par l'indice de la section\footnote{Lorsqu'il analyse un projet, PLM numérote les sections qu'il rencontre (à partir de $0$). C'est ce numéro qui remplace la séquence \nospace{!IDX!}.}.
\end{itemize}

PLM effectue donc cette opération pour chaque section, par ordre croissant de l'indice, et accumule le texte produit dans le fichier assembleur \texttt{src.s}.

Donc, quand une instruction \texttt{UDF} est rencontrée, le Cortex exécute l'exception n°3, qui renvoie vers \texttt{as\_section\_handler}, défini par le fichier \texttt{r12idx-section-dispatcher-code.s}~:

\begin{SHELL}\small
\hspace*{1.2em}.section	".text.as\_section\_handler","ax",\%progbits\\
\hspace*{1.2em}.global as\_section\_handler\\
\hspace*{1.2em}.type as\_section\_handler, \%function\\
\\
as\_section\_handler:\\
@--------------------- Save preserved registers\\
\hspace*{1.2em}push  {r5, lr}\\
@--------------------- R5 <- thread SP\\
\hspace*{1.2em}mrs   r5, psp           @ r5 <- thread SP\\
@--------------------- LR <- Address of UDF instruction\\
\hspace*{1.2em}ldr   lr, [r5, \#24]     @ 24 : 6 stacked registers before saved PC\\
@--------------------- Set return address to instruction following UDF\\
\hspace*{1.2em}adds  lr, \#2\\
\hspace*{1.2em}str   lr, [r5, \#24]\\
@--------------------- LR <- address of dispatcher table\\
\hspace*{1.2em}ldr   lr, =\_\_udf\_dispatcher\_table\\
@--------------------- r12 <- address of routine to call\\
\hspace*{1.2em}ldr   r12, [lr, r12, lsl \#2]   @ Address : LR + R12 << 2\\
@--------------------- Call service routine\\
\hspace*{1.2em}blx   r12                      @ R5: thread PSP\\
@--------------------- Set return code (from R0 to R3) in stacked registers\\
\hspace*{1.2em}stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\\
@--------------------- Restore preserved registers, return from interrupt\\
\hspace*{1.2em}pop   {r5, pc}
\end{SHELL}

Ce code va utiliser la valeur \texttt{r12} pour construire l'adresse d'une entrée du tableau \texttt{\_\_udf\_dispatcher\_table}. Cette entrée contient l'adresse de la routine à exécuter.

Remarquer ce code empile deux registres (soit 8 octets) dans la pile système~; il faut s'assurer que cette valeur correspond à la valeur du paramètre \emph{Section handler system stack byte count footprint} déclaré dans la \plm=configuration=.

Il faut donc construire ce tableau\footnote{Les fichiers \texttt{r12idx-section-dispatcher-header.s} et \texttt{r12idx-section-dispatcher-entry.s} sont identiques à ceux du schéma précédent \texttt{"udfcoded"}.}. Le fichier \texttt{r12idx-section-dispatcher-header.s} définit son en-tête~:

\begin{SHELL}\small
\_\_udf\_dispatcher\_table:
\end{SHELL}

Ce texte est ajouté à la fin du fichier assembleur \texttt{src.s}.

Ensuite, PLM va utiliser le fichier \texttt{r12idx-section-dispatcher-entry.s} pour définir chaque entrée du tableau~:
\begin{SHELL}\small
\hspace*{1.2em}.word !IMPLEMENTATION\_ROUTINE! @ !IDX!, user routine !USER\_ROUTINE!

\end{SHELL}

PLM effectue pour chaque section les substitutions de \nospace{!IMPLEMENTATION\_ROUTINE!}, de \nospace{!USER\_ROUTINE!} et de \nospace{!IDX!}, par ordre croissant de l'indice, en ajoutant le texte produit à la fin du fichier assembleur \texttt{src.s}.











\subsubsection{Schéma \texttt{r12direct} d'appel des sections}

Dans ce schéma, l'instruction indéfinie \texttt{UDF} est utilisée. L'adresse de la routine implémentant la section est entrée dans le registre \texttt{r12}.

Pour coder l'appel relatif à une section, PLM va utiliser le fichier \texttt{r12direct-section-invocation.s}. Le contenu de fichier est~:
\begin{SHELL}\small
\hspace*{1.2em}.section  ".text.!USER\_ROUTINE!","ax",\%progbits\\
\hspace*{1.2em}.global !USER\_ROUTINE!\\
\hspace*{1.2em}.type  !USER\_ROUTINE!,\%function\\
\hspace*{1.2em}.align  1\\
\hspace*{1.2em}.code  16\\
\hspace*{1.2em}.thumb\_func\\
\\
!USER\_ROUTINE!:\\
\hspace*{1.2em}.fnstart\\
\hspace*{1.2em}movw  r12, :lower16:!IMPLEMENTATION\_ROUTINE!\\
\hspace*{1.2em}movt  r12, :upper16:!IMPLEMENTATION\_ROUTINE!\\
\hspace*{1.2em}udf 0\\
\hspace*{1.2em}bx  lr\\
\\
.Lfunc\_end\_!USER\_ROUTINE!:\\
\hspace*{1.2em}.size  !USER\_ROUTINE!, .Lfunc\_end\_!USER\_ROUTINE! - !USER\_ROUTINE!\\
\hspace*{1.2em}.cantunwind\\
\hspace*{1.2em}.fnend
\end{SHELL}

Trois séquences sont remplacées par le compilateur PLM~:
\begin{itemize}
\item \nospace{!USER\_ROUTINE!}, par le nom assembleur de la fonction qui implémente l'appel de la section en mode utilisateur~;
\item \nospace{!IMPLEMENTATION\_ROUTINE!}, par le nom assembleur de la fonction qui implémente la section~;
\item \nospace{!IDX!}, par l'indice de la section (inutilisé dans ce shéma).
\end{itemize}

PLM effectue donc cette opération pour chaque section, par ordre croissant de l'indice, et accumule le texte produit dans le fichier assembleur \texttt{src.s}.

Donc, quand une instruction \texttt{UDF} est rencontrée, le Cortex exécute l'exception n°3, qui renvoie vers \texttt{as\_section\_handler}, défini par le fichier \texttt{r12direct-section-dispatcher-code.s}~:

\begin{SHELL}\small
\hspace*{1.2em}.section	".text.as\_section\_handler","ax",\%progbits\\
\hspace*{1.2em}.global as\_section\_handler\\
\hspace*{1.2em}.type as\_section\_handler, \%function\\
\\
as\_section\_handler:\\
@--------------------- Save preserved registers\\
\hspace*{1.2em}push  {r5, lr}\\
@--------------------- R5 <- thread SP\\
\hspace*{1.2em}mrs   r5, psp           @ r5 <- thread SP\\
@--------------------- LR <- Address of UDF instruction\\
\hspace*{1.2em}ldr   lr, [r5, \#24]     @ 24 : 6 stacked registers before saved PC\\
@--------------------- Set return address to instruction following UDF\\
\hspace*{1.2em}adds  lr, \#2\\
\hspace*{1.2em}str   lr, [r5, \#24]\\
@--------------------- Call service routine\\
\hspace*{1.2em}blx   r12                      @ R5: thread PSP\\
@--------------------- Set return code (from R0 to R3) in stacked registers\\
\hspace*{1.2em}stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\\
@--------------------- Restore preserved registers, return from interrupt\\
\hspace*{1.2em}pop   {r5, pc}
\end{SHELL}

Ce code utilise directement la valeur \texttt{r12}, c'est l'adresse de la routine à exécuter. Remarquer ce code empile deux registres (soit 8 octets) dans la pile système~; il faut s'assurer que cette valeur correspond à la valeur du paramètre \emph{Section handler system stack byte count footprint} déclaré dans la \plm=configuration=.


Les fichiers \texttt{r12direct-section-dispatcher-header.s} et \texttt{r12direct-section-dispatcher-entry.s} sont inutiles pour ce schéma, et sont donc vides.










\subsection{Le répertoire \texttt{teensy-3-1/custom}}

Texte à définir…




\sectionLabel{La directive \texttt{check target}}{directiveCheckTarget}\index{check target}

La directive \plm=check target= permet de vérifier l'identité de la cible. Elle est utile pour s'assurer qu'un fichier est acceptable par une cible. À la compilation, toute directive \plm=check target= incorrecte entraîne une erreur.

Par exemple, compiler pour la cible \plm+"teensy-3-1"+ est spécifié par~:

\begin{PLM}
target "teensy-3-1"
\end{PLM}

Si la définition du projet implique d'importer le fichier \plm+"monFichier.plm"+~:

\begin{PLM}
target "teensy-3-1"
import "monFichier.plm"
\end{PLM}

Si le contenu de ce fichier commence par~:
\begin{PLM}
check target "lpc2294"
\end{PLM}

Alors une erreur de compilation apparaît. La directive \plm=check target= doit être~:
\begin{PLM}
check target "teensy-3-1"
\end{PLM}

