%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Définition d'une cible}{chapitreConfCible}

Dans ce chapitre, nous allons voir comment est définie une cible, en prenant pour exemple la cible \texttt{teensy-3-1-sequential-systick}. 

Si vous voulez définir votre propre cible, la lecture de ce chapitre est indispensable. 

Le compilateur recherche la cible citée :
\begin{itemize}
  \item par défaut, parmi les fichiers qu'il embarque ;
  \item si l'option \texttt{-T=$cibles$} est présente dans la ligne de commande, dans les fichiers du répertoire $cibles$.
\end{itemize}

Pour explorer les fichiers indispensables à la définition d'une cible, il est nécessaire de les placer dans le système de fichiers. La première section de ce chapitre (\refSectionPage{cibleDansSystemeFichiers}) va donc indiquer comment extraire de l'exécutable les fichiers de définition des cibles, et comment les exploiter.

%\minitoc

\sectionLabel{Utilisation d'une cible dans le système de fichiers}{cibleDansSystemeFichiers}

Une cible est définie par une arborescence de fichiers, soit embarquée dans le compilateur, soit situé dans le système de fichiers. On va voir dans cette section comment est configurée une cible dans le système de fichiers, permettant ainsi de créer ses propres cibles. Pour cela, on commence par extraire de l'exécutable du compilateur les cibles qu'il embarque.

\subsection{Liste des cibles embarquées}
À titre d'information, on peut appeler l'option \texttt{-L} pour obtenir la liste des cibles embarquées :
\begin{SHELL}
{\bfseries plm -L}\\
Embedded targets:\\ 
\hspace*{1.2em}teensy-3-1-interrupt\\
\hspace*{1.2em}teensy-3-1-sequential-systick\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction des cibles embarquées}
L'option \texttt{-X=cibles} permet d'extraire de l'exécutable du compilateur tous les fichiers de définition des cibles et de les placer dans le répertoire \texttt{cibles}\footnote{Ici, le répertoire destination \texttt{cibles} est un répertoire relatif au répertoire courant, mais un répertoire absolu peut aussi être utilisé.} :
\begin{SHELL}
{\bfseries plm -X=cibles}\\
\hspace*{1.2em}cibles/makef{}ile.py\\
\hspace*{1.2em}cibles/teensy-3-1-interrupt.plm-target\\
\hspace*{1.2em}cibles/teensy-3-1-sequential-systick.plm-target\\
\hspace*{1.2em}cibles/files/boot-teensy-3-1.plm\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction d'un fichier d'exemple}
On extrait maintenant un fichier d'exemple \texttt{01-blinkled.plm} pour la cible \texttt{teensy-3-1-sequential-systick} :
\begin{SHELL}
\bfseries plm -x=/teensy-3-1-sequential-systick/01-blinkled.plm
\end{SHELL}

\subsection{Compilation du fichier exemple}
Le fichier \texttt{01-blinkled.plm} est écrit dans le répertoire local. Maintenant, pour compiler ce fichier, on peut faire référence aux cibles que l'on vient d'extraire au moyen de l'option \texttt{-T} :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}


\subsection{Changement du nom de la cible dans le système de fichiers}

Pour se convaincre que la cible nommée dans le fichier est bien celle située dans le répertoire \texttt{cibles}, nous allons changer son nom. Pour cela, nous devons modifier :
\begin{itemize}
  \item la référence à la cible dans le fichier \texttt{01-blinkled.plm} ;
  \item le nom d'un fichier et d'un répertoire dans le répertoire \texttt{cibles}. 
\end{itemize}

Commençons par le fichier \texttt{01-blinkled.plm}. Sa première ligne est :
\begin{PLM}[1]
target "teensy-3-1-sequential-systick"
\end{PLM}

Cette ligne signifie que la cible s'appelle \texttt{teensy-3-1-sequential-systick}. Nous allons la renommer en \texttt{myTeensy}. La première ligne du fichier \texttt{01-blinkled.plm} devient donc :

\begin{PLM}[1]
target "myTeensy"
\end{PLM}

Maintenant, si on essaie de compiler le fichier \texttt{01-blinkled.plm}, une erreur se déclenche : la cible \texttt{myTeensy} n'est pas définie. Pour la définir, listons le contenu le répertoire \texttt{cibles} :
\begin{SHELL}
{\bfseries ls -1F cibles}\\
f{}iles/\\
makef{}ile.py\\
...\\
teensy-3-1-sequential-systick/\\
teensy-3-1-sequential-systick.plm-target\\
...
\end{SHELL}

Le répertoire \texttt{f{}iles} et le fichier \texttt{makef{}ile.py} seront présentés plus loin. Chaque cible est définie par un répertoire et un fichier, dont l'extension est \texttt{plm-target}. Nous allons donc effectuer les renommages suivants :
\begin{itemize}
  \item le répertoire \texttt{teensy-3-1-sequential-systick} est renommé en \texttt{myTeensy} ;
  \item le fichier \texttt{teensy-3-1-sequential-systick.plm-target} en \texttt{myTeensy.plm-target}.
\end{itemize}

À présent, la compilation s'effectue avec succès :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}

Si on essaie de compiler en utilisant les cibles embarquées dans le compilateur :
\begin{SHELL}
\bfseries plm 01-blinkled.plm
\end{SHELL}

Une erreur se déclenche, la cible \texttt{myTeensy} n'étant pas définie dans l'exécutable du compilateur.






\sectionLabel{Comment est définie une cible}{exempleDefinitionCible}

Nous allons décrire comment est définie une cible dans le système de fichiers. Nous prenons comme exemple la cible \texttt{myTeensy} du répertoire \texttt{cibles} (voir la \refSectionPage{cibleDansSystemeFichiers}).

Pour la cible \texttt{myTeensy} :
\begin{itemize}
  \item le fichier \texttt{myTeensy.plm-target} permet de paramétrer l'analyse sémantique ;
  \item le répertoire \texttt{myTeensy} permet de configurer la génération de code.
\end{itemize}

On va explorer successivement le fichier \texttt{myTeensy.plm-target} puis le répertoire \texttt{myTeensy}.

\subsection{Organigramme d'exécution}

La \refFigure{}{sequenceDemarrage} définit l'organigramme d'exécution d'un programme dont la cible est \texttt{teensy-3-1-sequential-systick}, ou \texttt{myTeensy} dont il est la copie.

Le micro-contrôleur démarre sur une horloge interne, la mémoire vive n'étant pas initialisée. La première étape est de configurer les horloges internes du micro-contrôleur : c'est le rôle des routines \plm=boot=. À ce stade, la mémoire vive n'est toujours pas initialisée, aussi les routines \plm=boot= n'y accèdent pas (le compilateur l'assure).

La deuxième étape est d'initialiser la mémoire vive, c'est-à-dire mettre à zéro la zone \texttt{bss}, et de recopier à partir de la flash les valeurs initiales des variables initialisées.

La troisième étape est l'exécution des routines \plm=init=. À partir de cette étape et pour les suivantes, les variables globales sont initialisées, et donc leur emploi est autorisé. Le rôle des routines \plm=init= est de configurer les entrées/sorties du micro-contrôleur. En particulier, la routine \plm=init 0= de cette cible configure le \emph{SysTick Timer} pour qu'il engendre une interruption toutes les millisecondes (\refSubsectionPage{fichierTarget}).


\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=5mm
    ]
    \node [cloud] (start) {\textsc{Démarrage}} ;
    \node [block] (boot) [below=of start] {Routines \bf\texttt{boot}} ;
    \node [block] (raz) [below=of boot] {Initialisation des variables globales} ;
    \node [block] (init) [below=of raz] {Routines \bf\texttt{init}} ;
    \node [block] (setup) [below=of init] {Procédure \texttt{setup}} ;
    \node [block] (loop) [below=of setup] {Procédure \texttt{loop}} ;

    \draw [-stealth, thick] (start) -- (boot) ;
    \draw [-stealth, thick] (boot) -- (raz) ;
    \draw [-stealth, thick] (raz) -- (init) ;
    \draw [-stealth, thick] (init) -- (setup) ;
    \draw [-stealth, thick] (setup) -- (loop) ;
    \draw [-stealth, thick] (loop.south) -- +(0, -.25) -- +(1.7, -.25) -- +(1.7, 0.8)-- +(0, 0.8) ;
  \end{tikzpicture}
  \caption{Organigramme d'exécution défini par la cible \texttt{teensy-3-1-sequential-systick}}
  \labelFigure{sequenceDemarrage}
  \ligne
\end{figure}




\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      block/.style ={rectangle, draw=black, thick, fill=white, align=center, minimum height=1cm, minimum width=2cm},
      node distance=1.8cm
    ]
    \node [block] (plm) {\tt programme.plm} ;
    \node [block] (plmc) [right=of plm] {\tt plm.c} ;
    \node [block] (plms) [below=of plmc] {\tt plm.s} ;
    \node [block] (plmco) [right=of plmc] {\tt plm.c.o} ;
    \node [block] (plmso) [right=of plms] {\tt plm.s.o} ;
    \node [block] (linker) [below=of plmso] {\tt linker.ld} ;
    \node [block] (elf) [right=of plmso] {\tt plm.elf} ;

    \draw [-stealth, thick] (plm) to node[above] {\tt plm} (plmc) ;
    \draw [-stealth, thick] (plm.east) -- +(0.9, 0) |- (plms.west) ;
    \draw [-stealth, thick] (plmc) to node[above] {\tt gcc} (plmco) ;
    \draw [-stealth, thick] (plms) to node[above] {\tt gcc} (plmso) ;
    \draw [-stealth, thick] (plmso) to node[above right] {\tt gcc} (elf) ;
    \draw [thick] (plmco.east) -- +(0.9, 0) |- (elf.west) ;
    \draw [-stealth, thick] (linker.east) -- +(0.9, 0) |- (elf.west) ;
  \end{tikzpicture}
  \caption{Compilation d'un programme PLM}
  \labelFigure{compilationProgrammePLM}
  \ligne
\end{figure}








\subsectionLabel{Le fichier \texttt{myTeensy.plm-target}}{fichierTarget}

Voici le contenu du fichier \texttt{myTeensy.plm-target} :
\begin{PLM}[1]
newUnsignedRepresentation @unsigned8  "uint8_t"   8
newUnsignedRepresentation @unsigned16 "uint16_t" 16
newUnsignedRepresentation @unsigned32 "uint32_t" 32
newUnsignedRepresentation @unsigned64 "uint64_t" 64

newSignedRepresentation @signed8  "int8_t"   8
newSignedRepresentation @signed16 "int16_t" 16
newSignedRepresentation @signed32 "int32_t" 32
newSignedRepresentation @signed64 "int64_t" 64

newUnsignedRepresentation @size "uint32_t" 32

booleanType Bool @unsigned8

newIntegerType UInt8  @unsigned8
newIntegerType UInt16 @unsigned16
newIntegerType UInt32 @unsigned32
newIntegerType UInt64 @unsigned64
newIntegerType Int8  @signed8
newIntegerType Int16 @signed16
newIntegerType Int32 @signed32
newIntegerType Int64 @signed64

exception : Int32 UInt32

mode $isr
mode $user

import "files/mk20dx256.plm"
import "files/boot-teensy-3-1.plm"

required proc systickHandler $isr ()
required proc setup $user ()
required proc loop $user ()

proc systickHandler $isr @weak () {
}

init 0 { // Configure Systick interrupt every ms
  SYST_RVR = 96000 - 1 // Interrupt every 96000 core clocks, i.e. every ms
  SYST_CVR = 0
  SYST_CSR = SYST_CSR::CLKSOURCE | SYST_CSR::TICKINT | SYST_CSR::ENABLE
}
\end{PLM}
%\ligne\\

{\bf Lignes 1 à 4.} Les quatre déclarations \plm+newUnsignedRepresentation+ définissent des représentations relatives aux entiers non signés (\refSubsectionPage{DefNewUnsignedRepresentation}). Les représentations ainsi définies (\plm+@unsigned8+, \plm+@unsigned16+, ...) ne sont pas des types directement utilisables en PLM, mais des annotations qui paramètrent certaines déclarations, comme par exemple la déclaration des types entiers non signés lignes 15 à 18.

{\bf Lignes 6 à 9.} De manière analogue, les quatre déclarations \plm+newSignedRepresentation+ définissent des représentations relatives aux entiers signés (\refSubsectionPage{DefNewSignedRepresentation}). Les représentations ainsi définies (\plm+@signed8+, \plm+@signed16+, ...) ne sont pas des types directement utilisables en PLM, mais des annotations qui paramètrent certaines déclarations, comme par exemple la déclaration des types entiers signés lignes 19 à 22.

{\bf Ligne 11.} Cette ligne déclare la représentation \plm+@size+, qui est celle utilisée par défaut pour les types énumérés (\emph{référence à ajouter}). La déclaration de la représentation \plm+@size+ est obligatoire.

{\bf Ligne 13.} Déclaration du type booléen : il se nomme conventionnellement \plm+Bool+, et sa représentation est \plm+@unsigned8+, c'est-à-dire un entier non signé sur 8 bits. La déclaration d'un type booléen est obligatoire.

{\bf Lignes 15 à 22.} Déclaration des types entier, non signés et signés. Les noms \plm+UInt8+, ..., \plm+Int64+ sont les noms des types entiers directement utilisables en PLM.

{\bf Ligne 24.} Déclaration des types entier relatifs aux exceptions (\refSectionPage{typeLiesException}). Le premier type définit le type du code de l'exception (\plm+Int32+, dont un code d'exception peut être négatif, positif, ou nul), le second le type du numéro de ligne (\plm+UInt32+, un numéro de ligne est positif). Cette déclaration est obligatoire.

{\bf Lignes 26 et 27.} Déclaration des modes complémentaires, propres à la cible. Trois modes sont prédéfinis : \plm+$boot+, \plm+$init+ et \plm=$exception= (\refSectionPage{modesPredefinis}). Ces déclarations sont optionnelles, en leur absence seuls les trois modes prédéféfinis existent.


{\bf Lignes 29 et 30.} Importation de fichiers source. Le fichier \texttt{mk20dx256.plm} contient la définition des registres de contrôle du processeur qui équipe la carte \emph{Teensy 3.1}, \texttt{boot-teensy-3-1.plm} contient le code de configuration du processeur (routine \plm=boot 0=). Si l'appel du compilateur contient l'option \texttt{-T=cibles} (par exemple : \texttt{plm -T=cibles 01-blinkled.plm}), alors, ces fichiers sont recherchés dans le système de fichiers, relativement au répertoire \texttt{cibles}.Si l'appel du compilateur ne contient pas l'option \texttt{-T} (par exemple : \texttt{plm 01-blinkled.plm}), alors, ces fichiers sont recherchés parmi les fichiers embarqués dans l'exécutable.



{\bf Lignes 32 à 34.} Déclaration des procédures requises (\refSubsectionPage{procedureRequise}). Ces déclarations ont une double signification :
\begin{itemize}
  \item d'abord, que les procédures citées doivent être définies soit dans la cible (c'est le cas de \texttt{systickHandler}), soit dans le code utilisateur (ici \texttt{01-blinkled.plm}) : c'est le cas des procédures \texttt{setup} et \texttt{loop} ;
  \item ensuite, le compilateur calcule le graphe des appels des routines, afin de supprimer les routines inutilisées ; les procédures requises sont les racines du graphe d'accessibilité.
\end{itemize}

{\bf Lignes 36 et 37.} Déclaration de la procédure \texttt{systickHandler}. Elle s'exécute dans le mode \plm=$isr=, c'est donc une routine d'interruption. Elle est déclarée avec l'attribut \plm=@weak= (\refSubsectionPage{attributWeak}), c'est-à-dire qu'une procédure de même nom peut être déclarée, qui va remplacer celle-ci. Cette déclaration définit donc la routine par défaut.

{\bf Lignes 39 à 43.} Définition de la routine \plm=init 0= (\refSectionPage{initRoutine}). Le code de cette routine configure le \emph{SysTick Timer} de façon qu'une interruption \emph{SysTick} survienne toutes les millisecondes. Comme cette routine porte le numéro $0$, on est sûr qu'elle soit la première à être exécutée.






\subsection{Le répertoire \texttt{myTeensy}}








