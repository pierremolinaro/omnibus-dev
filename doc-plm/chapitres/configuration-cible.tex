%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Définition d'une cible}{chapitreConfCible}

Dans ce chapitre, nous allons voir comment est définie une cible, en prenant pour exemple la cible \texttt{teensy-3-1/unprivileged}. 

Si vous voulez définir votre propre cible, la lecture de ce chapitre est indispensable. 

Le compilateur recherche la cible citée~:
\begin{itemize}
  \item par défaut, parmi les fichiers embarqués dans le compilateur PLM~;
  \item si l'option \OPTION{-T=$repertoire$} (voir \refSectionPage{optionsCiblesEmbarquees}) est présente dans la ligne de commande, dans les fichiers du répertoire $cibles$.
\end{itemize}

Pour explorer les fichiers indispensables à la définition d'une cible, il est nécessaire de les placer dans le système de fichiers. La première section de ce chapitre (\refSectionPage{cibleDansSystemeFichiers}) va donc indiquer comment extraire de l'exécutable les fichiers de définition des cibles, et comment les exploiter.

%\minitoc

\sectionLabel{Utilisation d'une cible dans le système de fichiers}{cibleDansSystemeFichiers}

Une cible est définie par une arborescence de fichiers, soit embarquée dans le compilateur, soit située dans le système de fichiers. On va voir dans cette section comment est configurée une cible dans le système de fichiers, permettant ainsi de créer ses propres cibles. Pour cela, on commence par extraire de l'exécutable du compilateur les cibles qu'il embarque.

\subsection{Liste des cibles embarquées}
À titre d'information, on peut appeler l'option \OPTION{-L} pour obtenir la liste des cibles embarquées~:
\begin{SHELL}
{\bfseries plm -L}\\
Embedded targets:\\ 
\hspace*{1.2em}LPC-2294\\
\hspace*{1.2em}teensy-3-1/privileged\\
\hspace*{1.2em}teensy-3-1/unprivileged\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction des cibles embarquées}
L'option \OPTION{-X=cibles} permet d'extraire de l'exécutable du compilateur tous les fichiers de définition des cibles et de les placer dans le répertoire \texttt{cibles}\footnote{Ici, le répertoire destination \texttt{cibles} est un répertoire relatif au répertoire courant, mais un répertoire absolu peut aussi être utilisé.}~:
\begin{SHELL}
{\bfseries plm -X=cibles}\\
\hspace*{1.2em}...
\end{SHELL}





\subsection{Liste des fichiers d'exemple embarqués dans l'exécutable}
L'option \OPTION{-l} permet d'afficher la liste de tous les fichiers d'exemple embarqués dans l'exécutable du compilateur ~:
\begin{SHELL}
{\bfseries plm -l}\\
\hspace*{1.2em}LPC-L2294/01-blinkleds.plm\\
\hspace*{1.2em}LPC-L2294/02-control-register-array.plm\\
\hspace*{1.2em}teensy-3-1/00-structure-example.plm\\
\hspace*{1.2em}teensy-3-1/01-blink-led.plm\\
\hspace*{1.2em}...
\end{SHELL}




\subsection{Extraction d'un fichier d'exemple}
On extrait maintenant un fichier d'exemple \texttt{teensy-3-1/01-blink-led.plm}~:
\begin{SHELL}
\bfseries plm -x=teensy-3-1/01-blink-led.plm
\end{SHELL}

Le fichier extrait est recopié dans le répertoire courant.






\subsection{Compilation du fichier exemple}
Par défaut, le compilateur utilise les cibles qu'il embarque :
\begin{SHELL}
\bfseries plm 01-blink-led.plm
\end{SHELL}

Si on veut utiliser les cibles définies dans le répertoire $cibles$, on utilise l'option \OPTION{-T}~:
\begin{SHELL}
\bfseries plm -T=cibles 01-blink-led.plm
\end{SHELL}


\subsection{Changement du nom de la cible dans le système de fichiers}

Pour se convaincre que la cible nommée dans le fichier est bien celle située dans le répertoire $cibles$, nous allons changer son nom. Pour cela, nous devons modifier~:
\begin{itemize}
  \item la référence à la cible dans le fichier \texttt{01-blink-led.plm}~;
  \item le nom d'un fichier et d'un répertoire dans le répertoire \texttt{cibles}. 
\end{itemize}

Commençons par le fichier \texttt{01-blink-led.plm}. Sa première ligne est~:

\begin{PLM}
target "teensy-3-1/unprivileged"
\end{PLM}

Cette ligne signifie que la cible s'appelle \texttt{teensy-3-1/unprivileged}. Nous allons la renommer en \texttt{teensy-3-1/custom}. La première ligne du fichier \texttt{01-blink-led.plm} devient donc~:

\begin{PLM}
target "teensy-3-1/custom"
\end{PLM}

Maintenant, si on essaie de compiler le fichier \texttt{01-blink-led.plm}, une erreur se déclenche~: la cible \texttt{teensy-3-1/custom} n'est pas définie.
\begin{SHELL}
{\bfseries plm -T=cibles 01-blink-led.plm}\\
\textcolor{red}{semantic error \#1: This target is not defined in 'cibles' directory}\\
\textcolor{red}{target "teensy-3-1/custom"}\\
\textcolor{red}{-{}-{}-{}-{}-{}-{}-\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}}
\end{SHELL}


Pour définir la cible, il faut d'abord comprendre comment le répertoire \texttt{cibles} est organisé. Affichons la liste de ses sous répertoires~:
\begin{SHELL}
{\bfseries find cibles -type d}\\
cibles\\
cibles/LPC-L2294\\
cibles/teensy-3-1\\
cibles/teensy-3-1/privileged\\
cibles/teensy-3-1/unprivileged
\end{SHELL}

Chaque sous répertoire peut définir une cible\footnote{Pour cela, il doit en fait contenir un fichier \texttt{+config.plm-target}.}. Il suffit donc de dupliquer le répertoire \texttt{teensy-3-1/unprivileged} en le renommant \texttt{teensy-3-1/custom}~:
\begin{SHELL}
{\bfseries find cibles -type d}\\
cibles\\
cibles/LPC-L2294\\
cibles/teensy-3-1\\
cibles/teensy-3-1/custom\\
cibles/teensy-3-1/privileged\\
cibles/teensy-3-1/unprivileged
\end{SHELL}

Maintenant, la compilation s'effectue avec succès~:
\begin{SHELL}
{\bfseries plm -T=cibles 01-blink-led.plm}
\end{SHELL}

Si on essaie de compiler en utilisant les cibles embarquées dans le compilateur~:
\begin{SHELL}
{\bfseries plm 01-blink-led.plm}\\
\textcolor{red}{semantic error \#1: This target is not defined in embedded targets}\\
\textcolor{red}{target "teensy-3-1/custom"}\\
\textcolor{red}{-{}-{}-{}-{}-{}-{}-\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}\^{}}
\end{SHELL}

Une erreur se déclenche, la cible \texttt{teensy-3-1/custom} n'étant pas définie dans l'exécutable du compilateur.






\sectionLabel{Définition d'une cible : fichier \texttt{+config.plm-target}}{exempleDefinitionCible}

Nous allons décrire comment est définie une cible dans le système de fichiers. Nous prenons comme exemple la cible \texttt{teensy-3-1/custom} du répertoire \texttt{cibles} (voir la \refSectionPage{cibleDansSystemeFichiers}).

Un répertoire définit une cible si il contient un fichier nommé \texttt{+config.plm-target}. Le contenu de ce fichier configure la cible, en voici le début~:

\begin{PLM}
//--- Python tool list
PYTHON_UTILITIES:
   "../../py-toolpath.txt" -> "sources/toolpath.py",
   "../../py-makefile.txt" -> "sources/makefile.py",
   ...
\end{PLM}


Le contenu est une séquence de définitions, chacune d'elles ayant la syntaxe suivante~:
\begin{itemize}
  \item son nom (dans l'exemple ci-dessus, \plm=PYTHON_UTILITIES=)~;
  \item le délimiteur \plm=:=~;
  \item une liste de paramètres séparés par un virgule, ce qui signifie qu'un nombre quelconque d'items est accepté~;
  \item {\bf ou} une liste de paramètres séparés par un point-virgule, ce qui signifie qu'un nombre fixe d'items est accepté, et que chacun d'eux a une signification particulière~;
  \item {\bf ou} un simple paramètre~;
  \item quand un paramètre désigne un fichier par un chemin relatif, celui-ci est pris à partir du répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.
\end{itemize}

L'ordre des séquences est imposée.

Les sections qui suivent détaillent chaque définition, dans leur ordre d'apparition dans le fichier \texttt{+config.plm-target}.










\subsectionLabel{\texttt{PYTHON\_UTILITIES}}{configurationPythonUtilities}\index{PYTHON\_UTILITIES}

\begin{PLM}
PYTHON_UTILITIES:
   "../../py-toolpath.txt" -> "sources/toolpath.py",
   "../../py-makefile.txt" -> "sources/makefile.py",
   "../../py-check-stacks.txt" -> "sources/check-stacks.py",
   "../../py-plm.txt" -> "sources/plm.py",
   "../../py-build-verbose.txt" -> "build-verbose.py",
   "../../py-clean.txt" -> "clean.py",
   "../../py-objdump.txt" -> "objdump.py",
   "../../py-objsize.txt" -> "objsize.py",
   "../py-run.txt" -> "run.py"
\end{PLM}

Cette déclaration liste une liste de fichiers à recopier dans le répertoire engendré pour chaque projet :
\begin{itemize}
  \item le fichier source (par exemple \texttt{../../py-toolpath.txt}) est désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}~;
  \item le fichier destination (par exemple \texttt{sources/toolpath.py}) est désigné par un chemin relatif par rapport au répertoire du projet~;
  \item le fichier destination est rendu exécutable.
\end{itemize}





\subsectionLabel{\texttt{PYTHON\_BUILD}}{configurationPythonBuild}\index{PYTHON\_BUILD}

\begin{PLM}
PYTHON_BUILD:
   "../py-build.txt"
\end{PLM}

Le fichier source (ici \texttt{../py-build.txt}) est désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source~:
\begin{itemize}
  \item \texttt{<<OPT\_OPTIMIZATION\_OPTION>>} est remplacé par l'option d'optimisation choisie (\texttt{O0}, \texttt{O1}, \texttt{O2}, \texttt{O3}, \texttt{Os} ou \texttt{Oz})~;
  \item \texttt{<<LLC\_OPTIMIZATION\_OPTION>>} est remplacé par l'option d'optimisation correspondante pour l'utilitaire \texttt{llc} (\texttt{O0}, \texttt{O1}, \texttt{O2} ou \texttt{O3}).
\end{itemize}


La chaîne résultat est copiée dans le fichier \texttt{build.py} situé dans le répertoire du projet. Ce fichier est rendu exécutable.









\subsectionLabel{\texttt{LINKER\_SCRIPT}}{configurationLinkerScript}\index{LINKER\_SCRIPT}

\begin{PLM}
LINKER_SCRIPT:
  "../ld-linker.txt"
\end{PLM}

Le fichier source (ici \texttt{../ld-linker.txt}) est désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Une substitution est effectuée dans la chaîne obtenue par la lecture du fichier source~:
\begin{itemize}
  \item \texttt{!SYSTEMSTACKSIZE!} est remplacé par la taille allouée (en nombre d'octets) à la pile système~; cette valeur est fixée par la définition \texttt{SYSTEM\_STACK\_SIZE}, voir \refSubsectionPage{configurationSystemStackSize}.
\end{itemize}

La chaîne résultat est copiée dans le fichier \texttt{sources/linker.ld} situé dans le répertoire du projet.











\subsectionLabel{\texttt{PANIC}}{configurationPanic}\index{PANIC}

\begin{PLM}
PANIC:
  Int32 ; UInt32 ; "../target-panic.ll"
\end{PLM}

Trois arguments (séparés par un point-virgule) sont définis ici~:
\begin{itemize}
  \item le premier (ici \plm=Int32=) est le type PLM utilisé pour le code de panique~;
  \item le deuxième (ici \plm=UInt32=) est le type PLM utilisé pour coder le numéro de la ligne source du fichier contenant l'instruction qui peut engendrer une panique~;
  \item le dernier (ici \plm="../target-panic.ll"=) désigne un fichier source LLVM par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.
\end{itemize}

Deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{../target-panic.ll}~:
\begin{itemize}
  \item \texttt{!PANICCODE!} est remplacé par le type LLVM correspondant type PLM utilisé pour le code de panique (donc, ici \texttt{i32} qui est le type LLVM image de \plm=Int32=)~;
  \item \texttt{!PANICLINE!} est remplacé par le type PLM utilisé pour coder le numéro de la ligne source  (donc, ici \texttt{i32} qui est aussi le type LLVM image de \plm=UInt32=).
\end{itemize}


La chaîne résultat est ensuite ajoutée au fichier source LLVM \texttt{src.ll} du projet.







\subsectionLabel{\texttt{POINTER\_BIT\_COUNT}}{configurationPointerBitCount}\index{POINTER\_BIT\_COUNT}

\begin{PLM}
POINTER_BIT_COUNT:
  32
\end{PLM}

Le nombre de bits d'un pointeur. Le Cortex-M4 étant une machine 32 bits, sa valeur est 32.












\subsectionLabel{\texttt{SYSTEM\_STACK\_SIZE}}{configurationSystemStackSize}\index{SYSTEM\_STACK\_SIZE}

\begin{PLM}
SYSTEM_STACK_SIZE:
  1024
\end{PLM}

La taille en octets allouée à la pile système.







\subsectionLabel{\texttt{NOP}}{configurationNop}\index{nop}
\begin{PLM}
NOP:
  "call void asm sideeffect \"nop\", \"\"() nounwind"
\end{PLM}

Cette entrée définit l'instruction processeur \texttt{nop}, telle qu'elle doit être formulée en LLVM. Pour insérer cette instruction en PLM, utiser le mot réservé \plm=nop= (\refSectionPage{instructionNop}).





\subsectionLabel{\texttt{SERVICE}}{configurationService}\index{SERVICE}

\begin{PLM}
SERVICE:
  "service-handler.s" ;
  12 ; // as_svc_handler saves 3 registers on system stack
  "service-dispatcher-header.s" ;
  "service-dispatcher-entry.s" ;
  "service-entry.s"
\end{PLM}

Le premier argument (ici \plm="service-handler.s"=) est un fichier assembleur désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Son contenu est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ce fichier contient l'implémentation du \emph{svc handler}.

Le deuxième argument (ici \plm=12=) est le nombre d'octets de la pile système que l'exécution du \emph{svc handler} utilise.

Les troisième et quatrième arguments (ici les chaînes \plm="service-dispatcher-header.s"= et \plm="service-dispatcher-entry.s"=) désignent des fichiers assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ces deux fichiers permettent de construire la table des appels système. D'abord, le contenu du fichier \plm="service-dispatcher-header.s"= est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ensuite, l'opération suivante est effectuée pour chaque service défini dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{service-dispatcher-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine réalisant l'implémentation du service~;
    \item \texttt{!IDX!} est remplacé par l'indice du service (PLM numérote les services, à partir de $0$)~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}

Le dernier argument (ici \plm="service-entry.s"=) permet de construire la routine appelée par les tâches. Il désigne un fichier assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ensuite, l'opération suivante est effectuée pour chaque service défini dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{service-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine appelée par les tâches~;
    \item \texttt{!IDX!} est remplacé par l'indice du service~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}











\subsectionLabel{\texttt{SECTION}}{configurationSection}\index{SECTION}

Il y a deux possibilités -- selon les cibles -- pour paramétrer l'implémentation des sections~:
\begin{itemize}
  \item par un appel système (\refSubsubsection{configurationSectionAppelSysteme})~;
  \item par un masquage temporaire des interruptions (\refSubsubsectionPage{configurationSectionMasquageInterruption}).
\end{itemize}

\subsubsectionLabel{Implémentation via un appel système}{configurationSectionAppelSysteme}

\begin{PLM}
SECTION:
  "udfcoded-section-handler.s" ;
  8 ; // saves 2 registers on system stack
  "udfcoded-section-dispatcher-header.s" ;
  "udfcoded-section-dispatcher-entry.s" ;
  "udfcoded-section-invocation.s"
\end{PLM}

L'implémentation des sections via des appels système est détaillée à la \refSectionPage{schemaAppelSectionsViaSystemCall}.

Le premier argument (ici \plm="udfcoded-section-handler.s"=) est un fichier assembleur désigné par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Son contenu est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ce fichier contient l'implémentation du \emph{handler} associé.

Le deuxième argument (ici \plm=8=) est le nombre d'octets de la pile système que l'exécution du \emph{handler} utilise.

Les troisième et quatrième arguments (ici les chaînes \plm="udfcoded-dispatcher-header.s"= et \plm="service-dispatcher-entry.s"=) désignent des fichiers assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ces deux fichiers permettent de construire la table des appels système. D'abord, le contenu du fichier \plm="udfcoded-dispatcher-header.s"= est simplement ajouté au fichier source assembleur \texttt{src.s} du projet. Ensuite, l'opération suivante est effectuée pour chaque section définie dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{udfcoded-dispatcher-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine réalisant l'implémentation de la section~;
    \item \texttt{!IDX!} est remplacé par l'indice de la section (PLM numérote les sections, à partir de $0$)~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}

Le dernier argument (ici \plm="udfcoded-entry.s"=) permet de construire la routine appelée par les tâches. Il désigne un fichier assembleur par un chemin relatif au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}. Ensuite, l'opération suivante est effectuée pour chaque section définie dans le projet~:
\begin{itemize}
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{udfcoded-entry.s}~:
  \begin{itemize}
    \item \texttt{!ENTRY!} est remplacé par le nom assembleur de la routine appelée par les tâches~;
    \item \texttt{!IDX!} est remplacé par l'indice de la section~;
  \end{itemize}
  \item la chaîne résultat est simplement ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}



\subsubsectionLabel{Implémentation via un masquage temporaire des interruptions}{configurationSectionMasquageInterruption}

\begin{PLM}
SECTION:
"call void asm sideeffect \"cpsid i\", \"\"() nounwind";// Disable interrupt
"call void asm sideeffect \"cpsie i\", \"\"() nounwind" // Enable interrupt
\end{PLM}

Cette implémentation exige que les tâches puissent masquer les interruptions, ce qui impose qu'elles s'exécutent en mode privilégié. C'est par exemple le cas de la cible \texttt{teensy-3-1/privileged}.

Dans ce cas, l'implémentation est complètement réalisée en LLVM, sans avoir besoin de fichier assembleur. Il faut simplement fournir les instructions LLVM de \emph{masquage} et \emph{démasquage} des interruptions. C'est le rôle des deux arguments. Ils expriment les instructions LLVM qui embarquent les instructions assembleur correspondantes.




\subsectionLabel{\texttt{C\_FILES}}{configurationFichiersC}\index{C\_FILES}

\begin{PLM}
C_FILES:
  "../c-cortex-m4-context.c",
  "../../c-real-time-kernel.c",
  "../c-countTrainingZeros.c"
\end{PLM}

Cette entrée liste tous les fichiers C qui composent le fichier \texttt{src.c} d'un projet. Il sont tous désignés par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Les opérations effectuées sont les suivantes~:
\begin{itemize}
  \item les fichiers sont lus et concaténés dans leur ordre d'apparition dans l'entrée \texttt{C\_FILES}~:
  \item deux substitutions sont effectuées dans la chaîne obtenue par la lecture du fichier source \texttt{udfcoded-entry.s}~:
  \begin{itemize}
    \item \texttt{!TASKCOUNT!} est remplacé par le nombre de tâches du projet~;
    \item \texttt{!GUARDCOUNT!} est remplacé par le nombre maximum de commandes gardées des tâches du projet~;
  \end{itemize}
  \item la chaîne résultat constitue le fichier source C \texttt{src.c} du projet.
\end{itemize}






\subsectionLabel{\texttt{S\_FILES}}{configurationFichiersAssembleur}\index{S\_FILES}

\begin{PLM}
S_FILES:
  "../s-cortex-m4-header.s",
  "s-interrupt-vectors.s",
  "s-reset-handler.s"
\end{PLM}

Cette entrée liste tous les fichiers assembleur qui composent le début du fichier \texttt{src.s} d'un projet. Il sont tous désignés par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Les opérations effectuées sont les suivantes~:
\begin{itemize}
  \item les fichiers sont lus et concaténés dans leur ordre d'apparition dans l'entrée \texttt{S\_FILES}~:
  \item la chaîne résultat constitue le début du fichier source assembleur \texttt{src.s} du projet~; PLM y ajoute ensuite le texte assembleur provenant de l'implémentation des services, des sections et des interruptions.
\end{itemize}












\subsectionLabel{\texttt{LL\_FILES}}{configurationFichiersLLVM}\index{LL\_FILES}

\begin{PLM}
LL_FILES:
  "../ll-cortex-m4.ll",
  "../../ll-clear-bss.ll",
  "../../ll-copy-data-section.ll",
  "../../ll-configuration-on-boot.ll",
  "../../ll-create-task.ll"
\end{PLM}

Cette entrée liste tous les fichiers LLVM qui composent le début du fichier \texttt{src.ll} d'un projet. Il sont tous désignés par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.

Les opérations effectuées sont les suivantes~:
\begin{itemize}
  \item les fichiers sont lus et concaténés dans leur ordre d'apparition dans l'entrée \texttt{LL\_FILES}~:
  \item la chaîne résultat constitue le début du fichier source assembleur \texttt{src.ll} du projet~; PLM y ajoute ensuite le texte LLVM provenant de la compilation des sources PLM.
\end{itemize}













\subsectionLabel{\texttt{PLM\_FILES}}{configurationFichiersPLM}\index{PLM\_FILES}

\begin{PLM}
PLM_FILES:
  "../plm-registers-mk20dx256.plm",
  "../plm-teensy-3-1-boot.plm",
  "../plm-teensy-3-1-xtr.plm",
  "../plm-teensy-3-1-digital-io.plm",
  "../plm-teensy-3-1-lcd.plm",
  "../plm-teensy-3-1-panic.plm",
  "../../plm-semaphore.plm"
\end{PLM}

Cette entrée liste tous les fichiers PLM qui sont automatiquement inclus lors de la compilation d'un projet. Il sont tous désignés par un chemin relatif par rapport au répertoire qui contient le fichier de configuration \texttt{+config.plm-target}.







\subsectionLabel{\texttt{INTERRUPT\_HANDLER}}{configurationInterruptHandler}\index{INTERRUPT\_HANDLER}

\begin{PLM}
INTERRUPT_HANDLER:
  "../xtr-interrupt-handler.s" ;
  32 ; // Cortex M4 saves 8 regs in user stack on interrupt
  "../undefined-interrupt.s"
\end{PLM}

Le premier argument définit le handler d'interruption, qui est engendré pour chaque interruption qui s'exécute en mode \plm=service=\footnote{Le compilateur PLM prend complètement en charge la compilation d'une routine d'interruption déclarée avec le qualificatif \texttt{section} ou  \texttt{safe}.} (c'est-à-dire déclarée avec le qualificatif \plm=service=\index{isr!service}, \refSubsectionPage{definirRoutineInterruption}). Les opérations effectuées sont les suivantes~:
\begin{itemize}
  \item pour chaque interruption qui s'exécute en mode \plm=service=, le fichier est lu~:
  \item deux substitutions sont effectuées dans la chaîne obtenue~:
  \begin{itemize}
    \item \texttt{!ISR!} est remplacé par le nom assembleur du handler assembleur~;
    \item \texttt{!HANDLER!} est remplacé par le nom assembleur de la routine issue de la compilation PLM de la routine d'interruption~;
  \end{itemize}
  \item la chaîne résultat est ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}



Le deuxième argument (ici \plm=32=) est le nombre d'octets empilés dans le pile d'une tâche lorsqu'une interruption survient.



Le dernier paramètre est utilisé uniquement quand le projet est compilé sans engendrer le code de panique. Il définit le handler pour toute interruption non définie en PLM\footnote{Quand un projet est compilé avec le code de panique, le compilateur PLM prend en charge les interruptions non définies.}. Les opérations effectuées sont les suivantes~:
\begin{itemize}
  \item pour chaque interruption indéfinie, le fichier \texttt{../undefined-interrupt.s} est lu~:
  \item une substitution est effectuée dans la chaîne obtenue~:
  \begin{itemize}
    \item \texttt{!ISR!} est remplacé par le nom assembleur du handler assembleur~;
  \end{itemize}
  \item la chaîne résultat est ajoutée au fichier source assembleur \texttt{src.s} du projet.
\end{itemize}








\subsectionLabel{\texttt{INTERRUPTS}}{configurationInterrupts}\index{INTERRUPTS}

\begin{PLM}
INTERRUPTS:
  NMI -> 2,
  MemManage -> 4,
  BusFault -> 5,
  UsageFault -> 6,
  ...
  pinDetectPortD -> 106,
  pinDetectPortE -> 107,
  softwareInterrupt -> 110
\end{PLM}


La liste de toutes les interruptions, chacune d'elle étant accompagnée de son numéro. Celui-ci est utilisé lors de la panique, si une interruption se déclenche alors qu'aucune routine de réponse à cette interruption n'est installée.






\sectionLabel{Schéma d'appel des sections}{schemaAppelSectionsViaSystemCall}

Est présenté ici comment sont implémentées les sections, dont l'appel à partir des tâches s'effectue via un \emph{system call}\footnote{Quand une section est appelée à partir d'un mode privilégié, l'appel est un simple appel de routine.}. c'est le cas de la cible \texttt{teensy-3-1/unprivileged}, que nous prenons comme exemple tout au long des explications.

L'implémentation de cette opération est paramètrable grâce à quatre fichiers assembleurs, comme expliqué à la \refSubsubsectionTitlePage{configurationSectionAppelSysteme}~:
\begin{itemize}
  \item \texttt{udfcoded-section-dispatcher-code.s}~: implémentation du code exécuté par l'appel système invoqué par l'appel à une section~;
  \item \texttt{udfcoded-section-dispatcher-entry.s}~: entrée du tableau définissant le nom de la fonction implémentant la section~;
  \item \texttt{udfcoded-section-dispatcher-header.s}~: en-tête du tableau contenant les noms de la fonction implémentant la section~;
  \item \texttt{udfcoded-section-invocation.s}~: implémentation de l'appel à une section. 
\end{itemize}

Il suffit donc de changer ces fichiers assembleur pour modifier le schéma d'appel. En fait, trois schémas sont possibles pour la cible \texttt{teensy-3-1/unprivileged} : \texttt{udfcoded} (celui utilisé), \texttt{r12idx} et \texttt{r12direct}, et sont décrits dans les sections suivantes. Le \refTableauPage{dureeSchemasServices} résume les caractéristiques de chacun. Les durées sont estimées grâce au projet \texttt{04-section-service-duration.plm}. 

\begin{table}[t]
\centering
\begin{tabular}{llll}
  \textbf{Nom du schéma} & \textbf{Par entrée} & \textbf{\texttt{as\_section\_handler}} & \textbf{Durée estimée} \\
   & (octets) & (octets) & (en cycles d'horloge) \\
  \texttt{udfcoded} & 4 + 4 & 40 & 64 \\
  \texttt{r12idx} & 8 + 4 & 36 & 65 \\
  \texttt{r12direct} & 12 + 0 & 24 & 61 \\
\end{tabular}
\caption{Caractéristiques de différents schémas d'appel de section}
\labelTableau{dureeSchemasServices}
\ligne
\end{table}


\subsection{Schéma \texttt{udfcoded} d'appel des sections}

Dans ce schéma, l'instruction indéfinie \texttt{UDF} est utilisée. Le code de cette instruction est \texttt{0xDE$xx$}, où $xx$ est une valeur que le Cortex ignore. On utilise ce champ pour coder l'indice du service appelé.

Pour coder l'appel relatif à une section, PLM va utiliser le fichier \texttt{udfcoded-section-invocation.s}. Le contenu de fichier est~:
\begin{SHELL}\small
\hspace*{1.2em}.section  ".text.!USER\_ROUTINE!","ax",\%progbits\\
\hspace*{1.2em}.global !USER\_ROUTINE!\\
\hspace*{1.2em}.type  !USER\_ROUTINE!,\%function\\
\hspace*{1.2em}.align  1\\
\hspace*{1.2em}.code  16\\
\hspace*{1.2em}.thumb\_func\\
\\
!USER\_ROUTINE!:\\
\hspace*{1.2em}.fnstart\\
\hspace*{1.2em}udf !IDX!\\
\hspace*{1.2em}bx  lr\\
\\
.Lfunc\_end\_!USER\_ROUTINE!:\\
\hspace*{1.2em}.size  !USER\_ROUTINE!, .Lfunc\_end\_!USER\_ROUTINE! - !USER\_ROUTINE!\\
\hspace*{1.2em}.cantunwind\\
\hspace*{1.2em}.fnend
\end{SHELL}

Trois séquences sont remplacées par le compilateur PLM~:
\begin{itemize}
\item \zeroEspaceAvantPonctuation{!USER\_ROUTINE!}, par le nom assembleur de la fonction qui implémente l'appel de la section en mode utilisateur~;
\item \zeroEspaceAvantPonctuation{!IMPLEMENTATION\_ROUTINE!}, par le nom assembleur de la fonction qui implémente la section (inutilisée dans ce shéma)~;
\item \zeroEspaceAvantPonctuation{!IDX!}, par l'indice de la section\footnote{Lorsqu'il analyse un projet, PLM numérote les sections qu'il rencontre (à partir de $0$). C'est ce numéro qui remplace la séquence \zeroEspaceAvantPonctuation{!IDX!}.}.
\end{itemize}

PLM effectue donc cette opération pour chaque section, par ordre croissant de l'indice, et accumule le texte produit dans le fichier assembleur \texttt{src.s}.

Donc, quand une instruction \texttt{UDF} est rencontrée, le Cortex exécute l'exception n°3, qui renvoie vers \texttt{as\_section\_handler}\footnote{Ce qui est défini dans le fichier \texttt{s-interrupt-vectors.s} de la cible qui décrit la table des interruptions (voir \refSubsectionTitlePage{configurationFichiersAssembleur}).}, défini par le fichier \texttt{udfcoded-section-dispatcher-code.s}~:

\begin{SHELL}\small
\hspace*{1.2em}.section	".text.as\_section\_handler","ax",\%progbits\\
\hspace*{1.2em}.global as\_section\_handler\\
\hspace*{1.2em}.type as\_section\_handler, \%function\\
\\
as\_section\_handler:\\
@--------------------- Save preserved registers\\
\hspace*{1.2em}push  {r5, lr}\\
@--------------------- R5 <- thread SP\\
\hspace*{1.2em}mrs   r5, psp           @ r5 <- thread SP\\
@--------------------- LR <- Address of UDF instruction\\
\hspace*{1.2em}ldr   lr, [r5, \#24]     @ 24 : 6 stacked registers before saved PC\\
@--------------------- Set return address to instruction following UDF\\
\hspace*{1.2em}adds  lr, \#2\\
\hspace*{1.2em}str   lr, [r5, \#24]\\
@--------------------- R12 <- address of dispatcher\\
\hspace*{1.2em}ldr   r12, =\_\_udf\_dispatcher\_table\\
@--------------------- LR <- bits 0-7 of UDF instruction\\
\hspace*{1.2em}ldrb  lr, [lr, \#-2]            @ LR is service call index\\
@--------------------- r12 <- address of routine to call\\
\hspace*{1.2em}ldr   r12, [r12, lr, lsl \#2]   @ Address R12 + LR << 2\\
@--------------------- Call service routine\\
\hspace*{1.2em}blx   r12                      @ R5: thread PSP\\
@--------------------- Set return code (from R0 to R3) in stacked registers\\
\hspace*{1.2em}stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\\
@--------------------- Restore preserved registers, return from interrupt\\
\hspace*{1.2em}pop   {r5, pc}
\end{SHELL}

Ce code va rechercher dans l'instruction \texttt{UDF} la valeur $xx$ de l'octet de poids faible, et l'utilise pour construire l'adresse d'une entrée du tableau \texttt{\_\_udf\_dispatcher\_table}. Cette entrée contient l'adresse de la routine à exécuter.

Remarquer ce code empile deux registres (soit 8 octets) dans la pile système~; il faut s'assurer que cette valeur correspond à la valeur du paramètre \emph{Section handler system stack byte count footprint} déclaré dans la \plm=configuration=.

Remarquer aussi que lorsque l'instruction \texttt{UDF} est exécutée, l'adresse de retour empilée est l'adresse de l'instruction \texttt{UDF}, et non pas l'adresse de l'instruction suivante. Il faut donc manuellement ajouter $2$ à l'adresse de retour.

Il faut donc construire ce tableau. Le fichier \texttt{udfcoded-section-dispatcher-header.s} définit son en-tête~:

\begin{SHELL}\small
\_\_udf\_dispatcher\_table:
\end{SHELL}

Ce texte est ajouté à la fin du fichier assembleur \texttt{src.s}.

Ensuite, PLM va utiliser le fichier \texttt{udfcoded-section-dispatcher-entry.s} pour définir chaque entrée du tableau~:
\begin{SHELL}\small
\hspace*{1.2em}.word !IMPLEMENTATION\_ROUTINE! @ !IDX!, user routine !USER\_ROUTINE!

\end{SHELL}

PLM effectue pour chaque section les substitutions de \zeroEspaceAvantPonctuation{!IMPLEMENTATION\_ROUTINE!}, de \zeroEspaceAvantPonctuation{!USER\_ROUTINE!} et de \zeroEspaceAvantPonctuation{!IDX!}, par ordre croissant de l'indice, en ajoutant le texte produit à la fin du fichier assembleur \texttt{src.s}.










\subsection{Schéma \texttt{r12idx} d'appel des sections}

Dans ce schéma, l'instruction indéfinie \texttt{UDF} est utilisée.  Le code de cette instruction est \texttt{0xDE$xx$}, où $xx$ est une valeur que le Cortex ignore. Contrairement au shéma précédent, le champ $xx$ est toujours à $0$, l'indice de la section est entré dans le registre \texttt{r12}\footnote{L'ABI considère le registre \texttt{r12} comme l'\emph{Intra-Procedure-call scratch register}~: \emph{register r12 (IP) may be used by a linker as a scratch register between a routine and any subroutine it calls}.}.

Pour coder l'appel relatif à une section, PLM va utiliser le fichier \texttt{r12idx-section-invocation.s}. Le contenu de fichier est~:
\begin{SHELL}\small
\hspace*{1.2em}.section  ".text.!USER\_ROUTINE!","ax",\%progbits\\
\hspace*{1.2em}.global !USER\_ROUTINE!\\
\hspace*{1.2em}.type  !USER\_ROUTINE!,\%function\\
\hspace*{1.2em}.align  1\\
\hspace*{1.2em}.code  16\\
\hspace*{1.2em}.thumb\_func\\
\\
!USER\_ROUTINE!:\\
\hspace*{1.2em}.fnstart\\
\hspace*{1.2em}mov r12, !IDX!\\
\hspace*{1.2em}udf 0\\
\hspace*{1.2em}bx  lr\\
\\
.Lfunc\_end\_!USER\_ROUTINE!:\\
\hspace*{1.2em}.size  !USER\_ROUTINE!, .Lfunc\_end\_!USER\_ROUTINE! - !USER\_ROUTINE!\\
\hspace*{1.2em}.cantunwind\\
\hspace*{1.2em}.fnend
\end{SHELL}

Trois séquences sont remplacées par le compilateur PLM~:
\begin{itemize}
\item \zeroEspaceAvantPonctuation{!USER\_ROUTINE!}, par le nom assembleur de la fonction qui implémente l'appel de la section en mode utilisateur~;
\item \zeroEspaceAvantPonctuation{!IMPLEMENTATION\_ROUTINE!}, par le nom assembleur de la fonction qui implémente la section (inutilisée dans ce shéma)~;
\item \zeroEspaceAvantPonctuation{!IDX!}, par l'indice de la section\footnote{Lorsqu'il analyse un projet, PLM numérote les sections qu'il rencontre (à partir de $0$). C'est ce numéro qui remplace la séquence \zeroEspaceAvantPonctuation{!IDX!}.}.
\end{itemize}

PLM effectue donc cette opération pour chaque section, par ordre croissant de l'indice, et accumule le texte produit dans le fichier assembleur \texttt{src.s}.

Donc, quand une instruction \texttt{UDF} est rencontrée, le Cortex exécute l'exception n°3, qui renvoie vers \texttt{as\_section\_handler}, défini par le fichier \texttt{r12idx-section-dispatcher-code.s}~:

\begin{SHELL}\small
\hspace*{1.2em}.section	".text.as\_section\_handler","ax",\%progbits\\
\hspace*{1.2em}.global as\_section\_handler\\
\hspace*{1.2em}.type as\_section\_handler, \%function\\
\\
as\_section\_handler:\\
@--------------------- Save preserved registers\\
\hspace*{1.2em}push  {r5, lr}\\
@--------------------- R5 <- thread SP\\
\hspace*{1.2em}mrs   r5, psp           @ r5 <- thread SP\\
@--------------------- LR <- Address of UDF instruction\\
\hspace*{1.2em}ldr   lr, [r5, \#24]     @ 24 : 6 stacked registers before saved PC\\
@--------------------- Set return address to instruction following UDF\\
\hspace*{1.2em}adds  lr, \#2\\
\hspace*{1.2em}str   lr, [r5, \#24]\\
@--------------------- LR <- address of dispatcher table\\
\hspace*{1.2em}ldr   lr, =\_\_udf\_dispatcher\_table\\
@--------------------- r12 <- address of routine to call\\
\hspace*{1.2em}ldr   r12, [lr, r12, lsl \#2]   @ Address : LR + R12 << 2\\
@--------------------- Call service routine\\
\hspace*{1.2em}blx   r12                      @ R5: thread PSP\\
@--------------------- Set return code (from R0 to R3) in stacked registers\\
\hspace*{1.2em}stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\\
@--------------------- Restore preserved registers, return from interrupt\\
\hspace*{1.2em}pop   {r5, pc}
\end{SHELL}

Ce code va utiliser la valeur \texttt{r12} pour construire l'adresse d'une entrée du tableau \texttt{\_\_udf\_dispatcher\_table}. Cette entrée contient l'adresse de la routine à exécuter.

Remarquer ce code empile deux registres (soit 8 octets) dans la pile système~; il faut s'assurer que cette valeur correspond à la valeur du paramètre \emph{Section handler system stack byte count footprint} déclaré dans la \plm=configuration=.

Il faut donc construire ce tableau\footnote{Les fichiers \texttt{r12idx-section-dispatcher-header.s} et \texttt{r12idx-section-dispatcher-entry.s} sont identiques à ceux du schéma précédent \texttt{"udfcoded"}.}. Le fichier \texttt{r12idx-section-dispatcher-header.s} définit son en-tête~:

\begin{SHELL}\small
\_\_udf\_dispatcher\_table:
\end{SHELL}

Ce texte est ajouté à la fin du fichier assembleur \texttt{src.s}.

Ensuite, PLM va utiliser le fichier \texttt{r12idx-section-dispatcher-entry.s} pour définir chaque entrée du tableau~:
\begin{SHELL}\small
\hspace*{1.2em}.word !IMPLEMENTATION\_ROUTINE! @ !IDX!, user routine !USER\_ROUTINE!

\end{SHELL}

PLM effectue pour chaque section les substitutions de \zeroEspaceAvantPonctuation{!IMPLEMENTATION\_ROUTINE!}, de \zeroEspaceAvantPonctuation{!USER\_ROUTINE!} et de \zeroEspaceAvantPonctuation{!IDX!}, par ordre croissant de l'indice, en ajoutant le texte produit à la fin du fichier assembleur \texttt{src.s}.











\subsection{Schéma \texttt{r12direct} d'appel des sections}

Dans ce schéma, l'instruction indéfinie \texttt{UDF} est utilisée. L'adresse de la routine implémentant la section est entrée dans le registre \texttt{r12}.

Pour coder l'appel relatif à une section, PLM va utiliser le fichier \texttt{r12direct-section-invocation.s}. Le contenu de fichier est~:
\begin{SHELL}\small
\hspace*{1.2em}.section  ".text.!USER\_ROUTINE!","ax",\%progbits\\
\hspace*{1.2em}.global !USER\_ROUTINE!\\
\hspace*{1.2em}.type  !USER\_ROUTINE!,\%function\\
\hspace*{1.2em}.align  1\\
\hspace*{1.2em}.code  16\\
\hspace*{1.2em}.thumb\_func\\
\\
!USER\_ROUTINE!:\\
\hspace*{1.2em}.fnstart\\
\hspace*{1.2em}movw  r12, :lower16:!IMPLEMENTATION\_ROUTINE!\\
\hspace*{1.2em}movt  r12, :upper16:!IMPLEMENTATION\_ROUTINE!\\
\hspace*{1.2em}udf 0\\
\hspace*{1.2em}bx  lr\\
\\
.Lfunc\_end\_!USER\_ROUTINE!:\\
\hspace*{1.2em}.size  !USER\_ROUTINE!, .Lfunc\_end\_!USER\_ROUTINE! - !USER\_ROUTINE!\\
\hspace*{1.2em}.cantunwind\\
\hspace*{1.2em}.fnend
\end{SHELL}

Trois séquences sont remplacées par le compilateur PLM~:
\begin{itemize}
\item \zeroEspaceAvantPonctuation{!USER\_ROUTINE!}, par le nom assembleur de la fonction qui implémente l'appel de la section en mode utilisateur~;
\item \zeroEspaceAvantPonctuation{!IMPLEMENTATION\_ROUTINE!}, par le nom assembleur de la fonction qui implémente la section~;
\item \zeroEspaceAvantPonctuation{!IDX!}, par l'indice de la section (inutilisé dans ce shéma).
\end{itemize}

PLM effectue donc cette opération pour chaque section, par ordre croissant de l'indice, et accumule le texte produit dans le fichier assembleur \texttt{src.s}.

Donc, quand une instruction \texttt{UDF} est rencontrée, le Cortex exécute l'exception n°3, qui renvoie vers \texttt{as\_section\_handler}, défini par le fichier \texttt{r12direct-section-dispatcher-code.s}~:

\begin{SHELL}\small
\hspace*{1.2em}.section	".text.as\_section\_handler","ax",\%progbits\\
\hspace*{1.2em}.global as\_section\_handler\\
\hspace*{1.2em}.type as\_section\_handler, \%function\\
\\
as\_section\_handler:\\
@--------------------- Save preserved registers\\
\hspace*{1.2em}push  {r5, lr}\\
@--------------------- R5 <- thread SP\\
\hspace*{1.2em}mrs   r5, psp           @ r5 <- thread SP\\
@--------------------- LR <- Address of UDF instruction\\
\hspace*{1.2em}ldr   lr, [r5, \#24]     @ 24 : 6 stacked registers before saved PC\\
@--------------------- Set return address to instruction following UDF\\
\hspace*{1.2em}adds  lr, \#2\\
\hspace*{1.2em}str   lr, [r5, \#24]\\
@--------------------- Call service routine\\
\hspace*{1.2em}blx   r12                      @ R5: thread PSP\\
@--------------------- Set return code (from R0 to R3) in stacked registers\\
\hspace*{1.2em}stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\\
@--------------------- Restore preserved registers, return from interrupt\\
\hspace*{1.2em}pop   {r5, pc}
\end{SHELL}

Ce code utilise directement la valeur \texttt{r12}, c'est l'adresse de la routine à exécuter. Remarquer ce code empile deux registres (soit 8 octets) dans la pile système~; il faut s'assurer que cette valeur correspond à la valeur du paramètre \emph{Section handler system stack byte count footprint} déclaré dans la \plm=configuration=.


Les fichiers \texttt{r12direct-section-dispatcher-header.s} et \texttt{r12direct-section-dispatcher-entry.s} sont inutiles pour ce schéma, et sont donc vides.




