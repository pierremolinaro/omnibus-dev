%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Configuration d'une cible}{chapitreConfCible}






\sectionLabel{Exemple de définition de cible}{exempleDefinitionCible}

Une cible est définie par une arborescence de fichiers, soit embarquée dans le compilateur, soit situé dans le système de fichiers. On va voir dans cette partie comment est configurée une cible dans le système de fichiers, permettant ainsi de créer ses propres cibles. Pour cela, on va extraire de l'exécutable du compilateur les cibles qu'il embarque.

À titre d'information, on peut appeler l'option \texttt{-L} pour obtenir la liste des cibles embarquées :
\begin{SHELL}
{\bfseries plm -L}\\
Embedded targets:\\ 
\hspace*{1.2em}teensy-3-1-interrupt.plms\\
\hspace*{1.2em}teensy-3-1-sequential-systick.plms\\
\hspace*{1.2em}...
\end{SHELL}

L'option \texttt{-X} permet d'extraire de l'exécutable du compilateur tous les fichiers de définition des cibles et de les placer dans le répertoire \texttt{cibles}\footnote{Ici, le répertoire destination \texttt{cibles} est un répertoire relatif au répertoire courant, mais un répertoire absolu peut aussi être utilisé.} :
\begin{SHELL}
{\bfseries plm -X=cibles}\\
\hspace*{1.2em}cibles/makef{}ile.py\\
\hspace*{1.2em}cibles/teensy-3-1-interrupt.plms\\
\hspace*{1.2em}cibles/teensy-3-1-sequential-systick.plms\\
\hspace*{1.2em}cibles/microcontrollers/boot-teensy-3-1.plm\\
\hspace*{1.2em}...
\end{SHELL}

On extrait maintenant un fichier d'exemple \texttt{01-blinkled.plm} pour la cible \texttt{teensy-3-1-sequential-systick} :
\begin{SHELL}
\bfseries plm -x=/teensy-3-1-sequential-systick/01-blinkled.plm
\end{SHELL}

Le fichier \texttt{01-blinkled.plm} est écrit dans le répertoire local. Maintenant, pour compiler ce fichier, on peut faire référence aux cibles que l'on vient d'extraire au moyen de l'option \texttt{-T} :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}



















\sectionLabel{Déclaration \texttt{newUnsignedRepresentation}}{DefNewUnsignedRepresentation}
\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=!Definition@Définition}

La déclaration \plm=newUnsignedRepresentation= permet de définir une représentation entière non signée. Sa syntaxe est la suivante :


\begin{PLM}
newUnsignedRepresentation @nom "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@nom= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers non signés habituels peut être définie par :
\begin{PLM}
newUnsignedRepresentation @unsigned8  "uint8_t"   8
newUnsignedRepresentation @unsigned16 "uint16_t" 16
newUnsignedRepresentation @unsigned32 "uint32_t" 32
newUnsignedRepresentation @unsigned64 "uint64_t" 64
\end{PLM}








\sectionLabel{Déclaration \texttt{newSignedRepresentation}}{DefNewSignedRepresentation}
\index{newSignedRepresentation@\plm=newSignedRepresentation=!Definition@Définition}

La déclaration \plm=newSignedRepresentation= permet de définir une représentation entière signée. Sa syntaxe est la suivante :


\begin{PLM}
newSignedRepresentation @representation "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@representation= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers signés habituels peut être définie par :
\begin{PLM}
newSignedRepresentation @signed8  "int8_t"   8
newSignedRepresentation @signed16 "int16_t" 16
newSignedRepresentation @signed32 "int32_t" 32
newSignedRepresentation @signed64 "int64_t" 64
\end{PLM}











\sectionLabel{Déclaration \texttt{newIntegerType}}{DefNewIntegerType}
\index{newIntegerType@\plm=newIntegerType=!Definition@Définition}

La déclaration \plm=newIntegerType= permet de définir un nouveau type entier signé ou non signé. Elle a la syntaxe suivante :
\begin{PLM}
newIntegerType NomDeType @representation
\end{PLM}
Où :
\begin{itemize}
  \item \plm=NomDeType= est le nom donné au type entier.
  \item \plm=@representation= est le nom de la représentation, qui doit avoir été défini soit par une déclaration \plm=newUnsignedRepresentation= (\refSectionPage{DefNewUnsignedRepresentation})\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=}, soit par une déclaration \plm=newSignedRepresentation= (\refSectionPage{DefNewSignedRepresentation}\index{newSignedRepresentation@\plm=newSignedRepresentation=}).
\end{itemize}

Le type entier ainsi déclaré est non signé si la représentation est non signée (c'est-à-dire déclarée avec \plm=newUnsignedRepresentation=), et signé si la représentation est signée (c'est-à-dire déclarée avec \plm=newSignedRepresentation=). Les types usuels peuvent ainsi être déclarés :
\begin{PLM}
newIntegerType UInt8  @unsigned8
newIntegerType UInt16 @unsigned16
newIntegerType UInt32 @unsigned32
newIntegerType UInt64 @unsigned64
newIntegerType Int8  @signed8
newIntegerType Int16 @signed16
newIntegerType Int32 @signed32
newIntegerType Int64 @signed64
\end{PLM}





\sectionLabel{\texttt{boot} routines}{bootRoutine}
\index{boot@\plm=boot=!Routine}
\index{Routine!boot@\plm=boot=}

Une routine \plm=boot= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, avant que les variables globales ne soient initialisées. Elle a la syntaxe suivante :
\begin{PLM}
boot priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=boot= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=boot= n'ont pas la même priorité.

Les routines \plm=boot= s'exécutent dans le mode \plm=$boot=.\index{\$boot}

Comme les routines \plm=boot= s'exécutent avant que les variables globales soient initialisées, l'accès aux variables globales y est interdit. L'interdiction est mise en place de la façon suivante : il n'est pas possible d'associer le mode \plm=$boot= à une variable globale lors de sa déclaration (\refSectionPage{declarationVariableGlobale}).

Par contre, l'accès aux registres de contrôle est autorisé dans une routine \plm=boot= (d'ailleurs, elle sert à cela : configurer le micro-contrôleur au démarrage).







\sectionLabel{\texttt{init} routines}{initRoutine}
\index{init@\plm=init=!Routine}
\index{Routine!init@\plm=init=}

Une routine \plm=init= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, après l'initialisation des variables globales. Elle a la syntaxe suivante :
\begin{PLM}
init priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=init= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=init= n'ont pas la même priorité.

Les routines \plm=init= s'exécutent dans le mode \plm=$init=.\index{\$init}

Comme les routines \plm=init= s'exécutent après l'initialisation des variables globales, l'accès aux variables globales y est autorisé, du moment que la variable globale cite le mode \plm=$init= dans sa déclaration (\refSectionPage{declarationVariableGlobale}).


\sectionLabel{Séquence de démarrage du micro-contrôleur}{demarrageMicro}

\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=5mm
    ]
    \node [cloud] (start) {\textsc{Démarrage}} ;
    \node [block] (boot) [below=of start] {Routines \bf\texttt{boot}} ;
    \node [block] (raz) [below=of boot] {Initialisation des variables globales} ;
    \node [block] (init) [below=of raz] {Routines \bf\texttt{init}} ;
    \node [block] (setup) [below=of init] {Procédure \texttt{setup}} ;
    \node [block] (loop) [below=of setup] {Procédure \texttt{loop}} ;

    \draw [-stealth, thick] (start) -- (boot) ;
    \draw [-stealth, thick] (boot) -- (raz) ;
    \draw [-stealth, thick] (raz) -- (init) ;
    \draw [-stealth, thick] (init) -- (setup) ;
    \draw [-stealth, thick] (setup) -- (loop) ;
    \draw [-stealth, thick] (loop.south) -- +(0, -.25) -- +(1.7, -.25) -- +(1.7, 0.8)-- +(0, 0.8) ;
  \end{tikzpicture}
  \caption{Organigramme de la séquence de démarrage}
  \labelFigure{sequenceDemarrage}
  \ligne
\end{figure}


