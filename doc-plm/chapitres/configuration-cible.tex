%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Définition d'une cible}{chapitreConfCible}

Dans ce chapitre, nous allons voir comment est définie une cible, en prenant pour exemple la cible \texttt{teensy-3-1-it}. 

Si vous voulez définir votre propre cible, la lecture de ce chapitre est indispensable. 

Le compilateur recherche la cible citée :
\begin{itemize}
  \item par défaut, parmi les fichiers qu'il embarque ;
  \item si l'option \texttt{-T=$cibles$} est présente dans la ligne de commande, dans les fichiers du répertoire $cibles$.
\end{itemize}

Pour explorer les fichiers indispensables à la définition d'une cible, il est nécessaire de les placer dans le système de fichiers. La première section de ce chapitre (\refSectionPage{cibleDansSystemeFichiers}) va donc indiquer comment extraire de l'exécutable les fichiers de définition des cibles, et comment les exploiter.

%\minitoc

\sectionLabel{Utilisation d'une cible dans le système de fichiers}{cibleDansSystemeFichiers}

Une cible est définie par une arborescence de fichiers, soit embarquée dans le compilateur, soit situé dans le système de fichiers. On va voir dans cette section comment est configurée une cible dans le système de fichiers, permettant ainsi de créer ses propres cibles. Pour cela, on commence par extraire de l'exécutable du compilateur les cibles qu'il embarque.

\subsection{Liste des cibles embarquées}
À titre d'information, on peut appeler l'option \texttt{-L} pour obtenir la liste des cibles embarquées :
\begin{SHELL}
{\bfseries plm -L}\\
Embedded targets:\\ 
\hspace*{1.2em}teensy-3-1-it\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction des cibles embarquées}
L'option \texttt{-X=cibles} permet d'extraire de l'exécutable du compilateur tous les fichiers de définition des cibles et de les placer dans le répertoire \texttt{cibles}\footnote{Ici, le répertoire destination \texttt{cibles} est un répertoire relatif au répertoire courant, mais un répertoire absolu peut aussi être utilisé.} :
\begin{SHELL}
{\bfseries plm -X=cibles}\\
\hspace*{1.2em}cibles/makef{}ile.py\\
\hspace*{1.2em}cibles/teensy-3-1-it.plm-target\\
\hspace*{1.2em}cibles/files/boot-teensy-3-1-it.plm\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction d'un fichier d'exemple}
On extrait maintenant un fichier d'exemple \texttt{01-blinkled.plm} pour la cible \texttt{teensy-3-1-it} :
\begin{SHELL}
\bfseries plm -x=/teensy-3-1-it/01-blinkled.plm
\end{SHELL}

\subsection{Compilation du fichier exemple}
Le fichier \texttt{01-blinkled.plm} est écrit dans le répertoire local. Maintenant, pour compiler ce fichier, on peut faire référence aux cibles que l'on vient d'extraire au moyen de l'option \texttt{-T} :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}


\subsection{Changement du nom de la cible dans le système de fichiers}

Pour se convaincre que la cible nommée dans le fichier est bien celle située dans le répertoire \texttt{cibles}, nous allons changer son nom. Pour cela, nous devons modifier :
\begin{itemize}
  \item la référence à la cible dans le fichier \texttt{01-blinkled.plm} ;
  \item le nom d'un fichier et d'un répertoire dans le répertoire \texttt{cibles}. 
\end{itemize}

Commençons par le fichier \texttt{01-blinkled.plm}. Sa première ligne est :
\begin{PLM}[1]
target "teensy-3-1-it"
\end{PLM}

Cette ligne signifie que la cible s'appelle \texttt{teensy-3-1-it}. Nous allons la renommer en \texttt{myTeensy}. La première ligne du fichier \texttt{01-blinkled.plm} devient donc :

\begin{PLM}[1]
target "myTeensy"
\end{PLM}

Maintenant, si on essaie de compiler le fichier \texttt{01-blinkled.plm}, une erreur se déclenche : la cible \texttt{myTeensy} n'est pas définie. Pour la définir, listons le contenu le répertoire \texttt{cibles} :
\begin{SHELL}
{\bfseries ls -1F cibles}\\
f{}iles/\\
makef{}ile.py\\
...\\
teensy-3-1-it/\\
teensy-3-1-it.plm-target\\
...
\end{SHELL}

Le répertoire \texttt{f{}iles} et le fichier \texttt{makef{}ile.py} seront présentés plus loin. Chaque cible est définie par un répertoire et un fichier, dont l'extension est \texttt{plm-target}. Nous allons donc effectuer les renommages suivants :
\begin{itemize}
  \item le répertoire \texttt{teensy-3-1-it} est renommé en \texttt{myTeensy} ;
  \item le fichier \texttt{teensy-3-1-it.plm-target} en \texttt{myTeensy.plm-target}.
\end{itemize}

À présent, la compilation s'effectue avec succès :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}

Si on essaie de compiler en utilisant les cibles embarquées dans le compilateur :
\begin{SHELL}
\bfseries plm 01-blinkled.plm
\end{SHELL}

Une erreur se déclenche, la cible \texttt{myTeensy} n'étant pas définie dans l'exécutable du compilateur.






\sectionLabel{Comment est définie une cible}{exempleDefinitionCible}

Nous allons décrire comment est définie une cible dans le système de fichiers. Nous prenons comme exemple la cible \texttt{myTeensy} du répertoire \texttt{cibles} (voir la \refSectionPage{cibleDansSystemeFichiers}).

Pour la cible \texttt{myTeensy} :
\begin{itemize}
  \item le fichier \texttt{myTeensy.plm-target} permet de paramétrer l'analyse sémantique ;
  \item le répertoire \texttt{myTeensy} permet de configurer la génération de code.
\end{itemize}

On va explorer successivement le fichier \texttt{myTeensy.plm-target} puis le répertoire \texttt{myTeensy}.











\subsectionLabel{Le fichier \texttt{myTeensy.plm-target}}{fichierTarget}

Voici le contenu du fichier \texttt{myTeensy.plm-target} :
\begin{PLM}[1]
signedIntegerType 1 -> 128
unsignedIntegerType 1 -> 128

pointerSize 32

exception : $int32 $uint32

mode `isr
mode `user

import "files/mk20dx256.plm"
import "files/boot-teensy-3-1-it.plm"

required proc systickHandler `isr ()
required proc setup `user ()
required proc loop `user ()

proc systickHandler `isr @weak () {
}

init 0 { // Configure Systick interrupt every ms
  SYST_RVR = 96000 - 1 // Interrupt every 96000 core clocks, i.e. every ms
  SYST_CVR = 0
  SYST_CSR = SYST_CSR::CLKSOURCE | SYST_CSR::TICKINT | SYST_CSR::ENABLE
}
\end{PLM}
%\ligne\\

{\bf Ligne 1.} Cette déclaration définit les type entiers signés de \plm!$int1! à \plm!$int128!.


{\bf Ligne 2.} Cette déclaration définit les type entiers non signés de \plm!$uint1! à \plm!$uint128!.


{\bf Ligne 4.} Définition de la taille d'un pointeur, en nombre de bits.


{\bf Ligne 6.} Déclaration des types entier relatifs aux exceptions (\refSectionPage{typeLiesException}). Le premier type définit le type du code de l'exception (\plm+$int32+, dont un code d'exception peut être négatif, positif, ou nul), le second le type du numéro de ligne (\plm+$uint32+, un numéro de ligne est positif). Cette déclaration est obligatoire.

{\bf Lignes 8 et 9.} Déclaration des modes complémentaires, propres à la cible. Trois modes sont prédéfinis : \plm+`boot+, \plm+`init+ et \plm=`panic= (\refSectionPage{modesPredefinis}). Ces déclarations sont optionnelles, en leur absence seuls les trois modes prédéféfinis existent.


{\bf Lignes 11 et 12.} Importation de fichiers source. Le fichier \texttt{mk20dx256.plm} contient la définition des registres de contrôle du processeur qui équipe la carte \emph{Teensy 3.1}, \texttt{boot-teensy-3-1-it.plm} contient le code de configuration du processeur (routine \plm=boot 0=). Si l'appel du compilateur contient l'option \texttt{-T=cibles} (par exemple : \texttt{plm -T=cibles 01-blinkled.plm}), alors, ces fichiers sont recherchés dans le système de fichiers, relativement au répertoire \texttt{cibles}.Si l'appel du compilateur ne contient pas l'option \texttt{-T} (par exemple : \texttt{plm 01-blinkled.plm}), alors, ces fichiers sont recherchés parmi les fichiers embarqués dans l'exécutable.



{\bf Lignes 14 à 16.} Déclaration des procédures requises (\refSubsectionPage{procedureRequise}). Ces déclarations ont une double signification :
\begin{itemize}
  \item d'abord, que les procédures citées doivent être définies soit dans la cible (c'est le cas de \texttt{systickHandler}), soit dans le code utilisateur (ici \texttt{01-blinkled.plm}) : c'est le cas des procédures \texttt{setup} et \texttt{loop} ;
  \item ensuite, le compilateur calcule le graphe des appels des routines, afin de supprimer les routines inutilisées ; les procédures requises sont les racines du graphe d'accessibilité.
\end{itemize}

{\bf Lignes 18 et 19.} Déclaration de la procédure \texttt{systickHandler}. Elle s'exécute dans le mode \plm=`isr=, c'est donc une routine d'interruption. Elle est déclarée avec l'attribut \plm=@weak= (\refSubsectionPage{attributWeak}), c'est-à-dire qu'une procédure de même nom peut être déclarée, qui va remplacer celle-ci. Cette déclaration définit donc la routine par défaut.

{\bf Lignes 21 à 25.} Définition de la routine \plm=init 0= (\refSectionPage{initRoutine}). Le code de cette routine configure le \emph{SysTick Timer} de façon qu'une interruption \emph{SysTick} survienne toutes les millisecondes. Comme cette routine porte le numéro $0$, on est sûr qu'elle soit la première à être exécutée.






\subsection{Le répertoire \texttt{myTeensy}}

Texte à définir…






