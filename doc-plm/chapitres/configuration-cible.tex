%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapterLabel{Configuration d'une cible}{chapitreConfCible}






\sectionLabel{Utilisation d'une cible dans le système de fichier}{cibleDansSystemeFichiers}

Une cible est définie par une arborescence de fichiers, soit embarquée dans le compilateur, soit situé dans le système de fichiers. On va voir dans cette partie comment est configurée une cible dans le système de fichiers, permettant ainsi de créer ses propres cibles. Pour cela, on va extraire de l'exécutable du compilateur les cibles qu'il embarque.

\subsection{Liste des cibles embarquées}
À titre d'information, on peut appeler l'option \texttt{-L} pour obtenir la liste des cibles embarquées :
\begin{SHELL}
{\bfseries plm -L}\\
Embedded targets:\\ 
\hspace*{1.2em}teensy-3-1-interrupt.plms\\
\hspace*{1.2em}teensy-3-1-sequential-systick.plms\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction des cibles embarquées}
L'option \texttt{-X=cibles} permet d'extraire de l'exécutable du compilateur tous les fichiers de définition des cibles et de les placer dans le répertoire \texttt{cibles}\footnote{Ici, le répertoire destination \texttt{cibles} est un répertoire relatif au répertoire courant, mais un répertoire absolu peut aussi être utilisé.} :
\begin{SHELL}
{\bfseries plm -X=cibles}\\
\hspace*{1.2em}cibles/makef{}ile.py\\
\hspace*{1.2em}cibles/teensy-3-1-interrupt.plms\\
\hspace*{1.2em}cibles/teensy-3-1-sequential-systick.plms\\
\hspace*{1.2em}cibles/microcontrollers/boot-teensy-3-1.plm\\
\hspace*{1.2em}...
\end{SHELL}

\subsection{Extraction d'un fichier d'exemple}
On extrait maintenant un fichier d'exemple \texttt{01-blinkled.plm} pour la cible \texttt{teensy-3-1-sequential-systick} :
\begin{SHELL}
\bfseries plm -x=/teensy-3-1-sequential-systick/01-blinkled.plm
\end{SHELL}

\subsection{Compilation du fichier exemple}
Le fichier \texttt{01-blinkled.plm} est écrit dans le répertoire local. Maintenant, pour compiler ce fichier, on peut faire référence aux cibles que l'on vient d'extraire au moyen de l'option \texttt{-T} :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}


\subsection{Changement du nom de la cible dans le système de fichiers}

Pour se convaincre que la cible nommée dans le fichier est bien celle située dans le répertoire \texttt{cibles}, nous allons changer son nom. Pour cela, nous devons modifier :
\begin{itemize}
  \item la référence à la cible dans le fichier \texttt{01-blinkled.plm} ;
  \item le nom d'un fichier et d'un répertoire dans le répertoire \texttt{cibles}. 
\end{itemize}

Commençons par le fichier \texttt{01-blinkled.plm}. Sa première ligne est :
\begin{PLM}[1]
target "teensy-3-1-sequential-systick"
\end{PLM}

Cette ligne signifie que la cible s'appelle \texttt{teensy-3-1-sequential-systick}. Nous allons la renommer en \texttt{myTeensy}. La première ligne du fichier \texttt{01-blinkled.plm} devient donc :

\begin{PLM}[1]
target "myTeensy"
\end{PLM}

Maintenant, si on essaie de compiler le fichier \texttt{01-blinkled.plm}, une erreur se déclenchera : la cible \texttt{myTeensy} n'est pas définie. Pour la définir, listons le contenu le répertoire \texttt{cibles} :
\begin{SHELL}
{\bfseries ls -1F cibles}\\
f{}iles/\\
makef{}ile.py\\
...\\
teensy-3-1-sequential-systick/\\
teensy-3-1-sequential-systick.plm-target\\
...
\end{SHELL}

Le répertoire \texttt{f{}iles} et le fichier \texttt{makef{}ile.py} seront présentés plus loin. Chaque cible est définie par un répertoire et un fichier, dont l'extension est \texttt{plm-target}. Nous allons donc effectuer les renommages suivants :
\begin{itemize}
  \item le répertoire \texttt{teensy-3-1-sequential-systick} est renommé en \texttt{myTeensy} ;
  \item le fichier \texttt{teensy-3-1-sequential-systick.plm-target} en \texttt{myTeensy.plm-target}.
\end{itemize}

À présent, la compilation s'effectue avec succès :
\begin{SHELL}
\bfseries plm -T=cibles 01-blinkled.plm
\end{SHELL}

Si on essaie de compiler en utilisant les cibles embarquées dans le compilateur :
\begin{SHELL}
\bfseries plm 01-blinkled.plm
\end{SHELL}

Une erreur se déclenche, la cible \texttt{myTeensy} n'étant pas définie dans l'exécutable du compilateur.






\sectionLabel{Comment est définie une cible}{exempleDefinitionCible}

Nous allons décrire comment est définie une cible dans le système de fichiers. Nous prenons comme exemple la cible \texttt{myTeensy} du répertoire \texttt{cibles} (voir la \refSectionPage{cibleDansSystemeFichiers}).

Pour la cible \texttt{myTeensy} :
\begin{itemize}
  \item le fichier \texttt{myTeensy.plm-target} permet de paramétrer l'analyse sémantique ;
  \item le répertoire \texttt{myTeensy} permet de configurer la génération de code.
\end{itemize}

On va explorer successivement le fichier \texttt{myTeensy.plm-target} puis le répertoire \texttt{myTeensy}.

\subsection{Le fichier \texttt{myTeensy.plm-target}}

Voici le contenu du fichier \texttt{myTeensy.plm-target} :
\begin{PLM}[1]
newUnsignedRepresentation @unsigned8  "uint8_t"   8
newUnsignedRepresentation @unsigned16 "uint16_t" 16
newUnsignedRepresentation @unsigned32 "uint32_t" 32
newUnsignedRepresentation @unsigned64 "uint64_t" 64

newSignedRepresentation @signed8  "int8_t"   8
newSignedRepresentation @signed16 "int16_t" 16
newSignedRepresentation @signed32 "int32_t" 32
newSignedRepresentation @signed64 "int64_t" 64

newUnsignedRepresentation @size "uint32_t" 32

booleanType Bool @unsigned8

newIntegerType UInt8  @unsigned8
newIntegerType UInt16 @unsigned16
newIntegerType UInt32 @unsigned32
newIntegerType UInt64 @unsigned64
newIntegerType Int8  @signed8
newIntegerType Int16 @signed16
newIntegerType Int32 @signed32
newIntegerType Int64 @signed64

exception : Int32 UInt32

mode $isr
mode $user

import "files/mk20dx256.plm"
import "files/boot-teensy-3-1.plm"

required proc systickHandler $isr ()

proc systickHandler $isr @weak () {
}

init 0 { // Configure Systick interrupt every ms
  SYST_RVR = 96000 - 1 // Interrupt every 96000 core clocks, i.e. every ms
  SYST_CVR = 0
  SYST_CSR = SYST_CSR::CLKSOURCE | SYST_CSR::TICKINT | SYST_CSR::ENABLE
}

required proc setup $user ()
required proc loop $user ()
\end{PLM}
%\ligne\\

{\bf Lignes 1 à 4.} Les quatre déclarations \plm+newUnsignedRepresentation+ définissent des représentations relatives aux entiers non signés (\refSectionPage{DefNewUnsignedRepresentation}). Les représentations ainsi définies (\plm+@unsigned8+, \plm+@unsigned16+, ...) ne sont pas des types directement utilisables en PLM, mais des annotations qui paramètrent certaines déclarations, comme par exemple la déclaration des types entiers non signés lignes 15 à 18.

{\bf Lignes 6 à 9.} De manière analogue, les quatre déclarations \plm+newSignedRepresentation+ définissent des représentations relatives aux entiers signés (\refSectionPage{DefNewSignedRepresentation}). Les représentations ainsi définies (\plm+@signed8+, \plm+@signed16+, ...) ne sont pas des types directement utilisables en PLM, mais des annotations qui paramètrent certaines déclarations, comme par exemple la déclaration des types entiers signés lignes 19 à 22.

{\bf Ligne 11.} Cette ligne déclare la représentation \plm+@size+, qui est celle utilisée par défaut pour les types énumérés (\emph{référence à ajouter}). La déclaration de la représentation \plm+@size+ est obligatoire.

{\bf Ligne 13.} Déclaration du type booléen : il se nomme conventionnellement \plm+Bool+, et sa représentation est \plm+@unsigned8+, c'est-à-dire un entier non signé sur 8 bits. La déclaration d'un type booléen est obligatoire.

{\bf Lignes 15 à 22.} Déclaration des types entier, non signés et signés. Les noms \plm+UInt8+, ..., \plm+Int64+ sont les noms des types entiers directement utilisables en PLM.

{\bf Ligne 24.} Déclaration des types entier relatifs aux exceptions (\refSectionPage{typeLiesException}). Le premier type définit le type du code de l'exception (\plm+Int32+, dont un code d'exception peut être négatif, positif, ou nul), le second le type du numéro de ligne (\plm+UInt32+, un numéro de ligne est positif). Cette déclaration est obligatoire.

{\bf Lignes 26 et 27.} Déclaration de mode.





\subsection{Le répertoire \texttt{myTeensy}}







\sectionLabel{Déclaration \texttt{newUnsignedRepresentation}}{DefNewUnsignedRepresentation}
\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=!Definition@Définition}

La déclaration \plm=newUnsignedRepresentation= permet de définir une représentation entière non signée. Sa syntaxe est la suivante :


\begin{PLM}
newUnsignedRepresentation @nom "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@nom= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers non signés sur 8, 16, 32 et 64 bits peut être définie par :
\begin{PLM}
newUnsignedRepresentation @unsigned8  "uint8_t"   8
newUnsignedRepresentation @unsigned16 "uint16_t" 16
newUnsignedRepresentation @unsigned32 "uint32_t" 32
newUnsignedRepresentation @unsigned64 "uint64_t" 64
\end{PLM}








\sectionLabel{Déclaration \texttt{newSignedRepresentation}}{DefNewSignedRepresentation}
\index{newSignedRepresentation@\plm=newSignedRepresentation=!Definition@Définition}

La déclaration \plm=newSignedRepresentation= permet de définir une représentation entière signée. Sa syntaxe est la suivante :


\begin{PLM}
newSignedRepresentation @representation "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@representation= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers signés sur 8, 16, 32 et 64 bits peut être définie par :
\begin{PLM}
newSignedRepresentation @signed8  "int8_t"   8
newSignedRepresentation @signed16 "int16_t" 16
newSignedRepresentation @signed32 "int32_t" 32
newSignedRepresentation @signed64 "int64_t" 64
\end{PLM}











\sectionLabel{Déclaration \texttt{newIntegerType}}{DefNewIntegerType}
\index{newIntegerType@\plm=newIntegerType=!Definition@Définition}

La déclaration \plm=newIntegerType= permet de définir un nouveau type entier signé ou non signé. Elle a la syntaxe suivante :
\begin{PLM}
newIntegerType NomDeType @representation
\end{PLM}
Où :
\begin{itemize}
  \item \plm=NomDeType= est le nom donné au type entier.
  \item \plm=@representation= est le nom de la représentation, qui doit avoir été défini soit par une déclaration \plm=newUnsignedRepresentation= (\refSectionPage{DefNewUnsignedRepresentation})\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=}, soit par une déclaration \plm=newSignedRepresentation= (\refSectionPage{DefNewSignedRepresentation}\index{newSignedRepresentation@\plm=newSignedRepresentation=}).
\end{itemize}

Le type entier ainsi déclaré est non signé si la représentation est non signée (c'est-à-dire déclarée avec \plm=newUnsignedRepresentation=), et signé si la représentation est signée (c'est-à-dire déclarée avec \plm=newSignedRepresentation=). Les types usuels peuvent ainsi être déclarés :
\begin{PLM}
newIntegerType UInt8  @unsigned8
newIntegerType UInt16 @unsigned16
newIntegerType UInt32 @unsigned32
newIntegerType UInt64 @unsigned64
newIntegerType Int8  @signed8
newIntegerType Int16 @signed16
newIntegerType Int32 @signed32
newIntegerType Int64 @signed64
\end{PLM}





\sectionLabel{\texttt{boot} routines}{bootRoutine}
\index{boot@\plm=boot=!Routine}
\index{Routine!boot@\plm=boot=}

Une routine \plm=boot= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, avant que les variables globales ne soient initialisées. Elle a la syntaxe suivante :
\begin{PLM}
boot priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=boot= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=boot= n'ont pas la même priorité.

Les routines \plm=boot= s'exécutent dans le mode \plm=$boot=.\index{\$boot}

Comme les routines \plm=boot= s'exécutent avant que les variables globales soient initialisées, l'accès aux variables globales y est interdit. L'interdiction est mise en place de la façon suivante : il n'est pas possible d'associer une routine \plm=$boot= à une variable globale lors de sa déclaration (\refSectionPage{declarationVariableGlobale}).

Par contre, l'accès aux registres de contrôle est autorisé dans une routine \plm=boot= (d'ailleurs, elle sert à cela : configurer le micro-contrôleur au démarrage).







\sectionLabel{\texttt{init} routines}{initRoutine}
\index{init@\plm=init=!Routine}
\index{Routine!init@\plm=init=}

Une routine \plm=init= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, après l'initialisation des variables globales. Elle a la syntaxe suivante :
\begin{PLM}
init priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=init= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=init= n'ont pas la même priorité.

Les routines \plm=init= s'exécutent dans le mode \plm=$init=.\index{\$init}

Comme les routines \plm=init= s'exécutent après l'initialisation des variables globales, l'accès aux variables globales y est autorisé, du moment que la variable globale cite le mode \plm=$init= dans sa déclaration (\refSectionPage{declarationVariableGlobale}).


\sectionLabel{Séquence de démarrage du micro-contrôleur}{demarrageMicro}

\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=5mm
    ]
    \node [cloud] (start) {\textsc{Démarrage}} ;
    \node [block] (boot) [below=of start] {Routines \bf\texttt{boot}} ;
    \node [block] (raz) [below=of boot] {Initialisation des variables globales} ;
    \node [block] (init) [below=of raz] {Routines \bf\texttt{init}} ;
    \node [block] (setup) [below=of init] {Procédure \texttt{setup}} ;
    \node [block] (loop) [below=of setup] {Procédure \texttt{loop}} ;

    \draw [-stealth, thick] (start) -- (boot) ;
    \draw [-stealth, thick] (boot) -- (raz) ;
    \draw [-stealth, thick] (raz) -- (init) ;
    \draw [-stealth, thick] (init) -- (setup) ;
    \draw [-stealth, thick] (setup) -- (loop) ;
    \draw [-stealth, thick] (loop.south) -- +(0, -.25) -- +(1.7, -.25) -- +(1.7, 0.8)-- +(0, 0.8) ;
  \end{tikzpicture}
  \caption{Organigramme de la séquence de démarrage}
  \labelFigure{sequenceDemarrage}
  \ligne
\end{figure}


