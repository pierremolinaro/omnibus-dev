%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Cible \texttt{teensy-3-1-it}}\index{Cible!\texttt{teensy-3-1-it}}

Dans l'état actuel de PLM, une seule cible est définie : \texttt{teensy-3-1-it}.  Elle permet une programmation séquentielle avec routines d'interruption. L'interruption \texttt{systick} est programmée pour se déclencher chaque milliseconde. L'objet de ce chapitre est de décrire son utilisation.

Il est possible de définir sa propre cible (\refChapterPage{chapitreConfCible}).




















\sectionLabel{Organigramme d'exécution}{organigrammeExecutionTeensy31It}

La \refFigure{}{sequenceDemarrageTeensySequentialSystick} définit l'organigramme d'exécution d'un programme.

Le micro-contrôleur démarre sur une horloge interne, la mémoire vive n'étant pas initialisée. Il est dans le mode \emph{thread, priviliged access}, avec une seule pile. La configuration conservera cette pile unique, jusqu'au démarrage des tâches.

La première étape est de configurer les horloges internes du micro-contrôleur : c'est le rôle des routines \plm=boot= (\refSectionPage{personalisationDemarrageTeensy31it}). À ce stade, la mémoire vive n'est toujours pas initialisée, aussi les routines \plm=boot= n'y accèdent pas (le compilateur l'assure).

La deuxième étape est d'initialiser les \emph{variables globales}, c'est-à-dire mettre à zéro la zone \texttt{bss}, et de recopier à partir de la flash les valeurs initiales des variables initialisées.

La troisième étape est l'exécution des routines \plm=init= (\refSectionPage{personalisationInitTeensy31it}). À partir de cette étape et pour les suivantes, les variables globales sont initialisées, et donc leur emploi est autorisé. Le rôle des routines \plm=init= est de configurer les entrées/sorties du micro-contrôleur.

Ensuite, les tâches sont lancées, et exécutées en fonction de leurs priorités et synchronisations.


\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=5mm
    ]
    \node [cloud] (start) {\textsc{Démarrage du micro-contrôleur}} ;
    \node [block] (boot) [below=of start] {Routines \bf\texttt{boot}} ;
    \node [block] (raz) [below=of boot] {Initialisation des variables globales} ;
    \node [block] (init) [below=of raz] {Routines \bf\texttt{init}} ;
    \node [block] (setup) [below=of init] {Démarrage des tâches} ;

    \draw [-stealth, thick] (start) -- (boot) ;
    \draw [-stealth, thick] (boot) -- (raz) ;
    \draw [-stealth, thick] (raz) -- (init) ;
    \draw [-stealth, thick] (init) -- (setup) ;
  \end{tikzpicture}
  \caption{Organigramme d'exécution de la cible \texttt{teensy-3-1-it}}
  \labelFigure{sequenceDemarrageTeensySequentialSystick}
  \ligne
\end{figure}










\sectionLabel{Personalisation du démarrage}{personalisationDemarrageTeensy31it}

La cible définit la routine \plm+boot 0+ qui configure le micro-contrôleur.

Vous pouvez ajouter vos propres routines \plm+boot+. À chaque routine \plm+boot+ est associée une priorité d'exécution, qui doit être unique. Les routines \plm+boot+ sont exécutées dans l'ordre croissant des priorités, c'est-à-dire que la routine \plm+boot 0+ est exécutée la première.





\sectionLabel{Personalisation de l'initialisation}{personalisationInitTeensy31it}

La cible définit la routine \plm+init 0+ qui configure le \emph{SysTick Timer} pour qu'il engendre une interruption toutes les millisecondes.

Vous pouvez ajouter vos propres routines \plm+init+. À chaque routine \plm+init+ est associée une priorité d'exécution, qui doit être unique. Les routines \plm+init+ sont exécutées dans l'ordre croissant des priorités, c'est-à-dire que la routine \plm+init 0+ est exécutée la première.












\section{API}

L'API de la cible \texttt{teensy-3-1-it} regroupe les fonctions disponibles dans des modules et des types :
\begin{itemize}
  \item le module \plm=time=, la gestion du temps (\refSubsectionPage{moduleTime}) ;
  \item le module \plm=leds=, la gestion des leds (\refSubsectionPage{moduleLeds}) ;
  \item le module \plm=lcd=, la gestion de l'afficheur LCD (\refSubsectionPage{moduleLCD}) ;
  \item le type \plm=$semaphore=, le sémaphore de Dijkstra (\refSubsectionPage{typeSemaphore}) ;
\end{itemize}

\subsectionLabel{Module \texttt{time}}{moduleTime}

Le module \plm=time= regroupe des fonctions dédiées à la gestion du temps. Pour la cible \texttt{teensy-3-1-it}, le temps est compté en nombre de milli-secondes écoulées depuis le démarrage du micro-contrôleur. 

\subsubsection{Fonction \texttt{oneMillisecondBusyWait}}

\begin{PLM}
  public func `panic `init oneMillisecondBusyWait ()
\end{PLM}

Cette fonction réalise une attente active jusqu'à la prochaine milli-seconde. Elle n'est appelable que dans les modes \plm=`panic= et \plm=`init=. 





\subsubsection{Fonction \texttt{busyWaitingDuringMS}}

\begin{PLM}
  public func `panic `init busyWaitingDuringMS (?inDelay $uint32)
\end{PLM}

Cette fonction réalise une attente active en appelant \plm=inDelay= fois la fonction \plm=oneMillisecondBusyWait=. Elle n'est appelable que dans les modes \plm=`panic= et \plm=`init=. 





\subsubsection{Primitive \texttt{waitUntilMS}}

\begin{PLM}
  public primitive waitUntilMS (?deadline: inDate $uint32)
\end{PLM}

Cette fonction réalise une attente passive jusqu'à la date absolue \plm=inDate=. 






\subsubsection{Primitive \texttt{waitDuringMS}}

\begin{PLM}
  public primitive waitDuringMS (?delay: inDelay $uint32)
\end{PLM}

Cette fonction réalise une attente passive pendant \plm=inDelay= milli-secondes. 





\subsubsection{Primitive \texttt{waitDuringMS}}

\begin{PLM}
  public primitive waitDuringMS (?delay: inDelay $uint32)
\end{PLM}

Cette fonction réalise une attente passive pendant \plm=inDelay= milli-secondes. 





\subsubsection{Garde \texttt{waitUntilMS}}

\begin{PLM}
  public guard waitUntilMS (?deadline:inDeadline $uint32)
\end{PLM}

Cette fonction exprime l'attente passive en garde pendant \plm=inDelay= milli-secondes. 









\subsectionLabel{Module \texttt{leds}}{moduleLeds}


\subsubsection{Constantes}

Les constantes suivantes sont de type \plm=$uint32= et sont dédiées aux leds : \plm=LED_L0=, \plm=LED_L1=, \plm=LED_L2=, \plm=LED_L3= et \plm=LED_L4=.


\subsubsectionLabel{Fonction \texttt{off}}{routineLedOffTeensy31it}

\begin{PLM}
  public func `user `panic `service `kernel off (?inLeds $uint32) 
\end{PLM}

Cette routine éteint un ensemble de leds. Pour éteindre une led, écrire :
\begin{PLM}[1]
  leds.off (!LED_L0)
\end{PLM}

 Pour éteindre plusieurs leds, utiliser l'opérateur \plm=|= :
\begin{PLM}[1]
  leds.off (!LED_L0 | LED_L4)
\end{PLM}



\subsubsectionLabel{Fonction \texttt{on}}{routineLedOnTeensy31it}

\begin{PLM}
  public func `user `panic `service `kernel on (?inLeds $uint32) 
\end{PLM}

Cette routine allume un ensemble de leds. Pour allumer une led, écrire :
\begin{PLM}[1]
  leds.on (!LED_L0)
\end{PLM}

 Pour allumer plusieurs leds, utiliser l'opérateur \plm=|= :
\begin{PLM}[1]
  leds.on (!LED_L0 | LED_L4)
\end{PLM}



\subsubsectionLabel{Fonction \texttt{toggle}}{routineLedToggleTeensy31it}

\begin{PLM}
  public func `user `panic `service `kernel toggle (?inLeds $uint32) 
\end{PLM}

Cette routine complémente un ensemble de leds. Pour complémenter une led, écrire :
\begin{PLM}[1]
  leds.toggle (!LED_L0)
\end{PLM}

 Pour complémenter plusieurs leds, utiliser l'opérateur \plm=|= :
\begin{PLM}[1]
  leds.toggle (!LED_L0 | LED_L4)
\end{PLM}






\subsectionLabel{Module \texttt{lcd}}{moduleLCD}


\subsubsection{Fonction \texttt{clearScreen}}

\begin{PLM}
  public func `user clearScreen ()
\end{PLM}

Cette fonction efface l'afficheur LCD, et place le curseur au début de la première ligne.





\subsubsection{Fonction \texttt{goto}}

\begin{PLM}
  public func `user goto (?line:inLine $uint2
                          ?column:inColumn $uint8)
\end{PLM}

Cette fonction place le curseur à la colonne \plm=inColumn= de la ligne \plm=inLine=. L'afficheur possédant quatre lignes, l'argument \plm=inLine= est de type \plm=$uint2=.




\subsubsection{Fonction \texttt{printSpaces}}

\begin{PLM}
  public func `user printSpaces (?inCount $uint32)
\end{PLM}

Cette fonction écrit \plm=inCount= caractères espace à partir de la position du curseur.





\subsubsection{Fonction \texttt{printUnsigned}}

\begin{PLM}
  public func `user printUnsigned (?inValue $uint32)
\end{PLM}

Cette fonction écrit la valeur de l'argument (un entier non signé sur 32 bits) \plm=inValue= à partir de la position du curseur.






\subsubsection{Fonction \texttt{printSigned}}

\begin{PLM}
  public func `user printSigned (?inValue $int32)
\end{PLM}

Cette fonction écrit la valeur de l'argument (un entier signé sur 32 bits) \plm=inValue= à partir de la position du curseur.







\subsubsection{Fonction \texttt{printString}}

\begin{PLM}
  public func `user printString (?inValue $staticString)
\end{PLM}

Cette fonction écrit la valeur de l'argument (une chaîne de caractères) \plm=inValue= à partir de la position du curseur.









\subsubsection{Fonction \texttt{clearScreenInPanicMode}}

\begin{PLM}
  public func `panic clearScreenInPanicMode ()
\end{PLM}

Cette fonction efface l'afficheur LCD, et place le curseur au début de la première ligne. Appelable uniquement en mode \plm=`panic=.





\subsubsection{Fonction \texttt{gotoInPanicMode}}

\begin{PLM}
  public func `panic gotoInPanicMode (?line:inLine $uint2
                                      ?column:inColumn $uint8)
\end{PLM}

Cette fonction place le curseur à la colonne \plm=inColumn= de la ligne \plm=inLine=. L'afficheur possédant quatre lignes, l'argument \plm=inLine= est de type \plm=$uint2=. Appelable uniquement en mode \plm=`panic=.




\subsubsection{Fonction \texttt{printSpacesInPanicMode}}

\begin{PLM}
  public func `panic printSpacesInPanicMode (?inCount $uint32)
\end{PLM}

Cette fonction écrit \plm=inCount= caractères espace à partir de la position du curseur. Appelable uniquement en mode \plm=`panic=.





\subsubsection{Fonction \texttt{printUnsignedInPanicMode}}

\begin{PLM}
  public func `panic printUnsignedInPanicMode (?inValue $uint32)
\end{PLM}

Cette fonction écrit la valeur de l'argument (un entier non signé sur 32 bits) \plm=inValue= à partir de la position du curseur. Appelable uniquement en mode \plm=`panic=.






\subsubsection{Fonction \texttt{printSignedInPanicMode}}

\begin{PLM}
  public func `panic printSignedInPanicMode (?inValue $int32)
\end{PLM}

Cette fonction écrit la valeur de l'argument (un entier signé sur 32 bits) \plm=inValue= à partir de la position du curseur. Appelable uniquement en mode \plm=`panic=.







\subsubsection{Fonction \texttt{printStringInPanicMode}}

\begin{PLM}
  public func `panic printStringInPanicMode (?inValue $staticString)
\end{PLM}

Cette fonction écrit la valeur de l'argument (une chaîne de caractères) \plm=inValue= à partir de la position du curseur. Appelable uniquement en mode \plm=`panic=.








\subsectionLabel{Type \texttt{\$semaphore}}{typeSemaphore}

Le type \plm=$semaphore= implémente le sémaphore de Dijstra. La liste des tâches bloquées est ordonnée selon leur priorité.


La déclaration d'un sémaphore mentionne sa valeur initiale, qui est un entier non signé de 32 bits :

\begin{PLM}[1]
  var s = $semaphore (!value:0)
\end{PLM}


\subsubsection{Service \texttt{V}}

\begin{PLM}
  public service V ()
\end{PLM}

Ce service effectue l'opération \texttt{V} sur le sémaphore sur lequel il s'applique. C'est un service, car il est appelable à partir d'une tâche, d'une primitive, et d'une routine d'interruption.



\subsubsection{Primitive \texttt{P}}

\begin{PLM}
  public primitive P () 
\end{PLM}

Cette primitive effectue l'opération \texttt{P} sur le sémaphore sur lequel il s'applique. C'est une primitive, car elle n'est pas appelable à partir d'une routine d'interruption.




\subsubsection{Primitive \texttt{P\_until}}

\begin{PLM}
  public primitive P_until (?deadline:inDeadline $uint32) -> $bool
\end{PLM}

Cette primitive attend d'effectuer l'opération \texttt{P}, jusqu'à l'échéance \plm=inDeadline=. Elle renvoie \plm=true= si la primitive \texttt{P} a été effectuée, ou \plm=false= si l'échéance est arrivée.





\subsubsection{Garde \texttt{P}}

\begin{PLM}
  public guard P () {
\end{PLM}

Cette primitive exprime l'opération \texttt{P} en garde.











\subsectionLabel{Écriture des primitives, des services et des gardes}{EcriturePrimitivesServicesGardes}

PLM définit deux types opaques et neuf fonctions externes\footnote{Externes à PLM, car écrites en C.} qui permettent d'écrire outils de synchronisation et gardes.

\subsubsection{Type opaque \texttt{\$taskList}}

Le type opaque \plm=$taskList= est utilisé pour maintenir la liste des tâches bloquées sur un outil de synchronisation.


\subsubsection{Type opaque \texttt{\$guardList}}

Le type opaque \plm=$guardList= est utilisé pour maintenir la liste des tâches qui ont invoqué une garde d'un outil de synchronisation.



\subsubsection{Fonction \texttt{blockInList}}

\begin{PLM}
func `kernel blockInList (?!list:ioWaitingList $taskList)
\end{PLM}

Cette fonction bloque la tâche en cours dans la liste \plm=ioWaitingList= passée en argument. Elle est appelable en mode \plm=`kernel=, c'est-à-dire par les primitives.




\subsubsection{Fonction \texttt{blockOnDeadline}}

\begin{PLM}
func `kernel blockOnDeadline (?deadline:inDeadline $uint32) 
\end{PLM}

Cette fonction bloque la tâche en cours jusqu'à la date \plm=inDeadline=. Elle est appelable en mode \plm=`kernel=, c'est-à-dire par les primitives.







\subsubsection{Fonction \texttt{blockInListAndOnDeadline}}

\begin{PLM}
func `kernel blockInListAndOnDeadline (?!list:ioWaitingList $taskList
                                       ?deadline:inDeadline $uint32) 
\end{PLM}

Cette fonction bloque la tâche en cours dans la liste \plm=ioWaitingList= jusqu'à la date \plm=inDeadline=. Elle est appelable en mode \plm=`kernel=, c'est-à-dire par les primitives.








\subsubsection{Fonction \texttt{makeTaskReady}}

\begin{PLM}
func `kernel `service `guard
makeTaskReady (?!list:ioWaitingList $taskList) -> $bool
\end{PLM}

Si la liste \plm=ioWaitingList= est vide, la fonction renvoie \plm=false=. Si la liste n'est pas vide, cette fonction retire de la liste la tâche de plus forte priorité, la rend prête, et la fonction renvoie \plm=true=.

Cette fonction est appelable en mode \plm=`kernel=, c'est-à-dire par les primitives, et en mode \plm=`service=, c'est-à-dire par les routines d'interruption.










\subsubsection{Fonction \texttt{makeTasksReadyFrom}}

\begin{PLM}
func `service
makeTasksReadyFrom (?currentDate:inCurrentDate $uint32)
\end{PLM}

Cette fonction rend prête toutes les tâches en attente d'échéance dont l'échéance est atteinte.

Cette fonction est appelable mode \plm=`service=, c'est-à-dire par les routines d'interruption.






\subsubsection{Fonction \texttt{handleGuardedCommand}}

\begin{PLM}
func `guard handleGuardedCommand (?!guard:ioGuard $guardList)
\end{PLM}

Cette fonction enregistre la tâche courante dans la liste \plm=ioGuard=. Cette fonction est appelable mode \plm=`guard=, c'est-à-dire par les gardes.








\subsubsection{Fonction \texttt{handleGuardedWaitUntil}}

\begin{PLM}
func `guard handleGuardedWaitUntil (?deadline:inDeadline $uint32)
\end{PLM}

Cette fonction enregistre la tâche courante pour une attente en garde jusqu'à la date \plm=inDeadline=. Cette fonction est appelable mode \plm=`guard=, c'est-à-dire par les gardes.










\subsubsection{Fonction \texttt{guardDidChange}}

\begin{PLM}
func `kernel `service guardDidChange (?!guard:ioGuard $guardList)
\end{PLM}

Cette fonction signifie aux tâches enregistrées dans \plm=ioGuard= que les gardes doivent être re-évaluées. Cette fonction est appelable en mode \plm=`kernel= et en mode  \plm=`service=.











\subsubsection{Fonction \texttt{tickHandlerForGuardedWaitUntil}}

\begin{PLM}
func `service
tickHandlerForGuardedWaitUntil (?currentDate:inCurrentDate $uint32)
\end{PLM}

Cette fonction signifie aux tâches en attente d'échéance en garde que l'instant \plm=inCurrentDate= est atteint, et qu'elles doivent re-évaluer leur gardes. Cette fonction est appelable en mode \plm=`service=.








\section{Les routines d'interruption}

Les \refTableau{tableItTeensySequentialSystick1}, \refTableau{tableItTeensySequentialSystick2} et \refTableau{tableItTeensySequentialSystick3} listent les interruptions définies par le processeur qui équipe la carte \emph{Teensy 3.1}. L'utilisateur peut définir une routine d'interruption pour chacune d'entre elles, sauf l'interruption n°1 (remise à zéro), et la n°15 (\texttt{SysTick}) qui est prise en charge de façon particulière (voir la \refSubsectionTitlePage{SystickPourTeensy31It}). Celle des autres interruptions est décrite dans les sections suivantes :
\begin{itemize}
  \item \refSubsectionTitlePage{itsTeensy31AvecExceptions} ;
  \item \refSubsectionTitlePage{itsTeensy31SansExceptions} ;
  \item \refSubsectionTitlePage{itsTeensyRoutinesUtilisateur}.
\end{itemize}


\begin{table}[!t]
  \centering
  \begin{tabular}{llllll}
    \textbf{Numéro}& \textbf{Nom routine} \\
    1  & \emph{ResetHandler, réservé par PLM} \\
    2  & \texttt{NMIHandler}\\
    3  & \texttt{HardFaultHandler}\\
    4  & \texttt{MemManageHandler}\\
    5  & \texttt{BusFaultHandler}\\
    6  & \texttt{UsageFaultHandler}\\
    7 à 10 & \emph{réservées par ARM} \\
    11 & \texttt{svcHandler}\\
    12 & \texttt{DebugMonitorHandler}\\
    13 & \emph{réservée par ARM} \\
    14 & \texttt{PendSVHandler}\\
    15 & \texttt{userSystickHandler}, voir \refSubsectionPage{SystickPourTeensy31It} \\
  \end{tabular}
  \caption{Table des interruptions 1 à 15 de la cible \texttt{teensy-3-1-it}}
  \labelTableau{tableItTeensySequentialSystick1}
  \ligne
\end{table}

\begin{table}[!t]
  \centering
  \begin{tabular}{llllll}
    \textbf{Numéro} & \textbf{Nom routine} \\
    16  & \texttt{DMAChannel0TranfertCompleteHandler}\\
    17  & \texttt{DMAChannel1TranfertCompleteHandler}\\
    18  & \texttt{DMAChannel2TranfertCompleteHandler}\\
    19  & \texttt{DMAChannel3TranfertCompleteHandler}\\
    20  & \texttt{DMAChannel4TranfertCompleteHandler}\\
    21  & \texttt{DMAChannel5TranfertCompleteHandler}\\
    22  & \texttt{DMAChannel6TranfertCompleteHandler}\\
    23  & \texttt{DMAChannel7TranfertCompleteHandler}\\
    24  & \texttt{DMAChannel8TranfertCompleteHandler}\\
    25  & \texttt{DMAChannel9TranfertCompleteHandler}\\
    26  & \texttt{DMAChannel10TranfertCompleteHandler}\\
    27  & \texttt{DMAChannel11TranfertCompleteHandler}\\
    28  & \texttt{DMAChannel12TranfertCompleteHandler}\\
    29  & \texttt{DMAChannel13TranfertCompleteHandler}\\
    30  & \texttt{DMAChannel14TranfertCompleteHandler}\\
    31  & \texttt{DMAChannel15TranfertCompleteHandler}\\
    32  & \texttt{DMAErrorHandler}\\
    33  & \emph{inutilisée} \\
    34  & \texttt{flashMemoryCommandCompleteHandler}\\
    35  & \texttt{flashMemoryReadCollisionHandler}\\
    36  & \texttt{modeControllerHandler}\\
    37  & \texttt{LLWUHandler}\\
    38  & \texttt{WDOGEWMHandler}\\
    39  & \emph{inutilisée} \\
    40  & \texttt{I2C0Handler}\\
    41  & \texttt{I2C1Handler}\\
    42  & \texttt{SPI0Handler}\\
    43  & \texttt{SPI1Handler}\\
    44  & \emph{inutilisée} \\
    45  & \texttt{CAN0MessageBufferHandler}\\
    46  & \texttt{CAN0BusOffHandler}\\
    47  & \texttt{CAN0ErrorHandler}\\
    48  & \texttt{CAN0TransmitWarningHandler}\\
    49  & \texttt{CAN0ReceiveWarningHandler}\\
    50  & \texttt{CAN0WakeUpHandler}\\
    51  & \texttt{I2S0TransmitHandler}\\
    52  & \texttt{I2S0ReceiveHandler}\\
    53 à 59  & \emph{inutilisées} \\
  \end{tabular}
  \caption{Table des interruptions 16 à 59 de la cible \texttt{teensy-3-1-it}}
  \labelTableau{tableItTeensySequentialSystick2}
  \ligne
\end{table}

\begin{table}[!t]
  \centering
  \begin{tabular}{llllll}
    \textbf{Numéro}& \textbf{Nom routine} \\
    60  & \texttt{UART0LONHandler}\\
    61  & \texttt{UART0StatusHandler}\\
    62  & \texttt{UART0ErrorHandler}\\
    63  & \texttt{UART1StatusHandler}\\
    64  & \texttt{UART1ErrorHandler}\\
    65  & \texttt{UART2StatusHandler}\\
    66  & \texttt{UART2ErrorHandler}\\
    67 à 72  & \emph{inutilisées} \\
    73  & \texttt{ADC0Handler}\\
    74  & \texttt{ADC1Handler}\\
    75  & \texttt{CMP0Handler}\\
    76  & \texttt{CMP1Handler}\\
    77  & \texttt{CMP2Handler}\\
    78  & \texttt{FMT0Handler}\\
    79  & \texttt{FMT1Handler}\\
    80  & \texttt{FMT2Handler}\\
    81  & \texttt{CMTHandler}\\
    82  & \texttt{RTCAlarmHandler}\\
    83  & \texttt{RTCSecondHandler}\\
    84  & \texttt{PITChannel0Handler}\\
    85  & \texttt{PITChannel1Handler}\\
    86  & \texttt{PITChannel2Handler}\\
    87  & \texttt{PITChannel3Handler}\\
    88  & \texttt{PDBHandler}\\
    89  & \texttt{USBOTGHandler}\\
    90  & \texttt{USBChargerDetectHandler}\\
    91 à 96  & \emph{inutilisées} \\
    97  & \texttt{DAC0Handler}\\
    98  & \emph{inutilisée} \\
    99  & \texttt{TSIHandler}\\
    100  & \texttt{MCGHandler}\\
    101  & \texttt{lowPowerTimerHandler}\\
    103  & \texttt{pinDetectPortAHandler}\\
    104  & \texttt{pinDetectPortBHandler}\\
    105  & \texttt{pinDetectPortCHandler}\\
    106  & \texttt{pinDetectPortDHandler}\\
    107  & \texttt{pinDetectPortEHandler}\\
    108 et 109  & \emph{inutilisées} \\
    110  & \texttt{softwareInterruptHandler}
  \end{tabular}
  \caption{Table des interruptions 60 à 110 de la cible \texttt{teensy-3-1-it}}
  \labelTableau{tableItTeensySequentialSystick3}
  \ligne
\end{table}


\subsectionLabel{Routines d'interruption par défaut, panique activée}{itsTeensy31AvecExceptions}

Quand la panique est activée, une routine par défaut est prédéfinie pour chaque interruption (sauf la n°1 et la n°15). Celle-ci exécute l'instruction \plm+panic+, dont l'argument est le numéro de l'interruption. Par exemple, pour l'interruption n°2 (\texttt{NMI}), la routine prédéfinie est :
\begin{PLM}[1]
proc NMIHandler `isr @nullWhenPanicDisabled @weak () {
  panic 2
}
\end{PLM}


\subsectionLabel{Routines d'interruption par défaut, panique inactivée}{itsTeensy31SansExceptions}

Quand la panique est inactivée, l'attribut \plm+@nullWhenPanicDisabled+ associé à chaque routine d'interruption provoque la suppression de cette routine d'interruption, et son remplacement de son adresse dans la table des vecteurs d'interruption par la valeur $0$.



\subsectionLabel{Routines d'interruption définies par l'utilisateur}{itsTeensyRoutinesUtilisateur}

L'attribut \plm+@weak+ associé à chaque routine d'interruption permet sa redéfinition par l'utilisateur. La routine par défaut est alors ignorée, que la panique soit activée ou non.

Par exemple, l'utilisateur peut définir la routine associée à \texttt{NMI} par :
\begin{PLM}[1]
proc NMIHandler `isr {
  ...
}
\end{PLM}

Il est important de conserver le nom. Si celui-ci est mal orthographié et ne correspond à aucune interruption :
\begin{itemize}
  \item la routine d'interruption par défaut est conservée (panique activée) ou supprimée (panique inactivée) ;
  \item un \emph{warning} est déclenché, signalant que la routine utilisateur est inutilisée.
\end{itemize}



\subsectionLabel{Routine associée à l'interruption \texttt{SysTick}}{SystickPourTeensy31It}

L'interruption \texttt{SysTick} est particulière. Elle est programmé par la routine \plm+init 0+ de façon à engendrer une interruption chaque milliseconde. Cette interruption se déclenche après la fin de l'exécution la routine \plm+init 0+, y compris éventuellement dans les routines \plm+init+ qui suivent. La routine d'interruption associée, inaccessible à l'utilisateur :
\begin{itemize}
  \item incrémente une variable globale de comptage du temps ;
  \item appelle la routine \plm+userSystickHandler+.
\end{itemize}

La routine \plm+userSystickHandler+ est définie par :
\begin{PLM}[1]
proc userSystickHandler `isr @weak () {
}
\end{PLM}

L'attribut \plm+@weak+ permet sa redéfinition par l'utilisateur.



