%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Variables globales}

Les variables peuvent être déclarées en deux endroits :
\begin{itemize}
  \item en dehors de toute routine : c'est une variable globale (voir ci-après) ;
  \item parmi les instructions d'une routine : c'est une variable locale à la routine (voir \refSectionPage{declarationVariableLocale}).
\end{itemize}





\sectionLabel{Déclaration d'une variable globale}{declarationVariableGlobale}\index{Variable!globale}

La déclaration d'une variable globale est la suivante :

\begin{PLM}
var nom : Type = expression_statique {
  en_tetes_routines_autorisees
}
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable globale ;
  \item \plm=Type= est le nom du type de la variable globale ;
  \item \plm=expression_statique= est l'expression qui fournit la valeur initiale de cette variable ; cette expression est calculée lors de la compilation ;
  \item \plm=en_tetes_routines_autorisees= est la liste des routines qui sont autorisées à accéder à la variable globale (\refSectionPage{DecRoutinesAutoriseesVarGlobale}) ; par défaut, l'accès est autorisé en lecture seule ; pour avoir l'autorisation d'écrire la variable, l'attribut \plm=@rw=\index{"@rw} doit être placé avant la routine.
\end{itemize}

La portée d'une variable globale est le programme dans son intégralité : peu importe où est déclarée la variable. Toutefois, seules les routines explicitement autorisées dans peuvent y accéder.

L'\plm=expression_statique= peut utiliser la valeur des constantes globales : le compilateur évalue les constantes globales avant d'évaluer les valeurs initiales des variables globales. Par contre, \plm=expression_statique= ne peut pas utiliser les valeurs d'une autre variable globale.

Par exemple, voici comment on peut implémenter une variable globale \texttt{gCompteur}, incrémentée par la routine d'interruption \texttt{timerHandler}, et écrire un service d'attente de délai \texttt{wait} avec une boucle d'attente active :

\begin{PLM}
var gCompteur $uint32 = 0 {
  @rw func timerHandler // Ne pas faire figurer
  func waitMS           // la liste des arguments
}

func timerHandler `isr () {
  gCompteur +%= 1
}

func wait `user (?inDuration $uint32) {
  let deadline = gCompteur + inDuration
  while gCompteur < deadline do
  end
}
\end{PLM}

Note : si une variable globale est accédée par des routines appartenant à plusieurs modes, le compilateur ajoute le qualificatif \texttt{volatile}\index{volatile@\texttt{volatile}} dans le code engendré pour déclarer cette variable. C'est le cas de l'exemple ci-dessus, la variable \texttt{gCompteur} pouvant être accédée dans les modes \plm=`isr= et \plm=`user=.


Les routines d'initialisation (\refSectionPage{initRoutine})\index{init@\plm=init=!Routine} et les routines de panique (\refSubsectionPage{routinesPanique})\index{Routine!panique \plm=panic=}
 doivent de même être déclarées pour pouvoir accéder à une variable globale (et avec l'attribut \plm=@rw= si on veut l'accès en écriture). Par exemple :
\begin{PLM}
var gCompteur $uint32 = 0 {
  @rw init 112
  @rw func panic loop 179
}

func init 112 {
  gCompteur = 10
}

func panic loop 179 {
  gCompteur = 100
}
\end{PLM}


\sectionLabel{Déclarations des routines autorisées}{DecRoutinesAutoriseesVarGlobale}

Dans la déclaration d'une variable globale, \plm=en_tetes_routines_autorisees= liste l'ensemble des routines pouvant accédéer à la variable globale. Cette liste doit être non vide. On peut ainsi autoriser l'accès à :
\begin{itemize}
  \item une routine d'initialisation (\plm!init!) ;
  \item une fonction (\plm!func!) ;
  \item une section (\plm!section!) ;
  \item une routine de panique (\plm!func panic!) ;
  \item une fonction de type (\plm!func!).
\end{itemize}

Le \refTableauPage{DecRoutinesAutoriseesAccesVarGlobale} résume les déclarations des routines autorisées. Par défaut, seul l'accès en lecture est permis. L'attribut \plm!@rw! permet d'autoriser pour une routine l'accès en écriture, sauf pour les fonctions ou cet attribut est interdit.

Le compilateur interdit l'accès des routines \plm+boot+ aux variables globales\footnote{En effet, comme les routines \texttt{boot} sont exécutées avant l'initialisation des variables globales, le comportement à l'exécution serait indéfini.}.

\begin{table}[t]
\centering
\begin{tabular}{lp{5cm}l}
  \textbf{Déclaration} & \textbf{Routine autorisée} & \textbf{Accés en écriture} \\
  \plm=init priorite= & Routine d'initialisation de priorité \plm=priorite= & Nécessite \plm!@rw! \\
  \plm=func nom= & Fonction \plm!nom! & Jamais \\
  \plm=section nom= & Section \plm!nom! & Nécessite \plm!@rw! \\
  \plm=func panic nom prorite= & Routine de panique \plm!nom! de priorité \plm=priorite= & Nécessite \plm!@rw! \\
  \plm=func $type nom= & Procédure \plm!nom! du type \plm!$type! & Nécessite \plm!@rw! \\
  \plm=func $type nom= & Fonction \plm!nom! du type \plm!$type! & Jamais \\
\end{tabular}
\caption{Déclaration des routines autorisées}
\labelTableau{DecRoutinesAutoriseesAccesVarGlobale}
\ligne
\end{table}













\section{Restrictions d'usage des variables globales}
\index{Parametre effectif@Paramètre effectif!Variable globale}

Une variable globale ne peut pas :
\begin{itemize}
  \item apparaître comme paramètre effectif en entrée d'une procédure ;
  \item apparaître comme paramètre effectif en sortie/entrée d'une procédure.
\end{itemize}

Prenons un exemple ; la procédure \texttt{uneProcedure} présente un argument formel en sortie, et la variable globale \texttt{gGlobale} peut être accédée en lecture et écriture par la procédure \texttt{autreProcedure} :
\begin{PLM}
func uneProcedure `user (!outValue $uint32) {
  outValue = 5
}

var gGlobale $uint32 {
  @rw func autreProcedure
}
\end{PLM}

L'écriture suivante est correcte (écriture de la variable globale) :
\begin{PLM}
func autreProcedure `user () {
  gGlobale = 10 // Ok
}
\end{PLM}


Par contre, l'écriture suivante est rejetée par le compilateur (passage d'une variable globale comme paramètre effectif en entrée) :
\begin{PLM}
func autreProcedure `user () {
  uneProcedure (?gGlobale) // Erreur, variable globale comme
                           // paramètre effectif en entrée
}
\end{PLM}

