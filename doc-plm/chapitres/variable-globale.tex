%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Variables globales}

Une variable est dite \emph{globale} si elle est déclarée en dehors de toute routine, tâche, module.


%Les variables peuvent être déclarées en deux endroits~:
%\begin{itemize}
%  \item en dehors de toute routine~: c'est une variable globale (voir ci-après) ;
%  \item parmi les instructions d'une routine~: c'est une variable locale à la routine (voir \refSectionPage{declarationVariableLocale}).
%\end{itemize}
%




\sectionLabel{Déclaration d'une variable globale}{declarationVariableGlobale}\index{Variable!globale}

La déclaration d'une variable globale est la suivante~:

\begin{PLM}
var nom $type = expression_statique
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable globale ;
  \item \plm=$type= est le nom du type de la variable globale ;
  \item \plm=expression_statique= est l'expression qui fournit la valeur initiale de cette variable ; cette expression est calculée lors de la compilation.
\end{itemize}

L'\plm=expression_statique= est obligatoire ; si la valeur de celle-ci revient à un zéro binaire, la variable est placée dans une section « \texttt{.bss.*} », de façon à être initialisée au début de l'exécution (\refSectionPage{sequenceDemarrage}).

La portée d'une variable globale est le programme dans son intégralité~: peu importe où est déclarée la variable.

% Toutefois, seules les routines explicitement autorisées dans peuvent y accéder.
%
%L'\plm=expression_statique= peut utiliser la valeur des constantes globales~: le compilateur évalue les constantes globales avant d'évaluer les valeurs initiales des variables globales. Par contre, \plm=expression_statique= ne peut pas utiliser les valeurs d'une autre variable globale.
%
%Par exemple, voici comment on peut implémenter une variable globale \texttt{gCompteur}, incrémentée par la routine d'interruption \texttt{timerHandler}, et écrire un service d'attente de délai \texttt{wait} avec une boucle d'attente active~:
%
%\begin{PLM}
%var gCompteur $uint32 = 0 {
%  @rw func timerHandler // Ne pas faire figurer
%  func waitMS           // la liste des arguments
%}
%
%func timerHandler isr () {
%  gCompteur +%= 1
%}
%
%func wait user (?inDuration $uint32) {
%  let deadline = gCompteur + inDuration
%  while gCompteur < deadline do
%  end
%}
%\end{PLM}
%
%Note~: si une variable globale est accédée par des routines appartenant à plusieurs modes, le compilateur ajoute le qualificatif \texttt{volatile}\index{volatile@\texttt{volatile}} dans le code engendré pour déclarer cette variable. C'est le cas de l'exemple ci-dessus, la variable \texttt{gCompteur} pouvant être accédée dans les modes \plm=isr= et \plm=user=.
%
%
%Les routines d'initialisation (\refSectionPage{initRoutine})\index{init@\plm=init=!Routine} et les routines de panique (\refSubsectionPage{routinesPanique})\index{Routine!panique \plm=panic=}
% doivent de même être déclarées pour pouvoir accéder à une variable globale (et avec l'attribut \plm=@rw= si on veut l'accès en écriture). Par exemple~:
%\begin{PLM}
%var gCompteur $uint32 = 0 {
%  @rw init 112
%  @rw func panic loop 179
%}
%
%func init 112 {
%  gCompteur = 10
%}
%
%func panic loop 179 {
%  gCompteur = 100
%}
%\end{PLM}
%
%
%\sectionLabel{Déclarations des routines autorisées}{DecRoutinesAutoriseesVarGlobale}
%
%Dans la déclaration d'une variable globale, \plm=en_tetes_routines_autorisees= liste l'ensemble des routines pouvant accédéer à la variable globale. Cette liste doit être non vide. On peut ainsi autoriser l'accès à~:
%\begin{itemize}
%  \item une routine d'initialisation (\plm!init!) ;
%  \item une fonction (\plm!func!) ;
%  \item une section (\plm!section!) ;
%  \item une routine de panique (\plm!func panic!) ;
%  \item une fonction de type (\plm!func!).
%\end{itemize}
%
%Le \refTableauPage{DecRoutinesAutoriseesAccesVarGlobale} résume les déclarations des routines autorisées. Par défaut, seul l'accès en lecture est permis. L'attribut \plm!@rw! permet d'autoriser pour une routine l'accès en écriture, sauf pour les fonctions ou cet attribut est interdit.
%
%Le compilateur interdit l'accès des routines \plm+boot+ aux variables globales\footnote{En effet, comme les routines \texttt{boot} sont exécutées avant l'initialisation des variables globales, le comportement à l'exécution serait indéfini.}.
%
%\begin{table}[t]
%\centering
%\begin{tabular}{lp{5cm}l}
%  \textbf{Déclaration} & \textbf{Routine autorisée} & \textbf{Accés en écriture} \\
%  \plm=init priorite= & Routine d'initialisation de priorité \plm=priorite= & Nécessite \plm!@rw! \\
%  \plm=func nom= & Fonction \plm!nom! & Jamais \\
%  \plm=section nom= & Section \plm!nom! & Nécessite \plm!@rw! \\
%  \plm=func panic nom prorite= & Routine de panique \plm!nom! de priorité \plm=priorite= & Nécessite \plm!@rw! \\
%  \plm=func $type nom= & Procédure \plm!nom! du type \plm!$type! & Nécessite \plm!@rw! \\
%  \plm=func $type nom= & Fonction \plm!nom! du type \plm!$type! & Jamais \\
%\end{tabular}
%\caption{Déclaration des routines autorisées}
%\labelTableau{DecRoutinesAutoriseesAccesVarGlobale}
%\ligne
%\end{table}













\sectionLabel{Restrictions d'usage des variables globales}{restrictionUsageVariableGlobale}

La concurrence impose des restrictions sur l'usage des variables globales. Pour les illustrer, nous prenons l'exemple d'une variable globale \plm+gVariable+, de type \plm=$s= :

\begin{PLM}
var gVariable = $s ()

struct $s {
  var mX $uint32 = 0 ;
  var mY $uint32 = 0 ;
  
  func increment @mutating @access () {
    mX += 1
    mY += 1
  }

  func section atomicIncrement @mutating @access () {
    mX += 1
    mY += 1
  }

  func indirectIncrement @mutating () {
    self.atomicIncrement ()
  }
}
\end{PLM}

Pour mémoire (§), l'attribut \plm=@access= signifie que la méthode accède {\bf directement} aux propriétés : c'est le cas de \plm=increment= et de \plm=atomicIncrement=. L'attribut \plm=@mutating= signifie que la méthode modifie la valeur des propriétés, directement (si \plm=@access= est présent), ou indrectement (pas d'attribut \plm=@access=), comme c'est le cas de la méthode \plm=indirectIncrement=.

\subsection{Accès à une variable globale}


Afin de préciser ces règles, il convient de rappeler les différents types d'accès à une variable :
\begin{enumerate}[label=(\arabic*)]
  \item accès en lecture (par exemple \plm+var u = gVariable+) ;
  \item accès en écriture (par exemple \plm+gVariable = u+) ;
  \item accès en lecture / écriture (par exemple \plm!gVariable += u!) ;
  \item appel d'une méthode, par exemple \plm+gVariable.increment ()+.
\end{enumerate}

L'accès en lecture (1), en écriture (2), en lecture / écriture (3) est interdite à une routine s'exécutant dans le mode \plm=user=. Il en est de même pour les fonctions «~universelles~» (\refSubsectionPage{fonctionUniverselle}) : leur mode d'exécution n'étant pas fixé à la compilation, il se peut qu'elles s'exécutent en mode \plm+user+.

Le cas (4) est plus difficile à appréhender. Si la méthode est déclarée en mode privilégié, l'appel est possible sans restriction, comme par exemple \plm+gVariable.atomicIncrement ()+. Par contre, \plm+gVariable.increment ()+ est interdit, et détecté comme une erreur par le compilateur : en effet, appelé en mode \plm=user=, l'incrémentation des propriétés ne serait pas atomique. L'appel \plm+gVariable.indirectIncrement ()+ est autorisé, puisque l'incrémentation est réalisé par une routine en mode privilégié.

En résumé :
\begin{itemize}
  \item l'appel d'une méthode privilégiée d'une variable globale est autorisée ;
  \item l'appel d'une méthode «~universelle~» ou \plm=user= d'une variable globale est autorisée, sous réserve que cette méthode n'ait pas l'attribut \plm=@access=.
\end{itemize}








\subsection{Variable globale comme paramètre effectif}

Une variable globale ne peut pas~:\index{Parametre effectif@Paramètre effectif!Variable globale}

\begin{itemize}
  \item apparaître comme paramètre effectif en entrée d'une fonction ;
  \item apparaître comme paramètre effectif en sortie/entrée d'une fonction.
\end{itemize}

Par contre, sous certaines conditions, une variable globale peut apparaître en paramètre effectif de sortie : la routine appelante doit être privilégiée. La transmission d'un paramètre effectif en sortie implique une copie, or en mode \plm=user=, celle-ci n'est pas atomique.


