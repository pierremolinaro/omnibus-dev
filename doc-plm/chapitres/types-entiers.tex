%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Les types entiers}

Les types entiers ne sont pas prédéfinis dans le langage. C'est la configuration de la cible qui définit les types entiers disponibles (voir \refChapterPage{chapitreConfCible}).

À titre d'exemple, le \refTableau{typesEntiersTeensy} liste les types entiers définis par la cible \texttt{teensy3-1-sequential-systick}.

\begin{table}[h]
\centering
\ligne\\
\begin{tabular}{lllll}
  \textbf{Nature} & \textbf{8 bits} & \textbf{16 bits} & \textbf{32 bits} & \textbf{64 bits} \\
  Signé & \plm=$int8= & \plm=$int16= & \plm=$int32= & \plm=$int64= \\
  Non signé & \plm=$uint8= & \plm=$uint16= & \plm=$uint32= & \plm=$uint64= \\
\end{tabular}
\caption{Types entiers définis par la cible \texttt{teensy-3-1-sequential-systick}}
\labelTableau{typesEntiersTeensy}
\ligne
\end{table}



\section{Constante littérale entière}

Le langage accepte des constantes littérales non signés de 64 bits. Une constante est convertie dans le type entier requis par le contexte sémantique, et une erreur est déclenchée à la compilation en cas d'impossibilité. Par exemple :

\begin{PLM}
var v : $int8 = 128 // Erreur de compilation :
                   // 128 non représentable par un entier signé 8 bits
\end{PLM}

\colorbox{red}{C'est une erreur à corriger}

\begin{PLM}
var v : $int8 = -128 // Devrait être accepté, erreur actuellement
\end{PLM}

Une constante littérale entière n'a pas de type défini, aussi seul l'inférence de type peut lui affecter un type. Par exemple, si on écrit :
\begin{PLM}
var v = 28 // Erreur, le type ne peut pas être inféré
\end{PLM}

Dans ce cas, il faut que la déclaration contienne l'annotation de type :
\begin{PLM}
var v : $int32 = 28 // Ok
\end{PLM}




\section{Conversion entre valeurs entières}

\colorbox{red}{À compléter}

\subsection{Conversions implicites silencieuses}
Les conversions qui sont toujours possibles sans débordement sont acceptées silencieusement. Par exemple :
\begin{PLM}
let v : $uint8 = ...
let x : $uint16 = v
let y : $int16 = v
\end{PLM}

Par contre, une conversion pouvant provoquer un débordement est rejetée à la compilation :
\begin{PLM}
let s : $int8 = ...
let x : $uint16 = x // Erreur de compilation
\end{PLM}

\subsection{L'opérateur \texttt{\textbackslash}}
L'opérateur \plm+\+ permet de spécifier une conversion explicite.

\begin{PLM}
let s : $int8 = ...
let x : $uint16 = x \ $uint16
\end{PLM}

L'opérateur \plm+\+ engendre un code qui vérifie à l'exécution que l'expression source (ici \plm+x+) peut être convertie dans le type cible (ici \plm+$uint16+) sans débordement. En cas de débordement détecté à l'exécution, une exception dont le code est donné dans le \refTableauPage{tableauCodeExceptions} est levée. L'opérateur \plm+\+ est donc interdit dans les constructions où les exceptions sont interdites : il faut alors utiliser l'opérateur \plm=&\=.

L'opérateur \plm+\+ ne peut pas apparaître dans une expression statique.

De plus, une erreur de compilation est déclenchée si l'opérateur \plm+\+ est utilisé alors qu'une conversion implicite est possible :
\begin{PLM}
let v : $uint8 = ...
let y : $int16 = v \ $int16 // Erreur, la conversion implicite est possible
\end{PLM}

\subsection{L'opérateur \texttt{\&\textbackslash}}

L'opérateur \plm+&\+ permet de spécifier une conversion explicite silencieuse, qui ne lève aucune exception. La valeur de l'expression source est tronquée en cas de débordement\footnote{L'opérateur \texttt{\&\textbackslash} est équivalent au \emph{type cast} entre entiers du langage C.}. Par exemple :

\begin{PLM}
let s : $int8 = -10
let x : $uint16 = x &\ $uint16
\end{PLM}

L'opérateur \plm+&\+ ne peut pas apparaître dans une expression statique.

De plus, une erreur de compilation est déclenchée si l'opérateur \plm+&\+ est utilisé alors qu'une conversion implicite est possible :
\begin{PLM}
let v : $uint8 = ...
let y : $int16 = v &\ $int16 // Erreur, la conversion implicite est possible
\end{PLM}

\section{Opérateurs infixes et conversions implicites}

\colorbox{red}{À définir.}

\section{Opérateurs infix de comparaison}

Les valeurs entières sont comparables, les six opérateurs \plm+==+, \plm+!=+, \plm+>=+, \plm+>+, \plm+<=+ et \plm+<+ sont acceptés.

La comparaison ne peut s'effectuer qu'entre valeurs de même type entier.









\sectionLabel{Opérateurs infixes arithmétiques}{operateursInfixArithmétiques}

Les opérateurs infixes arithmétiques sont listés dans le \refTableau{operateursInfixesArithmetiques} avec leur signification.

\begin{table}[h]
\centering
\begin{tabular}{lllll}
  \textbf{Opérateur} & \textbf{Signification} \\
  \plm=+= & Addition avec détection de débordement\\
  \plm=-= & Soustraction avec détection de débordement\\
  \plm=*= & Multiplication avec détection de débordement\\
  \plm=/= & Division avec détection de débordement\\
  \plm=%= & Modulo avec détection de division par zéro\\
  \plm=&+= & Addition sans détection de débordement\\
  \plm=&-= & Soustraction sans détection de débordement\\
  \plm=&*= & Multiplication sans détection de débordement\\
  \plm=&/= & Division sans détection de débordement\\
  \plm=&%= & Modulo sans détection de division par zéro\\
\end{tabular}
\caption{Opérateurs infixes arithmétiques}
\labelTableau{operateursInfixesArithmetiques}
\ligne
\end{table}




\section{Opérateurs préfixés de négation arithmétique}

\subsectionLabel{Opérateur \texttt{-}}{negationOvf}

L'opérateur préfixé \plm=-= est la négation arithmétique avec détection de débordement. Il n'est accepté que sur les types signés. La négation de la borne inférieure d'un type signé (\plm+-128+ pour \plm+$int8+, \plm+-32768+ pour \plm+$int16+, ...) entraîne un débordement arithmétique qui déclenche une exception dont le code est donné dans le \refTableau{tableauCodeExceptions}.


\subsectionLabel{Opérateur \texttt{\&-}}{negationNoOvf}

L'opérateur préfixé \plm=&-= est la négation arithmétique sans détection de débordement. Il n'est accepté que sur les types signés. La négation de la borne inférieure d'un type signé (\plm+-128+ pour \plm+$int8+, \plm+-32768+ pour \plm+$int16+, ...) retourne cette même valeur. Cet opérateur n'engendre jamais d'exception.




\sectionLabel{Opérateurs infixes bit-à-bit}{operateurBitABitEntier}
\index{\&!Entier}
\index{\textbar!Entier}
\index{\^!Entier}

Les opérateurs infixes bit-à-bit acceptent les types entiers non signés (\refTableau{operateursInfixesBitABit}).

\begin{table}[h]
\centering
\begin{tabular}{lllll}
  \textbf{Opérateur} & \textbf{Signification} \\
  \plm=|= & \emph{ou} bit-à-bit\\
  \plm=&= & \emph{et} bit-à-bit\\
  \plm=^= & \emph{ou exclusif} bit-à-bit\\
\end{tabular}
\caption{Opérateurs infixes bit-à-bit sur les entiers non signés}
\labelTableau{operateursInfixesBitABit}
\ligne
\end{table}





\section{Opérateur préfixé bit-à-bit}

L'opérateur préfixé \plm=~= retourne la complémentation bit-à-bit d'une valeur entière non signée.




\section{Opérateurs infixes de décalage}

Les opérateurs infixes \plm=<<= et \plm=>>= réalisent respectivement le décalage à gauche et à droite de l'opérande de gauche. L'amplitude du décalage est spécifiée par la valeur de l'opérande droite (\refTableau{operateursInfixesDecalage}). \plm=a= est une expression entière signée ou non signée, et l'expression renvoie une valeur de même type que \plm=a=. L'expression \plm=b= est une expression entière non signée.

\begin{table}[h]
\centering
\begin{tabular}{lllll}
  \textbf{Expression} & \textbf{Signification} \\
  \plm=a << b= & Décalage à gauche de \plm=a= d'une amplitude de \plm=b= bits\\
  \plm=a >> b= & Décalage à droite de \plm=a= d'une amplitude de \plm=b= bits\\
\end{tabular}
\caption{Opérateurs infixes de décalage sur les entiers}
\labelTableau{operateursInfixesDecalage}
\ligne
\end{table}



\sectionLabel {Incrémentation et décrémentation}{incDecEntier}
\index{Incrementation@Incrémentation!Entier}
\index{Decrementation@Decrémentation!Entier}

Les opérateurs postfixés \plm=++= et \plm=--= réalisent respectivement l'incrémentation et la décrémentation. Ils s'utilisent dans une instruction :
\begin{PLM}
variable ++
\end{PLM}

\plm=++= et \plm=--= déclenchent une exception (dont le code est donné par le \refTableauPage{tableauCodeExceptions}) en cas de débordement de capacité :
\begin{PLM}
var variable : $uint8 = 255
variable ++ // Déclenchement d'une exception
\end{PLM}

Les opérateurs \plm=&++= et \plm=&--= ignorent le dépassement de capacité (et fonctionnent donc comme les opérateurs d'incrémentation et de décrémentation du C) :
\begin{PLM}
var variable : $uint8 = 255
variable &++ // variable vaut 0
\end{PLM}






\sectionLabel{Opérateurs combinées avec une affectation}{operateursCombinesAffectationEntier}
\index{\&=!Entier}
\index{\textbar=!Entier}
\index{\^{}=!Entier}

Les trois opérateurs \plm!&=!, \plm!|=! et \plm!^=! sont définis pour les entiers.

\plm!a &= b! est équivalent à \plm!a = a & b!.

\plm!a |= b! est équivalent à \plm!a = a | b!.

\plm!a ^= b! est équivalent à \plm!a = a ^ b!.

Les opérateurs infixes \plm!&=!, \plm!|=! et \plm!^=! sont décrits à la \refSectionPage{operateurBitABitEntier}.


\section{Définition des types entier par une cible}

Les trois constructions suivantes ne peuvent apparaître que dans un fichier de définition de cible, dont l'extension est \texttt{.plm-target}. Un exemple d'utilisation est présenté à la \refSubsectionPage{fichierTarget}. Ces constructions sont :
\begin{itemize}
  \item déclaration d'une représentation entière non signée ;
  \item déclaration d'une représentation entière signée ;
  \item déclaration d'un type entier.
\end{itemize}


\subsectionLabel{Déclaration \texttt{newUnsignedRepresentation}}{DefNewUnsignedRepresentation}
\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=!Definition@Définition}

La déclaration \plm=newUnsignedRepresentation= permet de définir une représentation entière non signée. Sa syntaxe est la suivante :


\begin{PLM}
newUnsignedRepresentation @nom "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@nom= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers non signés sur 8, 16, 32 et 64 bits peut être définie par :
\begin{PLM}
newUnsignedRepresentation @unsigned8  "uint8_t"   8
newUnsignedRepresentation @unsigned16 "uint16_t" 16
newUnsignedRepresentation @unsigned32 "uint32_t" 32
newUnsignedRepresentation @unsigned64 "uint64_t" 64
\end{PLM}








\subsectionLabel{Déclaration \texttt{newSignedRepresentation}}{DefNewSignedRepresentation}
\index{newSignedRepresentation@\plm=newSignedRepresentation=!Definition@Définition}

La déclaration \plm=newSignedRepresentation= permet de définir une représentation entière signée. Sa syntaxe est la suivante :


\begin{PLM}
newSignedRepresentation @representation "type-c" taille
\end{PLM}

Où :
\begin{itemize}
  \item \plm=@representation= est le nom donné à la représentation ;
  \item \plm="type-c"= est le nom du type C qui sera utilisé lors de la génération de code ;
  \item \plm=taille= est le nombre de bits de cette représentation.
\end{itemize}

Par exemple, la représentation des entiers signés sur 8, 16, 32 et 64 bits peut être définie par :
\begin{PLM}
newSignedRepresentation @signed8  "int8_t"   8
newSignedRepresentation @signed16 "int16_t" 16
newSignedRepresentation @signed32 "int32_t" 32
newSignedRepresentation @signed64 "int64_t" 64
\end{PLM}











\subsectionLabel{Déclaration \texttt{newIntegerType}}{DefNewIntegerType}
\index{newIntegerType@\plm=newIntegerType=!Definition@Définition}

La déclaration \plm=newIntegerType= permet de définir un nouveau type entier signé ou non signé. Elle a la syntaxe suivante :
\begin{PLM}
newIntegerType NomDeType @representation
\end{PLM}
Où :
\begin{itemize}
  \item \plm=NomDeType= est le nom donné au type entier.
  \item \plm=@representation= est le nom de la représentation, qui doit avoir été défini soit par une déclaration \plm=newUnsignedRepresentation= (\refSubsectionPage{DefNewUnsignedRepresentation})\index{newUnsignedRepresentation@\plm=newUnsignedRepresentation=}, soit par une déclaration \plm=newSignedRepresentation= (\refSubsectionPage{DefNewSignedRepresentation}\index{newSignedRepresentation@\plm=newSignedRepresentation=}).
\end{itemize}

Le type entier ainsi déclaré est non signé si la représentation est non signée (c'est-à-dire déclarée avec \plm=newUnsignedRepresentation=), et signé si la représentation est signée (c'est-à-dire déclarée avec \plm=newSignedRepresentation=). Les types usuels peuvent ainsi être déclarés :
\begin{PLM}
newIntegerType $uint8  : @unsigned8
newIntegerType $uint16 : @unsigned16
newIntegerType $uint32 : @unsigned32
newIntegerType $uint64 : @unsigned64
newIntegerType $int8  : @signed8
newIntegerType $int16 : @signed16
newIntegerType $int32 : @signed32
newIntegerType $int64 : @signed64
\end{PLM}


