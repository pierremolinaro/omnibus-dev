%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex


\chapter{Tutorial}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}

\colorbox{red}{À revoir}


\emph{PLM} est un langage destiné aux systèmes embarqués. Particularités :
\begin{itemize}
  \item détection des débordements arithmétiques ;
  \item mode d'exécution d'une routine ;
  \item routines de démarrage, d'initialisation, d'exception ;
\end{itemize}



\sectionLabel{Premier exemple « blinkled »}{exempleBlinkled}

\subsection{Programmes d'exemple embarqués}

Le compilateur PLM embarque un certain nombre de fichiers d'exemple, prêts à l'emploi. Deux options (voir \refSectionPage{optionsExemplesEmbarques}) permettent de lister les fichiers d'exemple et de les extraire.

Pour afficher la liste des fichiers d'exemple, entrez :

\begin{SHELL}
{\bfseries plm -l}\\
Embedded sample code:\\ 
\hspace*{1.2em}/teensy-3-1-sequential-systick/blinkled.plm\\
\hspace*{1.2em}...
\end{SHELL}

Les exemples sont triés par cible, ainsi, pour la première ligne, la cible est \texttt{teensy-3-1-sequential-systick}, et le fichier d'exemple \texttt{blinkled.plm}. Comme son nom le suggère, cet exemple fait clignoter une led, celle embarquée sur la carte \emph{Teensy 3.1}.

\subsection{Extraction d'un fichier d'exemple}

Pour extraire le fichier d'exemple \texttt{blinkled.plm}, exécuter :

\begin{SHELL}
\bfseries plm -x=/teensy-3-1-sequential-systick/blinkled.plm
\end{SHELL}


Ceci écrit le fichier \texttt{blinkled.plm} dans le répertoire courant. Ce fichier est prêt à être compilé.

\subsection{Compilation et flashage}

Pour compiler et flasher la cible sur une carte \emph{Teensy 3.1}, entrer\footnote{Pour compiler sans flasher, ajouter l'option « \texttt{-f} » (\refSectionPage{optionCodeEngendre}) ; pour compiler avec des messages détaillés, ajouter l'option « \texttt{-v} » (\refSectionPage{optionsGenerales}). Les options peuvent apparaître sur la ligne de commande avant ou après le nom du fichier compilé.} :
\begin{SHELL}
{\bfseries plm blinkled.plm}\\
Downloading compiler tool chain\\
..................................................................\\
Product directory: \emph{voir ci-dessous}\\
Compiling plm.c\\
Linking product/product.elf\\
Hexing product/product.ihex\\
Loading Teensy...\\
Waiting for Teensy device (press the reset button)
\end{SHELL}

À la première compilation, le compilateur C va être automatiquement téléchargé\footnote{Les outils de compilation C sont installés en \texttt{$\sim$/plm-tools/}.}, cela peut prendre plusieurs minutes.

Ensuite, la compilation s'effectue, et range tous ses fichiers de production dans un sous répertoire de \texttt{$\sim$/plm-products/}, dont le nom est le  chemin absolu du fichier source (sans son extension), dans lequel tous les « \texttt{/} » ont été remplacés par des « \texttt{+} ».

Comme la compilation s'est effectuée sans erreur, et la carte \emph{Teensy 3.1} est prête à être flashée : appuyer sur le bouton \emph{reset} de la carte pour démarrer le flashage. Si vous ne voulez pas flasher la carte, entrez simplement \texttt{$ctrl$~C}. L'affichage sur le terminal devient :
\begin{SHELL}
Found HalfKay Bootloader\\
Read "product/product.ihex": 1472 bytes, 1.1\% usage\\
Programming..\\
Booting\\
Success
\end{SHELL}

Le programme d'exemple a été flashé (« \emph{Programming} »), puis le micro-contrôleur a été redémarré (« \emph{Booting} ») : la led de la carte clignote.

\subsection{Texte source de \texttt{blinkled.plm}}

Maintenant, nous allons examiner le code source PLM du fichier \texttt{blinkled.plm} :

\begin{PLM}[1]
target "teensy-3-1-sequential-systick.plms"

proc setup $user () {
  PORTC_PCR5 = PORTC_PCR5::mux (1)
  GPIOC_PDDR |= (1 << 5)
}

var gDelai : UInt32 = 0 {
  @rw proc loop ()
}

proc loop $user () {
  gDelai ++ ;
  if gDelai == 1_500_000 then
    GPIOC_PSOR = 1 << 5 ; // Allumer la led
  elsif gDelai == 3_000_000 then
    gDelai = 0
    GPIOC_PCOR = 1 << 5 ; // Éteindre la led
  end  
}
\end{PLM}

La première ligne \plm+target "teensy-3-1-sequential-systick.plms"+ nomme la cible, en référençant un fichier embarqué dans le compilateur. Un fichier de définition de cible comporte toujours l'extension « \texttt{.plms} », et définit types, routines, registres de contrôle, … Un fichier de définition de cible ne peut être compilé séparement, il doit être cité dans un programme utilisateur (ici \texttt{blinkled.plm}). Un fichier de définition de cible peut exiger que le programme utilisateur définisse certains routines : ici, les deux routines \plm+proc setup $user ()+ et \plm+proc loop $user ()+ doivent être définies ; essayez de les commenter\footnote{Un commentaire commence par « \texttt{//} » et s'étend jusqu'à la fin de la ligne courante.}, vous obtiendrez des messages d'erreur.

Comme pour l'Arduino, la routine \plm+proc setup $user ()+ est exécutée une seule fois, puis la routine \plm+proc setup $user ()+ est exécutée de manière répétitive. En PLM, à toute routine est associé un \emph{mode d'exécution}. Syntaxiquement, un mode d'exécution est un nom précédé du caractère « \texttt{\$} » : ici, \plm+$user+. Un \emph{mode d'exécution} permet au compilateur de vérifier la cohérence de l'appel d'une routine, par exemple qu'une routine d'interruption n'est pas appelée directement\footnote{Les \emph{modes d'exécution} font l'objet du \refChapterPage{chapitreModesExecution}.}. Ici, dans le cadre d'un exemple très simple, l'annotation de mode peut sembler superflue, car inutile. 


Examinons la la routine \plm+proc setup $user ()+. La cible n'effectue aucune configuration des entrées / sorties, aussi faut-il programmer le port \texttt{PC5}, qui est connecté à la led de la carte, en sortie logique. Cette programmation est faite par les lignes :

\begin{PLM}[4]
  PORTC_PCR5 = PORTC_PCR5::mux (1)
  GPIOC_PDDR |= (1 << 5)
\end{PLM}

\plm+PORTC_PCR5+ et \plm+GPIOC_PDDR+ sont des registres de contrôle du micro-contrôleur, et sont définis par la cible. La notation \plm+PORTC_PCR5::mux(1)+ permet de définir une constante à partir de la définition des champs de bits du registre \plm+PORTC_PCR5+. La cible définit le registre \plm+PORTC_PCR5+ de la façon suivante\footnote{Voir la \refSectionPage{declarationRegistreEtChamps} pour l'explication détaillée de cette notation.} :

\begin{PLM}[0]
register PORTC_PCR5 at 0x4004_B014 : UInt32 {
  7, isf, 4, irqc[4], lk, 4, mux[3], 1, dse, ode, pfe, 1, sre, pe, ps
}
\end{PLM}

Le champ \plm+mux+ est un champ de $3$ bits, commençant au bit $8$. Le paramètre \plm+(1)+ affecte à ce champ la valeur binaire \plm+001+. La constante \plm+PORTC_PCR5::mux(1)+ a donc pour valeur \plm+0x0000_0800+.

Examinons maintenant la déclaration de \plm+gDelai+ :
\begin{PLM}[8]
var gDelai : UInt32 = 0 {
  @rw proc loop ()
}
\end{PLM}

C'est une variable (la déclaration commence par \plm+var+) globale (elle est déclarée en dehors d'une routine). Son type est \plm+UInt32+ (entier non signé sur $32$ bits, défini par la cible), et sa valeur initiale est $0$.

En PLM, une variable globale doit citer les routines qui ont le droit de l'utiliser : ici la procédure \plm+loop+ a le droit de l'accéder, et en lecture et en écriture grâce à l'annotation \plm+@rw+ ; sans celle-ci, seul l'accès en lecture serait accepté.

Enfin, la routine \plm+loop+ :
\begin{PLM}[12]
proc loop $user () {
  gDelai ++ ;
  if gDelai == 1_500_000 then
    GPIOC_PSOR = 1 << 5 ; // Allumer la led
  elsif gDelai == 3_000_000 then
    gDelai = 0
    GPIOC_PCOR = 1 << 5 ; // Éteindre la led
  end  
}
\end{PLM}

Son écriture est simple : la variable globale \plm+gDelai+ est incrémentée (sa valeur initiale est $0$) ; quand elle atteint $1~500~000$, la led est allumée ; quand elle atteint $3~000~000$, elle est ramenée à $0$ et la led est éteinte.

