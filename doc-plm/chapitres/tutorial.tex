%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex


\chapter{Tutorial}

%--- Pour supprimer tout en-tête et pied de page sur la 1re page d'un chapitre
\thispagestyle{empty}

\colorbox{red}{À revoir}


\emph{PLM} est un langage destiné aux systèmes embarqués. Particularités :
\begin{itemize}
  \item détection des débordements arithmétiques ;
  \item mode d'exécution d'une routine ;
  \item routines de démarrage, d'initialisation, d'exception ;
\end{itemize}


\sectionLabel{Premier exemple « blinkled »}{exempleBlinkled}

\subsection{Programmes d'exemple embarqués}

Le compilateur PLM embarque un certain nombre de fichiers d'exemple, prêts à l'emploi. Deux options (voir \refSectionPage{optionsExemplesEmbarques}) permettent de lister les fichiers d'exemple et de les extraire.

Pour afficher la liste des fichiers d'exemple, entrez :

\begin{SHELL}
{\bfseries plm -l}\\
Embedded sample code:\\ 
\hspace*{1.2em}/teensy-3-1-sequential-systick/01-blinkled.plm\\
\hspace*{1.2em}...
\end{SHELL}

Les exemples sont triés par cible, ainsi, pour la première ligne, la cible est \texttt{teensy-3-1-sequential-systick}, et le fichier d'exemple \texttt{01-blinkled.plm}. Les noms des fichiers d'exemple commencent par des chiffres, simplement pour qu'ils apparaissent dans l'ordre souhaité. Vous pouvez nommer vos fichiers PLM comme vous le voulez.

Comme son nom le suggère, l'exemple \texttt{01-blinkled.plm} fait clignoter une led, celle embarquée sur la carte \emph{Teensy 3.1}.

\subsection{Extraction d'un fichier d'exemple}

Pour extraire le fichier d'exemple \texttt{01-blinkled.plm}, exécuter :

\begin{SHELL}
\bfseries plm -x=/teensy-3-1-sequential-systick/01-blinkled.plm
\end{SHELL}


Ceci écrit le fichier \texttt{01-blinkled.plm} dans le répertoire courant. Ce fichier est prêt à être compilé.

\subsection{Compilation et flashage}

Pour compiler et flasher la cible sur une carte \emph{Teensy 3.1}, entrer\footnote{Pour compiler sans flasher, ajouter l'option « \texttt{-f} » (\refSectionPage{optionCodeEngendre}) ; pour compiler avec des messages détaillés, ajouter l'option « \texttt{-v} » (\refSectionPage{optionsGenerales}). Les options peuvent apparaître sur la ligne de commande avant ou après le nom du fichier compilé.} :
\begin{SHELL}
{\bfseries plm 01-blinkled.plm}\\
Downloading compiler tool chain\\
..................................................................\\
Product directory: \emph{voir ci-dessous}\\
Compiling plm.c\\
Linking product/product.elf\\
Hexing product/product.ihex\\
Loading Teensy...\\
Waiting for Teensy device (press the reset button)
\end{SHELL}

À la première compilation, le compilateur C va être automatiquement téléchargé\footnote{Les outils de compilation C sont installés en \texttt{$\sim$/plm-tools/}.}, cela peut prendre plusieurs minutes.

Ensuite, la compilation s'effectue, et range tous ses fichiers de production dans un sous répertoire de \texttt{$\sim$/plm-products/}, dont le nom est le  chemin absolu du fichier source (sans son extension), dans lequel tous les « \texttt{/} » ont été remplacés par des « \texttt{+} ».

Comme la compilation s'est effectuée sans erreur, et la carte \emph{Teensy 3.1} est prête à être flashée : appuyer sur le bouton \emph{reset} de la carte pour démarrer le flashage. Si vous ne voulez pas flasher la carte, entrez simplement \texttt{`ctrl`~C}. L'affichage sur le terminal devient :
\begin{SHELL}
Found HalfKay Bootloader\\
Read "product/product.ihex": 1472 bytes, 1.1\% usage\\
Programming..\\
Booting\\
Success
\end{SHELL}

Le programme d'exemple a été flashé (« \emph{Programming} »), puis le micro-contrôleur a été redémarré (« \emph{Booting} ») : la led de la carte clignote.

\subsection{Texte source de \texttt{01-blinkled.plm}}

Maintenant, nous allons examiner le code source PLM du fichier \texttt{01-blinkled.plm} :

\begin{PLM}[1]
target "teensy-3-1-sequential-systick"

proc setup `user () {
  PORTC_PCR5 = PORTC_PCR5::mux (1)
  GPIOC_PDDR |= (1 << 5)
}

var gDelai : UInt32 = 0 {
  @rw proc loop ()
}

proc loop `user () {
  gDelai ++ ;
  if gDelai == 1_500_000 then
    GPIOC_PSOR = 1 << 5 ; // Allumer la led
  elsif gDelai == 3_000_000 then
    gDelai = 0
    GPIOC_PCOR = 1 << 5 ; // Éteindre la led
  end  
}
\end{PLM}

La première ligne \plm+target "teensy-3-1-sequential-systick"+ nomme la cible, en référençant un fichier embarqué dans le compilateur. Un fichier de définition de cible définit types, routines, registres de contrôle, … Un fichier de définition de cible ne peut être compilé séparement, il doit être cité dans un programme utilisateur (ici \texttt{01-blinkled.plm}). Un fichier de définition de cible peut exiger que le programme utilisateur définisse certains routines : ici, les deux routines \plm+setup+ et \plm+loop+ doivent être définies ; essayez de les commenter\footnote{Un commentaire commence par « \texttt{//} » et s'étend jusqu'à la fin de la ligne courante.}, vous obtiendrez des messages d'erreur.

Comme pour l'Arduino, la routine \plm+setup+ est exécutée une seule fois, puis la routine \plm+setup+ est exécutée de manière répétitive. En PLM, à toute routine est associé un \emph{mode d'exécution}\index{Mode@Mode d'exécution}. Syntaxiquement, un mode d'exécution est un nom précédé du caractère « \texttt{\`} » : ici, \plm+`user+. Un \emph{mode d'exécution} permet au compilateur de vérifier la cohérence de l'appel d'une routine, par exemple qu'une routine d'interruption n'est pas appelée directement\footnote{Les \emph{modes d'exécution} font l'objet du \refChapterPage{chapitreModesExecution}.}. Ici, dans le cadre d'un exemple très simple, l'annotation de mode peut sembler superflue, car la sûreté qu'elle apporte n'est pas exploitée. 


Examinons la la routine \plm+proc setup `user ()+. La cible n'effectue aucune configuration des entrées / sorties, aussi faut-il programmer le port \texttt{PC5}, qui est connecté à la led de la carte, en sortie logique. Cette programmation est faite par les lignes :

\begin{PLM}[4]
  PORTC_PCR5 = PORTC_PCR5::mux (1)
  GPIOC_PDDR |= (1 << 5)
\end{PLM}

\plm+PORTC_PCR5+ et \plm+GPIOC_PDDR+ sont des registres de contrôle du micro-contrôleur, et sont définis par la cible. La notation \plm+PORTC_PCR5::mux(1)+ permet de définir une constante à partir de la définition des champs de bits du registre \plm+PORTC_PCR5+. La cible définit le registre \plm+PORTC_PCR5+ de la façon suivante\footnote{Voir la \refSectionPage{declarationRegistreEtChamps} pour l'explication détaillée de cette notation.} :

\begin{PLM}[0]
register PORTC_PCR5 at 0x4004_B014 : UInt32 {
  7, isf, 4, irqc[4], lk, 4, mux[3], 1, dse, ode, pfe, 1, sre, pe, ps
}
\end{PLM}

Le champ \plm+mux+ est un champ de `3` bits, commençant au bit `8`. Le paramètre \plm+(1)+ affecte à ce champ la valeur binaire \plm+001+. La constante \plm+PORTC_PCR5::mux(1)+ a donc pour valeur \plm+0x0000_0800+.

Examinons maintenant la déclaration de \plm+gDelai+ :
\begin{PLM}[8]
var gDelai : UInt32 = 0 {
  @rw proc loop ()
}
\end{PLM}

C'est une variable (la déclaration commence par \plm+var+) globale (elle est déclarée en dehors d'une routine). Son type est \plm+UInt32+ (entier non signé sur `32` bits, défini par la cible), et sa valeur initiale est `0`.

En PLM, une variable globale doit citer les routines qui ont le droit de l'utiliser : ici la procédure \plm+loop+ a le droit de l'accéder, et en lecture et en écriture grâce à l'annotation \plm+@rw+ ; sans celle-ci, seul l'accès en lecture serait accepté.

Enfin, la routine \plm+loop+ :
\begin{PLM}[12]
proc loop `user () {
  gDelai ++ ;
  if gDelai == 1_500_000 then
    GPIOC_PSOR = 1 << 5 ; // Allumer la led
  elsif gDelai == 3_000_000 then
    gDelai = 0
    GPIOC_PCOR = 1 << 5 ; // Éteindre la led
  end  
}
\end{PLM}

Son écriture est simple : la variable globale \plm+gDelai+ est incrémentée à chaque exécution (sa valeur initiale est `0`) ; quand elle atteint `1~500~000`, la led est allumée ; quand elle atteint `3~000~000`, elle est ramenée à `0` et la led est éteinte. Les valeurs `1~500~000` et `3~000~000` sont empiriques et choisies pour obtenir un clignotement visible. L'exemple suivant va montrer comment utiliser une routine d'interruption pour obtenir un délai dont l'unité sera la milliseconde.





\sectionLabel{Deuxième exemple : clignotement avec routine d'interruption}{deuxiemeExemple}

La cible \texttt{teensy-3-1-sequential-systick} programme le décompteur \texttt{SysTick} de façon que l'interruption correspondante se déclenche toutes les millisecondes, et appelle une routine d'interruption. Par défaut, cette routine ne comporte aucune instruction et n'a donc aucun effet. 

Le programme d'exemple \texttt{02-blinkled-systick.plm} redéfinit cette routine d'interruption et l'utilise pour compter le temps.

Pour extraire le programme d'exemple :
\begin{SHELL}
\bfseries plm -x=/teensy-3-1-sequential-systick/02-blinkled-systick.plm
\end{SHELL}

Ensuite, vous pouvez le compiler et effectuer son flashage sur la carte \emph{Teensy 3.1} :
\begin{SHELL}
\bfseries plm 02-blinkled-systick.plm
\end{SHELL}

La led sur la carte \emph{Teensy 3.1} clignote à la fréquence de `1`~Hz.

Voyons maintenant le contenu du fichier d'exemple \texttt{02-blinkled-systick.plm} :

\begin{PLM}[1]
target "teensy-3-1-sequential-systick"

proc setup `user () {
  PORTC_PCR5 = PORTC_PCR5::mux (1)
  GPIOC_PDDR |= (1 << 5)
}

var gUpTimeMS : UInt32 = 0 {
  @rw proc systickHandler ()
  proc wait (?ms: inDuration : UInt32)
}

proc systickHandler `isr () {
  gUpTimeMS ++
}

proc wait `user (?ms: inDuration : UInt32) {
  let deadline = gUpTimeMS + inDuration
  while deadline > gUpTimeMS do
  end
}

proc loop `user () {
  wait (!ms:500)
  GPIOC_PSOR = 1 << 5 // Allumer la led
  wait (!ms:500)
  GPIOC_PCOR = 1 << 5  // Éteindre la led
}
\end{PLM}

La référence à la cible \plm+target "teensy-3-1-sequential-systick"+ et la définition de la routine \plm+setup+ sont identiques à celles écrites dans le premier exemple.

La définition de la variable globale \plm+gUpTimeMS+ :

\begin{PLM}[8]
var gUpTimeMS : UInt32 = 0 {
  @rw proc systickHandler ()
  proc wait (?ms: inDuration : UInt32)
}
\end{PLM}

Cette variable compte le temps exprimé en millisecondes. Deux routines y accèdent, \plm+systickHandler+ en lecture / écriture, et \plm+wait+, uniquement en lecture. Remarquons que \plm+wait+ présente un argument formel en entrée, \plm+inDuration+, dont la notation sera présentée plus loin.

La routine d'interruption \plm+systickHandler+ :

\begin{PLM}[13]
proc systickHandler `isr () {
  gUpTimeMS ++
}
\end{PLM}

Le mode associé à une routine d'interruption est toujours \plm+`isr+. L'instruction d'appel de routine (\refSectionPage{instructionAppelProc}) vérifie que les modes de la routine appelée soient un sous-ensemble des modes de la routine appelante : ainsi, par exemple, il n'est pas possible d'appeler \plm+systickHandler+ à partir de la routine \plm+loop+.

La routine d'interruption \plm+systickHandler+ est appelée toutes les millisecondes, la variable globale \plm+gUpTimeMS+ contient donc le temps absolu depuis le démarrage, exprimé en millisecondes.

L'attente durant un certain délai est effectué par la routine \plm+wait+ :
\begin{PLM}[17]
proc wait `user (?ms: inDuration : UInt32) {
  let deadline = gUpTimeMS + inDuration
  while deadline > gUpTimeMS do
  end
}
\end{PLM}

Cette routine présente un paramètre formel : \plm+inDuration+, de type \plm+UInt32+. Le \emph{sélecteur} \plm+?ms:+ indique que \plm+inDuration+ est un paramètre en entrée (son sélecteur commence par « \texttt{?} »), et que le nom de ce sélecteur est « \texttt{ms} »\footnote{La liste de tous les arguments formels et des paramètres effectifs correspondants est présentée à la \refSectionPage{argumentFormel}.}.

Le code de cette routine est simple : après avoir calculé la constante \plm+deadline+\footnote{Une constante locale à une routine est déclarée par le mot réservé \texttt{\bfseries let} (voir \refSectionPage{declarationConstanteLocale}).}, la boucle \plm+while+ attend le délai imparti.

Il reste à commenter le code ce la routine \plm+loop+ :
\begin{PLM}[23]
proc loop `user () {
  wait (!ms:500)
  GPIOC_PSOR = 1 << 5 // Allumer la led
  wait (!ms:500)
  GPIOC_PCOR = 1 << 5  // Éteindre la led
}
\end{PLM}

Intéressons-nous à l'appel de la routine \plm+wait+ ; celle-ci présente un argument formel en entrée, dont le sélecteur est \plm+?ms:+. L'instruction d'appel devra donc comporter un paramètre effectif en sortie (donc son sélecteur commence par « \texttt{!} »), et de même nom : le sélecteur du paramètre effectif est donc \plm+!ms:+. En ce qui concerne les modes, la routine appelée \plm+wait+ est déclarée avec le mode \plm+`user+, comme la routine appelante \plm+loop+ : l'appel est donc valide.



\section{Fichiers produits par la compilation}

À titre d'information, on décrit l'organisation des fichiers produits par la compilation d'un fichier \texttt{f{}ichier.plm}. Cette organisation est résumée par la \refFigure{}{compilationProgrammePLM}.

\begin{figure}[ht]
  \centering
  \footnotesize
  \begin{tikzpicture}[
      block/.style ={rectangle, draw=black, thick, fill=white, align=center, minimum height=0.5cm, minimum width=1.4cm},
      block2/.style ={rectangle, draw=black, thick, fill=white, align=center, minimum height=0.5cm, minimum width=1.6cm},
      node distance=0.5cm and 1.4cm
    ]
    \node [block] (plm) at (0, 0) {\tt f{}ichier.plm} ;
    \node (ws) [right=of plm, minimum height=0.6cm, minimum width=1.4cm] {} ;
    \node [block] (plmc) [right=of ws] {\tt plm.c} ;
    \node [block] (plms) [below=of plmc] {\tt plm.s} ;
    \node [block] (plmco) [right=of plmc] {\tt plm.c.o} ;
    \node [block] (plmso) [right=of plms] {\tt plm.s.o} ;
    \node [block] (link) [below=of plms] {\tt link.ld} ;
    \node [block] (elf) [right=of plmso] {\tt plm.elf} ;
    \node (elf2) [above=of elf, minimum height=0.6cm] {};
    \node [block] (make) [below=of link] {\tt make.py};
    \node [block] (makeplm) [below=of make] {\tt plm.py};
    \begin{scope}[node distance=0.1cm and 1.6cm]
      \node [block2] (build) at (3, -0.5) {\tt build.py};
      \node [block2] (clean) [below=of build] {\tt clean.py};
      \node [block2] (run) [below=of clean] {\tt run.py};
      \node [block2] (buildas) [below=of run] {\tt build-as.py};
      \node [block2] (buildverbose) [below=of buildas] {\tt build-verbose.py};
      \node [block2] (objsize) [below=of buildverbose] {\tt objsize.py};
      \node [block2] (objdump) [below=of objsize] {\tt objdump.py};
    \end{scope}

    \draw [-stealth, thick] (plm) to node [above] {\tt plm} (plmc) ;
    \draw [-stealth, thick] (ws.east) -- +(0.7, 0) |- (plms.west) ;
    \draw [-stealth, thick] (ws.east) -- +(0.7, 0) |- (link) ;
    \draw [-stealth, thick] (ws.east) -- +(0.7, 0) |- (make) ;
    \draw [-stealth, thick] (ws.east) -- +(0.7, 0) |- (makeplm) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (build.west) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (run.west) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (clean.west) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (buildas.west) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (buildverbose.west) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (objsize.west) ;
    \draw [-stealth, thick] (plm.east) -- +(0.3, 0) |- (objdump.west) ;
    \draw [-stealth, thick] (plms) to node[above] {\tt gcc} (plmso) ;
    \draw [-stealth, thick] (plmso) to node[above right] {\tt gcc} (elf) ;
    \draw [-stealth, thick] (plmc) to node[above] {\tt gcc} (plmco) ;
    \draw [thick] (plmco.east) -- +(0.7, 0) |- (elf.west) ;
    \draw [thick] (elf.west) -- +(-0.7, 0) |- (plmco.east) ;
    \draw [thick] (elf.west) -- +(-0.7, 0) |- (link.east) ;
    
    \begin{scope}[node distance=5mm]
    \node (repws) [above=of ws] {\tt ws/} ;
    \node (source) [above=of plmc] {\tt ws/sources/} ;
    \node (objects) [above=of plmco] {\tt ws/objects/} ;
    \node (product) [above=of elf2] {\tt ws/product/} ;
    \node (titre) [above=of plm] {Répertoires :} ;
    \end{scope}
  \end{tikzpicture}
  \caption{Fichiers produits par la compilation d'un programme PLM}
  \labelFigure{compilationProgrammePLM}
  \ligne
\end{figure}



Les fichiers produits par la compilation sont regroupés dans un répertoire noté \texttt{ws} dans la \refFigure{}{compilationProgrammePLM}, et obtenu de la façon suivante :
\begin{itemize}
  \item on considère le chemin absolu du fichier source ; par exemple, pour {\tt f{}ichier.plm} situé dans le répertoire courant \texttt{/chemin/absolu} : \colorbox{gray!25}{\tt/chemin/absolu/f{}ichier.plm} ;
  \item on retire l'extension du fichier source ; \colorbox{gray!25}{\tt/chemin/absolu/f{}ichier} ;
  \item on remplace chaque « \texttt{/} » par un « \texttt{+} » : \colorbox{gray!25}{\tt+chemin+absolu+f{}ichier} ;
  \item le chemin vers le répertoire \texttt{ws} est obtenu en préfixant par \texttt{$\sim$/plm-product/}, où $\sim$ est le répertoire \emph{home} de l'utilisateur : \colorbox{gray!25}{\tt$\sim$/plm-product/+chemin+absolu+f{}ichier}.
\end{itemize}

\begin{table}[t!]
\centering
\begin{tabular}{p{2cm}p{11cm}}
  \textbf{Nom} & \textbf{Commentaire} \\
  \texttt{build.py} & Effectue la compilation de \texttt{plm.c}, l'assemblage de \texttt{plm.s}, et l'édition de liens afin d'obtenir l'exécutable \texttt{plm.elf}, comme décrit à la \refFigure{}{compilationProgrammePLM}. \\
  \texttt{build-as.py} & Effectue la compilation de \texttt{plm.c} jusqu'à la génération d'un fichier assembleur \texttt{plm.c.s} qui est placé dans \texttt{ws/objects}. Cette opération permet de connaître la traduction en assembleur du source C.\\
  \texttt{build-verbose.py} & Effectue les mêmes opérations que \texttt{build.py}, mais affiche les lignes de commande.\\
  \texttt{run.py} & Construit l'exécutable \texttt{plm.elf} (comme le fait \texttt{build.py}), et lance l'exécution sur la cible. Équivalent à l'option \texttt{-f} de la ligne de commande. \\
  \texttt{clean.py} & Supprime les répertoires \texttt{ws/objects} et \texttt{ws/product}. \\
  \texttt{objdump.py} & Effectue les mêmes opérations que \texttt{build.py}, puis affiche le code machine obtenu désassemblé. \\
  \texttt{objsize.py} & Effectue les mêmes opérations que \texttt{build.py}, puis affiche la taille du code engendré. \\
\end{tabular}
\caption{Scripts Python engendrés dans le répertoire \texttt{ws}}
\labelTableau{scriptsPythonEngendres}
\ligne
\end{table}

\begin{table}[t!]
\centering
\begin{tabular}{p{2cm}p{11cm}}
  \textbf{Nom} & \textbf{Commentaire} \\
  \texttt{plm.c} & Contient tout le code C de l'application. \\
  \texttt{plm.s} & Contient tout le code assembleur de l'application. En fonction de la cible, ce fichier peut être vide.\\
  \texttt{make.py} & Makefile générique écrit en Python.\\
  \texttt{plm.py} & Configuration du makefile générique pour la compilation PLM.\\
  \texttt{link.ld} & Script de l'édition de liens.\\
\end{tabular}
\caption{Fichiers engendrés dans le répertoire \texttt{ws/sources}}
\labelTableau{fichiersSourcesEngendres}
\ligne
\end{table}

La compilation place dans le répertoire \texttt{ws} les scripts \emph{python} décrits par le \refTableau{scriptsPythonEngendres}. Ces scripts peuvent être appelés directement à partir de la ligne de commande.


Le répertoire \texttt{ws/sources} contient les fichiers décrits dans le \refTableau{fichiersSourcesEngendres}, \texttt{ws/objects} contient les fichiers objets issus de la compilation et l'assemblage, et \texttt{ws/product} le fichier exécutable nommé \texttt{plm.elf}. Suivant la cible, il peut aussi contenir l'exécutable \texttt{plm.ihex} sous le format \emph{hex} d'Intel.
