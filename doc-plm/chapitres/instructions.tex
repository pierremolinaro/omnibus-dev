%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Instructions}





\sectionLabel{Déclaration d'une variable locale}{declarationVariableLocale}\index{Variable!locale}

La déclaration d'une variable locale peut prendre plusieurs formes, suivant que la variable est initialisée ou non.

\subsection{Déclaration d'une variable locale initialisée}

\begin{PLM}
var nom $type = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable locale ;
  \item \plm=$type= est le nom du type de la variable globale ;
  \item \plm=expression= est l'expression qui fournit la valeur initiale de cette variable ; cette expression peut être statique ou non.
\end{itemize}

L'annotation de type peut être omise ; la variable a alors le type de l'expression qui l'initialise :
\begin{PLM}
var nom = expression
\end{PLM}


\subsection{Déclaration d'une variable locale non initialisée}
\begin{PLM}
var nom $yype
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable locale ;
  \item \plm=$type= est le nom du type de la variable globale.
\end{itemize}

Le compilateur garantit qu'aucune lecture n'est faite avant que la variable reçoive une valeur.










\sectionLabel{Déclaration d'une constante locale}{declarationConstanteLocale}\index{Constante!locale}

La déclaration d'une constante locale apparaît dans une liste d'instructions et sa syntaxe est la suivante :

\begin{PLM}
let nom $type = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la constante globale ;
  \item \plm=$type= est le nom du type de la constante globale ;
  \item \plm=expression= est l'expression qui fournit la valeur de cette constante ; cette expression est soit calculable statiquement, soit à l'exécution.
\end{itemize}

Il n'y a aucune restriction pour l'\plm=expression= : elle peut nommer constantes locales et globales, variables locales et globales.






\section {Instruction d'affectation}

L'instruction d'affectation se présente sous plusieurs formes ; la plus simple est la suivante :

\begin{PLM}
nom = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom d'une variable glogale ou locale, ou le nom d'un registre de contrôle ;
  \item \plm=expression= est l'expression qui fournit la valeur.
\end{itemize}









%\sectionLabel{Instructions d'incrémentation et de décrémentation}{instructionIncDec}
%\index{Incrementation@Incrémentation!Instruction}
%\index{Decrementation@Decrémentation!Instruction}
%
%Les opérateurs postfixés \plm=++= et \plm=--= réalisent respectivement l'incrémentation et la décrémentation de la variable nommée dans l'instruction :
%\begin{PLM}
%variable ++
%\end{PLM}
%
%\plm=++= et \plm=--= déclenchent la panique sur dépassement de capacité.
%
%Les opérateurs \plm=++%= et \plm=--%= ignorent le dépassement de capacité.
%
%Les instructions d'incrémentation et de décrémentation de variables entières sont détaillées à la \refSectionPage{incDecEntier}.
%





\sectionLabel {Opérateurs combinés avec l'affectation}{operateursCombinesAffectation}
\index{\&=}
\index{\textbar=}
\index{\^{}=}

Le \refTableau{tableauOperateursCombinesAffectation} liste les opérateurs combinés avec une affectation.
\begin{table}[ht]
\centering
\begin{tabular}{rcl}
  \textbf{Opérateur combiné} & \textbf{Écriture équivalente} & \textbf{Lien}\\
  \plm!a &= b! & \plm!a = a & b! & \refSectionPage{operateursCombinesAffectationEntier}\\
  \plm!a |= b! & \plm!a = a | b! & \refSectionPage{operateursCombinesAffectationEntier}\\
  \plm!a ^= b! & \plm!a = a ^ b! & \refSectionPage{operateursCombinesAffectationEntier}\\
  \plm!a += b! & \plm!a = a + b! \\
  \plm!a +%= b! & \plm!a = a +% b! \\
  \plm!a -= b! & \plm!a = a - b! \\
  \plm!a -%= b! & \plm!a = a -% b! \\
  \plm!a *= b! & \plm!a = a * b! \\
  \plm!a *%= b! & \plm!a = a *% b! \\
  \plm-a /= b- & \plm-a = a / b- \\
  \plm-a !/= b- & \plm-a = a !/ b- \\
  \plm-a %= b- & \plm-a = a % b- \\
  \plm-a !%= b- & \plm-a = a !% b- \\
\end{tabular}
\caption{Opérateurs combinés avec l'affectation}
\labelTableau{tableauOperateursCombinesAffectation}
\end{table}


\sectionLabel{Instruction \texttt{check}}{directiveCheck}\index{check@\plm=check=}

La directive \plm=check= apparaît dans une liste d'instructions et a la syntaxe suivante :
\begin{PLM}
check expression
\end{PLM}

L'\plm=expression= est une expression booléenne calculée statiquement.

Contrairement à l'instruction \plm=assert= (\refSectionPage{instructionAssert}) qui évalue l'expression booléenne à l'exécution, la directive \plm=check= est toujours évaluée à la compilation. Elle permet d'exprimer des assertions qui sont évaluées lors de la compilation.

Aucun code n'est engendré. La directive \plm=check= peut donc apparaître dans des listes d'instructions où la panique est interdite.

Exemples :
\begin{PLM}
check true  // Ok
check false // Erreur, expression fausse
\end{PLM}



\sectionLabel{L'instruction \texttt{assert}}{instructionAssert}\index{assert@\plm=assert=}

L'instruction \plm=assert= a la syntaxe suivante :
\begin{PLM}
assert expression
\end{PLM}

L'\plm=expression= est une expression booléenne non calculable statiquement.

Si le programme est compilé avec la panique activée, alors le compilateur engendre le code de calcul de l'expression booléenne. Celle-ci sera calculée à l'exécution. Si le résultat est faux, une panique (dont le code est donné par le \refTableau{tableauCodePanique}) est déclenchée.

Si le programme est compilé avec l'option \texttt{-{}-no-panic-generation}, alors aucun code n'est engendré.

Noter que \plm=expression= ne doit pas être calculable statiquement. Si elle est calculable statiquement, il faut utiliser la directive \plm=check=, \refSectionPage{directiveCheck}. Par exemple, le code suivant provoque une erreur de compilation :
\begin{PLM}
assert true // Erreur, l'expression est calculable statiquement
\end{PLM}



\section{L'instruction \texttt{panic}}\index{panic@\plm=panic=}

L'instruction \plm=panic= a la syntaxe suivante :
\begin{PLM}
panic expression
\end{PLM}

L'\plm=expression= est une expression entière, calculée statiquement. Son type est défini pour chaque cible (\refSectionPage{typePanique}) et peut être signé (les valeurs négatives sont alors acceptées) ou non signé.

Si le programme est compilé avec la panique activée, alors l'exécution de l'instruction \plm=panic= déclenche la panique avec le code est la valeur de l'\plm=expression=.

Si le programme est compilé avec l'option \texttt{-{}-no-panic-generation}, alors aucun code n'est engendré.




\sectionLabel{Instruction d'appel de procédure}{instructionAppelProc}

\colorbox{red}{À définir}


\section{Instruction \texttt{if}}
\index{if@\plm=if=}

L'instruction \plm=if= a une structure classique, où \plm=condition= est une expression booléenne :
\begin{PLM}
if condition then
  instructions_then
else
  instructions_else
end
\end{PLM}

Le compilateur vérifie que la \plm=condition= n'est pas une expression statique : une erreur de compilation est émise si elle l'est.

La branche \plm=else= est optionnelle :
\begin{PLM}
if condition then
  instructions_then
end
\end{PLM}


Une ou plusieurs branches \plm=elsif= peuvent être ajoutées, avec ou sans branche \plm=else= :
\begin{PLM}
if condition then
  instructions_then
elsif condition2 then
  instructions_elsif
elsif condition3 then
  instructions_elsif_3
else
  instructions_else
end
\end{PLM}

\subsectionLabel{Étiquettes}{etiquette-if}

Des \emph{étiquettes} peuvent être ajoutées pour augmenter la lisibilité :
\begin{PLM}
if@xyz condition then
  instructions_then
elsif@xyz condition2 then
  instructions_elsif
elsif@xyz condition3 then
  instructions_elsif_3
else@xyz
  instructions_else
end@xyz
\end{PLM}

Une étiquette est lexicalement un attribut, c'est-à-dire un nom préfixé par un \texttt{@}. Si une étiquette est apposée à un \plm!if!, alors les \plm!elsif!, \plm!else! et \plm!end! correspondants doivent être suivis par la même étiquette. De plus, une étiquette est unique dans une routine.


\section{Instruction \texttt{while}}
\index{if@\plm=while=}

L'instruction \plm=while= permet d'exprimer une répétition, où la \plm=condition= est testée avant l'exécution des instructions de la boucle :
\begin{PLM}
while condition do
  instructions_while
end
\end{PLM}

\plm=condition= est une expression booléenne, qui ne doit pas être statique : une erreur de compilation est émise si elle l'est.

Des \emph{étiquettes} peuvent être ajoutées pour augmenter la lisibilité :
\begin{PLM}
while@boucle condition do
  instructions_while
end@boucle
\end{PLM}

Une étiquette est lexicalement un attribut, c'est-à-dire un nom préfixé par un \texttt{@}. Si une étiquette est apposée à un \plm!while!, alors le \plm!end! correspondant doit être suivi par la même étiquette. De plus, une étiquette est unique dans une routine.

