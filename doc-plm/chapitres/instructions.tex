%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Instructions}





\sectionLabel{Déclaration d'une variable locale}{declarationVariableLocale}\index{Variable!locale}

La déclaration d'une variable locale peut prendre plusieurs formes, suivant que la variable est initialisée ou non.

\subsection{Déclaration d'une variable locale initialisée}

\begin{PLM}
var nom $type = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable locale ;
  \item \plm=$type= est le nom du type de la variable globale ;
  \item \plm=expression= est l'expression qui fournit la valeur initiale de cette variable ; cette expression peut être statique ou non.
\end{itemize}

L'annotation de type peut être omise ; la variable a alors le type de l'expression qui l'initialise :
\begin{PLM}
var nom = expression
\end{PLM}


\subsection{Déclaration d'une variable locale non initialisée}
\begin{PLM}
var nom $yype
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable locale ;
  \item \plm=$type= est le nom du type de la variable globale.
\end{itemize}

Le compilateur garantit qu'aucune lecture n'est faite avant que la variable reçoive une valeur.










\sectionLabel{Déclaration d'une constante locale}{declarationConstanteLocale}\index{Constante!locale}

La déclaration d'une constante locale apparaît dans une liste d'instructions et sa syntaxe est la suivante :

\begin{PLM}
let nom $type = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la constante globale ;
  \item \plm=$type= est le nom du type de la constante globale ;
  \item \plm=expression= est l'expression qui fournit la valeur de cette constante ; cette expression est soit calculable statiquement, soit à l'exécution.
\end{itemize}

Il n'y a aucune restriction pour l'\plm=expression= : elle peut nommer constantes locales et globales, variables locales et globales.






\section {Instruction d'affectation}

L'instruction d'affectation est la suivante :

\begin{PLM}
nom = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom d'une variable glogale ou locale, ou le nom d'un registre de contrôle ;
  \item \plm=expression= est l'expression qui fournit la valeur.
\end{itemize}











\sectionLabel{Instructions d'incrémentation et de décrémentation}{instructionIncDec}
\index{Incrementation@Incrémentation!Instruction}
\index{Decrementation@Decrémentation!Instruction}

Les opérateurs postfixés \plm=++= et \plm=--= réalisent respectivement l'incrémentation et la décrémentation de la variable nommée dans l'instruction :
\begin{PLM}
variable ++
\end{PLM}

\plm=++= et \plm=--= engendrent une exception sur dépassement de capacité.

Les opérateurs \plm=&++= et \plm=&--= ignorent le dépassement de capacité.

Les instructions d'incrémentation et de décrémentation de variables entières sont détaillées à la \refSectionPage{incDecEntier}.






\sectionLabel {Opérateurs combinés avec une affectation}{operateursCombinesAffectation}
\index{\&=}
\index{\textbar=}
\index{\^{}=}

\plm!a &= b! est équivalent à \plm!a = a & b!.

\plm!a |= b! est équivalent à \plm!a = a | b!.

\plm!a ^= b! est équivalent à \plm!a = a ^ b!.

Les opérateurs infixes \plm!&=!, \plm!|=! et \plm!^=! sur les entiers sont décrits à la \refSectionPage{operateursCombinesAffectationEntier}.


\sectionLabel{Instruction \texttt{check}}{directiveCheck}\index{check@\plm=check=}

La directive \plm=check= apparaît dans une liste d'instructions et a la syntaxe suivante :
\begin{PLM}
check expression
\end{PLM}

L'\plm=expression= est une expression booléenne calculée statiquement.

Contrairement à l'instruction \plm=assert= (\refSectionPage{instructionAssert}) qui évalue l'expression booléenne à l'exécution, la directive \plm=check= est toujours évaluée à la compilation. Elle permet d'exprimer des assertions qui sont évaluées lors de la compilation.

Aucun code n'est engendré. La directive \plm=check= peut donc apparaître dans des listes d'instructions où les exceptions sont interdites.

Exemples :
\begin{PLM}
check true  // Ok
check false // Erreur, expression fausse
\end{PLM}



\sectionLabel{L'instruction \texttt{assert}}{instructionAssert}\index{assert@\plm=assert=}

L'instruction \plm=assert= a la syntaxe suivante :
\begin{PLM}
assert expression
\end{PLM}

L'\plm=expression= est une expression booléenne non calculable statiquement.

Si le programme est compilé avec les exceptions activées, alors le compilateur engendre le code de calcul de l'expression booléenne. Celle-ci sera calculée à l'exécution. Si le résultat est faux, une exception (dont le code est donné par le \refTableau{tableauCodeExceptions}) est levée.

Si le programme est compilé avec l'option \texttt{-{}-no-exception-generation}, alors aucun code n'est engendré.

Noter que \plm=expression= ne doit pas être calculable statiquement. Si elle est calculable statiquement, il faut utiliser la directive \plm=check=, \refSectionPage{directiveCheck}. Par exemple, le code suivant provoque une erreur de compilation :
\begin{PLM}
assert true // Erreur, l'expression est calculable statiquement
\end{PLM}



\section{L'instruction \texttt{panic}}\index{panic@\plm=panic=}

L'instruction \plm=panic= a la syntaxe suivante :
\begin{PLM}
panic expression
\end{PLM}

L'\plm=expression= est une expression entière, calculée statiquement. Son type est défini pour chaque cible (\refSectionPage{typeLiesException}) et peut être signé (les valeurs négatives sont alors acceptées) ou non signé.

Si le programme est compilé avec les exceptions activées, alors l'exécution de l'instruction \plm=panic= lève une exception dont le code est la valeur de l'\plm=expression=.

Si le programme est compilé avec l'option \texttt{-{}-no-exception-generation}, alors aucun code n'est engendré.




\sectionLabel{Instruction d'appel de procédure}{instructionAppelProc}

\colorbox{red}{À définir}


\section{Instruction \texttt{if}}
\index{if@\plm=if=}

L'instruction \plm=if= a une structure classique, où \plm=condition= est une expression booléenne :
\begin{PLM}
if condition then
  instructions_then
else
  instructions_else
end
\end{PLM}

Le compilateur vérifie que la \plm=condition= n'est pas une expression statique : une erreur de compilation est émise si elle l'est.

La branche \plm=else= est optionnelle :
\begin{PLM}
if condition then
  instructions_then
end
\end{PLM}


Une ou plusieurs branches \plm=elsif= peuvent être ajoutées, avec ou sans branche \plm=else= :
\begin{PLM}
if condition then
  instructions_then
elsif condition2 then
  instructions_elsif
elsif condition3 then
  instructions_elsif_3
else
  instructions_else
end
\end{PLM}

\subsectionLabel{Étiquettes}{etiquette-if}

Des \emph{étiquettes} peuvent être ajoutées pour augmenter la lisibilité :
\begin{PLM}
if@xyz condition then
  instructions_then
elsif@xyz condition2 then
  instructions_elsif
elsif@xyz condition3 then
  instructions_elsif_3
else@xyz
  instructions_else
end@xyz
\end{PLM}

Une étiquette est lexicalement un attribut, c'est-à-dire un nom préfixé par un \texttt{@}. Si une étiquette est apposée à un \plm!if!, alors les \plm!elsif!, \plm!else! et \plm!end! correspondants doivent être suivis par la même étiquette. De plus, une étiquette est unique dans une routine.


\section{Instruction \texttt{while}}
\index{if@\plm=while=}

L'instruction \plm=while= permet d'exprimer une répétition, où la \plm=condition= est testée avant l'exécution des instructions de la boucle :
\begin{PLM}
while condition do
  instructions_while
end
\end{PLM}

\plm=condition= est une expression booléenne, qui ne doit pas être statique : une erreur de compilation est émise si elle l'est.

Des \emph{étiquettes} peuvent être ajoutées pour augmenter la lisibilité :
\begin{PLM}
while@boucle condition do
  instructions_while
end@boucle
\end{PLM}

Une étiquette est lexicalement un attribut, c'est-à-dire un nom préfixé par un \texttt{@}. Si une étiquette est apposée à un \plm!while!, alors le \plm!end! correspondant doit être suivi par la même étiquette. De plus, une étiquette est unique dans une routine.

