%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Instructions}





\sectionLabel{Déclaration d'une variable locale}{declarationVariableLocale}\index{Variable!locale}

La déclaration d'une variable locale peut prendre plusieurs formes, suivant que la variable est initialisée ou non.

\subsection{Déclaration d'une variable locale initialisée}

\begin{PLM}
var nom $type = expression
\end{PLM}

Où :
\begin{itemize}
  \item \plm=nom= est le nom de la variable locale ;
  \item \plm=$type= est le nom du type de la variable globale ;
  \item \plm=expression= est l'expression qui fournit la valeur initiale de cette variable ; cette expression peut être statique ou non.
\end{itemize}

L'annotation de type peut être omise ; la variable a alors le type de l'expression qui l'initialise~:
\begin{PLM}
var nom = expression
\end{PLM}


\subsection{Déclaration d'une variable locale non initialisée}
\begin{PLM}
var nom $type
\end{PLM}
Où~:
\begin{itemize}
  \item \plm=nom= est le nom de la variable locale ;
  \item \plm=$type= est le nom du type de la variable globale.
\end{itemize}

Le compilateur garantit qu'aucune lecture n'est faite avant que la variable reçoive une valeur.










\sectionLabel{Déclaration d'une constante locale}{declarationConstanteLocale}\index{Constante!locale}

La déclaration d'une constante locale apparaît dans une liste d'instructions et sa syntaxe est la suivante~:

\begin{PLM}
let nom $type = expression
\end{PLM}

Où~:
\begin{itemize}
  \item \plm=nom= est le nom de la constante globale ;
  \item \plm=$type= est le nom du type de la constante globale ;
  \item \plm=expression= est l'expression qui fournit la valeur de cette constante ; cette expression est soit calculable statiquement, soit à l'exécution.
\end{itemize}

Il n'y a aucune restriction pour l'\plm=expression=~: elle peut nommer constantes locales et globales, variables locales et globales.






\section {Instruction d'affectation}

L'instruction d'affectation se présente sous plusieurs formes ; la plus simple est la suivante~:

\begin{PLM}
nom = expression
\end{PLM}

Où~:
\begin{itemize}
  \item \plm=nom= est le nom d'une variable globale, d'une variable locale, ou d'un registre de contrôle ;
  \item \plm=expression= est l'expression qui fournit la valeur.
\end{itemize}

On peut aussi accéder à une propriété d'une variable instance de structure~:
\begin{PLM}
nom.propriété = expression
\end{PLM}

Ainsi qu'à un élément de tableau~:
\begin{PLM}
nom [expression_indice] = expression
\end{PLM}

Ou encore toute combinaison de propriétés et d'éléments de tableau.



%\sectionLabel{Instructions d'incrémentation et de décrémentation}{instructionIncDec}
%\index{Incrementation@Incrémentation!Instruction}
%\index{Decrementation@Decrémentation!Instruction}
%
%Les opérateurs postfixés \plm=++= et \plm=--= réalisent respectivement l'incrémentation et la décrémentation de la variable nommée dans l'instruction :
%\begin{PLM}
%variable ++
%\end{PLM}
%
%\plm=++= et \plm=--= déclenchent la panique sur dépassement de capacité.
%
%Les opérateurs \plm=++%= et \plm=--%= ignorent le dépassement de capacité.
%
%Les instructions d'incrémentation et de décrémentation de variables entières sont détaillées à la \refSectionPage{incDecEntier}.
%





\sectionLabel {Opérateurs combinés avec l'affectation}{operateursCombinesAffectation}
\index{\&=!Entier}
\index{\textbar=!Entier}
\index{\^{}=!Entier}

Le \refTableau{tableauOperateursCombinesAffectation} liste les opérateurs combinés avec une affectation.
\begin{table}[ht]
\centering
\begin{tabular}{rcl}
  \textbf{Opérateur combiné} & \textbf{Écriture équivalente} & \textbf{Lien}\\
  \plm!a &= b! & \plm!a = a & b! & \refSectionPage{operateursCombinesAffectationEntier}\\
  \plm!a |= b! & \plm!a = a | b! & \refSectionPage{operateursCombinesAffectationEntier}\\
  \plm!a ^= b! & \plm!a = a ^ b! & \refSectionPage{operateursCombinesAffectationEntier}\\
  \plm!a += b! & \plm!a = a + b! \\
  \plm!a +%= b! & \plm!a = a +% b! \\
  \plm!a -= b! & \plm!a = a - b! \\
  \plm!a -%= b! & \plm!a = a -% b! \\
  \plm!a *= b! & \plm!a = a * b! \\
  \plm!a *%= b! & \plm!a = a *% b! \\
  \plm-a /= b- & \plm-a = a / b- \\
  \plm-a !/= b- & \plm-a = a !/ b- \\
  \plm-a %= b- & \plm-a = a % b- \\
  \plm-a !%= b- & \plm-a = a !% b- \\
  \plm-a <<= b- & \plm-a = a << b- \\
  \plm-a >>= b- & \plm-a = a >> b- \\
\end{tabular}
\caption{Opérateurs combinés avec l'affectation}
\labelTableau{tableauOperateursCombinesAffectation}
\end{table}


\sectionLabel{Instruction \texttt{check}}{directiveCheck}\index{check@\plm=check=}

La directive \plm=check= apparaît dans une liste d'instructions et a la syntaxe suivante :
\begin{PLM}
check expression
\end{PLM}

L'\plm=expression= est une expression booléenne calculée statiquement.

Contrairement à l'instruction \plm=assert= (\refSectionPage{instructionAssert}) qui évalue l'expression booléenne à l'exécution, la directive \plm=check= est toujours évaluée à la compilation. Elle permet d'exprimer des assertions qui sont évaluées lors de la compilation.

Aucun code n'est engendré. La directive \plm=check= peut donc apparaître dans des listes d'instructions où la panique est interdite.

Exemples :
\begin{PLM}
check yes  // Ok
check no // Erreur, expression fausse
\end{PLM}



\sectionLabel{L'instruction \texttt{assert}}{instructionAssert}\index{assert@\plm=assert=}

L'instruction \plm=assert= a la syntaxe suivante :
\begin{PLM}
assert expression
\end{PLM}

L'\plm=expression= est une expression booléenne non calculable statiquement.

Si le programme est compilé avec la panique activée, alors le compilateur engendre le code de calcul de l'expression booléenne. Celle-ci sera calculée à l'exécution. Si le résultat est faux, une panique (dont le code est donné par le \refTableau{tableauCodePanique}) est déclenchée.

Si le programme est compilé avec l'option \texttt{-{}-no-panic-generation}, alors aucun code n'est engendré.

Noter que \plm=expression= ne doit pas être calculable statiquement. Si elle est calculable statiquement, il faut utiliser la directive \plm=check=, \refSectionPage{directiveCheck}. Par exemple, le code suivant provoque une erreur de compilation :
\begin{PLM}
assert yes // Erreur de compilation, l'expression est calculable statiquement
\end{PLM}







\section{L'instruction \texttt{panic}}\index{panic@\plm=panic=}

L'instruction \plm=panic= a la syntaxe suivante :
\begin{PLM}
panic expression
\end{PLM}

L'\plm=expression= est une expression entière, calculée statiquement. Son type est défini pour chaque cible (\refSubsectionPage{configurationPanic}), c'est un type entier non signé.

Si le programme est compilé avec la panique activée, alors l'exécution de l'instruction \plm=panic= déclenche la panique avec le code est la valeur de l'\plm=expression=. Pour éviter un conflit de code avec les codes prédéfinis dans PLM, consulter le \refTableauPage{tableauCodePanique}.

Si le programme est compilé avec l'option \texttt{-{}-no-panic-generation}, alors aucun code n'est engendré, l'instruction est ignorée.




\sectionLabel{Instruction d'appel de procédure}{instructionAppelProc}

\colorbox{red}{À définir}


\sectionLabel{Instruction \texttt{if}}{instructionIF}
\index{if@\plm=if=}

L'instruction \plm=if= a une structure classique, où \plm=condition= est une expression booléenne :
\begin{PLM}
if condition {
  instructions_then
}else{
  instructions_else
}
\end{PLM}

Le compilateur vérifie que la \plm=condition= n'est pas une expression statique : une erreur de compilation est émise si elle l'est.

La branche \plm=else= est optionnelle :
\begin{PLM}
if condition {
  instructions_then
}
\end{PLM}


Une ou plusieurs branches \plm=else if= peuvent être ajoutées, avec ou sans branche \plm=else= :
\begin{PLM}
if condition {
  instructions_then
}else if condition2 {
  instructions_elsif
}else if condition3 {
  instructions_elsif_3
}else{
  instructions_else
}
\end{PLM}


\section{Instruction \texttt{while}}
\index{if@\plm=while=}

L'instruction \plm=while= permet d'exprimer une répétition, où la \plm=condition= est testée avant l'exécution des instructions de la boucle :
\begin{PLM}
while condition {
  instructions_while
}
\end{PLM}

\plm=condition= est une expression booléenne, qui ne doit pas être statique : une erreur de compilation est émise si elle l'est.












\sectionLabel{Instruction \texttt{for}}{instructionFor}


\subsection{Énumération entière}
\begin{PLM}
for nom $type in lower_bound ..< upper_bound {
  instructions_for
}
\end{PLM}

Si il n'est pas lu par les \plm=instructions_for=, \plm=nom= peut être remplacé par le joker « \plm=_= ».




\subsection{Énumération d'un tableau ou d'une chaîne de caractères}

\begin{PLM}
for nom in objet while expression {
  instructions_for
}
\end{PLM}













\sectionLabel{Instruction d'appel de routine}{instructionAppelRoutine}













\sectionLabel{Instruction \texttt{switch}}{instructionSwitch}













\section{Instruction \texttt{sync}}

L'instruction \plm=sync= est décrite à la \refSectionPage{instructionSync}.





\sectionLabel{Instruction \texttt{nop}}{instructionNop}

\begin{PLM}
nop
\end{PLM}

Le mot réservé \plm=nop= engendre une instruction assembleur \emph{nop}, telle que défini par le paramètre \texttt{NOP} dans la définition de la cible (\refSubsectionPage{configurationNop}).

