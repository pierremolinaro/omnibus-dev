%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Routines}

Le langage définit plusieurs natures de sous-programmes :
\begin{itemize}
  \item les \emph{procédures}, dont l'appel est une instruction (\refSectionPage{defProcedure}) ;
  \item les \emph{fonctions}, dont l'appel apparaît dans une expression (\refSectionPage{defFonction}) ;
  \item les \emph{boot routines}, exécutées une fois avant l'initialisation des variables globales (\refSectionPage{bootRoutine}) ;
  \item les \emph{init routines}, exécutées une fois après l'initialisation des variables globales (\refSectionPage{initRoutine}) ;
  \item les \emph{routines de panique}, exécutées lors d'une panique (\refSectionPage{routinePanique}) ;
  \item les \emph{sections}, qui sont des procédures exécutées en mode privilégié (\refSectionPage{declarationSection}).
\end{itemize}

Les \emph{routines}\index{Routine} se distinguent des \emph{procédures} et des \emph{fonctions} par le fait qu'elles n'ont pas d'arguments formels explicites, et qu'elles ne peuvent pas être appelées explicitement.









\sectionLabel{\texttt{boot} routines}{bootRoutine}
\index{boot@\plm=boot=!Routine}
\index{Routine!boot@\plm=boot=}

Une routine \plm=boot= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, avant que les variables globales ne soient initialisées. Elle a la syntaxe suivante :
\begin{PLM}
boot priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière statique. Les routines \plm=boot= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=boot= n'ont pas la même priorité.

Les routines \plm=boot= s'exécutent dans le mode \plm=`boot=.\index{\`boot}

Comme les routines \plm=boot= s'exécutent avant que les variables globales soient initialisées, l'accès aux variables globales y est interdit. L'interdiction est mise en place de la façon suivante : il n'est pas possible d'associer une routine \plm=`boot= à une variable globale lors de sa déclaration (\refSectionPage{declarationVariableGlobale}).

Par contre, l'accès aux registres de contrôle est autorisé dans une routine \plm=boot= (d'ailleurs, elle sert à cela : configurer le micro-contrôleur au démarrage).







\sectionLabel{\texttt{init} routines}{initRoutine}
\index{init@\plm=init=!Routine}
\index{Routine!init@\plm=init=}

Une routine \plm=init= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, après l'initialisation des variables globales. Elle a la syntaxe suivante :
\begin{PLM}
init priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière statique. Les routines \plm=init= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=init= n'ont pas la même priorité.

Les routines \plm=init= s'exécutent dans le mode \plm=`init=.\index{\`init}

Comme les routines \plm=init= s'exécutent après l'initialisation des variables globales, l'accès aux variables globales y est autorisé, du moment que la variable globale cite le mode \plm=`init= dans sa déclaration (\refSectionPage{declarationVariableGlobale}).






\sectionLabel{Arguments formels, paramètres effectifs, sélecteurs}{argumentFormel}
\index{Argument formel}
\index{Parametre effectif@Paramètre effectif}
\index{Selecteur@Sélecteur}

Il existe trois natures d'arguments formels : \emph{entrée}, \emph{sortie} et \emph{entrée / sortie}, décrits dans le \refTableau{argumentsFormels}. Un sélecteur peut être \emph{anonyme} (par exemple \plm+?+ pour un paramètre formel en entrée), ou comporter un nom (le nom « \texttt{nom} » pour \plm+?nom:+).

Une procédure déclare zéro, un ou plusieurs arguments formels qui peuvent être en \emph{entrée}, en \emph{sortie} ou en \emph{entrée/sortie}. Une fonction déclare zéro, un ou plusieurs arguments formels en \emph{entrée}.

La syntaxe des différents arguments formels et de leur paramètre effectif est résumée dans le \refTableau{argumentsFormelsParametresEffectifs}. 

\begin{table}[t]
  \centering
  \begin{tabular}{lp{6.5cm}l}
    \textbf{Argument formel} & \textbf{Transfert d'information} & \textbf{Sélecteur} \\
    Entrée & Lors de l'appel, de l'appelant vers l'appelé & \plm+?+ ou \plm+?selecteur:+\\
    Sortie & Lors du retour, de l'appelé vers l'appelant & \plm+!+ ou \plm+!selecteur:+\\
    Entrée / sortie & Lors de l'appel, de l'appelant vers l'appelé, et lors du retour, de l'appelé vers l'appelant & \plm+?!+ ou \plm+?!selecteur:+\\
  \end{tabular}
  \caption{Arguments formels}
  \labelTableau{argumentsFormels}
  \ligne
\end{table}



\begin{table}[t]
  \centering
  \begin{tabular}{llll}
    \textbf{Argument formel} & \textbf{Sélecteur} & \textbf{Paramètre effectif} & \textbf{Sélecteur} \\
    Entrée & \plm+?+         & Sortie & \plm+!expression+ \\
           & \plm+?selecteur:+ & & \plm+!selecteur:expression+ \\
    Sortie & \plm+!+         & Entrée & \plm+?variable+ \\
           & \plm+!selecteur:+ & & \plm+?selecteur:variable+ \\
    Entrée/sortie & \plm+?!+         & Sortie/entrée & \plm+!?variable+ \\
           & \plm+?!selecteur:+ & & \plm+!?selecteur:variable+ \\
  \end{tabular}
  \caption{Argument formel et paramètre effectif}
  \labelTableau{argumentsFormelsParametresEffectifs}
  \ligne
\end{table}







\sectionLabel{Procédures}{defProcedure}


\subsectionLabel{Déclaration d'une procédure}{declarationProcedure}\index{Procedure@Procédure}

La déclaration d'une procédure est la suivante :
\begin{PLM}
proc nom `mode1 `mode2 @attribut1 @attribut2 (arguments_formels) {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la procédure ;
  \item \plm=`mode1= \plm=`mode2= est la liste non vide de l'ensemble des modes associés à la procédure ;
  \item \plm=@attribut1= \plm=@attribut2= est une liste éventuellement vide d'attributs associés à la procédure.
\end{itemize}

Par exemple :

\begin{PLM}
proc setup `user () {
}
\end{PLM}

Ceci définit la procédure \plm=setup=, sans argument, sans attribut, appelable uniquement en mode \plm=`user=.

\begin{PLM}
proc goto `user @noWarningIfUnused (
  ?line:inLine $uint32
  ?column:inColumn $uint8) {
}
\end{PLM}

Ceci définit la procédure \plm=goto=, appelable uniquement en mode \plm=`user=, avec deux arguments formels en entrée. L'attribut \plm+@noWarningIfUnused+ signifie qu'aucune alerte n'est émise si la procédure n'est pas utilisée.




\subsectionLabel{Procédures et registres de contrôle}{procEtRegistresContrôles}

Si la procédure est déclarée avec le mode \plm!`user!, seuls les registres de contrôle déclarés \plm!@user! sont accessibles. Sinon, tous les registres de contrôle sont accessibles.







\subsectionLabel{Attribut \texttt{@noWarningIfUnused}}{attributNoWarningIfUnused}\index{"@noWarningIfUnused}

L'attribut \plm+@noWarningIfUnused+ signifie qu'aucune alerte n'est émise si la procédure n'est pas utilisée.



\subsectionLabel{Attribut \texttt{@weak}}{attributWeak}\index{"@weak}

L'attribut \plm+@weak+ signifie que la routine peut être redéfinie par une routine de même nom, avec les mêmes arguments formels, les mêmes modes. Les fichiers de définition de cible utilisent cette possibilité pour définir des routines par défaut.

Par exemple, la cible \texttt{teensy-3-1-it} définit cette routine d'interruption (voir le deuxième exemple du tutorial, \refSectionPage{deuxiemeExemple}) :

\begin{PLM}
proc systickHandler `isr @weak () {
}
\end{PLM}

Par défaut, la routine d'interruption \plm+systickHandler+ est donc définie, vide. Le programme d'exemple définit cette routine :

\begin{PLM}
proc systickHandler `isr () {
  gUpTimeMS += 1
}
\end{PLM}

Comme cette nouvelle routine a le même nom, les mêmes arguments formels et le même mode que la routine marquée \plm+@weak+, elle est utilisée à la place de celle-ci.






\subsectionLabel{Attribut \texttt{@nullWhenPanicDisabled}}{nullWhenPanicDisabled}\index{"@nullWhenPanicDisabled}

L'attribut \plm+@nullWhenPanicDisabled+ signifie que la procédure est éliminée si le projet est compilé avec la panique désactivée (option \OPTION{-{}-no-panic-generation}, \refSectionPage{optionCodeEngendre}). Les références à cette routine sont alors remplacées par la valeur zéro.

Cette option est à utiliser en toute connaissance de cause. Elle sert à éliminer les routines d'interruption qui ne sont pas utilisées dans un projet.

Par exemple, une routine d'interruption par défaut est déclarée par la cible :

\begin{PLM}
proc svcHandler `isr @nullWhenPanicDisabled @weak () {
  panic 11
}
\end{PLM}

Si cette routine n'est pas redéfinie par une routine de même nom, et que le programme est compilé avec la panique activée, alors l'occurrence de l'interruption déclenchera l'exception n°11.

Si cette routine n'est pas redéfinie par une routine de même nom, et que le programme est compilé avec la panique désactivée, alors l'attribut \plm+@nullWhenPanicDisabled+ fera que la routine sera éliminée de la génération de code, et l'entrée correspondante de la table des interruptions sera mise à zéro. Cela permet de ne pas engendrer de code inutile dans cette situation.

 





\subsectionLabel{Procédures requises}{procedureRequise}

La déclaration \plm+required proc+ permet de signifier au compilateur qu'une procédure doit être définie, soit par la cible, soit par le programme utilisateur.

Cette déclaration est la suivante :
\begin{PLM}
required proc nom `mode @attribut (arguments_formels)
\end{PLM}

Elle consiste à la déclaration de l'en-tête d'une procédure (voir \refSubsectionPage{declarationProcedure}), précédée par le mot réservée \plm+required+.

Par exemple, la cible \texttt{teensy-3-1-it} comporte ces deux déclarations :

\begin{PLM}
required proc setup `user ()
required proc loop `user ()
\end{PLM}

Ceci impose au programme utilisateur de définir ces deux procédures.









\sectionLabel{Fonctions}{defFonction}

\subsectionLabel{Déclaration d'une fonction}{declarationFonction}\index{Fonction}

La déclaration d'une fonction est la suivante :
\begin{PLM}
func nom `mode @attribut (arguments_formels) -> $type {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la fonction ;
  \item \plm=`mode= est la liste non vide de l'ensemble des modes associés à la procédure ;
  \item \plm=@attribut= est une liste éventuellement vide d'attributs associés à la procédure ;
  \item \plm=arguments_formels= est la liste (éventuellement vide) des paramètres formels (uniquement en entrée) ;
  \item \plm=@type= est le type de la valeur renvoyée.
\end{itemize}

Contrairement à beaucoup de langages, PLM n'a pas d'instruction \texttt{return}, qui permettrait de nommer la valeur de retour. En PLM, une variable nommée \plm=result= est implicitement déclarée du type \plm=@type=, et est non valuée initialement. La liste d'instructions de la fonction {\bf doit} valuer cette variable. Sa valeur à l'issue de l'exécution de la liste d'instructions est la valeur renvoyée par la fonction. 
Par exemple :

\begin{PLM}
func maFonction `user @noWarningIfUnused () -> $uint32 {
  result = 6
}
\end{PLM}

Ceci définit la fonction \plm=maFonction=, sans argument, appelable uniquement en mode \plm=`user= ; l'attribut \plm=@noWarningIfUnused= signifie qu'aucune alerte n'est émise si la fonction n'est pas utilisée.

\begin{PLM}
func autreFonction `user (?arg:a $uint27 ?b $uint27) -> $uint27 {
  result = a +% b
}
\end{PLM}

Ceci définit la fonction \plm=autreFonction=, avec deux arguments, sans attribut, appelable uniquement en mode \plm=`user=.


\subsectionLabel{Attribut \texttt{@noWarningIfUnused}}{attributFonctionNoWarningIfUnused}\index{"@noWarningIfUnused}

L'attribut \plm+@noWarningIfUnused+ signifie qu'aucune alerte n'est émise si la fonction n'est pas utilisée.



\subsectionLabel{Fonctions et variables globales}{fonctionEtVariableGlobale}

Les fonctions peuvent accéder aux variables globales en lecture, mais ne peuvent pas les modifier.

L'accès en lecture à une variable globale est autorisé par la variable qui nomme la fonction parmi les routines autorisées :

\begin{PLM}
var gGlobalVar $uint56 {
  ...
  func getGlobalVar
}

func getGlobalVar `user () -> $uint56 {
  result = getGlobalVar
}
\end{PLM}




\subsectionLabel{Fonctions et registres de contrôle}{fonctionEtRegistresContrôles}

Dans tous les cas, seul l'accès en lecture à un registre de contrôle peut être autorisé.


Si la fonction est déclarée avec le mode \plm!`user!, seuls les registres de contrôle déclarés \plm!@user! sont accessibles en lecture. Sinon, tous les registres de contrôle sont accessibles en lecture.


\sectionLabel{Section}{declarationSection}\index{section}

Une \emph{section} est une procédure qui est exécutée par le processeur en mode privilégié. Une section peut ainsi accéder à des registres de contrôles inaccessibles en mode \plm!`user!.

Une section est appelable :
\begin{itemize}
  \item en mode \plm!`user! : l'appel s'effectue à travers une instruction qui provoque un appel système et donc permet l'exécution avec le processeur en mode privilégié ; le mode PLM qui correspond est \plm!`section! ;
  \item en mode \plm!`section! : l'appel est un simple appel de routine.
\end{itemize}




















\subsection{Déclaration d'une section}


La déclaration d'une section est la suivante :
\begin{PLM}
section nom @attribut1 @attribut2 (arguments_formels) {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la section ;
  \item \plm=@attribut1= \plm=@attribut2= est une liste éventuellement vide d'attributs associés à la section ; actuellement, seul l'attribut \plm!@noWarningIfUnused! est défini (\refSubsectionPage{attributNoWarningIfUnusedSection}).
\end{itemize}



\subsectionLabel{Sections et registres de contrôle}{sectionEtRegistresContrôles}

Tous les registres de contrôle sont accessibles dans une section.







\subsectionLabel{Attribut \texttt{@noWarningIfUnused}}{attributNoWarningIfUnusedSection}\index{"@noWarningIfUnused}

L'attribut \plm+@noWarningIfUnused+ signifie qu'aucune alerte n'est émise si la section n'est pas utilisée.









\section{Routines utiles}

Le compilateur élimine les routines qui ne sont jamais appelées, en calculant le graphe des appels. Les racines de ce graphe sont les procédures requises (\refSubsectionPage{procedureRequise}), les routines \plm=boot=, \plm=init= et \plm=panic=. Les procédures et fonctions inatteignables sont éliminées, sans message d'alerte pour les routines déclarées avec l'attribut \plm!@noWarningIfUnused!.











\sectionLabel{Récursivité}{routinesRecursives}\index{Routines!recursives@récursives}

Par défaut, le compilateur émet un message d'erreur si une ou plusieurs routines récursives sont détectées. L'option \OPTION{-{}-do-not-detect-recursive-calls} (\refSectionPage{optionCodeEngendre}) permet d'inhiber cette recherche.

L'option \OPTION{-{}-routine-invocation-graph} permet d'obtenir un fichier contenant le graphe d'invocation, qui peut être affiché par le logiciel \texttt{graphviz}\index{graphviz}. Si le fichier source est \texttt{source.plm}, le fichier engendré s'appelle \texttt{source.subprogramInvocation.dot}.

