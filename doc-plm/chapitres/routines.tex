%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Routines}

Le langage définit plusieurs natures de sous-programmes :
\begin{itemize}
  \item les \emph{procédures}, dont l'appel est une instruction ;
  \item les \emph{fonctions}, dont l'appel apparaît dans une expression ;
  \item les \emph{boot routines}, exécutées une fois avant l'initialisation des variables globales ;
  \item les \emph{init routines}, exécutées une fois après l'initialisation des variables globales ;
  \item les \emph{routines d'exception}, exécutées lors d'une exception (\refSectionPage{routineException}).
\end{itemize}

Les \emph{routines}\index{Routine} se distinguent des \emph{procédures} et des \emph{fonctions} par le fait qu'elles n'ont pas d'arguments formels explicites, et qu'elles ne peuvent pas être appelées explicitement.









\sectionLabel{\texttt{boot} routines}{bootRoutine}
\index{boot@\plm=boot=!Routine}
\index{Routine!boot@\plm=boot=}

Une routine \plm=boot= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, avant que les variables globales ne soient initialisées. Elle a la syntaxe suivante :
\begin{PLM}
boot priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=boot= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=boot= n'ont pas la même priorité.

Les routines \plm=boot= s'exécutent dans le mode \plm=`boot=.\index{\`boot}

Comme les routines \plm=boot= s'exécutent avant que les variables globales soient initialisées, l'accès aux variables globales y est interdit. L'interdiction est mise en place de la façon suivante : il n'est pas possible d'associer une routine \plm=`boot= à une variable globale lors de sa déclaration (\refSectionPage{declarationVariableGlobale}).

Par contre, l'accès aux registres de contrôle est autorisé dans une routine \plm=boot= (d'ailleurs, elle sert à cela : configurer le micro-contrôleur au démarrage).







\sectionLabel{\texttt{init} routines}{initRoutine}
\index{init@\plm=init=!Routine}
\index{Routine!init@\plm=init=}

Une routine \plm=init= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, après l'initialisation des variables globales. Elle a la syntaxe suivante :
\begin{PLM}
init priorite {
  liste_instructions
}
\end{PLM}
Où \plm=priorite= est la priorité de la routine. C'est une constante entière entre $0$ et $2^{64}-1$. Les routines \plm=init= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=init= n'ont pas la même priorité.

Les routines \plm=init= s'exécutent dans le mode \plm=`init=.\index{\`init}

Comme les routines \plm=init= s'exécutent après l'initialisation des variables globales, l'accès aux variables globales y est autorisé, du moment que la variable globale cite le mode \plm=`init= dans sa déclaration (\refSectionPage{declarationVariableGlobale}).






\sectionLabel{Arguments formels, paramètres effectifs, sélecteurs}{argumentFormel}
\index{Argument formel}
\index{Parametre effectif@Paramètre effectif}
\index{Selecteur@Sélecteur}

Il existe trois natures d'arguments formels : \emph{entrée}, \emph{sortie} et \emph{entrée / sortie}, décrits dans le \refTableau{argumentsFormels}. Un sélecteur peut être \emph{anonyme} (par exemple \plm+?+ pour un paramètre formel en entrée), ou comporter un nom (le nom « \texttt{nom} » pour \plm+?nom:+).

Une procédure déclare zéro, un ou plusieurs arguments formels qui peuvent être en \emph{entrée}, en \emph{sortie} ou en \emph{entrée/sortie}. Une fonction déclare zéro, un ou plusieurs arguments formels en \emph{entrée}.

La syntaxe des différents arguments formels et de leur paramètre effectif est résumée dans le \refTableau{argumentsFormelsParametresEffectifs}. 

\begin{table}[t]
  \centering
  \begin{tabular}{lp{6.5cm}l}
    \textbf{Argument formel} & \textbf{Transfert d'information} & \textbf{Sélecteur} \\
    Entrée & Lors de l'appel, de l'appelant vers l'appelé & \plm+?+ ou \plm+?selecteur:+\\
    Sortie & Lors du retour, de l'appelé vers l'appelant & \plm+!+ ou \plm+!selecteur:+\\
    Entrée / sortie & Lors de l'appel, de l'appelant vers l'appelé, et lors du retour, de l'appelé vers l'appelant & \plm+?!+ ou \plm+?!selecteur:+\\
  \end{tabular}
  \caption{Arguments formels}
  \labelTableau{argumentsFormels}
  \ligne
\end{table}



\begin{table}[t]
  \centering
  \begin{tabular}{llll}
    \textbf{Argument formel} & \textbf{Sélecteur} & \textbf{Paramètre effectif} & \textbf{Sélecteur} \\
    Entrée & \plm+?+         & Sortie & \plm+!expression+ \\
           & \plm+?selecteur:+ & & \plm+!selecteur:expression+ \\
    Sortie & \plm+!+         & Entrée & \plm+?variable+ \\
           & \plm+!selecteur:+ & & \plm+?selecteur:variable+ \\
    Entrée/sortie & \plm+?!+         & Sortie/entrée & \plm+!?variable+ \\
           & \plm+?!selecteur:+ & & \plm+!?selecteur:variable+ \\
  \end{tabular}
  \caption{Argument formel et paramètre effectif}
  \labelTableau{argumentsFormelsParametresEffectifs}
  \ligne
\end{table}







\section{Procédure}


\subsectionLabel{Déclaration d'une procédure}{declarationProcedure}\index{Procedure@Procédure}

La déclaration d'une procédure est la suivante :
\begin{PLM}
proc nom `mode1 `mode2 @attribut1 @attribut2 (arguments_formels) {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la procédure ;
  \item \plm=`mode1= \plm=`mode2= est la liste non vide de l'ensemble des modes associés à la procédure ;
  \item \plm=@attribut1= \plm=@attribut2= est une liste éventuellement vide d'attributs associés à la procédure.
\end{itemize}

Par exemple :

\begin{PLM}
proc setup `user () {
}
\end{PLM}

Ceci définit la procédure \plm=setup=, sans argument, sans attribut, appelable uniquement en mode \plm=`user=.

\begin{PLM}
proc goto `user @noWarningIfUnused (
  ?line:inLine $uint32
  ?column:inColumn $uint8) {
}
\end{PLM}

Ceci définit la procédure \plm=goto=, appelable uniquement en mode \plm=`user=, avec deux arguments formels en entrée. L'attribut \plm+@noWarningIfUnused+ signifie qu'aucune alerte n'est émise si la procédure n'est pas utilisée.







\subsectionLabel{Attribut \texttt{@noWarningIfUnused}}{attributNoWarningIfUnused}\index{"@noWarningIfUnused}

L'attribut \plm+@noWarningIfUnused+ signifie qu'aucune alerte n'est émise si la procédure n'est pas utilisée.



\subsectionLabel{Attribut \texttt{@weak}}{attributWeak}\index{"@weak}

L'attribut \plm+@weak+ signifie que la routine peut être redéfinie par une routine de même nom, avec les mêmes arguments formels, les mêmes modes. Les fichiers de définition de cible utilisent cette possibilité pour définir des routines par défaut.

Par exemple, la cible \texttt{teensy-3-1-it} définit cette routine d'interruption (voir le deuxième exemple du tutorial, \refSectionPage{deuxiemeExemple}) :

\begin{PLM}
proc systickHandler `isr @weak () {
}
\end{PLM}

Par défaut, la routine d'interruption \plm+systickHandler+ est donc définie, vide. Le programme d'exemple définit cette routine :

\begin{PLM}
proc systickHandler `isr () {
  gUpTimeMS ++
}
\end{PLM}

Comme cette nouvelle routine a le même nom, les mêmes arguments formels et le même mode que la routine marquée \plm+@weak+, elle est utilisée à la place de celle-ci.






\subsectionLabel{Attribut \texttt{@nullWhenPanicDisabled}}{attributNullOnNoException}\index{"@nullWhenPanicDisabled}

L'attribut \plm+@nullWhenPanicDisabled+ signifie que la procédure est éliminée si le projet est compilé avec les exceptions désactivées (option \OPTION{-{}-no-exception-generation}, \refSectionPage{optionCodeEngendre}). Les références à cette routine sont alors remplacées par la valeur zéro.

Cette option est à utiliser en toute connaissance de cause. Elle sert à éliminer les routines d'interruption qui ne sont pas utilisées dans un projet.

Par exemple, une routine d'interruption par défaut est déclarée par la cible :

\begin{PLM}
proc svcHandler `isr @nullWhenPanicDisabled @weak () {
  panic 11
}
\end{PLM}

Si cette routine n'est pas redéfinie par une routine de même nom, et que le programme est compilé avec les exception activées, alors l'occurrence de l'interruption déclenchera l'exception n°11.

Si cette routine n'est pas redéfinie par une routine de même nom, et que le programme est compilé avec les exception désactivées, alors l'attribut \plm+@nullWhenPanicDisabled+ fera que la routine sera éliminée de la génération de code, et l'entrée correspondante de la table des interruptions sera mise à zéro. Cela permet de ne pas engendrer de code inutile dans cette situation.

 





\subsectionLabel{Procédures requises}{procedureRequise}

La déclaration \plm+required proc+ permet de signifier au compilateur qu'une procédure doit être définie, soit par la cible, soit par le programme utilisateur.

Cette déclaration est la suivante :
\begin{PLM}
required proc nom `mode1 `mode2 @attribut1 @attribut2 (arguments_formels)
\end{PLM}

Elle consiste à la déclaration de l'en-tête d'une procédure (voir \refSubsectionPage{declarationProcedure}), précédée par le mot réservée \plm+required+.

Par exemple, la cible \texttt{teensy-3-1-it} comporte ces deux déclarations :

\begin{PLM}
required proc setup `user ()
required proc loop `user ()
\end{PLM}

Ceci impose au programme utilisateur de définir ces deux procédures.









\section{Fonctions}

\colorbox{red}{À définir}







\section{Routines utiles}

Le compilateur élimine les procédures qui ne sont jamais appelées, en calculant le graphe des appels. Les racines de ce graphe sont les procédures requises (\refSubsectionPage{procedureRequise}), les routines \plm=boot=, \plm=init= et \plm=exception=. Les procédures et fonctions inatteignables sont éliminées, avec ou sans message d'alerte (\refSubsectionPage{attributNoWarningIfUnused}).











\sectionLabel{Récursivité}{routinesRecursives}\index{Routines!recursives@récursives}

Par défaut, le compilateur émet un message d'erreur si une ou plusieurs routines récursives sont détectées. L'option \OPTION{-{}-do-not-detect-recursive-calls} (\refSectionPage{optionCodeEngendre}) permet d'inhiber cette recherche.

L'option \OPTION{-{}-routine-invocation-graph} permet d'obtenir un fichier contenant le graphe d'invocation, qui peut être affiché par le logiciel \texttt{graphviz}\index{graphviz}. Si le fichier source est \texttt{source.plm}, le fichier engendré s'appelle \texttt{source.subprogramInvocation.dot}.

