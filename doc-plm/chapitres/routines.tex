%!TEX encoding = UTF-8 Unicode
%!TEX root = ../doc-plm.tex





\chapter{Routines}

Le langage définit plusieurs natures de routines :
\begin{itemize}
  \item les \emph{procédures}, dont l'appel est une instruction (\refSubsectionPage{declarationProcedure}) ;
  \item les \emph{fonctions}, dont l'appel est une instruction ou apparaît dans une expression (\refSectionPage{defFonction}) ;
  \item les \emph{boot routines}, exécutées une fois avant l'initialisation des variables globales (\refSectionPage{bootRoutine}) ;
  \item les \emph{init routines}, exécutées une fois après l'initialisation des variables globales (\refSectionPage{initRoutine}) ;
  \item les \emph{routines de panique}, exécutées lors d'une panique (\refSectionPage{routinePanique}) ;
  \item les \emph{sections}, qui sont des procédures exécutées en mode privilégié (\refSectionPage{declarationSection}) ;
  \item les \emph{services}, qui sont des primitives non bloquantes de l'exécutif (\refSectionPage{declarationService}).
  \item les \emph{primitives}, qui sont des primitives de l'exécutif (\refSectionPage{declarationPrimitive}).
  \item les \emph{routines d'interruption}, qui sont des primitives de l'exécutif (\refSectionPage{declarationRoutineInterruption}).
\end{itemize}

%Les \emph{routines}\index{Routine} se distinguent des \emph{procédures} et des \emph{fonctions} par le fait qu'elles n'ont pas d'paramètres formels explicites, et qu'elles ne peuvent pas être appelées explicitement.

Les \emph{sections}, \emph{services}, \emph{primitives} et  \emph{routines d'interruption} sont exécutées en mode privilégié. Elles se distinguent par leur accès aux primitives de l'exécutif :
\begin{itemize}
  \item une \emph{section} ne peut accéder à aucune primitive de l'exécutif ;
  \item un \emph{service} ne peut accéder qu'aux primitives non bloquantes de l'exécutif ;
  \item une \emph{primitive} peut accéder à toutes les primitives de l'exécutif ;
  \item une \emph{routines d'interruption} peut être, suivant sa déclaration, une \emph{section} ou un \emph{service}.
\end{itemize}








\sectionLabel{\texttt{boot} routines}{bootRoutine}
\index{boot@\plm=boot=!Routine}
\index{Routine!boot@\plm=boot=}

Une routine \plm=boot= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, avant que les variables globales ne soient initialisées. Elle a la syntaxe suivante :
\begin{PLM}
boot priorité {
  liste_instructions
}
\end{PLM}
Où \plm=priorité= est la priorité de la routine. C'est une constante entière statique. Les routines \plm=boot= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=boot= n'ont pas la même priorité.

Les routines \plm=boot= s'exécutent dans le mode \plm=`boot=.\index{`boot}

Comme les routines \plm=boot= s'exécutent avant que les variables globales soient initialisées, l'accès aux variables globales y est interdit. L'interdiction est mise en place de la façon suivante : il n'est pas possible d'associer une routine \plm=`boot= à une variable globale lors de sa déclaration (\refSectionPage{declarationVariableGlobale}).

Par contre, l'accès aux registres de contrôle est autorisé dans une routine \plm=boot= (d'ailleurs, elle sert à cela : configurer le micro-contrôleur au démarrage).







\sectionLabel{\texttt{init} routines}{initRoutine}
\index{init@\plm=init=!Routine}
\index{Routine!init@\plm=init=}

Une routine \plm=init= est exécutée une et une seule fois, lors du démarrage du micro-contrôleur, après l'initialisation des variables globales. Elle a la syntaxe suivante :
\begin{PLM}
init priorité {
  liste_instructions
}
\end{PLM}
Où \plm=priorité= est la priorité de la routine. C'est une constante entière statique. Les routines \plm=init= sont exécutées dans l'ordre des priorités croissantes. Le compilateur vérifie que deux routines \plm=init= n'ont pas la même priorité.

Les routines \plm=init= s'exécutent dans le mode \plm=`init=.\index{`init}

Comme les routines \plm=init= s'exécutent après l'initialisation des variables globales, l'accès aux variables globales y est autorisé, du moment que la variable globale cite le mode \plm=`init= dans sa déclaration (\refSectionPage{declarationVariableGlobale}).






\sectionLabel{Paramètres formels, arguments effectifs, sélecteurs}{argumentFormel}
\index{Parametre formel@Paramètre formel}
\index{Argument effectif}
\index{Selecteur@Sélecteur}

\subsection{Paramètres formels}

Il existe trois natures de paramètres formels : \emph{entrée}, \emph{sortie} et \emph{entrée / sortie}, décrits dans le \refTableau{argumentsFormels}. Un sélecteur peut être \emph{anonyme} (par exemple \plm+?+ pour un paramètre formel en entrée), ou comporter un nom (le nom « \texttt{nom} » pour \plm+?nom:+).

Une procédure déclare zéro, un ou plusieurs paramètres formels qui peuvent être en \emph{entrée}, en \emph{sortie} ou en \emph{entrée/sortie}. Une fonction déclare zéro, un ou plusieurs paramètres formels en \emph{entrée}.


\begin{table}[t]
  \centering
  \begin{tabular}{lp{6.5cm}l}
    \textbf{Paramètre formel} & \textbf{Transfert d'information} & \textbf{Sélecteur} \\
    Entrée & Lors de l'appel, de l'appelant vers l'appelé & \plm+?+ ou \plm+?selecteur:+\\
    Sortie & Lors du retour, de l'appelé vers l'appelant & \plm+!+ ou \plm+!selecteur:+\\
    Entrée / sortie & Lors de l'appel, de l'appelant vers l'appelé, et lors du retour, de l'appelé vers l'appelant & \plm+?!+ ou \plm+?!selecteur:+\\
  \end{tabular}
  \caption{Paramètres formels}
  \labelTableau{argumentsFormels}
  \ligne
\end{table}




\subsection{Arguments effectifs}

La syntaxe des différents paramètres formels et de leur argument effectif est résumée dans le \refTableau{argumentsFormelsParametresEffectifs}. 

\begin{table}[t]
  \centering
  \begin{tabular}{llll}
    \textbf{Paramètre formel} & \textbf{Sélecteur} & \textbf{Argument effectif} & \textbf{Sélecteur} \\
    Entrée & \plm+?+         & Sortie & \plm+!expression+ \\
           & \plm+?selecteur:+ & & \plm+!selecteur:expression+ \\
    Sortie & \plm+!+         & Entrée & \plm+?variable+ \\
           & \plm+!selecteur:+ & & \plm+?selecteur:variable+ \\
    Entrée/sortie & \plm+?!+         & Sortie/entrée & \plm+!?variable+ \\
           & \plm+?!selecteur:+ & & \plm+!?selecteur:variable+ \\
  \end{tabular}
  \caption{Paramètre formel et argument effectif}
  \labelTableau{argumentsFormelsParametresEffectifs}
  \ligne
\end{table}









\subsection{Signature d'une routine}

En PLM, une routine est identifiée par son nom et la liste de ses sélecteurs. Il est donc possible de déclarer des routine de mêmes noms, du moment qu'elles se distinguent par le nombre, la nature et le nom des sélecteurs.

[DES EXEMPLES POUR COMPLÉTER] 














 


















\sectionLabel{Fonctions}{defFonction}

Sous le terme \emph{fonction} sont en fait définies les \emph{procédures} et les « vraies » \emph{fonctions}. Une procédure est appelable dans une instruction et ne peut renvoyer des valeurs par ses paramètres formels de sortie et d'entrée/sortie ; une fonction est appelable dans une expression et renvoie une valeur.





\subsectionLabel{Déclaration d'une « vraie » fonction}{declarationFonction}\index{Fonction}

La déclaration d'une fonction est la suivante :
\begin{PLM}
func `mode nom @attribut (arguments_formels) -> $type {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la fonction ;
  \item \plm=`mode= est la liste non vide de l'ensemble des modes associés à la fonction ;
  \item \plm=@attribut= est une liste éventuellement vide d'attributs associés à la fonction ;
  \item \plm=arguments_formels= est la liste (éventuellement vide) des paramètres formels~;
  \item \plm=@type= est le type de la valeur renvoyée.
\end{itemize}

Contrairement à beaucoup de langages, PLM n'a pas d'instruction \texttt{return}, qui permettrait de nommer la valeur de retour. En PLM, une variable nommée \plm=result= est implicitement déclarée du type \plm=@type=, et est non valuée initialement. La liste d'instructions de la fonction {\bf doit} valuer cette variable. Sa valeur à l'issue de l'exécution de la liste d'instructions est la valeur renvoyée par la fonction. 
Par exemple :

\begin{PLM}
func `user maFonction @noUnusedWarning () -> $uint32 {
  result = 6
}
\end{PLM}

Ceci définit la fonction \plm=maFonction=, sans argument, appelable uniquement en mode \plm=`user= ; l'attribut \plm=@noUnusedWarning= signifie qu'aucune alerte n'est émise si la fonction n'est pas utilisée.

\begin{PLM}
func `user autreFonction (?arg:a $uint27 ?b $uint27) -> $uint27 {
  result = a +% b
}
\end{PLM}

Ceci définit la fonction \plm=autreFonction=, avec deux arguments, sans attribut, appelable uniquement en mode \plm=`user=.




\subsectionLabel{Déclaration d'une « procédure »}{declarationProcedure}\index{Procédure}

La déclaration d'une « procédure » est la suivante :
\begin{PLM}
func `mode nom @attribut (arguments_formels) {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la fonction ;
  \item \plm=`mode= est la liste non vide de l'ensemble des modes associés à la fonction ;
  \item \plm=@attribut= est une liste éventuellement vide d'attributs associés à la fonction ;
  \item \plm=arguments_formels= est la liste (éventuellement vide) des paramètres formels.
\end{itemize}

Aucun type de retour n'est mentionné, aussi aucune variable nommée \plm=result= n'est pré-définie. Une procédure est appelable dans une instruction.










\subsectionLabel{Fonctions requises}{procedureRequise}

La déclaration \plm+required func+ permet de signifier au compilateur qu'une procédure doit être définie, soit par la cible, soit par le programme utilisateur.

Cette déclaration est la suivante :
\begin{PLM}
required func `mode nom @attribut (arguments_formels) -> $type
\end{PLM}

ou :

\begin{PLM}
required func `mode nom @attribut (arguments_formels)
\end{PLM}

Elle consiste en la déclaration de l'en-tête d'une fonction, précédée par le mot réservé \plm+required+.







\subsectionLabel{Fonctions externes}{defProcedureExterne}

Une fonction externe est une procédure définie en C ou en assembleur et appelable en PLM.

La déclaration d'une fonction externe est la suivante :

\begin{PLM}
extern func `mode nom (arguments_formels) -> $type : "nom-assembleur"
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la fonction externe ;
  \item \plm=`mode= est la liste non vide de l'ensemble des modes associés à la fonction ;
  \item \plm=@type= est le type de la valeur renvoyée ;
  \item \plm="nom-assembleur"= est le nom qui sera engendré en assembleur, elle correspond à la directive \texttt{asm} de CLANG (et de GCC).
\end{itemize}

Si la fonction externe est en fait une \emph{procédure}, sa déclaration est la suivante :

\begin{PLM}
extern func `mode nom (arguments_formels) : "nom-assembleur"
\end{PLM}

\subsubsection{Exemple de fonction externe}

Prenons l'exemple de cette fonction, qui implémente le blocage de la tâche appelante dans une primitive :

\begin{PLM}
extern func
`kernel block (?!inList:ioWaitingList $taskList) : "blockInList"
\end{PLM}

La signature PLM de cette fonction est \plm=block(?!inList:)=.

Elle est appelable en mode \plm=`kernel=, c'est-à-dire dans une primitive. Dans l'instruction d'appel engendré en assembleur, le nom utilisé sera \texttt{func.blockInList}. Le préfixe \texttt{func.} est automatiquement ajouté par le compilateur.

Dans le code C qui implémente cette fonction, la déclaration du prototype est :

\begin{SHELL}
void block\_in\_list (TaskList * ioWaitingList) \\
asm ("!FUNC!blockInList") ;
\end{SHELL}

Le nom \texttt{block\_in\_list} est interne au code C.

Le type C \texttt{TaskList} correspond au type PLM \plm=$taskList= ; ces deux types sont définis indépendemment, c'est au programmeur de s'assurer qu'ils ont des tailles identiques (ici, 32 bits).

Le mode de passage de l'argument est spécifié par le sélecteur \plm=?!inList:=, c'est le mode \emph{entrée/sortie}, qui correspond au passage d'un pointeur en C. C'est au programmeur de s'assurer que les mode de passage spécifiés en PLM et C correspondent.

Enfin, le nom de la routine engendré en assembleur par le compilateur CLANG est spécifié par \texttt{asm("!FUNC!blockInList")}. Le nom « \texttt{blockInList} » doit être celui déclaré comme « \emph{nom-assembleur} » dans la déclaration PLM, et « \texttt{!FUNC!} » est remplacé par « \texttt{func.} » par le pré-processeur PLM.





\subsectionLabel{Attribut \texttt{@noUnusedWarning}}{attributFonctionNoWarningIfUnused}\index{"@noUnusedWarning}

L'attribut \plm+@noUnusedWarning+ signifie qu'aucune alerte n'est émise si la fonction n'est pas utilisée.



\subsectionLabel{Attribut \texttt{@global}}{attributProcGlobale}\index{"@global}

L'attribut \plm+@global+ signifie que la procédure sera visible par le code C et assembleur du projet. Ainsi une procédure écrite en PLM pourra être appelée à partir du code C et du code assembleur.





\subsectionLabel{Attribut \texttt{@weak}}{attributWeak}\index{"@weak}

[À REVOIR??]


L'attribut \plm+@weak+ signifie que la fonction peut être redéfinie par une fonction de même nom, avec les mêmes paramètres formels, les mêmes modes. Les fichiers de définition de cible utilisent cette possibilité pour définir des routines par défaut.

%Par exemple, la cible \texttt{teensy-3-1-it} définit cette routine d'interruption (voir le deuxième exemple du tutorial, \refSectionPage{deuxiemeExemple}) :

\begin{PLM}
proc systickHandler `isr @weak () {
}
\end{PLM}

Par défaut, la routine d'interruption \plm+systickHandler+ est donc définie, vide. Le programme d'exemple définit cette routine :

\begin{PLM}
proc systickHandler `isr () {
  gUpTimeMS += 1
}
\end{PLM}

Comme cette nouvelle routine a le même nom, les mêmes paramètres formels et le même mode que la routine marquée \plm+@weak+, elle est utilisée à la place de celle-ci.





\subsectionLabel{Fonctions et registres de contrôle}{procEtRegistresContrôles}

Si la fonction est déclarée avec le mode \plm!`user!, seuls les registres de contrôle déclarés \plm!@user! sont accessibles. Sinon, tous les registres de contrôle sont accessibles.


\subsectionLabel{Fonctions et variables globales}{fonctionEtVariableGlobale}

Les fonctions peuvent accéder aux variables globales en lecture, mais ne peuvent pas les modifier.

L'accès en lecture à une variable globale est autorisé par la variable qui nomme la fonction parmi les routines autorisées :

\begin{PLM}
var gGlobalVar $uint56 {
  ...
  func getGlobalVar
}

func getGlobalVar `user () -> $uint56 {
  result = getGlobalVar
}
\end{PLM}




\subsectionLabel{Fonctions et registres de contrôle}{fonctionEtRegistresContrôles}

Dans tous les cas, seul l'accès en lecture à un registre de contrôle peut être autorisé.


Si la fonction est déclarée avec le mode \plm!`user!, seuls les registres de contrôle déclarés \plm!@user! sont accessibles en lecture. Sinon, tous les registres de contrôle sont accessibles en lecture.



















\sectionLabel{Sections}{declarationSection}\index{section}

Une \emph{section} est une procédure qui est exécutée par le processeur en mode privilégié, le mode PLM qui correspond est \plm!`section!. Une section peut ainsi accéder à des registres de contrôles inaccessibles en mode \plm!`user!.

Une section est appelable uniquement à partir de fonctions ou de procédures en mode \plm!`user!.

Techniquement, l'appel s'effectue à travers une instruction telle que \emph{Service Call} qui provoque un appel système et donc permet l'exécution avec le processeur en mode privilégié.



\subsection{Déclaration d'une section}


La déclaration d'une section est la suivante :
\begin{PLM}
section nom @attribut1 @attribut2 (arguments_formels) {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la section ;
  \item \plm=@attribut1= \plm=@attribut2= est une liste éventuellement vide d'attributs associés à la section ; actuellement, seul l'attribut \plm!@noUnusedWarning! est défini (\refSubsectionPage{attributNoWarningIfUnusedSection}).
\end{itemize}



\subsectionLabel{Sections et variables globales}{sectionEtVariablesGlobales}

Pour pouvoir être utilisée dans une section, une variable globale doit déclarer cette section parmi les routines autorisées (\refSectionPage{DecRoutinesAutoriseesVarGlobale}).



\subsectionLabel{Sections et registres de contrôle}{sectionEtRegistresContrôles}

Tous les registres de contrôle sont accessibles dans une section.







\subsectionLabel{Attribut \texttt{@noUnusedWarning}}{attributNoWarningIfUnusedSection}\index{"@noUnusedWarning}

L'attribut \plm+@noUnusedWarning+ signifie qu'aucune alerte n'est émise si la section n'est pas utilisée.



















\sectionLabel{Services}{declarationService}\index{service}

Un \emph{service} est une fonction qui définit une primitive non bloquante de l'exécutif\footnote{Le processeur l'exécute en mode privilégié.}.

Un service est appelable à partir des tâches, de routines dans le mode \plm!`user!, d'autres services, ou de primitives.

Techniquement, l'appel s'effectue à travers une instruction telle que \emph{Service Call} qui provoque un appel système et donc permet l'exécution avec le processeur en mode privilégié.



\subsection{Déclaration d'un service}


La déclaration d'une section est la suivante :
\begin{PLM}
service nom @attribut (arguments_formels) {
  liste_instructions
}
\end{PLM}
Où :
\begin{itemize}
  \item \plm=nom= est le nom de la section ;
  \item \plm=@attribut= est une liste éventuellement vide d'attributs associés service ; actuellement, seul l'attribut \plm!@noUnusedWarning! est défini (\refSubsectionPage{attributNoWarningIfUnusedService}).
\end{itemize}



\subsectionLabel{Services et variables globales}{servicesEtVariablesGlobales}

Pour pouvoir être utilisée dans un service, une variable globale doit déclarer ce service parmi les routines autorisées (\refSectionPage{DecRoutinesAutoriseesVarGlobale}).



\subsectionLabel{Services et registres de contrôle}{servicesEtRegistresContrôles}

Tous les registres de contrôle sont accessibles dans un service.







\subsectionLabel{Attribut \texttt{@noUnusedWarning}}{attributNoWarningIfUnusedService}\index{"@noUnusedWarning}

L'attribut \plm+@noUnusedWarning+ signifie qu'aucune alerte n'est émise si le service n'est pas utilisé.















\sectionLabel{Primitives}{declarationPrimitive}\index{Primitive}










\sectionLabel{Routine d'interruption}{declarationRoutineInterruption}\index{Routine!Interruption}\index{Interruption!Routine}










\section{Routines utiles}

Le compilateur élimine les routines qui ne sont jamais appelées, en calculant le graphe des appels. Les racines de ce graphe sont les procédures requises (\refSubsectionPage{procedureRequise}), les routines \plm=boot=, \plm=init= et \plm=panic=. Les routines inatteignables sont éliminées, sans message d'alerte pour les routines déclarées avec l'attribut \plm!@noUnusedWarning!.











\sectionLabel{Récursivité}{routinesRecursives}\index{Routines!recursives@récursives}

Par défaut, le compilateur émet un message d'erreur si une ou plusieurs routines récursives sont détectées. L'option \OPTION{-{}-do-not-detect-recursive-calls} (\refSectionPage{optionCodeEngendre}) permet d'inhiber cette recherche.

L'option \OPTION{-{}-routine-invocation-graph} permet d'obtenir un fichier contenant le graphe d'invocation, qui peut être affiché par le logiciel \texttt{graphviz}\index{graphviz}. Si le fichier source est \texttt{source.plm}, le fichier engendré s'appelle \texttt{source.subprogramInvocation.dot}.

