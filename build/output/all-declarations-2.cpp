#include "galgas2/C_Compiler.h"
#include "galgas2/C_galgas_io.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "utilities/C_PrologueEpilogue.h"

//---------------------------------------------------------------------------------------------------------------------*

#include "all-declarations-2.h"


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          Function 'mangledNameForFunction'                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForFunction (GALGAS_string inArgument_inName,
                                               C_Compiler * inCompiler
                                               COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("func_").add_operation (inArgument_inName.reader_nameRepresentation (SOURCE_FILE ("generated-code-prefixes.galgas", 66)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 66)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForFunction [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForFunction (C_Compiler * inCompiler,
                                                                       const cObjectArray & inEffectiveParameterArray,
                                                                       const GALGAS_location & /* §§ inErrorLocation */
                                                                       COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_mangledNameForFunction (operand0,
                                          inCompiler
                                          COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForFunction ("mangledNameForFunction",
                                                                        functionWithGenericHeader_mangledNameForFunction,
                                                                        & kTypeDescriptor_GALGAS_string,
                                                                        1,
                                                                        functionArgs_mangledNameForFunction) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                         Function 'mangledNameForProcedure'                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForProcedure (GALGAS_string inArgument_inName,
                                                C_Compiler * inCompiler
                                                COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("proc_").add_operation (inArgument_inName.reader_nameRepresentation (SOURCE_FILE ("generated-code-prefixes.galgas", 72)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 72)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForProcedure [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForProcedure (C_Compiler * inCompiler,
                                                                        const cObjectArray & inEffectiveParameterArray,
                                                                        const GALGAS_location & /* §§ inErrorLocation */
                                                                        COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_mangledNameForProcedure (operand0,
                                           inCompiler
                                           COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForProcedure ("mangledNameForProcedure",
                                                                         functionWithGenericHeader_mangledNameForProcedure,
                                                                         & kTypeDescriptor_GALGAS_string,
                                                                         1,
                                                                         functionArgs_mangledNameForProcedure) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                       Function 'mangledNameForLocalVariable'                                        *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForLocalVariable (GALGAS_string inArgument_inName,
                                                    C_Compiler * inCompiler
                                                    COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("var_").add_operation (inArgument_inName.reader_nameRepresentation (SOURCE_FILE ("generated-code-prefixes.galgas", 78)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 78)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForLocalVariable [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForLocalVariable (C_Compiler * inCompiler,
                                                                            const cObjectArray & inEffectiveParameterArray,
                                                                            const GALGAS_location & /* §§ inErrorLocation */
                                                                            COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_mangledNameForLocalVariable (operand0,
                                               inCompiler
                                               COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForLocalVariable ("mangledNameForLocalVariable",
                                                                             functionWithGenericHeader_mangledNameForLocalVariable,
                                                                             & kTypeDescriptor_GALGAS_string,
                                                                             1,
                                                                             functionArgs_mangledNameForLocalVariable) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                       Function 'mangledNameForGlobalVariable'                                       *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForGlobalVariable (GALGAS_string inArgument_inName,
                                                     C_Compiler * inCompiler
                                                     COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("gvar_").add_operation (inArgument_inName.reader_nameRepresentation (SOURCE_FILE ("generated-code-prefixes.galgas", 84)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 84)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForGlobalVariable [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForGlobalVariable (C_Compiler * inCompiler,
                                                                             const cObjectArray & inEffectiveParameterArray,
                                                                             const GALGAS_location & /* §§ inErrorLocation */
                                                                             COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_mangledNameForGlobalVariable (operand0,
                                                inCompiler
                                                COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForGlobalVariable ("mangledNameForGlobalVariable",
                                                                              functionWithGenericHeader_mangledNameForGlobalVariable,
                                                                              & kTypeDescriptor_GALGAS_string,
                                                                              1,
                                                                              functionArgs_mangledNameForGlobalVariable) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          Function 'mangledNameForConstant'                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForConstant (GALGAS_string inArgument_inName,
                                               C_Compiler * inCompiler
                                               COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("const_").add_operation (inArgument_inName.reader_nameRepresentation (SOURCE_FILE ("generated-code-prefixes.galgas", 90)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 90)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForConstant [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForConstant (C_Compiler * inCompiler,
                                                                       const cObjectArray & inEffectiveParameterArray,
                                                                       const GALGAS_location & /* §§ inErrorLocation */
                                                                       COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_mangledNameForConstant (operand0,
                                          inCompiler
                                          COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForConstant ("mangledNameForConstant",
                                                                        functionWithGenericHeader_mangledNameForConstant,
                                                                        & kTypeDescriptor_GALGAS_string,
                                                                        1,
                                                                        functionArgs_mangledNameForConstant) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                     Function 'mangledNameForTemporaryConstant'                                      *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForTemporaryConstant (GALGAS_uint inArgument_inIndex,
                                                        C_Compiler * inCompiler
                                                        COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("tempconst_").add_operation (inArgument_inIndex.reader_string (SOURCE_FILE ("generated-code-prefixes.galgas", 95)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 95)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForTemporaryConstant [2] = {
  & kTypeDescriptor_GALGAS_uint,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForTemporaryConstant (C_Compiler * inCompiler,
                                                                                const cObjectArray & inEffectiveParameterArray,
                                                                                const GALGAS_location & /* §§ inErrorLocation */
                                                                                COMMA_LOCATION_ARGS) {
  const GALGAS_uint operand0 = GALGAS_uint::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                           inCompiler
                                                           COMMA_THERE) ;
  return function_mangledNameForTemporaryConstant (operand0,
                                                   inCompiler
                                                   COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForTemporaryConstant ("mangledNameForTemporaryConstant",
                                                                                 functionWithGenericHeader_mangledNameForTemporaryConstant,
                                                                                 & kTypeDescriptor_GALGAS_string,
                                                                                 1,
                                                                                 functionArgs_mangledNameForTemporaryConstant) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          Function 'mangledNameForRegister'                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_mangledNameForRegister (GALGAS_string inArgument_inName,
                                               C_Compiler * inCompiler
                                               COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outName ; // Returned variable
  result_outName = GALGAS_string ("register_").add_operation (inArgument_inName.reader_nameRepresentation (SOURCE_FILE ("generated-code-prefixes.galgas", 101)), inCompiler COMMA_SOURCE_FILE ("generated-code-prefixes.galgas", 101)) ;
//---
  return result_outName ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_mangledNameForRegister [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_mangledNameForRegister (C_Compiler * inCompiler,
                                                                       const cObjectArray & inEffectiveParameterArray,
                                                                       const GALGAS_location & /* §§ inErrorLocation */
                                                                       COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_mangledNameForRegister (operand0,
                                          inCompiler
                                          COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_mangledNameForRegister ("mangledNameForRegister",
                                                                        functionWithGenericHeader_mangledNameForRegister,
                                                                        & kTypeDescriptor_GALGAS_string,
                                                                        1,
                                                                        functionArgs_mangledNameForRegister) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             Routine 'codeOptimisation'                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_codeOptimisation (GALGAS_intermediateCodeStruct & ioArgument_ioIntermediateCodeStruct,
                               C_Compiler * inCompiler
                               COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_uint var_pass = GALGAS_uint ((uint32_t) 0U) ;
  GALGAS_bool var_optimizing = GALGAS_bool (true) ;
  if (ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 71)).add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 71)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 71)).add_operation (GALGAS_uint ((uint32_t) 1U), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 71)).isValid ()) {
    uint32_t variant_3248 = ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 71)).add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 71)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 71)).add_operation (GALGAS_uint ((uint32_t) 1U), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 71)).uintValue () ;
    bool loop_3248 = true ;
    while (loop_3248) {
      loop_3248 = var_optimizing.isValid () ;
      if (loop_3248) {
        loop_3248 = var_optimizing.boolValue () ;
      }
      if (loop_3248 && (0 == variant_3248)) {
        loop_3248 = false ;
        inCompiler->loopRunTimeVariantError (SOURCE_FILE ("code-optimisation.galgas", 71)) ;
      }
      if (loop_3248) {
        variant_3248 -- ;
        var_optimizing = GALGAS_bool (false) ;
        var_pass.increment_operation (inCompiler  COMMA_SOURCE_FILE ("code-optimisation.galgas", 74)) ;
        GALGAS_string var_s = GALGAS_string ("Optimisation pass ").add_operation (var_pass.reader_string (SOURCE_FILE ("code-optimisation.galgas", 76)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 76)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 76)) ;
        var_s.dotAssign_operation (GALGAS_string ("  ").add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mRegisterMap.reader_count (SOURCE_FILE ("code-optimisation.galgas", 77)).reader_string (SOURCE_FILE ("code-optimisation.galgas", 77)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 77)).add_operation (GALGAS_string (" registers\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 77))  COMMA_SOURCE_FILE ("code-optimisation.galgas", 77)) ;
        var_s.dotAssign_operation (GALGAS_string ("  ").add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalLiteralStringMap.reader_count (SOURCE_FILE ("code-optimisation.galgas", 78)).reader_string (SOURCE_FILE ("code-optimisation.galgas", 78)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 78)).add_operation (GALGAS_string (" static strings\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 78))  COMMA_SOURCE_FILE ("code-optimisation.galgas", 78)) ;
        var_s.dotAssign_operation (GALGAS_string ("  ").add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalConstantMap.reader_count (SOURCE_FILE ("code-optimisation.galgas", 79)).reader_string (SOURCE_FILE ("code-optimisation.galgas", 79)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 79)).add_operation (GALGAS_string (" global constants\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 79))  COMMA_SOURCE_FILE ("code-optimisation.galgas", 79)) ;
        var_s.dotAssign_operation (GALGAS_string ("  ").add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalVariableMap.reader_count (SOURCE_FILE ("code-optimisation.galgas", 80)).reader_string (SOURCE_FILE ("code-optimisation.galgas", 80)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 80)).add_operation (GALGAS_string (" global variables\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 80))  COMMA_SOURCE_FILE ("code-optimisation.galgas", 80)) ;
        var_s.dotAssign_operation (GALGAS_string ("  ").add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 81)).reader_string (SOURCE_FILE ("code-optimisation.galgas", 81)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 81)).add_operation (GALGAS_string (" procedures\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 81))  COMMA_SOURCE_FILE ("code-optimisation.galgas", 81)) ;
        var_s.dotAssign_operation (GALGAS_string ("  ").add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 82)).reader_string (SOURCE_FILE ("code-optimisation.galgas", 82)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 82)).add_operation (GALGAS_string (" functions\n"), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 82))  COMMA_SOURCE_FILE ("code-optimisation.galgas", 82)) ;
        inCompiler->printMessage (var_s  COMMA_SOURCE_FILE ("code-optimisation.galgas", 83)) ;
        GALGAS_accessibleEntities var_accessibleEntities ;
        {
        routine_suppressInaccessibleSubprograms (ioArgument_ioIntermediateCodeStruct, var_accessibleEntities, var_optimizing, inCompiler  COMMA_SOURCE_FILE ("code-optimisation.galgas", 85)) ;
        }
        GALGAS_registerMapIR var_usedRegisterMap = GALGAS_registerMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 91)) ;
        cEnumerator_registerMapIR enumerator_4427 (ioArgument_ioIntermediateCodeStruct.mAttribute_mRegisterMap, kEnumeration_up) ;
        while (enumerator_4427.hasCurrentObject ()) {
          const enumGalgasBool test_0 = var_accessibleEntities.mAttribute_mAccessibleRegisterSet.reader_hasKey (enumerator_4427.current_lkey (HERE).mAttribute_string COMMA_SOURCE_FILE ("code-optimisation.galgas", 93)).boolEnum () ;
          if (kBoolTrue == test_0) {
            {
            var_usedRegisterMap.modifier_insertKey (enumerator_4427.current_lkey (HERE), enumerator_4427.current_mRegisterTypeName (HERE), enumerator_4427.current_mRegisterAddress (HERE), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 94)) ;
            }
          }else if (kBoolFalse == test_0) {
            var_optimizing = GALGAS_bool (true) ;
          }
          enumerator_4427.gotoNextObject () ;
        }
        ioArgument_ioIntermediateCodeStruct.mAttribute_mRegisterMap = var_usedRegisterMap ;
        GALGAS_globalConstantMapIR var_globalConstantMap = GALGAS_globalConstantMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 101)) ;
        cEnumerator_globalConstantMapIR enumerator_4846 (ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalConstantMap, kEnumeration_up) ;
        while (enumerator_4846.hasCurrentObject ()) {
          const enumGalgasBool test_1 = var_accessibleEntities.mAttribute_mGlobalConstantSet.reader_hasKey (enumerator_4846.current (HERE).mAttribute_lkey.mAttribute_string COMMA_SOURCE_FILE ("code-optimisation.galgas", 103)).boolEnum () ;
          if (kBoolTrue == test_1) {
            {
            var_globalConstantMap.modifier_insertKey (enumerator_4846.current (HERE).mAttribute_lkey, enumerator_4846.current (HERE).mAttribute_mValueExpressionGeneration, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 104)) ;
            }
          }else if (kBoolFalse == test_1) {
            var_optimizing = GALGAS_bool (true) ;
          }
          enumerator_4846.gotoNextObject () ;
        }
        ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalConstantMap = var_globalConstantMap ;
        GALGAS_globalLiteralStringMap var_staticStringMap = GALGAS_globalLiteralStringMap::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 111)) ;
        cEnumerator_globalLiteralStringMap enumerator_5343 (ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalLiteralStringMap, kEnumeration_up) ;
        while (enumerator_5343.hasCurrentObject ()) {
          const enumGalgasBool test_2 = var_accessibleEntities.mAttribute_mStaticStringSet.reader_hasKey (enumerator_5343.current_lkey (HERE).mAttribute_string COMMA_SOURCE_FILE ("code-optimisation.galgas", 115)).boolEnum () ;
          if (kBoolTrue == test_2) {
            {
            var_staticStringMap.modifier_insertKey (enumerator_5343.current_lkey (HERE), enumerator_5343.current_mLiteralStringCname (HERE), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 116)) ;
            }
          }else if (kBoolFalse == test_2) {
            var_optimizing = GALGAS_bool (true) ;
          }
          enumerator_5343.gotoNextObject () ;
        }
        ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalLiteralStringMap = var_staticStringMap ;
        GALGAS_globalVariableMapIR var_globalVariableMap = GALGAS_globalVariableMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 123)) ;
        cEnumerator_globalVariableMapIR enumerator_5766 (ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalVariableMap, kEnumeration_up) ;
        while (enumerator_5766.hasCurrentObject ()) {
          const enumGalgasBool test_3 = var_accessibleEntities.mAttribute_mGlobalVariableSet.reader_hasKey (enumerator_5766.current (HERE).mAttribute_lkey.mAttribute_string COMMA_SOURCE_FILE ("code-optimisation.galgas", 125)).boolEnum () ;
          if (kBoolTrue == test_3) {
            {
            var_globalVariableMap.modifier_insertKey (enumerator_5766.current (HERE).mAttribute_lkey, enumerator_5766.current (HERE).mAttribute_mActualTypeName, enumerator_5766.current (HERE).mAttribute_mGenerateVolatile, enumerator_5766.current (HERE).mAttribute_mInitialValue, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 126)) ;
            }
          }else if (kBoolFalse == test_3) {
            var_optimizing = GALGAS_bool (true) ;
          }
          enumerator_5766.gotoNextObject () ;
        }
        ioArgument_ioIntermediateCodeStruct.mAttribute_mGlobalVariableMap = var_globalVariableMap ;
      }
    }
  }
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                      Routine 'suppressInaccessibleSubprograms'                                      *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_suppressInaccessibleSubprograms (GALGAS_intermediateCodeStruct & ioArgument_ioIntermediateCodeStruct,
                                              GALGAS_accessibleEntities & outArgument_outAccessibleEntities,
                                              GALGAS_bool & ioArgument_ioOptimizing,
                                              C_Compiler * inCompiler
                                              COMMA_UNUSED_LOCATION_ARGS) {
  outArgument_outAccessibleEntities.drop () ; // Release 'out' argument
  outArgument_outAccessibleEntities = GALGAS_accessibleEntities::constructor_default (SOURCE_FILE ("code-optimisation.galgas", 147)) ;
  GALGAS_procedureMapIR var_accessibleProcedureMap = GALGAS_procedureMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 148)) ;
  GALGAS_procedureMapIR var_nonExploredProcedureMap = GALGAS_procedureMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 149)) ;
  cEnumerator_procedureMapIR enumerator_6723 (ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR, kEnumeration_up) ;
  while (enumerator_6723.hasCurrentObject ()) {
    const enumGalgasBool test_0 = enumerator_6723.current (HERE).mAttribute_mIsRequired.boolEnum () ;
    if (kBoolTrue == test_0) {
      {
      var_accessibleProcedureMap.modifier_insertKey (enumerator_6723.current (HERE).mAttribute_lkey, enumerator_6723.current (HERE).mAttribute_mFormalArgumentListForGeneration, enumerator_6723.current (HERE).mAttribute_mInstructionGenerationList, enumerator_6723.current (HERE).mAttribute_mIsRequired, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 153)) ;
      }
      categoryMethod_enterAccessibleEntities (enumerator_6723.current (HERE), outArgument_outAccessibleEntities, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 159)) ;
      outArgument_outAccessibleEntities.mAttribute_mProcedureSet.addAssign_operation (enumerator_6723.current (HERE).mAttribute_lkey.mAttribute_string  COMMA_SOURCE_FILE ("code-optimisation.galgas", 160)) ;
    }else if (kBoolFalse == test_0) {
      {
      var_nonExploredProcedureMap.modifier_insertKey (enumerator_6723.current (HERE).mAttribute_lkey, enumerator_6723.current (HERE).mAttribute_mFormalArgumentListForGeneration, enumerator_6723.current (HERE).mAttribute_mInstructionGenerationList, enumerator_6723.current (HERE).mAttribute_mIsRequired, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 162)) ;
      }
    }
    enumerator_6723.gotoNextObject () ;
  }
  cEnumerator_initListIR enumerator_7413 (ioArgument_ioIntermediateCodeStruct.mAttribute_mInitList, kEnumeration_up) ;
  while (enumerator_7413.hasCurrentObject ()) {
    categoryMethod_enterAccessibleEntities (enumerator_7413.current (HERE).mAttribute_mInstructionListIR, outArgument_outAccessibleEntities, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 172)) ;
    enumerator_7413.gotoNextObject () ;
  }
  const enumGalgasBool test_1 = GALGAS_bool (gOption_plm_5F_options_noExceptionGeneration.reader_value ()).operator_not (SOURCE_FILE ("code-optimisation.galgas", 175)).boolEnum () ;
  if (kBoolTrue == test_1) {
    categoryMethod_enterAccessibleEntities (ioArgument_ioIntermediateCodeStruct.mAttribute_mExceptionInstructionListIR, outArgument_outAccessibleEntities, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 176)) ;
  }
  GALGAS_functionMapIR var_accessibleFunctionMap = GALGAS_functionMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 179)) ;
  GALGAS_functionMapIR var_nonExploredFunctionMap = ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR ;
  GALGAS_bool var_exploreProceduresAndFunctions = GALGAS_bool (true) ;
  if (ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 182)).add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 182)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 182)).add_operation (GALGAS_uint ((uint32_t) 1U), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 182)).isValid ()) {
    uint32_t variant_7945 = ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 182)).add_operation (ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR.reader_count (SOURCE_FILE ("code-optimisation.galgas", 182)), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 182)).add_operation (GALGAS_uint ((uint32_t) 1U), inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 182)).uintValue () ;
    bool loop_7945 = true ;
    while (loop_7945) {
      loop_7945 = var_exploreProceduresAndFunctions.isValid () ;
      if (loop_7945) {
        loop_7945 = var_exploreProceduresAndFunctions.boolValue () ;
      }
      if (loop_7945 && (0 == variant_7945)) {
        loop_7945 = false ;
        inCompiler->loopRunTimeVariantError (SOURCE_FILE ("code-optimisation.galgas", 182)) ;
      }
      if (loop_7945) {
        variant_7945 -- ;
        var_exploreProceduresAndFunctions = GALGAS_bool (false) ;
        GALGAS_procedureMapIR var_exNonExploredProcedureMap = var_nonExploredProcedureMap ;
        var_nonExploredProcedureMap = GALGAS_procedureMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 186)) ;
        cEnumerator_procedureMapIR enumerator_8289 (var_exNonExploredProcedureMap, kEnumeration_up) ;
        while (enumerator_8289.hasCurrentObject ()) {
          const enumGalgasBool test_2 = outArgument_outAccessibleEntities.mAttribute_mProcedureSet.reader_hasKey (enumerator_8289.current (HERE).mAttribute_lkey.mAttribute_string COMMA_SOURCE_FILE ("code-optimisation.galgas", 188)).boolEnum () ;
          if (kBoolTrue == test_2) {
            {
            var_accessibleProcedureMap.modifier_insertKey (enumerator_8289.current (HERE).mAttribute_lkey, enumerator_8289.current (HERE).mAttribute_mFormalArgumentListForGeneration, enumerator_8289.current (HERE).mAttribute_mInstructionGenerationList, enumerator_8289.current (HERE).mAttribute_mIsRequired, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 189)) ;
            }
            categoryMethod_enterAccessibleEntities (enumerator_8289.current (HERE), outArgument_outAccessibleEntities, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 195)) ;
            var_exploreProceduresAndFunctions = GALGAS_bool (true) ;
          }else if (kBoolFalse == test_2) {
            {
            var_nonExploredProcedureMap.modifier_insertKey (enumerator_8289.current (HERE).mAttribute_lkey, enumerator_8289.current (HERE).mAttribute_mFormalArgumentListForGeneration, enumerator_8289.current (HERE).mAttribute_mInstructionGenerationList, enumerator_8289.current (HERE).mAttribute_mIsRequired, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 198)) ;
            }
          }
          enumerator_8289.gotoNextObject () ;
        }
        GALGAS_functionMapIR var_exNonExploredFunctionMap = var_nonExploredFunctionMap ;
        var_nonExploredFunctionMap = GALGAS_functionMapIR::constructor_emptyMap (SOURCE_FILE ("code-optimisation.galgas", 207)) ;
        cEnumerator_functionMapIR enumerator_9113 (var_exNonExploredFunctionMap, kEnumeration_up) ;
        while (enumerator_9113.hasCurrentObject ()) {
          const enumGalgasBool test_3 = outArgument_outAccessibleEntities.mAttribute_mFunctionSet.reader_hasKey (enumerator_9113.current (HERE).mAttribute_lkey.mAttribute_string COMMA_SOURCE_FILE ("code-optimisation.galgas", 209)).boolEnum () ;
          if (kBoolTrue == test_3) {
            {
            var_accessibleFunctionMap.modifier_insertKey (enumerator_9113.current (HERE).mAttribute_lkey, enumerator_9113.current (HERE).mAttribute_mFormalArgumentListForGeneration, enumerator_9113.current (HERE).mAttribute_mInstructionGenerationList, enumerator_9113.current (HERE).mAttribute_mResultType, enumerator_9113.current (HERE).mAttribute_mResultVarName, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 210)) ;
            }
            categoryMethod_enterAccessibleEntities (enumerator_9113.current (HERE), outArgument_outAccessibleEntities, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 217)) ;
            var_exploreProceduresAndFunctions = GALGAS_bool (true) ;
          }else if (kBoolFalse == test_3) {
            {
            var_nonExploredFunctionMap.modifier_insertKey (enumerator_9113.current (HERE).mAttribute_lkey, enumerator_9113.current (HERE).mAttribute_mFormalArgumentListForGeneration, enumerator_9113.current (HERE).mAttribute_mInstructionGenerationList, enumerator_9113.current (HERE).mAttribute_mResultType, enumerator_9113.current (HERE).mAttribute_mResultVarName, inCompiler COMMA_SOURCE_FILE ("code-optimisation.galgas", 220)) ;
            }
          }
          enumerator_9113.gotoNextObject () ;
        }
      }
    }
  }
  const enumGalgasBool test_4 = GALGAS_bool (kIsNotEqual, ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR.objectCompare (var_accessibleProcedureMap)).boolEnum () ;
  if (kBoolTrue == test_4) {
    ioArgument_ioIntermediateCodeStruct.mAttribute_mProcedureMapIR = var_accessibleProcedureMap ;
    ioArgument_ioOptimizing = GALGAS_bool (true) ;
  }
  const enumGalgasBool test_5 = GALGAS_bool (kIsNotEqual, ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR.objectCompare (var_accessibleFunctionMap)).boolEnum () ;
  if (kBoolTrue == test_5) {
    ioArgument_ioIntermediateCodeStruct.mAttribute_mFunctionMapIR = var_accessibleFunctionMap ;
    ioArgument_ioOptimizing = GALGAS_bool (true) ;
  }
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            Once function 'separatorLine'                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_string onceFunction_separatorLine (C_Compiler * /* inCompiler */
                                                 COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outResult ; // Returned variable
  result_outResult = GALGAS_string ("//------------------------------------------------------------------------") ;
  result_outResult.dotAssign_operation (GALGAS_string ("---------------------------------------------*\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 76)) ;
//---
  return result_outResult ;
}



//---------------------------------------------------------------------------------------------------------------------*
//  Function implementation                                                                                            *
//---------------------------------------------------------------------------------------------------------------------*

static bool gOnceFunctionResultAvailable_separatorLine = false ;
static GALGAS_string gOnceFunctionResult_separatorLine ;

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_separatorLine (class C_Compiler * inCompiler
              COMMA_LOCATION_ARGS) {
  if (! gOnceFunctionResultAvailable_separatorLine) {
    gOnceFunctionResult_separatorLine = onceFunction_separatorLine (inCompiler COMMA_THERE) ;
    gOnceFunctionResultAvailable_separatorLine = true ;
  }
  return gOnceFunctionResult_separatorLine ;
}

//---------------------------------------------------------------------------------------------------------------------*

static void releaseOnceFunctionResult_separatorLine (void) {
  gOnceFunctionResult_separatorLine.drop () ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_PrologueEpilogue gEpilogueForOnceFunction_separatorLine (NULL,
                                                           releaseOnceFunctionResult_separatorLine) ;

//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_separatorLine [1] = {
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_separatorLine (C_Compiler * inCompiler,
                                                              const cObjectArray & /* inEffectiveParameterArray */,
                                                              const GALGAS_location & /* inErrorLocation */
                                                              COMMA_LOCATION_ARGS) {
  return function_separatorLine (inCompiler COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_separatorLine ("separatorLine",
                                                               functionWithGenericHeader_separatorLine,
                                                               & kTypeDescriptor_GALGAS_string,
                                                               0,
                                                               functionArgs_separatorLine) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                               Function 'titleComment'                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string function_titleComment (GALGAS_string inArgument_inTitle,
                                     C_Compiler * inCompiler
                                     COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outTitle ; // Returned variable
  result_outTitle = function_separatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 82)) ;
  result_outTitle.dotAssign_operation (GALGAS_string ("//   ").add_operation (inArgument_inTitle.reader_stringByRightPadding (GALGAS_uint ((uint32_t) 114U), GALGAS_char (TO_UNICODE (32)) COMMA_SOURCE_FILE ("code-generation.galgas", 83)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 83)).add_operation (GALGAS_string ("*\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 83))  COMMA_SOURCE_FILE ("code-generation.galgas", 83)) ;
  result_outTitle.dotAssign_operation (function_separatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 84)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 84))  COMMA_SOURCE_FILE ("code-generation.galgas", 84)) ;
//---
  return result_outTitle ;
}


//---------------------------------------------------------------------------------------------------------------------*
//  Function introspection                                                                                             *
//---------------------------------------------------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_titleComment [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//---------------------------------------------------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_titleComment (C_Compiler * inCompiler,
                                                             const cObjectArray & inEffectiveParameterArray,
                                                             const GALGAS_location & /* §§ inErrorLocation */
                                                             COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_titleComment (operand0,
                                inCompiler
                                COMMA_THERE).reader_object (THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_titleComment ("titleComment",
                                                              functionWithGenericHeader_titleComment,
                                                              & kTypeDescriptor_GALGAS_string,
                                                              1,
                                                              functionArgs_titleComment) ;

//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              Routine 'codeGeneration'                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_codeGeneration (const GALGAS_string constinArgument_inSourceFileName,
                             const GALGAS_intermediateCodeStruct constinArgument_inIntermediateCodeStruct,
                             const GALGAS_lstring constinArgument_inTargetName,
                             C_Compiler * inCompiler
                             COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string var_targetDirectory = constinArgument_inSourceFileName.reader_stringByDeletingPathExtension (SOURCE_FILE ("code-generation.galgas", 95)) ;
  GALGAS_string var_sourceDirectory = var_targetDirectory.add_operation (GALGAS_string ("/sources"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 96)) ;
  var_sourceDirectory.method_makeDirectory (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 97)) ;
  GALGAS_stringlist var_builtinFiles ;
  {
  routine_generateTargets (var_targetDirectory, constinArgument_inTargetName, var_builtinFiles, inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 99)) ;
  }
  GALGAS_string var_code = GALGAS_string::makeEmptyString () ;
  var_code.dotAssign_operation (GALGAS_string ("#include <stdint.h>\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 106)) ;
  var_code.dotAssign_operation (GALGAS_string ("#include <stdbool.h>\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 107)) ;
  var_code.dotAssign_operation (GALGAS_string ("#include <stddef.h>\n"
    "\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 108)) ;
  cEnumerator_typeMapIR enumerator_5138 (constinArgument_inIntermediateCodeStruct.mAttribute_mTypeMapIR, kEnumeration_up) ;
  while (enumerator_5138.hasCurrentObject ()) {
    var_code.dotAssign_operation (callCategoryReader_headerCodeGenerationForType ((const cPtr_abstractTypeIR *) enumerator_5138.current (HERE).mAttribute_mType.ptr (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 110))  COMMA_SOURCE_FILE ("code-generation.galgas", 110)) ;
    enumerator_5138.gotoNextObject () ;
  }
  var_code.dotAssign_operation (function_titleComment (GALGAS_string ("Init"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 112))  COMMA_SOURCE_FILE ("code-generation.galgas", 112)) ;
  var_code.dotAssign_operation (GALGAS_string ("static void init (void) ;\n"
    "\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 113)) ;
  const enumGalgasBool test_0 = GALGAS_bool (gOption_plm_5F_options_noExceptionGeneration.reader_value ()).operator_not (SOURCE_FILE ("code-generation.galgas", 114)).boolEnum () ;
  if (kBoolTrue == test_0) {
    var_code.dotAssign_operation (function_titleComment (GALGAS_string ("Exception"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 115))  COMMA_SOURCE_FILE ("code-generation.galgas", 115)) ;
    var_code.dotAssign_operation (GALGAS_string ("static void raise_exception_internal (const uint32_t inCode,\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 116)) ;
    var_code.dotAssign_operation (GALGAS_string ("                                      const char * inSourceFile,\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 117)) ;
    var_code.dotAssign_operation (GALGAS_string ("                                      const uint32_t inSourceLine) ;\n"
      "\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 118)) ;
    var_code.dotAssign_operation (GALGAS_string ("static void raise_exception (const int32_t inCode,\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 119)) ;
    var_code.dotAssign_operation (GALGAS_string ("                             const char * inSourceFile,\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 120)) ;
    var_code.dotAssign_operation (GALGAS_string ("                             const int32_t inSourceLine) {\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 121)) ;
    var_code.dotAssign_operation (GALGAS_string (" //--- Mask interrupt: write 1 into FAULTMASK register\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 122)) ;
    var_code.dotAssign_operation (GALGAS_string ("  const uint32_t maskValue = 1 ;\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 123)) ;
    var_code.dotAssign_operation (GALGAS_string ("  __asm__ (\"msr FAULTMASK, %[reg]\" : : [reg]\"r\"(maskValue));\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 124)) ;
    var_code.dotAssign_operation (GALGAS_string ("  raise_exception_internal (inCode, inSourceFile, inSourceLine) ;\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 125)) ;
    var_code.dotAssign_operation (GALGAS_string ("}\n"
      "\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 126)) ;
  }
  var_code.dotAssign_operation (function_titleComment (GALGAS_string ("Static Strings"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 128))  COMMA_SOURCE_FILE ("code-generation.galgas", 128)) ;
  cEnumerator_globalLiteralStringMap enumerator_6250 (constinArgument_inIntermediateCodeStruct.mAttribute_mGlobalLiteralStringMap, kEnumeration_up) ;
  while (enumerator_6250.hasCurrentObject ()) {
    var_code.dotAssign_operation (GALGAS_string ("static const char * ").add_operation (enumerator_6250.current_mLiteralStringCname (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 130)).add_operation (GALGAS_string (" = "), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 130)).add_operation (enumerator_6250.current_lkey (HERE).mAttribute_string.reader_utf_38_Representation (SOURCE_FILE ("code-generation.galgas", 130)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 130)).add_operation (GALGAS_string (" ;\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 130))  COMMA_SOURCE_FILE ("code-generation.galgas", 130)) ;
    enumerator_6250.gotoNextObject () ;
  }
  var_code.dotAssign_operation (GALGAS_string ("\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 132)) ;
  cEnumerator_registerMapIR enumerator_6439 (constinArgument_inIntermediateCodeStruct.mAttribute_mRegisterMap, kEnumeration_up) ;
  while (enumerator_6439.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_headerCodeGenerationForRegister (enumerator_6439.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 134))  COMMA_SOURCE_FILE ("code-generation.galgas", 134)) ;
    enumerator_6439.gotoNextObject () ;
  }
  cEnumerator_globalConstantMapIR enumerator_6571 (constinArgument_inIntermediateCodeStruct.mAttribute_mGlobalConstantMap, kEnumeration_up) ;
  while (enumerator_6571.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_headerCodeGeneration (enumerator_6571.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 137))  COMMA_SOURCE_FILE ("code-generation.galgas", 137)) ;
    enumerator_6571.gotoNextObject () ;
  }
  cEnumerator_globalVariableMapIR enumerator_6698 (constinArgument_inIntermediateCodeStruct.mAttribute_mGlobalVariableMap, kEnumeration_up) ;
  while (enumerator_6698.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_implementationCodeGeneration (enumerator_6698.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 140))  COMMA_SOURCE_FILE ("code-generation.galgas", 140)) ;
    enumerator_6698.gotoNextObject () ;
  }
  cEnumerator_functionMapIR enumerator_6823 (constinArgument_inIntermediateCodeStruct.mAttribute_mFunctionMapIR, kEnumeration_up) ;
  while (enumerator_6823.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_headerCodeGeneration (enumerator_6823.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 143))  COMMA_SOURCE_FILE ("code-generation.galgas", 143)) ;
    enumerator_6823.gotoNextObject () ;
  }
  cEnumerator_procedureMapIR enumerator_6936 (constinArgument_inIntermediateCodeStruct.mAttribute_mProcedureMapIR, kEnumeration_up) ;
  while (enumerator_6936.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_headerCodeGeneration (enumerator_6936.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 146))  COMMA_SOURCE_FILE ("code-generation.galgas", 146)) ;
    enumerator_6936.gotoNextObject () ;
  }
  var_code.dotAssign_operation (function_titleComment (GALGAS_string ("System code"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 148))  COMMA_SOURCE_FILE ("code-generation.galgas", 148)) ;
  cEnumerator_stringlist enumerator_7059 (var_builtinFiles, kEnumeration_up) ;
  while (enumerator_7059.hasCurrentObject ()) {
    var_code.dotAssign_operation (GALGAS_string ("#include \"").add_operation (enumerator_7059.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 150)).add_operation (GALGAS_string ("\"\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 150))  COMMA_SOURCE_FILE ("code-generation.galgas", 150)) ;
    enumerator_7059.gotoNextObject () ;
  }
  var_code.dotAssign_operation (GALGAS_string ("\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 152)) ;
  var_code.dotAssign_operation (function_titleComment (GALGAS_string ("Init"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 154))  COMMA_SOURCE_FILE ("code-generation.galgas", 154)) ;
  var_code.dotAssign_operation (GALGAS_string ("static void init (void) {\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 155)) ;
  cEnumerator_initListIR enumerator_7257 (constinArgument_inIntermediateCodeStruct.mAttribute_mInitList, kEnumeration_up) ;
  while (enumerator_7257.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_instructionListCode (enumerator_7257.current (HERE).mAttribute_mInstructionListIR, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 157))  COMMA_SOURCE_FILE ("code-generation.galgas", 157)) ;
    enumerator_7257.gotoNextObject () ;
  }
  var_code.dotAssign_operation (GALGAS_string ("}\n"
    "\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 159)) ;
  const enumGalgasBool test_1 = GALGAS_bool (gOption_plm_5F_options_noExceptionGeneration.reader_value ()).operator_not (SOURCE_FILE ("code-generation.galgas", 160)).boolEnum () ;
  if (kBoolTrue == test_1) {
    var_code.dotAssign_operation (function_titleComment (GALGAS_string ("Raise Exception internal"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 161))  COMMA_SOURCE_FILE ("code-generation.galgas", 161)) ;
    var_code.dotAssign_operation (GALGAS_string ("static void raise_exception_internal (const uint32_t in_CODE,\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 162)) ;
    var_code.dotAssign_operation (GALGAS_string ("                                      const char * in_FILE,\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 163)) ;
    var_code.dotAssign_operation (GALGAS_string ("                                      const uint32_t in_LINE) {\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 164)) ;
    var_code.dotAssign_operation (categoryReader_instructionListCode (constinArgument_inIntermediateCodeStruct.mAttribute_mExceptionInstructionListIR, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 165))  COMMA_SOURCE_FILE ("code-generation.galgas", 165)) ;
    var_code.dotAssign_operation (GALGAS_string ("}\n"
      "\n")  COMMA_SOURCE_FILE ("code-generation.galgas", 166)) ;
  }
  cEnumerator_procedureMapIR enumerator_7867 (constinArgument_inIntermediateCodeStruct.mAttribute_mProcedureMapIR, kEnumeration_up) ;
  while (enumerator_7867.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_implementationCodeGeneration (enumerator_7867.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 169))  COMMA_SOURCE_FILE ("code-generation.galgas", 169)) ;
    enumerator_7867.gotoNextObject () ;
  }
  cEnumerator_functionMapIR enumerator_7987 (constinArgument_inIntermediateCodeStruct.mAttribute_mFunctionMapIR, kEnumeration_up) ;
  while (enumerator_7987.hasCurrentObject ()) {
    var_code.dotAssign_operation (categoryReader_implementationCodeGeneration (enumerator_7987.current (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 172))  COMMA_SOURCE_FILE ("code-generation.galgas", 172)) ;
    enumerator_7987.gotoNextObject () ;
  }
  var_code.dotAssign_operation (function_separatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 174))  COMMA_SOURCE_FILE ("code-generation.galgas", 174)) ;
  GALGAS_bool joker_8146 ; // Joker input parameter
  var_code.method_writeToFileWhenDifferentContents (var_sourceDirectory.add_operation (GALGAS_string ("/plm.c"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 175)), joker_8146, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 175)) ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            Filewrapper 'targetTemplates'                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

//--- File '/makefile.py'

const char * gWrapperFileContent_0_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "import subprocess, sys, os, copy\n"
  "import urllib, shutil, subprocess\n"
  "import platform, json, operator\n"
  "import threading\n"
  "\n"
  "if sys.version_info >= (2, 6) :\n"
  "  import multiprocessing\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   processorCount                                                           *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def processorCount () :\n"
  "  if sys.version_info >= (2, 6) :\n"
  "    coreCount = multiprocessing.cpu_count ()\n"
  "  else:\n"
  "    coreCount = 1\n"
  "  return coreCount\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   FOR PRINTING IN COLOR                                                    *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BLACK () :\n"
  "  return '\\033[90m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def RED () :\n"
  "  return '\\033[91m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def GREEN () :\n"
  "  return '\\033[92m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def YELLOW () :\n"
  "  return '\\033[93m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BLUE () :\n"
  "  return '\\033[94m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def MAGENTA () :\n"
  "  return '\\033[95m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def CYAN () :\n"
  "  return '\\033[96m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def WHITE () :\n"
  "  return '\\033[97m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def ENDC () :\n"
  "  return '\\033[0m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD () :\n"
  "  return '\\033[1m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def UNDERLINE () :\n"
  "  return '\\033[4m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BLINK () :\n"
  "  return '\\033[5m'\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_BLUE () :\n"
  "  return BOLD () + BLUE ()\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_GREEN () :\n"
  "  return BOLD () + GREEN ()\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_RED () :\n"
  "  return BOLD () + RED ()\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   runHiddenCommand                                                         *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def runHiddenCommand (cmd) :\n"
  "  result = \"\"\n"
  "  childProcess = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n"
  "  while True:\n"
  "    line = childProcess.stdout.readline ()\n"
  "    if line != \"\":\n"
  "      result += line\n"
  "    else:\n"
  "      childProcess.wait ()\n"
  "      if childProcess.returncode != 0 :\n"
  "        sys.exit (childProcess.returncode)\n"
  "      return result\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   runCommand                                                               *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def runCommand (cmd, title, showCommand) :\n"
  "  if title != \"\":\n"
  "    print BOLD_BLUE () + title + ENDC ()\n"
  "  if (title == \"\") or showCommand :\n"
  "    cmdAsString = \"\"\n"
  "    for s in cmd:\n"
  "      if (s == \"\") or (s.find (\" \") >= 0):\n"
  "        cmdAsString += '\"' + s + '\" '\n"
  "      else:\n"
  "        cmdAsString += s + ' '\n"
  "    print cmdAsString\n"
  "  childProcess = subprocess.Popen (cmd)\n"
  "  childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   runInThread                                                              *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def runInThread (job, displayLock, terminationSemaphore):\n"
  "  childProcess = subprocess.Popen (job.mCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n"
  "  while True:\n"
  "    line = childProcess.stdout.readline ()\n"
  "    if line != \"\":\n"
  "      job.mOutputLines.append (line)\n"
  "      displayLock.acquire ()\n"
  "      sys.stdout.write (line) # Print without newline\n"
  "      displayLock.release ()\n"
  "    else:\n"
  "      childProcess.wait ()\n"
  "      job.mReturnCode = childProcess.returncode\n"
  "      terminationSemaphore.release ()\n"
  "      break\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   modificationDateForFile                                                  *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "def modificationDateForFile (dateCacheDictionary, file):\n"
  "  absFilePath = os.path.abspath (file)\n"
  "  if dateCacheDictionary.has_key (absFilePath) :\n"
  "    return dateCacheDictionary [absFilePath]\n"
  "  elif not os.path.exists (absFilePath):\n"
  "    date = sys.float_info.max # Very far in future\n"
  "    dateCacheDictionary [absFilePath] = date\n"
  "    return date\n"
  "  else:\n"
  "    date = os.path.getmtime (absFilePath)\n"
  "    dateCacheDictionary [absFilePath] = date\n"
  "    return date\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   class PostCommand                                                        *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "class PostCommand:\n"
  "  mCommand = []\n"
  "  mTitle = \"\"\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, title = \"\"):\n"
  "    self.mCommand = []\n"
  "    self.mTitle = title\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   class Job                                                                *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "class Job:\n"
  "  mTarget = \"\"\n"
  "  mCommand = []\n"
  "  mTitle = \"\"\n"
  "  mRequiredFiles = []\n"
  "  mPostCommands = []\n"
  "  mReturnCode = None\n"
  "  mPriority = 0\n"
  "  mState = 0 # 0: waiting for execution\n"
  "  mOutputLines = []\n"
  "  mOpenSourceOnError = False # Do not try to open source file on error\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, target, requiredFiles, command, postCommands, priority, title, openSourceOnError):\n"
  "    self.mTarget = copy.deepcopy (target)\n"
  "    self.mCommand = copy.deepcopy (command)\n"
  "    self.mRequiredFiles = copy.deepcopy (requiredFiles)\n"
  "    self.mTitle = copy.deepcopy (title)\n"
  "    self.mPostCommands = copy.deepcopy (postCommands)\n"
  "    self.mPriority = priority\n"
  "    self.mOutputLines = []\n"
  "    self.mOpenSourceOnError = openSourceOnError\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def run (self, displayLock, terminationSemaphore, showCommand):\n"
  "    displayLock.acquire ()\n"
  "    if self.mTitle != \"\":\n"
  "      print BOLD_BLUE () + self.mTitle + ENDC ()\n"
  "    if (self.mTitle == \"\") or showCommand :\n"
  "      cmdAsString = \"\"\n"
  "      for s in self.mCommand:\n"
  "        if (s == \"\") or (s.find (\" \") >= 0):\n"
  "          cmdAsString += '\"' + s + '\" '\n"
  "        else:\n"
  "          cmdAsString += s + ' '\n"
  "      print cmdAsString\n"
  "    displayLock.release ()\n"
  "    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n"
  "    thread.start()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def runPostCommand (self, displayLock, terminationSemaphore, showCommand):\n"
  "    postCommand = self.mPostCommands [0]\n"
  "    self.mCommand = postCommand.mCommand\n"
  "    displayLock.acquire ()\n"
  "    print BOLD_BLUE () + postCommand.mTitle + ENDC ()\n"
  "    if showCommand:\n"
  "      cmdAsString = \"\"\n"
  "      for s in self.mCommand:\n"
  "        if (s == \"\") or (s.find (\" \") >= 0):\n"
  "          cmdAsString += '\"' + s + '\" '\n"
  "        else:\n"
  "          cmdAsString += s + ' '\n"
  "      print cmdAsString\n"
  "    displayLock.release ()\n"
  "    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n"
  "    thread.start()\n"
  "\n"
  "#----------------------------------------------------------------------------*\n"
  "#   class Rule                                                               *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "class Rule:\n"
  "  mTarget = \"\"\n"
  "  mDependences = []\n"
  "  mCommand = []\n"
  "  mSecondaryMostRecentModificationDate = 0.0 # Far in the past\n"
  "  mTitle = \"\"\n"
  "  mPostCommands = []\n"
  "  mPriority = 0\n"
  "  mDeleteTargetOnError = False # No operation on error\n"
  "  mCleanOperation = 0 # No operation on clean\n"
  "  mOpenSourceOnError = False # Do not try to open source file on error\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, target, title = \"\"):\n"
  "    self.mTarget = copy.deepcopy (target)\n"
  "    self.mDependences = []\n"
  "    self.mCommand = []\n"
  "    self.mSecondaryMostRecentModificationDate = 0.0\n"
  "    self.mPostCommands = []\n"
  "    self.mPriority = 0\n"
  "    self.mDeleteTargetOnError = False # No operation on error\n"
  "    self.mOpenSourceOnError = False # Do not try to open source file on error\n"
  "    self.mCleanOperation = 0 # No operation on clean\n"
  "    if title == \"\":\n"
  "      self.mTitle = \"Building \" + target\n"
  "    else:\n"
  "      self.mTitle = copy.deepcopy (title)\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def deleteTargetFileOnClean (self):\n"
  "    self.mCleanOperation = 1\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def deleteTargetDirectoryOnClean (self):\n"
  "    self.mCleanOperation = 2\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def enterSecondaryDependanceFile (self, secondaryDependanceFile, make):\n"
  "    if make.mSelectedGoal != \"clean\":\n"
  "      filePath = os.path.abspath (secondaryDependanceFile)\n"
  "      if not os.path.exists (filePath):\n"
  "        self.mSecondaryMostRecentModificationDate = sys.float_info.max # Very far in future\n"
  "      else:\n"
  "        f = open (filePath, \"r\")\n"
  "        s = f.read ()\n"
  "        f.close ()\n"
  "        s = s.replace (\"\\\\ \", \"\\x01\") # Replace escaped spaces by \\0x01\n"
  "        s = s.replace (\"\\\\\\n\", \"\") # Suppress \\ at the end of lines\n"
  "        liste = s.split (\"\\n\\n\")\n"
  "        for s in liste:\n"
  "          components = s.split (':')\n"
  "          target = components [0].replace (\"\\x01\", \" \")\n"
  "          #print \"------- Optional dependency rules for target '\" + target + \"'\"\n"
  "          #print \"Secondary target '\" + target + \"'\"\n"
  "          for src in components [1].split ():\n"
  "            secondarySource = src.replace (\"\\x01\", \" \")\n"
  "            #print \"  '\" + secondarySource + \"'\"\n"
  "            modifDate = modificationDateForFile (make.mModificationDateDictionary, secondarySource)\n"
  "            if self.mSecondaryMostRecentModificationDate < modifDate :\n"
  "              self.mSecondaryMostRecentModificationDate = modifDate\n"
  "              #print BOLD_BLUE () + str (modifDate) + ENDC ()\n"
  "    \n"
  "#----------------------------------------------------------------------------*\n"
  "#   class Make                                                               *\n"
  "#----------------------------------------------------------------------------*\n"
  "\n"
  "class Make:\n"
  "  mRuleList = []\n"
  "  mJobList = []\n"
  "  mErrorCount = 0\n"
  "  mModificationDateDictionary = {}\n"
  "  mGoals = {}\n"
  "  mSelectedGoal = \"\"\n"
  "  mLinuxTextEditor = \"\"\n"
  "  mMacTextEditor = \"\"\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, goal):\n"
  "    self.mRuleList = []\n"
  "    self.mJobList = []\n"
  "    self.mErrorCount = 0\n"
  "    self.mModificationDateDictionary = {}\n"
  "    self.mGoals = {}\n"
  "    self.mSelectedGoal = goal\n"
  "    self.mLinuxTextEditor = \"gEdit\"\n"
  "    self.mMacTextEditor = \"TextEdit\"\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def addRule (self, rule):\n"
  "    self.mRuleList.append (copy.deepcopy (rule))\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printRules (self):\n"
  "    print BOLD_BLUE () + \"--- Print \" + str (len (self.mRuleList)) + \" rule\" + (\"s\" if len (self.mRuleList) > 1 else \"\") + \" ---\" + ENDC ()\n"
  "    for rule in self.mRuleList:\n"
  "      print BOLD_GREEN () + \"Target: \\\"\" + rule.mTarget + \"\\\"\" + ENDC ()\n"
  "      for dep in rule.mDependences:\n"
  "        print \"  Dependence: \\\"\" + dep + \"\\\"\"\n"
  "      s = \"  Command: \"\n"
  "      for cmd in rule.mCommand:\n"
  "        s += \" \\\"\" + cmd + \"\\\"\"\n"
  "      print s\n"
  "      print \"  Title: \\\"\" + rule.mTitle + \"\\\"\"\n"
  "      index = 0\n"
  "      for (command, title) in rule.mPostCommands:\n"
  "        index = index + 1\n"
  "        s = \"  Post command \" + str (index) + \": \"\n"
  "        for cmd in command:\n"
  "          s += \" \\\"\" + cmd + \"\\\"\"\n"
  "        print s\n"
  "        print \"  Its title: \\\"\" + title + \"\\\"\"\n"
  "        \n"
  "    print BOLD_BLUE () + \"--- End of print rule ---\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def writeRuleDependancesInDotFile (self, dotFileName):\n"
  "    s = \"digraph G {\\n\"\n"
  "    s += \"  node [fontname=courier]\\n\"\n"
  "    arrowSet = set ()\n"
  "    for rule in self.mRuleList:\n"
  "      s += '  \"' + rule.mTarget + '\" [shape=rectangle]\\n'\n"
  "      for dep in rule.mDependences:\n"
  "        arrowSet.add ('  \"' + rule.mTarget + '\" -> \"' + dep + '\"\\n')\n"
  "    for arrow in arrowSet:\n"
  "      s += arrow\n"
  "    s += \"}\\n\"\n"
  "    f = open (dotFileName, \"w\")\n"
  "    f.write (s)\n"
  "    f.close ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def checkRules (self):\n"
  "    if self.mErrorCount == 0:\n"
  "      ruleList = copy.deepcopy (self.mRuleList)\n"
  "      index = 0\n"
  "      looping = True\n"
  "    #--- loop on rules\n"
  "      while looping:\n"
  "        looping = False\n"
  "        while index < len (ruleList):\n"
  "          aRule = ruleList [index]\n"
  "          index = index + 1\n"
  "        #--- Check dependance files have rule for building, or does exist\n"
  "          depIdx = 0\n"
  "          while depIdx < len (aRule.mDependences):\n"
  "            dep = aRule.mDependences [depIdx]\n"
  "            depIdx = depIdx + 1\n"
  "            hasBuildRule = False\n"
  "            for r in ruleList:\n"
  "              if dep == r.mTarget:\n"
  "                hasBuildRule = True\n"
  "                break\n"
  "            if not hasBuildRule:\n"
  "              looping = True\n"
  "              if not os.path.exists (os.path.abspath (dep)):\n"
  "                self.mErrorCount = self.mErrorCount + 1\n"
  "                print BOLD_RED () + \"Check rules error: '\" + dep + \"' does not exist, and there is no rule for building it.\" + ENDC ()\n"
  "              depIdx = depIdx - 1\n"
  "              aRule.mDependences.pop (depIdx)\n"
  "        #--- Rule with no dependances\n"
  "          if len (aRule.mDependences) == 0 :\n"
  "            looping = True\n"
  "            index = index - 1\n"
  "            ruleList.pop (index)\n"
  "            idx = 0\n"
  "            while idx < len (ruleList):\n"
  "              r = ruleList [idx]\n"
  "              idx = idx + 1\n"
  "              while r.mDependences.count (aRule.mTarget) > 0 :\n"
  "                r.mDependences.remove (aRule.mTarget)\n"
  "    #--- Error if rules remain\n"
  "      if len (ruleList) > 0:\n"
  "        self.mErrorCount = self.mErrorCount + 1\n"
  "        print BOLD_RED () + \"Check rules error; circulary dependances between:\" + ENDC ()\n"
  "        for aRule in ruleList: \n"
  "          print BOLD_RED () + \"  - '\" + aRule.mTarget + \"', depends from:\" + ENDC ()\n"
  "          for dep in aRule.mDependences:\n"
  "            print BOLD_RED () + \"      '\" + dep + \"'\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def existsJobForTarget (self, target):\n"
  "    for job in self.mJobList:\n"
  "      if job.mTarget == target:\n"
  "        return True\n"
  "    return False\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def makeJob (self, target): # Return a bool indicating wheither the target should be built\n"
  "  #--- If there are errors, return immediatly\n"
  "    if self.mErrorCount != 0:\n"
  "      return False\n"
  "  #--- Target already in job list \?\n"
  "    if self.existsJobForTarget (target):\n"
  "      return True # yes, return target will be built\n"
  "  #--- Find a rule for making the target\n"
  "    absTarget = os.path.abspath (target)\n"
  "    rule = None\n"
  "    matchCount = 0\n"
  "    for r in self.mRuleList:\n"
  "      if target == r.mTarget:\n"
  "        matchCount = matchCount + 1\n"
  "        rule = r\n"
  "    if matchCount == 0:\n"
  "      absTarget = os.path.abspath (target)\n"
  "      if not os.path.exists (absTarget):\n"
  "        print BOLD_RED () + \"No rule for making '\" + target + \"'\" + ENDC ()\n"
  "        self.mErrorCount = self.mErrorCount + 1\n"
  "      return False # Error or target exists, and no rule for building it\n"
  "    elif matchCount > 1:\n"
  "      print BOLD_RED () + str (matchCount) + \" rules for making '\" + target + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "      return False # Error\n"
  "  #--- Target file does not exist, and 'rule' variable indicates how build it\n"
  "    appendToJobList = not os.path.exists (absTarget)\n"
  "  #--- Build primary dependences\n"
  "    jobDependenceFiles = []\n"
  "    for dependence in rule.mDependences:\n"
  "      willBeBuilt = self.makeJob (dependence)\n"
  "      if willBeBuilt:\n"
  "        jobDependenceFiles.append (dependence)\n"
  "        appendToJobList = True\n"
  "  #--- Check primary file modification dates\n"
  "    if not appendToJobList:\n"
  "      targetDateModification = os.path.getmtime (absTarget)\n"
  "      for source in rule.mDependences:\n"
  "        sourceDateModification = os.path.getmtime (source)\n"
  "        if targetDateModification < sourceDateModification:\n"
  "          appendToJobList = True\n"
  "          break\n"
  "  #--- Check for secondary dependancy files\n"
  "    if not appendToJobList:\n"
  "      targetDateModification = os.path.getmtime (absTarget)\n"
  "      if targetDateModification < rule.mSecondaryMostRecentModificationDate:\n"
  "        appendToJobList = True\n"
  "  #--- Append to job list\n"
  "    if appendToJobList:\n"
  "      self.mJobList.append (Job (target, jobDependenceFiles, rule.mCommand, rule.mPostCommands, rule.mPriority, rule.mTitle, rule.mOpenSourceOnError))"
  "\n"
  "  #--- Return\n"
  "    return appendToJobList\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "  #Job state\n"
  "  # 0: waiting\n"
  "  # 1:running\n"
  "  # 2: waiting for executing post command\n"
  "  # 3:executing for executing post command\n"
  "  # 4: completed\n"
  "\n"
  "  def runJobs (self, maxConcurrentJobs, showCommand):\n"
  "    if self.mErrorCount == 0:\n"
  "      if len (self.mJobList) == 0:\n"
  "        print BOLD_BLUE () + \"Nothing to make.\" + ENDC ()\n"
  "      else:\n"
  "      #--- Sort jobs following their priorities\n"
  "        self.mJobList = sorted (self.mJobList, key=operator.attrgetter(\"mPriority\"), reverse=True)\n"
  "      #--- Run\n"
  "        if maxConcurrentJobs <= 0:\n"
  "          maxConcurrentJobs = processorCount () - maxConcurrentJobs\n"
  "        jobCount = 0 ;\n"
  "        terminationSemaphore = threading.Semaphore (0)\n"
  "        displayLock = threading.Lock ()\n"
  "        loop = True\n"
  "        returnCode = 0\n"
  "        while loop:\n"
  "        #--- Launch jobs in parallel\n"
  "          for job in self.mJobList:\n"
  "            if (returnCode == 0) and (jobCount < maxConcurrentJobs):\n"
  "              if (job.mState == 0) and (len (job.mRequiredFiles) == 0):\n"
  "                #--- Create target directory if does not exist\n"
  "                absTargetDirectory = os.path.dirname (os.path.abspath (job.mTarget))\n"
  "                if not os.path.exists (absTargetDirectory):\n"
  "                  displayLock.acquire ()\n"
  "                  runCommand ([\"mkdir\", \"-p\", os.path.dirname (job.mTarget)], \"Making \\\"\" + os.path.dirname (job.mTarget) + \"\\\" directory\", showComman"
  "d)\n"
  "                  displayLock.release ()\n"
  "                #--- Run job\n"
  "                job.run (displayLock, terminationSemaphore, showCommand)\n"
  "                jobCount = jobCount + 1\n"
  "                job.mState = 1 # Means is running\n"
  "              elif job.mState == 2: # Waiting for executing post command\n"
  "                job.mReturnCode = None # Means post command not terminated\n"
  "                job.runPostCommand (displayLock, terminationSemaphore, showCommand)\n"
  "                jobCount = jobCount + 1\n"
  "                job.mState = 3 # Means post command is running\n"
  "        #--- Wait for a job termination\n"
  "          #print \"wait \" + str (jobCount) + \" \" + str (len (self.mJobList))\n"
  "          terminationSemaphore.acquire ()\n"
  "        #--- Checks for terminated jobs\n"
  "          index = 0\n"
  "          while index < len (self.mJobList):\n"
  "            job = self.mJobList [index]\n"
  "            index = index + 1\n"
  "            if (job.mState == 1) and (job.mReturnCode == 0) : # Terminated without error\n"
  "              jobCount = jobCount - 1\n"
  "              if not os.path.exists (os.path.abspath (job.mTarget)): # Warning: target does not exist\n"
  "                displayLock.acquire ()\n"
  "                print MAGENTA () + BOLD () + \"Warning: target \\\"\" + job.mTarget + \"\\\" was not created by rule execution.\" + ENDC ()\n"
  "                displayLock.release ()\n"
  "              if len (job.mPostCommands) > 0:\n"
  "                job.mState = 2 # Ready to execute next post command\n"
  "              else:\n"
  "                job.mState = 4 # Completed\n"
  "                index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 1) and (job.mReturnCode > 0) : # terminated with error : exit\n"
  "              jobCount = jobCount - 1\n"
  "              job.mState = 4 # Means Terminated\n"
  "              index = index - 1 # For removing job from list\n"
  "              if job.mOpenSourceOnError:\n"
  "                for line in job.mOutputLines:\n"
  "                  components = line.split (':')\n"
  "                  if (len (components) > 1) and os.path.exists (os.path.abspath (components [0])) :\n"
  "                    if sys.platform == \"darwin\":\n"
  "                      os.system (\"open -a \\\"\" + self.mMacTextEditor + \"\\\" \\\"\" + components [0] + \"\\\"\")\n"
  "                    elif sys.platform == \"linux2\":\n"
  "                      os.system (\"\\\"\" + self.mLinuxTextEditor + \"\\\" \\\"\" + components [0] + \"\\\"\")\n"
  "            elif (job.mState == 3) and (job.mReturnCode == 0): # post command is terminated without error\n"
  "              jobCount = jobCount - 1\n"
  "              job.mPostCommands.pop (0) # Remove completed post command\n"
  "              if len (job.mPostCommands) > 0:\n"
  "                job.mState = 2 # Ready to execute next post command\n"
  "              else:\n"
  "                job.mState = 4 # Completed\n"
  "                index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 3) and (job.mReturnCode > 0): # post command is terminated with error\n"
  "              jobCount = jobCount - 1\n"
  "              job.mState = 4 # Completed\n"
  "              index = index - 1 # For removing job from list\n"
  "            elif job.mState == 4: # Completed: delete job\n"
  "              index = index - 1\n"
  "              self.mJobList.pop (index) # Remove terminated job\n"
  "              #displayLock.acquire ()\n"
  "              #print \"Completed '\" + job.mTitle + \"'\"\n"
  "              #--- Remove dependences from this job\n"
  "              idx = 0\n"
  "              while idx < len (self.mJobList):\n"
  "                aJob = self.mJobList [idx]\n"
  "                idx = idx + 1\n"
  "                while aJob.mRequiredFiles.count (job.mTarget) > 0 :\n"
  "                  aJob.mRequiredFiles.remove (job.mTarget)\n"
  "                  #print \"  Removed from '\" + aJob.mTitle + \"': \" + str (len (aJob.mRequiredFiles))\n"
  "              #displayLock.release ()\n"
  "              #--- Signal error \?\n"
  "              if (job.mReturnCode > 0) and (returnCode == 0):\n"
  "                self.mErrorCount = self.mErrorCount + 1\n"
  "                print BOLD_RED () + \"Return code: \" + str (job.mReturnCode) + ENDC ()\n"
  "                if (returnCode == 0) and (jobCount > 0) :\n"
  "                  print \"Wait for job termination...\"\n"
  "                returnCode = job.mReturnCode\n"
  "          loop = (len (self.mJobList) > 0) if (returnCode == 0) else (jobCount > 0)\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def searchFileInDirectories (self, file, directoryList): # returns \"\" if not found, register error\n"
  "    matchCount = 0\n"
  "    result = \"\"\n"
  "    for sourceDir in directoryList:\n"
  "      sourcePath = sourceDir + \"/\" + file\n"
  "      if os.path.exists (os.path.abspath (sourcePath)):\n"
  "        matchCount = matchCount + 1\n"
  "        result = sourcePath\n"
  "    if matchCount == 0:\n"
  "      print BOLD_RED () + \"Cannot find '\" + file + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "    elif matchCount > 1:\n"
  "      print BOLD_RED () + str (matchCount) + \" source files for making '\" + file + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "      result = \"\"\n"
  "    return result\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def addGoal (self, goal, targetList, message):\n"
  "    if self.mGoals.has_key (goal) or (goal == \"clean\") :\n"
  "      self.enterError (\"The '\" + goal + \"' goal is already defined\")\n"
  "    else:\n"
  "      self.mGoals [goal] = (targetList, message)\n"
  "    #print '%s' % ', '.join(map(str, self.mGoals))\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printGoals (self):\n"
  "    print BOLD_BLUE () + \"--- Print \" + str (len (self.mGoals)) + \" goal\" + (\"s\" if len (self.mGoals) > 1 else \"\") + \" ---\" + ENDC ()\n"
  "    for goalKey in self.mGoals.keys ():\n"
  "      print BOLD_GREEN () + \"Goal: \\\"\" + goalKey + \"\\\"\" + ENDC ()\n"
  "      (targetList, message) = self.mGoals [goalKey]\n"
  "      for target in targetList:\n"
  "        print \"  Target: \\\"\" + target + \"\\\"\"\n"
  "      print \"  Message: \\\"\" + message + \"\\\"\"\n"
  "        \n"
  "    print BOLD_BLUE () + \"--- End of print goals ---\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def runGoal (self, maxConcurrentJobs, showCommand):\n"
  "    if self.mGoals.has_key (self.mSelectedGoal) :\n"
  "      (targetList, message) = self.mGoals [self.mSelectedGoal]\n"
  "      for target in targetList:\n"
  "        self.makeJob (target)\n"
  "      self.runJobs (maxConcurrentJobs, showCommand)\n"
  "      if self.mErrorCount > 0:\n"
  "        for rule in self.mRuleList:\n"
  "          if rule.mDeleteTargetOnError and os.path.exists (os.path.abspath (rule.mTarget)):\n"
  "            runCommand ([\"rm\", rule.mTarget], \"Delete \\\"\" + rule.mTarget + \"\\\" on error\", showCommand)\n"
  "    elif self.mSelectedGoal == \"clean\" :\n"
  "      filesToRemoveList = []\n"
  "      directoriesToRemoveSet = set ()\n"
  "      for rule in self.mRuleList:\n"
  "        if rule.mCleanOperation == 1: # Delete target\n"
  "          filesToRemoveList.append (rule.mTarget)\n"
  "        elif rule.mCleanOperation == 2: # Delete target directories\n"
  "          directoriesToRemoveSet.add (os.path.dirname (rule.mTarget))\n"
  "      for dir in directoriesToRemoveSet:\n"
  "        if os.path.exists (os.path.abspath (dir)):\n"
  "          runCommand ([\"rm\", \"-fr\", dir], \"Removing \\\"\" + dir + \"\\\"\", showCommand)\n"
  "      for file in filesToRemoveList:\n"
  "        if os.path.exists (os.path.abspath (file)):\n"
  "          runCommand ([\"rm\", \"-f\", file], \"Deleting \\\"\" + file + \"\\\"\", showCommand)\n"
  "    else:\n"
  "      errorMessage = \"The '\" + self.mSelectedGoal + \"' goal is not defined; defined goals:\"\n"
  "      for key in self.mGoals:\n"
  "        (targetList, message) = self.mGoals [key]\n"
  "        errorMessage += \"\\n  '\" + key + \"': \" + message\n"
  "      print BOLD_RED () + errorMessage + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def enterError (self, message):\n"
  "    print BOLD_RED () + message + ENDC ()\n"
  "    self.mErrorCount = self.mErrorCount + 1\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printErrorCountAndExitOnError (self):\n"
  "    if self.mErrorCount == 1:\n"
  "      print BOLD_RED () + \"1 error.\" + ENDC ()\n"
  "      sys.exit (1)\n"
  "    elif self.mErrorCount > 1:\n"
  "      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n"
  "      sys.exit (1)\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printErrorCount (self):\n"
  "    if self.mErrorCount == 1:\n"
  "      print BOLD_RED () + \"1 error.\" + ENDC ()\n"
  "    elif self.mErrorCount > 1:\n"
  "      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def errorCount (self):\n"
  "    return self.mErrorCount\n"
  "\n"
  "#----------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_0_targetTemplates (
  "makefile.py",
  "py",
  true, // Text file
  28167, // Text length
  gWrapperFileContent_0_targetTemplates
) ;

//--- File 'microcontrollers/lcd.plm'

const char * gWrapperFileContent_1_targetTemplates = "\n"
  "// http://esd.cs.ucr.edu/labs/interface/interface.html\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "//   PORT CONFIGURATION                                                        *\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//   D4 : PTB0\n"
  "//   D5 : PTC0\n"
  "//   D6 : PTD1\n"
  "//   D7 : PTB2\n"
  "//   RS : PTB3\n"
  "//   E  : PTB1\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init configurePorts () {\n"
  "//--- D4 (PTB0) is a GPIO (input by default)\n"
  "  PORTB_PCR0 = (1 << 8) ;\n"
  "  GPIOB_PDDR |= (1 << 0) ; // Program D4 as output (PTB0)\n"
  "//--- D5 (PTC0) is a GPIO (input by default)\n"
  "  PORTC_PCR0 = (1 << 8) ;\n"
  "  GPIOC_PDDR |= (1 << 0) ; // Program D5 as output (PTC0)\n"
  "//--- D6 (PTD1) is a GPIO (input by default)\n"
  "  PORTD_PCR1 = (1 << 8) ;\n"
  "  GPIOD_PDDR |= (1 << 1) ; // Program D6 as output (PTD1)\n"
  "//--- D7 (PTB2) is a GPIO (input by default)\n"
  "  PORTB_PCR2 = (1 << 8) ;\n"
  "  GPIOB_PDDR |= (1 << 2) ; // Program D7 as output (PTB2)\n"
  "//--- RS (PTB3) is an output\n"
  "  PORTB_PCR3 = (1 << 8) ;\n"
  "  GPIOB_PDDR |= (1 << 3) ;\n"
  "//--- E (PTB1) is an output\n"
  "  PORTB_PCR1 = (1 << 8) ;\n"
  "  GPIOB_PDDR |= (1 << 1) ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init $exception $user driveHighE () {\n"
  "  GPIOB_PSOR = 1 << 1 ; // E is PTB1\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "\n"
  "proc $init $exception $user driveLowE () {\n"
  "  GPIOB_PCOR = 1 << 1 ; // E is PTB1\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "\n"
  "proc $init $exception $user driveHighRS () {\n"
  "  GPIOB_PSOR = 1 << 3 ; // RS is PTB3\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "\n"
  "proc $init $exception $user driveLowRS () {\n"
  "  GPIOB_PCOR = 1 << 3 ; // RS is PTB3\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init $exception $user setD4 (\?inValue : Bool) { // PTB0\n"
  "  if inValue then\n"
  "    GPIOB_PSOR = 1 << 0 ;\n"
  "  else\n"
  "    GPIOB_PCOR = 1 << 0 ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init $exception $user setD5 (\?inValue : Bool) { // PTC0\n"
  "  if inValue then\n"
  "    GPIOC_PSOR = 1 << 0 ;\n"
  "  else\n"
  "    GPIOC_PCOR = 1 << 0 ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init $exception $user setD6 (\?inValue : Bool) { // PTD1\n"
  "  if inValue then\n"
  "    GPIOD_PSOR = 1 << 1 ;\n"
  "  else\n"
  "    GPIOD_PCOR = 1 << 1 ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init $exception $user setD7 (\?inValue : Bool) { // PTB2\n"
  "  if inValue then\n"
  "    GPIOB_PSOR = 1 << 2 ;\n"
  "  else\n"
  "    GPIOB_PCOR = 1 << 2 ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "//   UTILITY ROUTINES                                                          *\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init busyWaitingDuringMS (\?inDuration : UInt32) {\n"
  "  let deadline = gCompteur + inDuration\n"
  "  while gCompteur < deadline do\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init programLcd4BitDataBusOutput (\?inValue : UInt8) {\n"
  "  setD4 (!(inValue & 0x01) != 0)\n"
  "  setD5 (!(inValue & 0x02) != 0)\n"
  "  setD6 (!(inValue & 0x04) != 0)\n"
  "  setD7 (!(inValue & 0x08) != 0)\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init write4BitCommand (\?inValue : UInt8) {\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowRS () ;\n"
  "  programLcd4BitDataBusOutput (!inValue) ;\n"
  "  driveHighE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init write8bitCommand (\?inCommand : UInt8) {\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowRS () ;\n"
  "  programLcd4BitDataBusOutput (!inCommand >> 4) ;\n"
  "  driveHighE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  programLcd4BitDataBusOutput (!inCommand) ;\n"
  "  driveHighE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $init writeData (\?inData : UInt8) {\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveHighRS () ;\n"
  "  programLcd4BitDataBusOutput (!inData >> 4) ;\n"
  "  driveHighE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  programLcd4BitDataBusOutput (!inData) ;\n"
  "  driveHighE () ;\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "//   LCD INIT                                                                  *\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "init {\n"
  "  configurePorts () ;\n"
  "//--- \xC3""\x89""tape 1 : attendre 15 ms\n"
  "  busyWaitingDuringMS (!15) ;\n"
  "//--- \xC3""\x89""tape 2 : \xC3""\xA9""crire la commande 0x30\n"
  "  write4BitCommand (!0x3) ;\n"
  "//--- \xC3""\x89""tape 3 : attendre 4,1 ms (en fait 5 ms)\n"
  "  busyWaitingDuringMS (!5) ;\n"
  "//--- \xC3""\x89""tape 4 : \xC3""\xA9""crire la commande 0x30 une 2e fois\n"
  "  write4BitCommand (!0x3) ;\n"
  "//--- \xC3""\x89""tape 5 : attendre 100 \xC2""\xB5""s\n"
  "  busyWaitingDuringMS (!1) ;\n"
  "//--- \xC3""\x89""tape 6 : \xC3""\xA9""crire la commande 0x30 une 3e fois\n"
  "  write4BitCommand (!0x3) ;\n"
  "//--- \xC3""\x89""tape 7 : \xC3""\xA9""crire la commande 0x20 pour passer en 4 bits\n"
  "  write4BitCommand (!0x2) ;\n"
  "//--- \xC3""\x89""tape 8 : \xC3""\xA9""crire la commande 'Set Interface Length' : 0 0 1 DL N F * *\n"
  "//    DL : Data interface length : 0 (4 bits)\n"
  "//    N : Number of Display lines : 1 (2 lignes)\n"
  "//    F : Character Font : 0 (5x7)\n"
  "  write8bitCommand (!0x28) ;\n"
  "//--- \xC3""\x89""tape 9 : \xC3""\xA9""crire la commande 'Display Off'\n"
  "  write8bitCommand (!0x08) ;\n"
  "//--- \xC3""\x89""tape 10 : \xC3""\xA9""crire la commande 'Clear Display'\n"
  "  write8bitCommand (!0x01) ;\n"
  "//--- \xC3""\x89""tape 11 : \xC3""\xA9""crire la commande 'Set Cursor Move Direction' : 0 0 0 0 0 1 ID S\n"
  "//    ID : Increment Cursor after Each Byte Written to Display : 1 (oui)\n"
  "//    S : Shift Display When Byte Written : 0 (non)\n"
  "  write8bitCommand (!0x06) ;\n"
  "//--- \xC3""\x89""tape 12 : \xC3""\xA9""crire la commande 'Move Cursor / Shift Display' : 0 0 0 1 SC RL * *\n"
  "//    SC : Display Shift On : 1 (oui)\n"
  "//    RL : Direction of Shift : 1 (vers la droite)\n"
  "  write8bitCommand (!0x1C) ;\n"
  "//--- \xC3""\x89""tape 13 : \xC3""\xA9""crire la commande 'Return Cursor and LCD to Home Position'\n"
  "  write8bitCommand (!0x02) ;\n"
  "//--- \xC3""\x89""tape 14 : \xC3""\xA9""crire la commande 'Enable Display / Cursor' : 0 0 0 0 1 D C B\n"
  "//    D : Turn Display On : 1 (oui)\n"
  "//    C : Turn Cursor On : 0 (non)\n"
  "//    B : Cursor Blink On : 0 (non)\n"
  "  write8bitCommand (!0x0C) ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "//   PRINT ROUTINES IN USER MODE                                               *\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user programLcd4BitDataBusOutput_inUserMode (\?inValue : UInt8) {\n"
  "  setD4 (!(inValue & 0x01) != 0)\n"
  "  setD5 (!(inValue & 0x02) != 0)\n"
  "  setD6 (!(inValue & 0x04) != 0)\n"
  "  setD7 (!(inValue & 0x08) != 0)\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user write8bitCommand_inUserMode (\?inCommand : UInt8) {\n"
  "  waitMS (!1) ;\n"
  "  driveLowRS () ;\n"
  "  programLcd4BitDataBusOutput_inUserMode (!inCommand >> 4) ;\n"
  "  driveHighE () ;\n"
  "  waitMS (!1) ;\n"
  "  driveLowE () ;\n"
  "  waitMS (!1) ;\n"
  "  programLcd4BitDataBusOutput_inUserMode (!inCommand) ;\n"
  "  driveHighE () ;\n"
  "  waitMS (!1) ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user writeData_inUserMode (\?inData : UInt8) {\n"
  "  waitMS (!1) ;\n"
  "  driveHighRS () ;\n"
  "  programLcd4BitDataBusOutput_inUserMode (!inData >> 4) ;\n"
  "  driveHighE () ;\n"
  "  waitMS (!1) ;\n"
  "  driveLowE () ;\n"
  "  waitMS (!1) ;\n"
  "  programLcd4BitDataBusOutput_inUserMode (!inData) ;\n"
  "  driveHighE () ;\n"
  "  waitMS (!1) ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "// Line 0 : 00 -> 19\n"
  "// Line 1 : 64 -> 83\n"
  "// Line 2 : 20 -> 39\n"
  "// Line 3 : 84 -> 103\n"
  "\n"
  "proc $user goto (\?line:inLine : UInt32 \?column:inColumn : UInt8) {\n"
  "  if inColumn < 20 then\n"
  "    if inLine == 0 then\n"
  "      write8bitCommand_inUserMode (!0x80 + 0 + inColumn) ;\n"
  "    elsif inLine == 1 then\n"
  "      write8bitCommand_inUserMode (!0x80 + 64 + inColumn) ;\n"
  "    elsif inLine == 2 then\n"
  "      write8bitCommand_inUserMode (!0x80 + 20 + inColumn) ;\n"
  "    elsif inLine == 3 then\n"
  "      write8bitCommand_inUserMode (!0x80 + 84 + inColumn) ;\n"
  "    end\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printString (const char * inString) {\n"
  "//  if (NULL != inString) {\n"
  "//    while ('\\0' != *inString) {\n"
  "//      writeData (*inString) ;\n"
  "//      inString ++ ;\n"
  "//    }\n"
  "//  }\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printChar (const char inChar) {\n"
  "//  writeData (inChar) ;\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user clearScreen () {\n"
  "  write8bitCommand_inUserMode (!0x01)\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user printSpaces (\?inCount : UInt32) {\n"
  "  var count = inCount\n"
  "  while (count > 0) do\n"
  "    writeData_inUserMode (!0x20)\n"
  "    count -- ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user printUnsigned (\?inValue : UInt32) {\n"
  "  if inValue > 9 then\n"
  "    printUnsigned (!inValue / 10)\n"
  "  end\n"
  "  writeData_inUserMode (!0x30 + ((inValue % 10) as UInt8))\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user printSigned (\?inValue : Int32) {\n"
  "  if inValue >= 0 then\n"
  "    printUnsigned (!inValue as UInt32)\n"
  "  else\n"
  "    writeData_inUserMode (!0x2D) // Signe -\n"
  "    printUnsigned (!(- inValue) as UInt32)\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printSigned (const int32_t inValue) {\n"
  "//  if (inValue < 0) {\n"
  "//    printChar ('-') ;\n"
  "//    printUnsigned ((uint32_t) -inValue) ;\n"
  "//  }else{\n"
  "//    printUnsigned ((uint32_t) inValue) ;\n"
  "//  }\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printHex1 (const uint32_t inValue) {\n"
  "//  const uint32_t v = inValue & 0xF ;\n"
  "//  if (v < 10) {\n"
  "//    printChar ('0' + v) ;\n"
  "//  }else{\n"
  "//    printChar ('A' + v - 10) ;\n"
  "//  }  \n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printHex2 (const uint32_t inValue) {\n"
  "//  printHex1 (inValue >> 4) ;\n"
  "//  printHex1 (inValue) ;\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printHex4 (const uint32_t inValue) {\n"
  "//  printHex2 (inValue >> 8) ;\n"
  "//  printHex2 (inValue) ;\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "\n"
  "//void printHex8 (const uint32_t inValue) {\n"
  "//  printHex4 (inValue >> 16) ;\n"
  "//  printHex4 (inValue) ;\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "//void printHex16 (const uint64_t inValue) {\n"
  "//  printHex8 ((uint32_t) (inValue >> 32)) ;\n"
  "//  printHex8 ((uint32_t) inValue) ;\n"
  "//}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "//   EXCEPTION                                                                 *\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception programLcd4BitDataBusOutput_inExceptionMode (\?inValue : UInt8) {\n"
  "  setD4 (!(inValue & 0x01) != 0)\n"
  "  setD5 (!(inValue & 0x02) != 0)\n"
  "  setD6 (!(inValue & 0x04) != 0)\n"
  "  setD7 (!(inValue & 0x08) != 0)\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception waitOneMillisecondInExceptionMode () {\n"
  "  while (SYST_CSR & SYST_CSR_COUNTFLAG) == 0 do\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception waitMSInExceptionMode (\?duration: inDuration : UInt32) {\n"
  "  var duration = inDuration\n"
  "  while duration > 0 do\n"
  "    waitOneMillisecondInExceptionMode ()\n"
  "    duration &--\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception writeDataInExceptionMode (\?inData : UInt8) {\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  driveHighRS () ;\n"
  "  programLcd4BitDataBusOutput_inExceptionMode (!inData >> 4) ;\n"
  "  driveHighE () ;\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  driveLowE () ;\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  programLcd4BitDataBusOutput_inExceptionMode (!inData) ;\n"
  "  driveHighE () ;\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception printUnsignedInExceptionMode (\?inValue : UInt32) {\n"
  "  if inValue > 9 then\n"
  "    printUnsignedInExceptionMode (!inValue &/ 10)\n"
  "  end\n"
  "  writeDataInExceptionMode (!0x30 &+ ((inValue % 10) as UInt8))\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception write8bitCommand_inExceptionMode (\?inCommand : UInt8) {\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  driveLowRS () ;\n"
  "  programLcd4BitDataBusOutput_inExceptionMode (!inCommand >> 4) ;\n"
  "  driveHighE () ;\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  driveLowE () ;\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  programLcd4BitDataBusOutput_inExceptionMode (!inCommand) ;\n"
  "  driveHighE () ;\n"
  "  waitOneMillisecondInExceptionMode () ;\n"
  "  driveLowE () ;\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception gotoInExceptionMode (\?line:inLine : UInt32 \?column:inColumn : UInt8) {\n"
  "  if inColumn < 20 then\n"
  "    if inLine == 0 then\n"
  "      write8bitCommand_inExceptionMode (!0x80 &+ 0 &+ inColumn) ;\n"
  "    elsif inLine == 1 then\n"
  "      write8bitCommand_inExceptionMode (!0x80 &+ 64 &+ inColumn) ;\n"
  "    elsif inLine == 2 then\n"
  "      write8bitCommand_inExceptionMode (!0x80 &+ 20 &+ inColumn) ;\n"
  "    elsif inLine == 3 then\n"
  "      write8bitCommand_inExceptionMode (!0x80 &+ 84 &+ inColumn) ;\n"
  "    end\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $exception clearScreenInExceptionMode () {\n"
  "  write8bitCommand_inExceptionMode (!0x01)\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "exception {\n"
  "  clearScreenInExceptionMode ()\n"
  "  waitMSInExceptionMode (!duration:4)\n"
  "  gotoInExceptionMode (!line:0 !column:0)\n"
  "  printUnsignedInExceptionMode (!CODE)\n"
  "  gotoInExceptionMode (!line:1 !column:0)\n"
  "  printUnsignedInExceptionMode (!LINE)\n"
  "  forever\n"
  "    waitMSInExceptionMode (!duration:50)\n"
  "    ledOn (!LED_L0 | LED_L1 | LED_L2 | LED_L3 | LED_L4 | LED_TEENSY)\n"
  "    waitMSInExceptionMode (!duration:50)\n"
  "    ledOff (!LED_L0 | LED_L1 | LED_L2 | LED_L3 | LED_L4 | LED_TEENSY)\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n" ;

const cRegularFileWrapper gWrapperFile_1_targetTemplates (
  "lcd.plm",
  "plm",
  true, // Text file
  14766, // Text length
  gWrapperFileContent_1_targetTemplates
) ;

//--- File 'microcontrollers/leds.plm'

const char * gWrapperFileContent_2_targetTemplates = "target \"target-teensy-sequential-systick.plms\"\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "//   Led L0 : PTA12\n"
  "//   Led L1 : PTA13\n"
  "//   Led L2 : PTD7\n"
  "//   Led L3 : PTD4\n"
  "//   Led L4 : PTD2\n"
  "//   Led sur carte Teensy : PTC5\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "init {\n"
  "//--- Led L0 : PTA12\n"
  "  PORTA_PCR12 = (1 << 8)\n"
  "  GPIOA_PDDR |= (1 << 12)\n"
  "//--- Led L1 : PTA13\n"
  "  PORTA_PCR13 = (1 << 8)\n"
  "  GPIOA_PDDR |= (1 << 13)\n"
  "//--- Led L2 : PTD13\n"
  "  PORTD_PCR7 = (1 << 8)\n"
  "  GPIOD_PDDR |= (1 << 7)\n"
  "//--- Led L3 : PTD4\n"
  "  PORTD_PCR4 = (1 << 8)\n"
  "  GPIOD_PDDR |= (1 << 4)\n"
  "//--- Led L4 : PTD2\n"
  "  PORTD_PCR2 = (1 << 8)\n"
  "  GPIOD_PDDR |= (1 << 2)\n"
  "//--- Led Teensy\n"
  "  PORTC_PCR5 = (1 << 8)\n"
  "  GPIOC_PDDR = GPIOC_PDDR | (1 << 5)\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "let LED_L0 : UInt32 = (1 << 0)\n"
  "let LED_L1 : UInt32 = (1 << 1)\n"
  "let LED_L2 : UInt32 = (1 << 2)\n"
  "let LED_L3 : UInt32 = (1 << 3)\n"
  "let LED_L4 : UInt32 = (1 << 4)\n"
  "let LED_TEENSY : UInt32 = (1 << 5)\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user $exception $isr ledOn (\?inLeds : UInt32) {\n"
  "//--- Led L0\n"
  "  if ((inLeds & LED_L0) != 0) then\n"
  "    GPIOA_PSOR = 1 << 12 ;\n"
  "  end\n"
  "//--- Led L1\n"
  "  if ((inLeds & LED_L1) != 0) then\n"
  "    GPIOA_PSOR = 1 << 13 ;\n"
  "  end\n"
  "//--- Led L2\n"
  "  if ((inLeds & LED_L2) != 0) then\n"
  "    GPIOD_PSOR = 1 << 7 ;\n"
  "  end\n"
  "//--- Led L3\n"
  "  if ((inLeds & LED_L3) != 0) then\n"
  "    GPIOD_PSOR = 1 << 4 ;\n"
  "  end\n"
  "//--- Led L4\n"
  "  if ((inLeds & LED_L4) != 0) then\n"
  "    GPIOD_PSOR = 1 << 2 ;\n"
  "  end\n"
  "//--- Led Teensy\n"
  "  if ((inLeds & LED_TEENSY) != 0) then\n"
  "    GPIOC_PSOR = 1 << 5 ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user $exception $isr ledOff (\?inLeds : UInt32) {\n"
  "//--- Led L0\n"
  "  if ((inLeds & LED_L0) != 0) then\n"
  "    GPIOA_PCOR = 1 << 12 ;\n"
  "  end\n"
  "//--- Led L1\n"
  "  if ((inLeds & LED_L1) != 0) then\n"
  "    GPIOA_PCOR = 1 << 13 ;\n"
  "  end\n"
  "//--- Led L2\n"
  "  if ((inLeds & LED_L2) != 0) then\n"
  "    GPIOD_PCOR = 1 << 7 ;\n"
  "  end\n"
  "//--- Led L3\n"
  "  if ((inLeds & LED_L3) != 0) then\n"
  "    GPIOD_PCOR = 1 << 4 ;\n"
  "  end\n"
  "//--- Led L4\n"
  "  if ((inLeds & LED_L4) != 0) then\n"
  "    GPIOD_PCOR = 1 << 2 ;\n"
  "  end\n"
  "//--- Led Teensy\n"
  "  if ((inLeds & LED_TEENSY) != 0) then\n"
  "    GPIOC_PCOR = 1 << 5 ;\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_2_targetTemplates (
  "leds.plm",
  "plm",
  true, // Text file
  2394, // Text length
  gWrapperFileContent_2_targetTemplates
) ;

//--- File 'microcontrollers/mk20dx256.plm'

const char * gWrapperFileContent_3_targetTemplates = "// Teensyduino Core Library\n"
  "// http://www.pjrc.com/teensy/\n"
  "// Copyright (c) 2013 PJRC.COM, LLC.\n"
  "//\n"
  "// Permission is hereby granted, free of charge, to any person obtaining\n"
  "// a copy of this software and associated documentation files (the\n"
  "// \"Software\"), to deal in the Software without restriction, including\n"
  "// without limitation the rights to use, copy, modify, merge, publish,\n"
  "// distribute, sublicense, and/or sell copies of the Software, and to\n"
  "// permit persons to whom the Software is furnished to do so, subject to\n"
  "// the following conditions:\n"
  "//\n"
  "// 1. The above copyright notice and this permission notice shall be \n"
  "// included in all copies or substantial portions of the Software.\n"
  "//\n"
  "// 2. If the Software is incorporated into a build system thallows \n"
  "// selection among a list of target devices, then similar target\n"
  "// devices manufactured by PJRC.COM must be included in the list of\n"
  "// target devices and selectable in the same manner.\n"
  "//\n"
  "// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
  "// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
  "// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
  "// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
  "// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
  "// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
  "// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
  "// SOFTWARE.\n"
  "\n"
  "let f_cpu : UInt32 = 96_000_000\n"
  "\n"
  "let f_bus : UInt32 = 48_000_000\n"
  "let f_mem  : UInt32= 24_000_000\n"
  "\n"
  "// chapter 11: Port control and interrupts (PORT)\n"
  "register PORTA_PCR0 : UInt32 at 0x40049000 // Pin Control Register n\n"
  "let PORT_PCR_ISF  : UInt32  = 0x01000000  // Interrupt Status Flag\n"
  "//register UInt32 PORT_PCR_IRQC(n)   (((n) & 15) << 16) // Interrupt Configuration\n"
  "let PORT_PCR_IRQC_MASK  : UInt32 = 0x000F0000\n"
  "let PORT_PCR_LK   : UInt32 = 0x00008000  // Lock Register\n"
  "//register UInt32 PORT_PCR_MUX(n)    (((n) & 7) << 8) // Pin Mux Control\n"
  "let PORT_PCR_MUX_MASK : UInt32 = 0x00000700\n"
  "let PORT_PCR_DSE      : UInt32 = 0x00000040  // Drive Strength Enable\n"
  "let PORT_PCR_ODE      : UInt32 = 0x00000020  // Open Drain Enable\n"
  "let PORT_PCR_PFE      : UInt32 = 0x00000010  // Passive Filter Enable\n"
  "let PORT_PCR_SRE      : UInt32 = 0x00000004  // Slew Rate Enable\n"
  "let PORT_PCR_PE       : UInt32 = 0x00000002  // Pull Enable\n"
  "let PORT_PCR_PS       : UInt32 = 0x00000001  // Pull Select\n"
  "\n"
  "register PORTA_PCR1   : UInt32 at 0x40049004 // Pin Control Register n\n"
  "register PORTA_PCR2   : UInt32 at 0x40049008 // Pin Control Register n\n"
  "register PORTA_PCR3   : UInt32 at 0x4004900C // Pin Control Register n\n"
  "register PORTA_PCR4   : UInt32 at 0x40049010 // Pin Control Register n\n"
  "register PORTA_PCR5   : UInt32 at 0x40049014 // Pin Control Register n\n"
  "register PORTA_PCR6   : UInt32 at 0x40049018 // Pin Control Register n\n"
  "register PORTA_PCR7   : UInt32 at 0x4004901C // Pin Control Register n\n"
  "register PORTA_PCR8   : UInt32 at 0x40049020 // Pin Control Register n\n"
  "register PORTA_PCR9   : UInt32 at 0x40049024 // Pin Control Register n\n"
  "register PORTA_PCR10  : UInt32 at 0x40049028 // Pin Control Register n\n"
  "register PORTA_PCR11  : UInt32 at 0x4004902C // Pin Control Register n\n"
  "register PORTA_PCR12  : UInt32 at 0x40049030 // Pin Control Register n\n"
  "register PORTA_PCR13  : UInt32 at 0x40049034 // Pin Control Register n\n"
  "register PORTA_PCR14  : UInt32 at 0x40049038 // Pin Control Register n\n"
  "register PORTA_PCR15  : UInt32 at 0x4004903C // Pin Control Register n\n"
  "register PORTA_PCR16  : UInt32 at 0x40049040 // Pin Control Register n\n"
  "register PORTA_PCR17  : UInt32 at 0x40049044 // Pin Control Register n\n"
  "register PORTA_PCR18  : UInt32 at 0x40049048 // Pin Control Register n\n"
  "register PORTA_PCR19  : UInt32 at 0x4004904C // Pin Control Register n\n"
  "register PORTA_PCR20  : UInt32 at 0x40049050 // Pin Control Register n\n"
  "register PORTA_PCR21  : UInt32 at 0x40049054 // Pin Control Register n\n"
  "register PORTA_PCR22  : UInt32 at 0x40049058 // Pin Control Register n\n"
  "register PORTA_PCR23  : UInt32 at 0x4004905C // Pin Control Register n\n"
  "register PORTA_PCR24  : UInt32 at 0x40049060 // Pin Control Register n\n"
  "register PORTA_PCR25  : UInt32 at 0x40049064 // Pin Control Register n\n"
  "register PORTA_PCR26  : UInt32 at 0x40049068 // Pin Control Register n\n"
  "register PORTA_PCR27  : UInt32 at 0x4004906C // Pin Control Register n\n"
  "register PORTA_PCR28  : UInt32 at 0x40049070 // Pin Control Register n\n"
  "register PORTA_PCR29  : UInt32 at 0x40049074 // Pin Control Register n\n"
  "register PORTA_PCR30  : UInt32 at 0x40049078 // Pin Control Register n\n"
  "register PORTA_PCR31  : UInt32 at 0x4004907C // Pin Control Register n\n"
  "register PORTA_GPCLR  : UInt32 at 0x40049080 // Global Pin Control Low Register\n"
  "register PORTA_GPCHR  : UInt32 at 0x40049084 // Global Pin Control High Register\n"
  "register PORTA_ISFR   : UInt32 at 0x400490A0 // Interrupt Status Flag Register\n"
  "register PORTB_PCR0   : UInt32 at 0x4004A000 // Pin Control Register n\n"
  "register PORTB_PCR1   : UInt32 at 0x4004A004 // Pin Control Register n\n"
  "register PORTB_PCR2   : UInt32 at 0x4004A008 // Pin Control Register n\n"
  "register PORTB_PCR3   : UInt32 at 0x4004A00C // Pin Control Register n\n"
  "register PORTB_PCR4   : UInt32 at 0x4004A010 // Pin Control Register n\n"
  "register PORTB_PCR5   : UInt32 at 0x4004A014 // Pin Control Register n\n"
  "register PORTB_PCR6   : UInt32 at 0x4004A018 // Pin Control Register n\n"
  "register PORTB_PCR7   : UInt32 at 0x4004A01C // Pin Control Register n\n"
  "register PORTB_PCR8   : UInt32 at 0x4004A020 // Pin Control Register n\n"
  "register PORTB_PCR9   : UInt32 at 0x4004A024 // Pin Control Register n\n"
  "register PORTB_PCR10  : UInt32 at 0x4004A028 // Pin Control Register n\n"
  "register PORTB_PCR11  : UInt32 at 0x4004A02C // Pin Control Register n\n"
  "register PORTB_PCR12  : UInt32 at 0x4004A030 // Pin Control Register n\n"
  "register PORTB_PCR13  : UInt32 at 0x4004A034 // Pin Control Register n\n"
  "register PORTB_PCR14  : UInt32 at 0x4004A038 // Pin Control Register n\n"
  "register PORTB_PCR15  : UInt32 at 0x4004A03C // Pin Control Register n\n"
  "register PORTB_PCR16  : UInt32 at 0x4004A040 // Pin Control Register n\n"
  "register PORTB_PCR17  : UInt32 at 0x4004A044 // Pin Control Register n\n"
  "register PORTB_PCR18  : UInt32 at 0x4004A048 // Pin Control Register n\n"
  "register PORTB_PCR19  : UInt32 at 0x4004A04C // Pin Control Register n\n"
  "register PORTB_PCR20  : UInt32 at 0x4004A050 // Pin Control Register n\n"
  "register PORTB_PCR21  : UInt32 at 0x4004A054 // Pin Control Register n\n"
  "register PORTB_PCR22  : UInt32 at 0x4004A058 // Pin Control Register n\n"
  "register PORTB_PCR23  : UInt32 at 0x4004A05C // Pin Control Register n\n"
  "register PORTB_PCR24  : UInt32 at 0x4004A060 // Pin Control Register n\n"
  "register PORTB_PCR25  : UInt32 at 0x4004A064 // Pin Control Register n\n"
  "register PORTB_PCR26  : UInt32 at 0x4004A068 // Pin Control Register n\n"
  "register PORTB_PCR27  : UInt32 at 0x4004A06C // Pin Control Register n\n"
  "register PORTB_PCR28  : UInt32 at 0x4004A070 // Pin Control Register n\n"
  "register PORTB_PCR29  : UInt32 at 0x4004A074 // Pin Control Register n\n"
  "register PORTB_PCR30  : UInt32 at 0x4004A078 // Pin Control Register n\n"
  "register PORTB_PCR31  : UInt32 at 0x4004A07C // Pin Control Register n\n"
  "register PORTB_GPCLR  : UInt32 at 0x4004A080 // Global Pin Control Low Register\n"
  "register PORTB_GPCHR  : UInt32 at 0x4004A084 // Global Pin Control High Register\n"
  "register PORTB_ISFR   : UInt32 at 0x4004A0A0 // Interrupt Status Flag Register\n"
  "register PORTC_PCR0   : UInt32 at 0x4004B000 // Pin Control Register n\n"
  "register PORTC_PCR1   : UInt32 at 0x4004B004 // Pin Control Register n\n"
  "register PORTC_PCR2   : UInt32 at 0x4004B008 // Pin Control Register n\n"
  "register PORTC_PCR3   : UInt32 at 0x4004B00C // Pin Control Register n\n"
  "register PORTC_PCR4   : UInt32 at 0x4004B010 // Pin Control Register n\n"
  "register PORTC_PCR5   : UInt32 at 0x4004B014 // Pin Control Register n\n"
  "register PORTC_PCR6   : UInt32 at 0x4004B018 // Pin Control Register n\n"
  "register PORTC_PCR7   : UInt32 at 0x4004B01C // Pin Control Register n\n"
  "register PORTC_PCR8   : UInt32 at 0x4004B020 // Pin Control Register n\n"
  "register PORTC_PCR9   : UInt32 at 0x4004B024 // Pin Control Register n\n"
  "register PORTC_PCR10  : UInt32 at 0x4004B028 // Pin Control Register n\n"
  "register PORTC_PCR11  : UInt32 at 0x4004B02C // Pin Control Register n\n"
  "register PORTC_PCR12  : UInt32 at 0x4004B030 // Pin Control Register n\n"
  "register PORTC_PCR13  : UInt32 at 0x4004B034 // Pin Control Register n\n"
  "register PORTC_PCR14  : UInt32 at 0x4004B038 // Pin Control Register n\n"
  "register PORTC_PCR15  : UInt32 at 0x4004B03C // Pin Control Register n\n"
  "register PORTC_PCR16  : UInt32 at 0x4004B040 // Pin Control Register n\n"
  "register PORTC_PCR17  : UInt32 at 0x4004B044 // Pin Control Register n\n"
  "register PORTC_PCR18  : UInt32 at 0x4004B048 // Pin Control Register n\n"
  "register PORTC_PCR19  : UInt32 at 0x4004B04C // Pin Control Register n\n"
  "register PORTC_PCR20  : UInt32 at 0x4004B050 // Pin Control Register n\n"
  "register PORTC_PCR21  : UInt32 at 0x4004B054 // Pin Control Register n\n"
  "register PORTC_PCR22  : UInt32 at 0x4004B058 // Pin Control Register n\n"
  "register PORTC_PCR23  : UInt32 at 0x4004B05C // Pin Control Register n\n"
  "register PORTC_PCR24  : UInt32 at 0x4004B060 // Pin Control Register n\n"
  "register PORTC_PCR25  : UInt32 at 0x4004B064 // Pin Control Register n\n"
  "register PORTC_PCR26  : UInt32 at 0x4004B068 // Pin Control Register n\n"
  "register PORTC_PCR27  : UInt32 at 0x4004B06C // Pin Control Register n\n"
  "register PORTC_PCR28  : UInt32 at 0x4004B070 // Pin Control Register n\n"
  "register PORTC_PCR29  : UInt32 at 0x4004B074 // Pin Control Register n\n"
  "register PORTC_PCR30  : UInt32 at 0x4004B078 // Pin Control Register n\n"
  "register PORTC_PCR31  : UInt32 at 0x4004B07C // Pin Control Register n\n"
  "register PORTC_GPCLR  : UInt32 at 0x4004B080 // Global Pin Control Low Register\n"
  "register PORTC_GPCHR  : UInt32 at 0x4004B084 // Global Pin Control High Register\n"
  "register PORTC_ISFR   : UInt32 at 0x4004B0A0 // Interrupt Status Flag Register\n"
  "register PORTD_PCR0   : UInt32 at 0x4004C000 // Pin Control Register n\n"
  "register PORTD_PCR1   : UInt32 at 0x4004C004 // Pin Control Register n\n"
  "register PORTD_PCR2   : UInt32 at 0x4004C008 // Pin Control Register n\n"
  "register PORTD_PCR3   : UInt32 at 0x4004C00C // Pin Control Register n\n"
  "register PORTD_PCR4   : UInt32 at 0x4004C010 // Pin Control Register n\n"
  "register PORTD_PCR5   : UInt32 at 0x4004C014 // Pin Control Register n\n"
  "register PORTD_PCR6   : UInt32 at 0x4004C018 // Pin Control Register n\n"
  "register PORTD_PCR7   : UInt32 at 0x4004C01C // Pin Control Register n\n"
  "register PORTD_PCR8   : UInt32 at 0x4004C020 // Pin Control Register n\n"
  "register PORTD_PCR9   : UInt32 at 0x4004C024 // Pin Control Register n\n"
  "register PORTD_PCR10  : UInt32 at 0x4004C028 // Pin Control Register n\n"
  "register PORTD_PCR11  : UInt32 at 0x4004C02C // Pin Control Register n\n"
  "register PORTD_PCR12  : UInt32 at 0x4004C030 // Pin Control Register n\n"
  "register PORTD_PCR13  : UInt32 at 0x4004C034 // Pin Control Register n\n"
  "register PORTD_PCR14  : UInt32 at 0x4004C038 // Pin Control Register n\n"
  "register PORTD_PCR15  : UInt32 at 0x4004C03C // Pin Control Register n\n"
  "register PORTD_PCR16  : UInt32 at 0x4004C040 // Pin Control Register n\n"
  "register PORTD_PCR17  : UInt32 at 0x4004C044 // Pin Control Register n\n"
  "register PORTD_PCR18  : UInt32 at 0x4004C048 // Pin Control Register n\n"
  "register PORTD_PCR19  : UInt32 at 0x4004C04C // Pin Control Register n\n"
  "register PORTD_PCR20  : UInt32 at 0x4004C050 // Pin Control Register n\n"
  "register PORTD_PCR21  : UInt32 at 0x4004C054 // Pin Control Register n\n"
  "register PORTD_PCR22  : UInt32 at 0x4004C058 // Pin Control Register n\n"
  "register PORTD_PCR23  : UInt32 at 0x4004C05C // Pin Control Register n\n"
  "register PORTD_PCR24  : UInt32 at 0x4004C060 // Pin Control Register n\n"
  "register PORTD_PCR25  : UInt32 at 0x4004C064 // Pin Control Register n\n"
  "register PORTD_PCR26  : UInt32 at 0x4004C068 // Pin Control Register n\n"
  "register PORTD_PCR27  : UInt32 at 0x4004C06C // Pin Control Register n\n"
  "register PORTD_PCR28  : UInt32 at 0x4004C070 // Pin Control Register n\n"
  "register PORTD_PCR29  : UInt32 at 0x4004C074 // Pin Control Register n\n"
  "register PORTD_PCR30  : UInt32 at 0x4004C078 // Pin Control Register n\n"
  "register PORTD_PCR31  : UInt32 at 0x4004C07C // Pin Control Register n\n"
  "register PORTD_GPCLR  : UInt32 at 0x4004C080 // Global Pin Control Low Register\n"
  "register PORTD_GPCHR  : UInt32 at 0x4004C084 // Global Pin Control High Register\n"
  "register PORTD_ISFR   : UInt32 at 0x4004C0A0 // Interrupt Status Flag Register\n"
  "register PORTE_PCR0   : UInt32 at 0x4004D000 // Pin Control Register n\n"
  "register PORTE_PCR1   : UInt32 at 0x4004D004 // Pin Control Register n\n"
  "register PORTE_PCR2   : UInt32 at 0x4004D008 // Pin Control Register n\n"
  "register PORTE_PCR3   : UInt32 at 0x4004D00C // Pin Control Register n\n"
  "register PORTE_PCR4   : UInt32 at 0x4004D010 // Pin Control Register n\n"
  "register PORTE_PCR5   : UInt32 at 0x4004D014 // Pin Control Register n\n"
  "register PORTE_PCR6   : UInt32 at 0x4004D018 // Pin Control Register n\n"
  "register PORTE_PCR7   : UInt32 at 0x4004D01C // Pin Control Register n\n"
  "register PORTE_PCR8   : UInt32 at 0x4004D020 // Pin Control Register n\n"
  "register PORTE_PCR9   : UInt32 at 0x4004D024 // Pin Control Register n\n"
  "register PORTE_PCR10  : UInt32 at 0x4004D028 // Pin Control Register n\n"
  "register PORTE_PCR11  : UInt32 at 0x4004D02C // Pin Control Register n\n"
  "register PORTE_PCR12  : UInt32 at 0x4004D030 // Pin Control Register n\n"
  "register PORTE_PCR13  : UInt32 at 0x4004D034 // Pin Control Register n\n"
  "register PORTE_PCR14  : UInt32 at 0x4004D038 // Pin Control Register n\n"
  "register PORTE_PCR15  : UInt32 at 0x4004D03C // Pin Control Register n\n"
  "register PORTE_PCR16  : UInt32 at 0x4004D040 // Pin Control Register n\n"
  "register PORTE_PCR17  : UInt32 at 0x4004D044 // Pin Control Register n\n"
  "register PORTE_PCR18  : UInt32 at 0x4004D048 // Pin Control Register n\n"
  "register PORTE_PCR19  : UInt32 at 0x4004D04C // Pin Control Register n\n"
  "register PORTE_PCR20  : UInt32 at 0x4004D050 // Pin Control Register n\n"
  "register PORTE_PCR21  : UInt32 at 0x4004D054 // Pin Control Register n\n"
  "register PORTE_PCR22  : UInt32 at 0x4004D058 // Pin Control Register n\n"
  "register PORTE_PCR23  : UInt32 at 0x4004D05C // Pin Control Register n\n"
  "register PORTE_PCR24  : UInt32 at 0x4004D060 // Pin Control Register n\n"
  "register PORTE_PCR25  : UInt32 at 0x4004D064 // Pin Control Register n\n"
  "register PORTE_PCR26  : UInt32 at 0x4004D068 // Pin Control Register n\n"
  "register PORTE_PCR27  : UInt32 at 0x4004D06C // Pin Control Register n\n"
  "register PORTE_PCR28  : UInt32 at 0x4004D070 // Pin Control Register n\n"
  "register PORTE_PCR29  : UInt32 at 0x4004D074 // Pin Control Register n\n"
  "register PORTE_PCR30  : UInt32 at 0x4004D078 // Pin Control Register n\n"
  "register PORTE_PCR31  : UInt32 at 0x4004D07C // Pin Control Register n\n"
  "register PORTE_GPCLR  : UInt32 at 0x4004D080 // Global Pin Control Low Register\n"
  "register PORTE_GPCHR  : UInt32 at 0x4004D084 // Global Pin Control High Register\n"
  "register PORTE_ISFR   : UInt32 at 0x4004D0A0 // Interrupt Status Flag Register\n"
  "\n"
  "// Chapter 12: System Integration Module (SIM)\n"
  "register SIM_SOPT1    : UInt32 at 0x40047000 // System Options Register 1\n"
  "register SIM_SOPT1CFG : UInt32 at 0x40047004 // SOPT1 Configuration Register\n"
  "register SIM_SOPT2    : UInt32 at 0x40048004 // System Options Register 2\n"
  "register SIM_SOPT2_USBSRC : UInt32 at 0x00040000  // 0=USB_CLKIN, 1=FFL/PLL \n"
  "register SIM_SOPT2_PLLFLLSEL : UInt32 at 0x00010000  // 0=FLL, 1=PLL\n"
  "register SIM_SOPT2_TRACECLKSEL : UInt32 at 0x00001000  // 0=MCGOUTCLK, 1=CPU\n"
  "register SIM_SOPT2_PTD7PAD : UInt32 at 0x00000800  // 0=normal, 1=double drive PTD7\n"
  "//register UInt32 SIM_SOPT2_CLKOUTSEL(n)   (((n) & 7) << 5) // Selects the clock to output on the CLKOUT pin.\n"
  "let SIM_SOPT2_RTCCLKOUTSEL : UInt32 = 0x00000010  // RTC clock out select\n"
  "register SIM_SOPT4   : UInt32 at 0x4004800C // System Options Register 4\n"
  "register SIM_SOPT5   : UInt32 at 0x40048010 // System Options Register 5\n"
  "register SIM_SOPT7   : UInt32 at 0x40048018 // System Options Register 7\n"
  "register @ro SIM_SDID  : UInt32 at 0x40048024 // System Device Identification Register\n"
  "register SIM_SCGC2  : UInt32 at 0x4004802C // System Clock Gating Control Register 2\n"
  "let SIM_SCGC2_DAC0  : UInt32 =  0x00001000  // DAC0 Clock Gate Control\n"
  "register SIM_SCGC3  : UInt32 at 0x40048030 // System Clock Gating Control Register 3\n"
  "let SIM_SCGC3_ADC1 : UInt32 =  0x08000000  // ADC1 Clock Gate Control\n"
  "let SIM_SCGC3_FTM2 : UInt32 =  0x01000000  // FTM2 Clock Gate Control\n"
  "register SIM_SCGC4 : UInt32 at 0x40048034 // System Clock Gating Control Register 4\n"
  "let SIM_SCGC4_VREF  : UInt32 =  0x00100000  // VREF Clock Gate Control\n"
  "let SIM_SCGC4_CMP   : UInt32 = 0x00080000  // Comparator Clock Gate Control\n"
  "let SIM_SCGC4_USBOTG  : UInt32 = 0x00040000  // USB Clock Gate Control\n"
  "let SIM_SCGC4_UART2  : UInt32 =  0x00001000  // UART2 Clock Gate Control\n"
  "let SIM_SCGC4_UART1  : UInt32 =  0x00000800  // UART1 Clock Gate Control\n"
  "let SIM_SCGC4_UART0  : UInt32 =  0x00000400  // UART0 Clock Gate Control\n"
  "let SIM_SCGC4_I2C1  : UInt32 =  0x00000080  // I2C1 Clock Gate Control\n"
  "let SIM_SCGC4_I2C0  : UInt32 =  0x00000040  // I2C0 Clock Gate Control\n"
  "let SIM_SCGC4_CMT  : UInt32 =  0x00000004  // CMT Clock Gate Control\n"
  "let SIM_SCGC4_EWM  : UInt32 =  0x00000002  // EWM Clock Gate Control\n"
  "register SIM_SCGC5 : UInt32 at 0x40048038 // System Clock Gating Control Register 5\n"
  "let SIM_SCGC5_PORTE  : UInt32 =  0x00002000  // Port E Clock Gate Control\n"
  "let SIM_SCGC5_PORTD  : UInt32 =  0x00001000  // Port D Clock Gate Control\n"
  "let SIM_SCGC5_PORTC  : UInt32 =  0x00000800  // Port C Clock Gate Control\n"
  "let SIM_SCGC5_PORTB  : UInt32 =  0x00000400  // Port B Clock Gate Control\n"
  "let SIM_SCGC5_PORTA  : UInt32 =  0x00000200  // Port A Clock Gate Control\n"
  "let SIM_SCGC5_TSI  : UInt32 =  0x00000020  // Touch Sense Input TSI Clock Gate Control\n"
  "let SIM_SCGC5_LPTIMER  : UInt32 =  0x00000001  // Low Power Timer Access Control\n"
  "register SIM_SCGC6 : UInt32 at 0x4004803C // System Clock Gating Control Register 6\n"
  "let SIM_SCGC6_RTC   : UInt32 = 0x20000000  // RTC Access\n"
  "let SIM_SCGC6_ADC0  : UInt32 =   0x08000000  // ADC0 Clock Gate Control\n"
  "let SIM_SCGC6_FTM1  : UInt32 =   0x02000000  // FTM1 Clock Gate Control\n"
  "let SIM_SCGC6_FTM0  : UInt32=   0x01000000  // FTM0 Clock Gate Control\n"
  "let SIM_SCGC6_PIT  : UInt32 =  0x00800000  // PIT Clock Gate Control\n"
  "let SIM_SCGC6_PDB  : UInt32 =  0x00400000  // PDB Clock Gate Control\n"
  "let SIM_SCGC6_USBDCD  : UInt32=  0x00200000  // USB DCD Clock Gate Control\n"
  "let SIM_SCGC6_CRC  : UInt32 =  0x00040000  // CRC Clock Gate Control\n"
  "let SIM_SCGC6_I2S  : UInt32 =  0x00008000  // I2S Clock Gate Control\n"
  "let SIM_SCGC6_SPI1  : UInt32=   0x00002000  // SPI1 Clock Gate Control\n"
  "let SIM_SCGC6_SPI0  : UInt32=   0x00001000  // SPI0 Clock Gate Control\n"
  "let SIM_SCGC6_FLEXCAN0  : UInt32 =  0x00000010  // FlexCAN0 Clock Gate Control\n"
  "let SIM_SCGC6_DMAMUX : UInt32 =  0x00000002  // DMA Mux Clock Gate Control\n"
  "let SIM_SCGC6_FTFL  : UInt32 =  0x00000001  // Flash Memory Clock Gate Control\n"
  "\n"
  "register SIM_SCGC7 : UInt32 at 0x40048040 // System Clock Gating Control Register 7\n"
  "let SIM_SCGC7_DMA  : UInt32 =  0x00000002  // DMA Clock Gate Control\n"
  "\n"
  "register SIM_CLKDIV1 : UInt32 at 0x40048044 // System Clock Divider Register 1\n"
  "//register UInt32 SIM_CLKDIV1_OUTDIV1(n)   (((n) & 0x0F) << 28) // divide value for the core/system clock\n"
  "let SIM_CLKDIV1_OUTDIV1_0 : UInt32 = 0 << 28\n"
  "//register UInt32 SIM_CLKDIV1_OUTDIV2(n)   (((n) & 0x0F) << 24) // divide value for the peripheral clock\n"
  "let SIM_CLKDIV1_OUTDIV2_1 : UInt32 = 1 << 24\n"
  "//register UInt32 SIM_CLKDIV1_OUTDIV4(n)   (((n) & 0x0F) << 16) // divide value for the flash clock\n"
  "let SIM_CLKDIV1_OUTDIV4_3 : UInt32 = 3 << 16\n"
  "\n"
  "register SIM_CLKDIV2 : UInt32 at 0x40048048 // System Clock Divider Register 2\n"
  "//register UInt32 SIM_CLKDIV2_USBDIV(n)   (((n) & 0x07) << 1)\n"
  "let SIM_CLKDIV2_USBFRAC  : UInt32 =  0x01\n"
  "register @ro SIM_FCFG1 : UInt32 at 0x4004804C // Flash Configuration Register 1\n"
  "register @ro SIM_FCFG2 : UInt32 at 0x40048050 // Flash Configuration Register 2\n"
  "register @ro SIM_UIDH  : UInt32 at 0x40048054 // Unique Identification Register High\n"
  "register @ro SIM_UIDMH : UInt32 at 0x40048058 // Unique Identification Register Mid-High\n"
  "register @ro SIM_UIDML : UInt32 at 0x4004805C // Unique Identification Register Mid Low\n"
  "register @ro SIM_UIDL  : UInt32 at 0x40048060 // Unique Identification Register Low\n"
  "\n"
  "// Chapter 13: Reset Control Module (RCM)\n"
  "register RCM_SRS0 : UInt8 at 0x4007F000 // System Reset Status Register 0\n"
  "register RCM_SRS1 : UInt8 at 0x4007F001 // System Reset Status Register 1\n"
  "register RCM_RPFC : UInt8 at 0x4007F004 // Reset Pin Filter Control Register\n"
  "register RCM_RPFW : UInt8 at 0x4007F005 // Reset Pin Filter Width Register\n"
  "register RCM_MR   : UInt8 at 0x4007F007 // Mode Register\n"
  "\n"
  "// Chapter 14: System Mode Controller\n"
  "register SMC_PMPROT  : UInt8 at 0x4007E000 // Power Mode Protection Register\n"
  "let SMC_PMPROT_AVLP  : UInt8 = 0x20   // Allow very low power modes\n"
  "let SMC_PMPROT_ALLS : UInt8  = 0x08   // Allow low leakage stop mode\n"
  "let SMC_PMPROT_AVLLS : UInt8 = 0x02   // Allow very low leakage stop mode\n"
  "\n"
  "register SMC_PMCTRL  : UInt8 at 0x4007E001 // Power Mode Control Register\n"
  "let SMC_PMCTRL_LPWUI : UInt8  = 0x80   // Low Power Wake Up on Interrupt\n"
  "//register UInt8 SMC_PMCTRL_RUNM(n)  (uint8_t)(((n) & 0x03) << 5) // Run Mode Control\n"
  "let SMC_PMCTRL_STOPA : UInt8  = 0x08   // Stop Aborted\n"
  "//register UInt8 SMC_PMCTRL_STOPM(n)  (uint8_t)((n) & 0x07)  // Stop Mode Control\n"
  "\n"
  "register SMC_VLLSCTRL : UInt8 at 0x4007E002 // VLLS Control Register\n"
  "let SMC_VLLSCTRL_PORPO : UInt8 = 0x20   // POR Power Option\n"
  "//let UInt8 SMC_VLLSCTRL_VLLSM(n)  (uint8_t)((n) & 0x07)  // VLLS Mode Control\n"
  "\n"
  "register SMC_PMST : UInt8 at 0x4007E003 // Power Mode Status Register\n"
  "let SMC_PMSTAT_RUN  : UInt8 = 0x01   // Current power mode is RUN\n"
  "let SMC_PMSTAT_STOP : UInt8 = 0x02   // Current power mode is STOP\n"
  "let SMC_PMSTAT_VLPR : UInt8 = 0x04   // Current power mode is VLPR\n"
  "let SMC_PMSTAT_VLPW : UInt8 = 0x08   // Current power mode is VLPW\n"
  "let SMC_PMSTAT_VLPS : UInt8 = 0x10   // Current power mode is VLPS\n"
  "let SMC_PMSTAT_LLS  : UInt8 = 0x20   // Current power mode is LLS\n"
  "let SMC_PMSTAT_VLLS : UInt8 = 0x40   // Current power mode is VLLS\n"
  "\n"
  "// Chapter 15: Power Management Controller\n"
  "register PMC_LVDSC1 : UInt8 at 0x4007D000 // Low Voltage Detect Status And Control 1 register\n"
  "let PMC_LVDSC1_LVDF : UInt8 = 0x80   // Low-Voltage Detect Flag\n"
  "let PMC_LVDSC1_LVDACK : UInt8 = 0x40   // Low-Voltage Detect Acknowledge\n"
  "let PMC_LVDSC1_LVDIE : UInt8 = 0x20   // Low-Voltage Detect Interrupt Enable\n"
  "let PMC_LVDSC1_LVDRE : UInt8 = 0x10   // Low-Voltage Detect Reset Enable\n"
  "//let UInt8 PMC_LVDSC1_LVDV(n)  (uint8_t)((n) & 0x03)  // Low-Voltage Detect Voltage Select\n"
  "register PMC_LVDSC2 : UInt8 at 0x4007D001 // Low Voltage Detect Status And Control 2 register\n"
  "let PMC_LVDSC2_LVWF : UInt8  = 0x80   // Low-Voltage Warning Flag\n"
  "let PMC_LVDSC2_LVWACK : UInt8 = 0x40   // Low-Voltage Warning Acknowledge\n"
  "let PMC_LVDSC2_LVWIE : UInt8 = 0x20   // Low-Voltage Warning Interrupt Enable\n"
  "//let UInt8 PMC_LVDSC2_LVWV(n)  (uint8_t)((n) & 0x03)  // Low-Voltage Warning Voltage Select\n"
  "register PMC_REGSC : UInt8 at 0x4007D002 // Regulator Status And Control register\n"
  "let PMC_REGSC_BGEN  : UInt8 = 0x10   // Bandgap Enable In VLPx Operation\n"
  "let PMC_REGSC_ACKISO : UInt8 = 0x08   // Acknowledge Isolation\n"
  "let PMC_REGSC_REGONS : UInt8 = 0x04   // Regulator In Run Regulation Status\n"
  "let PMC_REGSC_BGBE  : UInt8 = 0x01   // Bandgap Buffer Enable\n"
  "\n"
  "// Chapter 16: Low-Leakage Wakeup Unit (LLWU)\n"
  "register LLWU_PE1  : UInt8 at 0x4007C000 // LLWU Pin Enable 1 register\n"
  "register LLWU_PE2  : UInt8 at 0x4007C001 // LLWU Pin Enable 2 register\n"
  "register LLWU_PE3  : UInt8 at 0x4007C002 // LLWU Pin Enable 3 register\n"
  "register LLWU_PE4  : UInt8 at 0x4007C003 // LLWU Pin Enable 4 register\n"
  "register LLWU_ME   : UInt8 at 0x4007C004 // LLWU Module Enable register\n"
  "register LLWU_F1   : UInt8 at 0x4007C005 // LLWU Flag 1 register\n"
  "register LLWU_F2   : UInt8 at 0x4007C006 // LLWU Flag 2 register\n"
  "register LLWU_F3   : UInt8 at 0x4007C007 // LLWU Flag 3 register\n"
  "register LLWU_FILT1: UInt8 at 0x4007C008 // LLWU Pin Filter 1 register\n"
  "register LLWU_FILT2: UInt8 at 0x4007C009 // LLWU Pin Filter 2 register\n"
  "register LLWU_RST  : UInt8 at 0x4007C00A // LLWU Reset Enable register\n"
  "\n"
  "// Chapter 17: Miscellaneous Control Module (MCM)\n"
  "register MCM_PLASC : UInt16 at 0xE0080008 // Crossbar Switch (AXBS) Slave Configuration\n"
  "\n"
  "register MCM_PLAMC : UInt16 at 0xE008000A // Crossbar Switch (AXBS) Master Configuration\n"
  "\n"
  "register MCM_PLACR : UInt32 at 0xE008000C // Crossbar Switch (AXBS) Control Register (MK20DX128)\n"
  "let MCM_PLACR_ARG   : UInt32 = 0x00000200  // Arbitration select, 0=fixed, 1=round-robin\n"
  "\n"
  "register MCM_CR : UInt32 at 0xE008000C // RAM arbitration control register (MK20DX256)\n"
  "let MCM_CR_SRAMLWP  : UInt32 =  0x4000_0000  // SRAM_L write protect\n"
  "//let UInt32 MCM_CR_SRAMLAP(n)   (((n) & 0x03) << 28) // SRAM_L priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA\n"
  "let MCM_CR_SRAMUWP  : UInt32 =  0x0400_0000  // SRAM_U write protect\n"
  "//let UInt32 MCM_CR_SRAMUAP(n)   (((n) & 0x03) << 24) // SRAM_U priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA\n"
  "\n"
  "// Crossbar Switch (AXBS) - only programmable on MK20DX256\n"
  "register AXBS_PRS0   : UInt32 at 0x40004000 // Priority Registers Slave 0\n"
  "register AXBS_CRS0   : UInt32 at 0x40004010 // Control Register 0\n"
  "register AXBS_PRS1   : UInt32 at 0x40004100 // Priority Registers Slave 1\n"
  "register AXBS_CRS1   : UInt32 at 0x40004110 // Control Register 1\n"
  "register AXBS_PRS2   : UInt32 at 0x40004200 // Priority Registers Slave 2\n"
  "register AXBS_CRS2   : UInt32 at 0x40004210 // Control Register 2\n"
  "register AXBS_PRS3   : UInt32 at 0x40004300 // Priority Registers Slave 3\n"
  "register AXBS_CRS3   : UInt32 at 0x40004310 // Control Register 3\n"
  "register AXBS_PRS4   : UInt32 at 0x40004400 // Priority Registers Slave 4\n"
  "register AXBS_CRS4   : UInt32 at 0x40004410 // Control Register 4\n"
  "register AXBS_PRS5   : UInt32 at 0x40004500 // Priority Registers Slave 5\n"
  "register AXBS_CRS5   : UInt32 at 0x40004510 // Control Register 5\n"
  "register AXBS_PRS6   : UInt32 at 0x40004600 // Priority Registers Slave 6\n"
  "register AXBS_CRS6   : UInt32 at 0x40004610 // Control Register 6\n"
  "register AXBS_PRS7   : UInt32 at 0x40004700 // Priority Registers Slave 7\n"
  "register AXBS_CRS7   : UInt32 at 0x40004710 // Control Register 7\n"
  "register AXBS_MGPCR0 : UInt32 at 0x40004800 // Master 0 General Purpose Control Register\n"
  "register AXBS_MGPCR1 : UInt32 at 0x40004900 // Master 1 General Purpose Control Register\n"
  "register AXBS_MGPCR2 : UInt32 at 0x40004A00 // Master 2 General Purpose Control Register\n"
  "register AXBS_MGPCR3 : UInt32 at 0x40004B00 // Master 3 General Purpose Control Register\n"
  "register AXBS_MGPCR4 : UInt32 at 0x40004C00 // Master 4 General Purpose Control Register\n"
  "register AXBS_MGPCR5 : UInt32 at 0x40004D00 // Master 5 General Purpose Control Register\n"
  "register AXBS_MGPCR6 : UInt32 at 0x40004E00 // Master 6 General Purpose Control Register\n"
  "register AXBS_MGPCR7 : UInt32 at 0x40004F00 // Master 7 General Purpose Control Register\n"
  "let AXBS_CRS_READONLY  : UInt32=  0x80000000\n"
  "let AXBS_CRS_HALTLOWPRIORITY  : UInt32 = 0x40000000\n"
  "let AXBS_CRS_ARB_FIXED  : UInt32 = 0x00000000\n"
  "let AXBS_CRS_ARB_ROUNDROBIN  : UInt32 = 0x00010000\n"
  "let AXBS_CRS_PARK_FIXED  : UInt32 =  0x00000000\n"
  "let AXBS_CRS_PARK_PREVIOUS  : UInt32 =  0x00000010\n"
  "let AXBS_CRS_PARK_NONE  : UInt32 =  0x00000020\n"
  "//let UInt32 AXBS_CRS_PARK(n)   (((n) & 7) << 0)\n"
  "\n"
  "\n"
  "\n"
  "// Chapter 20: Direct Memory Access Multiplexer (DMAMUX)\n"
  "register DMAMUX0_CHCFG0  : UInt8 at 0x40021000 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG1  : UInt8 at 0x40021001 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG2  : UInt8 at 0x40021002 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG3  : UInt8 at 0x40021003 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG4  : UInt8 at 0x40021004 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG5  : UInt8 at 0x40021005 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG6  : UInt8 at 0x40021006 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG7  : UInt8 at 0x40021007 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG8  : UInt8 at 0x40021008 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG9  : UInt8 at 0x40021009 // Channel Configuration register\n"
  "register DMAMUX0_CHCFG10 : UInt8 at 0x4002100A // Channel Configuration register\n"
  "register DMAMUX0_CHCFG11 : UInt8 at 0x4002100B // Channel Configuration register\n"
  "register DMAMUX0_CHCFG12 : UInt8 at 0x4002100C // Channel Configuration register\n"
  "register DMAMUX0_CHCFG13 : UInt8 at 0x4002100D // Channel Configuration register\n"
  "register DMAMUX0_CHCFG14 : UInt8 at 0x4002100E // Channel Configuration register\n"
  "register DMAMUX0_CHCFG15 : UInt8 at 0x4002100F // Channel Configuration register\n"
  "let DMAMUX_DISABLE : UInt8 =  0\n"
  "let DMAMUX_TRIG  : UInt8 = 64\n"
  "let DMAMUX_ENABLE : UInt8 =  128\n"
  "let DMAMUX_SOURCE_UART0_RX : UInt8 = 2\n"
  "let DMAMUX_SOURCE_UART0_TX : UInt8 = 3\n"
  "let DMAMUX_SOURCE_UART1_RX : UInt8 = 4\n"
  "let DMAMUX_SOURCE_UART1_TX : UInt8 = 5\n"
  "let DMAMUX_SOURCE_UART2_RX : UInt8 = 6\n"
  "let DMAMUX_SOURCE_UART2_TX : UInt8 = 7\n"
  "let DMAMUX_SOURCE_I2S0_RX  : UInt8 =14\n"
  "let DMAMUX_SOURCE_I2S0_TX  : UInt8 =15\n"
  "let DMAMUX_SOURCE_SPI0_RX  : UInt8 =16\n"
  "let DMAMUX_SOURCE_SPI0_TX  : UInt8 =17\n"
  "let DMAMUX_SOURCE_I2C0  : UInt8 =22\n"
  "let DMAMUX_SOURCE_I2C1  : UInt8 =23\n"
  "let DMAMUX_SOURCE_FTM0_CH0 : UInt8 = 24\n"
  "let DMAMUX_SOURCE_FTM0_CH1 : UInt8 = 25\n"
  "let DMAMUX_SOURCE_FTM0_CH2 : UInt8 = 26\n"
  "let DMAMUX_SOURCE_FTM0_CH3 : UInt8 = 27\n"
  "let DMAMUX_SOURCE_FTM0_CH4 : UInt8 = 28\n"
  "let DMAMUX_SOURCE_FTM0_CH5 : UInt8 = 29\n"
  "let DMAMUX_SOURCE_FTM0_CH6 : UInt8 = 30\n"
  "let DMAMUX_SOURCE_FTM0_CH7 : UInt8 = 31\n"
  "let DMAMUX_SOURCE_FTM1_CH0 : UInt8 = 32\n"
  "let DMAMUX_SOURCE_FTM1_CH1 : UInt8 = 33\n"
  "let DMAMUX_SOURCE_FTM2_CH0 : UInt8 = 34\n"
  "let DMAMUX_SOURCE_FTM2_CH1 : UInt8 = 35\n"
  "let DMAMUX_SOURCE_ADC0 : UInt8 = 40\n"
  "let DMAMUX_SOURCE_ADC1 : UInt8 = 41\n"
  "let DMAMUX_SOURCE_CMP0 : UInt8 = 42\n"
  "let DMAMUX_SOURCE_CMP1 : UInt8 = 43\n"
  "let DMAMUX_SOURCE_CMP2 : UInt8 = 44\n"
  "let DMAMUX_SOURCE_DAC0 : UInt8 = 45\n"
  "let DMAMUX_SOURCE_CMT  : UInt8 = 47\n"
  "let DMAMUX_SOURCE_PDB  : UInt8 = 48\n"
  "let DMAMUX_SOURCE_PORTA : UInt8 = 49\n"
  "let DMAMUX_SOURCE_PORTB : UInt8 = 50\n"
  "let DMAMUX_SOURCE_PORTC : UInt8 = 51\n"
  "let DMAMUX_SOURCE_PORTD : UInt8 = 52\n"
  "let DMAMUX_SOURCE_PORTE : UInt8 = 53\n"
  "let DMAMUX_SOURCE_ALWAYS0 : UInt8 = 54\n"
  "let DMAMUX_SOURCE_ALWAYS1 : UInt8 = 55\n"
  "let DMAMUX_SOURCE_ALWAYS2 : UInt8 = 56\n"
  "let DMAMUX_SOURCE_ALWAYS3 : UInt8 = 57\n"
  "let DMAMUX_SOURCE_ALWAYS4 : UInt8 = 58\n"
  "let DMAMUX_SOURCE_ALWAYS5 : UInt8 = 59\n"
  "let DMAMUX_SOURCE_ALWAYS6 : UInt8 = 60\n"
  "let DMAMUX_SOURCE_ALWAYS7 : UInt8 = 61\n"
  "let DMAMUX_SOURCE_ALWAYS8 : UInt8 = 62\n"
  "let DMAMUX_SOURCE_ALWAYS9 : UInt8 = 63\n"
  "\n"
  "// Chapter 21: Direct Memory Access Controller (eDMA)\n"
  "register DMA_CR : UInt32 at 0x40008000 // Control Register\n"
  "let DMA_CR_CX   : UInt32  = 0x2_0000 // Cancel Transfer\n"
  "let DMA_CR_ECX   : UInt32 = 0x1_0000 // Error Cancel Transfer\n"
  "let DMA_CR_EMLM   : UInt32= 0x80 // Enable Minor Loop Mapping\n"
  "let DMA_CR_CLM   : UInt32 = 0x40 // Continuous Link Mode\n"
  "let DMA_CR_HALT  : UInt32 = 0x20 // Halt DMA Operations\n"
  "let DMA_CR_HOE   : UInt32 = 0x10 // Halt On Error\n"
  "let DMA_CR_ERCA  : UInt32 = 0x04 // Enable Round Robin Channel Arbitration\n"
  "let DMA_CR_EDBG   : UInt32= 0x02 // Enable Debug\n"
  "register DMA_ES  : UInt32 at 0x40008004 // Error Status Register\n"
  "register DMA_ERQ : UInt32 at 0x4000800C // Enable Request Register\n"
  "let DMA_ERQ_ERQ0   : UInt32 = 1 // Enable DMA Request 0\n"
  "let DMA_ERQ_ERQ1   : UInt32 = 2 // Enable DMA Request 1\n"
  "let DMA_ERQ_ERQ2   : UInt32 = 4 // Enable DMA Request 2\n"
  "let DMA_ERQ_ERQ3   : UInt32 = 8 // Enable DMA Request 3\n"
  "register DMA_EEI : UInt32 at 0x40008014 // Enable Error Interrupt Register\n"
  "let DMA_EEI_EEI0   : UInt32 = 1 // Enable Error Interrupt 0\n"
  "let DMA_EEI_EEI1   : UInt32 = 2 // Enable Error Interrupt 1\n"
  "let DMA_EEI_EEI2   : UInt32 = 4 // Enable Error Interrupt 2\n"
  "let DMA_EEI_EEI3   : UInt32 = 8 // Enable Error Interrupt 3\n"
  "//register UInt8 DMA_CEEI  *(volatile uint8_t  *)0x40008018 // Clear Enable Error Interrupt Register\n"
  "//register UInt32 DMA_CEEI_CEEI(n)  ((uint8_t)(n & 3)<<0) // Clear Enable Error Interrupt\n"
  "//register UInt32 DMA_CEEI_CAEE   ((uint8_t)1<<6)  // Clear All Enable Error Interrupts\n"
  "//register UInt32 DMA_CEEI_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_SEEI  *(volatile uint8_t  *)0x40008019 // Set Enable Error Interrupt Register\n"
  "//register UInt32 DMA_SEEI_SEEI(n)  ((uint8_t)(n & 3)<<0) // Set Enable Error Interrupt\n"
  "//register UInt32 DMA_SEEI_SAEE   ((uint8_t)1<<6)  // Set All Enable Error Interrupts\n"
  "//register UInt32 DMA_SEEI_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_CERQ  *(volatile uint8_t  *)0x4000801A // Clear Enable Request Register\n"
  "//register UInt32 DMA_CERQ_CERQ(n)  ((uint8_t)(n & 3)<<0) // Clear Enable Request\n"
  "//register UInt32 DMA_CERQ_CAER   ((uint8_t)1<<6)  // Clear All Enable Requests\n"
  "//register UInt32 DMA_CERQ_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_SERQ  *(volatile uint8_t  *)0x4000801B // Set Enable Request Register\n"
  "//register UInt32 DMA_SERQ_SERQ(n)  ((uint8_t)(n & 3)<<0) // Set Enable Request\n"
  "//register UInt32 DMA_SERQ_SAER   ((uint8_t)1<<6)  // Set All Enable Requests\n"
  "//register UInt32 DMA_SERQ_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_CDNE  *(volatile uint8_t  *)0x4000801C // Clear DONE Status Bit Register\n"
  "//register UInt32 DMA_CDNE_CDNE(n)  ((uint8_t)(n & 3)<<0) // Clear Done Bit\n"
  "//register UInt32 DMA_CDNE_CADN   ((uint8_t)1<<6)  // Clear All Done Bits\n"
  "//register UInt32 DMA_CDNE_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_SSRT  *(volatile uint8_t  *)0x4000801D // Set START Bit Register\n"
  "//register UInt32 DMA_SSRT_SSRT(n)  ((uint8_t)(n & 3)<<0) // Set Start Bit\n"
  "//register UInt32 DMA_SSRT_SAST   ((uint8_t)1<<6)  // Set All Start Bits\n"
  "//register UInt32 DMA_SSRT_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_CERR  *(volatile uint8_t  *)0x4000801E // Clear Error Register\n"
  "//register UInt32 DMA_CERR_CERR(n)  ((uint8_t)(n & 3)<<0) // Clear Error Indicator\n"
  "//register UInt32 DMA_CERR_CAEI   ((uint8_t)1<<6)  // Clear All Error Indicators\n"
  "//register UInt32 DMA_CERR_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_CINT  *(volatile uint8_t  *)0x4000801F // Clear Interrupt Request Register\n"
  "//register UInt32 DMA_CINT_CINT(n)  ((uint8_t)(n & 3)<<0) // Clear Interrupt Request\n"
  "//register UInt32 DMA_CINT_CAIR   ((uint8_t)1<<6)  // Clear All Interrupt Requests\n"
  "//register UInt32 DMA_CINT_NOP   ((uint8_t)1<<7)  // NOP\n"
  "//register UInt32 DMA_INT    0x40008024 // Interrupt Request Register\n"
  "//register UInt32 DMA_INT_INT0   ( 1<<0) // Interrupt Request 0\n"
  "//register UInt32 DMA_INT_INT1   ( 1<<1) // Interrupt Request 1\n"
  "//register UInt32 DMA_INT_INT2   ( 1<<2) // Interrupt Request 2\n"
  "//register UInt32 DMA_INT_INT3   ( 1<<3) // Interrupt Request 3\n"
  "//register UInt32 DMA_ERR    0x4000802C // Error Register\n"
  "//register UInt32 DMA_ERR_ERR0   ( 1<<0) // Error in Channel 0\n"
  "//register UInt32 DMA_ERR_ERR1   ( 1<<1) // Error in Channel 1\n"
  "//register UInt32 DMA_ERR_ERR2   ( 1<<2) // Error in Channel 2\n"
  "//register UInt32 DMA_ERR_ERR3   ( 1<<3) // Error in Channel 3\n"
  "//register UInt32 DMA_HRS    0x40008034 // Hardware Request Status Register\n"
  "//register UInt32 DMA_HRS_HRS0   ( 1<<0) // Hardware Request Status Channel 0\n"
  "//register UInt32 DMA_HRS_HRS1   ( 1<<1) // Hardware Request Status Channel 1\n"
  "//register UInt32 DMA_HRS_HRS2   ( 1<<2) // Hardware Request Status Channel 2\n"
  "//register UInt32 DMA_HRS_HRS3   ( 1<<3) // Hardware Request Status Channel 3\n"
  "//register UInt32 DMA_DCHPRI3  *(volatile uint8_t  *)0x40008100 // Channel n Priority Register\n"
  "//register UInt32 DMA_DCHPRI2  *(volatile uint8_t  *)0x40008101 // Channel n Priority Register\n"
  "//register UInt32 DMA_DCHPRI1  *(volatile uint8_t  *)0x40008102 // Channel n Priority Register\n"
  "//register UInt32 DMA_DCHPRI0  *(volatile uint8_t  *)0x40008103 // Channel n Priority Register\n"
  "//register UInt32 DMA_DCHPRI_CHPRI(n)  ((uint8_t)(n & 3)<<0) // Channel Arbitration Priority\n"
  "//register UInt32 DMA_DCHPRI_DPA   ((uint8_t)1<<6)  // Disable PreEmpt Ability\n"
  "//register UInt32 DMA_DCHPRI_ECP   ((uint8_t)1<<7)  // Enable PreEmption\n"
  "//\n"
  "//\n"
  "//register DMA_TCD_ATTR_SMOD(n)  (((n) & 0x1F) << 11)\n"
  "//register DMA_TCD_ATTR_SSIZE(n)  (((n) & 0x7) << 8)\n"
  "//register DMA_TCD_ATTR_DMOD(n)  (((n) & 0x1F) << 3)\n"
  "//register DMA_TCD_ATTR_DSIZE(n)  (((n) & 0x7) << 0)\n"
  "//register DMA_TCD_ATTR_SIZE_8BIT  0\n"
  "//register DMA_TCD_ATTR_SIZE_16BIT  1\n"
  "//register DMA_TCD_ATTR_SIZE_32BIT  2\n"
  "//register DMA_TCD_ATTR_SIZE_16BYTE 4\n"
  "//register DMA_TCD_ATTR_SIZE_32BYTE 5\n"
  "//register DMA_TCD_CSR_BWC(n)  (((n) & 0x3) << 14)\n"
  "//register DMA_TCD_CSR_MAJORLINKCH(n) (((n) & 0x3) << 8)\n"
  "//register DMA_TCD_CSR_DONE  0x0080\n"
  "//register DMA_TCD_CSR_ACTIVE  0x0040\n"
  "//register DMA_TCD_CSR_MAJORELINK  0x0020\n"
  "//register DMA_TCD_CSR_ESG   0x0010\n"
  "//register DMA_TCD_CSR_DREQ  0x0008\n"
  "//register DMA_TCD_CSR_INTHALF  0x0004\n"
  "//register DMA_TCD_CSR_INTMAJOR  0x0002\n"
  "//register DMA_TCD_CSR_START  0x0001\n"
  "//register DMA_TCD_CITER_MASK      ((uint16_t)0x7FFF)    // Loop count mask\n"
  "//register DMA_TCD_CITER_ELINK      ((uint16_t)1<<15)    // Enable channel linking on minor-loop complete\n"
  "//register DMA_TCD_BITER_MASK      ((uint16_t)0x7FFF)    // Loop count mask\n"
  "//register DMA_TCD_BITER_ELINK      ((uint16_t)1<<15)    // Enable channel linking on minor-loop complete\n"
  "//register DMA_TCD_NBYTES_SMLOE      ( 1<<31)      // Source Minor Loop Offset Enable\n"
  "//register DMA_TCD_NBYTES_DMLOE      ( 1<<30)      // Destination Minor Loop Offset Enable\n"
  "//register DMA_TCD_NBYTES_MLOFFNO_NBYTES(n)    ( (n))      // NBytes transfer count when minor loop disabled\n"
  "//register DMA_TCD_NBYTES_MLOFFYES_NBYTES(n)   ( (n & 0x1F))     // NBytes transfer count when minor loop enabled\n"
  "//register DMA_TCD_NBYTES_MLOFFYES_MLOFF(n)    ( (n & 0xFFFFF)<<10)   // Offset \n"
  "//\n"
  "//register DMA_TCD0_SADDR  *(volatile const void * volatile *)0x40009000 // TCD Source Address\n"
  "//register DMA_TCD0_SOFF  *(volatile int16_t *)0x40009004  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD0_ATTR  *(volatile uint16_t *)0x40009006 // TCD Transfer Attributes\n"
  "//register DMA_TCD0_NBYTES_MLNO  0x40009008 // TCD Minor Byte Count (Minor Loop Disabled)\n"
  "//register DMA_TCD0_NBYTES_MLOFFNO  0x40009008 // TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)\n"
  "//register DMA_TCD0_NBYTES_MLOFFYES  0x40009008 // TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)\n"
  "//register DMA_TCD0_SLAST  *(volatile int32_t *)0x4000900C  // TCD Last Source Address Adjustment\n"
  "//register DMA_TCD0_DADDR  *(volatile void * volatile *)0x40009010 // TCD Destination Address\n"
  "//register DMA_TCD0_DOFF  *(volatile int16_t *)0x40009014  // TCD Signed Destination Address Offset\n"
  "//register DMA_TCD0_CITER_ELINKYES *(volatile uint16_t *)0x40009016 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "//register DMA_TCD0_CITER_ELINKNO *(volatile uint16_t *)0x40009016 // \?\?\n"
  "//register DMA_TCD0_DLASTSGA *(volatile int32_t *)0x40009018  // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "//register DMA_TCD0_CSR  *(volatile uint16_t *)0x4000901C // TCD Control and Status\n"
  "//register DMA_TCD0_BITER_ELINKYES *(volatile uint16_t *)0x4000901E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "//register DMA_TCD0_BITER_ELINKNO *(volatile uint16_t *)0x4000901E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Disabled\n"
  "//\n"
  "//register DMA_TCD1_SADDR  *(volatile const void * volatile *)0x40009020 // TCD Source Address\n"
  "//register DMA_TCD1_SOFF  *(volatile int16_t *)0x40009024  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD1_ATTR  *(volatile uint16_t *)0x40009026 // TCD Transfer Attributes\n"
  "//register DMA_TCD1_NBYTES_MLNO  0x40009028 // TCD Minor Byte Count, Minor Loop Disabled\n"
  "//register DMA_TCD1_NBYTES_MLOFFNO  0x40009028 // TCD Signed Minor Loop Offset, Minor Loop Enabled and Offset Disabled\n"
  "//register DMA_TCD1_NBYTES_MLOFFYES  0x40009028 // TCD Signed Minor Loop Offset, Minor Loop and Offset Enabled\n"
  "//register DMA_TCD1_SLAST  *(volatile int32_t *)0x4000902C  // TCD Last Source Address Adjustment\n"
  "//register DMA_TCD1_DADDR  *(volatile void * volatile *)0x40009030 // TCD Destination Address\n"
  "//register DMA_TCD1_DOFF  *(volatile int16_t *)0x40009034  // TCD Signed Destination Address Offset\n"
  "//register DMA_TCD1_CITER_ELINKYES *(volatile uint16_t *)0x40009036 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "//register DMA_TCD1_CITER_ELINKNO *(volatile uint16_t *)0x40009036 // \?\?\n"
  "//register DMA_TCD1_DLASTSGA *(volatile int32_t *)0x40009038  // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "//register DMA_TCD1_CSR  *(volatile uint16_t *)0x4000903C // TCD Control and Status\n"
  "//register DMA_TCD1_BITER_ELINKYES *(volatile uint16_t *)0x4000903E // TCD Beginning Minor Loop Link, Major Loop Count Channel Linking Enabled\n"
  "//register DMA_TCD1_BITER_ELINKNO *(volatile uint16_t *)0x4000903E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Disabled\n"
  "//\n"
  "//register DMA_TCD2_SADDR  *(volatile const void * volatile *)0x40009040 // TCD Source Address\n"
  "//register DMA_TCD2_SOFF  *(volatile int16_t *)0x40009044  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD2_ATTR  *(volatile uint16_t *)0x40009046 // TCD Transfer Attributes\n"
  "//register DMA_TCD2_NBYTES_MLNO  0x40009048 // TCD Minor Byte Count, Minor Loop Disabled\n"
  "//register DMA_TCD2_NBYTES_MLOFFNO  0x40009048 // TCD Signed Minor Loop Offset, Minor Loop Enabled and Offset Disabled\n"
  "//register DMA_TCD2_NBYTES_MLOFFYES  0x40009048 // TCD Signed Minor Loop Offset, Minor Loop and Offset Enabled\n"
  "//register DMA_TCD2_SLAST  *(volatile int32_t *)0x4000904C  // TCD Last Source Address Adjustment\n"
  "//register DMA_TCD2_DADDR  *(volatile void * volatile *)0x40009050 // TCD Destination Address\n"
  "//register DMA_TCD2_DOFF  *(volatile int16_t *)0x40009054  // TCD Signed Destination Address Offset\n"
  "//register DMA_TCD2_CITER_ELINKYES *(volatile uint16_t *)0x40009056 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "//register DMA_TCD2_CITER_ELINKNO *(volatile uint16_t *)0x40009056 // \?\?\n"
  "//register DMA_TCD2_DLASTSGA *(volatile int32_t *)0x40009058  // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "//register DMA_TCD2_CSR  *(volatile uint16_t *)0x4000905C // TCD Control and Status\n"
  "//register DMA_TCD2_BITER_ELINKYES *(volatile uint16_t *)0x4000905E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "//register DMA_TCD2_BITER_ELINKNO *(volatile uint16_t *)0x4000905E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Disabled\n"
  "//\n"
  "//register DMA_TCD3_SADDR  *(volatile const void * volatile *)0x40009060 // TCD Source Address\n"
  "//register DMA_TCD3_SOFF  *(volatile int16_t *)0x40009064  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD3_ATTR  *(volatile uint16_t *)0x40009066 // TCD Transfer Attributes\n"
  "//register DMA_TCD3_NBYTES_MLNO  0x40009068 // TCD Minor Byte Count, Minor Loop Disabled\n"
  "//register DMA_TCD3_NBYTES_MLOFFNO  0x40009068 // TCD Signed Minor Loop Offset, Minor Loop Enabled and Offset Disabled\n"
  "//register DMA_TCD3_NBYTES_MLOFFYES  0x40009068 // TCD Signed Minor Loop Offset, Minor Loop and Offset Enabled\n"
  "//register DMA_TCD3_SLAST  *(volatile int32_t *)0x4000906C  // TCD Last Source Address Adjustment\n"
  "//register DMA_TCD3_DADDR  *(volatile void * volatile *)0x40009070 // TCD Destination Address\n"
  "//register DMA_TCD3_DOFF  *(volatile int16_t *)0x40009074  // TCD Signed Destination Address Offset\n"
  "//register DMA_TCD3_CITER_ELINKYES *(volatile uint16_t *)0x40009076 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "//register DMA_TCD3_CITER_ELINKNO *(volatile uint16_t *)0x40009076 // \?\?\n"
  "//register DMA_TCD3_DLASTSGA *(volatile int32_t *)0x40009078  // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "//register DMA_TCD3_CSR  *(volatile uint16_t *)0x4000907C // TCD Control and Status\n"
  "//register DMA_TCD3_BITER_ELINKYES *(volatile uint16_t *)0x4000907E // TCD Beginning Minor Loop Link, Major Loop Count ,Channel Linking Enabled\n"
  "//register DMA_TCD3_BITER_ELINKNO *(volatile uint16_t *)0x4000907E // TCD Beginning Minor Loop Link, Major Loop Count ,Channel Linking Disabled\n"
  "//\n"
  "//register DMA_TCD4_SADDR  *(volatile const void * volatile *)0x40009080 // TCD Source Addr\n"
  "//register DMA_TCD4_SOFF  *(volatile int16_t *)0x40009084  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD4_ATTR  *(volatile uint16_t *)0x40009086 // TCD Transfer Attributes\n"
  "//register DMA_TCD4_NBYTES_MLNO  0x40009088 // TCD Minor Byte Count\n"
  "//register DMA_TCD4_NBYTES_MLOFFNO  0x40009088 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD4_NBYTES_MLOFFYES  0x40009088 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD4_SLAST  *(volatile int32_t *)0x4000908C  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD4_DADDR  *(volatile void * volatile *)0x40009090 // TCD Destination Address\n"
  "//register DMA_TCD4_DOFF  *(volatile int16_t *)0x40009094  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD4_CITER_ELINKYES *(volatile uint16_t *)0x40009096 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD4_CITER_ELINKNO *(volatile uint16_t *)0x40009096 // \?\?\n"
  "//register DMA_TCD4_DLASTSGA *(volatile int32_t *)0x40009098  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD4_CSR  *(volatile uint16_t *)0x4000909C // TCD Control and Status\n"
  "//register DMA_TCD4_BITER_ELINKYES *(volatile uint16_t *)0x4000909E // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD4_BITER_ELINKNO *(volatile uint16_t *)0x4000909E // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD5_SADDR  *(volatile const void * volatile *)0x400090A0 // TCD Source Addr\n"
  "//register DMA_TCD5_SOFF  *(volatile int16_t *)0x400090A4  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD5_ATTR  *(volatile uint16_t *)0x400090A6 // TCD Transfer Attributes\n"
  "//register DMA_TCD5_NBYTES_MLNO  0x400090A8 // TCD Minor Byte Count\n"
  "//register DMA_TCD5_NBYTES_MLOFFNO  0x400090A8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD5_NBYTES_MLOFFYES  0x400090A8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD5_SLAST  *(volatile int32_t *)0x400090AC  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD5_DADDR  *(volatile void * volatile *)0x400090B0 // TCD Destination Address\n"
  "//register DMA_TCD5_DOFF  *(volatile int16_t *)0x400090B4  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD5_CITER_ELINKYES *(volatile uint16_t *)0x400090B6 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD5_CITER_ELINKNO *(volatile uint16_t *)0x400090B6 // \?\?\n"
  "//register DMA_TCD5_DLASTSGA *(volatile int32_t *)0x400090B8  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD5_CSR  *(volatile uint16_t *)0x400090BC // TCD Control and Status\n"
  "//register DMA_TCD5_BITER_ELINKYES *(volatile uint16_t *)0x400090BE // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD5_BITER_ELINKNO *(volatile uint16_t *)0x400090BE // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD6_SADDR  *(volatile const void * volatile *)0x400090C0 // TCD Source Addr\n"
  "//register DMA_TCD6_SOFF  *(volatile int16_t *)0x400090C4  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD6_ATTR  *(volatile uint16_t *)0x400090C6 // TCD Transfer Attributes\n"
  "//register DMA_TCD6_NBYTES_MLNO  0x400090C8 // TCD Minor Byte Count\n"
  "//register DMA_TCD6_NBYTES_MLOFFNO  0x400090C8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD6_NBYTES_MLOFFYES  0x400090C8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD6_SLAST  *(volatile int32_t *)0x400090CC  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD6_DADDR  *(volatile void * volatile *)0x400090D0 // TCD Destination Address\n"
  "//register DMA_TCD6_DOFF  *(volatile int16_t *)0x400090D4  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD6_CITER_ELINKYES *(volatile uint16_t *)0x400090D6 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD6_CITER_ELINKNO *(volatile uint16_t *)0x400090D6 // \?\?\n"
  "//register DMA_TCD6_DLASTSGA *(volatile int32_t *)0x400090D8  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD6_CSR  *(volatile uint16_t *)0x400090DC // TCD Control and Status\n"
  "//register DMA_TCD6_BITER_ELINKYES *(volatile uint16_t *)0x400090DE // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD6_BITER_ELINKNO *(volatile uint16_t *)0x400090DE // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD7_SADDR  *(volatile const void * volatile *)0x400090E0 // TCD Source Addr\n"
  "//register DMA_TCD7_SOFF  *(volatile int16_t *)0x400090E4  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD7_ATTR  *(volatile uint16_t *)0x400090E6 // TCD Transfer Attributes\n"
  "//register DMA_TCD7_NBYTES_MLNO  0x400090E8 // TCD Minor Byte Count\n"
  "//register DMA_TCD7_NBYTES_MLOFFNO  0x400090E8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD7_NBYTES_MLOFFYES  0x400090E8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD7_SLAST  *(volatile int32_t *)0x400090EC  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD7_DADDR  *(volatile void * volatile *)0x400090F0 // TCD Destination Address\n"
  "//register DMA_TCD7_DOFF  *(volatile int16_t *)0x400090F4  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD7_CITER_ELINKYES *(volatile uint16_t *)0x400090F6 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD7_CITER_ELINKNO *(volatile uint16_t *)0x400090F6 // \?\?\n"
  "//register DMA_TCD7_DLASTSGA *(volatile int32_t *)0x400090F8  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD7_CSR  *(volatile uint16_t *)0x400090FC // TCD Control and Status\n"
  "//register DMA_TCD7_BITER_ELINKYES *(volatile uint16_t *)0x400090FE // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD7_BITER_ELINKNO *(volatile uint16_t *)0x400090FE // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD8_SADDR  *(volatile const void * volatile *)0x40009100 // TCD Source Addr\n"
  "//register DMA_TCD8_SOFF  *(volatile int16_t *)0x40009104  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD8_ATTR  *(volatile uint16_t *)0x40009106 // TCD Transfer Attributes\n"
  "//register DMA_TCD8_NBYTES_MLNO  0x40009108 // TCD Minor Byte Count\n"
  "//register DMA_TCD8_NBYTES_MLOFFNO  0x40009108 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD8_NBYTES_MLOFFYES  0x40009108 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD8_SLAST  *(volatile int32_t *)0x4000910C  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD8_DADDR  *(volatile void * volatile *)0x40009110 // TCD Destination Address\n"
  "//register DMA_TCD8_DOFF  *(volatile int16_t *)0x40009114  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD8_CITER_ELINKYES *(volatile uint16_t *)0x40009116 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD8_CITER_ELINKNO *(volatile uint16_t *)0x40009116 // \?\?\n"
  "//register DMA_TCD8_DLASTSGA *(volatile int32_t *)0x40009118  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD8_CSR  *(volatile uint16_t *)0x4000911C // TCD Control and Status\n"
  "//register DMA_TCD8_BITER_ELINKYES *(volatile uint16_t *)0x4000911E // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD8_BITER_ELINKNO *(volatile uint16_t *)0x4000911E // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD9_SADDR  *(volatile const void * volatile *)0x40009120 // TCD Source Addr\n"
  "//register DMA_TCD9_SOFF  *(volatile int16_t *)0x40009124  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD9_ATTR  *(volatile uint16_t *)0x40009126 // TCD Transfer Attributes\n"
  "//register DMA_TCD9_NBYTES_MLNO  0x40009128 // TCD Minor Byte Count\n"
  "//register DMA_TCD9_NBYTES_MLOFFNO  0x40009128 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD9_NBYTES_MLOFFYES  0x40009128 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD9_SLAST  *(volatile int32_t *)0x4000912C  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD9_DADDR  *(volatile void * volatile *)0x40009130 // TCD Destination Address\n"
  "//register DMA_TCD9_DOFF  *(volatile int16_t *)0x40009134  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD9_CITER_ELINKYES *(volatile uint16_t *)0x40009136 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD9_CITER_ELINKNO *(volatile uint16_t *)0x40009136 // \?\?\n"
  "//register DMA_TCD9_DLASTSGA *(volatile int32_t *)0x40009138  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD9_CSR  *(volatile uint16_t *)0x4000913C // TCD Control and Status\n"
  "//register DMA_TCD9_BITER_ELINKYES *(volatile uint16_t *)0x4000913E // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD9_BITER_ELINKNO *(volatile uint16_t *)0x4000913E // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD10_SADDR  *(volatile const void * volatile *)0x40009140 // TCD Source Addr\n"
  "//register DMA_TCD10_SOFF  *(volatile int16_t *)0x40009144  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD10_ATTR  *(volatile uint16_t *)0x40009146 // TCD Transfer Attributes\n"
  "//register DMA_TCD10_NBYTES_MLNO  0x40009148 // TCD Minor Byte Count\n"
  "//register DMA_TCD10_NBYTES_MLOFFNO  0x40009148 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD10_NBYTES_MLOFFYES  0x40009148 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD10_SLAST  *(volatile int32_t *)0x4000914C  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD10_DADDR  *(volatile void * volatile *)0x40009150 // TCD Destination Address\n"
  "//register DMA_TCD10_DOFF  *(volatile int16_t *)0x40009154  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD10_CITER_ELINKYES *(volatile uint16_t *)0x40009156 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD10_CITER_ELINKNO *(volatile uint16_t *)0x40009156 // \?\?\n"
  "//register DMA_TCD10_DLASTSGA *(volatile int32_t *)0x40009158  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD10_CSR  *(volatile uint16_t *)0x4000915C // TCD Control and Status\n"
  "//register DMA_TCD10_BITER_ELINKYES *(volatile uint16_t *)0x4000915E // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD10_BITER_ELINKNO *(volatile uint16_t *)0x4000915E // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD11_SADDR  *(volatile const void * volatile *)0x40009160 // TCD Source Addr\n"
  "//register DMA_TCD11_SOFF  *(volatile int16_t *)0x40009164  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD11_ATTR  *(volatile uint16_t *)0x40009166 // TCD Transfer Attributes\n"
  "//register DMA_TCD11_NBYTES_MLNO  0x40009168 // TCD Minor Byte Count\n"
  "//register DMA_TCD11_NBYTES_MLOFFNO  0x40009168 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD11_NBYTES_MLOFFYES  0x40009168 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD11_SLAST  *(volatile int32_t *)0x4000916C  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD11_DADDR  *(volatile void * volatile *)0x40009170 // TCD Destination Address\n"
  "//register DMA_TCD11_DOFF  *(volatile int16_t *)0x40009174  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD11_CITER_ELINKYES *(volatile uint16_t *)0x40009176 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD11_CITER_ELINKNO *(volatile uint16_t *)0x40009176 // \?\?\n"
  "//register DMA_TCD11_DLASTSGA *(volatile int32_t *)0x40009178  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD11_CSR  *(volatile uint16_t *)0x4000917C // TCD Control and Status\n"
  "//register DMA_TCD11_BITER_ELINKYES *(volatile uint16_t *)0x4000917E // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD11_BITER_ELINKNO *(volatile uint16_t *)0x4000917E // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD12_SADDR  *(volatile const void * volatile *)0x40009180 // TCD Source Addr\n"
  "//register DMA_TCD12_SOFF  *(volatile int16_t *)0x40009184  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD12_ATTR  *(volatile uint16_t *)0x40009186 // TCD Transfer Attributes\n"
  "//register DMA_TCD12_NBYTES_MLNO  0x40009188 // TCD Minor Byte Count\n"
  "//register DMA_TCD12_NBYTES_MLOFFNO  0x40009188 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD12_NBYTES_MLOFFYES  0x40009188 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD12_SLAST  *(volatile int32_t *)0x4000918C  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD12_DADDR  *(volatile void * volatile *)0x40009190 // TCD Destination Address\n"
  "//register DMA_TCD12_DOFF  *(volatile int16_t *)0x40009194  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD12_CITER_ELINKYES *(volatile uint16_t *)0x40009196 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD12_CITER_ELINKNO *(volatile uint16_t *)0x40009196 // \?\?\n"
  "//register DMA_TCD12_DLASTSGA *(volatile int32_t *)0x40009198  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD12_CSR  *(volatile uint16_t *)0x4000919C // TCD Control and Status\n"
  "//register DMA_TCD12_BITER_ELINKYES *(volatile uint16_t *)0x4000919E // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD12_BITER_ELINKNO *(volatile uint16_t *)0x4000919E // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD13_SADDR  *(volatile const void * volatile *)0x400091A0 // TCD Source Addr\n"
  "//register DMA_TCD13_SOFF  *(volatile int16_t *)0x400091A4  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD13_ATTR  *(volatile uint16_t *)0x400091A6 // TCD Transfer Attributes\n"
  "//register DMA_TCD13_NBYTES_MLNO  0x400091A8 // TCD Minor Byte Count\n"
  "//register DMA_TCD13_NBYTES_MLOFFNO  0x400091A8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD13_NBYTES_MLOFFYES  0x400091A8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD13_SLAST  *(volatile int32_t *)0x400091AC  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD13_DADDR  *(volatile void * volatile *)0x400091B0 // TCD Destination Address\n"
  "//register DMA_TCD13_DOFF  *(volatile int16_t *)0x400091B4  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD13_CITER_ELINKYES *(volatile uint16_t *)0x400091B6 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD13_CITER_ELINKNO *(volatile uint16_t *)0x400091B6 // \?\?\n"
  "//register DMA_TCD13_DLASTSGA *(volatile int32_t *)0x400091B8  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD13_CSR  *(volatile uint16_t *)0x400091BC // TCD Control and Status\n"
  "//register DMA_TCD13_BITER_ELINKYES *(volatile uint16_t *)0x400091BE // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD13_BITER_ELINKNO *(volatile uint16_t *)0x400091BE // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD14_SADDR  *(volatile const void * volatile *)0x400091C0 // TCD Source Addr\n"
  "//register DMA_TCD14_SOFF  *(volatile int16_t *)0x400091C4  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD14_ATTR  *(volatile uint16_t *)0x400091C6 // TCD Transfer Attributes\n"
  "//register DMA_TCD14_NBYTES_MLNO  0x400091C8 // TCD Minor Byte Count\n"
  "//register DMA_TCD14_NBYTES_MLOFFNO  0x400091C8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD14_NBYTES_MLOFFYES  0x400091C8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD14_SLAST  *(volatile int32_t *)0x400091CC  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD14_DADDR  *(volatile void * volatile *)0x400091D0 // TCD Destination Address\n"
  "//register DMA_TCD14_DOFF  *(volatile int16_t *)0x400091D4  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD14_CITER_ELINKYES *(volatile uint16_t *)0x400091D6 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD14_CITER_ELINKNO *(volatile uint16_t *)0x400091D6 // \?\?\n"
  "//register DMA_TCD14_DLASTSGA *(volatile int32_t *)0x400091D8  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD14_CSR  *(volatile uint16_t *)0x400091DC // TCD Control and Status\n"
  "//register DMA_TCD14_BITER_ELINKYES *(volatile uint16_t *)0x400091DE // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD14_BITER_ELINKNO *(volatile uint16_t *)0x400091DE // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//register DMA_TCD15_SADDR  *(volatile const void * volatile *)0x400091E0 // TCD Source Addr\n"
  "//register DMA_TCD15_SOFF  *(volatile int16_t *)0x400091E4  // TCD Signed Source Address Offset\n"
  "//register DMA_TCD15_ATTR  *(volatile uint16_t *)0x400091E6 // TCD Transfer Attributes\n"
  "//register DMA_TCD15_NBYTES_MLNO  0x400091E8 // TCD Minor Byte Count\n"
  "//register DMA_TCD15_NBYTES_MLOFFNO  0x400091E8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD15_NBYTES_MLOFFYES  0x400091E8 // TCD Signed Minor Loop Offset\n"
  "//register DMA_TCD15_SLAST  *(volatile int32_t *)0x400091EC  // TCD Last Source Addr Adj.\n"
  "//register DMA_TCD15_DADDR  *(volatile void * volatile *)0x400091F0 // TCD Destination Address\n"
  "//register DMA_TCD15_DOFF  *(volatile int16_t *)0x400091F4  // TCD Signed Dest Address Offset\n"
  "//register DMA_TCD15_CITER_ELINKYES *(volatile uint16_t *)0x400091F6 // TCD Current Minor Loop Link\n"
  "//register DMA_TCD15_CITER_ELINKNO *(volatile uint16_t *)0x400091F6 // \?\?\n"
  "//register DMA_TCD15_DLASTSGA *(volatile int32_t *)0x400091F8  // TCD Last Destination Addr Adj\n"
  "//register DMA_TCD15_CSR  *(volatile uint16_t *)0x400091FC // TCD Control and Status\n"
  "//register DMA_TCD15_BITER_ELINKYES *(volatile uint16_t *)0x400091FE // TCD Beginning Minor Loop Link\n"
  "//register DMA_TCD15_BITER_ELINKNO *(volatile uint16_t *)0x400091FE // TCD Beginning Minor Loop Link\n"
  "//\n"
  "//\n"
  "//// Chapter 22: External Watchdog Monitor (EWM)\n"
  "//register EWM_CTRL  *(volatile uint8_t  *)0x40061000 // Control Register\n"
  "//register EWM_SERV  *(volatile uint8_t  *)0x40061001 // Service Register\n"
  "//register EWM_CMPL  *(volatile uint8_t  *)0x40061002 // Compare Low Register\n"
  "//register EWM_CMPH  *(volatile uint8_t  *)0x40061003 // Compare High Register\n"
  "//\n"
  "//// Chapter 23: Watchdog Timer (WDOG)\n"
  "register WDOG_STCTRLH : UInt16 at 0x40052000 // Watchdog Status and Control Register High\n"
  "let WDOG_STCTRLH_DISTESTWDOG : UInt16 = 0x4000  // Allows the WDOG's functional test mode to be disabled permanently.\n"
  "//register WDOG_STCTRLH_BYTESEL(n)  (uint16_t)(((n) & 3) << 12) // selects the byte to be tested when the watchdog is in the byte test mode.\n"
  "let WDOG_STCTRLH_TESTSEL  : UInt16 = 0x0800\n"
  "let WDOG_STCTRLH_TESTWDOG : UInt16 = 0x0400\n"
  "let WDOG_STCTRLH_WAITEN : UInt16 = 0x0080\n"
  "let WDOG_STCTRLH_STOPEN : UInt16 = 0x0040\n"
  "let WDOG_STCTRLH_DBGEN  : UInt16 = 0x0020\n"
  "let WDOG_STCTRLH_ALLOWUPDATE : UInt16 = 0x0010\n"
  "let WDOG_STCTRLH_WINEN : UInt16 = 0x0008\n"
  "let WDOG_STCTRLH_IRQRSTEN : UInt16 = 0x0004\n"
  "let WDOG_STCTRLH_CLKSRC : UInt16 = 0x0002\n"
  "let WDOG_STCTRLH_WDOGEN : UInt16 = 0x0001\n"
  "register WDOG_STCTRLL  : UInt16 at 0x40052002 // Watchdog Status and Control Register Low\n"
  "register WDOG_TOVALH   : UInt16 at 0x40052004 // Watchdog Time-out Value Register High\n"
  "register WDOG_TOVALL   : UInt16 at 0x40052006 // Watchdog Time-out Value Register Low\n"
  "register WDOG_WINH     : UInt16 at 0x40052008 // Watchdog Window Register High\n"
  "register WDOG_WINL     : UInt16 at 0x4005200A // Watchdog Window Register Low\n"
  "register WDOG_REFRESH  : UInt16 at 0x4005200C // Watchdog Refresh register\n"
  "register WDOG_UNLOCK   : UInt16 at 0x4005200E // Watchdog Unlock register\n"
  "let WDOG_UNLOCK_SEQ1 : UInt16   = 0xC520\n"
  "let WDOG_UNLOCK_SEQ2 : UInt16   = 0xD928\n"
  "register WDOG_TMROUTH  : UInt16 at 0x40052010 // Watchdog Timer Output Register High\n"
  "register WDOG_TMROUTL  : UInt16 at 0x40052012 // Watchdog Timer Output Register Low\n"
  "register WDOG_RSTCNT   : UInt16 at 0x40052014 // Watchdog Reset Count register\n"
  "register WDOG_PRESC    : UInt16 at 0x40052016 // Watchdog Prescaler register\n"
  "//\n"
  "//// Chapter 24: Multipurpose Clock Generator (MCG)\n"
  "register MCG_C1 : UInt8 at 0x40064000 // MCG Control 1 Register\n"
  "let MCG_C1_IREFSTEN : UInt8 = 0x01   // Internal Reference Stop Enable, Controls whether or not the internal reference clock remains enabled when the "
  "MCG enters Stop mode.\n"
  "let MCG_C1_IRCLKEN : UInt8 = 0x02   // Internal Reference Clock Enable, Enables the internal reference clock for use as MCGIRCLK.\n"
  "let MCG_C1_IREFS : UInt8 = 0x04   // Internal Reference Select, Selects the reference clock source for the FLL.\n"
  "//register MCG_C1_FRDIV(n)   (uint8_t)(((n) & 0x07) << 3) // FLL External Reference Divider, Selects the amount to divide down the external reference "
  "clock for the FLL\n"
  "let MCG_C1_FRDIV_0 : UInt8 = 0 << 3\n"
  "let MCG_C1_FRDIV_1 : UInt8 = 1 << 3\n"
  "let MCG_C1_FRDIV_2 : UInt8 = 2 << 3\n"
  "let MCG_C1_FRDIV_3 : UInt8 = 3 << 3\n"
  "let MCG_C1_FRDIV_4 : UInt8 = 4 << 3\n"
  "let MCG_C1_FRDIV_5 : UInt8 = 5 << 3\n"
  "let MCG_C1_FRDIV_6 : UInt8 = 6 << 3\n"
  "let MCG_C1_FRDIV_7 : UInt8 = 7 << 3\n"
  "//register MCG_C1_CLKS(n)   (uint8_t)(((n) & 0x03) << 6) // Clock Source Select, Selects the clock source for MCGOUTCLK\n"
  "let MCG_C1_CLKS_0 : UInt8 = 0 << 6\n"
  "let MCG_C1_CLKS_1 : UInt8 = 1 << 6\n"
  "let MCG_C1_CLKS_2 : UInt8 = 2 << 6\n"
  "let MCG_C1_CLKS_3 : UInt8 = 3 << 6\n"
  "register MCG_C2 : UInt8 at 0x40064001 // MCG Control 2 Register\n"
  "let MCG_C2_IRCS : UInt8  = 0x01   // Internal Reference Clock Select, Selects between the fast or slow internal reference clock source.\n"
  "let MCG_C2_LP : UInt8 = 0x02   // Low Power Select, Controls whether the FLL or PLL is disabled in BLPI and BLPE modes.\n"
  "let MCG_C2_EREFS : UInt8 = 0x04   // External Reference Select, Selects the source for the external reference clock. \n"
  "let MCG_C2_HGO0 : UInt8 = 0x08   // High Gain Oscillator Select, Controls the crystal oscillator mode of operation\n"
  "//register MCG_C2_RANGE0(n)  (uint8_t)(((n) & 0x03) << 4) // Frequency Range Select, Selects the frequency range for the crystal oscillator\n"
  "let MCG_C2_RANGE0_0 : UInt8 = 0 << 4\n"
  "let MCG_C2_RANGE0_1 : UInt8 = 1 << 4\n"
  "let MCG_C2_RANGE0_2 : UInt8 = 2 << 4\n"
  "let MCG_C2_RANGE0_3 : UInt8 = 3 << 4\n"
  "let MCG_C2_LOCRE0 : UInt8 = 0x80   // Loss of Clock Reset Enable, Determines whether an interrupt or a reset request is made following a loss of OSC0 "
  "\n"
  "register MCG_C3 : UInt8 at 0x40064002 // MCG Control 3 Register\n"
  "//register MCG_C3_SCTRIM(n)  (uint8_t)(n)   // Slow Internal Reference Clock Trim Setting\n"
  "register MCG_C4 : UInt8 at 0x40064003 // MCG Control 4 Register\n"
  "let MCG_C4_SCFTRIM : UInt8 = 0x01   // Slow Internal Reference Clock Fine Trim\n"
  "//register MCG_C4_FCTRIM(n)  (uint8_t)(((n) & 0x0F) << 1) // Fast Internal Reference Clock Trim Setting\n"
  "//register MCG_C4_DRST_DRS(n)  (uint8_t)(((n) & 0x03) << 5) // DCO Range Select\n"
  "let MCG_C4_DMX32 : UInt8 = 0x80   // DCO Maximum Frequency with 32.768 kHz Reference, controls whether the DCO frequency range is narrowed\n"
  "register MCG_C5 : UInt8 at 0x40064004 // MCG Control 5 Register\n"
  "//register MCG_C5_PRDIV0(n)  (uint8_t)((n) & 0x1F)  // PLL External Reference Divider\n"
  "let MCG_C5_PRDIV0_3 : UInt8 = 3\n"
  "let MCG_C5_PLLSTEN0 : UInt8 = 0x20   // PLL Stop Enable\n"
  "let MCG_C5_PLLCLKEN0 : UInt8 = 0x40   // PLL Clock Enable\n"
  "register MCG_C6 : UInt8 at 0x40064005 // MCG Control 6 Register\n"
  "//register MCG_C6_VDIV0(n)   (uint8_t)((n) & 0x1F)  // VCO 0 Divider\n"
  "let MCG_C6_VDIV0_0 : UInt8 = 0   // Clock Monitor Enable\n"
  "let MCG_C6_CME0 : UInt8 = 0x20   // Clock Monitor Enable\n"
  "let MCG_C6_PLLS : UInt8 = 0x40   // PLL Select, Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00. \n"
  "//register MCG_C6_LOLIE0   (uint8_t)0x80   // Loss of Lock Interrrupt Enable\n"
  "register MCG_S  : UInt8 at 0x40064006 // MCG Status Register\n"
  "let MCG_S_IRCST : UInt8 = 0x01   // Internal Reference Clock Status\n"
  "let MCG_S_OSCINIT0 : UInt8 = 0x02   // OSC Initialization, resets to 0, is set to 1 after the initialization cycles of the crystal oscillator\n"
  "//register MCG_S_CLKST(n)   (uint8_t)(((n) & 0x03) << 2) // Clock Mode Status, 0=FLL is selected, 1= Internal ref, 2=External ref, 3=PLL\n"
  "let MCG_S_CLKST_0 : UInt8 = 0 << 2 \n"
  "let MCG_S_CLKST_1 : UInt8 = 1 << 2 \n"
  "let MCG_S_CLKST_2 : UInt8 = 2 << 2 \n"
  "let MCG_S_CLKST_3 : UInt8 = 3 << 2 \n"
  "\n"
  "\n"
  "let MCG_S_CLKST_MASK : UInt8 = 0x0C\n"
  "let MCG_S_IREFST : UInt8 = 0x10   // Internal Reference Status\n"
  "let MCG_S_PLLST : UInt8 = 0x20   // PLL Select Status\n"
  "let MCG_S_LOCK0 : UInt8  = 0x40   // Lock Status, 0=PLL Unlocked, 1=PLL Locked\n"
  "let MCG_S_LOLS0 : UInt8  = 0x80   // Loss of Lock Status\n"
  "\n"
  "register MCG_SC : UInt8 at 0x40064008 // MCG Status and Control Register\n"
  "let MCG_SC_LOCS0 : UInt8 = 0x01   // OSC0 Loss of Clock Status\n"
  "//register MCG_SC_FCRDIV(n)  (uint8_t)(((n) & 0x07) << 1) // Fast Clock Internal Reference Divider\n"
  "let MCG_SC_FLTPRSRV : UInt8 = 0x10   // FLL Filter Preserve Enable\n"
  "let MCG_SC_ATMF : UInt8 = 0x20   // Automatic Trim Machine Fail Flag\n"
  "let MCG_SC_ATMS : UInt8 = 0x40   // Automatic Trim Machine Select\n"
  "let MCG_SC_ATME : UInt8 = 0x80   // Automatic Trim Machine Enable\n"
  "\n"
  "register MCG_ATCVH : UInt8 at 0x4006400A // MCG Auto Trim Compare Value High Register\n"
  "register MCG_ATCVL : UInt8 at 0x4006400B // MCG Auto Trim Compare Value Low Register\n"
  "register MCG_C7    : UInt8 at 0x4006400C // MCG Control 7 Register\n"
  "register MCG_C8    : UInt8 at 0x4006400D // MCG Control 8 Register\n"
  "//\n"
  "//// Chapter 25: Oscillator (OSC)\n"
  "register OSC0_CR : UInt8 at 0x40065000 // OSC Control Register\n"
  "let OSC_SC16P  : UInt8 = 0x01   // Oscillator 16 pF Capacitor Load Configure\n"
  "let OSC_SC8P   : UInt8 = 0x02   // Oscillator 8 pF Capacitor Load Configure\n"
  "let OSC_SC4P   : UInt8 = 0x04   // Oscillator 4 pF Capacitor Load Configure\n"
  "let OSC_SC2P   : UInt8 = 0x08   // Oscillator 2 pF Capacitor Load Configure\n"
  "let OSC_EREFSTEN : UInt8 = 0x20   // External Reference Stop Enable, Controls whether or not the external reference clock (OSCERCLK) remains enabled w"
  "hen MCU enters Stop mode.\n"
  "let OSC_ERCLKEN : UInt8 = 0x80   // External Reference Enable, Enables external reference clock (OSCERCLK).\n"
  "//\n"
  "//// Chapter 27: Flash Memory Controller (FMC)\n"
  "register FMC_PFAPR     : UInt32 at 0x4001F000 // Flash Access Protection\n"
  "register FMC_PFB0CR    : UInt32 at 0x4001F004 // Flash Control\n"
  "register FMC_TAGVDW0S0 : UInt32 at 0x4001F100 // Cache Tag Storage\n"
  "register FMC_TAGVDW0S1 : UInt32 at 0x4001F104 // Cache Tag Storage\n"
  "register FMC_TAGVDW1S0 : UInt32 at 0x4001F108 // Cache Tag Storage\n"
  "register FMC_TAGVDW1S1 : UInt32 at 0x4001F10C // Cache Tag Storage\n"
  "register FMC_TAGVDW2S0 : UInt32 at 0x4001F110 // Cache Tag Storage\n"
  "register FMC_TAGVDW2S1 : UInt32 at 0x4001F114 // Cache Tag Storage\n"
  "register FMC_TAGVDW3S0 : UInt32 at 0x4001F118 // Cache Tag Storage\n"
  "register FMC_TAGVDW3S1 : UInt32 at 0x4001F11C // Cache Tag Storage\n"
  "register FMC_DATAW0S0  : UInt32 at 0x4001F200 // Cache Data Storage\n"
  "register FMC_DATAW0S1  : UInt32 at 0x4001F204 // Cache Data Storage\n"
  "register FMC_DATAW1S0  : UInt32 at 0x4001F208 // Cache Data Storage\n"
  "register FMC_DATAW1S1  : UInt32 at 0x4001F20C // Cache Data Storage\n"
  "register FMC_DATAW2S0  : UInt32 at 0x4001F210 // Cache Data Storage\n"
  "register FMC_DATAW2S1  : UInt32 at 0x4001F214 // Cache Data Storage\n"
  "register FMC_DATAW3S0  : UInt32 at 0x4001F218 // Cache Data Storage\n"
  "register FMC_DATAW3S1  : UInt32 at 0x4001F21C // Cache Data Storage\n"
  "//\n"
  "//// Chapter 28: Flash Memory Module (FTFL)\n"
  "//register FTFL_FST *(volatile uint8_t  *)0x40020000      // Flash Status Register\n"
  "//register FTFL_FSTAT_CCIF   (uint8_t)0x80   // Command Complete Interrupt Flag\n"
  "//register FTFL_FSTAT_RDCOLERR  (uint8_t)0x40   // Flash Read Collision Error Flag\n"
  "//register FTFL_FSTAT_ACCERR  (uint8_t)0x20   // Flash Access Error Flag\n"
  "//register FTFL_FSTAT_FPVIOL  (uint8_t)0x10   // Flash Protection Violation Flag\n"
  "//register FTFL_FSTAT_MGSTAT0  (uint8_t)0x01   // Memory Controller Command Completion Status Flag\n"
  "//register FTFL_FCNFG  *(volatile uint8_t  *)0x40020001      // Flash Configuration Register\n"
  "//register FTFL_FCNFG_CCIE   (uint8_t)0x80   // Command Complete Interrupt Enable\n"
  "//register FTFL_FCNFG_RDCOLLIE  (uint8_t)0x40   // Read Collision Error Interrupt Enable\n"
  "//register FTFL_FCNFG_ERSAREQ  (uint8_t)0x20   // Erase All Request\n"
  "//register FTFL_FCNFG_ERSSUSP  (uint8_t)0x10   // Erase Suspend\n"
  "//register FTFL_FCNFG_PFLSH  (uint8_t)0x04   // Flash memory configuration\n"
  "//register FTFL_FCNFG_RAMRDY  (uint8_t)0x02   // RAM Ready\n"
  "//register FTFL_FCNFG_EEERDY  (uint8_t)0x01   // EEPROM Ready\n"
  "//register FTFL_FSEC  *(const    uint8_t  *)0x40020002      // Flash Security Register\n"
  "//register FTFL_FOPT  *(const    uint8_t  *)0x40020003      // Flash Option Register\n"
  "//register FTFL_FCCOB3  *(volatile uint8_t  *)0x40020004      // Flash Common Command Object Registers\n"
  "//register FTFL_FCCOB2  *(volatile uint8_t  *)0x40020005\n"
  "//register FTFL_FCCOB1  *(volatile uint8_t  *)0x40020006\n"
  "//register FTFL_FCCOB0  *(volatile uint8_t  *)0x40020007\n"
  "//register FTFL_FCCOB7  *(volatile uint8_t  *)0x40020008\n"
  "//register FTFL_FCCOB6  *(volatile uint8_t  *)0x40020009\n"
  "//register FTFL_FCCOB5  *(volatile uint8_t  *)0x4002000A\n"
  "//register FTFL_FCCOB4  *(volatile uint8_t  *)0x4002000B\n"
  "//register FTFL_FCCOBB  *(volatile uint8_t  *)0x4002000C\n"
  "//register FTFL_FCCOBA  *(volatile uint8_t  *)0x4002000D\n"
  "//register FTFL_FCCOB9  *(volatile uint8_t  *)0x4002000E\n"
  "//register FTFL_FCCOB8  *(volatile uint8_t  *)0x4002000F\n"
  "//register FTFL_FPROT3  *(volatile uint8_t  *)0x40020010      // Program Flash Protection Registers\n"
  "//register FTFL_FPROT2  *(volatile uint8_t  *)0x40020011      // Program Flash Protection Registers\n"
  "//register FTFL_FPROT1  *(volatile uint8_t  *)0x40020012      // Program Flash Protection Registers\n"
  "//register FTFL_FPROT0  *(volatile uint8_t  *)0x40020013      // Program Flash Protection Registers\n"
  "//register FTFL_FEPROT  *(volatile uint8_t  *)0x40020016      // EEPROM Protection Register\n"
  "//register FTFL_FDPROT  *(volatile uint8_t  *)0x40020017      // Data Flash Protection Register\n"
  "//\n"
  "//// Chapter 30: Cyclic Redundancy Check (CRC)\n"
  "register CRC_CRC   : UInt32 at 0x40032000 // CRC Data register\n"
  "register CRC_GPOLY : UInt32 at 0x40032004 // CRC Polynomial register\n"
  "register CRC_CTRL  : UInt32 at 0x40032008 // CRC Control register\n"
  "//\n"
  "//// Chapter 31: Analog-to-Digital Converter (ADC)\n"
  "register ADC0_SC1A   : UInt32 at 0x4003B000 // ADC status and control registers 1\n"
  "register ADC0_SC1B   : UInt32 at 0x4003B004 // ADC status and control registers 1\n"
  "let ADC_SC1_COCO  : UInt32 = 0x80   // Conversion complete flag\n"
  "let ADC_SC1_AIEN  : UInt32 = 0x40   // Interrupt enable\n"
  "let ADC_SC1_DIFF  : UInt32 = 0x20   // Differential mode enable\n"
  "//register ADC_SC1_ADCH(n)    ((n) & 0x1F)  // Input channel select\n"
  "register ADC0_CFG1   : UInt32 at 0x4003B008 // ADC configuration register 1\n"
  "let ADC_CFG1_ADLPC  : UInt32 = 0x80   // Low-power configuration\n"
  "//register ADC_CFG1_ADIV(n)   (((n) & 3) << 5) // Clock divide select, 0=direct, 1=div2, 2=div4, 3=div8\n"
  "let ADC_CFG1_ADLSMP  : UInt32 = 0x10   // Sample time configuration, 0=Short, 1=Long\n"
  "//register ADC_CFG1_MODE(n)   (((n) & 3) << 2) // Conversion mode, 0=8 bit, 1=12 bit, 2=10 bit, 3=16 bit\n"
  "//register ADC_CFG1_ADICLK(n)   (((n) & 3) << 0) // Input clock, 0=bus, 1=bus/2, 2=OSCERCLK, 3=async\n"
  "register ADC0_CFG2  : UInt32 at 0x4003B00C // Configuration register 2\n"
  "let ADC_CFG2_MUXSEL  : UInt32 = 0x10   // 0=a channels, 1=b channels\n"
  "let ADC_CFG2_ADACKEN  : UInt32 = 0x08   // async clock enable\n"
  "let ADC_CFG2_ADHSC   : UInt32 = 0x04   // High speed configuration\n"
  "//register ADC_CFG2_ADLSTS(n)   (((n) & 3) << 0) // Sample time, 0=24 cycles, 1=12 cycles, 2=6 cycles, 3=2 cycles\n"
  "register ADC0_RA    : UInt32 at 0x4003B010 // ADC data result register\n"
  "register ADC0_RB    : UInt32 at 0x4003B014 // ADC data result register\n"
  "register ADC0_CV1   : UInt32 at 0x4003B018 // Compare value registers\n"
  "register ADC0_CV2   : UInt32 at 0x4003B01C // Compare value registers\n"
  "register ADC0_SC2   : UInt32 at 0x4003B020 // Status and control register 2\n"
  "let ADC_SC2_ADACT  : UInt32 = 0x80   // Conversion active\n"
  "let ADC_SC2_ADTRG  : UInt32 = 0x40   // Conversion trigger select, 0=software, 1=hardware\n"
  "let ADC_SC2_ACFE   : UInt32 = 0x20   // Compare function enable\n"
  "let ADC_SC2_ACFGT  : UInt32 = 0x10   // Compare function greater than enable\n"
  "let ADC_SC2_ACREN  : UInt32 = 0x08   // Compare function range enable\n"
  "let ADC_SC2_DMAEN  : UInt32= 0x04   // DMA enable\n"
  "//register ADC_SC2_REFSEL(n)   (((n) & 3) << 0) // Voltage reference, 0=vcc/external, 1=1.2 volts\n"
  "register ADC0_SC3   : UInt32 at 0x4003B024 // Status and control register 3\n"
  "let ADC_SC3_CAL  : UInt32 = 0x80   // Calibration, 1=begin, stays set while cal in progress\n"
  "let ADC_SC3_CALF  : UInt32= 0x40   // Calibration failed flag\n"
  "let ADC_SC3_ADCO  : UInt32= 0x08   // Continuous conversion enable\n"
  "let ADC_SC3_AVGE  : UInt32= 0x04   // Hardware average enable\n"
  "//register ADC_SC3_AVGS(n)    (((n) & 3) << 0) // avg select, 0=4 samples, 1=8 samples, 2=16 samples, 3=32 samples\n"
  "register ADC0_OFS   : UInt32 at 0x4003B028 // ADC offset correction register\n"
  "register ADC0_PG    : UInt32 at 0x4003B02C // ADC plus-side gain register\n"
  "register ADC0_MG    : UInt32 at 0x4003B030 // ADC minus-side gain register\n"
  "register ADC0_CLPD  : UInt32 at 0x4003B034 // ADC plus-side general calibration value register\n"
  "register ADC0_CLPS  : UInt32 at 0x4003B038 // ADC plus-side general calibration value register\n"
  "register ADC0_CLP4  : UInt32 at 0x4003B03C // ADC plus-side general calibration value register\n"
  "register ADC0_CLP3  : UInt32 at 0x4003B040 // ADC plus-side general calibration value register\n"
  "register ADC0_CLP2  : UInt32 at 0x4003B044 // ADC plus-side general calibration value register\n"
  "register ADC0_CLP1  : UInt32 at 0x4003B048 // ADC plus-side general calibration value register\n"
  "register ADC0_CLP0  : UInt32 at 0x4003B04C // ADC plus-side general calibration value register\n"
  "register ADC0_PGA   : UInt32 at 0x4003B050 // ADC Programmable Gain Amplifier\n"
  "let ADC0_PGA_PGAEN  : UInt32 = 0x00800000  // Enable\n"
  "let ADC0_PGA_PGALPB  : UInt32 = 0x00100000  // Low-Power Mode Control, 0=low power, 1=normal\n"
  "//register ADC0_PGA_PGAG(n)   (((n) & 15) << 16) // Gain, 0=1X, 1=2X, 2=4X, 3=8X, 4=16X, 5=32X, 6=64X\n"
  "register ADC0_CLMD   : UInt32 at 0x4003B054 // ADC minus-side general calibration value register\n"
  "register ADC0_CLMS   : UInt32 at 0x4003B058 // ADC minus-side general calibration value register\n"
  "register ADC0_CLM4   : UInt32 at 0x4003B05C // ADC minus-side general calibration value register\n"
  "register ADC0_CLM3   : UInt32 at 0x4003B060 // ADC minus-side general calibration value register\n"
  "register ADC0_CLM2   : UInt32 at 0x4003B064 // ADC minus-side general calibration value register\n"
  "register ADC0_CLM1   : UInt32 at 0x4003B068 // ADC minus-side general calibration value register\n"
  "register ADC0_CLM0   : UInt32 at 0x4003B06C // ADC minus-side general calibration value register\n"
  "//\n"
  "register ADC1_SC1A   : UInt32 at 0x400BB000 // ADC status and control registers 1\n"
  "register ADC1_SC1B   : UInt32 at 0x400BB004 // ADC status and control registers 1\n"
  "register ADC1_CFG1   : UInt32 at 0x400BB008 // ADC configuration register 1\n"
  "register ADC1_CFG2   : UInt32 at 0x400BB00C // Configuration register 2\n"
  "register ADC1_RA     : UInt32 at 0x400BB010 // ADC data result register\n"
  "register ADC1_RB     : UInt32 at 0x400BB014 // ADC data result register\n"
  "register ADC1_CV1    : UInt32 at 0x400BB018 // Compare value registers\n"
  "register ADC1_CV2    : UInt32 at 0x400BB01C // Compare value registers\n"
  "register ADC1_SC2    : UInt32 at 0x400BB020 // Status and control register 2\n"
  "register ADC1_SC3    : UInt32 at 0x400BB024 // Status and control register 3\n"
  "register ADC1_OFS    : UInt32 at 0x400BB028 // ADC offset correction register\n"
  "register ADC1_PG     : UInt32 at 0x400BB02C // ADC plus-side gain register\n"
  "register ADC1_MG     : UInt32 at 0x400BB030 // ADC minus-side gain register\n"
  "register ADC1_CLPD   : UInt32 at 0x400BB034 // ADC plus-side general calibration value register\n"
  "register ADC1_CLPS   : UInt32 at 0x400BB038 // ADC plus-side general calibration value register\n"
  "register ADC1_CLP4   : UInt32 at 0x400BB03C // ADC plus-side general calibration value register\n"
  "register ADC1_CLP3   : UInt32 at 0x400BB040 // ADC plus-side general calibration value register\n"
  "register ADC1_CLP2   : UInt32 at 0x400BB044 // ADC plus-side general calibration value register\n"
  "register ADC1_CLP1   : UInt32 at 0x400BB048 // ADC plus-side general calibration value register\n"
  "register ADC1_CLP0   : UInt32 at 0x400BB04C // ADC plus-side general calibration value register\n"
  "register ADC1_PGA    : UInt32 at 0x400BB050 // ADC Programmable Gain Amplifier\n"
  "register ADC1_CLMD   : UInt32 at 0x400BB054 // ADC minus-side general calibration value register\n"
  "register ADC1_CLMS   : UInt32 at 0x400BB058 // ADC minus-side general calibration value register\n"
  "register ADC1_CLM4   : UInt32 at 0x400BB05C // ADC minus-side general calibration value register\n"
  "register ADC1_CLM3   : UInt32 at 0x400BB060 // ADC minus-side general calibration value register\n"
  "register ADC1_CLM2   : UInt32 at 0x400BB064 // ADC minus-side general calibration value register\n"
  "register ADC1_CLM1   : UInt32 at 0x400BB068 // ADC minus-side general calibration value register\n"
  "register ADC1_CLM0   : UInt32 at 0x400BB06C // ADC minus-side general calibration value register\n"
  "\n"
  "register DAC0_DAT0L : UInt8 at 0x400CC000 // DAC Data Low Register \n"
  "register DAC0_DATH  : UInt8 at 0x400CC001 // DAC Data High Register \n"
  "register DAC0_DAT1L : UInt8 at 0x400CC002 // DAC Data Low Register \n"
  "register DAC0_DAT2L : UInt8 at 0x400CC004 // DAC Data Low Register \n"
  "register DAC0_DAT3L : UInt8 at 0x400CC006 // DAC Data Low Register \n"
  "register DAC0_DAT4L : UInt8 at 0x400CC008 // DAC Data Low Register \n"
  "register DAC0_DAT5L : UInt8 at 0x400CC00A // DAC Data Low Register \n"
  "register DAC0_DAT6L : UInt8 at 0x400CC00C // DAC Data Low Register \n"
  "register DAC0_DAT7L : UInt8 at 0x400CC00E // DAC Data Low Register \n"
  "register DAC0_DAT8L : UInt8 at 0x400CC010 // DAC Data Low Register \n"
  "register DAC0_DAT9L : UInt8 at 0x400CC012 // DAC Data Low Register \n"
  "register DAC0_DAT10L : UInt8 at 0x400CC014 // DAC Data Low Register \n"
  "register DAC0_DAT11L : UInt8 at 0x400CC016 // DAC Data Low Register \n"
  "register DAC0_DAT12L : UInt8 at 0x400CC018 // DAC Data Low Register \n"
  "register DAC0_DAT13L : UInt8 at 0x400CC01A // DAC Data Low Register \n"
  "register DAC0_DAT14L : UInt8 at 0x400CC01C // DAC Data Low Register \n"
  "register DAC0_DAT15L : UInt8 at 0x400CC01E // DAC Data Low Register \n"
  "register DAC0_SR     : UInt8 at 0x400CC020 // DAC Status Register \n"
  "register DAC0_C0     : UInt8 at 0x400CC021 // DAC Control Register \n"
  "let DAC_C0_DACEN  : UInt8 = 0x80    // DAC Enable\n"
  "let DAC_C0_DACRFS : UInt8 = 0x40    // DAC Reference Select\n"
  "let DAC_C0_DACTRGSEL : UInt8 = 0x20    // DAC Trigger Select\n"
  "let DAC_C0_DACSWTRG  : UInt8 = 0x10    // DAC Software Trigger\n"
  "let DAC_C0_LPEN  : UInt8 = 0x08    // DAC Low Power Control\n"
  "let DAC_C0_DACBWIEN  : UInt8 = 0x04    // DAC Buffer Watermark Interrupt Enable\n"
  "let DAC_C0_DACBTIEN : UInt8 = 0x02    // DAC Buffer Read Pointer Top Flag Interrupt Enable\n"
  "let DAC_C0_DACBBIEN : UInt8 = 0x01    // DAC Buffer Read Pointer Bottom Flag Interrupt Enable\n"
  "\n"
  "register DAC0_C1  : UInt8 at 0x400CC022 // DAC Control Register 1 \n"
  "let DAC_C1_DMAEN : UInt8 = 0x80    // DMA Enable Select\n"
  "//register DAC_C1_DACBFWM(n)  (((n) & 3) << 3)  // DAC Buffer Watermark Select\n"
  "//register DAC_C1_DACBFMD(n)  (((n) & 3) << 0)  // DAC Buffer Work Mode Select\n"
  "let DAC_C1_DACBFEN : UInt8 = 0x00    // DAC Buffer Enable\n"
  "//\n"
  "register DAC0_C2  : UInt8 at 0x400CC023 // DAC Control Register 2 \n"
  "//register DAC_C2_DACBFRP(n)  (((n) & 15) << 4)  // DAC Buffer Read Pointer\n"
  "//register DAC_C2_DACBFUP(n)  (((n) & 15) << 0)  // DAC Buffer Upper Limit\n"
  "//\n"
  "//\n"
  "////register MCG_C2_RANGE0(n)  (uint8_t)(((n) & 0x03) << 4) // Frequency Range Select, Selects the frequency range for the crystal oscillator\n"
  "////register MCG_C2_LOCRE0   (uint8_t)0x80   // Loss of Clock Reset Enable, Determines whether an interrupt or a reset request is made following a los"
  "s of OSC0 \n"
  "//\n"
  "//// Chapter 32: Comparator (CMP)\n"
  "register CMP0_CR0   : UInt8 at 0x40073000 // CMP Control Register 0\n"
  "register CMP0_CR1   : UInt8 at 0x40073001 // CMP Control Register 1\n"
  "register CMP0_FPR   : UInt8 at 0x40073002 // CMP Filter Period Register\n"
  "register CMP0_SCR   : UInt8 at 0x40073003 // CMP Status and Control Register\n"
  "register CMP0_DACCR : UInt8 at 0x40073004 // DAC Control Register\n"
  "register CMP0_MUXCR : UInt8 at 0x40073005 // MUX Control Register\n"
  "register CMP1_CR0   : UInt8 at 0x40073008 // CMP Control Register 0\n"
  "register CMP1_CR1   : UInt8 at 0x40073009 // CMP Control Register 1\n"
  "register CMP1_FPR   : UInt8 at 0x4007300A // CMP Filter Period Register\n"
  "register CMP1_SCR   : UInt8 at 0x4007300B // CMP Status and Control Register\n"
  "register CMP1_DACCR : UInt8 at 0x4007300C // DAC Control Register\n"
  "register CMP1_MUXCR : UInt8 at 0x4007300D // MUX Control Register\n"
  "//\n"
  "//// Chapter 33: Voltage Reference (VREFV1)\n"
  "register VREF_TRM  : UInt8 at 0x40074000 // VREF Trim Register\n"
  "register VREF_SC   : UInt8 at 0x40074001 // VREF Status and Control Register\n"
  "//\n"
  "//// Chapter 34: Programmable Delay Block (PDB)\n"
  "//register PDB0_SC    0x40036000 // Status and Control Register\n"
  "//register PDB_SC_LDMOD(n)   (((n) & 3) << 18) // Load Mode Select\n"
  "//register PDB_SC_PDBEIE   0x00020000  // Sequence Error Interrupt Enable\n"
  "//register PDB_SC_SWTRIG   0x00010000  // Software Trigger\n"
  "//register PDB_SC_DMAEN   0x00008000  // DMA Enable\n"
  "//register PDB_SC_PRESCALER(n)  (((n) & 7) << 12) // Prescaler Divider Select\n"
  "//register PDB_SC_TRGSEL(n)  (((n) & 15) << 8) // Trigger Input Source Select\n"
  "//register PDB_SC_PDBEN   0x00000080  // PDB Enable\n"
  "//register PDB_SC_PDBIF   0x00000040  // PDB Interrupt Flag\n"
  "//register PDB_SC_PDBIE   0x00000020  // PDB Interrupt Enable.\n"
  "//register PDB_SC_MULT(n)   (((n) & 3) << 2) // Multiplication Factor\n"
  "//register PDB_SC_CONT   0x00000002  // Continuous Mode Enable\n"
  "//register PDB_SC_LDOK   0x00000001  // Load OK\n"
  "//register PDB0_MOD   0x40036004 // Modulus Register\n"
  "//register PDB0_CNT   0x40036008 // Counter Register\n"
  "//register PDB0_IDLY   0x4003600C // Interrupt Delay Register\n"
  "//register PDB0_CH0C1   0x40036010 // Channel n Control Register 1\n"
  "//register PDB0_CH0S   0x40036014 // Channel n Status Register\n"
  "//register PDB0_CH0DLY0   0x40036018 // Channel n Delay 0 Register\n"
  "//register PDB0_CH0DLY1   0x4003601C // Channel n Delay 1 Register\n"
  "//register PDB0_POEN   0x40036190 // Pulse-Out n Enable Register\n"
  "//register PDB0_PO0DLY   0x40036194 // Pulse-Out n Delay Register\n"
  "//register PDB0_PO1DLY   0x40036198 // Pulse-Out n Delay Register\n"
  "//\n"
  "//// Chapter 35: FlexTimer Module (FTM)\n"
  "//register FTM0_SC    0x40038000 // Status And Control\n"
  "//register FTM_SC_TOF   0x80    // Timer Overflow Flag\n"
  "//register FTM_SC_TOIE   0x40    // Timer Overflow Interrupt Enable\n"
  "//register FTM_SC_CPWMS   0x20    // Center-Aligned PWM Select\n"
  "//register FTM_SC_CLKS(n)   (((n) & 3) << 3)  // Clock Source Selection\n"
  "//register FTM_SC_PS(n)   (((n) & 7) << 0)  // Prescale Factor Selection\n"
  "//register FTM0_CNT   0x40038004 // Counter\n"
  "//register FTM0_MOD   0x40038008 // Modulo\n"
  "//register FTM0_C0SC   0x4003800C // Channel 0 Status And Control\n"
  "//register FTM0_C0V   0x40038010 // Channel 0 Value\n"
  "//register FTM0_C1SC   0x40038014 // Channel 1 Status And Control\n"
  "//register FTM0_C1V   0x40038018 // Channel 1 Value\n"
  "//register FTM0_C2SC   0x4003801C // Channel 2 Status And Control\n"
  "//register FTM0_C2V   0x40038020 // Channel 2 Value\n"
  "//register FTM0_C3SC   0x40038024 // Channel 3 Status And Control\n"
  "//register FTM0_C3V   0x40038028 // Channel 3 Value\n"
  "//register FTM0_C4SC   0x4003802C // Channel 4 Status And Control\n"
  "//register FTM0_C4V   0x40038030 // Channel 4 Value\n"
  "//register FTM0_C5SC   0x40038034 // Channel 5 Status And Control\n"
  "//register FTM0_C5V   0x40038038 // Channel 5 Value\n"
  "//register FTM0_C6SC   0x4003803C // Channel 6 Status And Control\n"
  "//register FTM0_C6V   0x40038040 // Channel 6 Value\n"
  "//register FTM0_C7SC   0x40038044 // Channel 7 Status And Control\n"
  "//register FTM0_C7V   0x40038048 // Channel 7 Value\n"
  "//register FTM0_CNTIN   0x4003804C // Counter Initial Value\n"
  "//register FTM0_STATUS   0x40038050 // Capture And Compare Status\n"
  "//register FTM0_MODE   0x40038054 // Features Mode Selection\n"
  "//register FTM_MODE_FAULTIE  0x80    // Fault Interrupt Enable\n"
  "//register FTM_MODE_FAULTM(n)  (((n) & 3) << 5)  // Fault Control Mode\n"
  "//register FTM_MODE_CAPTEST  0x10    // Capture Test Mode Enable\n"
  "//register FTM_MODE_PWMSYNC  0x08    // PWM Synchronization Mode\n"
  "//register FTM_MODE_WPDIS   0x04    // Write Protection Disable\n"
  "//register FTM_MODE_INIT   0x02    // Initialize The Channels Output\n"
  "//register FTM_MODE_FTMEN   0x01    // FTM Enable\n"
  "//register FTM0_SYNC   0x40038058 // Synchronization\n"
  "//register FTM_SYNC_SWSYNC   0x80    // \n"
  "//register FTM_SYNC_TRIG2   0x40    // \n"
  "//register FTM_SYNC_TRIG1   0x20    // \n"
  "//register FTM_SYNC_TRIG0   0x10    // \n"
  "//register FTM_SYNC_SYNCHOM  0x08    // \n"
  "//register FTM_SYNC_REINIT   0x04    // \n"
  "//register FTM_SYNC_CNTMAX   0x02    // \n"
  "//register FTM_SYNC_CNTMIN   0x01    // \n"
  "//register FTM0_OUTINIT   0x4003805C // Initial State For Channels Output\n"
  "//register FTM0_OUTMASK   0x40038060 // Output Mask\n"
  "//register FTM0_COMBINE   0x40038064 // Function For Linked Channels\n"
  "//register FTM0_DEADTIME   0x40038068 // Deadtime Insertion Control\n"
  "//register FTM0_EXTTRIG   0x4003806C // FTM External Trigger\n"
  "//register FTM0_POL   0x40038070 // Channels Polarity\n"
  "//register FTM0_FMS   0x40038074 // Fault Mode Status\n"
  "//register FTM0_FILTER   0x40038078 // Input Capture Filter Control\n"
  "//register FTM0_FLTCTRL   0x4003807C // Fault Control\n"
  "//register FTM0_QDCTRL   0x40038080 // Quadrature Decoder Control And Status\n"
  "//register FTM0_CONF   0x40038084 // Configuration\n"
  "//register FTM0_FLTPOL   0x40038088 // FTM Fault Input Polarity\n"
  "//register FTM0_SYNCONF   0x4003808C // Synchronization Configuration\n"
  "//register FTM0_INVCTRL   0x40038090 // FTM Inverting Control\n"
  "//register FTM0_SWOCTRL   0x40038094 // FTM Software Output Control\n"
  "//register FTM0_PWMLOAD   0x40038098 // FTM PWM Load\n"
  "//register FTM1_SC    0x40039000 // Status And Control\n"
  "//register FTM1_CNT   0x40039004 // Counter\n"
  "//register FTM1_MOD   0x40039008 // Modulo\n"
  "//register FTM1_C0SC   0x4003900C // Channel 0 Status And Control\n"
  "//register FTM1_C0V   0x40039010 // Channel 0 Value\n"
  "//register FTM1_C1SC   0x40039014 // Channel 1 Status And Control\n"
  "//register FTM1_C1V   0x40039018 // Channel 1 Value\n"
  "//register FTM1_CNTIN   0x4003904C // Counter Initial Value\n"
  "//register FTM1_STATUS   0x40039050 // Capture And Compare Status\n"
  "//register FTM1_MODE   0x40039054 // Features Mode Selection\n"
  "//register FTM1_SYNC   0x40039058 // Synchronization\n"
  "//register FTM1_OUTINIT   0x4003905C // Initial State For Channels Output\n"
  "//register FTM1_OUTMASK   0x40039060 // Output Mask\n"
  "//register FTM1_COMBINE   0x40039064 // Function For Linked Channels\n"
  "//register FTM1_DEADTIME   0x40039068 // Deadtime Insertion Control\n"
  "//register FTM1_EXTTRIG   0x4003906C // FTM External Trigger\n"
  "//register FTM1_POL   0x40039070 // Channels Polarity\n"
  "//register FTM1_FMS   0x40039074 // Fault Mode Status\n"
  "//register FTM1_FILTER   0x40039078 // Input Capture Filter Control\n"
  "//register FTM1_FLTCTRL   0x4003907C // Fault Control\n"
  "//register FTM1_QDCTRL   0x40039080 // Quadrature Decoder Control And Status\n"
  "//register FTM1_CONF   0x40039084 // Configuration\n"
  "//register FTM1_FLTPOL   0x40039088 // FTM Fault Input Polarity\n"
  "//register FTM1_SYNCONF   0x4003908C // Synchronization Configuration\n"
  "//register FTM1_INVCTRL   0x40039090 // FTM Inverting Control\n"
  "//register FTM1_SWOCTRL   0x40039094 // FTM Software Output Control\n"
  "//register FTM1_PWMLOAD   0x40039098 // FTM PWM Load\n"
  "//register FTM2_SC    0x400B8000 // Status And Control\n"
  "//register FTM2_CNT   0x400B8004 // Counter\n"
  "//register FTM2_MOD   0x400B8008 // Modulo\n"
  "//register FTM2_C0SC   0x400B800C // Channel 0 Status And Control\n"
  "//register FTM2_C0V   0x400B8010 // Channel 0 Value\n"
  "//register FTM2_C1SC   0x400B8014 // Channel 1 Status And Control\n"
  "//register FTM2_C1V   0x400B8018 // Channel 1 Value\n"
  "//register FTM2_CNTIN   0x400B804C // Counter Initial Value\n"
  "//register FTM2_STATUS   0x400B8050 // Capture And Compare Status\n"
  "//register FTM2_MODE   0x400B8054 // Features Mode Selection\n"
  "//register FTM2_SYNC   0x400B8058 // Synchronization\n"
  "//register FTM2_OUTINIT   0x400B805C // Initial State For Channels Output\n"
  "//register FTM2_OUTMASK   0x400B8060 // Output Mask\n"
  "//register FTM2_COMBINE   0x400B8064 // Function For Linked Channels\n"
  "//register FTM2_DEADTIME   0x400B8068 // Deadtime Insertion Control\n"
  "//register FTM2_EXTTRIG   0x400B806C // FTM External Trigger\n"
  "//register FTM2_POL   0x400B8070 // Channels Polarity\n"
  "//register FTM2_FMS   0x400B8074 // Fault Mode Status\n"
  "//register FTM2_FILTER   0x400B8078 // Input Capture Filter Control\n"
  "//register FTM2_FLTCTRL   0x400B807C // Fault Control\n"
  "//register FTM2_QDCTRL   0x400B8080 // Quadrature Decoder Control And Status\n"
  "//register FTM2_CONF   0x400B8084 // Configuration\n"
  "//register FTM2_FLTPOL   0x400B8088 // FTM Fault Input Polarity\n"
  "//register FTM2_SYNCONF   0x400B808C // Synchronization Configuration\n"
  "//register FTM2_INVCTRL   0x400B8090 // FTM Inverting Control\n"
  "//register FTM2_SWOCTRL   0x400B8094 // FTM Software Output Control\n"
  "//register FTM2_PWMLOAD   0x400B8098 // FTM PWM Load\n"
  "//\n"
  "//// Chapter 36: Periodic Interrupt Timer (PIT)\n"
  "//register PIT_MCR    0x40037000 // PIT Module Control Register\n"
  "//register PIT_LDVAL0   0x40037100 // Timer Load Value Register\n"
  "//register PIT_CVAL0   0x40037104 // Current Timer Value Register\n"
  "//register PIT_TCTRL0   0x40037108 // Timer Control Register\n"
  "//register PIT_TFLG0   0x4003710C // Timer Flag Register\n"
  "//register PIT_LDVAL1   0x40037110 // Timer Load Value Register\n"
  "//register PIT_CVAL1   0x40037114 // Current Timer Value Register\n"
  "//register PIT_TCTRL1   0x40037118 // Timer Control Register\n"
  "//register PIT_TFLG1   0x4003711C // Timer Flag Register\n"
  "//register PIT_LDVAL2   0x40037120 // Timer Load Value Register\n"
  "//register PIT_CVAL2   0x40037124 // Current Timer Value Register\n"
  "//register PIT_TCTRL2   0x40037128 // Timer Control Register\n"
  "//register PIT_TFLG2   0x4003712C // Timer Flag Register\n"
  "//register PIT_LDVAL3   0x40037130 // Timer Load Value Register\n"
  "//register PIT_CVAL3   0x40037134 // Current Timer Value Register\n"
  "//register PIT_TCTRL3   0x40037138 // Timer Control Register\n"
  "//register PIT_TFLG3   0x4003713C // Timer Flag Register\n"
  "//\n"
  "//// Chapter 37: Low-Power Timer (LPTMR)\n"
  "//register LPTMR0_CSR   0x40040000 // Low Power Timer Control Status Register\n"
  "//register LPTMR0_PSR   0x40040004 // Low Power Timer Prescale Register\n"
  "//register LPTMR0_CMR   0x40040008 // Low Power Timer Compare Register\n"
  "//register LPTMR0_CNR   0x4004000C // Low Power Timer Counter Register\n"
  "//\n"
  "//// Chapter 38: Carrier Modulator Transmitter (CMT)\n"
  "//register CMT_CGH1  *(volatile uint8_t  *)0x40062000 // CMT Carrier Generator High Data Register 1\n"
  "//register CMT_CGL1  *(volatile uint8_t  *)0x40062001 // CMT Carrier Generator Low Data Register 1\n"
  "//register CMT_CGH2  *(volatile uint8_t  *)0x40062002 // CMT Carrier Generator High Data Register 2\n"
  "//register CMT_CGL2  *(volatile uint8_t  *)0x40062003 // CMT Carrier Generator Low Data Register 2\n"
  "//register CMT_OC   *(volatile uint8_t  *)0x40062004 // CMT Output Control Register\n"
  "//register CMT_MSC   *(volatile uint8_t  *)0x40062005 // CMT Modulator Status and Control Register\n"
  "//register CMT_CMD1  *(volatile uint8_t  *)0x40062006 // CMT Modulator Data Register Mark High\n"
  "//register CMT_CMD2  *(volatile uint8_t  *)0x40062007 // CMT Modulator Data Register Mark Low\n"
  "//register CMT_CMD3  *(volatile uint8_t  *)0x40062008 // CMT Modulator Data Register Space High\n"
  "//register CMT_CMD4  *(volatile uint8_t  *)0x40062009 // CMT Modulator Data Register Space Low\n"
  "//register CMT_PPS   *(volatile uint8_t  *)0x4006200A // CMT Primary Prescaler Register\n"
  "//register CMT_DMA   *(volatile uint8_t  *)0x4006200B // CMT Direct Memory Access Register\n"
  "//\n"
  "//// Chapter 39: Real Time Clock (RTC)\n"
  "register RTC_TSR : UInt32 at  0x4003D000 // RTC Time Seconds Register\n"
  "register RTC_TPR : UInt32 at  0x4003D004 // RTC Time Prescaler Register\n"
  "register RTC_TAR : UInt32 at  0x4003D008 // RTC Time Alarm Register\n"
  "register RTC_TCR : UInt32 at  0x4003D00C // RTC Time Compensation Register\n"
  "//register RTC_TCR_CIC(n)   (((n) & 255) << 24)  // Compensation Interval Counter\n"
  "//register RTC_TCR_TCV(n)   (((n) & 255) << 16)  // Time Compensation Value\n"
  "//register RTC_TCR_CIR(n)   (((n) & 255) << 8)  // Compensation Interval Register\n"
  "//register RTC_TCR_TCR(n)   (((n) & 255) << 0)  // Time Compensation Register\n"
  "register RTC_CR : UInt32 at  0x4003D010 // RTC Control Register\n"
  "let RTC_CR_SC2P : UInt32 = 0x00002000  // \n"
  "let RTC_CR_SC4P : UInt32 = 0x00001000  // \n"
  "let RTC_CR_SC8P : UInt32 = 0x00000800  // \n"
  "let RTC_CR_SC16P : UInt32 = 0x00000400  // \n"
  "let RTC_CR_CLKO : UInt32 = 0x00000200  // \n"
  "let RTC_CR_OSCE : UInt32 = 0x00000100  // \n"
  "let RTC_CR_UM : UInt32 = 0x00000008  // \n"
  "let RTC_CR_SUP : UInt32 = 0x00000004  // \n"
  "let RTC_CR_WPE : UInt32 = 0x00000002  // \n"
  "let RTC_CR_SWR : UInt32 = 0x00000001  // \n"
  "register RTC_SR : UInt32 at  0x4003D014 // RTC Status Register\n"
  "let RTC_SR_TCE : UInt32 = 0x00000010  // \n"
  "let RTC_SR_TAF : UInt32 = 0x00000004  // \n"
  "let RTC_SR_TOF : UInt32 = 0x00000002  // \n"
  "let RTC_SR_TIF : UInt32 = 0x00000001  // \n"
  "register RTC_LR: UInt32 at 0x4003D018 // RTC Lock Register\n"
  "register RTC_IER: UInt32 at 0x4003D01C // RTC Interrupt Enable Register\n"
  "register RTC_WAR: UInt32 at 0x4003D800 // RTC Write Access Register\n"
  "register RTC_RAR: UInt32 at 0x4003D804 // RTC Read Access Register\n"
  "\n"
  "//// Chapter 40: Universal Serial Bus OTG Controller (USBOTG)\n"
  "//register USB0_PERID  *(const    uint8_t  *)0x40072000 // Peripheral ID register\n"
  "//register USB0_IDCOMP  *(const    uint8_t  *)0x40072004 // Peripheral ID Complement register\n"
  "//register USB0_REV  *(const    uint8_t  *)0x40072008 // Peripheral Revision register\n"
  "//register USB0_ADDINFO  *(volatile uint8_t  *)0x4007200C // Peripheral Additional Info register\n"
  "//register USB0_OTGIST *(volatile uint8_t  *)0x40072010 // OTG Interrupt Status register\n"
  "//register USB_OTGISTAT_IDCHG  (uint8_t)0x80   //\n"
  "//register USB_OTGISTAT_ONEMSEC  (uint8_t)0x40   //\n"
  "//register USB_OTGISTAT_LINE_STATE_CHG (uint8_t)0x20   //\n"
  "//register USB_OTGISTAT_SESSVLDCHG  (uint8_t)0x08   //\n"
  "//register USB_OTGISTAT_B_SESS_CHG  (uint8_t)0x04   //\n"
  "//register USB_OTGISTAT_AVBUSCHG  (uint8_t)0x01   //\n"
  "//register USB0_OTGICR  *(volatile uint8_t  *)0x40072014 // OTG Interrupt Control Register\n"
  "//register USB_OTGICR_IDEN   (uint8_t)0x80   // \n"
  "//register USB_OTGICR_ONEMSECEN  (uint8_t)0x40   // \n"
  "//register USB_OTGICR_LINESTATEEN  (uint8_t)0x20   // \n"
  "//register USB_OTGICR_SESSVLDEN  (uint8_t)0x08   // \n"
  "//register USB_OTGICR_BSESSEN  (uint8_t)0x04   // \n"
  "//register USB_OTGICR_AVBUSEN  (uint8_t)0x01   // \n"
  "//register USB0_OTGST *(volatile uint8_t  *)0x40072018 // OTG Status register\n"
  "//register USB_OTGSTAT_ID   (uint8_t)0x80   // \n"
  "//register USB_OTGSTAT_ONEMSECEN  (uint8_t)0x40   // \n"
  "//register USB_OTGSTAT_LINESTATESTABLE (uint8_t)0x20   // \n"
  "//register USB_OTGSTAT_SESS_VLD  (uint8_t)0x08   // \n"
  "//register USB_OTGSTAT_BSESSEND  (uint8_t)0x04   // \n"
  "//register USB_OTGSTAT_AVBUSVLD  (uint8_t)0x01   // \n"
  "//register USB0_OTGCTL  *(volatile uint8_t  *)0x4007201C // OTG Control Register\n"
  "//register USB_OTGCTL_DPHIGH  (uint8_t)0x80   // \n"
  "//register USB_OTGCTL_DPLOW  (uint8_t)0x20   // \n"
  "//register USB_OTGCTL_DMLOW  (uint8_t)0x10   // \n"
  "//register USB_OTGCTL_OTGEN  (uint8_t)0x04   // \n"
  "//register USB0_IST *(volatile uint8_t  *)0x40072080 // Interrupt Status Register\n"
  "//register USB_ISTAT_STALL   (uint8_t)0x80   // \n"
  "//register USB_ISTAT_ATTACH  (uint8_t)0x40   // \n"
  "//register USB_ISTAT_RESUME  (uint8_t)0x20   // \n"
  "//register USB_ISTAT_SLEEP   (uint8_t)0x10   // \n"
  "//register USB_ISTAT_TOKDNE  (uint8_t)0x08   // \n"
  "//register USB_ISTAT_SOFTOK  (uint8_t)0x04   // \n"
  "//register USB_ISTAT_ERROR   (uint8_t)0x02   // \n"
  "//register USB_ISTAT_USBRST  (uint8_t)0x01   // \n"
  "//register USB0_INTEN  *(volatile uint8_t  *)0x40072084 // Interrupt Enable Register\n"
  "//register USB_INTEN_STALLEN  (uint8_t)0x80   // \n"
  "//register USB_INTEN_ATTACHEN  (uint8_t)0x40   // \n"
  "//register USB_INTEN_RESUMEEN  (uint8_t)0x20   // \n"
  "//register USB_INTEN_SLEEPEN  (uint8_t)0x10   // \n"
  "//register USB_INTEN_TOKDNEEN  (uint8_t)0x08   // \n"
  "//register USB_INTEN_SOFTOKEN  (uint8_t)0x04   // \n"
  "//register USB_INTEN_ERROREN  (uint8_t)0x02   // \n"
  "//register USB_INTEN_USBRSTEN  (uint8_t)0x01   // \n"
  "//register USB0_ERRST *(volatile uint8_t  *)0x40072088 // Error Interrupt Status Register\n"
  "//register USB_ERRSTAT_BTSERR  (uint8_t)0x80   // \n"
  "//register USB_ERRSTAT_DMAERR  (uint8_t)0x20   // \n"
  "//register USB_ERRSTAT_BTOERR  (uint8_t)0x10   // \n"
  "//register USB_ERRSTAT_DFN8  (uint8_t)0x08   // \n"
  "//register USB_ERRSTAT_CRC16  (uint8_t)0x04   // \n"
  "//register USB_ERRSTAT_CRC5EOF  (uint8_t)0x02   // \n"
  "//register USB_ERRSTAT_PIDERR  (uint8_t)0x01   // \n"
  "//register USB0_ERREN  *(volatile uint8_t  *)0x4007208C // Error Interrupt Enable Register\n"
  "//register USB_ERREN_BTSERREN  (uint8_t)0x80   // \n"
  "//register USB_ERREN_DMAERREN  (uint8_t)0x20   // \n"
  "//register USB_ERREN_BTOERREN  (uint8_t)0x10   // \n"
  "//register USB_ERREN_DFN8EN  (uint8_t)0x08   // \n"
  "//register USB_ERREN_CRC16EN  (uint8_t)0x04   // \n"
  "//register USB_ERREN_CRC5EOFEN  (uint8_t)0x02   // \n"
  "//register USB_ERREN_PIDERREN  (uint8_t)0x01   // \n"
  "//register USB0_ST *(volatile uint8_t  *)0x40072090 // Status Register\n"
  "//register USB_STAT_TX   (uint8_t)0x08   // \n"
  "//register USB_STAT_ODD   (uint8_t)0x04   // \n"
  "//register USB_STAT_ENDP(n)  (uint8_t)((n) >> 4)  // \n"
  "//register USB0_CTL  *(volatile uint8_t  *)0x40072094 // Control Register\n"
  "//register USB_CTL_JSTATE   (uint8_t)0x80   // \n"
  "//register USB_CTL_SE0   (uint8_t)0x40   // \n"
  "//register USB_CTL_TXSUSPENDTOKENBUSY (uint8_t)0x20   // \n"
  "//register USB_CTL_RESET   (uint8_t)0x10   // \n"
  "//register USB_CTL_HOSTMODEEN  (uint8_t)0x08   // \n"
  "//register USB_CTL_RESUME   (uint8_t)0x04   // \n"
  "//register USB_CTL_ODDRST   (uint8_t)0x02   // \n"
  "//register USB_CTL_USBENSOFEN  (uint8_t)0x01   // \n"
  "//register USB0_ADDR  *(volatile uint8_t  *)0x40072098 // Address Register\n"
  "//register USB0_BDTPAGE1  *(volatile uint8_t  *)0x4007209C // BDT Page Register 1\n"
  "//register USB0_FRMNUML  *(volatile uint8_t  *)0x400720A0 // Frame Number Register Low\n"
  "//register USB0_FRMNUMH  *(volatile uint8_t  *)0x400720A4 // Frame Number Register High\n"
  "//register USB0_TOKEN  *(volatile uint8_t  *)0x400720A8 // Token Register\n"
  "//register USB0_SOFTHLD  *(volatile uint8_t  *)0x400720AC // SOF Threshold Register\n"
  "//register USB0_BDTPAGE2  *(volatile uint8_t  *)0x400720B0 // BDT Page Register 2\n"
  "//register USB0_BDTPAGE3  *(volatile uint8_t  *)0x400720B4 // BDT Page Register 3\n"
  "//register USB0_ENDPT0  *(volatile uint8_t  *)0x400720C0 // Endpoint Control Register\n"
  "//register USB_ENDPT_HOSTWOHUB  (uint8_t)0x80   // host only, enable low speed\n"
  "//register USB_ENDPT_RETRYDIS  (uint8_t)0x40   // host only, set to disable NAK retry\n"
  "//register USB_ENDPT_EPCTLDIS  (uint8_t)0x10   // 0=control, 1=bulk, interrupt, isync\n"
  "//register USB_ENDPT_EPRXEN  (uint8_t)0x08   // enables the endpoint for RX transfers.\n"
  "//register USB_ENDPT_EPTXEN  (uint8_t)0x04   // enables the endpoint for TX transfers.\n"
  "//register USB_ENDPT_EPSTALL  (uint8_t)0x02   // set to stall endpoint\n"
  "//register USB_ENDPT_EPHSHK  (uint8_t)0x01   // enable handshaking during a transaction, generally set unless Isochronous\n"
  "//register USB0_ENDPT1  *(volatile uint8_t  *)0x400720C4 // Endpoint Control Register\n"
  "//register USB0_ENDPT2  *(volatile uint8_t  *)0x400720C8 // Endpoint Control Register\n"
  "//register USB0_ENDPT3  *(volatile uint8_t  *)0x400720CC // Endpoint Control Register\n"
  "//register USB0_ENDPT4  *(volatile uint8_t  *)0x400720D0 // Endpoint Control Register\n"
  "//register USB0_ENDPT5  *(volatile uint8_t  *)0x400720D4 // Endpoint Control Register\n"
  "//register USB0_ENDPT6  *(volatile uint8_t  *)0x400720D8 // Endpoint Control Register\n"
  "//register USB0_ENDPT7  *(volatile uint8_t  *)0x400720DC // Endpoint Control Register\n"
  "//register USB0_ENDPT8  *(volatile uint8_t  *)0x400720E0 // Endpoint Control Register\n"
  "//register USB0_ENDPT9  *(volatile uint8_t  *)0x400720E4 // Endpoint Control Register\n"
  "//register USB0_ENDPT10  *(volatile uint8_t  *)0x400720E8 // Endpoint Control Register\n"
  "//register USB0_ENDPT11  *(volatile uint8_t  *)0x400720EC // Endpoint Control Register\n"
  "//register USB0_ENDPT12  *(volatile uint8_t  *)0x400720F0 // Endpoint Control Register\n"
  "//register USB0_ENDPT13  *(volatile uint8_t  *)0x400720F4 // Endpoint Control Register\n"
  "//register USB0_ENDPT14  *(volatile uint8_t  *)0x400720F8 // Endpoint Control Register\n"
  "//register USB0_ENDPT15  *(volatile uint8_t  *)0x400720FC // Endpoint Control Register\n"
  "//register USB0_USBCTRL  *(volatile uint8_t  *)0x40072100 // USB Control Register\n"
  "//register USB_USBCTRL_SUSP  (uint8_t)0x80   // Places the USB transceiver into the suspend state.\n"
  "//register USB_USBCTRL_PDE   (uint8_t)0x40   // Enables the weak pulldowns on the USB transceiver.\n"
  "//register USB0_OBSERVE  *(volatile uint8_t  *)0x40072104 // USB OTG Observe Register\n"
  "//register USB_OBSERVE_DPPU  (uint8_t)0x80   // \n"
  "//register USB_OBSERVE_DPPD  (uint8_t)0x40   // \n"
  "//register USB_OBSERVE_DMPD  (uint8_t)0x10   // \n"
  "//register USB0_CONTROL  *(volatile uint8_t  *)0x40072108 // USB OTG Control Register\n"
  "//register USB_CONTROL_DPPULLUPNONOTG (uint8_t)0x10   //  Provides control of the DP PULLUP in the USB OTG module, if USB is configured in non-OTG dev"
  "ice mode.\n"
  "//register USB0_USBTRC0  *(volatile uint8_t  *)0x4007210C // USB Transceiver Control Register 0\n"
  "//register USB_USBTRC_USBRESET  (uint8_t)0x80   //\n"
  "//register USB_USBTRC_USBRESMEN  (uint8_t)0x20   //\n"
  "//register USB_USBTRC_SYNC_DET  (uint8_t)0x02   //\n"
  "//register USB_USBTRC_USB_RESUME_INT (uint8_t)0x01   //\n"
  "//register USB0_USBFRMADJUST *(volatile uint8_t  *)0x40072114 // Frame Adjust Register\n"
  "//\n"
  "//// Chapter 41: USB Device Charger Detection Module (USBDCD)\n"
  "//register USBDCD_CONTROL   0x40035000 // Control register\n"
  "//register USBDCD_CLOCK   0x40035004 // Clock register\n"
  "//register USBDCD_STATUS   0x40035008 // Status register\n"
  "//register USBDCD_TIMER0   0x40035010 // TIMER0 register\n"
  "//register USBDCD_TIMER1   0x40035014 // TIMER1 register\n"
  "//register USBDCD_TIMER2   0x40035018 // TIMER2 register\n"
  "//\n"
  "//// Chapter 43: SPI (DSPI)\n"
  "//register SPI0_MCR   0x4002C000 // DSPI Module Configuration Register\n"
  "//register SPI_MCR_MSTR    0x80000000  // Master/Slave Mode Select\n"
  "//register SPI_MCR_CONT_SCKE   0x40000000  // \n"
  "//register SPI_MCR_DCONF(n)  (((n) & 3) << 28)  // \n"
  "//register SPI_MCR_FRZ    0x08000000  // \n"
  "//register SPI_MCR_MTFE    0x04000000  // \n"
  "//register SPI_MCR_ROOE    0x01000000  // \n"
  "//register SPI_MCR_PCSIS(n)  (((n) & 0x1F) << 16)  //\n"
  "//register SPI_MCR_DOZE    0x00008000  // \n"
  "//register SPI_MCR_MDIS    0x00004000  // \n"
  "//register SPI_MCR_DIS_TXF    0x00002000  // \n"
  "//register SPI_MCR_DIS_RXF    0x00001000  // \n"
  "//register SPI_MCR_CLR_TXF    0x00000800  // \n"
  "//register SPI_MCR_CLR_RXF    0x00000400  // \n"
  "//register SPI_MCR_SMPL_PT(n)  (((n) & 3) << 8)  //\n"
  "//register SPI_MCR_HALT    0x00000001  // \n"
  "//register SPI0_TCR   0x4002C008 // DSPI Transfer Count Register\n"
  "//register SPI0_CTAR0   0x4002C00C // DSPI Clock and Transfer Attributes Register, In Master Mode\n"
  "//register SPI_CTAR_DBR    0x80000000  // Double Baud Rate\n"
  "//register SPI_CTAR_FMSZ(n)  (((n) & 15) << 27)  // Frame Size (+1)\n"
  "//register SPI_CTAR_CPOL    0x04000000  // Clock Polarity\n"
  "//register SPI_CTAR_CPHA    0x02000000  // Clock Phase\n"
  "//register SPI_CTAR_LSBFE    0x01000000  // LSB First\n"
  "//register SPI_CTAR_PCSSCK(n)  (((n) & 3) << 22)  // PCS to SCK Delay Prescaler\n"
  "//register SPI_CTAR_PASC(n)  (((n) & 3) << 20)  // After SCK Delay Prescaler\n"
  "//register SPI_CTAR_PDT(n)   (((n) & 3) << 18)  // Delay after Transfer Prescaler\n"
  "//register SPI_CTAR_PBR(n)   (((n) & 3) << 16)  // Baud Rate Prescaler\n"
  "//register SPI_CTAR_CSSCK(n)  (((n) & 15) << 12)  // PCS to SCK Delay Scaler\n"
  "//register SPI_CTAR_ASC(n)   (((n) & 15) << 8)  // After SCK Delay Scaler\n"
  "//register SPI_CTAR_DT(n)   (((n) & 15) << 4)  // Delay After Transfer Scaler\n"
  "//register SPI_CTAR_BR(n)   (((n) & 15) << 0)  // Baud Rate Scaler\n"
  "//register SPI0_CTAR0_SLAVE  0x4002C00C // DSPI Clock and Transfer Attributes Register, In Slave Mode\n"
  "//register SPI0_CTAR1   0x4002C010 // DSPI Clock and Transfer Attributes Register, In Master Mode\n"
  "//register SPI0_SR    0x4002C02C // DSPI Status Register\n"
  "//register SPI_SR_TCF    0x80000000  // Transfer Complete Flag\n"
  "//register SPI_SR_TXRXS    0x40000000  // TX and RX Status\n"
  "//register SPI_SR_EOQF    0x10000000  // End of Queue Flag\n"
  "//register SPI_SR_TFUF    0x08000000  // Transmit FIFO Underflow Flag\n"
  "//register SPI_SR_TFFF    0x02000000  // Transmit FIFO Fill Flag\n"
  "//register SPI_SR_RFOF    0x00080000  // Receive FIFO Overflow Flag\n"
  "//register SPI_SR_RFDF    0x00020000  // Receive FIFO Drain Flag\n"
  "//register SPI0_RSER   0x4002C030 // DSPI DMA/Interrupt Request Select and Enable Register\n"
  "//register SPI_RSER_TCF_RE    0x80000000  // Transmission Complete Request Enable\n"
  "//register SPI_RSER_EOQF_RE   0x10000000  // DSPI Finished Request Request Enable\n"
  "//register SPI_RSER_TFUF_RE   0x08000000  // Transmit FIFO Underflow Request Enable\n"
  "//register SPI_RSER_TFFF_RE   0x02000000  // Transmit FIFO Fill Request Enable\n"
  "//register SPI_RSER_TFFF_DIRS   0x01000000  // Transmit FIFO FIll Dma or Interrupt Request Select\n"
  "//register SPI_RSER_RFOF_RE   0x00080000  // Receive FIFO Overflow Request Enable\n"
  "//register SPI_RSER_RFDF_RE   0x00020000  // Receive FIFO Drain Request Enable\n"
  "//register SPI_RSER_RFDF_DIRS   0x00010000  // Receive FIFO Drain DMA or Interrupt Request Select\n"
  "//register SPI0_PUSHR   0x4002C034 // DSPI PUSH TX FIFO Register In Master Mode\n"
  "//register SPI_PUSHR_CONT    0x80000000  // \n"
  "//register SPI_PUSHR_CTAS(n)  (((n) & 7) << 28)  // \n"
  "//register SPI_PUSHR_EOQ    0x08000000  // \n"
  "//register SPI_PUSHR_CTCNT    0x04000000  // \n"
  "//register SPI_PUSHR_PCS(n)  (((n) & 31) << 16)  //\n"
  "//register SPI0_PUSHR_SLAVE  0x4002C034 // DSPI PUSH TX FIFO Register In Slave Mode\n"
  "//register SPI0_POPR   0x4002C038 // DSPI POP RX FIFO Register\n"
  "//register SPI0_TXFR0   0x4002C03C // DSPI Transmit FIFO Registers\n"
  "//register SPI0_TXFR1   0x4002C040 // DSPI Transmit FIFO Registers\n"
  "//register SPI0_TXFR2   0x4002C044 // DSPI Transmit FIFO Registers\n"
  "//register SPI0_TXFR3   0x4002C048 // DSPI Transmit FIFO Registers\n"
  "//register SPI0_RXFR0   0x4002C07C // DSPI Receive FIFO Registers\n"
  "//register SPI0_RXFR1   0x4002C080 // DSPI Receive FIFO Registers\n"
  "//register SPI0_RXFR2   0x4002C084 // DSPI Receive FIFO Registers\n"
  "//register SPI0_RXFR3   0x4002C088 // DSPI Receive FIFO Registers\n"
  "//typedef struct {\n"
  "// volatile uint32_t MCR; // 0\n"
  "// volatile uint32_t unused1;// 4\n"
  "// volatile uint32_t TCR; // 8\n"
  "// volatile uint32_t CTAR0; // c\n"
  "// volatile uint32_t CTAR1; // 10\n"
  "// volatile uint32_t CTAR2; // 14\n"
  "// volatile uint32_t CTAR3; // 18\n"
  "// volatile uint32_t CTAR4; // 1c\n"
  "// volatile uint32_t CTAR5; // 20\n"
  "// volatile uint32_t CTAR6; // 24\n"
  "// volatile uint32_t CTAR7; // 28\n"
  "// volatile uint32_t SR; // 2c\n"
  "// volatile uint32_t RSER; // 30\n"
  "// volatile uint32_t PUSHR; // 34\n"
  "// volatile uint32_t POPR; // 38\n"
  "// volatile uint32_t TXFR[16]; // 3c\n"
  "// volatile uint32_t RXFR[16]; // 7c\n"
  "//} SPI_t;\n"
  "//register SPI0  (*(SPI_t *)0x4002C000)\n"
  "//\n"
  "//// Chapter 44: Inter-Integrated Circuit (I2C)\n"
  "//register I2C0_A1   *(volatile uint8_t  *)0x40066000 // I2C Address Register 1\n"
  "//register I2C0_F   *(volatile uint8_t  *)0x40066001 // I2C Frequency Divider register\n"
  "//register I2C0_C1   *(volatile uint8_t  *)0x40066002 // I2C Control Register 1\n"
  "//register I2C_C1_IICEN   (uint8_t)0x80   // I2C Enable\n"
  "//register I2C_C1_IICIE   (uint8_t)0x40   // I2C Interrupt Enable\n"
  "//register I2C_C1_MST   (uint8_t)0x20   // Master Mode Select\n"
  "//register I2C_C1_TX   (uint8_t)0x10   // Transmit Mode Select\n"
  "//register I2C_C1_TXAK   (uint8_t)0x08   // Transmit Acknowledge Enable\n"
  "//register I2C_C1_RSTA   (uint8_t)0x04   // RepeSTART\n"
  "//register I2C_C1_WUEN   (uint8_t)0x02   // Wakeup Enable\n"
  "//register I2C_C1_DMAEN   (uint8_t)0x01   // DMA Enable\n"
  "//register I2C0_S   *(volatile uint8_t  *)0x40066003 // I2C Status register\n"
  "//register I2C_S_TCF   (uint8_t)0x80   // Transfer Complete Flag\n"
  "//register I2C_S_IAAS   (uint8_t)0x40   // Addressed As A Slave\n"
  "//register I2C_S_BUSY   (uint8_t)0x20   // Bus Busy\n"
  "//register I2C_S_ARBL   (uint8_t)0x10   // Arbitration Lost\n"
  "//register I2C_S_RAM   (uint8_t)0x08   // Range Address Match\n"
  "//register I2C_S_SRW   (uint8_t)0x04   // Slave Read/Write\n"
  "//register I2C_S_IICIF   (uint8_t)0x02   // Interrupt Flag\n"
  "//register I2C_S_RXAK   (uint8_t)0x01   // Receive Acknowledge\n"
  "//register I2C0_D   *(volatile uint8_t  *)0x40066004 // I2C Data I/O register\n"
  "//register I2C0_C2   *(volatile uint8_t  *)0x40066005 // I2C Control Register 2\n"
  "//register I2C_C2_GCAEN   (uint8_t)0x80   // General Call Address Enable\n"
  "//register I2C_C2_ADEXT   (uint8_t)0x40   // Address Extension\n"
  "//register I2C_C2_HDRS   (uint8_t)0x20   // High Drive Select\n"
  "//register I2C_C2_SBRC   (uint8_t)0x10   // Slave Baud Rate Control\n"
  "//register I2C_C2_RMEN   (uint8_t)0x08   // Range Address Matching Enable\n"
  "//register I2C_C2_AD(n)   ((n) & 7)   // Slave Address, upper 3 bits\n"
  "//register I2C0_FLT  *(volatile uint8_t  *)0x40066006 // I2C Programmable Input Glitch Filter register\n"
  "//register I2C0_RA   *(volatile uint8_t  *)0x40066007 // I2C Range Address register\n"
  "//register I2C0_SMB  *(volatile uint8_t  *)0x40066008 // I2C SMBus Control and Status register\n"
  "//register I2C0_A2   *(volatile uint8_t  *)0x40066009 // I2C Address Register 2\n"
  "//register I2C0_SLTH  *(volatile uint8_t  *)0x4006600A // I2C SCL Low Timeout Register High\n"
  "//register I2C0_SLTL  *(volatile uint8_t  *)0x4006600B // I2C SCL Low Timeout Register Low\n"
  "//\n"
  "//register I2C1_A1   *(volatile uint8_t  *)0x40067000 // I2C Address Register 1\n"
  "//register I2C1_F   *(volatile uint8_t  *)0x40067001 // I2C Frequency Divider register\n"
  "//register I2C1_C1   *(volatile uint8_t  *)0x40067002 // I2C Control Register 1\n"
  "//register I2C1_S   *(volatile uint8_t  *)0x40067003 // I2C Status register\n"
  "//register I2C1_D   *(volatile uint8_t  *)0x40067004 // I2C Data I/O register\n"
  "//register I2C1_C2   *(volatile uint8_t  *)0x40067005 // I2C Control Register 2\n"
  "//register I2C1_FLT  *(volatile uint8_t  *)0x40067006 // I2C Programmable Input Glitch Filter register\n"
  "//register I2C1_RA   *(volatile uint8_t  *)0x40067007 // I2C Range Address register\n"
  "//register I2C1_SMB  *(volatile uint8_t  *)0x40067008 // I2C SMBus Control and Status register\n"
  "//register I2C1_A2   *(volatile uint8_t  *)0x40067009 // I2C Address Register 2\n"
  "//register I2C1_SLTH  *(volatile uint8_t  *)0x4006700A // I2C SCL Low Timeout Register High\n"
  "//register I2C1_SLTL  *(volatile uint8_t  *)0x4006700B // I2C SCL Low Timeout Register Low\n"
  "//\n"
  "//// Chapter 45: Universal Asynchronous Receiver/Transmitter (UART)\n"
  "//register UART0_BDH  *(volatile uint8_t  *)0x4006A000 // UART Baud Rate Registers: High\n"
  "//register UART0_BDL  *(volatile uint8_t  *)0x4006A001 // UART Baud Rate Registers: Low\n"
  "//register UART0_C1  *(volatile uint8_t  *)0x4006A002 // UART Control Register 1\n"
  "//register UART_C1_LOOPS   (uint8_t)0x80   // When LOOPS is set, the RxD pin is disconnected from the UART and the transmitter output is internally co"
  "nnected to the receiver input\n"
  "//register UART_C1_UARTSWAI  (uint8_t)0x40   // UART Stops in Wait Mode\n"
  "//register UART_C1_RSRC   (uint8_t)0x20   // When LOOPS is set, the RSRC field determines the source for the receiver shift register input\n"
  "//register UART_C1_M   (uint8_t)0x10   // 9-bit or 8-bit Mode Select\n"
  "//register UART_C1_WAKE   (uint8_t)0x08   // Determines which condition wakes the UART\n"
  "//register UART_C1_ILT   (uint8_t)0x04   // Idle Line Type Select\n"
  "//register UART_C1_PE   (uint8_t)0x02   // Parity Enable\n"
  "//register UART_C1_PT   (uint8_t)0x01   // Parity Type, 0=even, 1=odd\n"
  "//register UART0_C2  *(volatile uint8_t  *)0x4006A003 // UART Control Register 2\n"
  "//register UART_C2_TIE   (uint8_t)0x80   // Transmitter Interrupt or DMA Transfer Enable.\n"
  "//register UART_C2_TCIE   (uint8_t)0x40   // Transmission Complete Interrupt Enable\n"
  "//register UART_C2_RIE   (uint8_t)0x20   // Receiver Full Interrupt or DMA Transfer Enable\n"
  "//register UART_C2_ILIE   (uint8_t)0x10   // Idle Line Interrupt Enable\n"
  "//register UART_C2_TE   (uint8_t)0x08   // Transmitter Enable\n"
  "//register UART_C2_RE   (uint8_t)0x04   // Receiver Enable\n"
  "//register UART_C2_RWU   (uint8_t)0x02   // Receiver Wakeup Control\n"
  "//register UART_C2_SBK   (uint8_t)0x01   // Send Break\n"
  "//register UART0_S1  *(volatile uint8_t  *)0x4006A004 // UART Status Register 1\n"
  "//register UART_S1_TDRE   (uint8_t)0x80   // Transmit Data Register Empty Flag\n"
  "//register UART_S1_TC   (uint8_t)0x40   // Transmit Complete Flag\n"
  "//register UART_S1_RDRF   (uint8_t)0x20   // Receive Data Register Full Flag\n"
  "//register UART_S1_IDLE   (uint8_t)0x10   // Idle Line Flag\n"
  "//register UART_S1_OR   (uint8_t)0x08   // Receiver Overrun Flag\n"
  "//register UART_S1_NF   (uint8_t)0x04   // Noise Flag\n"
  "//register UART_S1_FE   (uint8_t)0x02   // Framing Error Flag\n"
  "//register UART_S1_PF   (uint8_t)0x01   // Parity Error Flag\n"
  "//register UART0_S2  *(volatile uint8_t  *)0x4006A005 // UART Status Register 2\n"
  "//register UART0_C3  *(volatile uint8_t  *)0x4006A006 // UART Control Register 3\n"
  "//register UART0_D   *(volatile uint8_t  *)0x4006A007 // UART Data Register\n"
  "//register UART0_MA1  *(volatile uint8_t  *)0x4006A008 // UART Match Address Registers 1\n"
  "//register UART0_MA2  *(volatile uint8_t  *)0x4006A009 // UART Match Address Registers 2\n"
  "//register UART0_C4  *(volatile uint8_t  *)0x4006A00A // UART Control Register 4\n"
  "//register UART0_C5  *(volatile uint8_t  *)0x4006A00B // UART Control Register 5\n"
  "//register UART0_ED  *(volatile uint8_t  *)0x4006A00C // UART Extended Data Register\n"
  "//register UART0_MODEM  *(volatile uint8_t  *)0x4006A00D // UART Modem Register\n"
  "//register UART0_IR  *(volatile uint8_t  *)0x4006A00E // UART Infrared Register\n"
  "//register UART0_PFIFO  *(volatile uint8_t  *)0x4006A010 // UART FIFO Parameters\n"
  "//register UART_PFIFO_TXFE   (uint8_t)0x80\n"
  "//register UART_PFIFO_RXFE   (uint8_t)0x08\n"
  "//register UART0_CFIFO  *(volatile uint8_t  *)0x4006A011 // UART FIFO Control Register\n"
  "//register UART_CFIFO_TXFLUSH  (uint8_t)0x80   // \n"
  "//register UART_CFIFO_RXFLUSH  (uint8_t)0x40   // \n"
  "//register UART_CFIFO_RXOFE  (uint8_t)0x04   // \n"
  "//register UART_CFIFO_TXOFE  (uint8_t)0x02   // \n"
  "//register UART_CFIFO_RXUFE  (uint8_t)0x01   // \n"
  "//register UART0_SFIFO  *(volatile uint8_t  *)0x4006A012 // UART FIFO Status Register\n"
  "//register UART_SFIFO_TXEMPT  (uint8_t)0x80\n"
  "//register UART_SFIFO_RXEMPT  (uint8_t)0x40\n"
  "//register UART_SFIFO_RXOF   (uint8_t)0x04\n"
  "//register UART_SFIFO_TXOF   (uint8_t)0x02\n"
  "//register UART_SFIFO_RXUF   (uint8_t)0x01\n"
  "//register UART0_TWFIFO  *(volatile uint8_t  *)0x4006A013 // UART FIFO Transmit Watermark\n"
  "//register UART0_TCFIFO  *(volatile uint8_t  *)0x4006A014 // UART FIFO Transmit Count\n"
  "//register UART0_RWFIFO  *(volatile uint8_t  *)0x4006A015 // UART FIFO Receive Watermark\n"
  "//register UART0_RCFIFO  *(volatile uint8_t  *)0x4006A016 // UART FIFO Receive Count\n"
  "//register UART0_C7816  *(volatile uint8_t  *)0x4006A018 // UART 7816 Control Register\n"
  "//register UART0_IE7816  *(volatile uint8_t  *)0x4006A019 // UART 7816 Interrupt Enable Register\n"
  "//register UART0_IS7816  *(volatile uint8_t  *)0x4006A01A // UART 7816 Interrupt Status Register\n"
  "//register UART0_WP7816T0  *(volatile uint8_t  *)0x4006A01B // UART 7816 Wait Parameter Register\n"
  "//register UART0_WP7816T1  *(volatile uint8_t  *)0x4006A01B // UART 7816 Wait Parameter Register\n"
  "//register UART0_WN7816  *(volatile uint8_t  *)0x4006A01C // UART 7816 Wait N Register\n"
  "//register UART0_WF7816  *(volatile uint8_t  *)0x4006A01D // UART 7816 Wait FD Register\n"
  "//register UART0_ET7816  *(volatile uint8_t  *)0x4006A01E // UART 7816 Error Threshold Register\n"
  "//register UART0_TL7816  *(volatile uint8_t  *)0x4006A01F // UART 7816 Transmit Length Register\n"
  "//register UART0_C6  *(volatile uint8_t  *)0x4006A021 // UART CEA709.1-B Control Register 6\n"
  "//register UART0_PCTH  *(volatile uint8_t  *)0x4006A022 // UART CEA709.1-B Packet Cycle Time Counter High\n"
  "//register UART0_PCTL  *(volatile uint8_t  *)0x4006A023 // UART CEA709.1-B Packet Cycle Time Counter Low\n"
  "//register UART0_B1T  *(volatile uint8_t  *)0x4006A024 // UART CEA709.1-B Beta1 Timer\n"
  "//register UART0_SDTH  *(volatile uint8_t  *)0x4006A025 // UART CEA709.1-B Secondary Delay Timer High\n"
  "//register UART0_SDTL  *(volatile uint8_t  *)0x4006A026 // UART CEA709.1-B Secondary Delay Timer Low\n"
  "//register UART0_PRE  *(volatile uint8_t  *)0x4006A027 // UART CEA709.1-B Preamble\n"
  "//register UART0_TPL  *(volatile uint8_t  *)0x4006A028 // UART CEA709.1-B Transmit Packet Length\n"
  "//register UART0_IE  *(volatile uint8_t  *)0x4006A029 // UART CEA709.1-B Interrupt Enable Register\n"
  "//register UART0_WB  *(volatile uint8_t  *)0x4006A02A // UART CEA709.1-B WBASE\n"
  "//register UART0_S3  *(volatile uint8_t  *)0x4006A02B // UART CEA709.1-B Status Register\n"
  "//register UART0_S4  *(volatile uint8_t  *)0x4006A02C // UART CEA709.1-B Status Register\n"
  "//register UART0_RPL  *(volatile uint8_t  *)0x4006A02D // UART CEA709.1-B Received Packet Length\n"
  "//register UART0_RPREL  *(volatile uint8_t  *)0x4006A02E // UART CEA709.1-B Received Preamble Length\n"
  "//register UART0_CPW  *(volatile uint8_t  *)0x4006A02F // UART CEA709.1-B Collision Pulse Width\n"
  "//register UART0_RIDT  *(volatile uint8_t  *)0x4006A030 // UART CEA709.1-B Receive Indeterminate Time\n"
  "//register UART0_TIDT  *(volatile uint8_t  *)0x4006A031 // UART CEA709.1-B Transmit Indeterminate Time\n"
  "//register UART1_BDH  *(volatile uint8_t  *)0x4006B000 // UART Baud Rate Registers: High\n"
  "//register UART1_BDL  *(volatile uint8_t  *)0x4006B001 // UART Baud Rate Registers: Low\n"
  "//register UART1_C1  *(volatile uint8_t  *)0x4006B002 // UART Control Register 1\n"
  "//register UART1_C2  *(volatile uint8_t  *)0x4006B003 // UART Control Register 2\n"
  "//register UART1_S1  *(volatile uint8_t  *)0x4006B004 // UART Status Register 1\n"
  "//register UART1_S2  *(volatile uint8_t  *)0x4006B005 // UART Status Register 2\n"
  "//register UART1_C3  *(volatile uint8_t  *)0x4006B006 // UART Control Register 3\n"
  "//register UART1_D   *(volatile uint8_t  *)0x4006B007 // UART Data Register\n"
  "//register UART1_MA1  *(volatile uint8_t  *)0x4006B008 // UART Match Address Registers 1\n"
  "//register UART1_MA2  *(volatile uint8_t  *)0x4006B009 // UART Match Address Registers 2\n"
  "//register UART1_C4  *(volatile uint8_t  *)0x4006B00A // UART Control Register 4\n"
  "//register UART1_C5  *(volatile uint8_t  *)0x4006B00B // UART Control Register 5\n"
  "//register UART1_ED  *(volatile uint8_t  *)0x4006B00C // UART Extended Data Register\n"
  "//register UART1_MODEM  *(volatile uint8_t  *)0x4006B00D // UART Modem Register\n"
  "//register UART1_IR  *(volatile uint8_t  *)0x4006B00E // UART Infrared Register\n"
  "//register UART1_PFIFO  *(volatile uint8_t  *)0x4006B010 // UART FIFO Parameters\n"
  "//register UART1_CFIFO  *(volatile uint8_t  *)0x4006B011 // UART FIFO Control Register\n"
  "//register UART1_SFIFO  *(volatile uint8_t  *)0x4006B012 // UART FIFO Status Register\n"
  "//register UART1_TWFIFO  *(volatile uint8_t  *)0x4006B013 // UART FIFO Transmit Watermark\n"
  "//register UART1_TCFIFO  *(volatile uint8_t  *)0x4006B014 // UART FIFO Transmit Count\n"
  "//register UART1_RWFIFO  *(volatile uint8_t  *)0x4006B015 // UART FIFO Receive Watermark\n"
  "//register UART1_RCFIFO  *(volatile uint8_t  *)0x4006B016 // UART FIFO Receive Count\n"
  "//register UART1_C7816  *(volatile uint8_t  *)0x4006B018 // UART 7816 Control Register\n"
  "//register UART1_IE7816  *(volatile uint8_t  *)0x4006B019 // UART 7816 Interrupt Enable Register\n"
  "//register UART1_IS7816  *(volatile uint8_t  *)0x4006B01A // UART 7816 Interrupt Status Register\n"
  "//register UART1_WP7816T0  *(volatile uint8_t  *)0x4006B01B // UART 7816 Wait Parameter Register\n"
  "//register UART1_WP7816T1  *(volatile uint8_t  *)0x4006B01B // UART 7816 Wait Parameter Register\n"
  "//register UART1_WN7816  *(volatile uint8_t  *)0x4006B01C // UART 7816 Wait N Register\n"
  "//register UART1_WF7816  *(volatile uint8_t  *)0x4006B01D // UART 7816 Wait FD Register\n"
  "//register UART1_ET7816  *(volatile uint8_t  *)0x4006B01E // UART 7816 Error Threshold Register\n"
  "//register UART1_TL7816  *(volatile uint8_t  *)0x4006B01F // UART 7816 Transmit Length Register\n"
  "//register UART1_C6  *(volatile uint8_t  *)0x4006B021 // UART CEA709.1-B Control Register 6\n"
  "//register UART1_PCTH  *(volatile uint8_t  *)0x4006B022 // UART CEA709.1-B Packet Cycle Time Counter High\n"
  "//register UART1_PCTL  *(volatile uint8_t  *)0x4006B023 // UART CEA709.1-B Packet Cycle Time Counter Low\n"
  "//register UART1_B1T  *(volatile uint8_t  *)0x4006B024 // UART CEA709.1-B Beta1 Timer\n"
  "//register UART1_SDTH  *(volatile uint8_t  *)0x4006B025 // UART CEA709.1-B Secondary Delay Timer High\n"
  "//register UART1_SDTL  *(volatile uint8_t  *)0x4006B026 // UART CEA709.1-B Secondary Delay Timer Low\n"
  "//register UART1_PRE  *(volatile uint8_t  *)0x4006B027 // UART CEA709.1-B Preamble\n"
  "//register UART1_TPL  *(volatile uint8_t  *)0x4006B028 // UART CEA709.1-B Transmit Packet Length\n"
  "//register UART1_IE  *(volatile uint8_t  *)0x4006B029 // UART CEA709.1-B Interrupt Enable Register\n"
  "//register UART1_WB  *(volatile uint8_t  *)0x4006B02A // UART CEA709.1-B WBASE\n"
  "//register UART1_S3  *(volatile uint8_t  *)0x4006B02B // UART CEA709.1-B Status Register\n"
  "//register UART1_S4  *(volatile uint8_t  *)0x4006B02C // UART CEA709.1-B Status Register\n"
  "//register UART1_RPL  *(volatile uint8_t  *)0x4006B02D // UART CEA709.1-B Received Packet Length\n"
  "//register UART1_RPREL  *(volatile uint8_t  *)0x4006B02E // UART CEA709.1-B Received Preamble Length\n"
  "//register UART1_CPW  *(volatile uint8_t  *)0x4006B02F // UART CEA709.1-B Collision Pulse Width\n"
  "//register UART1_RIDT  *(volatile uint8_t  *)0x4006B030 // UART CEA709.1-B Receive Indeterminate Time\n"
  "//register UART1_TIDT  *(volatile uint8_t  *)0x4006B031 // UART CEA709.1-B Transmit Indeterminate Time\n"
  "//register UART2_BDH  *(volatile uint8_t  *)0x4006C000 // UART Baud Rate Registers: High\n"
  "//register UART2_BDL  *(volatile uint8_t  *)0x4006C001 // UART Baud Rate Registers: Low\n"
  "//register UART2_C1  *(volatile uint8_t  *)0x4006C002 // UART Control Register 1\n"
  "//register UART2_C2  *(volatile uint8_t  *)0x4006C003 // UART Control Register 2\n"
  "//register UART2_S1  *(volatile uint8_t  *)0x4006C004 // UART Status Register 1\n"
  "//register UART2_S2  *(volatile uint8_t  *)0x4006C005 // UART Status Register 2\n"
  "//register UART2_C3  *(volatile uint8_t  *)0x4006C006 // UART Control Register 3\n"
  "//register UART2_D   *(volatile uint8_t  *)0x4006C007 // UART Data Register\n"
  "//register UART2_MA1  *(volatile uint8_t  *)0x4006C008 // UART Match Address Registers 1\n"
  "//register UART2_MA2  *(volatile uint8_t  *)0x4006C009 // UART Match Address Registers 2\n"
  "//register UART2_C4  *(volatile uint8_t  *)0x4006C00A // UART Control Register 4\n"
  "//register UART2_C5  *(volatile uint8_t  *)0x4006C00B // UART Control Register 5\n"
  "//register UART2_ED  *(volatile uint8_t  *)0x4006C00C // UART Extended Data Register\n"
  "//register UART2_MODEM  *(volatile uint8_t  *)0x4006C00D // UART Modem Register\n"
  "//register UART2_IR  *(volatile uint8_t  *)0x4006C00E // UART Infrared Register\n"
  "//register UART2_PFIFO  *(volatile uint8_t  *)0x4006C010 // UART FIFO Parameters\n"
  "//register UART2_CFIFO  *(volatile uint8_t  *)0x4006C011 // UART FIFO Control Register\n"
  "//register UART2_SFIFO  *(volatile uint8_t  *)0x4006C012 // UART FIFO Status Register\n"
  "//register UART2_TWFIFO  *(volatile uint8_t  *)0x4006C013 // UART FIFO Transmit Watermark\n"
  "//register UART2_TCFIFO  *(volatile uint8_t  *)0x4006C014 // UART FIFO Transmit Count\n"
  "//register UART2_RWFIFO  *(volatile uint8_t  *)0x4006C015 // UART FIFO Receive Watermark\n"
  "//register UART2_RCFIFO  *(volatile uint8_t  *)0x4006C016 // UART FIFO Receive Count\n"
  "//register UART2_C7816  *(volatile uint8_t  *)0x4006C018 // UART 7816 Control Register\n"
  "//register UART2_IE7816  *(volatile uint8_t  *)0x4006C019 // UART 7816 Interrupt Enable Register\n"
  "//register UART2_IS7816  *(volatile uint8_t  *)0x4006C01A // UART 7816 Interrupt Status Register\n"
  "//register UART2_WP7816T0  *(volatile uint8_t  *)0x4006C01B // UART 7816 Wait Parameter Register\n"
  "//register UART2_WP7816T1  *(volatile uint8_t  *)0x4006C01B // UART 7816 Wait Parameter Register\n"
  "//register UART2_WN7816  *(volatile uint8_t  *)0x4006C01C // UART 7816 Wait N Register\n"
  "//register UART2_WF7816  *(volatile uint8_t  *)0x4006C01D // UART 7816 Wait FD Register\n"
  "//register UART2_ET7816  *(volatile uint8_t  *)0x4006C01E // UART 7816 Error Threshold Register\n"
  "//register UART2_TL7816  *(volatile uint8_t  *)0x4006C01F // UART 7816 Transmit Length Register\n"
  "//register UART2_C6  *(volatile uint8_t  *)0x4006C021 // UART CEA709.1-B Control Register 6\n"
  "//register UART2_PCTH  *(volatile uint8_t  *)0x4006C022 // UART CEA709.1-B Packet Cycle Time Counter High\n"
  "//register UART2_PCTL  *(volatile uint8_t  *)0x4006C023 // UART CEA709.1-B Packet Cycle Time Counter Low\n"
  "//register UART2_B1T  *(volatile uint8_t  *)0x4006C024 // UART CEA709.1-B Beta1 Timer\n"
  "//register UART2_SDTH  *(volatile uint8_t  *)0x4006C025 // UART CEA709.1-B Secondary Delay Timer High\n"
  "//register UART2_SDTL  *(volatile uint8_t  *)0x4006C026 // UART CEA709.1-B Secondary Delay Timer Low\n"
  "//register UART2_PRE  *(volatile uint8_t  *)0x4006C027 // UART CEA709.1-B Preamble\n"
  "//register UART2_TPL  *(volatile uint8_t  *)0x4006C028 // UART CEA709.1-B Transmit Packet Length\n"
  "//register UART2_IE  *(volatile uint8_t  *)0x4006C029 // UART CEA709.1-B Interrupt Enable Register\n"
  "//register UART2_WB  *(volatile uint8_t  *)0x4006C02A // UART CEA709.1-B WBASE\n"
  "//register UART2_S3  *(volatile uint8_t  *)0x4006C02B // UART CEA709.1-B Status Register\n"
  "//register UART2_S4  *(volatile uint8_t  *)0x4006C02C // UART CEA709.1-B Status Register\n"
  "//register UART2_RPL  *(volatile uint8_t  *)0x4006C02D // UART CEA709.1-B Received Packet Length\n"
  "//register UART2_RPREL  *(volatile uint8_t  *)0x4006C02E // UART CEA709.1-B Received Preamble Length\n"
  "//register UART2_CPW  *(volatile uint8_t  *)0x4006C02F // UART CEA709.1-B Collision Pulse Width\n"
  "//register UART2_RIDT  *(volatile uint8_t  *)0x4006C030 // UART CEA709.1-B Receive Indeterminate Time\n"
  "//register UART2_TIDT  *(volatile uint8_t  *)0x4006C031 // UART CEA709.1-B Transmit Indeterminate Time\n"
  "//\n"
  "//// Chapter 46: Synchronous Audio Interface (SAI)\n"
  "//register I2S0_TCSR   0x4002F000 // SAI Transmit Control Register\n"
  "//register I2S_TCSR_TE    0x80000000 // Transmitter Enable\n"
  "//register I2S_TCSR_STOPE    0x40000000 // Transmitter Enable in Stop mode\n"
  "//register I2S_TCSR_DBGE    0x20000000 // Transmitter Enable in Debug mode\n"
  "//register I2S_TCSR_BCE    0x10000000 // Bit Clock Enable\n"
  "//register I2S_TCSR_FR    0x02000000 // FIFO Reset\n"
  "//register I2S_TCSR_SR    0x01000000 // Software Reset\n"
  "//register I2S_TCSR_WSF    0x00100000 // Word Start Flag\n"
  "//register I2S_TCSR_SEF    0x00080000 // Sync Error Flag\n"
  "//register I2S_TCSR_FEF    0x00040000 // FIFO Error Flag (underrun)\n"
  "//register I2S_TCSR_FWF    0x00020000 // FIFO Warning Flag (empty)\n"
  "//register I2S_TCSR_FRF    0x00010000 // FIFO Request Flag (Data Ready)\n"
  "//register I2S_TCSR_WSIE    0x00001000 // Word Start Interrupt Enable\n"
  "//register I2S_TCSR_SEIE    0x00000800 // Sync Error Interrupt Enable\n"
  "//register I2S_TCSR_FEIE    0x00000400 // FIFO Error Interrupt Enable\n"
  "//register I2S_TCSR_FWIE    0x00000200 // FIFO Warning Interrupt Enable\n"
  "//register I2S_TCSR_FRIE    0x00000100 // FIFO Request Interrupt Enable\n"
  "//register I2S_TCSR_FWDE    0x00000002 // FIFO Warning DMA Enable\n"
  "//register I2S_TCSR_FRDE    0x00000001 // FIFO Request DMA Enable\n"
  "//register I2S0_TCR1   0x4002F004 // SAI Transmit Configuration 1 Register\n"
  "//register I2S_TCR1_TFW(n)   ( n & 0x03)       // Transmit FIFO watermark\n"
  "//register I2S0_TCR2   0x4002F008 // SAI Transmit Configuration 2 Register\n"
  "//register I2S_TCR2_DIV(n)   ( n & 0xff)       // Bit clock divide by (DIV+1)*2\n"
  "//register I2S_TCR2_BCD   ( 1<<24)       // Bit clock direction\n"
  "//register I2S_TCR2_BCP   ( 1<<25)       // Bit clock polarity\n"
  "//register I2S_TCR2_MSEL(n)  ( (n & 3)<<26)       // MCLK select, 0=bus clock, 1=I2S0_MCLK\n"
  "//register I2S_TCR2_BCI   ( 1<<28)       // Bit clock input\n"
  "//register I2S_TCR2_BCS   ( 1<<29)       // Bit clock swap\n"
  "//register I2S_TCR2_SYNC(n)  ( (n & 3)<<30)       // 0=async 1=sync with receiver\n"
  "//register I2S0_TCR3   0x4002F00C // SAI Transmit Configuration 3 Register\n"
  "//register I2S_TCR3_WDFL(n)  ( n & 0x0f)       // word flag configuration\n"
  "//register I2S_TCR3_TCE   ( 0x10000)       // transmit channel enable\n"
  "//register I2S0_TCR4   0x4002F010 // SAI Transmit Configuration 4 Register\n"
  "//register I2S_TCR4_FSD   ( 1)        // Frame Sync Direction\n"
  "//register I2S_TCR4_FSP   ( 2)        // Frame Sync Polarity\n"
  "//register I2S_TCR4_FSE   ( 8)        // Frame Sync Early\n"
  "//register I2S_TCR4_MF   ( 0x10)       // MSB First\n"
  "//register I2S_TCR4_SYWD(n)  ( (n & 0x1f)<<8)     // Sync Width\n"
  "//register I2S_TCR4_FRSZ(n)  ( (n & 0x0f)<<16)    // Frame Size\n"
  "//register I2S0_TCR5   0x4002F014 // SAI Transmit Configuration 5 Register\n"
  "//register I2S_TCR5_FBT(n)   ( (n & 0x1f)<<8)     // First Bit Shifted\n"
  "//register I2S_TCR5_W0W(n)   ( (n & 0x1f)<<16)    // Word 0 Width\n"
  "//register I2S_TCR5_WNW(n)   ( (n & 0x1f)<<24)    // Word N Width\n"
  "//register I2S0_TDR0   0x4002F020 // SAI Transmit Data Register\n"
  "//register I2S0_TDR1   0x4002F024 // SAI Transmit Data Register\n"
  "//register I2S0_TFR0   0x4002F040 // SAI Transmit FIFO Register\n"
  "//register I2S0_TFR1   0x4002F044 // SAI Transmit FIFO Register\n"
  "//register I2S_TFR_RFP(n)   ( n & 7)       // read FIFO pointer\n"
  "//register I2S_TFR_WFP(n)   ( (n & 7)<<16)       // write FIFO pointer\n"
  "//register I2S0_TMR   0x4002F060 // SAI Transmit Mask Register\n"
  "//register I2S_TMR_TWM(n)   ( n & 0xFFFFFFFF)\n"
  "//register I2S0_RCSR   0x4002F080 // SAI Receive Control Register\n"
  "//register I2S_RCSR_RE    0x80000000 // Receiver Enable\n"
  "//register I2S_RCSR_STOPE    0x40000000 // Receiver Enable in Stop mode\n"
  "//register I2S_RCSR_DBGE    0x20000000 // Receiver Enable in Debug mode\n"
  "//register I2S_RCSR_BCE    0x10000000 // Bit Clock Enable\n"
  "//register I2S_RCSR_FR    0x02000000 // FIFO Reset\n"
  "//register I2S_RCSR_SR    0x01000000 // Software Reset\n"
  "//register I2S_RCSR_WSF    0x00100000 // Word Start Flag\n"
  "//register I2S_RCSR_SEF    0x00080000 // Sync Error Flag\n"
  "//register I2S_RCSR_FEF    0x00040000 // FIFO Error Flag (underrun)\n"
  "//register I2S_RCSR_FWF    0x00020000 // FIFO Warning Flag (empty)\n"
  "//register I2S_RCSR_FRF    0x00010000 // FIFO Request Flag (Data Ready)\n"
  "//register I2S_RCSR_WSIE    0x00001000 // Word Start Interrupt Enable\n"
  "//register I2S_RCSR_SEIE    0x00000800 // Sync Error Interrupt Enable\n"
  "//register I2S_RCSR_FEIE    0x00000400 // FIFO Error Interrupt Enable\n"
  "//register I2S_RCSR_FWIE    0x00000200 // FIFO Warning Interrupt Enable\n"
  "//register I2S_RCSR_FRIE    0x00000100 // FIFO Request Interrupt Enable\n"
  "//register I2S_RCSR_FWDE    0x00000002 // FIFO Warning DMA Enable\n"
  "//register I2S_RCSR_FRDE    0x00000001 // FIFO Request DMA Enable\n"
  "//register I2S0_RCR1   0x4002F084 // SAI Receive Configuration 1 Register\n"
  "//register I2S_RCR1_RFW(n)   ( n & 0x03)       // Receive FIFO watermark\n"
  "//register I2S0_RCR2   0x4002F088 // SAI Receive Configuration 2 Register\n"
  "//register I2S_RCR2_DIV(n)   ( n & 0xff)       // Bit clock divide by (DIV+1)*2\n"
  "//register I2S_RCR2_BCD   ( 1<<24)       // Bit clock direction\n"
  "//register I2S_RCR2_BCP   ( 1<<25)       // Bit clock polarity\n"
  "//register I2S_RCR2_MSEL(n)  ( (n & 3)<<26)       // MCLK select, 0=bus clock, 1=I2S0_MCLK\n"
  "//register I2S_RCR2_BCI   ( 1<<28)       // Bit clock input\n"
  "//register I2S_RCR2_BCS   ( 1<<29)       // Bit clock swap\n"
  "//register I2S_RCR2_SYNC(n)  ( (n & 3)<<30)       // 0=async 1=sync with receiver\n"
  "//register I2S0_RCR3   0x4002F08C // SAI Receive Configuration 3 Register\n"
  "//register I2S_RCR3_WDFL(n)  ( n & 0x0f)       // word flag configuration\n"
  "//register I2S_RCR3_RCE   ( 0x10000)       // receive channel enable\n"
  "//register I2S0_RCR4   0x4002F090 // SAI Receive Configuration 4 Register\n"
  "//register I2S_RCR4_FSD   ( 1)        // Frame Sync Direction\n"
  "//register I2S_RCR4_FSP   ( 2)        // Frame Sync Polarity\n"
  "//register I2S_RCR4_FSE   ( 8)        // Frame Sync Early\n"
  "//register I2S_RCR4_MF   ( 0x10)       // MSB First\n"
  "//register I2S_RCR4_SYWD(n)  ( (n & 0x1f)<<8)     // Sync Width\n"
  "//register I2S_RCR4_FRSZ(n)  ( (n & 0x0f)<<16)    // Frame Size\n"
  "//register I2S0_RCR5   0x4002F094 // SAI Receive Configuration 5 Register\n"
  "//register I2S_RCR5_FBT(n)   ( (n & 0x1f)<<8)     // First Bit Shifted\n"
  "//register I2S_RCR5_W0W(n)   ( (n & 0x1f)<<16)    // Word 0 Width\n"
  "//register I2S_RCR5_WNW(n)   ( (n & 0x1f)<<24)    // Word N Width\n"
  "//register I2S0_RDR0   0x4002F0A0 // SAI Receive Data Register\n"
  "//register I2S0_RDR1   0x4002F0A4 // SAI Receive Data Register\n"
  "//register I2S0_RFR0   0x4002F0C0 // SAI Receive FIFO Register\n"
  "//register I2S0_RFR1   0x4002F0C4 // SAI Receive FIFO Register\n"
  "//register I2S_RFR_RFP(n)   ( n & 7)       // read FIFO pointer\n"
  "//register I2S_RFR_WFP(n)   ( (n & 7)<<16)       // write FIFO pointer\n"
  "//register I2S0_RMR   0x4002F0E0 // SAI Receive Mask Register\n"
  "//register I2S_RMR_RWM(n)   ( n & 0xFFFFFFFF)\n"
  "//register I2S0_MCR   0x4002F100 // SAI MCLK Control Register\n"
  "//register I2S_MCR_DUF   ( 1<<31)       // Divider Update Flag\n"
  "//register I2S_MCR_MOE   ( 1<<30)       // MCLK Output Enable\n"
  "//register I2S_MCR_MICS(n)   ( (n & 3)<<24)       // MCLK Input Clock Select\n"
  "//register I2S0_MDR   0x4002F104 // SAI MCLK Divide Register\n"
  "//register I2S_MDR_FRACT(n)  ( (n & 0xff)<<12)    // MCLK Fraction\n"
  "//register I2S_MDR_DIVIDE(n)  ( (n & 0xfff))       // MCLK Divide\n"
  "//\n"
  "//// Chapter 47: General-Purpose Input/Output (GPIO)\n"
  "register GPIOA_PDOR   : UInt32 at 0x400FF000 // Port Data Output Register\n"
  "register GPIOA_PSOR   : UInt32 at 0x400FF004 // Port Set Output Register\n"
  "register GPIOA_PCOR   : UInt32 at 0x400FF008 // Port Clear Output Register\n"
  "register GPIOA_PTOR   : UInt32 at 0x400FF00C // Port Toggle Output Register\n"
  "register GPIOA_PDIR   : UInt32 at 0x400FF010 // Port Data Input Register\n"
  "register GPIOA_PDDR   : UInt32 at 0x400FF014 // Port Data Direction Register\n"
  "register GPIOB_PDOR   : UInt32 at 0x400FF040 // Port Data Output Register\n"
  "register GPIOB_PSOR   : UInt32 at 0x400FF044 // Port Set Output Register\n"
  "register GPIOB_PCOR   : UInt32 at 0x400FF048 // Port Clear Output Register\n"
  "register GPIOB_PTOR   : UInt32 at 0x400FF04C // Port Toggle Output Register\n"
  "register GPIOB_PDIR   : UInt32 at 0x400FF050 // Port Data Input Register\n"
  "register GPIOB_PDDR   : UInt32 at 0x400FF054 // Port Data Direction Register\n"
  "register GPIOC_PDOR   : UInt32 at 0x400FF080 // Port Data Output Register\n"
  "register GPIOC_PSOR   : UInt32 at 0x400FF084 // Port Set Output Register\n"
  "register GPIOC_PCOR   : UInt32 at 0x400FF088 // Port Clear Output Register\n"
  "register GPIOC_PTOR   : UInt32 at 0x400FF08C // Port Toggle Output Register\n"
  "register GPIOC_PDIR   : UInt32 at 0x400FF090 // Port Data Input Register\n"
  "register GPIOC_PDDR   : UInt32 at 0x400FF094 // Port Data Direction Register\n"
  "register GPIOD_PDOR   : UInt32 at 0x400FF0C0 // Port Data Output Register\n"
  "register GPIOD_PSOR   : UInt32 at 0x400FF0C4 // Port Set Output Register\n"
  "register GPIOD_PCOR   : UInt32 at 0x400FF0C8 // Port Clear Output Register\n"
  "register GPIOD_PTOR   : UInt32 at 0x400FF0CC // Port Toggle Output Register\n"
  "register GPIOD_PDIR   : UInt32 at 0x400FF0D0 // Port Data Input Register\n"
  "register GPIOD_PDDR   : UInt32 at 0x400FF0D4 // Port Data Direction Register\n"
  "register GPIOE_PDOR   : UInt32 at 0x400FF100 // Port Data Output Register\n"
  "register GPIOE_PSOR   : UInt32 at 0x400FF104 // Port Set Output Register\n"
  "register GPIOE_PCOR   : UInt32 at 0x400FF108 // Port Clear Output Register\n"
  "register GPIOE_PTOR   : UInt32 at 0x400FF10C // Port Toggle Output Register\n"
  "register GPIOE_PDIR   : UInt32 at 0x400FF110 // Port Data Input Register\n"
  "register GPIOE_PDDR   : UInt32 at 0x400FF114 // Port Data Direction Register\n"
  "//\n"
  "//// Chapter 48: Touch sense input (TSI)\n"
  "//register TSI0_GENCS   0x40045000 // General Control and Status Register\n"
  "//register TSI_GENCS_LPCLKS   0x10000000  // \n"
  "//register TSI_GENCS_LPSCNITV(n)  (((n) & 15) << 24)  // \n"
  "//register TSI_GENCS_NSCN(n)  (((n) & 31) << 19)  // \n"
  "//register TSI_GENCS_PS(n)   (((n) & 7) << 16)  // \n"
  "//register TSI_GENCS_EOSF    0x00008000  // \n"
  "//register TSI_GENCS_OUTRGF   0x00004000  // \n"
  "//register TSI_GENCS_EXTERF   0x00002000  // \n"
  "//register TSI_GENCS_OVRF    0x00001000  // \n"
  "//register TSI_GENCS_SCNIP    0x00000200  // \n"
  "//register TSI_GENCS_SWTS    0x00000100  // \n"
  "//register TSI_GENCS_TSIEN    0x00000080  // \n"
  "//register TSI_GENCS_TSIIE    0x00000040  // \n"
  "//register TSI_GENCS_ERIE    0x00000020  // \n"
  "//register TSI_GENCS_ESOR    0x00000010  // \n"
  "//register TSI_GENCS_STM    0x00000002  // \n"
  "//register TSI_GENCS_STPE    0x00000001  // \n"
  "//register TSI0_SCANC   0x40045004 // SCAN Control Register\n"
  "//register TSI_SCANC_REFCHRG(n)  (((n) & 15) << 24)  // \n"
  "//register TSI_SCANC_EXTCHRG(n)  (((n) & 7) << 16)  // \n"
  "//register TSI_SCANC_SMOD(n)  (((n) & 255) << 8)  // \n"
  "//register TSI_SCANC_AMCLKS(n)  (((n) & 3) << 3)  // \n"
  "//register TSI_SCANC_AMPSC(n)  (((n) & 7) << 0)  // \n"
  "//register TSI0_PEN   0x40045008 // Pin Enable Register\n"
  "//register TSI0_WUCNTR   0x4004500C // Wake-Up Channel Counter Register\n"
  "//register TSI0_CNTR1   0x40045100 // Counter Register\n"
  "//register TSI0_CNTR3   0x40045104 // Counter Register\n"
  "//register TSI0_CNTR5   0x40045108 // Counter Register\n"
  "//register TSI0_CNTR7   0x4004510C // Counter Register\n"
  "//register TSI0_CNTR9   0x40045110 // Counter Register\n"
  "//register TSI0_CNTR11   0x40045114 // Counter Register\n"
  "//register TSI0_CNTR13   0x40045118 // Counter Register\n"
  "//register TSI0_CNTR15   0x4004511C // Counter Register\n"
  "//register TSI0_THRESHOLD   0x40045120 // Low Power Channel Threshold Register\n"
  "//\n"
  "//// Nested Vectored Interrupt Controller, Table 3-4 & ARMv7 ref, appendix B3.4 (page 750)\n"
  "//register NVIC_ENABLE_IRQ(n) (*((volatile uint32_t *)0xE000E100 + (n >> 5)) = (1 << (n & 31)))\n"
  "//register NVIC_DISABLE_IRQ(n) (*((volatile uint32_t *)0xE000E180 + (n >> 5)) = (1 << (n & 31)))\n"
  "//register NVIC_SET_PENDING(n) (*((volatile uint32_t *)0xE000E200 + (n >> 5)) = (1 << (n & 31)))\n"
  "//register NVIC_CLEAR_PENDING(n) (*((volatile uint32_t *)0xE000E280 + (n >> 5)) = (1 << (n & 31)))\n"
  "//\n"
  "//register NVIC_ISER0   0xE000E100\n"
  "//register NVIC_ISER1   0xE000E104\n"
  "//register NVIC_ICER0   0xE000E180\n"
  "//register NVIC_ICER1   0xE000E184\n"
  "//\n"
  "//// 0 = highest priority\n"
  "//// Cortex-M4: 0,16,32,48,64,80,96,112,128,144,160,176,192,208,224,240\n"
  "//// Cortex-M0: 0,64,128,192\n"
  "//register NVIC_SET_PRIORITY(irqnum, priority)  (*((volatile uint8_t *)0xE000E400 + (irqnum)) = (uint8_t)(priority))\n"
  "//register NVIC_GET_PRIORITY(irqnum) (*((uint8_t *)0xE000E400 + (irqnum)))\n"
  "//\n"
  "//register IRQ_DMA_CH0  0\n"
  "//register IRQ_DMA_CH1  1\n"
  "//register IRQ_DMA_CH2  2\n"
  "//register IRQ_DMA_CH3  3\n"
  "//register IRQ_DMA_CH4  4\n"
  "//register IRQ_DMA_CH5  5\n"
  "//register IRQ_DMA_CH6  6\n"
  "//register IRQ_DMA_CH7  7\n"
  "//register IRQ_DMA_CH8  8\n"
  "//register IRQ_DMA_CH9  9\n"
  "//register IRQ_DMA_CH10  10\n"
  "//register IRQ_DMA_CH11  11\n"
  "//register IRQ_DMA_CH12  12\n"
  "//register IRQ_DMA_CH13  13\n"
  "//register IRQ_DMA_CH14  14\n"
  "//register IRQ_DMA_CH15  15\n"
  "//register IRQ_DMA_ERROR  16\n"
  "//register IRQ_FTFL_COMPLETE 18\n"
  "//register IRQ_FTFL_COLLISION 19\n"
  "//register IRQ_LOW_VOLTAGE  20\n"
  "//register IRQ_LLWU  21\n"
  "//register IRQ_WDOG  22\n"
  "//register IRQ_I2C0  24\n"
  "//register IRQ_I2C1  25\n"
  "//register IRQ_SPI0  26\n"
  "//register IRQ_SPI1  27\n"
  "//register IRQ_CAN_MESSAGE  29\n"
  "//register IRQ_CAN_BUS_OFF  30\n"
  "//register IRQ_CAN_ERROR  31\n"
  "//register IRQ_CAN_TX_WARN  32\n"
  "//register IRQ_CAN_RX_WARN  33\n"
  "//register IRQ_CAN_WAKEUP  34\n"
  "//register IRQ_I2S0_TX  35\n"
  "//register IRQ_I2S0_RX  36\n"
  "//register IRQ_UART0_LON  44\n"
  "//register IRQ_UART0_STATUS 45\n"
  "//register IRQ_UART0_ERROR  46\n"
  "//register IRQ_UART1_STATUS 47\n"
  "//register IRQ_UART1_ERROR  48\n"
  "//register IRQ_UART2_STATUS 49\n"
  "//register IRQ_UART2_ERROR  50\n"
  "//register IRQ_ADC0  57\n"
  "//register IRQ_ADC1  58\n"
  "//register IRQ_CMP0  59\n"
  "//register IRQ_CMP1  60\n"
  "//register IRQ_CMP2  61\n"
  "//register IRQ_FTM0  62\n"
  "//register IRQ_FTM1  63\n"
  "//register IRQ_FTM2  64\n"
  "//register IRQ_CMT   65\n"
  "//register IRQ_RTC_ALARM  66\n"
  "//register IRQ_RTC_SECOND  67\n"
  "//register IRQ_PIT_CH0  68\n"
  "//register IRQ_PIT_CH1  69\n"
  "//register IRQ_PIT_CH2  70\n"
  "//register IRQ_PIT_CH3  71\n"
  "//register IRQ_PDB   72\n"
  "//register IRQ_USBOTG  73\n"
  "//register IRQ_USBDCD  74\n"
  "//register IRQ_DAC0  81\n"
  "//register IRQ_TSI   83\n"
  "//register IRQ_MCG   84\n"
  "//register IRQ_LPTMR  85\n"
  "//register IRQ_PORTA  87\n"
  "//register IRQ_PORTB  88\n"
  "//register IRQ_PORTC  89\n"
  "//register IRQ_PORTD  90\n"
  "//register IRQ_PORTE  91\n"
  "//register IRQ_SOFTWARE  94\n"
  "//register NVIC_NUM_INTERRUPTS 95\n"
  "//\n"
  "//// System Control Space (SCS), ARMv7 ref manual, B3.2, page 708\n"
  "//register SCB_CPUID  *(const    uint32_t *)0xE000ED00 // CPUID Base Register\n"
  "//register SCB_ICSR   0xE000ED04 // Interrupt Control and State\n"
  "//register SCB_ICSR_PENDSTSET   0x04000000\n"
  "//register SCB_VTOR   0xE000ED08 // Vector Table Offset\n"
  "//register SCB_AIRCR   0xE000ED0C // Application Interrupt and Reset Control\n"
  "//register SCB_SCR    0xE000ED10 // System Control Register\n"
  "//register SCB_CCR    0xE000ED14 // Configuration and Control\n"
  "//register SCB_SHPR1   0xE000ED18 // System Handler Priority Register 1\n"
  "//register SCB_SHPR2   0xE000ED1C // System Handler Priority Register 2\n"
  "//register SCB_SHPR3   0xE000ED20 // System Handler Priority Register 3\n"
  "//register SCB_SHCSR   0xE000ED24 // System Handler Control and State\n"
  "//register SCB_CFSR   0xE000ED28 // Configurable Fault Status Register\n"
  "//register SCB_HFSR   0xE000ED2C // HardFault Status\n"
  "//register SCB_DFSR   0xE000ED30 // Debug Fault Status\n"
  "//register SCB_MMFAR   0xE000ED34 // MemManage Fault Address\n"
  "\n"
  "register SYST_CSR : UInt32 at 0xE000E010 // SysTick Control and Status\n"
  "let SYST_CSR_COUNTFLAG  : UInt32 = 0x00010000\n"
  "let SYST_CSR_CLKSOURCE   : UInt32= 0x00000004\n"
  "let SYST_CSR_TICKINT  : UInt32 = 0x00000002\n"
  "let SYST_CSR_ENABLE   : UInt32 =  0x00000001\n"
  "register SYST_RVR   : UInt32 at 0xE000E014 // SysTick Reload Value Register\n"
  "register SYST_CVR   : UInt32 at 0xE000E018 // SysTick Current Value Register\n"
  "register @ro SYST_CALIB : UInt32 at 0xE000E01C // SysTick Calibration Value\n"
  "\n"
  "\n"
  "//register ARM_DEMCR   0xE000EDFC // Debug Exception and Monitor Control\n"
  "//register ARM_DEMCR_TRCENA  (1 << 24)  // Enable debugging & monitoring blocks\n"
  "//register ARM_DWT_CTRL   0xE0001000 // DWT control register\n"
  "//register ARM_DWT_CTRL_CYCCNTENA  (1 << 0)  // Enable cycle count\n"
  "//register ARM_DWT_CYCCNT   0xE0001004 // Cycle count register\n" ;

const cRegularFileWrapper gWrapperFile_3_targetTemplates (
  "mk20dx256.plm",
  "plm",
  true, // Text file
  144402, // Text length
  gWrapperFileContent_3_targetTemplates
) ;

//--- All files of 'microcontrollers' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_1 [4] = {
  & gWrapperFile_1_targetTemplates,
  & gWrapperFile_2_targetTemplates,
  & gWrapperFile_3_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'microcontrollers' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_1 [1] = {
  NULL
} ;

//--- Directory 'microcontrollers'

const cDirectoryWrapper gWrapperDirectory_1_targetTemplates (
  "microcontrollers",
  3,
  gWrapperAllFiles_targetTemplates_1,
  0,
  gWrapperAllDirectories_targetTemplates_1
) ;

//--- File 'targets/target-teensy-sequential-systick.plms'

const char * gWrapperFileContent_4_targetTemplates = "newUnsignedBaseType @unsigned8  \"uint8_t\"   8\n"
  "newUnsignedBaseType @unsigned16 \"uint16_t\" 16\n"
  "newUnsignedBaseType @unsigned32 \"uint32_t\" 32\n"
  "newUnsignedBaseType @unsigned64 \"uint64_t\" 64\n"
  "\n"
  "newSignedBaseType @signed8  \"int8_t\"   8\n"
  "newSignedBaseType @signed16 \"int16_t\" 16\n"
  "newSignedBaseType @signed32 \"int32_t\" 32\n"
  "newSignedBaseType @signed64 \"int64_t\" 64\n"
  "\n"
  "newUnsignedBaseType @size \"uint32_t\" 32\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "newBooleanType Bool @unsigned8\n"
  "\n"
  "newIntegerType UInt8  @unsigned8\n"
  "newIntegerType UInt16 @unsigned16\n"
  "newIntegerType UInt32 @unsigned32\n"
  "newIntegerType UInt64 @unsigned64\n"
  "\n"
  "newIntegerType Int8  @signed8\n"
  "newIntegerType Int16 @signed16\n"
  "newIntegerType Int32 @signed32\n"
  "newIntegerType Int64 @signed64\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "import \"microcontrollers/mk20dx256.plm\"\n"
  "import \"microcontrollers/lcd.plm\"\n"
  "import \"microcontrollers/leds.plm\"\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "mode $isr\n"
  "mode $user\n"
  "mode $init\n"
  "mode $exception\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "required proc $user setup ()\n"
  "required proc $user loop ()\n"
  "required proc $isr systickHandler ()\n"
  "required proc $isr userSystickHandler ()\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $isr systickHandler () {\n"
  "  gCompteur &++\n"
  "  userSystickHandler ()\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "var $user $isr $init gCompteur : UInt32 = 0\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "proc $user $init waitMS (\?inDuration : UInt32) {\n"
  "  let deadline = gCompteur + inDuration\n"
  "  while gCompteur < deadline do\n"
  "  end\n"
  "}\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n" ;

const cRegularFileWrapper gWrapperFile_4_targetTemplates (
  "target-teensy-sequential-systick.plms",
  "plms",
  true, // Text file
  1882, // Text length
  gWrapperFileContent_4_targetTemplates
) ;

//--- File 'targets/target-teensy-sequential.plms'

const char * gWrapperFileContent_5_targetTemplates = "newUnsignedBaseType @unsigned8  \"uint8_t\"   8\n"
  "newUnsignedBaseType @unsigned16 \"uint16_t\" 16\n"
  "newUnsignedBaseType @unsigned32 \"uint32_t\" 32\n"
  "newUnsignedBaseType @unsigned64 \"uint64_t\" 64\n"
  "\n"
  "newSignedBaseType @signed8  \"int8_t\"   8\n"
  "newSignedBaseType @signed16 \"int16_t\" 16\n"
  "newSignedBaseType @signed32 \"int32_t\" 32\n"
  "newSignedBaseType @signed64 \"int64_t\" 64\n"
  "\n"
  "newUnsignedBaseType @size \"uint32_t\" 32\n"
  "\n"
  "newBooleanType Bool @unsigned8\n"
  "\n"
  "newIntegerType UInt8  @unsigned8\n"
  "newIntegerType UInt16 @unsigned16\n"
  "newIntegerType UInt32 @unsigned32\n"
  "newIntegerType UInt64 @unsigned64\n"
  "\n"
  "newIntegerType Int8  @signed8\n"
  "newIntegerType Int16 @signed16\n"
  "newIntegerType Int32 @signed32\n"
  "newIntegerType Int64 @signed64\n"
  "\n"
  "import \"microcontrollers/mk20dx256.plm\"\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n"
  "\n"
  "mode $isr\n"
  "mode $user\n"
  "\n"
  "required proc $user setup ()\n"
  "required proc $user loop ()\n"
  "\n"
  "//-----------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_5_targetTemplates (
  "target-teensy-sequential.plms",
  "plms",
  true, // Text file
  967, // Text length
  gWrapperFileContent_5_targetTemplates
) ;

//--- File 'target-teensy-sequential/build-as.py'

const char * gWrapperFileContent_6_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"as\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_6_targetTemplates (
  "build-as.py",
  "py",
  true, // Text file
  996, // Text length
  gWrapperFileContent_6_targetTemplates
) ;

//--- File 'target-teensy-sequential/build-verbose.py'

const char * gWrapperFileContent_7_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"all\", \"1\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_7_targetTemplates (
  "build-verbose.py",
  "py",
  true, // Text file
  1002, // Text length
  gWrapperFileContent_7_targetTemplates
) ;

//--- File 'target-teensy-sequential/build.py'

const char * gWrapperFileContent_8_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess, sys, os, copy\n"
  "import urllib, shutil\n"
  "import subprocess, re\n"
  "from time import time\n"
  "import platform\n"
  "import json\n"
  "import threading, operator\n"
  "\n"
  "if sys.version_info >= (2, 6) :\n"
  "  import multiprocessing\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   processorCount                                                                                                     *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def processorCount () :\n"
  "  if sys.version_info >= (2, 6) :\n"
  "    coreCount = multiprocessing.cpu_count ()\n"
  "  else:\n"
  "    coreCount = 1\n"
  "  return coreCount\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   FOR PRINTING IN COLOR                                                                                              *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BLACK () :\n"
  "  return '\\033[90m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def RED () :\n"
  "  return '\\033[91m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def GREEN () :\n"
  "  return '\\033[92m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def YELLOW () :\n"
  "  return '\\033[93m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BLUE () :\n"
  "  return '\\033[94m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def MAGENTA () :\n"
  "  return '\\033[95m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def CYAN () :\n"
  "  return '\\033[96m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def WHITE () :\n"
  "  return '\\033[97m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def ENDC () :\n"
  "  return '\\033[0m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD () :\n"
  "  return '\\033[1m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def UNDERLINE () :\n"
  "  return '\\033[4m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BLINK () :\n"
  "  return '\\033[5m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_BLUE () :\n"
  "  return BOLD () + BLUE ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_GREEN () :\n"
  "  return BOLD () + GREEN ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_RED () :\n"
  "  return BOLD () + RED ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runHiddenCommand                                                                                                   *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runHiddenCommand (cmd) :\n"
  "  result = \"\"\n"
  "  childProcess = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n"
  "  while True:\n"
  "    line = childProcess.stdout.readline ()\n"
  "    if line != \"\":\n"
  "      result += line\n"
  "    else:\n"
  "      childProcess.wait ()\n"
  "      if childProcess.returncode != 0 :\n"
  "        sys.exit (childProcess.returncode)\n"
  "      return result\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runSingleCommand                                                                                                   *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runSingleCommand (cmd) :\n"
  "  cmdAsString = \"\"\n"
  "  for s in cmd:\n"
  "    if (s == \"\") or (s.find (\" \") >= 0):\n"
  "      cmdAsString += '\"' + s + '\" '\n"
  "    else:\n"
  "      cmdAsString += s + ' '\n"
  "  print cmdAsString\n"
  "  childProcess = subprocess.Popen (cmd)\n"
  "  childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runCommand                                                                                                         *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runCommand (cmd, title, showCommand) :\n"
  "  if title != \"\":\n"
  "    print BOLD_BLUE () + title + ENDC ()\n"
  "  if (title == \"\") or showCommand :\n"
  "    cmdAsString = \"\"\n"
  "    for s in cmd:\n"
  "      if (s == \"\") or (s.find (\" \") >= 0):\n"
  "        cmdAsString += '\"' + s + '\" '\n"
  "      else:\n"
  "        cmdAsString += s + ' '\n"
  "    print cmdAsString\n"
  "  childProcess = subprocess.Popen (cmd)\n"
  "  childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runInThread                                                                                                        *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runInThread (job, displayLock, terminationSemaphore):\n"
  "  childProcess = subprocess.Popen (job.mCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n"
  "  while True:\n"
  "    line = childProcess.stdout.readline ()\n"
  "    if line != \"\":\n"
  "      displayLock.acquire ()\n"
  "      sys.stdout.write (line) # Print without newline\n"
  "      displayLock.release ()\n"
  "    else:\n"
  "      childProcess.wait ()\n"
  "      job.mReturnCode = childProcess.returncode\n"
  "      terminationSemaphore.release ()\n"
  "      break\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   modificationDateForFile                                                                                            *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def modificationDateForFile (dateCacheDictionary, file):\n"
  "  absFilePath = os.path.abspath (file)\n"
  "  if dateCacheDictionary.has_key (absFilePath) :\n"
  "    return dateCacheDictionary [absFilePath]\n"
  "  elif not os.path.exists (absFilePath):\n"
  "    date = sys.float_info.max # Very far in future\n"
  "    dateCacheDictionary [absFilePath] = date\n"
  "    return date\n"
  "  else:\n"
  "    date = os.path.getmtime (absFilePath)\n"
  "    dateCacheDictionary [absFilePath] = date\n"
  "    return date\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class PostCommand                                                                                                  *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class PostCommand:\n"
  "  mCommand = []\n"
  "  mTitle = \"\"\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, title = \"\"):\n"
  "    self.mCommand = []\n"
  "    self.mTitle = title\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class Job                                                                                                          *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class Job:\n"
  "  mTarget = \"\"\n"
  "  mCommand = []\n"
  "  mTitle = \"\"\n"
  "  mRequiredFiles = []\n"
  "  mPostCommands = []\n"
  "  mReturnCode = None\n"
  "  mPriority = 0\n"
  "  mState = 0 # 0: waiting for execution\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, target, requiredFiles, command, postCommands, priority, title):\n"
  "    self.mTarget = copy.deepcopy (target)\n"
  "    self.mCommand = copy.deepcopy (command)\n"
  "    self.mRequiredFiles = copy.deepcopy (requiredFiles)\n"
  "    self.mTitle = copy.deepcopy (title)\n"
  "    self.mPostCommands = copy.deepcopy (postCommands)\n"
  "    self.mPriority = priority\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def run (self, displayLock, terminationSemaphore, showCommand):\n"
  "    displayLock.acquire ()\n"
  "    if self.mTitle != \"\":\n"
  "      print BOLD_BLUE () + self.mTitle + ENDC ()\n"
  "    if (self.mTitle == \"\") or showCommand :\n"
  "      cmdAsString = \"\"\n"
  "      for s in self.mCommand:\n"
  "        if (s == \"\") or (s.find (\" \") >= 0):\n"
  "          cmdAsString += '\"' + s + '\" '\n"
  "        else:\n"
  "          cmdAsString += s + ' '\n"
  "      print cmdAsString\n"
  "    displayLock.release ()\n"
  "    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n"
  "    thread.start()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def runPostCommand (self, displayLock, terminationSemaphore, showCommand):\n"
  "    postCommand = self.mPostCommands [0]\n"
  "    self.mCommand = postCommand.mCommand\n"
  "    displayLock.acquire ()\n"
  "    print BOLD_BLUE () + postCommand.mTitle + ENDC ()\n"
  "    if showCommand:\n"
  "      cmdAsString = \"\"\n"
  "      for s in self.mCommand:\n"
  "        if (s == \"\") or (s.find (\" \") >= 0):\n"
  "          cmdAsString += '\"' + s + '\" '\n"
  "        else:\n"
  "          cmdAsString += s + ' '\n"
  "      print cmdAsString\n"
  "    displayLock.release ()\n"
  "    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n"
  "    thread.start()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class Rule                                                                                                         *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class Rule:\n"
  "  mTarget = \"\"\n"
  "  mDependences = []\n"
  "  mCommand = []\n"
  "  mSecondaryMostRecentModificationDate = 0.0 # Far in the past\n"
  "  mTitle = \"\"\n"
  "  mPostCommands = []\n"
  "  mPriority = 0\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, target, title = \"\"):\n"
  "    self.mTarget = copy.deepcopy (target)\n"
  "    self.mDependences = []\n"
  "    self.mCommand = []\n"
  "    self.mSecondaryMostRecentModificationDate = 0.0\n"
  "    self.mPostCommands = []\n"
  "    self.mPriority = 0\n"
  "    if title == \"\":\n"
  "      self.mTitle = \"Building \" + target\n"
  "    else:\n"
  "      self.mTitle = copy.deepcopy (title)\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def enterSecondaryDependanceFile (self, secondaryDependanceFile):\n"
  "    if secondaryDependanceFile != \"\":\n"
  "      filePath = os.path.abspath (secondaryDependanceFile)\n"
  "      if os.path.exists (filePath):\n"
  "        f = open (filePath, \"r\")\n"
  "        s = f.read ().replace (\"\\\\ \", \"\\x01\") # Read and replace escaped spaces by \\0x01\n"
  "        f.close ()\n"
  "        s = s.replace (\"\\\\\\n\", \"\")\n"
  "        liste = s.split (\"\\n\\n\")\n"
  "        dateCacheDictionary = {}\n"
  "        for s in liste:\n"
  "          components = s.split (':')\n"
  "          target = components [0].replace (\"\\x01\", \" \")\n"
  "          #print \"------- Optional dependency rules for target '\" + target + \"'\"\n"
  "          #print \"Secondary target '\" + target + \"'\"\n"
  "          for src in components [1].split ():\n"
  "            secondarySource = src.replace (\"\\x01\", \" \")\n"
  "            #print \"  '\" + secondarySource + \"'\"\n"
  "            modifDate = modificationDateForFile (dateCacheDictionary, secondarySource)\n"
  "            if self.mSecondaryMostRecentModificationDate < modifDate :\n"
  "              self.mSecondaryMostRecentModificationDate = modifDate\n"
  "              #print BOLD_BLUE () + str (modifDate) + ENDC ()\n"
  "    \n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class Make                                                                                                         *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class Make:\n"
  "  mRuleList = []\n"
  "  mJobList = []\n"
  "  mErrorCount = 0\n"
  "  mModificationDateDictionary = {}\n"
  "  mGoals = {}\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def addRule (self, rule):\n"
  "    self.mRuleList.append (copy.deepcopy (rule))\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printRules (self):\n"
  "    print BOLD_BLUE () + \"--- Print the \" + str (len (self.mRuleList)) + \" rule\" + (\"s\" if len (self.mRuleList) > 1 else \"\") + \" ---\" + ENDC ()\n"
  "    for rule in self.mRuleList:\n"
  "      print BOLD_GREEN () + \"Target: '\" + rule.mTarget + \"'\" + ENDC ()\n"
  "      for dep in rule.mDependences:\n"
  "        print \"  Dependence: '\" + dep + \"'\"\n"
  "      s = \"  Command: \"\n"
  "      for cmd in rule.mCommand:\n"
  "        s += \" \\\"\" + cmd + \"\\\"\"\n"
  "      print s\n"
  "      print \"  Title: '\" + rule.mTitle + \"'\"\n"
  "      index = 0\n"
  "      for (command, title) in rule.mPostCommands:\n"
  "        index = index + 1\n"
  "        s = \"  Post command \" + str (index) + \": \"\n"
  "        for cmd in command:\n"
  "          s += \" \\\"\" + cmd + \"\\\"\"\n"
  "        print s\n"
  "        print \"  Its title: '\" + title + \"'\"\n"
  "        \n"
  "    print BOLD_BLUE () + \"--- End of print rule ---\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def writeRuleDependancesInDotFile (self, dotFileName):\n"
  "    s = \"digraph G {\\n\"\n"
  "    s += \"  node [fontname=courier]\\n\"\n"
  "    arrowSet = set ()\n"
  "    for rule in self.mRuleList:\n"
  "      s += '  \"' + rule.mTarget + '\" [shape=rectangle]\\n'\n"
  "      for dep in rule.mDependences:\n"
  "        arrowSet.add ('  \"' + rule.mTarget + '\" -> \"' + dep + '\"\\n')\n"
  "    for arrow in arrowSet:\n"
  "      s += arrow\n"
  "    s += \"}\\n\"\n"
  "    f = open (dotFileName, \"w\")\n"
  "    f.write (s)\n"
  "    f.close ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def checkRules (self):\n"
  "    if self.mErrorCount == 0:\n"
  "      ruleList = copy.deepcopy (self.mRuleList)\n"
  "      index = 0\n"
  "      looping = True\n"
  "    #--- loop on rules\n"
  "      while looping:\n"
  "        looping = False\n"
  "        while index < len (ruleList):\n"
  "          aRule = ruleList [index]\n"
  "          index = index + 1\n"
  "        #--- Check dependance files have rule for building, or does exist\n"
  "          depIdx = 0\n"
  "          while depIdx < len (aRule.mDependences):\n"
  "            dep = aRule.mDependences [depIdx]\n"
  "            depIdx = depIdx + 1\n"
  "            hasBuildRule = False\n"
  "            for r in ruleList:\n"
  "              if dep == r.mTarget:\n"
  "                hasBuildRule = True\n"
  "                break\n"
  "            if not hasBuildRule:\n"
  "              looping = True\n"
  "              if not os.path.exists (os.path.abspath (dep)):\n"
  "                self.mErrorCount = self.mErrorCount + 1\n"
  "                print BOLD_RED () + \"Check rules error: '\" + dep + \"' does not exist, and there is no rule for building it.\" + ENDC ()\n"
  "              depIdx = depIdx - 1\n"
  "              aRule.mDependences.pop (depIdx)\n"
  "        #--- Rule with no dependances\n"
  "          if len (aRule.mDependences) == 0 :\n"
  "            looping = True\n"
  "            index = index - 1\n"
  "            ruleList.pop (index)\n"
  "            idx = 0\n"
  "            while idx < len (ruleList):\n"
  "              r = ruleList [idx]\n"
  "              idx = idx + 1\n"
  "              while r.mDependences.count (aRule.mTarget) > 0 :\n"
  "                r.mDependences.remove (aRule.mTarget)\n"
  "    #--- Error if rules remain\n"
  "      if len (ruleList) > 0:\n"
  "        self.mErrorCount = self.mErrorCount + 1\n"
  "        print BOLD_RED () + \"Check rules error; circulary dependances between:\" + ENDC ()\n"
  "        for aRule in ruleList: \n"
  "          print BOLD_RED () + \"  - '\" + aRule.mTarget + \"', depends from:\" + ENDC ()\n"
  "          for dep in aRule.mDependences:\n"
  "            print BOLD_RED () + \"      '\" + dep + \"'\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def existsJobForTarget (self, target):\n"
  "    for job in self.mJobList:\n"
  "      if job.mTarget == target:\n"
  "        return True\n"
  "    return False\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def makeJob (self, target): # Return a bool indicating wheither the target should be built\n"
  "  #--- If there are errors, return immediatly\n"
  "    if self.mErrorCount != 0:\n"
  "      return False\n"
  "  #--- Target already in job list \?\n"
  "    if self.existsJobForTarget (target):\n"
  "      return True # yes, return target will be built\n"
  "  #--- Find a rule for making the target\n"
  "    absTarget = os.path.abspath (target)\n"
  "    rule = None\n"
  "    matchCount = 0\n"
  "    for r in self.mRuleList:\n"
  "      if target == r.mTarget:\n"
  "        matchCount = matchCount + 1\n"
  "        rule = r\n"
  "    if matchCount == 0:\n"
  "      absTarget = os.path.abspath (target)\n"
  "      if not os.path.exists (absTarget):\n"
  "        print BOLD_RED () + \"No rule for making '\" + target + \"'\" + ENDC ()\n"
  "        self.mErrorCount = self.mErrorCount + 1\n"
  "      return False # Error or target exists, and no rule for building it\n"
  "    elif matchCount > 1:\n"
  "      print BOLD_RED () + str (matchCount) + \" rules for making '\" + target + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "      return False # Error\n"
  "  #--- Target file does not exist, and 'rule' variable indicates how build it\n"
  "    appendToJobList = not os.path.exists (absTarget)\n"
  "  #--- Build primary dependences\n"
  "    jobDependenceFiles = []\n"
  "    for dependence in rule.mDependences:\n"
  "      willBeBuilt = self.makeJob (dependence)\n"
  "      if willBeBuilt:\n"
  "        jobDependenceFiles.append (dependence)\n"
  "        appendToJobList = True\n"
  "  #--- Check primary file modification dates\n"
  "    if not appendToJobList:\n"
  "      targetDateModification = os.path.getmtime (absTarget)\n"
  "      for source in rule.mDependences:\n"
  "        sourceDateModification = os.path.getmtime (source)\n"
  "        if targetDateModification < sourceDateModification:\n"
  "          appendToJobList = True\n"
  "          break\n"
  "  #--- Check for secondary dependancy files\n"
  "    if not appendToJobList:\n"
  "      targetDateModification = os.path.getmtime (absTarget)\n"
  "      if targetDateModification < rule.mSecondaryMostRecentModificationDate:\n"
  "        appendToJobList = True\n"
  "  #--- Append to job list\n"
  "    if appendToJobList:\n"
  "      self.mJobList.append (Job (target, jobDependenceFiles, rule.mCommand, rule.mPostCommands, rule.mPriority, rule.mTitle))\n"
  "  #--- Return\n"
  "    return appendToJobList\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "  #Job state\n"
  "  # 0: waiting\n"
  "  # 1:running\n"
  "  # 2: waiting for executing post command\n"
  "  # 3:executing for executing post command\n"
  "  # 4: completed\n"
  "\n"
  "  def runJobs (self, maxConcurrentJobs, showCommand):\n"
  "    if self.mErrorCount == 0:\n"
  "      if len (self.mJobList) == 0:\n"
  "        print BOLD_BLUE () + \"Nothing to make.\" + ENDC ()\n"
  "      else:\n"
  "      #--- Sort jobs following their priorities\n"
  "        self.mJobList = sorted (self.mJobList, key=operator.attrgetter(\"mPriority\"), reverse=True)\n"
  "      #--- Run\n"
  "        if maxConcurrentJobs <= 0:\n"
  "          maxConcurrentJobs = processorCount () - maxConcurrentJobs\n"
  "        jobCount = 0 ;\n"
  "        terminationSemaphore = threading.Semaphore (0)\n"
  "        displayLock = threading.Lock ()\n"
  "        loop = True\n"
  "        returnCode = 0\n"
  "        while loop:\n"
  "        #--- Launch jobs in parallel\n"
  "          for job in self.mJobList:\n"
  "            if (returnCode == 0) and (jobCount < maxConcurrentJobs):\n"
  "              if (job.mState == 0) and (len (job.mRequiredFiles) == 0):\n"
  "                #--- Create target directory if does not exist\n"
  "                absTargetDirectory = os.path.dirname (os.path.abspath (job.mTarget))\n"
  "                if not os.path.exists (absTargetDirectory):\n"
  "                  displayLock.acquire ()\n"
  "                  runCommand ([\"mkdir\", \"-p\", absTargetDirectory], \"Making \" + absTargetDirectory + \" directory\", showCommand)\n"
  "                  displayLock.release ()\n"
  "                #--- Run job\n"
  "                job.run (displayLock, terminationSemaphore, showCommand)\n"
  "                jobCount = jobCount + 1\n"
  "                job.mState = 1 # Means is running\n"
  "              elif job.mState == 2: # Waiting for executing post command\n"
  "                job.mReturnCode = None # Means post command not terminated\n"
  "                job.runPostCommand (displayLock, terminationSemaphore, showCommand)\n"
  "                jobCount = jobCount + 1\n"
  "                job.mState = 3 # Means post command is running\n"
  "        #--- Wait for a job termination\n"
  "          #print \"wait \" + str (jobCount) + \" \" + str (len (self.mJobList))\n"
  "          terminationSemaphore.acquire ()\n"
  "        #--- Checks for terminated jobs\n"
  "          index = 0\n"
  "          while index < len (self.mJobList):\n"
  "            job = self.mJobList [index]\n"
  "            index = index + 1\n"
  "            if (job.mState == 1) and (job.mReturnCode == 0) : # Terminated without error\n"
  "              jobCount = jobCount - 1\n"
  "              if len (job.mPostCommands) > 0:\n"
  "                job.mState = 2 # Ready to execute next post command\n"
  "              else:\n"
  "                job.mState = 4 # Completed\n"
  "                index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 1) and (job.mReturnCode > 0) : # terminated with error : exit\n"
  "              jobCount = jobCount - 1\n"
  "              job.mState = 4 # Means Terminated\n"
  "              index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 3) and (job.mReturnCode == 0): # post command is terminated without error\n"
  "              jobCount = jobCount - 1\n"
  "              job.mPostCommands.pop (0) # Remove completed post command\n"
  "              if len (job.mPostCommands) > 0:\n"
  "                job.mState = 2 # Ready to execute next post command\n"
  "              else:\n"
  "                job.mState = 4 # Completed\n"
  "                index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 3) and (job.mReturnCode > 0): # post command is terminated with error\n"
  "              jobCount = jobCount - 1\n"
  "              job.mState = 4 # Completed\n"
  "              index = index - 1 # For removing job from list\n"
  "            elif job.mState == 4: # Completed: delete job\n"
  "              index = index - 1\n"
  "              self.mJobList.pop (index) # Remove terminated job\n"
  "              #displayLock.acquire ()\n"
  "              #print \"Completed '\" + job.mTitle + \"'\"\n"
  "              #--- Remove dependences from this job\n"
  "              idx = 0\n"
  "              while idx < len (self.mJobList):\n"
  "                aJob = self.mJobList [idx]\n"
  "                idx = idx + 1\n"
  "                while aJob.mRequiredFiles.count (job.mTarget) > 0 :\n"
  "                  aJob.mRequiredFiles.remove (job.mTarget)\n"
  "                  #print \"  Removed from '\" + aJob.mTitle + \"': \" + str (len (aJob.mRequiredFiles))\n"
  "              #displayLock.release ()\n"
  "              #--- Signal error \?\n"
  "              if (job.mReturnCode > 0) and (returnCode == 0):\n"
  "                self.mErrorCount = self.mErrorCount + 1\n"
  "                print BOLD_RED () + \"Return code: \" + str (job.mReturnCode) + ENDC ()\n"
  "                if (returnCode == 0) and (jobCount > 0) :\n"
  "                  print \"Wait for job termination...\"\n"
  "                returnCode = job.mReturnCode\n"
  "          loop = (len (self.mJobList) > 0) if (returnCode == 0) else (jobCount > 0)\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def searchFileInDirectories (self, file, directoryList): # returns \"\" if not found, register error\n"
  "    matchCount = 0\n"
  "    result = \"\"\n"
  "    for sourceDir in directoryList:\n"
  "      sourcePath = sourceDir + \"/\" + file\n"
  "      if os.path.exists (os.path.abspath (sourcePath)):\n"
  "        matchCount = matchCount + 1\n"
  "        result = sourcePath\n"
  "    if matchCount == 0:\n"
  "      print BOLD_RED () + \"Cannot find '\" + file + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "    elif matchCount > 1:\n"
  "      print BOLD_RED () + str (matchCount) + \" source files for making '\" + file + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "      result = \"\"\n"
  "    return result\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def addGoal (self, goal, targetList, message):\n"
  "    self.mGoals [goal] = (targetList, message)\n"
  "    #print '%s' % ', '.join(map(str, self.mGoals))\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printGoals (self):\n"
  "    print BOLD_BLUE () + \"--- Print the \" + str (len (self.mGoals)) + \" goal\" + (\"s\" if len (self.mGoals) > 1 else \"\") + \" ---\" + ENDC ()\n"
  "    for goalKey in self.mGoals.keys ():\n"
  "      print BOLD_GREEN () + \"Goal: '\" + goalKey + \"'\" + ENDC ()\n"
  "      (targetList, message) = self.mGoals [goalKey]\n"
  "      for target in targetList:\n"
  "        print \"  Target: '\" + target + \"'\"\n"
  "      print \"  Message: '\" + message + \"'\"\n"
  "        \n"
  "    print BOLD_BLUE () + \"--- End of print goals ---\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def runGoal (self, goal, maxConcurrentJobs, showCommand):\n"
  "    if self.mGoals.has_key (goal) :\n"
  "      (targetList, message) = self.mGoals [goal]\n"
  "      for target in targetList:\n"
  "        self.makeJob (target)\n"
  "      self.runJobs (maxConcurrentJobs, showCommand)\n"
  "    else:\n"
  "      errorMessage = \"The '\" + goal + \"' goal is not defined; defined goals:\"\n"
  "      for key in self.mGoals:\n"
  "        (targetList, message) = self.mGoals [key]\n"
  "        errorMessage += \"\\n  '\" + key + \"': \" + message\n"
  "      print BOLD_RED () + errorMessage + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def enterError (self, message):\n"
  "    print BOLD_RED () + message + ENDC ()\n"
  "    self.mErrorCount = self.mErrorCount + 1\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printErrorCountAndExitOnError (self):\n"
  "    if self.mErrorCount == 1:\n"
  "      print BOLD_RED () + \"1 error.\" + ENDC ()\n"
  "      sys.exit (1)\n"
  "    elif self.mErrorCount > 1:\n"
  "      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n"
  "      sys.exit (1)\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printErrorCount (self):\n"
  "    if self.mErrorCount == 1:\n"
  "      print BOLD_RED () + \"1 error.\" + ENDC ()\n"
  "    elif self.mErrorCount > 1:\n"
  "      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def errorCount (self):\n"
  "    return self.mErrorCount\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Source files                                                                                                       *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def sourceList ():\n"
  "  return [\"plm.c\", \"startup-sequential.c\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Product directory                                                                                                  *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def productDir ():\n"
  "  return \"product\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#                         Object files directories                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def objectDir ():\n"
  "  return \"objects\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#                         Object files directories                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def asDir ():\n"
  "  return \"as\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Tool dir                                                                                                           *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def toolDir ():\n"
  "  return os.path.expanduser (\"~/plm-tools/teensy-Intel-Darwin-binutils-2.25-gcc-4.9.2-newlib-2.2.0-libusb-1.0.19\")\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Compiler invocation                                                                                                *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def compiler ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-gcc\", \"-mthumb\", \"-mcpu=cortex-m4\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#    C Compiler options                                                                                                *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def cCompilerOptions ():\n"
  "  result = []\n"
  "  result.append (\"-Wall\")\n"
  "  result.append (\"-Werror\")\n"
  "  result.append (\"-Wreturn-type\")\n"
  "  result.append (\"-Wformat\")\n"
  "  result.append (\"-Wsign-compare\")\n"
  "  result.append (\"-Wpointer-arith\")\n"
  "  result.append (\"-Wparentheses\")\n"
  "  result.append (\"-Wcast-align\")\n"
  "  result.append (\"-Wcast-qual\")\n"
  "  result.append (\"-Wwrite-strings\")\n"
  "  result.append (\"-Wswitch\")\n"
  "  result.append (\"-Wuninitialized\")\n"
  "  result.append (\"-fno-builtin\")\n"
  "  result.append (\"-Wno-aggressive-loop-optimizations\")\n"
  "  result.append (\"-ffunction-sections\")\n"
  "  result.append (\"-fdata-sections\")\n"
  "  result.append (\"-std=c99\")\n"
  "  result.append (\"-Wstrict-prototypes\")\n"
  "  result.append (\"-Wbad-function-cast\")\n"
  "  result.append (\"-Wmissing-declarations\")\n"
  "  result.append (\"-Wimplicit-function-declaration\")\n"
  "  result.append (\"-Wno-int-to-pointer-cast\")\n"
  "  result.append (\"-Wno-pointer-to-int-cast\")\n"
  "  result.append (\"-Wmissing-prototypes\")\n"
  "  result.append (\"-Os\")\n"
  "  result.append (\"-fomit-frame-pointer\")\n"
  "  result.append (\"-foptimize-register-move\") \n"
  "  result.append (\"-I../build\")\n"
  "  return result\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Linker invocation                                                                                                  *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def linker ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-gcc\", \"-mthumb\", \"-mcpu=cortex-m4\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Linker options                                                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def linkerOptions ():\n"
  "  result = []\n"
  "  result.append (\"-nostartfiles\")\n"
  "  result.append (\"-Wl,--fatal-warnings\")\n"
  "  result.append (\"-Wl,--warn-common\")\n"
  "  result.append (\"-Wl,--no-undefined\")\n"
  "  result.append (\"-Wl,--cref\")\n"
  "  result.append (\"-lc\")\n"
  "  result.append (\"-lgcc\")\n"
  "  result.append (\"-Wl,-static\")\n"
  "  result.append (\"-Wl,-s\")\n"
  "  result.append (\"-Wl,--gc-sections\")\n"
  "  return result\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   objcopy invocation                                                                                                 *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def objcopy ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-objcopy\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Teensy loader                                                                                                      *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def teensyLoader ():\n"
  "  return toolDir () + \"/bin/teensy-loader-cli\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   ARCHIVE DOWNLOAD                                                                                                   *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def downloadReportHook (a,b,fileSize): \n"
  "  if fileSize < (1 << 10):\n"
  "    sizeString = str (fileSize)\n"
  "  else:\n"
  "    if fileSize < (1 << 20):\n"
  "      sizeString = str (fileSize >> 10) + \"Ki\"\n"
  "    else:\n"
  "      sizeString = str (fileSize >> 20) + \"Mi\"\n"
  "  # \",\" at the end of the line is important!\n"
  "  print \"% 3.1f%% of %sB\\r\" % (min(100.0, float(a * b) / fileSize * 100.0), sizeString),\n"
  "  sys.stdout.flush()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def downloadArchive (archiveURL, archivePath):\n"
  "  runSingleCommand ([\"rm\", \"-f\", archivePath + \".downloading\"])\n"
  "  runSingleCommand ([\"rm\", \"-f\", archivePath + \".tar.bz2\"])\n"
  "  runSingleCommand ([\"mkdir\", \"-p\", os.path.dirname (archivePath)])\n"
  "  print \"URL: \"+ archiveURL\n"
  "  print \"Downloading... \" + archivePath + \".downloading\"\n"
  "  urllib.urlretrieve (archiveURL,  archivePath + \".downloading\", downloadReportHook)\n"
  "  print \"\"\n"
  "  fileSize = os.path.getsize (archivePath + \".downloading\")\n"
  "  ok = fileSize > 1000000\n"
  "  if ok:\n"
  "    runSingleCommand ([\"mv\", archivePath + \".downloading\", archivePath + \".tar.bz2\"])\n"
  "  else:\n"
  "    print BOLD_RED () + \"Error: cannot download file\" + ENDC ()\n"
  "    sys.exit (1)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   MAIN                                                                                                               *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Get max parallel jobs as first argument\n"
  "goal = \"all\"\n"
  "if len (sys.argv) > 1 :\n"
  "  goal = sys.argv [1]\n"
  "#--- Get max parallel jobs as first argument\n"
  "maxParallelJobs = 0 # 0 means use host processor count\n"
  "if len (sys.argv) > 2 :\n"
  "  maxParallelJobs = int (sys.argv [2])\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "#--- Download compiler tool if needed\n"
  "toolDirectory = toolDir ()\n"
  "if not os.path.exists (toolDirectory):\n"
  "  print BOLD_GREEN () + \"Downloading compiler tool chain\" + ENDC ()\n"
  "  archiveName = os.path.basename (toolDirectory)\n"
  "  archiveURL = \"http://crossgcc.rts-software.org/downloads/plm-tools/\" + archiveName + \".tar.bz2\"\n"
  "  downloadArchive (archiveURL, toolDirectory)\n"
  "  installDir = os.path.normpath (toolDirectory + \"/..\")\n"
  "  os.chdir (installDir)\n"
  "  runSingleCommand ([\"bunzip2\", \"-k\", archiveName + \".tar.bz2\"])\n"
  "  runSingleCommand ([\"rm\", archiveName + \".tar.bz2\"])\n"
  "  runSingleCommand ([\"tar\", \"xf\", archiveName + \".tar\"])\n"
  "  runSingleCommand ([\"rm\", archiveName + \".tar\"])\n"
  "#---\n"
  "os.chdir (scriptDir)\n"
  "#--- Build python makefile\n"
  "makefile = Make ()\n"
  "#--- Add C files compile rule\n"
  "objectList = []\n"
  "asObjectList = []\n"
  "for source in sourceList ():\n"
  "#--- Compile\n"
  "  object = objectDir () + \"/\" + source + \".o\"\n"
  "  rule = Rule (object, \"Compiling \" + source)\n"
  "  rule.mDependences.append (\"sources/\" + source)\n"
  "  rule.mCommand += compiler ()\n"
  "  rule.mCommand += cCompilerOptions ()\n"
  "  rule.mCommand += [\"-c\", \"sources/\" + source]\n"
  "  rule.mCommand += [\"-o\", object]\n"
  "  makefile.addRule (rule)\n"
  "  objectList.append (object)\n"
  "#--- Assembling\n"
  "  asObject = asDir () + \"/\" + source + \".s\"\n"
  "  rule = Rule (asObject, \"Assembling \" + source)\n"
  "  rule.mDependences.append (\"sources/\" + source)\n"
  "  rule.mCommand += compiler ()\n"
  "  rule.mCommand += cCompilerOptions ()\n"
  "  rule.mCommand += [\"-S\", \"sources/\" + source]\n"
  "  rule.mCommand += [\"-o\", asObject]\n"
  "  makefile.addRule (rule)\n"
  "  asObjectList.append (asObject)\n"
  "#--- Add linker rule\n"
  "productELF = productDir () + \"/product.elf\"\n"
  "rule = Rule (productELF, \"Linking \" + productELF)\n"
  "rule.mDependences += objectList\n"
  "rule.mCommand += linker ()\n"
  "rule.mCommand += linkerOptions ()\n"
  "rule.mCommand += objectList\n"
  "rule.mCommand += [\"-o\", productELF]\n"
  "rule.mCommand += [\"-Tsources/linker-script.ld\"]\n"
  "rule.mCommand += [\"-Wl,-Map=\" + productELF + \".map\"]\n"
  "makefile.addRule (rule)\n"
  "#--- Add objcopy rule\n"
  "productHEX = productDir () + \"/product.ihex\"\n"
  "rule = Rule (productHEX, \"Hexing \" + productHEX)\n"
  "rule.mDependences += [productELF]\n"
  "rule.mCommand += objcopy ()\n"
  "rule.mCommand += [\"-O\", \"ihex\"]\n"
  "rule.mCommand += [productELF]\n"
  "rule.mCommand += [productHEX]\n"
  "makefile.addRule (rule)\n"
  "#--- Add goals\n"
  "makefile.addGoal (\"run\", [productHEX], \"Building all and run\")\n"
  "makefile.addGoal (\"all\", [productHEX], \"Building all\")\n"
  "makefile.addGoal (\"as\", asObjectList, \"Assembling C files\")\n"
  "#--- Build\n"
  "#makefile.printRules ()\n"
  "makefile.runGoal (goal, maxParallelJobs, maxParallelJobs == 1)\n"
  "#--- Build Ok \?\n"
  "makefile.printErrorCountAndExitOnError ()\n"
  "#--- Run \?\n"
  "if goal == \"run\":\n"
  "  print BOLD_BLUE () + \"Loading Teensy...\" + ENDC ()\n"
  "  childProcess = subprocess.Popen ([teensyLoader (), \"-w\", \"-v\", \"-mmcu=mk20dx128\", productHEX])\n"
  "#--- Wait for subprocess termination\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    print BOLD_RED () + \"Error \" + str (childProcess.returncode) + ENDC ()\n"
  "    sys.exit (childProcess.returncode)\n"
  "  else:\n"
  "    print BOLD_GREEN () + \"Success\" + ENDC ()\n" ;

const cRegularFileWrapper gWrapperFile_8_targetTemplates (
  "build.py",
  "py",
  true, // Text file
  41653, // Text length
  gWrapperFileContent_8_targetTemplates
) ;

//--- File 'target-teensy-sequential/clean.py'

const char * gWrapperFileContent_9_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "#--- Directories to clean\n"
  "dir1 = scriptDir + \"/objects\"\n"
  "dir2 = scriptDir + \"/product\"\n"
  "dir3 = scriptDir + \"/as\"\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"rm\", \"-fr\", dir1, dir2, dir3], cwd=scriptDir)\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_9_targetTemplates (
  "clean.py",
  "py",
  true, // Text file
  1264, // Text length
  gWrapperFileContent_9_targetTemplates
) ;

//--- File 'target-teensy-sequential/flash-teensy-and-run.py'

const char * gWrapperFileContent_10_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"run\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_10_targetTemplates (
  "flash-teensy-and-run.py",
  "py",
  true, // Text file
  997, // Text length
  gWrapperFileContent_10_targetTemplates
) ;

//--- File 'sources/linker-script.ld'

const char * gWrapperFileContent_11_targetTemplates = "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                   Memory                                   */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "MEMORY {\n"
  "  flash (rx) : ORIGIN = 0, LENGTH = 256k \n"
  "  sram_u (rwx) : ORIGIN = 0x20000000, LENGTH = 32k \n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "__sram_u_end = 0x20000000 + 32k ;\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                ISR Vectors                                 */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .vectors : {\n"
  "    __vectors_start = . ;\n"
  "    KEEP (*(.isr_vector)) ;\n"
  "    __vectors_end = . ;\n"
  "  } > flash\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                    Code                                    */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .text : {\n"
  "    FILL(0xff)\n"
  "    __code_start = . ;\n"
  "  /*--- Tableau des routines d'initialisation */\n"
  "    . = ALIGN (4) ;\n"
  "    __init_routine_array_start = . ;\n"
  "    KEEP (*(init_routine_array)) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __init_routine_array_end = . ;\n"
  "  /*--- Initialisation des objets globaux C++ */\n"
  "    . = ALIGN (4) ;\n"
  "    __constructor_array_start = . ;\n"
  "    KEEP (*(.init_array)) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __constructor_array_end = . ;\n"
  "  /*--- Real Interrupt Service Routine Array */\n"
  "    . = ALIGN (4) ;\n"
  "    __real_time_isr_array_start = . ;\n"
  "    KEEP (*(real_time_isr_array)) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __real_time_isr_array_end = . ;\n"
  "  /*--- Code */\n"
  "    *(.text.*) ;\n"
  "    *(.text) ;\n"
  "    *(text) ;\n"
  "    *(.gnu.linkonce.t.*) ;\n"
  "  /*---- ROM data ----*/\n"
  "    . = ALIGN(4);\n"
  "    *(.rodata);\n"
  "    . = ALIGN(4);\n"
  "    *(.rodata*);\n"
  "    . = ALIGN(4);\n"
  "    *(.gnu.linkonce.r.*);\n"
  "    . = ALIGN(4);\n"
  "    *(.glue_7t);\n"
  "    . = ALIGN(4);\n"
  "    *(.glue_7);\n"
  "    . = ALIGN(4);\n"
  "  } > flash\n"
  "\n"
  "  .ARM.exidx : {\n"
  "    *(.ARM.exidx* .gnu.linkonce.armexidx.*);\n"
  "    __code_end = . ;\n"
  "  } > flash\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                          Data (initialized data)                           */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .data : {\n"
  "    FILL (0xFF)\n"
  "    . = ALIGN (4) ;\n"
  "    __data_start = . ;\n"
  "    * (.data.*init*) ;\n"
  "    * (.data*) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __data_end = . ;\n"
  "  } > sram_u AT > flash\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "__data_load_start = LOADADDR (.data) ;\n"
  "__data_load_end   = LOADADDR (.data) + SIZEOF (.data) ;\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                          BSS (uninitialized data)                          */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .bss : {\n"
  "    . = ALIGN(4);\n"
  "    __bss_start = . ;\n"
  "    * (.bss.*) ;\n"
  "    * (.bss) ;\n"
  "    * (COMMON) ;\n"
  "    . = ALIGN(4);\n"
  "    __bss_end = . ;\n"
  "  } > sram_u\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                System stack                                */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .system_stack :{\n"
  "    . = ALIGN (4) ;\n"
  "    __system_stack_start = . ;\n"
  "    . += 1k ;\n"
  "    . = ALIGN (4) ;\n"
  "    __system_stack_end = . ;\n"
  "  } > sram_u\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                    Heap                                    */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .heap : {\n"
  "    . = ALIGN (4) ;\n"
  "    __heap_start = . ;\n"
  "  } > sram_u\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "__heap_end = __sram_u_end ;\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n" ;

const cRegularFileWrapper gWrapperFile_11_targetTemplates (
  "linker-script.ld",
  "ld",
  true, // Text file
  5218, // Text length
  gWrapperFileContent_11_targetTemplates
) ;

//--- File 'sources/mk20dx256.h'

const char * gWrapperFileContent_12_targetTemplates = "/* Teensyduino Core Library\n"
  " * http://www.pjrc.com/teensy/\n"
  " * Copyright (c) 2013 PJRC.COM, LLC.\n"
  " *\n"
  " * Permission is hereby granted, free of charge, to any person obtaining\n"
  " * a copy of this software and associated documentation files (the\n"
  " * \"Software\"), to deal in the Software without restriction, including\n"
  " * without limitation the rights to use, copy, modify, merge, publish,\n"
  " * distribute, sublicense, and/or sell copies of the Software, and to\n"
  " * permit persons to whom the Software is furnished to do so, subject to\n"
  " * the following conditions:\n"
  " *\n"
  " * 1. The above copyright notice and this permission notice shall be \n"
  " * included in all copies or substantial portions of the Software.\n"
  " *\n"
  " * 2. If the Software is incorporated into a build system that allows \n"
  " * selection among a list of target devices, then similar target\n"
  " * devices manufactured by PJRC.COM must be included in the list of\n"
  " * target devices and selectable in the same manner.\n"
  " *\n"
  " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
  " * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
  " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
  " * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
  " * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
  " * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
  " * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
  " * SOFTWARE.\n"
  " */\n"
  "\n"
  "#ifndef _mk20dx128_h_\n"
  "#define _mk20dx128_h_\n"
  "\n"
  "#define F_CPU 96000000\n"
  "#define __MK20DX256__\n"
  "//#define F_CPU 48000000\n"
  "//#define F_CPU 24000000\n"
  "//#define F_BUS 48000000\n"
  "//#define F_BUS 24000000\n"
  "//#define F_MEM 24000000\n"
  "\n"
  "#if (F_CPU == 96000000)\n"
  " #define F_BUS 48000000\n"
  " #define F_MEM 24000000\n"
  "#elif (F_CPU == 48000000)\n"
  " #define F_BUS 48000000\n"
  " #define F_MEM 24000000\n"
  "#elif (F_CPU == 24000000)\n"
  " #define F_BUS 24000000\n"
  " #define F_MEM 24000000\n"
  "#endif\n"
  "\n"
  "\n"
  "#include <stdint.h>\n"
  "\n"
  "#ifdef __cplusplus\n"
  "extern \"C\" {\n"
  "#endif\n"
  "\n"
  "// chapter 11: Port control and interrupts (PORT)\n"
  "#define PORTA_PCR0\t\t*(volatile uint32_t *)0x40049000 // Pin Control Register n\n"
  "#define PORT_PCR_ISF\t\t\t(uint32_t)0x01000000\t\t// Interrupt Status Flag\n"
  "#define PORT_PCR_IRQC(n)\t\t(uint32_t)(((n) & 15) << 16)\t// Interrupt Configuration\n"
  "#define PORT_PCR_IRQC_MASK\t\t(uint32_t)0x000F0000\n"
  "#define PORT_PCR_LK\t\t\t(uint32_t)0x00008000\t\t// Lock Register\n"
  "#define PORT_PCR_MUX(n)\t\t\t(uint32_t)(((n) & 7) << 8)\t// Pin Mux Control\n"
  "#define PORT_PCR_MUX_MASK\t\t(uint32_t)0x00000700\n"
  "#define PORT_PCR_DSE\t\t\t(uint32_t)0x00000040\t\t// Drive Strength Enable\n"
  "#define PORT_PCR_ODE\t\t\t(uint32_t)0x00000020\t\t// Open Drain Enable\n"
  "#define PORT_PCR_PFE\t\t\t(uint32_t)0x00000010\t\t// Passive Filter Enable\n"
  "#define PORT_PCR_SRE\t\t\t(uint32_t)0x00000004\t\t// Slew Rate Enable\n"
  "#define PORT_PCR_PE\t\t\t(uint32_t)0x00000002\t\t// Pull Enable\n"
  "#define PORT_PCR_PS\t\t\t(uint32_t)0x00000001\t\t// Pull Select\n"
  "#define PORTA_PCR1\t\t*(volatile uint32_t *)0x40049004 // Pin Control Register n\n"
  "#define PORTA_PCR2\t\t*(volatile uint32_t *)0x40049008 // Pin Control Register n\n"
  "#define PORTA_PCR3\t\t*(volatile uint32_t *)0x4004900C // Pin Control Register n\n"
  "#define PORTA_PCR4\t\t*(volatile uint32_t *)0x40049010 // Pin Control Register n\n"
  "#define PORTA_PCR5\t\t*(volatile uint32_t *)0x40049014 // Pin Control Register n\n"
  "#define PORTA_PCR6\t\t*(volatile uint32_t *)0x40049018 // Pin Control Register n\n"
  "#define PORTA_PCR7\t\t*(volatile uint32_t *)0x4004901C // Pin Control Register n\n"
  "#define PORTA_PCR8\t\t*(volatile uint32_t *)0x40049020 // Pin Control Register n\n"
  "#define PORTA_PCR9\t\t*(volatile uint32_t *)0x40049024 // Pin Control Register n\n"
  "#define PORTA_PCR10\t\t*(volatile uint32_t *)0x40049028 // Pin Control Register n\n"
  "#define PORTA_PCR11\t\t*(volatile uint32_t *)0x4004902C // Pin Control Register n\n"
  "#define PORTA_PCR12\t\t*(volatile uint32_t *)0x40049030 // Pin Control Register n\n"
  "#define PORTA_PCR13\t\t*(volatile uint32_t *)0x40049034 // Pin Control Register n\n"
  "#define PORTA_PCR14\t\t*(volatile uint32_t *)0x40049038 // Pin Control Register n\n"
  "#define PORTA_PCR15\t\t*(volatile uint32_t *)0x4004903C // Pin Control Register n\n"
  "#define PORTA_PCR16\t\t*(volatile uint32_t *)0x40049040 // Pin Control Register n\n"
  "#define PORTA_PCR17\t\t*(volatile uint32_t *)0x40049044 // Pin Control Register n\n"
  "#define PORTA_PCR18\t\t*(volatile uint32_t *)0x40049048 // Pin Control Register n\n"
  "#define PORTA_PCR19\t\t*(volatile uint32_t *)0x4004904C // Pin Control Register n\n"
  "#define PORTA_PCR20\t\t*(volatile uint32_t *)0x40049050 // Pin Control Register n\n"
  "#define PORTA_PCR21\t\t*(volatile uint32_t *)0x40049054 // Pin Control Register n\n"
  "#define PORTA_PCR22\t\t*(volatile uint32_t *)0x40049058 // Pin Control Register n\n"
  "#define PORTA_PCR23\t\t*(volatile uint32_t *)0x4004905C // Pin Control Register n\n"
  "#define PORTA_PCR24\t\t*(volatile uint32_t *)0x40049060 // Pin Control Register n\n"
  "#define PORTA_PCR25\t\t*(volatile uint32_t *)0x40049064 // Pin Control Register n\n"
  "#define PORTA_PCR26\t\t*(volatile uint32_t *)0x40049068 // Pin Control Register n\n"
  "#define PORTA_PCR27\t\t*(volatile uint32_t *)0x4004906C // Pin Control Register n\n"
  "#define PORTA_PCR28\t\t*(volatile uint32_t *)0x40049070 // Pin Control Register n\n"
  "#define PORTA_PCR29\t\t*(volatile uint32_t *)0x40049074 // Pin Control Register n\n"
  "#define PORTA_PCR30\t\t*(volatile uint32_t *)0x40049078 // Pin Control Register n\n"
  "#define PORTA_PCR31\t\t*(volatile uint32_t *)0x4004907C // Pin Control Register n\n"
  "#define PORTA_GPCLR\t\t*(volatile uint32_t *)0x40049080 // Global Pin Control Low Register\n"
  "#define PORTA_GPCHR\t\t*(volatile uint32_t *)0x40049084 // Global Pin Control High Register\n"
  "#define PORTA_ISFR\t\t*(volatile uint32_t *)0x400490A0 // Interrupt Status Flag Register\n"
  "#define PORTB_PCR0\t\t*(volatile uint32_t *)0x4004A000 // Pin Control Register n\n"
  "#define PORTB_PCR1\t\t*(volatile uint32_t *)0x4004A004 // Pin Control Register n\n"
  "#define PORTB_PCR2\t\t*(volatile uint32_t *)0x4004A008 // Pin Control Register n\n"
  "#define PORTB_PCR3\t\t*(volatile uint32_t *)0x4004A00C // Pin Control Register n\n"
  "#define PORTB_PCR4\t\t*(volatile uint32_t *)0x4004A010 // Pin Control Register n\n"
  "#define PORTB_PCR5\t\t*(volatile uint32_t *)0x4004A014 // Pin Control Register n\n"
  "#define PORTB_PCR6\t\t*(volatile uint32_t *)0x4004A018 // Pin Control Register n\n"
  "#define PORTB_PCR7\t\t*(volatile uint32_t *)0x4004A01C // Pin Control Register n\n"
  "#define PORTB_PCR8\t\t*(volatile uint32_t *)0x4004A020 // Pin Control Register n\n"
  "#define PORTB_PCR9\t\t*(volatile uint32_t *)0x4004A024 // Pin Control Register n\n"
  "#define PORTB_PCR10\t\t*(volatile uint32_t *)0x4004A028 // Pin Control Register n\n"
  "#define PORTB_PCR11\t\t*(volatile uint32_t *)0x4004A02C // Pin Control Register n\n"
  "#define PORTB_PCR12\t\t*(volatile uint32_t *)0x4004A030 // Pin Control Register n\n"
  "#define PORTB_PCR13\t\t*(volatile uint32_t *)0x4004A034 // Pin Control Register n\n"
  "#define PORTB_PCR14\t\t*(volatile uint32_t *)0x4004A038 // Pin Control Register n\n"
  "#define PORTB_PCR15\t\t*(volatile uint32_t *)0x4004A03C // Pin Control Register n\n"
  "#define PORTB_PCR16\t\t*(volatile uint32_t *)0x4004A040 // Pin Control Register n\n"
  "#define PORTB_PCR17\t\t*(volatile uint32_t *)0x4004A044 // Pin Control Register n\n"
  "#define PORTB_PCR18\t\t*(volatile uint32_t *)0x4004A048 // Pin Control Register n\n"
  "#define PORTB_PCR19\t\t*(volatile uint32_t *)0x4004A04C // Pin Control Register n\n"
  "#define PORTB_PCR20\t\t*(volatile uint32_t *)0x4004A050 // Pin Control Register n\n"
  "#define PORTB_PCR21\t\t*(volatile uint32_t *)0x4004A054 // Pin Control Register n\n"
  "#define PORTB_PCR22\t\t*(volatile uint32_t *)0x4004A058 // Pin Control Register n\n"
  "#define PORTB_PCR23\t\t*(volatile uint32_t *)0x4004A05C // Pin Control Register n\n"
  "#define PORTB_PCR24\t\t*(volatile uint32_t *)0x4004A060 // Pin Control Register n\n"
  "#define PORTB_PCR25\t\t*(volatile uint32_t *)0x4004A064 // Pin Control Register n\n"
  "#define PORTB_PCR26\t\t*(volatile uint32_t *)0x4004A068 // Pin Control Register n\n"
  "#define PORTB_PCR27\t\t*(volatile uint32_t *)0x4004A06C // Pin Control Register n\n"
  "#define PORTB_PCR28\t\t*(volatile uint32_t *)0x4004A070 // Pin Control Register n\n"
  "#define PORTB_PCR29\t\t*(volatile uint32_t *)0x4004A074 // Pin Control Register n\n"
  "#define PORTB_PCR30\t\t*(volatile uint32_t *)0x4004A078 // Pin Control Register n\n"
  "#define PORTB_PCR31\t\t*(volatile uint32_t *)0x4004A07C // Pin Control Register n\n"
  "#define PORTB_GPCLR\t\t*(volatile uint32_t *)0x4004A080 // Global Pin Control Low Register\n"
  "#define PORTB_GPCHR\t\t*(volatile uint32_t *)0x4004A084 // Global Pin Control High Register\n"
  "#define PORTB_ISFR\t\t*(volatile uint32_t *)0x4004A0A0 // Interrupt Status Flag Register\n"
  "#define PORTC_PCR0\t\t*(volatile uint32_t *)0x4004B000 // Pin Control Register n\n"
  "#define PORTC_PCR1\t\t*(volatile uint32_t *)0x4004B004 // Pin Control Register n\n"
  "#define PORTC_PCR2\t\t*(volatile uint32_t *)0x4004B008 // Pin Control Register n\n"
  "#define PORTC_PCR3\t\t*(volatile uint32_t *)0x4004B00C // Pin Control Register n\n"
  "#define PORTC_PCR4\t\t*(volatile uint32_t *)0x4004B010 // Pin Control Register n\n"
  "#define PORTC_PCR5\t\t*(volatile uint32_t *)0x4004B014 // Pin Control Register n\n"
  "#define PORTC_PCR6\t\t*(volatile uint32_t *)0x4004B018 // Pin Control Register n\n"
  "#define PORTC_PCR7\t\t*(volatile uint32_t *)0x4004B01C // Pin Control Register n\n"
  "#define PORTC_PCR8\t\t*(volatile uint32_t *)0x4004B020 // Pin Control Register n\n"
  "#define PORTC_PCR9\t\t*(volatile uint32_t *)0x4004B024 // Pin Control Register n\n"
  "#define PORTC_PCR10\t\t*(volatile uint32_t *)0x4004B028 // Pin Control Register n\n"
  "#define PORTC_PCR11\t\t*(volatile uint32_t *)0x4004B02C // Pin Control Register n\n"
  "#define PORTC_PCR12\t\t*(volatile uint32_t *)0x4004B030 // Pin Control Register n\n"
  "#define PORTC_PCR13\t\t*(volatile uint32_t *)0x4004B034 // Pin Control Register n\n"
  "#define PORTC_PCR14\t\t*(volatile uint32_t *)0x4004B038 // Pin Control Register n\n"
  "#define PORTC_PCR15\t\t*(volatile uint32_t *)0x4004B03C // Pin Control Register n\n"
  "#define PORTC_PCR16\t\t*(volatile uint32_t *)0x4004B040 // Pin Control Register n\n"
  "#define PORTC_PCR17\t\t*(volatile uint32_t *)0x4004B044 // Pin Control Register n\n"
  "#define PORTC_PCR18\t\t*(volatile uint32_t *)0x4004B048 // Pin Control Register n\n"
  "#define PORTC_PCR19\t\t*(volatile uint32_t *)0x4004B04C // Pin Control Register n\n"
  "#define PORTC_PCR20\t\t*(volatile uint32_t *)0x4004B050 // Pin Control Register n\n"
  "#define PORTC_PCR21\t\t*(volatile uint32_t *)0x4004B054 // Pin Control Register n\n"
  "#define PORTC_PCR22\t\t*(volatile uint32_t *)0x4004B058 // Pin Control Register n\n"
  "#define PORTC_PCR23\t\t*(volatile uint32_t *)0x4004B05C // Pin Control Register n\n"
  "#define PORTC_PCR24\t\t*(volatile uint32_t *)0x4004B060 // Pin Control Register n\n"
  "#define PORTC_PCR25\t\t*(volatile uint32_t *)0x4004B064 // Pin Control Register n\n"
  "#define PORTC_PCR26\t\t*(volatile uint32_t *)0x4004B068 // Pin Control Register n\n"
  "#define PORTC_PCR27\t\t*(volatile uint32_t *)0x4004B06C // Pin Control Register n\n"
  "#define PORTC_PCR28\t\t*(volatile uint32_t *)0x4004B070 // Pin Control Register n\n"
  "#define PORTC_PCR29\t\t*(volatile uint32_t *)0x4004B074 // Pin Control Register n\n"
  "#define PORTC_PCR30\t\t*(volatile uint32_t *)0x4004B078 // Pin Control Register n\n"
  "#define PORTC_PCR31\t\t*(volatile uint32_t *)0x4004B07C // Pin Control Register n\n"
  "#define PORTC_GPCLR\t\t*(volatile uint32_t *)0x4004B080 // Global Pin Control Low Register\n"
  "#define PORTC_GPCHR\t\t*(volatile uint32_t *)0x4004B084 // Global Pin Control High Register\n"
  "#define PORTC_ISFR\t\t*(volatile uint32_t *)0x4004B0A0 // Interrupt Status Flag Register\n"
  "#define PORTD_PCR0\t\t*(volatile uint32_t *)0x4004C000 // Pin Control Register n\n"
  "#define PORTD_PCR1\t\t*(volatile uint32_t *)0x4004C004 // Pin Control Register n\n"
  "#define PORTD_PCR2\t\t*(volatile uint32_t *)0x4004C008 // Pin Control Register n\n"
  "#define PORTD_PCR3\t\t*(volatile uint32_t *)0x4004C00C // Pin Control Register n\n"
  "#define PORTD_PCR4\t\t*(volatile uint32_t *)0x4004C010 // Pin Control Register n\n"
  "#define PORTD_PCR5\t\t*(volatile uint32_t *)0x4004C014 // Pin Control Register n\n"
  "#define PORTD_PCR6\t\t*(volatile uint32_t *)0x4004C018 // Pin Control Register n\n"
  "#define PORTD_PCR7\t\t*(volatile uint32_t *)0x4004C01C // Pin Control Register n\n"
  "#define PORTD_PCR8\t\t*(volatile uint32_t *)0x4004C020 // Pin Control Register n\n"
  "#define PORTD_PCR9\t\t*(volatile uint32_t *)0x4004C024 // Pin Control Register n\n"
  "#define PORTD_PCR10\t\t*(volatile uint32_t *)0x4004C028 // Pin Control Register n\n"
  "#define PORTD_PCR11\t\t*(volatile uint32_t *)0x4004C02C // Pin Control Register n\n"
  "#define PORTD_PCR12\t\t*(volatile uint32_t *)0x4004C030 // Pin Control Register n\n"
  "#define PORTD_PCR13\t\t*(volatile uint32_t *)0x4004C034 // Pin Control Register n\n"
  "#define PORTD_PCR14\t\t*(volatile uint32_t *)0x4004C038 // Pin Control Register n\n"
  "#define PORTD_PCR15\t\t*(volatile uint32_t *)0x4004C03C // Pin Control Register n\n"
  "#define PORTD_PCR16\t\t*(volatile uint32_t *)0x4004C040 // Pin Control Register n\n"
  "#define PORTD_PCR17\t\t*(volatile uint32_t *)0x4004C044 // Pin Control Register n\n"
  "#define PORTD_PCR18\t\t*(volatile uint32_t *)0x4004C048 // Pin Control Register n\n"
  "#define PORTD_PCR19\t\t*(volatile uint32_t *)0x4004C04C // Pin Control Register n\n"
  "#define PORTD_PCR20\t\t*(volatile uint32_t *)0x4004C050 // Pin Control Register n\n"
  "#define PORTD_PCR21\t\t*(volatile uint32_t *)0x4004C054 // Pin Control Register n\n"
  "#define PORTD_PCR22\t\t*(volatile uint32_t *)0x4004C058 // Pin Control Register n\n"
  "#define PORTD_PCR23\t\t*(volatile uint32_t *)0x4004C05C // Pin Control Register n\n"
  "#define PORTD_PCR24\t\t*(volatile uint32_t *)0x4004C060 // Pin Control Register n\n"
  "#define PORTD_PCR25\t\t*(volatile uint32_t *)0x4004C064 // Pin Control Register n\n"
  "#define PORTD_PCR26\t\t*(volatile uint32_t *)0x4004C068 // Pin Control Register n\n"
  "#define PORTD_PCR27\t\t*(volatile uint32_t *)0x4004C06C // Pin Control Register n\n"
  "#define PORTD_PCR28\t\t*(volatile uint32_t *)0x4004C070 // Pin Control Register n\n"
  "#define PORTD_PCR29\t\t*(volatile uint32_t *)0x4004C074 // Pin Control Register n\n"
  "#define PORTD_PCR30\t\t*(volatile uint32_t *)0x4004C078 // Pin Control Register n\n"
  "#define PORTD_PCR31\t\t*(volatile uint32_t *)0x4004C07C // Pin Control Register n\n"
  "#define PORTD_GPCLR\t\t*(volatile uint32_t *)0x4004C080 // Global Pin Control Low Register\n"
  "#define PORTD_GPCHR\t\t*(volatile uint32_t *)0x4004C084 // Global Pin Control High Register\n"
  "#define PORTD_ISFR\t\t*(volatile uint32_t *)0x4004C0A0 // Interrupt Status Flag Register\n"
  "#define PORTE_PCR0\t\t*(volatile uint32_t *)0x4004D000 // Pin Control Register n\n"
  "#define PORTE_PCR1\t\t*(volatile uint32_t *)0x4004D004 // Pin Control Register n\n"
  "#define PORTE_PCR2\t\t*(volatile uint32_t *)0x4004D008 // Pin Control Register n\n"
  "#define PORTE_PCR3\t\t*(volatile uint32_t *)0x4004D00C // Pin Control Register n\n"
  "#define PORTE_PCR4\t\t*(volatile uint32_t *)0x4004D010 // Pin Control Register n\n"
  "#define PORTE_PCR5\t\t*(volatile uint32_t *)0x4004D014 // Pin Control Register n\n"
  "#define PORTE_PCR6\t\t*(volatile uint32_t *)0x4004D018 // Pin Control Register n\n"
  "#define PORTE_PCR7\t\t*(volatile uint32_t *)0x4004D01C // Pin Control Register n\n"
  "#define PORTE_PCR8\t\t*(volatile uint32_t *)0x4004D020 // Pin Control Register n\n"
  "#define PORTE_PCR9\t\t*(volatile uint32_t *)0x4004D024 // Pin Control Register n\n"
  "#define PORTE_PCR10\t\t*(volatile uint32_t *)0x4004D028 // Pin Control Register n\n"
  "#define PORTE_PCR11\t\t*(volatile uint32_t *)0x4004D02C // Pin Control Register n\n"
  "#define PORTE_PCR12\t\t*(volatile uint32_t *)0x4004D030 // Pin Control Register n\n"
  "#define PORTE_PCR13\t\t*(volatile uint32_t *)0x4004D034 // Pin Control Register n\n"
  "#define PORTE_PCR14\t\t*(volatile uint32_t *)0x4004D038 // Pin Control Register n\n"
  "#define PORTE_PCR15\t\t*(volatile uint32_t *)0x4004D03C // Pin Control Register n\n"
  "#define PORTE_PCR16\t\t*(volatile uint32_t *)0x4004D040 // Pin Control Register n\n"
  "#define PORTE_PCR17\t\t*(volatile uint32_t *)0x4004D044 // Pin Control Register n\n"
  "#define PORTE_PCR18\t\t*(volatile uint32_t *)0x4004D048 // Pin Control Register n\n"
  "#define PORTE_PCR19\t\t*(volatile uint32_t *)0x4004D04C // Pin Control Register n\n"
  "#define PORTE_PCR20\t\t*(volatile uint32_t *)0x4004D050 // Pin Control Register n\n"
  "#define PORTE_PCR21\t\t*(volatile uint32_t *)0x4004D054 // Pin Control Register n\n"
  "#define PORTE_PCR22\t\t*(volatile uint32_t *)0x4004D058 // Pin Control Register n\n"
  "#define PORTE_PCR23\t\t*(volatile uint32_t *)0x4004D05C // Pin Control Register n\n"
  "#define PORTE_PCR24\t\t*(volatile uint32_t *)0x4004D060 // Pin Control Register n\n"
  "#define PORTE_PCR25\t\t*(volatile uint32_t *)0x4004D064 // Pin Control Register n\n"
  "#define PORTE_PCR26\t\t*(volatile uint32_t *)0x4004D068 // Pin Control Register n\n"
  "#define PORTE_PCR27\t\t*(volatile uint32_t *)0x4004D06C // Pin Control Register n\n"
  "#define PORTE_PCR28\t\t*(volatile uint32_t *)0x4004D070 // Pin Control Register n\n"
  "#define PORTE_PCR29\t\t*(volatile uint32_t *)0x4004D074 // Pin Control Register n\n"
  "#define PORTE_PCR30\t\t*(volatile uint32_t *)0x4004D078 // Pin Control Register n\n"
  "#define PORTE_PCR31\t\t*(volatile uint32_t *)0x4004D07C // Pin Control Register n\n"
  "#define PORTE_GPCLR\t\t*(volatile uint32_t *)0x4004D080 // Global Pin Control Low Register\n"
  "#define PORTE_GPCHR\t\t*(volatile uint32_t *)0x4004D084 // Global Pin Control High Register\n"
  "#define PORTE_ISFR\t\t*(volatile uint32_t *)0x4004D0A0 // Interrupt Status Flag Register\n"
  "\n"
  "// Chapter 12: System Integration Module (SIM)\n"
  "#define SIM_SOPT1\t\t*(volatile uint32_t *)0x40047000 // System Options Register 1\n"
  "#define SIM_SOPT1CFG\t\t*(volatile uint32_t *)0x40047004 // SOPT1 Configuration Register\n"
  "#define SIM_SOPT2\t\t*(volatile uint32_t *)0x40048004 // System Options Register 2\n"
  "#define SIM_SOPT2_USBSRC\t\t(uint32_t)0x00040000\t\t// 0=USB_CLKIN, 1=FFL/PLL \n"
  "#define SIM_SOPT2_PLLFLLSEL\t\t(uint32_t)0x00010000\t\t// 0=FLL, 1=PLL\n"
  "#define SIM_SOPT2_TRACECLKSEL\t\t(uint32_t)0x00001000\t\t// 0=MCGOUTCLK, 1=CPU\n"
  "#define SIM_SOPT2_PTD7PAD\t\t(uint32_t)0x00000800\t\t// 0=normal, 1=double drive PTD7\n"
  "#define SIM_SOPT2_CLKOUTSEL(n)\t\t(uint32_t)(((n) & 7) << 5)\t// Selects the clock to output on the CLKOUT pin.\n"
  "#define SIM_SOPT2_RTCCLKOUTSEL\t\t(uint32_t)0x00000010\t\t// RTC clock out select\n"
  "#define SIM_SOPT4\t\t*(volatile uint32_t *)0x4004800C // System Options Register 4\n"
  "#define SIM_SOPT5\t\t*(volatile uint32_t *)0x40048010 // System Options Register 5\n"
  "#define SIM_SOPT7\t\t*(volatile uint32_t *)0x40048018 // System Options Register 7\n"
  "#define SIM_SDID\t\t*(const\t   uint32_t *)0x40048024 // System Device Identification Register\n"
  "#define SIM_SCGC2\t\t*(volatile uint32_t *)0x4004802C // System Clock Gating Control Register 2\n"
  "#define SIM_SCGC2_DAC0\t\t\t(uint32_t)0x00001000\t\t// DAC0 Clock Gate Control\n"
  "#define SIM_SCGC3\t\t*(volatile uint32_t *)0x40048030 // System Clock Gating Control Register 3\n"
  "#define SIM_SCGC3_ADC1\t\t\t(uint32_t)0x08000000\t\t// ADC1 Clock Gate Control\n"
  "#define SIM_SCGC3_FTM2\t\t\t(uint32_t)0x01000000\t\t// FTM2 Clock Gate Control\n"
  "#define SIM_SCGC4\t\t*(volatile uint32_t *)0x40048034 // System Clock Gating Control Register 4\n"
  "#define SIM_SCGC4_VREF\t\t\t(uint32_t)0x00100000\t\t// VREF Clock Gate Control\n"
  "#define SIM_SCGC4_CMP\t\t\t(uint32_t)0x00080000\t\t// Comparator Clock Gate Control\n"
  "#define SIM_SCGC4_USBOTG\t\t(uint32_t)0x00040000\t\t// USB Clock Gate Control\n"
  "#define SIM_SCGC4_UART2\t\t\t(uint32_t)0x00001000\t\t// UART2 Clock Gate Control\n"
  "#define SIM_SCGC4_UART1\t\t\t(uint32_t)0x00000800\t\t// UART1 Clock Gate Control\n"
  "#define SIM_SCGC4_UART0\t\t\t(uint32_t)0x00000400\t\t// UART0 Clock Gate Control\n"
  "#define SIM_SCGC4_I2C1\t\t\t(uint32_t)0x00000080\t\t// I2C1 Clock Gate Control\n"
  "#define SIM_SCGC4_I2C0\t\t\t(uint32_t)0x00000040\t\t// I2C0 Clock Gate Control\n"
  "#define SIM_SCGC4_CMT\t\t\t(uint32_t)0x00000004\t\t// CMT Clock Gate Control\n"
  "#define SIM_SCGC4_EWM\t\t\t(uint32_t)0x00000002\t\t// EWM Clock Gate Control\n"
  "#define SIM_SCGC5\t\t*(volatile uint32_t *)0x40048038 // System Clock Gating Control Register 5\n"
  "#define SIM_SCGC5_PORTE\t\t\t(uint32_t)0x00002000\t\t// Port E Clock Gate Control\n"
  "#define SIM_SCGC5_PORTD\t\t\t(uint32_t)0x00001000\t\t// Port D Clock Gate Control\n"
  "#define SIM_SCGC5_PORTC\t\t\t(uint32_t)0x00000800\t\t// Port C Clock Gate Control\n"
  "#define SIM_SCGC5_PORTB\t\t\t(uint32_t)0x00000400\t\t// Port B Clock Gate Control\n"
  "#define SIM_SCGC5_PORTA\t\t\t(uint32_t)0x00000200\t\t// Port A Clock Gate Control\n"
  "#define SIM_SCGC5_TSI\t\t\t(uint32_t)0x00000020\t\t// Touch Sense Input TSI Clock Gate Control\n"
  "#define SIM_SCGC5_LPTIMER\t\t(uint32_t)0x00000001\t\t// Low Power Timer Access Control\n"
  "#define SIM_SCGC6\t\t*(volatile uint32_t *)0x4004803C // System Clock Gating Control Register 6\n"
  "#define SIM_SCGC6_RTC\t\t\t(uint32_t)0x20000000\t\t// RTC Access\n"
  "#define SIM_SCGC6_ADC0\t\t\t(uint32_t)0x08000000\t\t// ADC0 Clock Gate Control\n"
  "#define SIM_SCGC6_FTM1\t\t\t(uint32_t)0x02000000\t\t// FTM1 Clock Gate Control\n"
  "#define SIM_SCGC6_FTM0\t\t\t(uint32_t)0x01000000\t\t// FTM0 Clock Gate Control\n"
  "#define SIM_SCGC6_PIT\t\t\t(uint32_t)0x00800000\t\t// PIT Clock Gate Control\n"
  "#define SIM_SCGC6_PDB\t\t\t(uint32_t)0x00400000\t\t// PDB Clock Gate Control\n"
  "#define SIM_SCGC6_USBDCD\t\t(uint32_t)0x00200000\t\t// USB DCD Clock Gate Control\n"
  "#define SIM_SCGC6_CRC\t\t\t(uint32_t)0x00040000\t\t// CRC Clock Gate Control\n"
  "#define SIM_SCGC6_I2S\t\t\t(uint32_t)0x00008000\t\t// I2S Clock Gate Control\n"
  "#define SIM_SCGC6_SPI1\t\t\t(uint32_t)0x00002000\t\t// SPI1 Clock Gate Control\n"
  "#define SIM_SCGC6_SPI0\t\t\t(uint32_t)0x00001000\t\t// SPI0 Clock Gate Control\n"
  "#define SIM_SCGC6_FLEXCAN0\t\t(uint32_t)0x00000010\t\t// FlexCAN0 Clock Gate Control\n"
  "#define SIM_SCGC6_DMAMUX\t\t(uint32_t)0x00000002\t\t// DMA Mux Clock Gate Control\n"
  "#define SIM_SCGC6_FTFL\t\t\t(uint32_t)0x00000001\t\t// Flash Memory Clock Gate Control\n"
  "#define SIM_SCGC7\t\t*(volatile uint32_t *)0x40048040 // System Clock Gating Control Register 7\n"
  "#define SIM_SCGC7_DMA\t\t\t(uint32_t)0x00000002\t\t// DMA Clock Gate Control\n"
  "#define SIM_CLKDIV1\t\t*(volatile uint32_t *)0x40048044 // System Clock Divider Register 1\n"
  "#define SIM_CLKDIV1_OUTDIV1(n)\t\t(uint32_t)(((n) & 0x0F) << 28)\t// divide value for the core/system clock\n"
  "#define SIM_CLKDIV1_OUTDIV2(n)\t\t(uint32_t)(((n) & 0x0F) << 24)\t// divide value for the peripheral clock\n"
  "#define SIM_CLKDIV1_OUTDIV4(n)\t\t(uint32_t)(((n) & 0x0F) << 16)\t// divide value for the flash clock\n"
  "#define SIM_CLKDIV2\t\t*(volatile uint32_t *)0x40048048 // System Clock Divider Register 2\n"
  "#define SIM_CLKDIV2_USBDIV(n)\t\t(uint32_t)(((n) & 0x07) << 1)\n"
  "#define SIM_CLKDIV2_USBFRAC\t\t(uint32_t)0x01\n"
  "#define SIM_FCFG1\t\t*(const\t   uint32_t *)0x4004804C // Flash Configuration Register 1\n"
  "#define SIM_FCFG2\t\t*(const\t   uint32_t *)0x40048050 // Flash Configuration Register 2\n"
  "#define SIM_UIDH\t\t*(const\t   uint32_t *)0x40048054 // Unique Identification Register High\n"
  "#define SIM_UIDMH\t\t*(const\t   uint32_t *)0x40048058 // Unique Identification Register Mid-High\n"
  "#define SIM_UIDML\t\t*(const\t   uint32_t *)0x4004805C // Unique Identification Register Mid Low\n"
  "#define SIM_UIDL\t\t*(const\t   uint32_t *)0x40048060 // Unique Identification Register Low\n"
  "\n"
  "// Chapter 13: Reset Control Module (RCM)\n"
  "#define RCM_SRS0\t\t*(volatile uint8_t  *)0x4007F000 // System Reset Status Register 0\n"
  "#define RCM_SRS1\t\t*(volatile uint8_t  *)0x4007F001 // System Reset Status Register 1\n"
  "#define RCM_RPFC\t\t*(volatile uint8_t  *)0x4007F004 // Reset Pin Filter Control Register\n"
  "#define RCM_RPFW\t\t*(volatile uint8_t  *)0x4007F005 // Reset Pin Filter Width Register\n"
  "#define RCM_MR\t\t\t*(volatile uint8_t  *)0x4007F007 // Mode Register\n"
  "\n"
  "// Chapter 14: System Mode Controller\n"
  "#define SMC_PMPROT\t\t*(volatile uint8_t  *)0x4007E000 // Power Mode Protection Register\n"
  "#define SMC_PMPROT_AVLP\t\t\t(uint8_t)0x20\t\t\t// Allow very low power modes\n"
  "#define SMC_PMPROT_ALLS\t\t\t(uint8_t)0x08\t\t\t// Allow low leakage stop mode\n"
  "#define SMC_PMPROT_AVLLS\t\t(uint8_t)0x02\t\t\t// Allow very low leakage stop mode\n"
  "#define SMC_PMCTRL\t\t*(volatile uint8_t  *)0x4007E001 // Power Mode Control Register\n"
  "#define SMC_PMCTRL_LPWUI\t\t(uint8_t)0x80\t\t\t// Low Power Wake Up on Interrupt\n"
  "#define SMC_PMCTRL_RUNM(n)\t\t(uint8_t)(((n) & 0x03) << 5)\t// Run Mode Control\n"
  "#define SMC_PMCTRL_STOPA\t\t(uint8_t)0x08\t\t\t// Stop Aborted\n"
  "#define SMC_PMCTRL_STOPM(n)\t\t(uint8_t)((n) & 0x07)\t\t// Stop Mode Control\n"
  "#define SMC_VLLSCTRL\t\t*(volatile uint8_t  *)0x4007E002 // VLLS Control Register\n"
  "#define SMC_VLLSCTRL_PORPO\t\t(uint8_t)0x20\t\t\t// POR Power Option\n"
  "#define SMC_VLLSCTRL_VLLSM(n)\t\t(uint8_t)((n) & 0x07)\t\t// VLLS Mode Control\n"
  "#define SMC_PMSTAT\t\t*(volatile uint8_t  *)0x4007E003 // Power Mode Status Register\n"
  "#define SMC_PMSTAT_RUN\t\t\t(uint8_t)0x01\t\t\t// Current power mode is RUN\n"
  "#define SMC_PMSTAT_STOP\t\t\t(uint8_t)0x02\t\t\t// Current power mode is STOP\n"
  "#define SMC_PMSTAT_VLPR\t\t\t(uint8_t)0x04\t\t\t// Current power mode is VLPR\n"
  "#define SMC_PMSTAT_VLPW\t\t\t(uint8_t)0x08\t\t\t// Current power mode is VLPW\n"
  "#define SMC_PMSTAT_VLPS\t\t\t(uint8_t)0x10\t\t\t// Current power mode is VLPS\n"
  "#define SMC_PMSTAT_LLS\t\t\t(uint8_t)0x20\t\t\t// Current power mode is LLS\n"
  "#define SMC_PMSTAT_VLLS\t\t\t(uint8_t)0x40\t\t\t// Current power mode is VLLS\n"
  "\n"
  "// Chapter 15: Power Management Controller\n"
  "#define PMC_LVDSC1\t\t*(volatile uint8_t  *)0x4007D000 // Low Voltage Detect Status And Control 1 register\n"
  "#define PMC_LVDSC1_LVDF\t\t\t(uint8_t)0x80\t\t\t// Low-Voltage Detect Flag\n"
  "#define PMC_LVDSC1_LVDACK\t\t(uint8_t)0x40\t\t\t// Low-Voltage Detect Acknowledge\n"
  "#define PMC_LVDSC1_LVDIE\t\t(uint8_t)0x20\t\t\t// Low-Voltage Detect Interrupt Enable\n"
  "#define PMC_LVDSC1_LVDRE\t\t(uint8_t)0x10\t\t\t// Low-Voltage Detect Reset Enable\n"
  "#define PMC_LVDSC1_LVDV(n)\t\t(uint8_t)((n) & 0x03)\t\t// Low-Voltage Detect Voltage Select\n"
  "#define PMC_LVDSC2\t\t*(volatile uint8_t  *)0x4007D001 // Low Voltage Detect Status And Control 2 register\n"
  "#define PMC_LVDSC2_LVWF\t\t\t(uint8_t)0x80\t\t\t// Low-Voltage Warning Flag\n"
  "#define PMC_LVDSC2_LVWACK\t\t(uint8_t)0x40\t\t\t// Low-Voltage Warning Acknowledge\n"
  "#define PMC_LVDSC2_LVWIE\t\t(uint8_t)0x20\t\t\t// Low-Voltage Warning Interrupt Enable\n"
  "#define PMC_LVDSC2_LVWV(n)\t\t(uint8_t)((n) & 0x03)\t\t// Low-Voltage Warning Voltage Select\n"
  "#define PMC_REGSC\t\t*(volatile uint8_t  *)0x4007D002 // Regulator Status And Control register\n"
  "#define PMC_REGSC_BGEN\t\t\t(uint8_t)0x10\t\t\t// Bandgap Enable In VLPx Operation\n"
  "#define PMC_REGSC_ACKISO\t\t(uint8_t)0x08\t\t\t// Acknowledge Isolation\n"
  "#define PMC_REGSC_REGONS\t\t(uint8_t)0x04\t\t\t// Regulator In Run Regulation Status\n"
  "#define PMC_REGSC_BGBE\t\t\t(uint8_t)0x01\t\t\t// Bandgap Buffer Enable\n"
  "\n"
  "// Chapter 16: Low-Leakage Wakeup Unit (LLWU)\n"
  "#define LLWU_PE1\t\t*(volatile uint8_t  *)0x4007C000 // LLWU Pin Enable 1 register\n"
  "#define LLWU_PE2\t\t*(volatile uint8_t  *)0x4007C001 // LLWU Pin Enable 2 register\n"
  "#define LLWU_PE3\t\t*(volatile uint8_t  *)0x4007C002 // LLWU Pin Enable 3 register\n"
  "#define LLWU_PE4\t\t*(volatile uint8_t  *)0x4007C003 // LLWU Pin Enable 4 register\n"
  "#define LLWU_ME\t\t\t*(volatile uint8_t  *)0x4007C004 // LLWU Module Enable register\n"
  "#define LLWU_F1\t\t\t*(volatile uint8_t  *)0x4007C005 // LLWU Flag 1 register\n"
  "#define LLWU_F2\t\t\t*(volatile uint8_t  *)0x4007C006 // LLWU Flag 2 register\n"
  "#define LLWU_F3\t\t\t*(volatile uint8_t  *)0x4007C007 // LLWU Flag 3 register\n"
  "#define LLWU_FILT1\t\t*(volatile uint8_t  *)0x4007C008 // LLWU Pin Filter 1 register\n"
  "#define LLWU_FILT2\t\t*(volatile uint8_t  *)0x4007C009 // LLWU Pin Filter 2 register\n"
  "#define LLWU_RST\t\t*(volatile uint8_t  *)0x4007C00A // LLWU Reset Enable register\n"
  "\n"
  "// Chapter 17: Miscellaneous Control Module (MCM)\n"
  "#define MCM_PLASC\t\t*(volatile uint16_t *)0xE0080008 // Crossbar Switch (AXBS) Slave Configuration\n"
  "#define MCM_PLAMC\t\t*(volatile uint16_t *)0xE008000A // Crossbar Switch (AXBS) Master Configuration\n"
  "#define MCM_PLACR\t\t*(volatile uint32_t *)0xE008000C // Crossbar Switch (AXBS) Control Register (MK20DX128)\n"
  "#define MCM_PLACR_ARG\t\t\t(uint32_t)0x00000200\t\t// Arbitration select, 0=fixed, 1=round-robin\n"
  "#define MCM_CR\t\t\t*(volatile uint32_t *)0xE008000C // RAM arbitration control register (MK20DX256)\n"
  "#define MCM_CR_SRAMLWP\t\t\t(uint32_t)0x40000000\t\t// SRAM_L write protect\n"
  "#define MCM_CR_SRAMLAP(n)\t\t(uint32_t)(((n) & 0x03) << 28)\t// SRAM_L priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA\n"
  "#define MCM_CR_SRAMUWP\t\t\t(uint32_t)0x04000000\t\t// SRAM_U write protect\n"
  "#define MCM_CR_SRAMUAP(n)\t\t(uint32_t)(((n) & 0x03) << 24)\t// SRAM_U priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA\n"
  "\n"
  "// Crossbar Switch (AXBS) - only programmable on MK20DX256\n"
  "#define AXBS_PRS0\t\t*(volatile uint32_t *)0x40004000 // Priority Registers Slave 0\n"
  "#define AXBS_CRS0\t\t*(volatile uint32_t *)0x40004010 // Control Register 0\n"
  "#define AXBS_PRS1\t\t*(volatile uint32_t *)0x40004100 // Priority Registers Slave 1\n"
  "#define AXBS_CRS1\t\t*(volatile uint32_t *)0x40004110 // Control Register 1\n"
  "#define AXBS_PRS2\t\t*(volatile uint32_t *)0x40004200 // Priority Registers Slave 2\n"
  "#define AXBS_CRS2\t\t*(volatile uint32_t *)0x40004210 // Control Register 2\n"
  "#define AXBS_PRS3\t\t*(volatile uint32_t *)0x40004300 // Priority Registers Slave 3\n"
  "#define AXBS_CRS3\t\t*(volatile uint32_t *)0x40004310 // Control Register 3\n"
  "#define AXBS_PRS4\t\t*(volatile uint32_t *)0x40004400 // Priority Registers Slave 4\n"
  "#define AXBS_CRS4\t\t*(volatile uint32_t *)0x40004410 // Control Register 4\n"
  "#define AXBS_PRS5\t\t*(volatile uint32_t *)0x40004500 // Priority Registers Slave 5\n"
  "#define AXBS_CRS5\t\t*(volatile uint32_t *)0x40004510 // Control Register 5\n"
  "#define AXBS_PRS6\t\t*(volatile uint32_t *)0x40004600 // Priority Registers Slave 6\n"
  "#define AXBS_CRS6\t\t*(volatile uint32_t *)0x40004610 // Control Register 6\n"
  "#define AXBS_PRS7\t\t*(volatile uint32_t *)0x40004700 // Priority Registers Slave 7\n"
  "#define AXBS_CRS7\t\t*(volatile uint32_t *)0x40004710 // Control Register 7\n"
  "#define AXBS_MGPCR0\t\t*(volatile uint32_t *)0x40004800 // Master 0 General Purpose Control Register\n"
  "#define AXBS_MGPCR1\t\t*(volatile uint32_t *)0x40004900 // Master 1 General Purpose Control Register\n"
  "#define AXBS_MGPCR2\t\t*(volatile uint32_t *)0x40004A00 // Master 2 General Purpose Control Register\n"
  "#define AXBS_MGPCR3\t\t*(volatile uint32_t *)0x40004B00 // Master 3 General Purpose Control Register\n"
  "#define AXBS_MGPCR4\t\t*(volatile uint32_t *)0x40004C00 // Master 4 General Purpose Control Register\n"
  "#define AXBS_MGPCR5\t\t*(volatile uint32_t *)0x40004D00 // Master 5 General Purpose Control Register\n"
  "#define AXBS_MGPCR6\t\t*(volatile uint32_t *)0x40004E00 // Master 6 General Purpose Control Register\n"
  "#define AXBS_MGPCR7\t\t*(volatile uint32_t *)0x40004F00 // Master 7 General Purpose Control Register\n"
  "#define AXBS_CRS_READONLY\t\t(uint32_t)0x80000000\n"
  "#define AXBS_CRS_HALTLOWPRIORITY\t(uint32_t)0x40000000\n"
  "#define AXBS_CRS_ARB_FIXED\t\t(uint32_t)0x00000000\n"
  "#define AXBS_CRS_ARB_ROUNDROBIN\t\t(uint32_t)0x00010000\n"
  "#define AXBS_CRS_PARK_FIXED\t\t(uint32_t)0x00000000\n"
  "#define AXBS_CRS_PARK_PREVIOUS\t\t(uint32_t)0x00000010\n"
  "#define AXBS_CRS_PARK_NONE\t\t(uint32_t)0x00000020\n"
  "#define AXBS_CRS_PARK(n)\t\t(uint32_t)(((n) & 7) << 0)\n"
  "\n"
  "\n"
  "\n"
  "// Chapter 20: Direct Memory Access Multiplexer (DMAMUX)\n"
  "#define DMAMUX0_CHCFG0\t\t*(volatile uint8_t  *)0x40021000 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG1\t\t*(volatile uint8_t  *)0x40021001 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG2\t\t*(volatile uint8_t  *)0x40021002 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG3\t\t*(volatile uint8_t  *)0x40021003 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG4\t\t*(volatile uint8_t  *)0x40021004 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG5\t\t*(volatile uint8_t  *)0x40021005 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG6\t\t*(volatile uint8_t  *)0x40021006 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG7\t\t*(volatile uint8_t  *)0x40021007 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG8\t\t*(volatile uint8_t  *)0x40021008 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG9\t\t*(volatile uint8_t  *)0x40021009 // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG10\t\t*(volatile uint8_t  *)0x4002100A // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG11\t\t*(volatile uint8_t  *)0x4002100B // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG12\t\t*(volatile uint8_t  *)0x4002100C // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG13\t\t*(volatile uint8_t  *)0x4002100D // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG14\t\t*(volatile uint8_t  *)0x4002100E // Channel Configuration register\n"
  "#define DMAMUX0_CHCFG15\t\t*(volatile uint8_t  *)0x4002100F // Channel Configuration register\n"
  "#define DMAMUX_DISABLE\t\t\t0\n"
  "#define DMAMUX_TRIG\t\t\t64\n"
  "#define DMAMUX_ENABLE\t\t\t128\n"
  "#define DMAMUX_SOURCE_UART0_RX\t\t2\n"
  "#define DMAMUX_SOURCE_UART0_TX\t\t3\n"
  "#define DMAMUX_SOURCE_UART1_RX\t\t4\n"
  "#define DMAMUX_SOURCE_UART1_TX\t\t5\n"
  "#define DMAMUX_SOURCE_UART2_RX\t\t6\n"
  "#define DMAMUX_SOURCE_UART2_TX\t\t7\n"
  "#define DMAMUX_SOURCE_I2S0_RX\t\t14\n"
  "#define DMAMUX_SOURCE_I2S0_TX\t\t15\n"
  "#define DMAMUX_SOURCE_SPI0_RX\t\t16\n"
  "#define DMAMUX_SOURCE_SPI0_TX\t\t17\n"
  "#define DMAMUX_SOURCE_I2C0\t\t22\n"
  "#define DMAMUX_SOURCE_I2C1\t\t23\n"
  "#define DMAMUX_SOURCE_FTM0_CH0\t\t24\n"
  "#define DMAMUX_SOURCE_FTM0_CH1\t\t25\n"
  "#define DMAMUX_SOURCE_FTM0_CH2\t\t26\n"
  "#define DMAMUX_SOURCE_FTM0_CH3\t\t27\n"
  "#define DMAMUX_SOURCE_FTM0_CH4\t\t28\n"
  "#define DMAMUX_SOURCE_FTM0_CH5\t\t29\n"
  "#define DMAMUX_SOURCE_FTM0_CH6\t\t30\n"
  "#define DMAMUX_SOURCE_FTM0_CH7\t\t31\n"
  "#define DMAMUX_SOURCE_FTM1_CH0\t\t32\n"
  "#define DMAMUX_SOURCE_FTM1_CH1\t\t33\n"
  "#define DMAMUX_SOURCE_FTM2_CH0\t\t34\n"
  "#define DMAMUX_SOURCE_FTM2_CH1\t\t35\n"
  "#define DMAMUX_SOURCE_ADC0\t\t40\n"
  "#define DMAMUX_SOURCE_ADC1\t\t41\n"
  "#define DMAMUX_SOURCE_CMP0\t\t42\n"
  "#define DMAMUX_SOURCE_CMP1\t\t43\n"
  "#define DMAMUX_SOURCE_CMP2\t\t44\n"
  "#define DMAMUX_SOURCE_DAC0\t\t45\n"
  "#define DMAMUX_SOURCE_CMT\t\t47\n"
  "#define DMAMUX_SOURCE_PDB\t\t48\n"
  "#define DMAMUX_SOURCE_PORTA\t\t49\n"
  "#define DMAMUX_SOURCE_PORTB\t\t50\n"
  "#define DMAMUX_SOURCE_PORTC\t\t51\n"
  "#define DMAMUX_SOURCE_PORTD\t\t52\n"
  "#define DMAMUX_SOURCE_PORTE\t\t53\n"
  "#define DMAMUX_SOURCE_ALWAYS0\t\t54\n"
  "#define DMAMUX_SOURCE_ALWAYS1\t\t55\n"
  "#define DMAMUX_SOURCE_ALWAYS2\t\t56\n"
  "#define DMAMUX_SOURCE_ALWAYS3\t\t57\n"
  "#define DMAMUX_SOURCE_ALWAYS4\t\t58\n"
  "#define DMAMUX_SOURCE_ALWAYS5\t\t59\n"
  "#define DMAMUX_SOURCE_ALWAYS6\t\t60\n"
  "#define DMAMUX_SOURCE_ALWAYS7\t\t61\n"
  "#define DMAMUX_SOURCE_ALWAYS8\t\t62\n"
  "#define DMAMUX_SOURCE_ALWAYS9\t\t63\n"
  "\n"
  "// Chapter 21: Direct Memory Access Controller (eDMA)\n"
  "#define DMA_CR\t\t\t*(volatile uint32_t *)0x40008000 // Control Register\n"
  "#define DMA_CR_CX\t\t\t((uint32_t)(1<<17))\t// Cancel Transfer\n"
  "#define DMA_CR_ECX\t\t\t((uint32_t)(1<<16))\t// Error Cancel Transfer\n"
  "#define DMA_CR_EMLM\t\t\t((uint32_t)0x80)\t// Enable Minor Loop Mapping\n"
  "#define DMA_CR_CLM\t\t\t((uint32_t)0x40)\t// Continuous Link Mode\n"
  "#define DMA_CR_HALT\t\t\t((uint32_t)0x20)\t// Halt DMA Operations\n"
  "#define DMA_CR_HOE\t\t\t((uint32_t)0x10)\t// Halt On Error\n"
  "#define DMA_CR_ERCA\t\t\t((uint32_t)0x04)\t// Enable Round Robin Channel Arbitration\n"
  "#define DMA_CR_EDBG\t\t\t((uint32_t)0x02)\t// Enable Debug\n"
  "#define DMA_ES\t\t\t*(volatile uint32_t *)0x40008004 // Error Status Register\n"
  "#define DMA_ERQ\t\t\t*(volatile uint32_t *)0x4000800C // Enable Request Register\n"
  "#define DMA_ERQ_ERQ0\t\t\t((uint32_t)1<<0)\t// Enable DMA Request 0\n"
  "#define DMA_ERQ_ERQ1\t\t\t((uint32_t)1<<1)\t// Enable DMA Request 1\n"
  "#define DMA_ERQ_ERQ2\t\t\t((uint32_t)1<<2)\t// Enable DMA Request 2\n"
  "#define DMA_ERQ_ERQ3\t\t\t((uint32_t)1<<3)\t// Enable DMA Request 3\n"
  "#define DMA_EEI\t\t\t*(volatile uint32_t *)0x40008014 // Enable Error Interrupt Register\n"
  "#define DMA_EEI_EEI0\t\t\t((uint32_t)1<<0)\t// Enable Error Interrupt 0\n"
  "#define DMA_EEI_EEI1\t\t\t((uint32_t)1<<1)\t// Enable Error Interrupt 1\n"
  "#define DMA_EEI_EEI2\t\t\t((uint32_t)1<<2)\t// Enable Error Interrupt 2\n"
  "#define DMA_EEI_EEI3\t\t\t((uint32_t)1<<3)\t// Enable Error Interrupt 3\n"
  "#define DMA_CEEI\t\t*(volatile uint8_t  *)0x40008018 // Clear Enable Error Interrupt Register\n"
  "#define DMA_CEEI_CEEI(n)\t\t((uint8_t)(n & 3)<<0)\t// Clear Enable Error Interrupt\n"
  "#define DMA_CEEI_CAEE\t\t\t((uint8_t)1<<6)\t\t// Clear All Enable Error Interrupts\n"
  "#define DMA_CEEI_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_SEEI\t\t*(volatile uint8_t  *)0x40008019 // Set Enable Error Interrupt Register\n"
  "#define DMA_SEEI_SEEI(n)\t\t((uint8_t)(n & 3)<<0)\t// Set Enable Error Interrupt\n"
  "#define DMA_SEEI_SAEE\t\t\t((uint8_t)1<<6)\t\t// Set All Enable Error Interrupts\n"
  "#define DMA_SEEI_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_CERQ\t\t*(volatile uint8_t  *)0x4000801A // Clear Enable Request Register\n"
  "#define DMA_CERQ_CERQ(n)\t\t((uint8_t)(n & 3)<<0)\t// Clear Enable Request\n"
  "#define DMA_CERQ_CAER\t\t\t((uint8_t)1<<6)\t\t// Clear All Enable Requests\n"
  "#define DMA_CERQ_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_SERQ\t\t*(volatile uint8_t  *)0x4000801B // Set Enable Request Register\n"
  "#define DMA_SERQ_SERQ(n)\t\t((uint8_t)(n & 3)<<0)\t// Set Enable Request\n"
  "#define DMA_SERQ_SAER\t\t\t((uint8_t)1<<6)\t\t// Set All Enable Requests\n"
  "#define DMA_SERQ_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_CDNE\t\t*(volatile uint8_t  *)0x4000801C // Clear DONE Status Bit Register\n"
  "#define DMA_CDNE_CDNE(n)\t\t((uint8_t)(n & 3)<<0)\t// Clear Done Bit\n"
  "#define DMA_CDNE_CADN\t\t\t((uint8_t)1<<6)\t\t// Clear All Done Bits\n"
  "#define DMA_CDNE_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_SSRT\t\t*(volatile uint8_t  *)0x4000801D // Set START Bit Register\n"
  "#define DMA_SSRT_SSRT(n)\t\t((uint8_t)(n & 3)<<0)\t// Set Start Bit\n"
  "#define DMA_SSRT_SAST\t\t\t((uint8_t)1<<6)\t\t// Set All Start Bits\n"
  "#define DMA_SSRT_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_CERR\t\t*(volatile uint8_t  *)0x4000801E // Clear Error Register\n"
  "#define DMA_CERR_CERR(n)\t\t((uint8_t)(n & 3)<<0)\t// Clear Error Indicator\n"
  "#define DMA_CERR_CAEI\t\t\t((uint8_t)1<<6)\t\t// Clear All Error Indicators\n"
  "#define DMA_CERR_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_CINT\t\t*(volatile uint8_t  *)0x4000801F // Clear Interrupt Request Register\n"
  "#define DMA_CINT_CINT(n)\t\t((uint8_t)(n & 3)<<0)\t// Clear Interrupt Request\n"
  "#define DMA_CINT_CAIR\t\t\t((uint8_t)1<<6)\t\t// Clear All Interrupt Requests\n"
  "#define DMA_CINT_NOP\t\t\t((uint8_t)1<<7)\t\t// NOP\n"
  "#define DMA_INT\t\t\t*(volatile uint32_t *)0x40008024 // Interrupt Request Register\n"
  "#define DMA_INT_INT0\t\t\t((uint32_t)1<<0)\t// Interrupt Request 0\n"
  "#define DMA_INT_INT1\t\t\t((uint32_t)1<<1)\t// Interrupt Request 1\n"
  "#define DMA_INT_INT2\t\t\t((uint32_t)1<<2)\t// Interrupt Request 2\n"
  "#define DMA_INT_INT3\t\t\t((uint32_t)1<<3)\t// Interrupt Request 3\n"
  "#define DMA_ERR\t\t\t*(volatile uint32_t *)0x4000802C // Error Register\n"
  "#define DMA_ERR_ERR0\t\t\t((uint32_t)1<<0)\t// Error in Channel 0\n"
  "#define DMA_ERR_ERR1\t\t\t((uint32_t)1<<1)\t// Error in Channel 1\n"
  "#define DMA_ERR_ERR2\t\t\t((uint32_t)1<<2)\t// Error in Channel 2\n"
  "#define DMA_ERR_ERR3\t\t\t((uint32_t)1<<3)\t// Error in Channel 3\n"
  "#define DMA_HRS\t\t\t*(volatile uint32_t *)0x40008034 // Hardware Request Status Register\n"
  "#define DMA_HRS_HRS0\t\t\t((uint32_t)1<<0)\t// Hardware Request Status Channel 0\n"
  "#define DMA_HRS_HRS1\t\t\t((uint32_t)1<<1)\t// Hardware Request Status Channel 1\n"
  "#define DMA_HRS_HRS2\t\t\t((uint32_t)1<<2)\t// Hardware Request Status Channel 2\n"
  "#define DMA_HRS_HRS3\t\t\t((uint32_t)1<<3)\t// Hardware Request Status Channel 3\n"
  "#define DMA_DCHPRI3\t\t*(volatile uint8_t  *)0x40008100 // Channel n Priority Register\n"
  "#define DMA_DCHPRI2\t\t*(volatile uint8_t  *)0x40008101 // Channel n Priority Register\n"
  "#define DMA_DCHPRI1\t\t*(volatile uint8_t  *)0x40008102 // Channel n Priority Register\n"
  "#define DMA_DCHPRI0\t\t*(volatile uint8_t  *)0x40008103 // Channel n Priority Register\n"
  "#define DMA_DCHPRI_CHPRI(n)\t\t((uint8_t)(n & 3)<<0)\t// Channel Arbitration Priority\n"
  "#define DMA_DCHPRI_DPA\t\t\t((uint8_t)1<<6)\t\t// Disable PreEmpt Ability\n"
  "#define DMA_DCHPRI_ECP\t\t\t((uint8_t)1<<7)\t\t// Enable PreEmption\n"
  "\n"
  "\n"
  "#define DMA_TCD_ATTR_SMOD(n)\t\t(((n) & 0x1F) << 11)\n"
  "#define DMA_TCD_ATTR_SSIZE(n)\t\t(((n) & 0x7) << 8)\n"
  "#define DMA_TCD_ATTR_DMOD(n)\t\t(((n) & 0x1F) << 3)\n"
  "#define DMA_TCD_ATTR_DSIZE(n)\t\t(((n) & 0x7) << 0)\n"
  "#define DMA_TCD_ATTR_SIZE_8BIT\t\t0\n"
  "#define DMA_TCD_ATTR_SIZE_16BIT\t\t1\n"
  "#define DMA_TCD_ATTR_SIZE_32BIT\t\t2\n"
  "#define DMA_TCD_ATTR_SIZE_16BYTE\t4\n"
  "#define DMA_TCD_ATTR_SIZE_32BYTE\t5\n"
  "#define DMA_TCD_CSR_BWC(n)\t\t(((n) & 0x3) << 14)\n"
  "#define DMA_TCD_CSR_MAJORLINKCH(n)\t(((n) & 0x3) << 8)\n"
  "#define DMA_TCD_CSR_DONE\t\t0x0080\n"
  "#define DMA_TCD_CSR_ACTIVE\t\t0x0040\n"
  "#define DMA_TCD_CSR_MAJORELINK\t\t0x0020\n"
  "#define DMA_TCD_CSR_ESG\t\t\t0x0010\n"
  "#define DMA_TCD_CSR_DREQ\t\t0x0008\n"
  "#define DMA_TCD_CSR_INTHALF\t\t0x0004\n"
  "#define DMA_TCD_CSR_INTMAJOR\t\t0x0002\n"
  "#define DMA_TCD_CSR_START\t\t0x0001\n"
  "#define DMA_TCD_CITER_MASK\t\t    ((uint16_t)0x7FFF)\t   // Loop count mask\n"
  "#define DMA_TCD_CITER_ELINK\t\t    ((uint16_t)1<<15)\t   // Enable channel linking on minor-loop complete\n"
  "#define DMA_TCD_BITER_MASK\t\t    ((uint16_t)0x7FFF)\t   // Loop count mask\n"
  "#define DMA_TCD_BITER_ELINK\t\t    ((uint16_t)1<<15)\t   // Enable channel linking on minor-loop complete\n"
  "#define DMA_TCD_NBYTES_SMLOE\t\t    ((uint32_t)1<<31)\t\t    // Source Minor Loop Offset Enable\n"
  "#define DMA_TCD_NBYTES_DMLOE\t\t    ((uint32_t)1<<30)\t\t    // Destination Minor Loop Offset Enable\n"
  "#define DMA_TCD_NBYTES_MLOFFNO_NBYTES(n)    ((uint32_t)(n))\t\t    // NBytes transfer count when minor loop disabled\n"
  "#define DMA_TCD_NBYTES_MLOFFYES_NBYTES(n)   ((uint32_t)(n & 0x1F))\t    // NBytes transfer count when minor loop enabled\n"
  "#define DMA_TCD_NBYTES_MLOFFYES_MLOFF(n)    ((uint32_t)(n & 0xFFFFF)<<10)   // Offset \n"
  "\n"
  "#define DMA_TCD0_SADDR\t\t*(volatile const void * volatile *)0x40009000 // TCD Source Address\n"
  "#define DMA_TCD0_SOFF\t\t*(volatile int16_t *)0x40009004\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD0_ATTR\t\t*(volatile uint16_t *)0x40009006 // TCD Transfer Attributes\n"
  "#define DMA_TCD0_NBYTES_MLNO\t*(volatile uint32_t *)0x40009008 // TCD Minor Byte Count (Minor Loop Disabled)\n"
  "#define DMA_TCD0_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009008 // TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)\n"
  "#define DMA_TCD0_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009008 // TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)\n"
  "#define DMA_TCD0_SLAST\t\t*(volatile int32_t *)0x4000900C\t // TCD Last Source Address Adjustment\n"
  "#define DMA_TCD0_DADDR\t\t*(volatile void * volatile *)0x40009010 // TCD Destination Address\n"
  "#define DMA_TCD0_DOFF\t\t*(volatile int16_t *)0x40009014\t // TCD Signed Destination Address Offset\n"
  "#define DMA_TCD0_CITER_ELINKYES *(volatile uint16_t *)0x40009016 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "#define DMA_TCD0_CITER_ELINKNO\t*(volatile uint16_t *)0x40009016 // \?\?\n"
  "#define DMA_TCD0_DLASTSGA\t*(volatile int32_t *)0x40009018\t // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "#define DMA_TCD0_CSR\t\t*(volatile uint16_t *)0x4000901C // TCD Control and Status\n"
  "#define DMA_TCD0_BITER_ELINKYES *(volatile uint16_t *)0x4000901E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "#define DMA_TCD0_BITER_ELINKNO\t*(volatile uint16_t *)0x4000901E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Disabled\n"
  "\n"
  "#define DMA_TCD1_SADDR\t\t*(volatile const void * volatile *)0x40009020 // TCD Source Address\n"
  "#define DMA_TCD1_SOFF\t\t*(volatile int16_t *)0x40009024\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD1_ATTR\t\t*(volatile uint16_t *)0x40009026 // TCD Transfer Attributes\n"
  "#define DMA_TCD1_NBYTES_MLNO\t*(volatile uint32_t *)0x40009028 // TCD Minor Byte Count, Minor Loop Disabled\n"
  "#define DMA_TCD1_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009028 // TCD Signed Minor Loop Offset, Minor Loop Enabled and Offset Disabled\n"
  "#define DMA_TCD1_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009028 // TCD Signed Minor Loop Offset, Minor Loop and Offset Enabled\n"
  "#define DMA_TCD1_SLAST\t\t*(volatile int32_t *)0x4000902C\t // TCD Last Source Address Adjustment\n"
  "#define DMA_TCD1_DADDR\t\t*(volatile void * volatile *)0x40009030 // TCD Destination Address\n"
  "#define DMA_TCD1_DOFF\t\t*(volatile int16_t *)0x40009034\t // TCD Signed Destination Address Offset\n"
  "#define DMA_TCD1_CITER_ELINKYES *(volatile uint16_t *)0x40009036 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "#define DMA_TCD1_CITER_ELINKNO\t*(volatile uint16_t *)0x40009036 // \?\?\n"
  "#define DMA_TCD1_DLASTSGA\t*(volatile int32_t *)0x40009038\t // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "#define DMA_TCD1_CSR\t\t*(volatile uint16_t *)0x4000903C // TCD Control and Status\n"
  "#define DMA_TCD1_BITER_ELINKYES *(volatile uint16_t *)0x4000903E // TCD Beginning Minor Loop Link, Major Loop Count Channel Linking Enabled\n"
  "#define DMA_TCD1_BITER_ELINKNO\t*(volatile uint16_t *)0x4000903E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Disabled\n"
  "\n"
  "#define DMA_TCD2_SADDR\t\t*(volatile const void * volatile *)0x40009040 // TCD Source Address\n"
  "#define DMA_TCD2_SOFF\t\t*(volatile int16_t *)0x40009044\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD2_ATTR\t\t*(volatile uint16_t *)0x40009046 // TCD Transfer Attributes\n"
  "#define DMA_TCD2_NBYTES_MLNO\t*(volatile uint32_t *)0x40009048 // TCD Minor Byte Count, Minor Loop Disabled\n"
  "#define DMA_TCD2_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009048 // TCD Signed Minor Loop Offset, Minor Loop Enabled and Offset Disabled\n"
  "#define DMA_TCD2_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009048 // TCD Signed Minor Loop Offset, Minor Loop and Offset Enabled\n"
  "#define DMA_TCD2_SLAST\t\t*(volatile int32_t *)0x4000904C\t // TCD Last Source Address Adjustment\n"
  "#define DMA_TCD2_DADDR\t\t*(volatile void * volatile *)0x40009050 // TCD Destination Address\n"
  "#define DMA_TCD2_DOFF\t\t*(volatile int16_t *)0x40009054\t // TCD Signed Destination Address Offset\n"
  "#define DMA_TCD2_CITER_ELINKYES *(volatile uint16_t *)0x40009056 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "#define DMA_TCD2_CITER_ELINKNO\t*(volatile uint16_t *)0x40009056 // \?\?\n"
  "#define DMA_TCD2_DLASTSGA\t*(volatile int32_t *)0x40009058\t // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "#define DMA_TCD2_CSR\t\t*(volatile uint16_t *)0x4000905C // TCD Control and Status\n"
  "#define DMA_TCD2_BITER_ELINKYES *(volatile uint16_t *)0x4000905E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "#define DMA_TCD2_BITER_ELINKNO\t*(volatile uint16_t *)0x4000905E // TCD Beginning Minor Loop Link, Major Loop Count, Channel Linking Disabled\n"
  "\n"
  "#define DMA_TCD3_SADDR\t\t*(volatile const void * volatile *)0x40009060 // TCD Source Address\n"
  "#define DMA_TCD3_SOFF\t\t*(volatile int16_t *)0x40009064\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD3_ATTR\t\t*(volatile uint16_t *)0x40009066 // TCD Transfer Attributes\n"
  "#define DMA_TCD3_NBYTES_MLNO\t*(volatile uint32_t *)0x40009068 // TCD Minor Byte Count, Minor Loop Disabled\n"
  "#define DMA_TCD3_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009068 // TCD Signed Minor Loop Offset, Minor Loop Enabled and Offset Disabled\n"
  "#define DMA_TCD3_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009068 // TCD Signed Minor Loop Offset, Minor Loop and Offset Enabled\n"
  "#define DMA_TCD3_SLAST\t\t*(volatile int32_t *)0x4000906C\t // TCD Last Source Address Adjustment\n"
  "#define DMA_TCD3_DADDR\t\t*(volatile void * volatile *)0x40009070 // TCD Destination Address\n"
  "#define DMA_TCD3_DOFF\t\t*(volatile int16_t *)0x40009074\t // TCD Signed Destination Address Offset\n"
  "#define DMA_TCD3_CITER_ELINKYES *(volatile uint16_t *)0x40009076 // TCD Current Minor Loop Link, Major Loop Count, Channel Linking Enabled\n"
  "#define DMA_TCD3_CITER_ELINKNO\t*(volatile uint16_t *)0x40009076 // \?\?\n"
  "#define DMA_TCD3_DLASTSGA\t*(volatile int32_t *)0x40009078\t // TCD Last Destination Address Adjustment/Scatter Gather Address\n"
  "#define DMA_TCD3_CSR\t\t*(volatile uint16_t *)0x4000907C // TCD Control and Status\n"
  "#define DMA_TCD3_BITER_ELINKYES *(volatile uint16_t *)0x4000907E // TCD Beginning Minor Loop Link, Major Loop Count ,Channel Linking Enabled\n"
  "#define DMA_TCD3_BITER_ELINKNO\t*(volatile uint16_t *)0x4000907E // TCD Beginning Minor Loop Link, Major Loop Count ,Channel Linking Disabled\n"
  "\n"
  "#define DMA_TCD4_SADDR\t\t*(volatile const void * volatile *)0x40009080 // TCD Source Addr\n"
  "#define DMA_TCD4_SOFF\t\t*(volatile int16_t *)0x40009084\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD4_ATTR\t\t*(volatile uint16_t *)0x40009086 // TCD Transfer Attributes\n"
  "#define DMA_TCD4_NBYTES_MLNO\t*(volatile uint32_t *)0x40009088 // TCD Minor Byte Count\n"
  "#define DMA_TCD4_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009088 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD4_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009088 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD4_SLAST\t\t*(volatile int32_t *)0x4000908C\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD4_DADDR\t\t*(volatile void * volatile *)0x40009090 // TCD Destination Address\n"
  "#define DMA_TCD4_DOFF\t\t*(volatile int16_t *)0x40009094\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD4_CITER_ELINKYES *(volatile uint16_t *)0x40009096 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD4_CITER_ELINKNO\t*(volatile uint16_t *)0x40009096 // \?\?\n"
  "#define DMA_TCD4_DLASTSGA\t*(volatile int32_t *)0x40009098\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD4_CSR\t\t*(volatile uint16_t *)0x4000909C // TCD Control and Status\n"
  "#define DMA_TCD4_BITER_ELINKYES *(volatile uint16_t *)0x4000909E // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD4_BITER_ELINKNO\t*(volatile uint16_t *)0x4000909E // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD5_SADDR\t\t*(volatile const void * volatile *)0x400090A0 // TCD Source Addr\n"
  "#define DMA_TCD5_SOFF\t\t*(volatile int16_t *)0x400090A4\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD5_ATTR\t\t*(volatile uint16_t *)0x400090A6 // TCD Transfer Attributes\n"
  "#define DMA_TCD5_NBYTES_MLNO\t*(volatile uint32_t *)0x400090A8 // TCD Minor Byte Count\n"
  "#define DMA_TCD5_NBYTES_MLOFFNO *(volatile uint32_t *)0x400090A8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD5_NBYTES_MLOFFYES *(volatile uint32_t *)0x400090A8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD5_SLAST\t\t*(volatile int32_t *)0x400090AC\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD5_DADDR\t\t*(volatile void * volatile *)0x400090B0 // TCD Destination Address\n"
  "#define DMA_TCD5_DOFF\t\t*(volatile int16_t *)0x400090B4\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD5_CITER_ELINKYES *(volatile uint16_t *)0x400090B6 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD5_CITER_ELINKNO\t*(volatile uint16_t *)0x400090B6 // \?\?\n"
  "#define DMA_TCD5_DLASTSGA\t*(volatile int32_t *)0x400090B8\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD5_CSR\t\t*(volatile uint16_t *)0x400090BC // TCD Control and Status\n"
  "#define DMA_TCD5_BITER_ELINKYES *(volatile uint16_t *)0x400090BE // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD5_BITER_ELINKNO\t*(volatile uint16_t *)0x400090BE // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD6_SADDR\t\t*(volatile const void * volatile *)0x400090C0 // TCD Source Addr\n"
  "#define DMA_TCD6_SOFF\t\t*(volatile int16_t *)0x400090C4\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD6_ATTR\t\t*(volatile uint16_t *)0x400090C6 // TCD Transfer Attributes\n"
  "#define DMA_TCD6_NBYTES_MLNO\t*(volatile uint32_t *)0x400090C8 // TCD Minor Byte Count\n"
  "#define DMA_TCD6_NBYTES_MLOFFNO *(volatile uint32_t *)0x400090C8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD6_NBYTES_MLOFFYES *(volatile uint32_t *)0x400090C8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD6_SLAST\t\t*(volatile int32_t *)0x400090CC\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD6_DADDR\t\t*(volatile void * volatile *)0x400090D0 // TCD Destination Address\n"
  "#define DMA_TCD6_DOFF\t\t*(volatile int16_t *)0x400090D4\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD6_CITER_ELINKYES *(volatile uint16_t *)0x400090D6 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD6_CITER_ELINKNO\t*(volatile uint16_t *)0x400090D6 // \?\?\n"
  "#define DMA_TCD6_DLASTSGA\t*(volatile int32_t *)0x400090D8\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD6_CSR\t\t*(volatile uint16_t *)0x400090DC // TCD Control and Status\n"
  "#define DMA_TCD6_BITER_ELINKYES *(volatile uint16_t *)0x400090DE // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD6_BITER_ELINKNO\t*(volatile uint16_t *)0x400090DE // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD7_SADDR\t\t*(volatile const void * volatile *)0x400090E0 // TCD Source Addr\n"
  "#define DMA_TCD7_SOFF\t\t*(volatile int16_t *)0x400090E4\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD7_ATTR\t\t*(volatile uint16_t *)0x400090E6 // TCD Transfer Attributes\n"
  "#define DMA_TCD7_NBYTES_MLNO\t*(volatile uint32_t *)0x400090E8 // TCD Minor Byte Count\n"
  "#define DMA_TCD7_NBYTES_MLOFFNO *(volatile uint32_t *)0x400090E8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD7_NBYTES_MLOFFYES *(volatile uint32_t *)0x400090E8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD7_SLAST\t\t*(volatile int32_t *)0x400090EC\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD7_DADDR\t\t*(volatile void * volatile *)0x400090F0 // TCD Destination Address\n"
  "#define DMA_TCD7_DOFF\t\t*(volatile int16_t *)0x400090F4\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD7_CITER_ELINKYES *(volatile uint16_t *)0x400090F6 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD7_CITER_ELINKNO\t*(volatile uint16_t *)0x400090F6 // \?\?\n"
  "#define DMA_TCD7_DLASTSGA\t*(volatile int32_t *)0x400090F8\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD7_CSR\t\t*(volatile uint16_t *)0x400090FC // TCD Control and Status\n"
  "#define DMA_TCD7_BITER_ELINKYES *(volatile uint16_t *)0x400090FE // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD7_BITER_ELINKNO\t*(volatile uint16_t *)0x400090FE // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD8_SADDR\t\t*(volatile const void * volatile *)0x40009100 // TCD Source Addr\n"
  "#define DMA_TCD8_SOFF\t\t*(volatile int16_t *)0x40009104\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD8_ATTR\t\t*(volatile uint16_t *)0x40009106 // TCD Transfer Attributes\n"
  "#define DMA_TCD8_NBYTES_MLNO\t*(volatile uint32_t *)0x40009108 // TCD Minor Byte Count\n"
  "#define DMA_TCD8_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009108 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD8_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009108 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD8_SLAST\t\t*(volatile int32_t *)0x4000910C\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD8_DADDR\t\t*(volatile void * volatile *)0x40009110 // TCD Destination Address\n"
  "#define DMA_TCD8_DOFF\t\t*(volatile int16_t *)0x40009114\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD8_CITER_ELINKYES *(volatile uint16_t *)0x40009116 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD8_CITER_ELINKNO\t*(volatile uint16_t *)0x40009116 // \?\?\n"
  "#define DMA_TCD8_DLASTSGA\t*(volatile int32_t *)0x40009118\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD8_CSR\t\t*(volatile uint16_t *)0x4000911C // TCD Control and Status\n"
  "#define DMA_TCD8_BITER_ELINKYES *(volatile uint16_t *)0x4000911E // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD8_BITER_ELINKNO\t*(volatile uint16_t *)0x4000911E // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD9_SADDR\t\t*(volatile const void * volatile *)0x40009120 // TCD Source Addr\n"
  "#define DMA_TCD9_SOFF\t\t*(volatile int16_t *)0x40009124\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD9_ATTR\t\t*(volatile uint16_t *)0x40009126 // TCD Transfer Attributes\n"
  "#define DMA_TCD9_NBYTES_MLNO\t*(volatile uint32_t *)0x40009128 // TCD Minor Byte Count\n"
  "#define DMA_TCD9_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009128 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD9_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009128 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD9_SLAST\t\t*(volatile int32_t *)0x4000912C\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD9_DADDR\t\t*(volatile void * volatile *)0x40009130 // TCD Destination Address\n"
  "#define DMA_TCD9_DOFF\t\t*(volatile int16_t *)0x40009134\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD9_CITER_ELINKYES *(volatile uint16_t *)0x40009136 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD9_CITER_ELINKNO\t*(volatile uint16_t *)0x40009136 // \?\?\n"
  "#define DMA_TCD9_DLASTSGA\t*(volatile int32_t *)0x40009138\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD9_CSR\t\t*(volatile uint16_t *)0x4000913C // TCD Control and Status\n"
  "#define DMA_TCD9_BITER_ELINKYES *(volatile uint16_t *)0x4000913E // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD9_BITER_ELINKNO\t*(volatile uint16_t *)0x4000913E // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD10_SADDR\t\t*(volatile const void * volatile *)0x40009140 // TCD Source Addr\n"
  "#define DMA_TCD10_SOFF\t\t*(volatile int16_t *)0x40009144\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD10_ATTR\t\t*(volatile uint16_t *)0x40009146 // TCD Transfer Attributes\n"
  "#define DMA_TCD10_NBYTES_MLNO\t*(volatile uint32_t *)0x40009148 // TCD Minor Byte Count\n"
  "#define DMA_TCD10_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009148 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD10_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009148 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD10_SLAST\t\t*(volatile int32_t *)0x4000914C\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD10_DADDR\t\t*(volatile void * volatile *)0x40009150 // TCD Destination Address\n"
  "#define DMA_TCD10_DOFF\t\t*(volatile int16_t *)0x40009154\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD10_CITER_ELINKYES *(volatile uint16_t *)0x40009156 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD10_CITER_ELINKNO\t*(volatile uint16_t *)0x40009156 // \?\?\n"
  "#define DMA_TCD10_DLASTSGA\t*(volatile int32_t *)0x40009158\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD10_CSR\t\t*(volatile uint16_t *)0x4000915C // TCD Control and Status\n"
  "#define DMA_TCD10_BITER_ELINKYES *(volatile uint16_t *)0x4000915E // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD10_BITER_ELINKNO\t*(volatile uint16_t *)0x4000915E // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD11_SADDR\t\t*(volatile const void * volatile *)0x40009160 // TCD Source Addr\n"
  "#define DMA_TCD11_SOFF\t\t*(volatile int16_t *)0x40009164\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD11_ATTR\t\t*(volatile uint16_t *)0x40009166 // TCD Transfer Attributes\n"
  "#define DMA_TCD11_NBYTES_MLNO\t*(volatile uint32_t *)0x40009168 // TCD Minor Byte Count\n"
  "#define DMA_TCD11_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009168 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD11_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009168 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD11_SLAST\t\t*(volatile int32_t *)0x4000916C\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD11_DADDR\t\t*(volatile void * volatile *)0x40009170 // TCD Destination Address\n"
  "#define DMA_TCD11_DOFF\t\t*(volatile int16_t *)0x40009174\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD11_CITER_ELINKYES *(volatile uint16_t *)0x40009176 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD11_CITER_ELINKNO\t*(volatile uint16_t *)0x40009176 // \?\?\n"
  "#define DMA_TCD11_DLASTSGA\t*(volatile int32_t *)0x40009178\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD11_CSR\t\t*(volatile uint16_t *)0x4000917C // TCD Control and Status\n"
  "#define DMA_TCD11_BITER_ELINKYES *(volatile uint16_t *)0x4000917E // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD11_BITER_ELINKNO\t*(volatile uint16_t *)0x4000917E // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD12_SADDR\t\t*(volatile const void * volatile *)0x40009180 // TCD Source Addr\n"
  "#define DMA_TCD12_SOFF\t\t*(volatile int16_t *)0x40009184\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD12_ATTR\t\t*(volatile uint16_t *)0x40009186 // TCD Transfer Attributes\n"
  "#define DMA_TCD12_NBYTES_MLNO\t*(volatile uint32_t *)0x40009188 // TCD Minor Byte Count\n"
  "#define DMA_TCD12_NBYTES_MLOFFNO *(volatile uint32_t *)0x40009188 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD12_NBYTES_MLOFFYES *(volatile uint32_t *)0x40009188 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD12_SLAST\t\t*(volatile int32_t *)0x4000918C\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD12_DADDR\t\t*(volatile void * volatile *)0x40009190 // TCD Destination Address\n"
  "#define DMA_TCD12_DOFF\t\t*(volatile int16_t *)0x40009194\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD12_CITER_ELINKYES *(volatile uint16_t *)0x40009196 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD12_CITER_ELINKNO\t*(volatile uint16_t *)0x40009196 // \?\?\n"
  "#define DMA_TCD12_DLASTSGA\t*(volatile int32_t *)0x40009198\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD12_CSR\t\t*(volatile uint16_t *)0x4000919C // TCD Control and Status\n"
  "#define DMA_TCD12_BITER_ELINKYES *(volatile uint16_t *)0x4000919E // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD12_BITER_ELINKNO\t*(volatile uint16_t *)0x4000919E // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD13_SADDR\t\t*(volatile const void * volatile *)0x400091A0 // TCD Source Addr\n"
  "#define DMA_TCD13_SOFF\t\t*(volatile int16_t *)0x400091A4\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD13_ATTR\t\t*(volatile uint16_t *)0x400091A6 // TCD Transfer Attributes\n"
  "#define DMA_TCD13_NBYTES_MLNO\t*(volatile uint32_t *)0x400091A8 // TCD Minor Byte Count\n"
  "#define DMA_TCD13_NBYTES_MLOFFNO *(volatile uint32_t *)0x400091A8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD13_NBYTES_MLOFFYES *(volatile uint32_t *)0x400091A8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD13_SLAST\t\t*(volatile int32_t *)0x400091AC\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD13_DADDR\t\t*(volatile void * volatile *)0x400091B0 // TCD Destination Address\n"
  "#define DMA_TCD13_DOFF\t\t*(volatile int16_t *)0x400091B4\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD13_CITER_ELINKYES *(volatile uint16_t *)0x400091B6 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD13_CITER_ELINKNO\t*(volatile uint16_t *)0x400091B6 // \?\?\n"
  "#define DMA_TCD13_DLASTSGA\t*(volatile int32_t *)0x400091B8\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD13_CSR\t\t*(volatile uint16_t *)0x400091BC // TCD Control and Status\n"
  "#define DMA_TCD13_BITER_ELINKYES *(volatile uint16_t *)0x400091BE // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD13_BITER_ELINKNO\t*(volatile uint16_t *)0x400091BE // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD14_SADDR\t\t*(volatile const void * volatile *)0x400091C0 // TCD Source Addr\n"
  "#define DMA_TCD14_SOFF\t\t*(volatile int16_t *)0x400091C4\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD14_ATTR\t\t*(volatile uint16_t *)0x400091C6 // TCD Transfer Attributes\n"
  "#define DMA_TCD14_NBYTES_MLNO\t*(volatile uint32_t *)0x400091C8 // TCD Minor Byte Count\n"
  "#define DMA_TCD14_NBYTES_MLOFFNO *(volatile uint32_t *)0x400091C8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD14_NBYTES_MLOFFYES *(volatile uint32_t *)0x400091C8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD14_SLAST\t\t*(volatile int32_t *)0x400091CC\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD14_DADDR\t\t*(volatile void * volatile *)0x400091D0 // TCD Destination Address\n"
  "#define DMA_TCD14_DOFF\t\t*(volatile int16_t *)0x400091D4\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD14_CITER_ELINKYES *(volatile uint16_t *)0x400091D6 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD14_CITER_ELINKNO\t*(volatile uint16_t *)0x400091D6 // \?\?\n"
  "#define DMA_TCD14_DLASTSGA\t*(volatile int32_t *)0x400091D8\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD14_CSR\t\t*(volatile uint16_t *)0x400091DC // TCD Control and Status\n"
  "#define DMA_TCD14_BITER_ELINKYES *(volatile uint16_t *)0x400091DE // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD14_BITER_ELINKNO\t*(volatile uint16_t *)0x400091DE // TCD Beginning Minor Loop Link\n"
  "\n"
  "#define DMA_TCD15_SADDR\t\t*(volatile const void * volatile *)0x400091E0 // TCD Source Addr\n"
  "#define DMA_TCD15_SOFF\t\t*(volatile int16_t *)0x400091E4\t // TCD Signed Source Address Offset\n"
  "#define DMA_TCD15_ATTR\t\t*(volatile uint16_t *)0x400091E6 // TCD Transfer Attributes\n"
  "#define DMA_TCD15_NBYTES_MLNO\t*(volatile uint32_t *)0x400091E8 // TCD Minor Byte Count\n"
  "#define DMA_TCD15_NBYTES_MLOFFNO *(volatile uint32_t *)0x400091E8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD15_NBYTES_MLOFFYES *(volatile uint32_t *)0x400091E8 // TCD Signed Minor Loop Offset\n"
  "#define DMA_TCD15_SLAST\t\t*(volatile int32_t *)0x400091EC\t // TCD Last Source Addr Adj.\n"
  "#define DMA_TCD15_DADDR\t\t*(volatile void * volatile *)0x400091F0 // TCD Destination Address\n"
  "#define DMA_TCD15_DOFF\t\t*(volatile int16_t *)0x400091F4\t // TCD Signed Dest Address Offset\n"
  "#define DMA_TCD15_CITER_ELINKYES *(volatile uint16_t *)0x400091F6 // TCD Current Minor Loop Link\n"
  "#define DMA_TCD15_CITER_ELINKNO\t*(volatile uint16_t *)0x400091F6 // \?\?\n"
  "#define DMA_TCD15_DLASTSGA\t*(volatile int32_t *)0x400091F8\t // TCD Last Destination Addr Adj\n"
  "#define DMA_TCD15_CSR\t\t*(volatile uint16_t *)0x400091FC // TCD Control and Status\n"
  "#define DMA_TCD15_BITER_ELINKYES *(volatile uint16_t *)0x400091FE // TCD Beginning Minor Loop Link\n"
  "#define DMA_TCD15_BITER_ELINKNO\t*(volatile uint16_t *)0x400091FE // TCD Beginning Minor Loop Link\n"
  "\n"
  "\n"
  "// Chapter 22: External Watchdog Monitor (EWM)\n"
  "#define EWM_CTRL\t\t*(volatile uint8_t  *)0x40061000 // Control Register\n"
  "#define EWM_SERV\t\t*(volatile uint8_t  *)0x40061001 // Service Register\n"
  "#define EWM_CMPL\t\t*(volatile uint8_t  *)0x40061002 // Compare Low Register\n"
  "#define EWM_CMPH\t\t*(volatile uint8_t  *)0x40061003 // Compare High Register\n"
  "\n"
  "// Chapter 23: Watchdog Timer (WDOG)\n"
  "#define WDOG_STCTRLH\t\t*(volatile uint16_t *)0x40052000 // Watchdog Status and Control Register High\n"
  "#define WDOG_STCTRLH_DISTESTWDOG\t(uint16_t)0x4000\t\t// Allows the WDOG's functional test mode to be disabled permanently.\n"
  "#define WDOG_STCTRLH_BYTESEL(n)\t\t(uint16_t)(((n) & 3) << 12)\t// selects the byte to be tested when the watchdog is in the byte test mode.\n"
  "#define WDOG_STCTRLH_TESTSEL\t\t(uint16_t)0x0800\n"
  "#define WDOG_STCTRLH_TESTWDOG\t\t(uint16_t)0x0400\n"
  "#define WDOG_STCTRLH_WAITEN\t\t(uint16_t)0x0080\n"
  "#define WDOG_STCTRLH_STOPEN\t\t(uint16_t)0x0040\n"
  "#define WDOG_STCTRLH_DBGEN\t\t(uint16_t)0x0020\n"
  "#define WDOG_STCTRLH_ALLOWUPDATE\t(uint16_t)0x0010\n"
  "#define WDOG_STCTRLH_WINEN\t\t(uint16_t)0x0008\n"
  "#define WDOG_STCTRLH_IRQRSTEN\t\t(uint16_t)0x0004\n"
  "#define WDOG_STCTRLH_CLKSRC\t\t(uint16_t)0x0002\n"
  "#define WDOG_STCTRLH_WDOGEN\t\t(uint16_t)0x0001\n"
  "#define WDOG_STCTRLL\t\t*(volatile uint16_t *)0x40052002 // Watchdog Status and Control Register Low\n"
  "#define WDOG_TOVALH\t\t*(volatile uint16_t *)0x40052004 // Watchdog Time-out Value Register High\n"
  "#define WDOG_TOVALL\t\t*(volatile uint16_t *)0x40052006 // Watchdog Time-out Value Register Low\n"
  "#define WDOG_WINH\t\t*(volatile uint16_t *)0x40052008 // Watchdog Window Register High\n"
  "#define WDOG_WINL\t\t*(volatile uint16_t *)0x4005200A // Watchdog Window Register Low\n"
  "#define WDOG_REFRESH\t\t*(volatile uint16_t *)0x4005200C // Watchdog Refresh register\n"
  "#define WDOG_UNLOCK\t\t*(volatile uint16_t *)0x4005200E // Watchdog Unlock register\n"
  "#define WDOG_UNLOCK_SEQ1\t\t(uint16_t)0xC520\n"
  "#define WDOG_UNLOCK_SEQ2\t\t(uint16_t)0xD928\n"
  "#define WDOG_TMROUTH\t\t*(volatile uint16_t *)0x40052010 // Watchdog Timer Output Register High\n"
  "#define WDOG_TMROUTL\t\t*(volatile uint16_t *)0x40052012 // Watchdog Timer Output Register Low\n"
  "#define WDOG_RSTCNT\t\t*(volatile uint16_t *)0x40052014 // Watchdog Reset Count register\n"
  "#define WDOG_PRESC\t\t*(volatile uint16_t *)0x40052016 // Watchdog Prescaler register\n"
  "\n"
  "// Chapter 24: Multipurpose Clock Generator (MCG)\n"
  "#define MCG_C1\t\t\t*(volatile uint8_t  *)0x40064000 // MCG Control 1 Register\n"
  "#define MCG_C1_IREFSTEN\t\t\t(uint8_t)0x01\t\t\t// Internal Reference Stop Enable, Controls whether or not the internal reference clock remains enabled when"
  " the MCG enters Stop mode.\n"
  "#define MCG_C1_IRCLKEN\t\t\t(uint8_t)0x02\t\t\t// Internal Reference Clock Enable, Enables the internal reference clock for use as MCGIRCLK.\n"
  "#define MCG_C1_IREFS\t\t\t(uint8_t)0x04\t\t\t// Internal Reference Select, Selects the reference clock source for the FLL.\n"
  "#define MCG_C1_FRDIV(n)\t\t\t(uint8_t)(((n) & 0x07) << 3)\t// FLL External Reference Divider, Selects the amount to divide down the external reference clo"
  "ck for the FLL\n"
  "#define MCG_C1_CLKS(n)\t\t\t(uint8_t)(((n) & 0x03) << 6)\t// Clock Source Select, Selects the clock source for MCGOUTCLK\n"
  "#define MCG_C2\t\t\t*(volatile uint8_t  *)0x40064001 // MCG Control 2 Register\n"
  "#define MCG_C2_IRCS\t\t\t(uint8_t)0x01\t\t\t// Internal Reference Clock Select, Selects between the fast or slow internal reference clock source.\n"
  "#define MCG_C2_LP\t\t\t(uint8_t)0x02\t\t\t// Low Power Select, Controls whether the FLL or PLL is disabled in BLPI and BLPE modes.\n"
  "#define MCG_C2_EREFS\t\t\t(uint8_t)0x04\t\t\t// External Reference Select, Selects the source for the external reference clock. \n"
  "#define MCG_C2_HGO0\t\t\t(uint8_t)0x08\t\t\t// High Gain Oscillator Select, Controls the crystal oscillator mode of operation\n"
  "#define MCG_C2_RANGE0(n)\t\t(uint8_t)(((n) & 0x03) << 4)\t// Frequency Range Select, Selects the frequency range for the crystal oscillator\n"
  "#define MCG_C2_LOCRE0\t\t\t(uint8_t)0x80\t\t\t// Loss of Clock Reset Enable, Determines whether an interrupt or a reset request is made following a loss of "
  "OSC0 \n"
  "#define MCG_C3\t\t\t*(volatile uint8_t  *)0x40064002 // MCG Control 3 Register\n"
  "#define MCG_C3_SCTRIM(n)\t\t(uint8_t)(n)\t\t\t// Slow Internal Reference Clock Trim Setting\n"
  "#define MCG_C4\t\t\t*(volatile uint8_t  *)0x40064003 // MCG Control 4 Register\n"
  "#define MCG_C4_SCFTRIM\t\t\t(uint8_t)0x01\t\t\t// Slow Internal Reference Clock Fine Trim\n"
  "#define MCG_C4_FCTRIM(n)\t\t(uint8_t)(((n) & 0x0F) << 1)\t// Fast Internal Reference Clock Trim Setting\n"
  "#define MCG_C4_DRST_DRS(n)\t\t(uint8_t)(((n) & 0x03) << 5)\t// DCO Range Select\n"
  "#define MCG_C4_DMX32\t\t\t(uint8_t)0x80\t\t\t// DCO Maximum Frequency with 32.768 kHz Reference, controls whether the DCO frequency range is narrowed\n"
  "#define MCG_C5\t\t\t*(volatile uint8_t  *)0x40064004 // MCG Control 5 Register\n"
  "#define MCG_C5_PRDIV0(n)\t\t(uint8_t)((n) & 0x1F)\t\t// PLL External Reference Divider\n"
  "#define MCG_C5_PLLSTEN0\t\t\t(uint8_t)0x20\t\t\t// PLL Stop Enable\n"
  "#define MCG_C5_PLLCLKEN0\t\t(uint8_t)0x40\t\t\t// PLL Clock Enable\n"
  "#define MCG_C6\t\t\t*(volatile uint8_t  *)0x40064005 // MCG Control 6 Register\n"
  "#define MCG_C6_VDIV0(n)\t\t\t(uint8_t)((n) & 0x1F)\t\t// VCO 0 Divider\n"
  "#define MCG_C6_CME0\t\t\t(uint8_t)0x20\t\t\t// Clock Monitor Enable\n"
  "#define MCG_C6_PLLS\t\t\t(uint8_t)0x40\t\t\t// PLL Select, Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00. \n"
  "#define MCG_C6_LOLIE0\t\t\t(uint8_t)0x80\t\t\t// Loss of Lock Interrrupt Enable\n"
  "#define MCG_S\t\t\t*(volatile uint8_t  *)0x40064006 // MCG Status Register\n"
  "#define MCG_S_IRCST\t\t\t(uint8_t)0x01\t\t\t// Internal Reference Clock Status\n"
  "#define MCG_S_OSCINIT0\t\t\t(uint8_t)0x02\t\t\t// OSC Initialization,\tresets to 0, is set to 1 after the initialization cycles of the crystal oscillator\n"
  "#define MCG_S_CLKST(n)\t\t\t(uint8_t)(((n) & 0x03) << 2)\t// Clock Mode Status, 0=FLL is selected, 1= Internal ref, 2=External ref, 3=PLL\n"
  "#define MCG_S_CLKST_MASK\t\t(uint8_t)0x0C\n"
  "#define MCG_S_IREFST\t\t\t(uint8_t)0x10\t\t\t// Internal Reference Status\n"
  "#define MCG_S_PLLST\t\t\t(uint8_t)0x20\t\t\t// PLL Select Status\n"
  "#define MCG_S_LOCK0\t\t\t(uint8_t)0x40\t\t\t// Lock Status, 0=PLL Unlocked, 1=PLL Locked\n"
  "#define MCG_S_LOLS0\t\t\t(uint8_t)0x80\t\t\t// Loss of Lock Status\n"
  "#define MCG_SC\t\t\t*(volatile uint8_t  *)0x40064008 // MCG Status and Control Register\n"
  "#define MCG_SC_LOCS0\t\t\t(uint8_t)0x01\t\t\t// OSC0 Loss of Clock Status\n"
  "#define MCG_SC_FCRDIV(n)\t\t(uint8_t)(((n) & 0x07) << 1)\t// Fast Clock Internal Reference Divider\n"
  "#define MCG_SC_FLTPRSRV\t\t\t(uint8_t)0x10\t\t\t// FLL Filter Preserve Enable\n"
  "#define MCG_SC_ATMF\t\t\t(uint8_t)0x20\t\t\t// Automatic Trim Machine Fail Flag\n"
  "#define MCG_SC_ATMS\t\t\t(uint8_t)0x40\t\t\t// Automatic Trim Machine Select\n"
  "#define MCG_SC_ATME\t\t\t(uint8_t)0x80\t\t\t// Automatic Trim Machine Enable\n"
  "#define MCG_ATCVH\t\t*(volatile uint8_t  *)0x4006400A // MCG Auto Trim Compare Value High Register\n"
  "#define MCG_ATCVL\t\t*(volatile uint8_t  *)0x4006400B // MCG Auto Trim Compare Value Low Register\n"
  "#define MCG_C7\t\t\t*(volatile uint8_t  *)0x4006400C // MCG Control 7 Register\n"
  "#define MCG_C8\t\t\t*(volatile uint8_t  *)0x4006400D // MCG Control 8 Register\n"
  "\n"
  "// Chapter 25: Oscillator (OSC)\n"
  "#define OSC0_CR\t\t\t*(volatile uint8_t  *)0x40065000 // OSC Control Register\n"
  "#define OSC_SC16P\t\t\t(uint8_t)0x01\t\t\t// Oscillator 16 pF Capacitor Load Configure\n"
  "#define OSC_SC8P\t\t\t(uint8_t)0x02\t\t\t// Oscillator 8 pF Capacitor Load Configure\n"
  "#define OSC_SC4P\t\t\t(uint8_t)0x04\t\t\t// Oscillator 4 pF Capacitor Load Configure\n"
  "#define OSC_SC2P\t\t\t(uint8_t)0x08\t\t\t// Oscillator 2 pF Capacitor Load Configure\n"
  "#define OSC_EREFSTEN\t\t\t(uint8_t)0x20\t\t\t// External Reference Stop Enable, Controls whether or not the external reference clock (OSCERCLK) remains enab"
  "led when MCU enters Stop mode.\n"
  "#define OSC_ERCLKEN\t\t\t(uint8_t)0x80\t\t\t// External Reference Enable, Enables external reference clock (OSCERCLK).\n"
  "\n"
  "// Chapter 27: Flash Memory Controller (FMC)\n"
  "#define FMC_PFAPR\t\t*(volatile uint32_t *)0x4001F000\t// Flash Access Protection\n"
  "#define FMC_PFB0CR\t\t*(volatile uint32_t *)0x4001F004\t// Flash Control\n"
  "#define FMC_TAGVDW0S0\t\t*(volatile uint32_t *)0x4001F100\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW0S1\t\t*(volatile uint32_t *)0x4001F104\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW1S0\t\t*(volatile uint32_t *)0x4001F108\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW1S1\t\t*(volatile uint32_t *)0x4001F10C\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW2S0\t\t*(volatile uint32_t *)0x4001F110\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW2S1\t\t*(volatile uint32_t *)0x4001F114\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW3S0\t\t*(volatile uint32_t *)0x4001F118\t// Cache Tag Storage\n"
  "#define FMC_TAGVDW3S1\t\t*(volatile uint32_t *)0x4001F11C\t// Cache Tag Storage\n"
  "#define FMC_DATAW0S0\t\t*(volatile uint32_t *)0x4001F200\t// Cache Data Storage\n"
  "#define FMC_DATAW0S1\t\t*(volatile uint32_t *)0x4001F204\t// Cache Data Storage\n"
  "#define FMC_DATAW1S0\t\t*(volatile uint32_t *)0x4001F208\t// Cache Data Storage\n"
  "#define FMC_DATAW1S1\t\t*(volatile uint32_t *)0x4001F20C\t// Cache Data Storage\n"
  "#define FMC_DATAW2S0\t\t*(volatile uint32_t *)0x4001F210\t// Cache Data Storage\n"
  "#define FMC_DATAW2S1\t\t*(volatile uint32_t *)0x4001F214\t// Cache Data Storage\n"
  "#define FMC_DATAW3S0\t\t*(volatile uint32_t *)0x4001F218\t// Cache Data Storage\n"
  "#define FMC_DATAW3S1\t\t*(volatile uint32_t *)0x4001F21C\t// Cache Data Storage\n"
  "\n"
  "// Chapter 28: Flash Memory Module (FTFL)\n"
  "#define FTFL_FSTAT\t\t*(volatile uint8_t  *)0x40020000      // Flash Status Register\n"
  "#define FTFL_FSTAT_CCIF\t\t\t(uint8_t)0x80\t\t\t// Command Complete Interrupt Flag\n"
  "#define FTFL_FSTAT_RDCOLERR\t\t(uint8_t)0x40\t\t\t// Flash Read Collision Error Flag\n"
  "#define FTFL_FSTAT_ACCERR\t\t(uint8_t)0x20\t\t\t// Flash Access Error Flag\n"
  "#define FTFL_FSTAT_FPVIOL\t\t(uint8_t)0x10\t\t\t// Flash Protection Violation Flag\n"
  "#define FTFL_FSTAT_MGSTAT0\t\t(uint8_t)0x01\t\t\t// Memory Controller Command Completion Status Flag\n"
  "#define FTFL_FCNFG\t\t*(volatile uint8_t  *)0x40020001      // Flash Configuration Register\n"
  "#define FTFL_FCNFG_CCIE\t\t\t(uint8_t)0x80\t\t\t// Command Complete Interrupt Enable\n"
  "#define FTFL_FCNFG_RDCOLLIE\t\t(uint8_t)0x40\t\t\t// Read Collision Error Interrupt Enable\n"
  "#define FTFL_FCNFG_ERSAREQ\t\t(uint8_t)0x20\t\t\t// Erase All Request\n"
  "#define FTFL_FCNFG_ERSSUSP\t\t(uint8_t)0x10\t\t\t// Erase Suspend\n"
  "#define FTFL_FCNFG_PFLSH\t\t(uint8_t)0x04\t\t\t// Flash memory configuration\n"
  "#define FTFL_FCNFG_RAMRDY\t\t(uint8_t)0x02\t\t\t// RAM Ready\n"
  "#define FTFL_FCNFG_EEERDY\t\t(uint8_t)0x01\t\t\t// EEPROM Ready\n"
  "#define FTFL_FSEC\t\t*(const\t   uint8_t  *)0x40020002      // Flash Security Register\n"
  "#define FTFL_FOPT\t\t*(const\t   uint8_t  *)0x40020003      // Flash Option Register\n"
  "#define FTFL_FCCOB3\t\t*(volatile uint8_t  *)0x40020004      // Flash Common Command Object Registers\n"
  "#define FTFL_FCCOB2\t\t*(volatile uint8_t  *)0x40020005\n"
  "#define FTFL_FCCOB1\t\t*(volatile uint8_t  *)0x40020006\n"
  "#define FTFL_FCCOB0\t\t*(volatile uint8_t  *)0x40020007\n"
  "#define FTFL_FCCOB7\t\t*(volatile uint8_t  *)0x40020008\n"
  "#define FTFL_FCCOB6\t\t*(volatile uint8_t  *)0x40020009\n"
  "#define FTFL_FCCOB5\t\t*(volatile uint8_t  *)0x4002000A\n"
  "#define FTFL_FCCOB4\t\t*(volatile uint8_t  *)0x4002000B\n"
  "#define FTFL_FCCOBB\t\t*(volatile uint8_t  *)0x4002000C\n"
  "#define FTFL_FCCOBA\t\t*(volatile uint8_t  *)0x4002000D\n"
  "#define FTFL_FCCOB9\t\t*(volatile uint8_t  *)0x4002000E\n"
  "#define FTFL_FCCOB8\t\t*(volatile uint8_t  *)0x4002000F\n"
  "#define FTFL_FPROT3\t\t*(volatile uint8_t  *)0x40020010      // Program Flash Protection Registers\n"
  "#define FTFL_FPROT2\t\t*(volatile uint8_t  *)0x40020011      // Program Flash Protection Registers\n"
  "#define FTFL_FPROT1\t\t*(volatile uint8_t  *)0x40020012      // Program Flash Protection Registers\n"
  "#define FTFL_FPROT0\t\t*(volatile uint8_t  *)0x40020013      // Program Flash Protection Registers\n"
  "#define FTFL_FEPROT\t\t*(volatile uint8_t  *)0x40020016      // EEPROM Protection Register\n"
  "#define FTFL_FDPROT\t\t*(volatile uint8_t  *)0x40020017      // Data Flash Protection Register\n"
  "\n"
  "// Chapter 30: Cyclic Redundancy Check (CRC)\n"
  "#define CRC_CRC\t\t\t*(volatile uint32_t *)0x40032000 // CRC Data register\n"
  "#define CRC_GPOLY\t\t*(volatile uint32_t *)0x40032004 // CRC Polynomial register\n"
  "#define CRC_CTRL\t\t*(volatile uint32_t *)0x40032008 // CRC Control register\n"
  "\n"
  "// Chapter 31: Analog-to-Digital Converter (ADC)\n"
  "#define ADC0_SC1A\t\t*(volatile uint32_t *)0x4003B000 // ADC status and control registers 1\n"
  "#define ADC0_SC1B\t\t*(volatile uint32_t *)0x4003B004 // ADC status and control registers 1\n"
  "#define ADC_SC1_COCO\t\t\t(uint32_t)0x80\t\t\t// Conversion complete flag\n"
  "#define ADC_SC1_AIEN\t\t\t(uint32_t)0x40\t\t\t// Interrupt enable\n"
  "#define ADC_SC1_DIFF\t\t\t(uint32_t)0x20\t\t\t// Differential mode enable\n"
  "#define ADC_SC1_ADCH(n)\t\t\t(uint32_t)((n) & 0x1F)\t\t// Input channel select\n"
  "#define ADC0_CFG1\t\t*(volatile uint32_t *)0x4003B008 // ADC configuration register 1\n"
  "#define ADC_CFG1_ADLPC\t\t\t(uint32_t)0x80\t\t\t// Low-power configuration\n"
  "#define ADC_CFG1_ADIV(n)\t\t(uint32_t)(((n) & 3) << 5)\t// Clock divide select, 0=direct, 1=div2, 2=div4, 3=div8\n"
  "#define ADC_CFG1_ADLSMP\t\t\t(uint32_t)0x10\t\t\t// Sample time configuration, 0=Short, 1=Long\n"
  "#define ADC_CFG1_MODE(n)\t\t(uint32_t)(((n) & 3) << 2)\t// Conversion mode, 0=8 bit, 1=12 bit, 2=10 bit, 3=16 bit\n"
  "#define ADC_CFG1_ADICLK(n)\t\t(uint32_t)(((n) & 3) << 0)\t// Input clock, 0=bus, 1=bus/2, 2=OSCERCLK, 3=async\n"
  "#define ADC0_CFG2\t\t*(volatile uint32_t *)0x4003B00C // Configuration register 2\n"
  "#define ADC_CFG2_MUXSEL\t\t\t(uint32_t)0x10\t\t\t// 0=a channels, 1=b channels\n"
  "#define ADC_CFG2_ADACKEN\t\t(uint32_t)0x08\t\t\t// async clock enable\n"
  "#define ADC_CFG2_ADHSC\t\t\t(uint32_t)0x04\t\t\t// High speed configuration\n"
  "#define ADC_CFG2_ADLSTS(n)\t\t(uint32_t)(((n) & 3) << 0)\t// Sample time, 0=24 cycles, 1=12 cycles, 2=6 cycles, 3=2 cycles\n"
  "#define ADC0_RA\t\t\t*(volatile uint32_t *)0x4003B010 // ADC data result register\n"
  "#define ADC0_RB\t\t\t*(volatile uint32_t *)0x4003B014 // ADC data result register\n"
  "#define ADC0_CV1\t\t*(volatile uint32_t *)0x4003B018 // Compare value registers\n"
  "#define ADC0_CV2\t\t*(volatile uint32_t *)0x4003B01C // Compare value registers\n"
  "#define ADC0_SC2\t\t*(volatile uint32_t *)0x4003B020 // Status and control register 2\n"
  "#define ADC_SC2_ADACT\t\t\t(uint32_t)0x80\t\t\t// Conversion active\n"
  "#define ADC_SC2_ADTRG\t\t\t(uint32_t)0x40\t\t\t// Conversion trigger select, 0=software, 1=hardware\n"
  "#define ADC_SC2_ACFE\t\t\t(uint32_t)0x20\t\t\t// Compare function enable\n"
  "#define ADC_SC2_ACFGT\t\t\t(uint32_t)0x10\t\t\t// Compare function greater than enable\n"
  "#define ADC_SC2_ACREN\t\t\t(uint32_t)0x08\t\t\t// Compare function range enable\n"
  "#define ADC_SC2_DMAEN\t\t\t(uint32_t)0x04\t\t\t// DMA enable\n"
  "#define ADC_SC2_REFSEL(n)\t\t(uint32_t)(((n) & 3) << 0)\t// Voltage reference, 0=vcc/external, 1=1.2 volts\n"
  "#define ADC0_SC3\t\t*(volatile uint32_t *)0x4003B024 // Status and control register 3\n"
  "#define ADC_SC3_CAL\t\t\t(uint32_t)0x80\t\t\t// Calibration, 1=begin, stays set while cal in progress\n"
  "#define ADC_SC3_CALF\t\t\t(uint32_t)0x40\t\t\t// Calibration failed flag\n"
  "#define ADC_SC3_ADCO\t\t\t(uint32_t)0x08\t\t\t// Continuous conversion enable\n"
  "#define ADC_SC3_AVGE\t\t\t(uint32_t)0x04\t\t\t// Hardware average enable\n"
  "#define ADC_SC3_AVGS(n)\t\t\t(uint32_t)(((n) & 3) << 0)\t// avg select, 0=4 samples, 1=8 samples, 2=16 samples, 3=32 samples\n"
  "#define ADC0_OFS\t\t*(volatile uint32_t *)0x4003B028 // ADC offset correction register\n"
  "#define ADC0_PG\t\t\t*(volatile uint32_t *)0x4003B02C // ADC plus-side gain register\n"
  "#define ADC0_MG\t\t\t*(volatile uint32_t *)0x4003B030 // ADC minus-side gain register\n"
  "#define ADC0_CLPD\t\t*(volatile uint32_t *)0x4003B034 // ADC plus-side general calibration value register\n"
  "#define ADC0_CLPS\t\t*(volatile uint32_t *)0x4003B038 // ADC plus-side general calibration value register\n"
  "#define ADC0_CLP4\t\t*(volatile uint32_t *)0x4003B03C // ADC plus-side general calibration value register\n"
  "#define ADC0_CLP3\t\t*(volatile uint32_t *)0x4003B040 // ADC plus-side general calibration value register\n"
  "#define ADC0_CLP2\t\t*(volatile uint32_t *)0x4003B044 // ADC plus-side general calibration value register\n"
  "#define ADC0_CLP1\t\t*(volatile uint32_t *)0x4003B048 // ADC plus-side general calibration value register\n"
  "#define ADC0_CLP0\t\t*(volatile uint32_t *)0x4003B04C // ADC plus-side general calibration value register\n"
  "#define ADC0_PGA\t\t*(volatile uint32_t *)0x4003B050 // ADC Programmable Gain Amplifier\n"
  "#define ADC0_PGA_PGAEN\t\t\t(uint32_t)0x00800000\t\t// Enable\n"
  "#define ADC0_PGA_PGALPB\t\t\t(uint32_t)0x00100000\t\t// Low-Power Mode Control, 0=low power, 1=normal\n"
  "#define ADC0_PGA_PGAG(n)\t\t(uint32_t)(((n) & 15) << 16)\t// Gain, 0=1X, 1=2X, 2=4X, 3=8X, 4=16X, 5=32X, 6=64X\n"
  "#define ADC0_CLMD\t\t*(volatile uint32_t *)0x4003B054 // ADC minus-side general calibration value register\n"
  "#define ADC0_CLMS\t\t*(volatile uint32_t *)0x4003B058 // ADC minus-side general calibration value register\n"
  "#define ADC0_CLM4\t\t*(volatile uint32_t *)0x4003B05C // ADC minus-side general calibration value register\n"
  "#define ADC0_CLM3\t\t*(volatile uint32_t *)0x4003B060 // ADC minus-side general calibration value register\n"
  "#define ADC0_CLM2\t\t*(volatile uint32_t *)0x4003B064 // ADC minus-side general calibration value register\n"
  "#define ADC0_CLM1\t\t*(volatile uint32_t *)0x4003B068 // ADC minus-side general calibration value register\n"
  "#define ADC0_CLM0\t\t*(volatile uint32_t *)0x4003B06C // ADC minus-side general calibration value register\n"
  "\n"
  "#define ADC1_SC1A\t\t*(volatile uint32_t *)0x400BB000 // ADC status and control registers 1\n"
  "#define ADC1_SC1B\t\t*(volatile uint32_t *)0x400BB004 // ADC status and control registers 1\n"
  "#define ADC1_CFG1\t\t*(volatile uint32_t *)0x400BB008 // ADC configuration register 1\n"
  "#define ADC1_CFG2\t\t*(volatile uint32_t *)0x400BB00C // Configuration register 2\n"
  "#define ADC1_RA\t\t\t*(volatile uint32_t *)0x400BB010 // ADC data result register\n"
  "#define ADC1_RB\t\t\t*(volatile uint32_t *)0x400BB014 // ADC data result register\n"
  "#define ADC1_CV1\t\t*(volatile uint32_t *)0x400BB018 // Compare value registers\n"
  "#define ADC1_CV2\t\t*(volatile uint32_t *)0x400BB01C // Compare value registers\n"
  "#define ADC1_SC2\t\t*(volatile uint32_t *)0x400BB020 // Status and control register 2\n"
  "#define ADC1_SC3\t\t*(volatile uint32_t *)0x400BB024 // Status and control register 3\n"
  "#define ADC1_OFS\t\t*(volatile uint32_t *)0x400BB028 // ADC offset correction register\n"
  "#define ADC1_PG\t\t\t*(volatile uint32_t *)0x400BB02C // ADC plus-side gain register\n"
  "#define ADC1_MG\t\t\t*(volatile uint32_t *)0x400BB030 // ADC minus-side gain register\n"
  "#define ADC1_CLPD\t\t*(volatile uint32_t *)0x400BB034 // ADC plus-side general calibration value register\n"
  "#define ADC1_CLPS\t\t*(volatile uint32_t *)0x400BB038 // ADC plus-side general calibration value register\n"
  "#define ADC1_CLP4\t\t*(volatile uint32_t *)0x400BB03C // ADC plus-side general calibration value register\n"
  "#define ADC1_CLP3\t\t*(volatile uint32_t *)0x400BB040 // ADC plus-side general calibration value register\n"
  "#define ADC1_CLP2\t\t*(volatile uint32_t *)0x400BB044 // ADC plus-side general calibration value register\n"
  "#define ADC1_CLP1\t\t*(volatile uint32_t *)0x400BB048 // ADC plus-side general calibration value register\n"
  "#define ADC1_CLP0\t\t*(volatile uint32_t *)0x400BB04C // ADC plus-side general calibration value register\n"
  "#define ADC1_PGA\t\t*(volatile uint32_t *)0x400BB050 // ADC Programmable Gain Amplifier\n"
  "#define ADC1_CLMD\t\t*(volatile uint32_t *)0x400BB054 // ADC minus-side general calibration value register\n"
  "#define ADC1_CLMS\t\t*(volatile uint32_t *)0x400BB058 // ADC minus-side general calibration value register\n"
  "#define ADC1_CLM4\t\t*(volatile uint32_t *)0x400BB05C // ADC minus-side general calibration value register\n"
  "#define ADC1_CLM3\t\t*(volatile uint32_t *)0x400BB060 // ADC minus-side general calibration value register\n"
  "#define ADC1_CLM2\t\t*(volatile uint32_t *)0x400BB064 // ADC minus-side general calibration value register\n"
  "#define ADC1_CLM1\t\t*(volatile uint32_t *)0x400BB068 // ADC minus-side general calibration value register\n"
  "#define ADC1_CLM0\t\t*(volatile uint32_t *)0x400BB06C // ADC minus-side general calibration value register\n"
  "\n"
  "#define DAC0_DAT0L\t\t*(volatile uint8_t  *)0x400CC000 // DAC Data Low Register \n"
  "#define DAC0_DATH\t\t*(volatile uint8_t  *)0x400CC001 // DAC Data High Register \n"
  "#define DAC0_DAT1L\t\t*(volatile uint8_t  *)0x400CC002 // DAC Data Low Register \n"
  "#define DAC0_DAT2L\t\t*(volatile uint8_t  *)0x400CC004 // DAC Data Low Register \n"
  "#define DAC0_DAT3L\t\t*(volatile uint8_t  *)0x400CC006 // DAC Data Low Register \n"
  "#define DAC0_DAT4L\t\t*(volatile uint8_t  *)0x400CC008 // DAC Data Low Register \n"
  "#define DAC0_DAT5L\t\t*(volatile uint8_t  *)0x400CC00A // DAC Data Low Register \n"
  "#define DAC0_DAT6L\t\t*(volatile uint8_t  *)0x400CC00C // DAC Data Low Register \n"
  "#define DAC0_DAT7L\t\t*(volatile uint8_t  *)0x400CC00E // DAC Data Low Register \n"
  "#define DAC0_DAT8L\t\t*(volatile uint8_t  *)0x400CC010 // DAC Data Low Register \n"
  "#define DAC0_DAT9L\t\t*(volatile uint8_t  *)0x400CC012 // DAC Data Low Register \n"
  "#define DAC0_DAT10L\t\t*(volatile uint8_t  *)0x400CC014 // DAC Data Low Register \n"
  "#define DAC0_DAT11L\t\t*(volatile uint8_t  *)0x400CC016 // DAC Data Low Register \n"
  "#define DAC0_DAT12L\t\t*(volatile uint8_t  *)0x400CC018 // DAC Data Low Register \n"
  "#define DAC0_DAT13L\t\t*(volatile uint8_t  *)0x400CC01A // DAC Data Low Register \n"
  "#define DAC0_DAT14L\t\t*(volatile uint8_t  *)0x400CC01C // DAC Data Low Register \n"
  "#define DAC0_DAT15L\t\t*(volatile uint8_t  *)0x400CC01E // DAC Data Low Register \n"
  "#define DAC0_SR\t\t\t*(volatile uint8_t  *)0x400CC020 // DAC Status Register \n"
  "#define DAC0_C0\t\t\t*(volatile uint8_t  *)0x400CC021 // DAC Control Register \n"
  "#define DAC_C0_DACEN\t\t\t0x80\t\t\t\t// DAC Enable\n"
  "#define DAC_C0_DACRFS\t\t\t0x40\t\t\t\t// DAC Reference Select\n"
  "#define DAC_C0_DACTRGSEL\t\t0x20\t\t\t\t// DAC Trigger Select\n"
  "#define DAC_C0_DACSWTRG\t\t\t0x10\t\t\t\t// DAC Software Trigger\n"
  "#define DAC_C0_LPEN\t\t\t0x08\t\t\t\t// DAC Low Power Control\n"
  "#define DAC_C0_DACBWIEN\t\t\t0x04\t\t\t\t// DAC Buffer Watermark Interrupt Enable\n"
  "#define DAC_C0_DACBTIEN\t\t\t0x02\t\t\t\t// DAC Buffer Read Pointer Top Flag Interrupt Enable\n"
  "#define DAC_C0_DACBBIEN\t\t\t0x01\t\t\t\t// DAC Buffer Read Pointer Bottom Flag Interrupt Enable\n"
  "#define DAC0_C1\t\t\t*(volatile uint8_t  *)0x400CC022 // DAC Control Register 1 \n"
  "#define DAC_C1_DMAEN\t\t\t0x80\t\t\t\t// DMA Enable Select\n"
  "#define DAC_C1_DACBFWM(n)\t\t(((n) & 3) << 3)\t\t// DAC Buffer Watermark Select\n"
  "#define DAC_C1_DACBFMD(n)\t\t(((n) & 3) << 0)\t\t// DAC Buffer Work Mode Select\n"
  "#define DAC_C1_DACBFEN\t\t\t0x00\t\t\t\t// DAC Buffer Enable\n"
  "\n"
  "#define DAC0_C2\t\t\t*(volatile uint8_t  *)0x400CC023 // DAC Control Register 2 \n"
  "#define DAC_C2_DACBFRP(n)\t\t(((n) & 15) << 4)\t\t// DAC Buffer Read Pointer\n"
  "#define DAC_C2_DACBFUP(n)\t\t(((n) & 15) << 0)\t\t// DAC Buffer Upper Limit\n"
  "\n"
  "\n"
  "//#define MCG_C2_RANGE0(n)\t\t(uint8_t)(((n) & 0x03) << 4)\t// Frequency Range Select, Selects the frequency range for the crystal oscillator\n"
  "//#define MCG_C2_LOCRE0\t\t\t(uint8_t)0x80\t\t\t// Loss of Clock Reset Enable, Determines whether an interrupt or a reset request is made following a loss o"
  "f OSC0 \n"
  "\n"
  "// Chapter 32: Comparator (CMP)\n"
  "#define CMP0_CR0\t\t*(volatile uint8_t  *)0x40073000 // CMP Control Register 0\n"
  "#define CMP0_CR1\t\t*(volatile uint8_t  *)0x40073001 // CMP Control Register 1\n"
  "#define CMP0_FPR\t\t*(volatile uint8_t  *)0x40073002 // CMP Filter Period Register\n"
  "#define CMP0_SCR\t\t*(volatile uint8_t  *)0x40073003 // CMP Status and Control Register\n"
  "#define CMP0_DACCR\t\t*(volatile uint8_t  *)0x40073004 // DAC Control Register\n"
  "#define CMP0_MUXCR\t\t*(volatile uint8_t  *)0x40073005 // MUX Control Register\n"
  "#define CMP1_CR0\t\t*(volatile uint8_t  *)0x40073008 // CMP Control Register 0\n"
  "#define CMP1_CR1\t\t*(volatile uint8_t  *)0x40073009 // CMP Control Register 1\n"
  "#define CMP1_FPR\t\t*(volatile uint8_t  *)0x4007300A // CMP Filter Period Register\n"
  "#define CMP1_SCR\t\t*(volatile uint8_t  *)0x4007300B // CMP Status and Control Register\n"
  "#define CMP1_DACCR\t\t*(volatile uint8_t  *)0x4007300C // DAC Control Register\n"
  "#define CMP1_MUXCR\t\t*(volatile uint8_t  *)0x4007300D // MUX Control Register\n"
  "\n"
  "// Chapter 33: Voltage Reference (VREFV1)\n"
  "#define VREF_TRM\t\t*(volatile uint8_t  *)0x40074000 // VREF Trim Register\n"
  "#define VREF_SC\t\t\t*(volatile uint8_t  *)0x40074001 // VREF Status and Control Register\n"
  "\n"
  "// Chapter 34: Programmable Delay Block (PDB)\n"
  "#define PDB0_SC\t\t\t*(volatile uint32_t *)0x40036000 // Status and Control Register\n"
  "#define PDB_SC_LDMOD(n)\t\t\t(((n) & 3) << 18)\t// Load Mode Select\n"
  "#define PDB_SC_PDBEIE\t\t\t0x00020000\t\t// Sequence Error Interrupt Enable\n"
  "#define PDB_SC_SWTRIG\t\t\t0x00010000\t\t// Software Trigger\n"
  "#define PDB_SC_DMAEN\t\t\t0x00008000\t\t// DMA Enable\n"
  "#define PDB_SC_PRESCALER(n)\t\t(((n) & 7) << 12)\t// Prescaler Divider Select\n"
  "#define PDB_SC_TRGSEL(n)\t\t(((n) & 15) << 8)\t// Trigger Input Source Select\n"
  "#define PDB_SC_PDBEN\t\t\t0x00000080\t\t// PDB Enable\n"
  "#define PDB_SC_PDBIF\t\t\t0x00000040\t\t// PDB Interrupt Flag\n"
  "#define PDB_SC_PDBIE\t\t\t0x00000020\t\t// PDB Interrupt Enable.\n"
  "#define PDB_SC_MULT(n)\t\t\t(((n) & 3) << 2)\t// Multiplication Factor\n"
  "#define PDB_SC_CONT\t\t\t0x00000002\t\t// Continuous Mode Enable\n"
  "#define PDB_SC_LDOK\t\t\t0x00000001\t\t// Load OK\n"
  "#define PDB0_MOD\t\t*(volatile uint32_t *)0x40036004 // Modulus Register\n"
  "#define PDB0_CNT\t\t*(volatile uint32_t *)0x40036008 // Counter Register\n"
  "#define PDB0_IDLY\t\t*(volatile uint32_t *)0x4003600C // Interrupt Delay Register\n"
  "#define PDB0_CH0C1\t\t*(volatile uint32_t *)0x40036010 // Channel n Control Register 1\n"
  "#define PDB0_CH0S\t\t*(volatile uint32_t *)0x40036014 // Channel n Status Register\n"
  "#define PDB0_CH0DLY0\t\t*(volatile uint32_t *)0x40036018 // Channel n Delay 0 Register\n"
  "#define PDB0_CH0DLY1\t\t*(volatile uint32_t *)0x4003601C // Channel n Delay 1 Register\n"
  "#define PDB0_POEN\t\t*(volatile uint32_t *)0x40036190 // Pulse-Out n Enable Register\n"
  "#define PDB0_PO0DLY\t\t*(volatile uint32_t *)0x40036194 // Pulse-Out n Delay Register\n"
  "#define PDB0_PO1DLY\t\t*(volatile uint32_t *)0x40036198 // Pulse-Out n Delay Register\n"
  "\n"
  "// Chapter 35: FlexTimer Module (FTM)\n"
  "#define FTM0_SC\t\t\t*(volatile uint32_t *)0x40038000 // Status And Control\n"
  "#define FTM_SC_TOF\t\t\t0x80\t\t\t\t// Timer Overflow Flag\n"
  "#define FTM_SC_TOIE\t\t\t0x40\t\t\t\t// Timer Overflow Interrupt Enable\n"
  "#define FTM_SC_CPWMS\t\t\t0x20\t\t\t\t// Center-Aligned PWM Select\n"
  "#define FTM_SC_CLKS(n)\t\t\t(((n) & 3) << 3)\t\t// Clock Source Selection\n"
  "#define FTM_SC_PS(n)\t\t\t(((n) & 7) << 0)\t\t// Prescale Factor Selection\n"
  "#define FTM0_CNT\t\t*(volatile uint32_t *)0x40038004 // Counter\n"
  "#define FTM0_MOD\t\t*(volatile uint32_t *)0x40038008 // Modulo\n"
  "#define FTM0_C0SC\t\t*(volatile uint32_t *)0x4003800C // Channel 0 Status And Control\n"
  "#define FTM0_C0V\t\t*(volatile uint32_t *)0x40038010 // Channel 0 Value\n"
  "#define FTM0_C1SC\t\t*(volatile uint32_t *)0x40038014 // Channel 1 Status And Control\n"
  "#define FTM0_C1V\t\t*(volatile uint32_t *)0x40038018 // Channel 1 Value\n"
  "#define FTM0_C2SC\t\t*(volatile uint32_t *)0x4003801C // Channel 2 Status And Control\n"
  "#define FTM0_C2V\t\t*(volatile uint32_t *)0x40038020 // Channel 2 Value\n"
  "#define FTM0_C3SC\t\t*(volatile uint32_t *)0x40038024 // Channel 3 Status And Control\n"
  "#define FTM0_C3V\t\t*(volatile uint32_t *)0x40038028 // Channel 3 Value\n"
  "#define FTM0_C4SC\t\t*(volatile uint32_t *)0x4003802C // Channel 4 Status And Control\n"
  "#define FTM0_C4V\t\t*(volatile uint32_t *)0x40038030 // Channel 4 Value\n"
  "#define FTM0_C5SC\t\t*(volatile uint32_t *)0x40038034 // Channel 5 Status And Control\n"
  "#define FTM0_C5V\t\t*(volatile uint32_t *)0x40038038 // Channel 5 Value\n"
  "#define FTM0_C6SC\t\t*(volatile uint32_t *)0x4003803C // Channel 6 Status And Control\n"
  "#define FTM0_C6V\t\t*(volatile uint32_t *)0x40038040 // Channel 6 Value\n"
  "#define FTM0_C7SC\t\t*(volatile uint32_t *)0x40038044 // Channel 7 Status And Control\n"
  "#define FTM0_C7V\t\t*(volatile uint32_t *)0x40038048 // Channel 7 Value\n"
  "#define FTM0_CNTIN\t\t*(volatile uint32_t *)0x4003804C // Counter Initial Value\n"
  "#define FTM0_STATUS\t\t*(volatile uint32_t *)0x40038050 // Capture And Compare Status\n"
  "#define FTM0_MODE\t\t*(volatile uint32_t *)0x40038054 // Features Mode Selection\n"
  "#define FTM_MODE_FAULTIE\t\t0x80\t\t\t\t// Fault Interrupt Enable\n"
  "#define FTM_MODE_FAULTM(n)\t\t(((n) & 3) << 5)\t\t// Fault Control Mode\n"
  "#define FTM_MODE_CAPTEST\t\t0x10\t\t\t\t// Capture Test Mode Enable\n"
  "#define FTM_MODE_PWMSYNC\t\t0x08\t\t\t\t// PWM Synchronization Mode\n"
  "#define FTM_MODE_WPDIS\t\t\t0x04\t\t\t\t// Write Protection Disable\n"
  "#define FTM_MODE_INIT\t\t\t0x02\t\t\t\t// Initialize The Channels Output\n"
  "#define FTM_MODE_FTMEN\t\t\t0x01\t\t\t\t// FTM Enable\n"
  "#define FTM0_SYNC\t\t*(volatile uint32_t *)0x40038058 // Synchronization\n"
  "#define FTM_SYNC_SWSYNC\t\t\t0x80\t\t\t\t// \n"
  "#define FTM_SYNC_TRIG2\t\t\t0x40\t\t\t\t// \n"
  "#define FTM_SYNC_TRIG1\t\t\t0x20\t\t\t\t// \n"
  "#define FTM_SYNC_TRIG0\t\t\t0x10\t\t\t\t// \n"
  "#define FTM_SYNC_SYNCHOM\t\t0x08\t\t\t\t// \n"
  "#define FTM_SYNC_REINIT\t\t\t0x04\t\t\t\t// \n"
  "#define FTM_SYNC_CNTMAX\t\t\t0x02\t\t\t\t// \n"
  "#define FTM_SYNC_CNTMIN\t\t\t0x01\t\t\t\t// \n"
  "#define FTM0_OUTINIT\t\t*(volatile uint32_t *)0x4003805C // Initial State For Channels Output\n"
  "#define FTM0_OUTMASK\t\t*(volatile uint32_t *)0x40038060 // Output Mask\n"
  "#define FTM0_COMBINE\t\t*(volatile uint32_t *)0x40038064 // Function For Linked Channels\n"
  "#define FTM0_DEADTIME\t\t*(volatile uint32_t *)0x40038068 // Deadtime Insertion Control\n"
  "#define FTM0_EXTTRIG\t\t*(volatile uint32_t *)0x4003806C // FTM External Trigger\n"
  "#define FTM0_POL\t\t*(volatile uint32_t *)0x40038070 // Channels Polarity\n"
  "#define FTM0_FMS\t\t*(volatile uint32_t *)0x40038074 // Fault Mode Status\n"
  "#define FTM0_FILTER\t\t*(volatile uint32_t *)0x40038078 // Input Capture Filter Control\n"
  "#define FTM0_FLTCTRL\t\t*(volatile uint32_t *)0x4003807C // Fault Control\n"
  "#define FTM0_QDCTRL\t\t*(volatile uint32_t *)0x40038080 // Quadrature Decoder Control And Status\n"
  "#define FTM0_CONF\t\t*(volatile uint32_t *)0x40038084 // Configuration\n"
  "#define FTM0_FLTPOL\t\t*(volatile uint32_t *)0x40038088 // FTM Fault Input Polarity\n"
  "#define FTM0_SYNCONF\t\t*(volatile uint32_t *)0x4003808C // Synchronization Configuration\n"
  "#define FTM0_INVCTRL\t\t*(volatile uint32_t *)0x40038090 // FTM Inverting Control\n"
  "#define FTM0_SWOCTRL\t\t*(volatile uint32_t *)0x40038094 // FTM Software Output Control\n"
  "#define FTM0_PWMLOAD\t\t*(volatile uint32_t *)0x40038098 // FTM PWM Load\n"
  "#define FTM1_SC\t\t\t*(volatile uint32_t *)0x40039000 // Status And Control\n"
  "#define FTM1_CNT\t\t*(volatile uint32_t *)0x40039004 // Counter\n"
  "#define FTM1_MOD\t\t*(volatile uint32_t *)0x40039008 // Modulo\n"
  "#define FTM1_C0SC\t\t*(volatile uint32_t *)0x4003900C // Channel 0 Status And Control\n"
  "#define FTM1_C0V\t\t*(volatile uint32_t *)0x40039010 // Channel 0 Value\n"
  "#define FTM1_C1SC\t\t*(volatile uint32_t *)0x40039014 // Channel 1 Status And Control\n"
  "#define FTM1_C1V\t\t*(volatile uint32_t *)0x40039018 // Channel 1 Value\n"
  "#define FTM1_CNTIN\t\t*(volatile uint32_t *)0x4003904C // Counter Initial Value\n"
  "#define FTM1_STATUS\t\t*(volatile uint32_t *)0x40039050 // Capture And Compare Status\n"
  "#define FTM1_MODE\t\t*(volatile uint32_t *)0x40039054 // Features Mode Selection\n"
  "#define FTM1_SYNC\t\t*(volatile uint32_t *)0x40039058 // Synchronization\n"
  "#define FTM1_OUTINIT\t\t*(volatile uint32_t *)0x4003905C // Initial State For Channels Output\n"
  "#define FTM1_OUTMASK\t\t*(volatile uint32_t *)0x40039060 // Output Mask\n"
  "#define FTM1_COMBINE\t\t*(volatile uint32_t *)0x40039064 // Function For Linked Channels\n"
  "#define FTM1_DEADTIME\t\t*(volatile uint32_t *)0x40039068 // Deadtime Insertion Control\n"
  "#define FTM1_EXTTRIG\t\t*(volatile uint32_t *)0x4003906C // FTM External Trigger\n"
  "#define FTM1_POL\t\t*(volatile uint32_t *)0x40039070 // Channels Polarity\n"
  "#define FTM1_FMS\t\t*(volatile uint32_t *)0x40039074 // Fault Mode Status\n"
  "#define FTM1_FILTER\t\t*(volatile uint32_t *)0x40039078 // Input Capture Filter Control\n"
  "#define FTM1_FLTCTRL\t\t*(volatile uint32_t *)0x4003907C // Fault Control\n"
  "#define FTM1_QDCTRL\t\t*(volatile uint32_t *)0x40039080 // Quadrature Decoder Control And Status\n"
  "#define FTM1_CONF\t\t*(volatile uint32_t *)0x40039084 // Configuration\n"
  "#define FTM1_FLTPOL\t\t*(volatile uint32_t *)0x40039088 // FTM Fault Input Polarity\n"
  "#define FTM1_SYNCONF\t\t*(volatile uint32_t *)0x4003908C // Synchronization Configuration\n"
  "#define FTM1_INVCTRL\t\t*(volatile uint32_t *)0x40039090 // FTM Inverting Control\n"
  "#define FTM1_SWOCTRL\t\t*(volatile uint32_t *)0x40039094 // FTM Software Output Control\n"
  "#define FTM1_PWMLOAD\t\t*(volatile uint32_t *)0x40039098 // FTM PWM Load\n"
  "#define FTM2_SC\t\t\t*(volatile uint32_t *)0x400B8000 // Status And Control\n"
  "#define FTM2_CNT\t\t*(volatile uint32_t *)0x400B8004 // Counter\n"
  "#define FTM2_MOD\t\t*(volatile uint32_t *)0x400B8008 // Modulo\n"
  "#define FTM2_C0SC\t\t*(volatile uint32_t *)0x400B800C // Channel 0 Status And Control\n"
  "#define FTM2_C0V\t\t*(volatile uint32_t *)0x400B8010 // Channel 0 Value\n"
  "#define FTM2_C1SC\t\t*(volatile uint32_t *)0x400B8014 // Channel 1 Status And Control\n"
  "#define FTM2_C1V\t\t*(volatile uint32_t *)0x400B8018 // Channel 1 Value\n"
  "#define FTM2_CNTIN\t\t*(volatile uint32_t *)0x400B804C // Counter Initial Value\n"
  "#define FTM2_STATUS\t\t*(volatile uint32_t *)0x400B8050 // Capture And Compare Status\n"
  "#define FTM2_MODE\t\t*(volatile uint32_t *)0x400B8054 // Features Mode Selection\n"
  "#define FTM2_SYNC\t\t*(volatile uint32_t *)0x400B8058 // Synchronization\n"
  "#define FTM2_OUTINIT\t\t*(volatile uint32_t *)0x400B805C // Initial State For Channels Output\n"
  "#define FTM2_OUTMASK\t\t*(volatile uint32_t *)0x400B8060 // Output Mask\n"
  "#define FTM2_COMBINE\t\t*(volatile uint32_t *)0x400B8064 // Function For Linked Channels\n"
  "#define FTM2_DEADTIME\t\t*(volatile uint32_t *)0x400B8068 // Deadtime Insertion Control\n"
  "#define FTM2_EXTTRIG\t\t*(volatile uint32_t *)0x400B806C // FTM External Trigger\n"
  "#define FTM2_POL\t\t*(volatile uint32_t *)0x400B8070 // Channels Polarity\n"
  "#define FTM2_FMS\t\t*(volatile uint32_t *)0x400B8074 // Fault Mode Status\n"
  "#define FTM2_FILTER\t\t*(volatile uint32_t *)0x400B8078 // Input Capture Filter Control\n"
  "#define FTM2_FLTCTRL\t\t*(volatile uint32_t *)0x400B807C // Fault Control\n"
  "#define FTM2_QDCTRL\t\t*(volatile uint32_t *)0x400B8080 // Quadrature Decoder Control And Status\n"
  "#define FTM2_CONF\t\t*(volatile uint32_t *)0x400B8084 // Configuration\n"
  "#define FTM2_FLTPOL\t\t*(volatile uint32_t *)0x400B8088 // FTM Fault Input Polarity\n"
  "#define FTM2_SYNCONF\t\t*(volatile uint32_t *)0x400B808C // Synchronization Configuration\n"
  "#define FTM2_INVCTRL\t\t*(volatile uint32_t *)0x400B8090 // FTM Inverting Control\n"
  "#define FTM2_SWOCTRL\t\t*(volatile uint32_t *)0x400B8094 // FTM Software Output Control\n"
  "#define FTM2_PWMLOAD\t\t*(volatile uint32_t *)0x400B8098 // FTM PWM Load\n"
  "\n"
  "// Chapter 36: Periodic Interrupt Timer (PIT)\n"
  "#define PIT_MCR\t\t\t*(volatile uint32_t *)0x40037000 // PIT Module Control Register\n"
  "#define PIT_LDVAL0\t\t*(volatile uint32_t *)0x40037100 // Timer Load Value Register\n"
  "#define PIT_CVAL0\t\t*(volatile uint32_t *)0x40037104 // Current Timer Value Register\n"
  "#define PIT_TCTRL0\t\t*(volatile uint32_t *)0x40037108 // Timer Control Register\n"
  "#define PIT_TFLG0\t\t*(volatile uint32_t *)0x4003710C // Timer Flag Register\n"
  "#define PIT_LDVAL1\t\t*(volatile uint32_t *)0x40037110 // Timer Load Value Register\n"
  "#define PIT_CVAL1\t\t*(volatile uint32_t *)0x40037114 // Current Timer Value Register\n"
  "#define PIT_TCTRL1\t\t*(volatile uint32_t *)0x40037118 // Timer Control Register\n"
  "#define PIT_TFLG1\t\t*(volatile uint32_t *)0x4003711C // Timer Flag Register\n"
  "#define PIT_LDVAL2\t\t*(volatile uint32_t *)0x40037120 // Timer Load Value Register\n"
  "#define PIT_CVAL2\t\t*(volatile uint32_t *)0x40037124 // Current Timer Value Register\n"
  "#define PIT_TCTRL2\t\t*(volatile uint32_t *)0x40037128 // Timer Control Register\n"
  "#define PIT_TFLG2\t\t*(volatile uint32_t *)0x4003712C // Timer Flag Register\n"
  "#define PIT_LDVAL3\t\t*(volatile uint32_t *)0x40037130 // Timer Load Value Register\n"
  "#define PIT_CVAL3\t\t*(volatile uint32_t *)0x40037134 // Current Timer Value Register\n"
  "#define PIT_TCTRL3\t\t*(volatile uint32_t *)0x40037138 // Timer Control Register\n"
  "#define PIT_TFLG3\t\t*(volatile uint32_t *)0x4003713C // Timer Flag Register\n"
  "\n"
  "// Chapter 37: Low-Power Timer (LPTMR)\n"
  "#define LPTMR0_CSR\t\t*(volatile uint32_t *)0x40040000 // Low Power Timer Control Status Register\n"
  "#define LPTMR0_PSR\t\t*(volatile uint32_t *)0x40040004 // Low Power Timer Prescale Register\n"
  "#define LPTMR0_CMR\t\t*(volatile uint32_t *)0x40040008 // Low Power Timer Compare Register\n"
  "#define LPTMR0_CNR\t\t*(volatile uint32_t *)0x4004000C // Low Power Timer Counter Register\n"
  "\n"
  "// Chapter 38: Carrier Modulator Transmitter (CMT)\n"
  "#define CMT_CGH1\t\t*(volatile uint8_t  *)0x40062000 // CMT Carrier Generator High Data Register 1\n"
  "#define CMT_CGL1\t\t*(volatile uint8_t  *)0x40062001 // CMT Carrier Generator Low Data Register 1\n"
  "#define CMT_CGH2\t\t*(volatile uint8_t  *)0x40062002 // CMT Carrier Generator High Data Register 2\n"
  "#define CMT_CGL2\t\t*(volatile uint8_t  *)0x40062003 // CMT Carrier Generator Low Data Register 2\n"
  "#define CMT_OC\t\t\t*(volatile uint8_t  *)0x40062004 // CMT Output Control Register\n"
  "#define CMT_MSC\t\t\t*(volatile uint8_t  *)0x40062005 // CMT Modulator Status and Control Register\n"
  "#define CMT_CMD1\t\t*(volatile uint8_t  *)0x40062006 // CMT Modulator Data Register Mark High\n"
  "#define CMT_CMD2\t\t*(volatile uint8_t  *)0x40062007 // CMT Modulator Data Register Mark Low\n"
  "#define CMT_CMD3\t\t*(volatile uint8_t  *)0x40062008 // CMT Modulator Data Register Space High\n"
  "#define CMT_CMD4\t\t*(volatile uint8_t  *)0x40062009 // CMT Modulator Data Register Space Low\n"
  "#define CMT_PPS\t\t\t*(volatile uint8_t  *)0x4006200A // CMT Primary Prescaler Register\n"
  "#define CMT_DMA\t\t\t*(volatile uint8_t  *)0x4006200B // CMT Direct Memory Access Register\n"
  "\n"
  "// Chapter 39: Real Time Clock (RTC)\n"
  "#define RTC_TSR\t\t\t*(volatile uint32_t *)0x4003D000 // RTC Time Seconds Register\n"
  "#define RTC_TPR\t\t\t*(volatile uint32_t *)0x4003D004 // RTC Time Prescaler Register\n"
  "#define RTC_TAR\t\t\t*(volatile uint32_t *)0x4003D008 // RTC Time Alarm Register\n"
  "#define RTC_TCR\t\t\t*(volatile uint32_t *)0x4003D00C // RTC Time Compensation Register\n"
  "#define RTC_TCR_CIC(n)\t\t\t(((n) & 255) << 24)\t\t// Compensation Interval Counter\n"
  "#define RTC_TCR_TCV(n)\t\t\t(((n) & 255) << 16)\t\t// Time Compensation Value\n"
  "#define RTC_TCR_CIR(n)\t\t\t(((n) & 255) << 8)\t\t// Compensation Interval Register\n"
  "#define RTC_TCR_TCR(n)\t\t\t(((n) & 255) << 0)\t\t// Time Compensation Register\n"
  "#define RTC_CR\t\t\t*(volatile uint32_t *)0x4003D010 // RTC Control Register\n"
  "#define RTC_CR_SC2P\t\t\t(uint32_t)0x00002000\t\t// \n"
  "#define RTC_CR_SC4P\t\t\t(uint32_t)0x00001000\t\t// \n"
  "#define RTC_CR_SC8P\t\t\t(uint32_t)0x00000800\t\t// \n"
  "#define RTC_CR_SC16P\t\t\t(uint32_t)0x00000400\t\t// \n"
  "#define RTC_CR_CLKO\t\t\t(uint32_t)0x00000200\t\t// \n"
  "#define RTC_CR_OSCE\t\t\t(uint32_t)0x00000100\t\t// \n"
  "#define RTC_CR_UM\t\t\t(uint32_t)0x00000008\t\t// \n"
  "#define RTC_CR_SUP\t\t\t(uint32_t)0x00000004\t\t// \n"
  "#define RTC_CR_WPE\t\t\t(uint32_t)0x00000002\t\t// \n"
  "#define RTC_CR_SWR\t\t\t(uint32_t)0x00000001\t\t// \n"
  "#define RTC_SR\t\t\t*(volatile uint32_t *)0x4003D014 // RTC Status Register\n"
  "#define RTC_SR_TCE\t\t\t(uint32_t)0x00000010\t\t// \n"
  "#define RTC_SR_TAF\t\t\t(uint32_t)0x00000004\t\t// \n"
  "#define RTC_SR_TOF\t\t\t(uint32_t)0x00000002\t\t// \n"
  "#define RTC_SR_TIF\t\t\t(uint32_t)0x00000001\t\t// \n"
  "#define RTC_LR\t\t\t*(volatile uint32_t *)0x4003D018 // RTC Lock Register\n"
  "#define RTC_IER\t\t\t*(volatile uint32_t *)0x4003D01C // RTC Interrupt Enable Register\n"
  "#define RTC_WAR\t\t\t*(volatile uint32_t *)0x4003D800 // RTC Write Access Register\n"
  "#define RTC_RAR\t\t\t*(volatile uint32_t *)0x4003D804 // RTC Read Access Register\n"
  "\n"
  "// Chapter 40: Universal Serial Bus OTG Controller (USBOTG)\n"
  "#define USB0_PERID\t\t*(const\t   uint8_t  *)0x40072000 // Peripheral ID register\n"
  "#define USB0_IDCOMP\t\t*(const\t   uint8_t  *)0x40072004 // Peripheral ID Complement register\n"
  "#define USB0_REV\t\t*(const\t   uint8_t  *)0x40072008 // Peripheral Revision register\n"
  "#define USB0_ADDINFO\t\t*(volatile uint8_t  *)0x4007200C // Peripheral Additional Info register\n"
  "#define USB0_OTGISTAT\t\t*(volatile uint8_t  *)0x40072010 // OTG Interrupt Status register\n"
  "#define USB_OTGISTAT_IDCHG\t\t(uint8_t)0x80\t\t\t//\n"
  "#define USB_OTGISTAT_ONEMSEC\t\t(uint8_t)0x40\t\t\t//\n"
  "#define USB_OTGISTAT_LINE_STATE_CHG\t(uint8_t)0x20\t\t\t//\n"
  "#define USB_OTGISTAT_SESSVLDCHG\t\t(uint8_t)0x08\t\t\t//\n"
  "#define USB_OTGISTAT_B_SESS_CHG\t\t(uint8_t)0x04\t\t\t//\n"
  "#define USB_OTGISTAT_AVBUSCHG\t\t(uint8_t)0x01\t\t\t//\n"
  "#define USB0_OTGICR\t\t*(volatile uint8_t  *)0x40072014 // OTG Interrupt Control Register\n"
  "#define USB_OTGICR_IDEN\t\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_OTGICR_ONEMSECEN\t\t(uint8_t)0x40\t\t\t// \n"
  "#define USB_OTGICR_LINESTATEEN\t\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_OTGICR_SESSVLDEN\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_OTGICR_BSESSEN\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_OTGICR_AVBUSEN\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_OTGSTAT\t\t*(volatile uint8_t  *)0x40072018 // OTG Status register\n"
  "#define USB_OTGSTAT_ID\t\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_OTGSTAT_ONEMSECEN\t\t(uint8_t)0x40\t\t\t// \n"
  "#define USB_OTGSTAT_LINESTATESTABLE\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_OTGSTAT_SESS_VLD\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_OTGSTAT_BSESSEND\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_OTGSTAT_AVBUSVLD\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_OTGCTL\t\t*(volatile uint8_t  *)0x4007201C // OTG Control Register\n"
  "#define USB_OTGCTL_DPHIGH\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_OTGCTL_DPLOW\t\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_OTGCTL_DMLOW\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB_OTGCTL_OTGEN\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB0_ISTAT\t\t*(volatile uint8_t  *)0x40072080 // Interrupt Status Register\n"
  "#define USB_ISTAT_STALL\t\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_ISTAT_ATTACH\t\t(uint8_t)0x40\t\t\t// \n"
  "#define USB_ISTAT_RESUME\t\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_ISTAT_SLEEP\t\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB_ISTAT_TOKDNE\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_ISTAT_SOFTOK\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_ISTAT_ERROR\t\t\t(uint8_t)0x02\t\t\t// \n"
  "#define USB_ISTAT_USBRST\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_INTEN\t\t*(volatile uint8_t  *)0x40072084 // Interrupt Enable Register\n"
  "#define USB_INTEN_STALLEN\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_INTEN_ATTACHEN\t\t(uint8_t)0x40\t\t\t// \n"
  "#define USB_INTEN_RESUMEEN\t\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_INTEN_SLEEPEN\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB_INTEN_TOKDNEEN\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_INTEN_SOFTOKEN\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_INTEN_ERROREN\t\t(uint8_t)0x02\t\t\t// \n"
  "#define USB_INTEN_USBRSTEN\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_ERRSTAT\t\t*(volatile uint8_t  *)0x40072088 // Error Interrupt Status Register\n"
  "#define USB_ERRSTAT_BTSERR\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_ERRSTAT_DMAERR\t\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_ERRSTAT_BTOERR\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB_ERRSTAT_DFN8\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_ERRSTAT_CRC16\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_ERRSTAT_CRC5EOF\t\t(uint8_t)0x02\t\t\t// \n"
  "#define USB_ERRSTAT_PIDERR\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_ERREN\t\t*(volatile uint8_t  *)0x4007208C // Error Interrupt Enable Register\n"
  "#define USB_ERREN_BTSERREN\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_ERREN_DMAERREN\t\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_ERREN_BTOERREN\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB_ERREN_DFN8EN\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_ERREN_CRC16EN\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_ERREN_CRC5EOFEN\t\t(uint8_t)0x02\t\t\t// \n"
  "#define USB_ERREN_PIDERREN\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_STAT\t\t*(volatile uint8_t  *)0x40072090 // Status Register\n"
  "#define USB_STAT_TX\t\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_STAT_ODD\t\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_STAT_ENDP(n)\t\t(uint8_t)((n) >> 4)\t\t// \n"
  "#define USB0_CTL\t\t*(volatile uint8_t  *)0x40072094 // Control Register\n"
  "#define USB_CTL_JSTATE\t\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_CTL_SE0\t\t\t(uint8_t)0x40\t\t\t// \n"
  "#define USB_CTL_TXSUSPENDTOKENBUSY\t(uint8_t)0x20\t\t\t// \n"
  "#define USB_CTL_RESET\t\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB_CTL_HOSTMODEEN\t\t(uint8_t)0x08\t\t\t// \n"
  "#define USB_CTL_RESUME\t\t\t(uint8_t)0x04\t\t\t// \n"
  "#define USB_CTL_ODDRST\t\t\t(uint8_t)0x02\t\t\t// \n"
  "#define USB_CTL_USBENSOFEN\t\t(uint8_t)0x01\t\t\t// \n"
  "#define USB0_ADDR\t\t*(volatile uint8_t  *)0x40072098 // Address Register\n"
  "#define USB0_BDTPAGE1\t\t*(volatile uint8_t  *)0x4007209C // BDT Page Register 1\n"
  "#define USB0_FRMNUML\t\t*(volatile uint8_t  *)0x400720A0 // Frame Number Register Low\n"
  "#define USB0_FRMNUMH\t\t*(volatile uint8_t  *)0x400720A4 // Frame Number Register High\n"
  "#define USB0_TOKEN\t\t*(volatile uint8_t  *)0x400720A8 // Token Register\n"
  "#define USB0_SOFTHLD\t\t*(volatile uint8_t  *)0x400720AC // SOF Threshold Register\n"
  "#define USB0_BDTPAGE2\t\t*(volatile uint8_t  *)0x400720B0 // BDT Page Register 2\n"
  "#define USB0_BDTPAGE3\t\t*(volatile uint8_t  *)0x400720B4 // BDT Page Register 3\n"
  "#define USB0_ENDPT0\t\t*(volatile uint8_t  *)0x400720C0 // Endpoint Control Register\n"
  "#define USB_ENDPT_HOSTWOHUB\t\t(uint8_t)0x80\t\t\t// host only, enable low speed\n"
  "#define USB_ENDPT_RETRYDIS\t\t(uint8_t)0x40\t\t\t// host only, set to disable NAK retry\n"
  "#define USB_ENDPT_EPCTLDIS\t\t(uint8_t)0x10\t\t\t// 0=control, 1=bulk, interrupt, isync\n"
  "#define USB_ENDPT_EPRXEN\t\t(uint8_t)0x08\t\t\t// enables the endpoint for RX transfers.\n"
  "#define USB_ENDPT_EPTXEN\t\t(uint8_t)0x04\t\t\t// enables the endpoint for TX transfers.\n"
  "#define USB_ENDPT_EPSTALL\t\t(uint8_t)0x02\t\t\t// set to stall endpoint\n"
  "#define USB_ENDPT_EPHSHK\t\t(uint8_t)0x01\t\t\t// enable handshaking during a transaction, generally set unless Isochronous\n"
  "#define USB0_ENDPT1\t\t*(volatile uint8_t  *)0x400720C4 // Endpoint Control Register\n"
  "#define USB0_ENDPT2\t\t*(volatile uint8_t  *)0x400720C8 // Endpoint Control Register\n"
  "#define USB0_ENDPT3\t\t*(volatile uint8_t  *)0x400720CC // Endpoint Control Register\n"
  "#define USB0_ENDPT4\t\t*(volatile uint8_t  *)0x400720D0 // Endpoint Control Register\n"
  "#define USB0_ENDPT5\t\t*(volatile uint8_t  *)0x400720D4 // Endpoint Control Register\n"
  "#define USB0_ENDPT6\t\t*(volatile uint8_t  *)0x400720D8 // Endpoint Control Register\n"
  "#define USB0_ENDPT7\t\t*(volatile uint8_t  *)0x400720DC // Endpoint Control Register\n"
  "#define USB0_ENDPT8\t\t*(volatile uint8_t  *)0x400720E0 // Endpoint Control Register\n"
  "#define USB0_ENDPT9\t\t*(volatile uint8_t  *)0x400720E4 // Endpoint Control Register\n"
  "#define USB0_ENDPT10\t\t*(volatile uint8_t  *)0x400720E8 // Endpoint Control Register\n"
  "#define USB0_ENDPT11\t\t*(volatile uint8_t  *)0x400720EC // Endpoint Control Register\n"
  "#define USB0_ENDPT12\t\t*(volatile uint8_t  *)0x400720F0 // Endpoint Control Register\n"
  "#define USB0_ENDPT13\t\t*(volatile uint8_t  *)0x400720F4 // Endpoint Control Register\n"
  "#define USB0_ENDPT14\t\t*(volatile uint8_t  *)0x400720F8 // Endpoint Control Register\n"
  "#define USB0_ENDPT15\t\t*(volatile uint8_t  *)0x400720FC // Endpoint Control Register\n"
  "#define USB0_USBCTRL\t\t*(volatile uint8_t  *)0x40072100 // USB Control Register\n"
  "#define USB_USBCTRL_SUSP\t\t(uint8_t)0x80\t\t\t// Places the USB transceiver into the suspend state.\n"
  "#define USB_USBCTRL_PDE\t\t\t(uint8_t)0x40\t\t\t// Enables the weak pulldowns on the USB transceiver.\n"
  "#define USB0_OBSERVE\t\t*(volatile uint8_t  *)0x40072104 // USB OTG Observe Register\n"
  "#define USB_OBSERVE_DPPU\t\t(uint8_t)0x80\t\t\t// \n"
  "#define USB_OBSERVE_DPPD\t\t(uint8_t)0x40\t\t\t// \n"
  "#define USB_OBSERVE_DMPD\t\t(uint8_t)0x10\t\t\t// \n"
  "#define USB0_CONTROL\t\t*(volatile uint8_t  *)0x40072108 // USB OTG Control Register\n"
  "#define USB_CONTROL_DPPULLUPNONOTG\t(uint8_t)0x10\t\t\t//  Provides control of the DP PULLUP in the USB OTG module, if USB is configured in non-OTG device"
  " mode.\n"
  "#define USB0_USBTRC0\t\t*(volatile uint8_t  *)0x4007210C // USB Transceiver Control Register 0\n"
  "#define USB_USBTRC_USBRESET\t\t(uint8_t)0x80\t\t\t//\n"
  "#define USB_USBTRC_USBRESMEN\t\t(uint8_t)0x20\t\t\t//\n"
  "#define USB_USBTRC_SYNC_DET\t\t(uint8_t)0x02\t\t\t//\n"
  "#define USB_USBTRC_USB_RESUME_INT\t(uint8_t)0x01\t\t\t//\n"
  "#define USB0_USBFRMADJUST\t*(volatile uint8_t  *)0x40072114 // Frame Adjust Register\n"
  "\n"
  "// Chapter 41: USB Device Charger Detection Module (USBDCD)\n"
  "#define USBDCD_CONTROL\t\t*(volatile uint32_t *)0x40035000 // Control register\n"
  "#define USBDCD_CLOCK\t\t*(volatile uint32_t *)0x40035004 // Clock register\n"
  "#define USBDCD_STATUS\t\t*(volatile uint32_t *)0x40035008 // Status register\n"
  "#define USBDCD_TIMER0\t\t*(volatile uint32_t *)0x40035010 // TIMER0 register\n"
  "#define USBDCD_TIMER1\t\t*(volatile uint32_t *)0x40035014 // TIMER1 register\n"
  "#define USBDCD_TIMER2\t\t*(volatile uint32_t *)0x40035018 // TIMER2 register\n"
  "\n"
  "// Chapter 43: SPI (DSPI)\n"
  "#define SPI0_MCR\t\t*(volatile uint32_t *)0x4002C000 // DSPI Module Configuration Register\n"
  "#define SPI_MCR_MSTR\t\t\t(uint32_t)0x80000000\t\t// Master/Slave Mode Select\n"
  "#define SPI_MCR_CONT_SCKE\t\t(uint32_t)0x40000000\t\t// \n"
  "#define SPI_MCR_DCONF(n)\t\t(((n) & 3) << 28)\t\t// \n"
  "#define SPI_MCR_FRZ\t\t\t(uint32_t)0x08000000\t\t// \n"
  "#define SPI_MCR_MTFE\t\t\t(uint32_t)0x04000000\t\t// \n"
  "#define SPI_MCR_ROOE\t\t\t(uint32_t)0x01000000\t\t// \n"
  "#define SPI_MCR_PCSIS(n)\t\t(((n) & 0x1F) << 16)\t\t//\n"
  "#define SPI_MCR_DOZE\t\t\t(uint32_t)0x00008000\t\t// \n"
  "#define SPI_MCR_MDIS\t\t\t(uint32_t)0x00004000\t\t// \n"
  "#define SPI_MCR_DIS_TXF\t\t\t(uint32_t)0x00002000\t\t// \n"
  "#define SPI_MCR_DIS_RXF\t\t\t(uint32_t)0x00001000\t\t// \n"
  "#define SPI_MCR_CLR_TXF\t\t\t(uint32_t)0x00000800\t\t// \n"
  "#define SPI_MCR_CLR_RXF\t\t\t(uint32_t)0x00000400\t\t// \n"
  "#define SPI_MCR_SMPL_PT(n)\t\t(((n) & 3) << 8)\t\t//\n"
  "#define SPI_MCR_HALT\t\t\t(uint32_t)0x00000001\t\t// \n"
  "#define SPI0_TCR\t\t*(volatile uint32_t *)0x4002C008 // DSPI Transfer Count Register\n"
  "#define SPI0_CTAR0\t\t*(volatile uint32_t *)0x4002C00C // DSPI Clock and Transfer Attributes Register, In Master Mode\n"
  "#define SPI_CTAR_DBR\t\t\t(uint32_t)0x80000000\t\t// Double Baud Rate\n"
  "#define SPI_CTAR_FMSZ(n)\t\t(((n) & 15) << 27)\t\t// Frame Size (+1)\n"
  "#define SPI_CTAR_CPOL\t\t\t(uint32_t)0x04000000\t\t// Clock Polarity\n"
  "#define SPI_CTAR_CPHA\t\t\t(uint32_t)0x02000000\t\t// Clock Phase\n"
  "#define SPI_CTAR_LSBFE\t\t\t(uint32_t)0x01000000\t\t// LSB First\n"
  "#define SPI_CTAR_PCSSCK(n)\t\t(((n) & 3) << 22)\t\t// PCS to SCK Delay Prescaler\n"
  "#define SPI_CTAR_PASC(n)\t\t(((n) & 3) << 20)\t\t// After SCK Delay Prescaler\n"
  "#define SPI_CTAR_PDT(n)\t\t\t(((n) & 3) << 18)\t\t// Delay after Transfer Prescaler\n"
  "#define SPI_CTAR_PBR(n)\t\t\t(((n) & 3) << 16)\t\t// Baud Rate Prescaler\n"
  "#define SPI_CTAR_CSSCK(n)\t\t(((n) & 15) << 12)\t\t// PCS to SCK Delay Scaler\n"
  "#define SPI_CTAR_ASC(n)\t\t\t(((n) & 15) << 8)\t\t// After SCK Delay Scaler\n"
  "#define SPI_CTAR_DT(n)\t\t\t(((n) & 15) << 4)\t\t// Delay After Transfer Scaler\n"
  "#define SPI_CTAR_BR(n)\t\t\t(((n) & 15) << 0)\t\t// Baud Rate Scaler\n"
  "#define SPI0_CTAR0_SLAVE\t*(volatile uint32_t *)0x4002C00C // DSPI Clock and Transfer Attributes Register, In Slave Mode\n"
  "#define SPI0_CTAR1\t\t*(volatile uint32_t *)0x4002C010 // DSPI Clock and Transfer Attributes Register, In Master Mode\n"
  "#define SPI0_SR\t\t\t*(volatile uint32_t *)0x4002C02C // DSPI Status Register\n"
  "#define SPI_SR_TCF\t\t\t(uint32_t)0x80000000\t\t// Transfer Complete Flag\n"
  "#define SPI_SR_TXRXS\t\t\t(uint32_t)0x40000000\t\t// TX and RX Status\n"
  "#define SPI_SR_EOQF\t\t\t(uint32_t)0x10000000\t\t// End of Queue Flag\n"
  "#define SPI_SR_TFUF\t\t\t(uint32_t)0x08000000\t\t// Transmit FIFO Underflow Flag\n"
  "#define SPI_SR_TFFF\t\t\t(uint32_t)0x02000000\t\t// Transmit FIFO Fill Flag\n"
  "#define SPI_SR_RFOF\t\t\t(uint32_t)0x00080000\t\t// Receive FIFO Overflow Flag\n"
  "#define SPI_SR_RFDF\t\t\t(uint32_t)0x00020000\t\t// Receive FIFO Drain Flag\n"
  "#define SPI0_RSER\t\t*(volatile uint32_t *)0x4002C030 // DSPI DMA/Interrupt Request Select and Enable Register\n"
  "#define SPI_RSER_TCF_RE\t\t\t(uint32_t)0x80000000\t\t// Transmission Complete Request Enable\n"
  "#define SPI_RSER_EOQF_RE\t\t(uint32_t)0x10000000\t\t// DSPI Finished Request Request Enable\n"
  "#define SPI_RSER_TFUF_RE\t\t(uint32_t)0x08000000\t\t// Transmit FIFO Underflow Request Enable\n"
  "#define SPI_RSER_TFFF_RE\t\t(uint32_t)0x02000000\t\t// Transmit FIFO Fill Request Enable\n"
  "#define SPI_RSER_TFFF_DIRS\t\t(uint32_t)0x01000000\t\t// Transmit FIFO FIll Dma or Interrupt Request Select\n"
  "#define SPI_RSER_RFOF_RE\t\t(uint32_t)0x00080000\t\t// Receive FIFO Overflow Request Enable\n"
  "#define SPI_RSER_RFDF_RE\t\t(uint32_t)0x00020000\t\t// Receive FIFO Drain Request Enable\n"
  "#define SPI_RSER_RFDF_DIRS\t\t(uint32_t)0x00010000\t\t// Receive FIFO Drain DMA or Interrupt Request Select\n"
  "#define SPI0_PUSHR\t\t*(volatile uint32_t *)0x4002C034 // DSPI PUSH TX FIFO Register In Master Mode\n"
  "#define SPI_PUSHR_CONT\t\t\t(uint32_t)0x80000000\t\t// \n"
  "#define SPI_PUSHR_CTAS(n)\t\t(((n) & 7) << 28)\t\t// \n"
  "#define SPI_PUSHR_EOQ\t\t\t(uint32_t)0x08000000\t\t// \n"
  "#define SPI_PUSHR_CTCNT\t\t\t(uint32_t)0x04000000\t\t// \n"
  "#define SPI_PUSHR_PCS(n)\t\t(((n) & 31) << 16)\t\t//\n"
  "#define SPI0_PUSHR_SLAVE\t*(volatile uint32_t *)0x4002C034 // DSPI PUSH TX FIFO Register In Slave Mode\n"
  "#define SPI0_POPR\t\t*(volatile uint32_t *)0x4002C038 // DSPI POP RX FIFO Register\n"
  "#define SPI0_TXFR0\t\t*(volatile uint32_t *)0x4002C03C // DSPI Transmit FIFO Registers\n"
  "#define SPI0_TXFR1\t\t*(volatile uint32_t *)0x4002C040 // DSPI Transmit FIFO Registers\n"
  "#define SPI0_TXFR2\t\t*(volatile uint32_t *)0x4002C044 // DSPI Transmit FIFO Registers\n"
  "#define SPI0_TXFR3\t\t*(volatile uint32_t *)0x4002C048 // DSPI Transmit FIFO Registers\n"
  "#define SPI0_RXFR0\t\t*(volatile uint32_t *)0x4002C07C // DSPI Receive FIFO Registers\n"
  "#define SPI0_RXFR1\t\t*(volatile uint32_t *)0x4002C080 // DSPI Receive FIFO Registers\n"
  "#define SPI0_RXFR2\t\t*(volatile uint32_t *)0x4002C084 // DSPI Receive FIFO Registers\n"
  "#define SPI0_RXFR3\t\t*(volatile uint32_t *)0x4002C088 // DSPI Receive FIFO Registers\n"
  "typedef struct {\n"
  "\tvolatile uint32_t\tMCR;\t// 0\n"
  "\tvolatile uint32_t\tunused1;// 4\n"
  "\tvolatile uint32_t\tTCR;\t// 8\n"
  "\tvolatile uint32_t\tCTAR0;\t// c\n"
  "\tvolatile uint32_t\tCTAR1;\t// 10\n"
  "\tvolatile uint32_t\tCTAR2;\t// 14\n"
  "\tvolatile uint32_t\tCTAR3;\t// 18\n"
  "\tvolatile uint32_t\tCTAR4;\t// 1c\n"
  "\tvolatile uint32_t\tCTAR5;\t// 20\n"
  "\tvolatile uint32_t\tCTAR6;\t// 24\n"
  "\tvolatile uint32_t\tCTAR7;\t// 28\n"
  "\tvolatile uint32_t\tSR;\t// 2c\n"
  "\tvolatile uint32_t\tRSER;\t// 30\n"
  "\tvolatile uint32_t\tPUSHR;\t// 34\n"
  "\tvolatile uint32_t\tPOPR;\t// 38\n"
  "\tvolatile uint32_t\tTXFR[16]; // 3c\n"
  "\tvolatile uint32_t\tRXFR[16]; // 7c\n"
  "} SPI_t;\n"
  "#define SPI0\t\t(*(SPI_t *)0x4002C000)\n"
  "\n"
  "// Chapter 44: Inter-Integrated Circuit (I2C)\n"
  "#define I2C0_A1\t\t\t*(volatile uint8_t  *)0x40066000 // I2C Address Register 1\n"
  "#define I2C0_F\t\t\t*(volatile uint8_t  *)0x40066001 // I2C Frequency Divider register\n"
  "#define I2C0_C1\t\t\t*(volatile uint8_t  *)0x40066002 // I2C Control Register 1\n"
  "#define I2C_C1_IICEN\t\t\t(uint8_t)0x80\t\t\t// I2C Enable\n"
  "#define I2C_C1_IICIE\t\t\t(uint8_t)0x40\t\t\t// I2C Interrupt Enable\n"
  "#define I2C_C1_MST\t\t\t(uint8_t)0x20\t\t\t// Master Mode Select\n"
  "#define I2C_C1_TX\t\t\t(uint8_t)0x10\t\t\t// Transmit Mode Select\n"
  "#define I2C_C1_TXAK\t\t\t(uint8_t)0x08\t\t\t// Transmit Acknowledge Enable\n"
  "#define I2C_C1_RSTA\t\t\t(uint8_t)0x04\t\t\t// Repeat START\n"
  "#define I2C_C1_WUEN\t\t\t(uint8_t)0x02\t\t\t// Wakeup Enable\n"
  "#define I2C_C1_DMAEN\t\t\t(uint8_t)0x01\t\t\t// DMA Enable\n"
  "#define I2C0_S\t\t\t*(volatile uint8_t  *)0x40066003 // I2C Status register\n"
  "#define I2C_S_TCF\t\t\t(uint8_t)0x80\t\t\t// Transfer Complete Flag\n"
  "#define I2C_S_IAAS\t\t\t(uint8_t)0x40\t\t\t// Addressed As A Slave\n"
  "#define I2C_S_BUSY\t\t\t(uint8_t)0x20\t\t\t// Bus Busy\n"
  "#define I2C_S_ARBL\t\t\t(uint8_t)0x10\t\t\t// Arbitration Lost\n"
  "#define I2C_S_RAM\t\t\t(uint8_t)0x08\t\t\t// Range Address Match\n"
  "#define I2C_S_SRW\t\t\t(uint8_t)0x04\t\t\t// Slave Read/Write\n"
  "#define I2C_S_IICIF\t\t\t(uint8_t)0x02\t\t\t// Interrupt Flag\n"
  "#define I2C_S_RXAK\t\t\t(uint8_t)0x01\t\t\t// Receive Acknowledge\n"
  "#define I2C0_D\t\t\t*(volatile uint8_t  *)0x40066004 // I2C Data I/O register\n"
  "#define I2C0_C2\t\t\t*(volatile uint8_t  *)0x40066005 // I2C Control Register 2\n"
  "#define I2C_C2_GCAEN\t\t\t(uint8_t)0x80\t\t\t// General Call Address Enable\n"
  "#define I2C_C2_ADEXT\t\t\t(uint8_t)0x40\t\t\t// Address Extension\n"
  "#define I2C_C2_HDRS\t\t\t(uint8_t)0x20\t\t\t// High Drive Select\n"
  "#define I2C_C2_SBRC\t\t\t(uint8_t)0x10\t\t\t// Slave Baud Rate Control\n"
  "#define I2C_C2_RMEN\t\t\t(uint8_t)0x08\t\t\t// Range Address Matching Enable\n"
  "#define I2C_C2_AD(n)\t\t\t((n) & 7)\t\t\t// Slave Address, upper 3 bits\n"
  "#define I2C0_FLT\t\t*(volatile uint8_t  *)0x40066006 // I2C Programmable Input Glitch Filter register\n"
  "#define I2C0_RA\t\t\t*(volatile uint8_t  *)0x40066007 // I2C Range Address register\n"
  "#define I2C0_SMB\t\t*(volatile uint8_t  *)0x40066008 // I2C SMBus Control and Status register\n"
  "#define I2C0_A2\t\t\t*(volatile uint8_t  *)0x40066009 // I2C Address Register 2\n"
  "#define I2C0_SLTH\t\t*(volatile uint8_t  *)0x4006600A // I2C SCL Low Timeout Register High\n"
  "#define I2C0_SLTL\t\t*(volatile uint8_t  *)0x4006600B // I2C SCL Low Timeout Register Low\n"
  "\n"
  "#define I2C1_A1\t\t\t*(volatile uint8_t  *)0x40067000 // I2C Address Register 1\n"
  "#define I2C1_F\t\t\t*(volatile uint8_t  *)0x40067001 // I2C Frequency Divider register\n"
  "#define I2C1_C1\t\t\t*(volatile uint8_t  *)0x40067002 // I2C Control Register 1\n"
  "#define I2C1_S\t\t\t*(volatile uint8_t  *)0x40067003 // I2C Status register\n"
  "#define I2C1_D\t\t\t*(volatile uint8_t  *)0x40067004 // I2C Data I/O register\n"
  "#define I2C1_C2\t\t\t*(volatile uint8_t  *)0x40067005 // I2C Control Register 2\n"
  "#define I2C1_FLT\t\t*(volatile uint8_t  *)0x40067006 // I2C Programmable Input Glitch Filter register\n"
  "#define I2C1_RA\t\t\t*(volatile uint8_t  *)0x40067007 // I2C Range Address register\n"
  "#define I2C1_SMB\t\t*(volatile uint8_t  *)0x40067008 // I2C SMBus Control and Status register\n"
  "#define I2C1_A2\t\t\t*(volatile uint8_t  *)0x40067009 // I2C Address Register 2\n"
  "#define I2C1_SLTH\t\t*(volatile uint8_t  *)0x4006700A // I2C SCL Low Timeout Register High\n"
  "#define I2C1_SLTL\t\t*(volatile uint8_t  *)0x4006700B // I2C SCL Low Timeout Register Low\n"
  "\n"
  "// Chapter 45: Universal Asynchronous Receiver/Transmitter (UART)\n"
  "#define UART0_BDH\t\t*(volatile uint8_t  *)0x4006A000 // UART Baud Rate Registers: High\n"
  "#define UART0_BDL\t\t*(volatile uint8_t  *)0x4006A001 // UART Baud Rate Registers: Low\n"
  "#define UART0_C1\t\t*(volatile uint8_t  *)0x4006A002 // UART Control Register 1\n"
  "#define UART_C1_LOOPS\t\t\t(uint8_t)0x80\t\t\t// When LOOPS is set, the RxD pin is disconnected from the UART and the transmitter output is internally conne"
  "cted to the receiver input\n"
  "#define UART_C1_UARTSWAI\t\t(uint8_t)0x40\t\t\t// UART Stops in Wait Mode\n"
  "#define UART_C1_RSRC\t\t\t(uint8_t)0x20\t\t\t// When LOOPS is set, the RSRC field determines the source for the receiver shift register input\n"
  "#define UART_C1_M\t\t\t(uint8_t)0x10\t\t\t// 9-bit or 8-bit Mode Select\n"
  "#define UART_C1_WAKE\t\t\t(uint8_t)0x08\t\t\t// Determines which condition wakes the UART\n"
  "#define UART_C1_ILT\t\t\t(uint8_t)0x04\t\t\t// Idle Line Type Select\n"
  "#define UART_C1_PE\t\t\t(uint8_t)0x02\t\t\t// Parity Enable\n"
  "#define UART_C1_PT\t\t\t(uint8_t)0x01\t\t\t// Parity Type, 0=even, 1=odd\n"
  "#define UART0_C2\t\t*(volatile uint8_t  *)0x4006A003 // UART Control Register 2\n"
  "#define UART_C2_TIE\t\t\t(uint8_t)0x80\t\t\t// Transmitter Interrupt or DMA Transfer Enable.\n"
  "#define UART_C2_TCIE\t\t\t(uint8_t)0x40\t\t\t// Transmission Complete Interrupt Enable\n"
  "#define UART_C2_RIE\t\t\t(uint8_t)0x20\t\t\t// Receiver Full Interrupt or DMA Transfer Enable\n"
  "#define UART_C2_ILIE\t\t\t(uint8_t)0x10\t\t\t// Idle Line Interrupt Enable\n"
  "#define UART_C2_TE\t\t\t(uint8_t)0x08\t\t\t// Transmitter Enable\n"
  "#define UART_C2_RE\t\t\t(uint8_t)0x04\t\t\t// Receiver Enable\n"
  "#define UART_C2_RWU\t\t\t(uint8_t)0x02\t\t\t// Receiver Wakeup Control\n"
  "#define UART_C2_SBK\t\t\t(uint8_t)0x01\t\t\t// Send Break\n"
  "#define UART0_S1\t\t*(volatile uint8_t  *)0x4006A004 // UART Status Register 1\n"
  "#define UART_S1_TDRE\t\t\t(uint8_t)0x80\t\t\t// Transmit Data Register Empty Flag\n"
  "#define UART_S1_TC\t\t\t(uint8_t)0x40\t\t\t// Transmit Complete Flag\n"
  "#define UART_S1_RDRF\t\t\t(uint8_t)0x20\t\t\t// Receive Data Register Full Flag\n"
  "#define UART_S1_IDLE\t\t\t(uint8_t)0x10\t\t\t// Idle Line Flag\n"
  "#define UART_S1_OR\t\t\t(uint8_t)0x08\t\t\t// Receiver Overrun Flag\n"
  "#define UART_S1_NF\t\t\t(uint8_t)0x04\t\t\t// Noise Flag\n"
  "#define UART_S1_FE\t\t\t(uint8_t)0x02\t\t\t// Framing Error Flag\n"
  "#define UART_S1_PF\t\t\t(uint8_t)0x01\t\t\t// Parity Error Flag\n"
  "#define UART0_S2\t\t*(volatile uint8_t  *)0x4006A005 // UART Status Register 2\n"
  "#define UART0_C3\t\t*(volatile uint8_t  *)0x4006A006 // UART Control Register 3\n"
  "#define UART0_D\t\t\t*(volatile uint8_t  *)0x4006A007 // UART Data Register\n"
  "#define UART0_MA1\t\t*(volatile uint8_t  *)0x4006A008 // UART Match Address Registers 1\n"
  "#define UART0_MA2\t\t*(volatile uint8_t  *)0x4006A009 // UART Match Address Registers 2\n"
  "#define UART0_C4\t\t*(volatile uint8_t  *)0x4006A00A // UART Control Register 4\n"
  "#define UART0_C5\t\t*(volatile uint8_t  *)0x4006A00B // UART Control Register 5\n"
  "#define UART0_ED\t\t*(volatile uint8_t  *)0x4006A00C // UART Extended Data Register\n"
  "#define UART0_MODEM\t\t*(volatile uint8_t  *)0x4006A00D // UART Modem Register\n"
  "#define UART0_IR\t\t*(volatile uint8_t  *)0x4006A00E // UART Infrared Register\n"
  "#define UART0_PFIFO\t\t*(volatile uint8_t  *)0x4006A010 // UART FIFO Parameters\n"
  "#define UART_PFIFO_TXFE\t\t\t(uint8_t)0x80\n"
  "#define UART_PFIFO_RXFE\t\t\t(uint8_t)0x08\n"
  "#define UART0_CFIFO\t\t*(volatile uint8_t  *)0x4006A011 // UART FIFO Control Register\n"
  "#define UART_CFIFO_TXFLUSH\t\t(uint8_t)0x80\t\t\t// \n"
  "#define UART_CFIFO_RXFLUSH\t\t(uint8_t)0x40\t\t\t// \n"
  "#define UART_CFIFO_RXOFE\t\t(uint8_t)0x04\t\t\t// \n"
  "#define UART_CFIFO_TXOFE\t\t(uint8_t)0x02\t\t\t// \n"
  "#define UART_CFIFO_RXUFE\t\t(uint8_t)0x01\t\t\t// \n"
  "#define UART0_SFIFO\t\t*(volatile uint8_t  *)0x4006A012 // UART FIFO Status Register\n"
  "#define UART_SFIFO_TXEMPT\t\t(uint8_t)0x80\n"
  "#define UART_SFIFO_RXEMPT\t\t(uint8_t)0x40\n"
  "#define UART_SFIFO_RXOF\t\t\t(uint8_t)0x04\n"
  "#define UART_SFIFO_TXOF\t\t\t(uint8_t)0x02\n"
  "#define UART_SFIFO_RXUF\t\t\t(uint8_t)0x01\n"
  "#define UART0_TWFIFO\t\t*(volatile uint8_t  *)0x4006A013 // UART FIFO Transmit Watermark\n"
  "#define UART0_TCFIFO\t\t*(volatile uint8_t  *)0x4006A014 // UART FIFO Transmit Count\n"
  "#define UART0_RWFIFO\t\t*(volatile uint8_t  *)0x4006A015 // UART FIFO Receive Watermark\n"
  "#define UART0_RCFIFO\t\t*(volatile uint8_t  *)0x4006A016 // UART FIFO Receive Count\n"
  "#define UART0_C7816\t\t*(volatile uint8_t  *)0x4006A018 // UART 7816 Control Register\n"
  "#define UART0_IE7816\t\t*(volatile uint8_t  *)0x4006A019 // UART 7816 Interrupt Enable Register\n"
  "#define UART0_IS7816\t\t*(volatile uint8_t  *)0x4006A01A // UART 7816 Interrupt Status Register\n"
  "#define UART0_WP7816T0\t\t*(volatile uint8_t  *)0x4006A01B // UART 7816 Wait Parameter Register\n"
  "#define UART0_WP7816T1\t\t*(volatile uint8_t  *)0x4006A01B // UART 7816 Wait Parameter Register\n"
  "#define UART0_WN7816\t\t*(volatile uint8_t  *)0x4006A01C // UART 7816 Wait N Register\n"
  "#define UART0_WF7816\t\t*(volatile uint8_t  *)0x4006A01D // UART 7816 Wait FD Register\n"
  "#define UART0_ET7816\t\t*(volatile uint8_t  *)0x4006A01E // UART 7816 Error Threshold Register\n"
  "#define UART0_TL7816\t\t*(volatile uint8_t  *)0x4006A01F // UART 7816 Transmit Length Register\n"
  "#define UART0_C6\t\t*(volatile uint8_t  *)0x4006A021 // UART CEA709.1-B Control Register 6\n"
  "#define UART0_PCTH\t\t*(volatile uint8_t  *)0x4006A022 // UART CEA709.1-B Packet Cycle Time Counter High\n"
  "#define UART0_PCTL\t\t*(volatile uint8_t  *)0x4006A023 // UART CEA709.1-B Packet Cycle Time Counter Low\n"
  "#define UART0_B1T\t\t*(volatile uint8_t  *)0x4006A024 // UART CEA709.1-B Beta1 Timer\n"
  "#define UART0_SDTH\t\t*(volatile uint8_t  *)0x4006A025 // UART CEA709.1-B Secondary Delay Timer High\n"
  "#define UART0_SDTL\t\t*(volatile uint8_t  *)0x4006A026 // UART CEA709.1-B Secondary Delay Timer Low\n"
  "#define UART0_PRE\t\t*(volatile uint8_t  *)0x4006A027 // UART CEA709.1-B Preamble\n"
  "#define UART0_TPL\t\t*(volatile uint8_t  *)0x4006A028 // UART CEA709.1-B Transmit Packet Length\n"
  "#define UART0_IE\t\t*(volatile uint8_t  *)0x4006A029 // UART CEA709.1-B Interrupt Enable Register\n"
  "#define UART0_WB\t\t*(volatile uint8_t  *)0x4006A02A // UART CEA709.1-B WBASE\n"
  "#define UART0_S3\t\t*(volatile uint8_t  *)0x4006A02B // UART CEA709.1-B Status Register\n"
  "#define UART0_S4\t\t*(volatile uint8_t  *)0x4006A02C // UART CEA709.1-B Status Register\n"
  "#define UART0_RPL\t\t*(volatile uint8_t  *)0x4006A02D // UART CEA709.1-B Received Packet Length\n"
  "#define UART0_RPREL\t\t*(volatile uint8_t  *)0x4006A02E // UART CEA709.1-B Received Preamble Length\n"
  "#define UART0_CPW\t\t*(volatile uint8_t  *)0x4006A02F // UART CEA709.1-B Collision Pulse Width\n"
  "#define UART0_RIDT\t\t*(volatile uint8_t  *)0x4006A030 // UART CEA709.1-B Receive Indeterminate Time\n"
  "#define UART0_TIDT\t\t*(volatile uint8_t  *)0x4006A031 // UART CEA709.1-B Transmit Indeterminate Time\n"
  "#define UART1_BDH\t\t*(volatile uint8_t  *)0x4006B000 // UART Baud Rate Registers: High\n"
  "#define UART1_BDL\t\t*(volatile uint8_t  *)0x4006B001 // UART Baud Rate Registers: Low\n"
  "#define UART1_C1\t\t*(volatile uint8_t  *)0x4006B002 // UART Control Register 1\n"
  "#define UART1_C2\t\t*(volatile uint8_t  *)0x4006B003 // UART Control Register 2\n"
  "#define UART1_S1\t\t*(volatile uint8_t  *)0x4006B004 // UART Status Register 1\n"
  "#define UART1_S2\t\t*(volatile uint8_t  *)0x4006B005 // UART Status Register 2\n"
  "#define UART1_C3\t\t*(volatile uint8_t  *)0x4006B006 // UART Control Register 3\n"
  "#define UART1_D\t\t\t*(volatile uint8_t  *)0x4006B007 // UART Data Register\n"
  "#define UART1_MA1\t\t*(volatile uint8_t  *)0x4006B008 // UART Match Address Registers 1\n"
  "#define UART1_MA2\t\t*(volatile uint8_t  *)0x4006B009 // UART Match Address Registers 2\n"
  "#define UART1_C4\t\t*(volatile uint8_t  *)0x4006B00A // UART Control Register 4\n"
  "#define UART1_C5\t\t*(volatile uint8_t  *)0x4006B00B // UART Control Register 5\n"
  "#define UART1_ED\t\t*(volatile uint8_t  *)0x4006B00C // UART Extended Data Register\n"
  "#define UART1_MODEM\t\t*(volatile uint8_t  *)0x4006B00D // UART Modem Register\n"
  "#define UART1_IR\t\t*(volatile uint8_t  *)0x4006B00E // UART Infrared Register\n"
  "#define UART1_PFIFO\t\t*(volatile uint8_t  *)0x4006B010 // UART FIFO Parameters\n"
  "#define UART1_CFIFO\t\t*(volatile uint8_t  *)0x4006B011 // UART FIFO Control Register\n"
  "#define UART1_SFIFO\t\t*(volatile uint8_t  *)0x4006B012 // UART FIFO Status Register\n"
  "#define UART1_TWFIFO\t\t*(volatile uint8_t  *)0x4006B013 // UART FIFO Transmit Watermark\n"
  "#define UART1_TCFIFO\t\t*(volatile uint8_t  *)0x4006B014 // UART FIFO Transmit Count\n"
  "#define UART1_RWFIFO\t\t*(volatile uint8_t  *)0x4006B015 // UART FIFO Receive Watermark\n"
  "#define UART1_RCFIFO\t\t*(volatile uint8_t  *)0x4006B016 // UART FIFO Receive Count\n"
  "#define UART1_C7816\t\t*(volatile uint8_t  *)0x4006B018 // UART 7816 Control Register\n"
  "#define UART1_IE7816\t\t*(volatile uint8_t  *)0x4006B019 // UART 7816 Interrupt Enable Register\n"
  "#define UART1_IS7816\t\t*(volatile uint8_t  *)0x4006B01A // UART 7816 Interrupt Status Register\n"
  "#define UART1_WP7816T0\t\t*(volatile uint8_t  *)0x4006B01B // UART 7816 Wait Parameter Register\n"
  "#define UART1_WP7816T1\t\t*(volatile uint8_t  *)0x4006B01B // UART 7816 Wait Parameter Register\n"
  "#define UART1_WN7816\t\t*(volatile uint8_t  *)0x4006B01C // UART 7816 Wait N Register\n"
  "#define UART1_WF7816\t\t*(volatile uint8_t  *)0x4006B01D // UART 7816 Wait FD Register\n"
  "#define UART1_ET7816\t\t*(volatile uint8_t  *)0x4006B01E // UART 7816 Error Threshold Register\n"
  "#define UART1_TL7816\t\t*(volatile uint8_t  *)0x4006B01F // UART 7816 Transmit Length Register\n"
  "#define UART1_C6\t\t*(volatile uint8_t  *)0x4006B021 // UART CEA709.1-B Control Register 6\n"
  "#define UART1_PCTH\t\t*(volatile uint8_t  *)0x4006B022 // UART CEA709.1-B Packet Cycle Time Counter High\n"
  "#define UART1_PCTL\t\t*(volatile uint8_t  *)0x4006B023 // UART CEA709.1-B Packet Cycle Time Counter Low\n"
  "#define UART1_B1T\t\t*(volatile uint8_t  *)0x4006B024 // UART CEA709.1-B Beta1 Timer\n"
  "#define UART1_SDTH\t\t*(volatile uint8_t  *)0x4006B025 // UART CEA709.1-B Secondary Delay Timer High\n"
  "#define UART1_SDTL\t\t*(volatile uint8_t  *)0x4006B026 // UART CEA709.1-B Secondary Delay Timer Low\n"
  "#define UART1_PRE\t\t*(volatile uint8_t  *)0x4006B027 // UART CEA709.1-B Preamble\n"
  "#define UART1_TPL\t\t*(volatile uint8_t  *)0x4006B028 // UART CEA709.1-B Transmit Packet Length\n"
  "#define UART1_IE\t\t*(volatile uint8_t  *)0x4006B029 // UART CEA709.1-B Interrupt Enable Register\n"
  "#define UART1_WB\t\t*(volatile uint8_t  *)0x4006B02A // UART CEA709.1-B WBASE\n"
  "#define UART1_S3\t\t*(volatile uint8_t  *)0x4006B02B // UART CEA709.1-B Status Register\n"
  "#define UART1_S4\t\t*(volatile uint8_t  *)0x4006B02C // UART CEA709.1-B Status Register\n"
  "#define UART1_RPL\t\t*(volatile uint8_t  *)0x4006B02D // UART CEA709.1-B Received Packet Length\n"
  "#define UART1_RPREL\t\t*(volatile uint8_t  *)0x4006B02E // UART CEA709.1-B Received Preamble Length\n"
  "#define UART1_CPW\t\t*(volatile uint8_t  *)0x4006B02F // UART CEA709.1-B Collision Pulse Width\n"
  "#define UART1_RIDT\t\t*(volatile uint8_t  *)0x4006B030 // UART CEA709.1-B Receive Indeterminate Time\n"
  "#define UART1_TIDT\t\t*(volatile uint8_t  *)0x4006B031 // UART CEA709.1-B Transmit Indeterminate Time\n"
  "#define UART2_BDH\t\t*(volatile uint8_t  *)0x4006C000 // UART Baud Rate Registers: High\n"
  "#define UART2_BDL\t\t*(volatile uint8_t  *)0x4006C001 // UART Baud Rate Registers: Low\n"
  "#define UART2_C1\t\t*(volatile uint8_t  *)0x4006C002 // UART Control Register 1\n"
  "#define UART2_C2\t\t*(volatile uint8_t  *)0x4006C003 // UART Control Register 2\n"
  "#define UART2_S1\t\t*(volatile uint8_t  *)0x4006C004 // UART Status Register 1\n"
  "#define UART2_S2\t\t*(volatile uint8_t  *)0x4006C005 // UART Status Register 2\n"
  "#define UART2_C3\t\t*(volatile uint8_t  *)0x4006C006 // UART Control Register 3\n"
  "#define UART2_D\t\t\t*(volatile uint8_t  *)0x4006C007 // UART Data Register\n"
  "#define UART2_MA1\t\t*(volatile uint8_t  *)0x4006C008 // UART Match Address Registers 1\n"
  "#define UART2_MA2\t\t*(volatile uint8_t  *)0x4006C009 // UART Match Address Registers 2\n"
  "#define UART2_C4\t\t*(volatile uint8_t  *)0x4006C00A // UART Control Register 4\n"
  "#define UART2_C5\t\t*(volatile uint8_t  *)0x4006C00B // UART Control Register 5\n"
  "#define UART2_ED\t\t*(volatile uint8_t  *)0x4006C00C // UART Extended Data Register\n"
  "#define UART2_MODEM\t\t*(volatile uint8_t  *)0x4006C00D // UART Modem Register\n"
  "#define UART2_IR\t\t*(volatile uint8_t  *)0x4006C00E // UART Infrared Register\n"
  "#define UART2_PFIFO\t\t*(volatile uint8_t  *)0x4006C010 // UART FIFO Parameters\n"
  "#define UART2_CFIFO\t\t*(volatile uint8_t  *)0x4006C011 // UART FIFO Control Register\n"
  "#define UART2_SFIFO\t\t*(volatile uint8_t  *)0x4006C012 // UART FIFO Status Register\n"
  "#define UART2_TWFIFO\t\t*(volatile uint8_t  *)0x4006C013 // UART FIFO Transmit Watermark\n"
  "#define UART2_TCFIFO\t\t*(volatile uint8_t  *)0x4006C014 // UART FIFO Transmit Count\n"
  "#define UART2_RWFIFO\t\t*(volatile uint8_t  *)0x4006C015 // UART FIFO Receive Watermark\n"
  "#define UART2_RCFIFO\t\t*(volatile uint8_t  *)0x4006C016 // UART FIFO Receive Count\n"
  "#define UART2_C7816\t\t*(volatile uint8_t  *)0x4006C018 // UART 7816 Control Register\n"
  "#define UART2_IE7816\t\t*(volatile uint8_t  *)0x4006C019 // UART 7816 Interrupt Enable Register\n"
  "#define UART2_IS7816\t\t*(volatile uint8_t  *)0x4006C01A // UART 7816 Interrupt Status Register\n"
  "#define UART2_WP7816T0\t\t*(volatile uint8_t  *)0x4006C01B // UART 7816 Wait Parameter Register\n"
  "#define UART2_WP7816T1\t\t*(volatile uint8_t  *)0x4006C01B // UART 7816 Wait Parameter Register\n"
  "#define UART2_WN7816\t\t*(volatile uint8_t  *)0x4006C01C // UART 7816 Wait N Register\n"
  "#define UART2_WF7816\t\t*(volatile uint8_t  *)0x4006C01D // UART 7816 Wait FD Register\n"
  "#define UART2_ET7816\t\t*(volatile uint8_t  *)0x4006C01E // UART 7816 Error Threshold Register\n"
  "#define UART2_TL7816\t\t*(volatile uint8_t  *)0x4006C01F // UART 7816 Transmit Length Register\n"
  "#define UART2_C6\t\t*(volatile uint8_t  *)0x4006C021 // UART CEA709.1-B Control Register 6\n"
  "#define UART2_PCTH\t\t*(volatile uint8_t  *)0x4006C022 // UART CEA709.1-B Packet Cycle Time Counter High\n"
  "#define UART2_PCTL\t\t*(volatile uint8_t  *)0x4006C023 // UART CEA709.1-B Packet Cycle Time Counter Low\n"
  "#define UART2_B1T\t\t*(volatile uint8_t  *)0x4006C024 // UART CEA709.1-B Beta1 Timer\n"
  "#define UART2_SDTH\t\t*(volatile uint8_t  *)0x4006C025 // UART CEA709.1-B Secondary Delay Timer High\n"
  "#define UART2_SDTL\t\t*(volatile uint8_t  *)0x4006C026 // UART CEA709.1-B Secondary Delay Timer Low\n"
  "#define UART2_PRE\t\t*(volatile uint8_t  *)0x4006C027 // UART CEA709.1-B Preamble\n"
  "#define UART2_TPL\t\t*(volatile uint8_t  *)0x4006C028 // UART CEA709.1-B Transmit Packet Length\n"
  "#define UART2_IE\t\t*(volatile uint8_t  *)0x4006C029 // UART CEA709.1-B Interrupt Enable Register\n"
  "#define UART2_WB\t\t*(volatile uint8_t  *)0x4006C02A // UART CEA709.1-B WBASE\n"
  "#define UART2_S3\t\t*(volatile uint8_t  *)0x4006C02B // UART CEA709.1-B Status Register\n"
  "#define UART2_S4\t\t*(volatile uint8_t  *)0x4006C02C // UART CEA709.1-B Status Register\n"
  "#define UART2_RPL\t\t*(volatile uint8_t  *)0x4006C02D // UART CEA709.1-B Received Packet Length\n"
  "#define UART2_RPREL\t\t*(volatile uint8_t  *)0x4006C02E // UART CEA709.1-B Received Preamble Length\n"
  "#define UART2_CPW\t\t*(volatile uint8_t  *)0x4006C02F // UART CEA709.1-B Collision Pulse Width\n"
  "#define UART2_RIDT\t\t*(volatile uint8_t  *)0x4006C030 // UART CEA709.1-B Receive Indeterminate Time\n"
  "#define UART2_TIDT\t\t*(volatile uint8_t  *)0x4006C031 // UART CEA709.1-B Transmit Indeterminate Time\n"
  "\n"
  "// Chapter 46: Synchronous Audio Interface (SAI)\n"
  "#define I2S0_TCSR\t\t*(volatile uint32_t *)0x4002F000 // SAI Transmit Control Register\n"
  "#define I2S_TCSR_TE\t\t\t(uint32_t)0x80000000\t// Transmitter Enable\n"
  "#define I2S_TCSR_STOPE\t\t\t(uint32_t)0x40000000\t// Transmitter Enable in Stop mode\n"
  "#define I2S_TCSR_DBGE\t\t\t(uint32_t)0x20000000\t// Transmitter Enable in Debug mode\n"
  "#define I2S_TCSR_BCE\t\t\t(uint32_t)0x10000000\t// Bit Clock Enable\n"
  "#define I2S_TCSR_FR\t\t\t(uint32_t)0x02000000\t// FIFO Reset\n"
  "#define I2S_TCSR_SR\t\t\t(uint32_t)0x01000000\t// Software Reset\n"
  "#define I2S_TCSR_WSF\t\t\t(uint32_t)0x00100000\t// Word Start Flag\n"
  "#define I2S_TCSR_SEF\t\t\t(uint32_t)0x00080000\t// Sync Error Flag\n"
  "#define I2S_TCSR_FEF\t\t\t(uint32_t)0x00040000\t// FIFO Error Flag (underrun)\n"
  "#define I2S_TCSR_FWF\t\t\t(uint32_t)0x00020000\t// FIFO Warning Flag (empty)\n"
  "#define I2S_TCSR_FRF\t\t\t(uint32_t)0x00010000\t// FIFO Request Flag (Data Ready)\n"
  "#define I2S_TCSR_WSIE\t\t\t(uint32_t)0x00001000\t// Word Start Interrupt Enable\n"
  "#define I2S_TCSR_SEIE\t\t\t(uint32_t)0x00000800\t// Sync Error Interrupt Enable\n"
  "#define I2S_TCSR_FEIE\t\t\t(uint32_t)0x00000400\t// FIFO Error Interrupt Enable\n"
  "#define I2S_TCSR_FWIE\t\t\t(uint32_t)0x00000200\t// FIFO Warning Interrupt Enable\n"
  "#define I2S_TCSR_FRIE\t\t\t(uint32_t)0x00000100\t// FIFO Request Interrupt Enable\n"
  "#define I2S_TCSR_FWDE\t\t\t(uint32_t)0x00000002\t// FIFO Warning DMA Enable\n"
  "#define I2S_TCSR_FRDE\t\t\t(uint32_t)0x00000001\t// FIFO Request DMA Enable\n"
  "#define I2S0_TCR1\t\t*(volatile uint32_t *)0x4002F004 // SAI Transmit Configuration 1 Register\n"
  "#define I2S_TCR1_TFW(n)\t\t\t((uint32_t)n & 0x03)\t      // Transmit FIFO watermark\n"
  "#define I2S0_TCR2\t\t*(volatile uint32_t *)0x4002F008 // SAI Transmit Configuration 2 Register\n"
  "#define I2S_TCR2_DIV(n)\t\t\t((uint32_t)n & 0xff)\t      // Bit clock divide by (DIV+1)*2\n"
  "#define I2S_TCR2_BCD\t\t\t((uint32_t)1<<24)\t      // Bit clock direction\n"
  "#define I2S_TCR2_BCP\t\t\t((uint32_t)1<<25)\t      // Bit clock polarity\n"
  "#define I2S_TCR2_MSEL(n)\t\t((uint32_t)(n & 3)<<26)\t      // MCLK select, 0=bus clock, 1=I2S0_MCLK\n"
  "#define I2S_TCR2_BCI\t\t\t((uint32_t)1<<28)\t      // Bit clock input\n"
  "#define I2S_TCR2_BCS\t\t\t((uint32_t)1<<29)\t      // Bit clock swap\n"
  "#define I2S_TCR2_SYNC(n)\t\t((uint32_t)(n & 3)<<30)\t      // 0=async 1=sync with receiver\n"
  "#define I2S0_TCR3\t\t*(volatile uint32_t *)0x4002F00C // SAI Transmit Configuration 3 Register\n"
  "#define I2S_TCR3_WDFL(n)\t\t((uint32_t)n & 0x0f)\t      // word flag configuration\n"
  "#define I2S_TCR3_TCE\t\t\t((uint32_t)0x10000)\t      // transmit channel enable\n"
  "#define I2S0_TCR4\t\t*(volatile uint32_t *)0x4002F010 // SAI Transmit Configuration 4 Register\n"
  "#define I2S_TCR4_FSD\t\t\t((uint32_t)1)\t\t      // Frame Sync Direction\n"
  "#define I2S_TCR4_FSP\t\t\t((uint32_t)2)\t\t      // Frame Sync Polarity\n"
  "#define I2S_TCR4_FSE\t\t\t((uint32_t)8)\t\t      // Frame Sync Early\n"
  "#define I2S_TCR4_MF\t\t\t((uint32_t)0x10)\t      // MSB First\n"
  "#define I2S_TCR4_SYWD(n)\t\t((uint32_t)(n & 0x1f)<<8)     // Sync Width\n"
  "#define I2S_TCR4_FRSZ(n)\t\t((uint32_t)(n & 0x0f)<<16)    // Frame Size\n"
  "#define I2S0_TCR5\t\t*(volatile uint32_t *)0x4002F014 // SAI Transmit Configuration 5 Register\n"
  "#define I2S_TCR5_FBT(n)\t\t\t((uint32_t)(n & 0x1f)<<8)     // First Bit Shifted\n"
  "#define I2S_TCR5_W0W(n)\t\t\t((uint32_t)(n & 0x1f)<<16)    // Word 0 Width\n"
  "#define I2S_TCR5_WNW(n)\t\t\t((uint32_t)(n & 0x1f)<<24)    // Word N Width\n"
  "#define I2S0_TDR0\t\t*(volatile uint32_t *)0x4002F020 // SAI Transmit Data Register\n"
  "#define I2S0_TDR1\t\t*(volatile uint32_t *)0x4002F024 // SAI Transmit Data Register\n"
  "#define I2S0_TFR0\t\t*(volatile uint32_t *)0x4002F040 // SAI Transmit FIFO Register\n"
  "#define I2S0_TFR1\t\t*(volatile uint32_t *)0x4002F044 // SAI Transmit FIFO Register\n"
  "#define I2S_TFR_RFP(n)\t\t\t((uint32_t)n & 7)\t      // read FIFO pointer\n"
  "#define I2S_TFR_WFP(n)\t\t\t((uint32_t)(n & 7)<<16)\t      // write FIFO pointer\n"
  "#define I2S0_TMR\t\t*(volatile uint32_t *)0x4002F060 // SAI Transmit Mask Register\n"
  "#define I2S_TMR_TWM(n)\t\t\t((uint32_t)n & 0xFFFFFFFF)\n"
  "#define I2S0_RCSR\t\t*(volatile uint32_t *)0x4002F080 // SAI Receive Control Register\n"
  "#define I2S_RCSR_RE\t\t\t(uint32_t)0x80000000\t// Receiver Enable\n"
  "#define I2S_RCSR_STOPE\t\t\t(uint32_t)0x40000000\t// Receiver Enable in Stop mode\n"
  "#define I2S_RCSR_DBGE\t\t\t(uint32_t)0x20000000\t// Receiver Enable in Debug mode\n"
  "#define I2S_RCSR_BCE\t\t\t(uint32_t)0x10000000\t// Bit Clock Enable\n"
  "#define I2S_RCSR_FR\t\t\t(uint32_t)0x02000000\t// FIFO Reset\n"
  "#define I2S_RCSR_SR\t\t\t(uint32_t)0x01000000\t// Software Reset\n"
  "#define I2S_RCSR_WSF\t\t\t(uint32_t)0x00100000\t// Word Start Flag\n"
  "#define I2S_RCSR_SEF\t\t\t(uint32_t)0x00080000\t// Sync Error Flag\n"
  "#define I2S_RCSR_FEF\t\t\t(uint32_t)0x00040000\t// FIFO Error Flag (underrun)\n"
  "#define I2S_RCSR_FWF\t\t\t(uint32_t)0x00020000\t// FIFO Warning Flag (empty)\n"
  "#define I2S_RCSR_FRF\t\t\t(uint32_t)0x00010000\t// FIFO Request Flag (Data Ready)\n"
  "#define I2S_RCSR_WSIE\t\t\t(uint32_t)0x00001000\t// Word Start Interrupt Enable\n"
  "#define I2S_RCSR_SEIE\t\t\t(uint32_t)0x00000800\t// Sync Error Interrupt Enable\n"
  "#define I2S_RCSR_FEIE\t\t\t(uint32_t)0x00000400\t// FIFO Error Interrupt Enable\n"
  "#define I2S_RCSR_FWIE\t\t\t(uint32_t)0x00000200\t// FIFO Warning Interrupt Enable\n"
  "#define I2S_RCSR_FRIE\t\t\t(uint32_t)0x00000100\t// FIFO Request Interrupt Enable\n"
  "#define I2S_RCSR_FWDE\t\t\t(uint32_t)0x00000002\t// FIFO Warning DMA Enable\n"
  "#define I2S_RCSR_FRDE\t\t\t(uint32_t)0x00000001\t// FIFO Request DMA Enable\n"
  "#define I2S0_RCR1\t\t*(volatile uint32_t *)0x4002F084 // SAI Receive Configuration 1 Register\n"
  "#define I2S_RCR1_RFW(n)\t\t\t((uint32_t)n & 0x03)\t      // Receive FIFO watermark\n"
  "#define I2S0_RCR2\t\t*(volatile uint32_t *)0x4002F088 // SAI Receive Configuration 2 Register\n"
  "#define I2S_RCR2_DIV(n)\t\t\t((uint32_t)n & 0xff)\t      // Bit clock divide by (DIV+1)*2\n"
  "#define I2S_RCR2_BCD\t\t\t((uint32_t)1<<24)\t      // Bit clock direction\n"
  "#define I2S_RCR2_BCP\t\t\t((uint32_t)1<<25)\t      // Bit clock polarity\n"
  "#define I2S_RCR2_MSEL(n)\t\t((uint32_t)(n & 3)<<26)\t      // MCLK select, 0=bus clock, 1=I2S0_MCLK\n"
  "#define I2S_RCR2_BCI\t\t\t((uint32_t)1<<28)\t      // Bit clock input\n"
  "#define I2S_RCR2_BCS\t\t\t((uint32_t)1<<29)\t      // Bit clock swap\n"
  "#define I2S_RCR2_SYNC(n)\t\t((uint32_t)(n & 3)<<30)\t      // 0=async 1=sync with receiver\n"
  "#define I2S0_RCR3\t\t*(volatile uint32_t *)0x4002F08C // SAI Receive Configuration 3 Register\n"
  "#define I2S_RCR3_WDFL(n)\t\t((uint32_t)n & 0x0f)\t      // word flag configuration\n"
  "#define I2S_RCR3_RCE\t\t\t((uint32_t)0x10000)\t      // receive channel enable\n"
  "#define I2S0_RCR4\t\t*(volatile uint32_t *)0x4002F090 // SAI Receive Configuration 4 Register\n"
  "#define I2S_RCR4_FSD\t\t\t((uint32_t)1)\t\t      // Frame Sync Direction\n"
  "#define I2S_RCR4_FSP\t\t\t((uint32_t)2)\t\t      // Frame Sync Polarity\n"
  "#define I2S_RCR4_FSE\t\t\t((uint32_t)8)\t\t      // Frame Sync Early\n"
  "#define I2S_RCR4_MF\t\t\t((uint32_t)0x10)\t      // MSB First\n"
  "#define I2S_RCR4_SYWD(n)\t\t((uint32_t)(n & 0x1f)<<8)     // Sync Width\n"
  "#define I2S_RCR4_FRSZ(n)\t\t((uint32_t)(n & 0x0f)<<16)    // Frame Size\n"
  "#define I2S0_RCR5\t\t*(volatile uint32_t *)0x4002F094 // SAI Receive Configuration 5 Register\n"
  "#define I2S_RCR5_FBT(n)\t\t\t((uint32_t)(n & 0x1f)<<8)     // First Bit Shifted\n"
  "#define I2S_RCR5_W0W(n)\t\t\t((uint32_t)(n & 0x1f)<<16)    // Word 0 Width\n"
  "#define I2S_RCR5_WNW(n)\t\t\t((uint32_t)(n & 0x1f)<<24)    // Word N Width\n"
  "#define I2S0_RDR0\t\t*(volatile uint32_t *)0x4002F0A0 // SAI Receive Data Register\n"
  "#define I2S0_RDR1\t\t*(volatile uint32_t *)0x4002F0A4 // SAI Receive Data Register\n"
  "#define I2S0_RFR0\t\t*(volatile uint32_t *)0x4002F0C0 // SAI Receive FIFO Register\n"
  "#define I2S0_RFR1\t\t*(volatile uint32_t *)0x4002F0C4 // SAI Receive FIFO Register\n"
  "#define I2S_RFR_RFP(n)\t\t\t((uint32_t)n & 7)\t      // read FIFO pointer\n"
  "#define I2S_RFR_WFP(n)\t\t\t((uint32_t)(n & 7)<<16)\t      // write FIFO pointer\n"
  "#define I2S0_RMR\t\t*(volatile uint32_t *)0x4002F0E0 // SAI Receive Mask Register\n"
  "#define I2S_RMR_RWM(n)\t\t\t((uint32_t)n & 0xFFFFFFFF)\n"
  "#define I2S0_MCR\t\t*(volatile uint32_t *)0x4002F100 // SAI MCLK Control Register\n"
  "#define I2S_MCR_DUF\t\t\t((uint32_t)1<<31)\t      // Divider Update Flag\n"
  "#define I2S_MCR_MOE\t\t\t((uint32_t)1<<30)\t      // MCLK Output Enable\n"
  "#define I2S_MCR_MICS(n)\t\t\t((uint32_t)(n & 3)<<24)\t      // MCLK Input Clock Select\n"
  "#define I2S0_MDR\t\t*(volatile uint32_t *)0x4002F104 // SAI MCLK Divide Register\n"
  "#define I2S_MDR_FRACT(n)\t\t((uint32_t)(n & 0xff)<<12)    // MCLK Fraction\n"
  "#define I2S_MDR_DIVIDE(n)\t\t((uint32_t)(n & 0xfff))\t      // MCLK Divide\n"
  "\n"
  "// Chapter 47: General-Purpose Input/Output (GPIO)\n"
  "#define GPIOA_PDOR\t\t*(volatile uint32_t *)0x400FF000 // Port Data Output Register\n"
  "#define GPIOA_PSOR\t\t*(volatile uint32_t *)0x400FF004 // Port Set Output Register\n"
  "#define GPIOA_PCOR\t\t*(volatile uint32_t *)0x400FF008 // Port Clear Output Register\n"
  "#define GPIOA_PTOR\t\t*(volatile uint32_t *)0x400FF00C // Port Toggle Output Register\n"
  "#define GPIOA_PDIR\t\t*(volatile uint32_t *)0x400FF010 // Port Data Input Register\n"
  "#define GPIOA_PDDR\t\t*(volatile uint32_t *)0x400FF014 // Port Data Direction Register\n"
  "#define GPIOB_PDOR\t\t*(volatile uint32_t *)0x400FF040 // Port Data Output Register\n"
  "#define GPIOB_PSOR\t\t*(volatile uint32_t *)0x400FF044 // Port Set Output Register\n"
  "#define GPIOB_PCOR\t\t*(volatile uint32_t *)0x400FF048 // Port Clear Output Register\n"
  "#define GPIOB_PTOR\t\t*(volatile uint32_t *)0x400FF04C // Port Toggle Output Register\n"
  "#define GPIOB_PDIR\t\t*(volatile uint32_t *)0x400FF050 // Port Data Input Register\n"
  "#define GPIOB_PDDR\t\t*(volatile uint32_t *)0x400FF054 // Port Data Direction Register\n"
  "#define GPIOC_PDOR\t\t*(volatile uint32_t *)0x400FF080 // Port Data Output Register\n"
  "#define GPIOC_PSOR\t\t*(volatile uint32_t *)0x400FF084 // Port Set Output Register\n"
  "#define GPIOC_PCOR\t\t*(volatile uint32_t *)0x400FF088 // Port Clear Output Register\n"
  "#define GPIOC_PTOR\t\t*(volatile uint32_t *)0x400FF08C // Port Toggle Output Register\n"
  "#define GPIOC_PDIR\t\t*(volatile uint32_t *)0x400FF090 // Port Data Input Register\n"
  "#define GPIOC_PDDR\t\t*(volatile uint32_t *)0x400FF094 // Port Data Direction Register\n"
  "#define GPIOD_PDOR\t\t*(volatile uint32_t *)0x400FF0C0 // Port Data Output Register\n"
  "#define GPIOD_PSOR\t\t*(volatile uint32_t *)0x400FF0C4 // Port Set Output Register\n"
  "#define GPIOD_PCOR\t\t*(volatile uint32_t *)0x400FF0C8 // Port Clear Output Register\n"
  "#define GPIOD_PTOR\t\t*(volatile uint32_t *)0x400FF0CC // Port Toggle Output Register\n"
  "#define GPIOD_PDIR\t\t*(volatile uint32_t *)0x400FF0D0 // Port Data Input Register\n"
  "#define GPIOD_PDDR\t\t*(volatile uint32_t *)0x400FF0D4 // Port Data Direction Register\n"
  "#define GPIOE_PDOR\t\t*(volatile uint32_t *)0x400FF100 // Port Data Output Register\n"
  "#define GPIOE_PSOR\t\t*(volatile uint32_t *)0x400FF104 // Port Set Output Register\n"
  "#define GPIOE_PCOR\t\t*(volatile uint32_t *)0x400FF108 // Port Clear Output Register\n"
  "#define GPIOE_PTOR\t\t*(volatile uint32_t *)0x400FF10C // Port Toggle Output Register\n"
  "#define GPIOE_PDIR\t\t*(volatile uint32_t *)0x400FF110 // Port Data Input Register\n"
  "#define GPIOE_PDDR\t\t*(volatile uint32_t *)0x400FF114 // Port Data Direction Register\n"
  "\n"
  "// Chapter 48: Touch sense input (TSI)\n"
  "#define TSI0_GENCS\t\t*(volatile uint32_t *)0x40045000 // General Control and Status Register\n"
  "#define TSI_GENCS_LPCLKS\t\t(uint32_t)0x10000000\t\t// \n"
  "#define TSI_GENCS_LPSCNITV(n)\t\t(((n) & 15) << 24)\t\t// \n"
  "#define TSI_GENCS_NSCN(n)\t\t(((n) & 31) << 19)\t\t// \n"
  "#define TSI_GENCS_PS(n)\t\t\t(((n) & 7) << 16)\t\t// \n"
  "#define TSI_GENCS_EOSF\t\t\t(uint32_t)0x00008000\t\t// \n"
  "#define TSI_GENCS_OUTRGF\t\t(uint32_t)0x00004000\t\t// \n"
  "#define TSI_GENCS_EXTERF\t\t(uint32_t)0x00002000\t\t// \n"
  "#define TSI_GENCS_OVRF\t\t\t(uint32_t)0x00001000\t\t// \n"
  "#define TSI_GENCS_SCNIP\t\t\t(uint32_t)0x00000200\t\t// \n"
  "#define TSI_GENCS_SWTS\t\t\t(uint32_t)0x00000100\t\t// \n"
  "#define TSI_GENCS_TSIEN\t\t\t(uint32_t)0x00000080\t\t// \n"
  "#define TSI_GENCS_TSIIE\t\t\t(uint32_t)0x00000040\t\t// \n"
  "#define TSI_GENCS_ERIE\t\t\t(uint32_t)0x00000020\t\t// \n"
  "#define TSI_GENCS_ESOR\t\t\t(uint32_t)0x00000010\t\t// \n"
  "#define TSI_GENCS_STM\t\t\t(uint32_t)0x00000002\t\t// \n"
  "#define TSI_GENCS_STPE\t\t\t(uint32_t)0x00000001\t\t// \n"
  "#define TSI0_SCANC\t\t*(volatile uint32_t *)0x40045004 // SCAN Control Register\n"
  "#define TSI_SCANC_REFCHRG(n)\t\t(((n) & 15) << 24)\t\t// \n"
  "#define TSI_SCANC_EXTCHRG(n)\t\t(((n) & 7) << 16)\t\t// \n"
  "#define TSI_SCANC_SMOD(n)\t\t(((n) & 255) << 8)\t\t// \n"
  "#define TSI_SCANC_AMCLKS(n)\t\t(((n) & 3) << 3)\t\t// \n"
  "#define TSI_SCANC_AMPSC(n)\t\t(((n) & 7) << 0)\t\t// \n"
  "#define TSI0_PEN\t\t*(volatile uint32_t *)0x40045008 // Pin Enable Register\n"
  "#define TSI0_WUCNTR\t\t*(volatile uint32_t *)0x4004500C // Wake-Up Channel Counter Register\n"
  "#define TSI0_CNTR1\t\t*(volatile uint32_t *)0x40045100 // Counter Register\n"
  "#define TSI0_CNTR3\t\t*(volatile uint32_t *)0x40045104 // Counter Register\n"
  "#define TSI0_CNTR5\t\t*(volatile uint32_t *)0x40045108 // Counter Register\n"
  "#define TSI0_CNTR7\t\t*(volatile uint32_t *)0x4004510C // Counter Register\n"
  "#define TSI0_CNTR9\t\t*(volatile uint32_t *)0x40045110 // Counter Register\n"
  "#define TSI0_CNTR11\t\t*(volatile uint32_t *)0x40045114 // Counter Register\n"
  "#define TSI0_CNTR13\t\t*(volatile uint32_t *)0x40045118 // Counter Register\n"
  "#define TSI0_CNTR15\t\t*(volatile uint32_t *)0x4004511C // Counter Register\n"
  "#define TSI0_THRESHOLD\t\t*(volatile uint32_t *)0x40045120 // Low Power Channel Threshold Register\n"
  "\n"
  "// Nested Vectored Interrupt Controller, Table 3-4 & ARMv7 ref, appendix B3.4 (page 750)\n"
  "#define NVIC_ENABLE_IRQ(n)\t(*((volatile uint32_t *)0xE000E100 + (n >> 5)) = (1 << (n & 31)))\n"
  "#define NVIC_DISABLE_IRQ(n)\t(*((volatile uint32_t *)0xE000E180 + (n >> 5)) = (1 << (n & 31)))\n"
  "#define NVIC_SET_PENDING(n)\t(*((volatile uint32_t *)0xE000E200 + (n >> 5)) = (1 << (n & 31)))\n"
  "#define NVIC_CLEAR_PENDING(n)\t(*((volatile uint32_t *)0xE000E280 + (n >> 5)) = (1 << (n & 31)))\n"
  "\n"
  "#define NVIC_ISER0\t\t*(volatile uint32_t *)0xE000E100\n"
  "#define NVIC_ISER1\t\t*(volatile uint32_t *)0xE000E104\n"
  "#define NVIC_ICER0\t\t*(volatile uint32_t *)0xE000E180\n"
  "#define NVIC_ICER1\t\t*(volatile uint32_t *)0xE000E184\n"
  "\n"
  "// 0 = highest priority\n"
  "// Cortex-M4: 0,16,32,48,64,80,96,112,128,144,160,176,192,208,224,240\n"
  "// Cortex-M0: 0,64,128,192\n"
  "#define NVIC_SET_PRIORITY(irqnum, priority)  (*((volatile uint8_t *)0xE000E400 + (irqnum)) = (uint8_t)(priority))\n"
  "#define NVIC_GET_PRIORITY(irqnum) (*((uint8_t *)0xE000E400 + (irqnum)))\n"
  "\n"
  "#if defined(__MK20DX128__)\n"
  "#define IRQ_DMA_CH0\t\t0\n"
  "#define IRQ_DMA_CH1\t\t1\n"
  "#define IRQ_DMA_CH2\t\t2\n"
  "#define IRQ_DMA_CH3\t\t3\n"
  "#define IRQ_DMA_ERROR\t\t4\n"
  "#define IRQ_FTFL_COMPLETE\t6\n"
  "#define IRQ_FTFL_COLLISION\t7\n"
  "#define IRQ_LOW_VOLTAGE\t\t8\n"
  "#define IRQ_LLWU\t\t9\n"
  "#define IRQ_WDOG\t\t10\n"
  "#define IRQ_I2C0\t\t11\n"
  "#define IRQ_SPI0\t\t12\n"
  "#define IRQ_I2S0_TX\t\t13\n"
  "#define IRQ_I2S0_RX\t\t14\n"
  "#define IRQ_UART0_LON\t\t15\n"
  "#define IRQ_UART0_STATUS\t16\n"
  "#define IRQ_UART0_ERROR\t\t17\n"
  "#define IRQ_UART1_STATUS\t18\n"
  "#define IRQ_UART1_ERROR\t\t19\n"
  "#define IRQ_UART2_STATUS\t20\n"
  "#define IRQ_UART2_ERROR\t\t21\n"
  "#define IRQ_ADC0\t\t22\n"
  "#define IRQ_CMP0\t\t23\n"
  "#define IRQ_CMP1\t\t24\n"
  "#define IRQ_FTM0\t\t25\n"
  "#define IRQ_FTM1\t\t26\n"
  "#define IRQ_CMT\t\t\t27\n"
  "#define IRQ_RTC_ALARM\t\t28\n"
  "#define IRQ_RTC_SECOND\t\t29\n"
  "#define IRQ_PIT_CH0\t\t30\n"
  "#define IRQ_PIT_CH1\t\t31\n"
  "#define IRQ_PIT_CH2\t\t32\n"
  "#define IRQ_PIT_CH3\t\t33\n"
  "#define IRQ_PDB\t\t\t34\n"
  "#define IRQ_USBOTG\t\t35\n"
  "#define IRQ_USBDCD\t\t36\n"
  "#define IRQ_TSI\t\t\t37\n"
  "#define IRQ_MCG\t\t\t38\n"
  "#define IRQ_LPTMR\t\t39\n"
  "#define IRQ_PORTA\t\t40\n"
  "#define IRQ_PORTB\t\t41\n"
  "#define IRQ_PORTC\t\t42\n"
  "#define IRQ_PORTD\t\t43\n"
  "#define IRQ_PORTE\t\t44\n"
  "#define IRQ_SOFTWARE\t\t45\n"
  "#define NVIC_NUM_INTERRUPTS\t46\n"
  "\n"
  "#elif defined(__MK20DX256__)\n"
  "#define IRQ_DMA_CH0\t\t0\n"
  "#define IRQ_DMA_CH1\t\t1\n"
  "#define IRQ_DMA_CH2\t\t2\n"
  "#define IRQ_DMA_CH3\t\t3\n"
  "#define IRQ_DMA_CH4\t\t4\n"
  "#define IRQ_DMA_CH5\t\t5\n"
  "#define IRQ_DMA_CH6\t\t6\n"
  "#define IRQ_DMA_CH7\t\t7\n"
  "#define IRQ_DMA_CH8\t\t8\n"
  "#define IRQ_DMA_CH9\t\t9\n"
  "#define IRQ_DMA_CH10\t\t10\n"
  "#define IRQ_DMA_CH11\t\t11\n"
  "#define IRQ_DMA_CH12\t\t12\n"
  "#define IRQ_DMA_CH13\t\t13\n"
  "#define IRQ_DMA_CH14\t\t14\n"
  "#define IRQ_DMA_CH15\t\t15\n"
  "#define IRQ_DMA_ERROR\t\t16\n"
  "#define IRQ_FTFL_COMPLETE\t18\n"
  "#define IRQ_FTFL_COLLISION\t19\n"
  "#define IRQ_LOW_VOLTAGE\t\t20\n"
  "#define IRQ_LLWU\t\t21\n"
  "#define IRQ_WDOG\t\t22\n"
  "#define IRQ_I2C0\t\t24\n"
  "#define IRQ_I2C1\t\t25\n"
  "#define IRQ_SPI0\t\t26\n"
  "#define IRQ_SPI1\t\t27\n"
  "#define IRQ_CAN_MESSAGE\t\t29\n"
  "#define IRQ_CAN_BUS_OFF\t\t30\n"
  "#define IRQ_CAN_ERROR\t\t31\n"
  "#define IRQ_CAN_TX_WARN\t\t32\n"
  "#define IRQ_CAN_RX_WARN\t\t33\n"
  "#define IRQ_CAN_WAKEUP\t\t34\n"
  "#define IRQ_I2S0_TX\t\t35\n"
  "#define IRQ_I2S0_RX\t\t36\n"
  "#define IRQ_UART0_LON\t\t44\n"
  "#define IRQ_UART0_STATUS\t45\n"
  "#define IRQ_UART0_ERROR\t\t46\n"
  "#define IRQ_UART1_STATUS\t47\n"
  "#define IRQ_UART1_ERROR\t\t48\n"
  "#define IRQ_UART2_STATUS\t49\n"
  "#define IRQ_UART2_ERROR\t\t50\n"
  "#define IRQ_ADC0\t\t57\n"
  "#define IRQ_ADC1\t\t58\n"
  "#define IRQ_CMP0\t\t59\n"
  "#define IRQ_CMP1\t\t60\n"
  "#define IRQ_CMP2\t\t61\n"
  "#define IRQ_FTM0\t\t62\n"
  "#define IRQ_FTM1\t\t63\n"
  "#define IRQ_FTM2\t\t64\n"
  "#define IRQ_CMT\t\t\t65\n"
  "#define IRQ_RTC_ALARM\t\t66\n"
  "#define IRQ_RTC_SECOND\t\t67\n"
  "#define IRQ_PIT_CH0\t\t68\n"
  "#define IRQ_PIT_CH1\t\t69\n"
  "#define IRQ_PIT_CH2\t\t70\n"
  "#define IRQ_PIT_CH3\t\t71\n"
  "#define IRQ_PDB\t\t\t72\n"
  "#define IRQ_USBOTG\t\t73\n"
  "#define IRQ_USBDCD\t\t74\n"
  "#define IRQ_DAC0\t\t81\n"
  "#define IRQ_TSI\t\t\t83\n"
  "#define IRQ_MCG\t\t\t84\n"
  "#define IRQ_LPTMR\t\t85\n"
  "#define IRQ_PORTA\t\t87\n"
  "#define IRQ_PORTB\t\t88\n"
  "#define IRQ_PORTC\t\t89\n"
  "#define IRQ_PORTD\t\t90\n"
  "#define IRQ_PORTE\t\t91\n"
  "#define IRQ_SOFTWARE\t\t94\n"
  "#define NVIC_NUM_INTERRUPTS\t95\n"
  "\n"
  "#endif\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "#define __disable_irq() asm volatile(\"CPSID i\");\n"
  "#define __enable_irq()\tasm volatile(\"CPSIE i\");\n"
  "\n"
  "// System Control Space (SCS), ARMv7 ref manual, B3.2, page 708\n"
  "#define SCB_CPUID\t\t*(const\t   uint32_t *)0xE000ED00 // CPUID Base Register\n"
  "#define SCB_ICSR\t\t*(volatile uint32_t *)0xE000ED04 // Interrupt Control and State\n"
  "#define SCB_ICSR_PENDSTSET\t\t(uint32_t)0x04000000\n"
  "#define SCB_VTOR\t\t*(volatile uint32_t *)0xE000ED08 // Vector Table Offset\n"
  "#define SCB_AIRCR\t\t*(volatile uint32_t *)0xE000ED0C // Application Interrupt and Reset Control\n"
  "#define SCB_SCR\t\t\t*(volatile uint32_t *)0xE000ED10 // System Control Register\n"
  "#define SCB_CCR\t\t\t*(volatile uint32_t *)0xE000ED14 // Configuration and Control\n"
  "#define SCB_SHPR1\t\t*(volatile uint32_t *)0xE000ED18 // System Handler Priority Register 1\n"
  "#define SCB_SHPR2\t\t*(volatile uint32_t *)0xE000ED1C // System Handler Priority Register 2\n"
  "#define SCB_SHPR3\t\t*(volatile uint32_t *)0xE000ED20 // System Handler Priority Register 3\n"
  "#define SCB_SHCSR\t\t*(volatile uint32_t *)0xE000ED24 // System Handler Control and State\n"
  "#define SCB_CFSR\t\t*(volatile uint32_t *)0xE000ED28 // Configurable Fault Status Register\n"
  "#define SCB_HFSR\t\t*(volatile uint32_t *)0xE000ED2C // HardFault Status\n"
  "#define SCB_DFSR\t\t*(volatile uint32_t *)0xE000ED30 // Debug Fault Status\n"
  "#define SCB_MMFAR\t\t*(volatile uint32_t *)0xE000ED34 // MemManage Fault Address\n"
  "\n"
  "#define SYST_CSR\t\t*(volatile uint32_t *)0xE000E010 // SysTick Control and Status\n"
  "#define SYST_CSR_COUNTFLAG\t\t(uint32_t)0x00010000\n"
  "#define SYST_CSR_CLKSOURCE\t\t(uint32_t)0x00000004\n"
  "#define SYST_CSR_TICKINT\t\t(uint32_t)0x00000002\n"
  "#define SYST_CSR_ENABLE\t\t\t(uint32_t)0x00000001\n"
  "#define SYST_RVR\t\t*(volatile uint32_t *)0xE000E014 // SysTick Reload Value Register\n"
  "#define SYST_CVR\t\t*(volatile uint32_t *)0xE000E018 // SysTick Current Value Register\n"
  "#define SYST_CALIB\t*(const\t   uint32_t *)0xE000E01C // SysTick Calibration Value\n"
  "\n"
  "\n"
  "#define ARM_DEMCR\t\t*(volatile uint32_t *)0xE000EDFC // Debug Exception and Monitor Control\n"
  "#define ARM_DEMCR_TRCENA\t\t(1 << 24)\t // Enable debugging & monitoring blocks\n"
  "#define ARM_DWT_CTRL\t\t*(volatile uint32_t *)0xE0001000 // DWT control register\n"
  "#define ARM_DWT_CTRL_CYCCNTENA\t\t(1 << 0)\t\t// Enable cycle count\n"
  "#define ARM_DWT_CYCCNT\t\t*(volatile uint32_t *)0xE0001004 // Cycle count register\n"
  "\n"
  "\n"
  "#ifdef __cplusplus\n"
  "}\n"
  "#endif\n"
  "#endif\n" ;

const cRegularFileWrapper gWrapperFile_12_targetTemplates (
  "mk20dx256.h",
  "h",
  true, // Text file
  152136, // Text length
  gWrapperFileContent_12_targetTemplates
) ;

//--- File 'sources/startup-sequential.c'

const char * gWrapperFileContent_13_targetTemplates = "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "#include <stddef.h>\n"
  "\n"
  "#include \"plm.h\"\n"
  "#include \"mk20dx256.h\"\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "static void ResetISR (void) {\n"
  "//---------1- Inhiber le chien de garde\n"
  "  WDOG_UNLOCK = 0xC520 ;\n"
  "  WDOG_UNLOCK = 0xD928 ;\n"
  "  WDOG_STCTRLH = 0x0010 ;\n"
  "  // enable clocks to always-used peripherals\n"
  "  SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;\n"
  "  SIM_SCGC5 = 0x00043F82;    // clocks active to all GPIO\n"
  "  SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;\n"
  "  // if the RTC oscillator isn't enabled, get it started early\n"
  "  if (!(RTC_CR & RTC_CR_OSCE)) {\n"
  "    RTC_SR = 0;\n"
  "    RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;\n"
  "  }\n"
  "\n"
  "  // release I/O pins hold, if we woke up from VLLS mode\n"
  "  if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;\n"
  "\n"
  "  // TODO: do this while the PLL is waiting to lock....\n"
  "//  SCB_VTOR = 0;  // use vector table in flash\n"
  "\n"
  "  // default all interrupts to medium priority level\n"
  "//  for (int32_t i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);\n"
  "//---------2- Initialisation de la PLL\n"
  "  // start in FEI mode\n"
  "  // enable capacitors for crystal\n"
  "  OSC0_CR = OSC_SC8P | OSC_SC2P;\n"
  "  // enable osc, 8-32 MHz range, low power mode\n"
  "  MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;\n"
  "  // switch to crystal as clock source, FLL input = 16 MHz / 512\n"
  "  MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);\n"
  "  // wait for crystal oscillator to begin\n"
  "  while ((MCG_S & MCG_S_OSCINIT0) == 0) ;\n"
  "  // wait for FLL to use oscillator\n"
  "  while ((MCG_S & MCG_S_IREFST) != 0) ;\n"
  "  // wait for MCGOUT to use oscillator\n"
  "  while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;\n"
  "  // now we're in FBE mode\n"
  "  // config PLL input for 16 MHz Crystal / 4 = 4 MHz\n"
  "  MCG_C5 = MCG_C5_PRDIV0(3);\n"
  "  // config PLL for 96 MHz output\n"
  "  MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0);\n"
  "  // wait for PLL to start using xtal as its input\n"
  "  while (!(MCG_S & MCG_S_PLLST)) ;\n"
  "  // wait for PLL to lock\n"
  "  while (!(MCG_S & MCG_S_LOCK0)) ;\n"
  "  // now we're in PBE mode\n"
  "#if F_CPU == 96000000\n"
  "  // config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash\n"
  "  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) |   SIM_CLKDIV1_OUTDIV4(3);\n"
  "#elif F_CPU == 48000000\n"
  "  // config divisors: 48 MHz core, 48 MHz bus, 24 MHz flash\n"
  "  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV2(1) |   SIM_CLKDIV1_OUTDIV4(3);\n"
  "#elif F_CPU == 24000000\n"
  "  // config divisors: 24 MHz core, 24 MHz bus, 24 MHz flash\n"
  "  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(3) | SIM_CLKDIV1_OUTDIV2(3) |   SIM_CLKDIV1_OUTDIV4(3);\n"
  "#else\n"
  "#error \"Error, F_CPU must be 96000000, 48000000, or 24000000\"\n"
  "#endif\n"
  "  // switch to PLL as clock source, FLL input = 16 MHz / 512\n"
  "  MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);\n"
  "  // wait for PLL clock to be used\n"
  "  while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;\n"
  "  // now we're in PEE mode\n"
  "  // configure USB for 48 MHz clock\n"
  "//  SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1); // USB = 96 MHz PLL / 2\n"
  "  // USB uses PLL clock, trace is CPU clock, CLKOUT=OSCERCLK0\n"
  "//  SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);\n"
  "\n"
  "//---------3- Initialisation de la section .bss\n"
  "  extern unsigned __bss_start ;\n"
  "  extern unsigned __bss_end ;\n"
  "  unsigned * p = & __bss_start ;\n"
  "  while (p != & __bss_end) {\n"
  "    * p = 0 ;\n"
  "    p ++ ;\n"
  "  }\n"
  "//---------4- Copy de la section .data\n"
  "  extern unsigned __data_start ;\n"
  "  extern unsigned __data_end ;\n"
  "  extern unsigned __data_load_start ;\n"
  "  unsigned * pSrc = & __data_load_start ;\n"
  "  unsigned * pDest = & __data_start ;\n"
  "  while (pDest != & __data_end) {\n"
  "    * pDest = * pSrc ;\n"
  "    pDest ++ ;\n"
  "    pSrc ++ ;\n"
  "  }\n"
  "//---------5- Ex\xC3""\xA9""cuter les constructeurs des variables globales\n"
  "  extern void (* __constructor_array_start) (void) ;\n"
  "  extern void (* __constructor_array_end) (void) ;\n"
  "  void (** ptr) (void) = & __constructor_array_start ;\n"
  "  while (ptr != & __constructor_array_end) {\n"
  "    (* ptr) () ;\n"
  "    ptr ++ ;\n"
  "  }\n"
  "//---------6- Ex\xC3""\xA9""cuter les routines d'initialisation de la section init_routine_array\n"
  "  extern void (* __init_routine_array_start) (void) ;\n"
  "  extern void (* __init_routine_array_end) (void) ;\n"
  "  ptr = & __init_routine_array_start ;\n"
  "  while (ptr != & __init_routine_array_end) {\n"
  "    (* ptr) () ;\n"
  "    ptr ++ ;\n"
  "  }\n"
  "//---------7- Ex\xC3""\xA9""cuter le programme utilisateur\n"
  "  setup () ;\n"
  "  while (1) {\n"
  "    loop () ;\n"
  "  }\n"
  "}\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "//   Vector table                                                                                                      *\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "typedef struct {\n"
  "  unsigned * mStackPointer ;\n"
  "//--- ARM Core System Handler Vectors\n"
  "  void (* mCoreSystemHandlerVector [15]) (void) ;\n"
  "//--- Non-Core Vectors\n"
  "  void (* mNonCoreHandlerVector [240]) (void) ;\n"
  "//--- Flash magic values\n"
  "  int mFlash [4] ;\n"
  "} vectorStructSeq ;\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "extern unsigned __system_stack_end ;\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "const vectorStructSeq vector __attribute__ ((section (\".isr_vector\"))) = {\n"
  "  & __system_stack_end, // 0\n"
  "//--- ARM Core System Handler Vectors\n"
  "  { ResetISR, // 1\n"
  "    NULL, // 2\n"
  "    NULL, // 3\n"
  "    NULL, // 4\n"
  "    NULL, // 5\n"
  "    NULL, // 6\n"
  "    NULL, // 7\n"
  "    NULL, // 8\n"
  "    NULL, // 9\n"
  "    NULL, // 10\n"
  "    NULL, // 11\n"
  "    NULL, // 12\n"
  "    NULL, // 13\n"
  "    NULL, // 14\n"
  "    NULL // 15\n"
  "  },\n"
  "//--- Non-Core Vectors\n"
  "  { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n"
  "  },\n"
  "//--- Flash magic values\n"
  "  {-1, -1, -1, -2}\n"
  "} ;\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_13_targetTemplates (
  "startup-sequential.c",
  "c",
  true, // Text file
  7492, // Text length
  gWrapperFileContent_13_targetTemplates
) ;

//--- All files of 'sources' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_4 [4] = {
  & gWrapperFile_11_targetTemplates,
  & gWrapperFile_12_targetTemplates,
  & gWrapperFile_13_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'sources' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_4 [1] = {
  NULL
} ;

//--- Directory 'sources'

const cDirectoryWrapper gWrapperDirectory_4_targetTemplates (
  "sources",
  3,
  gWrapperAllFiles_targetTemplates_4,
  0,
  gWrapperAllDirectories_targetTemplates_4
) ;

//--- All files of 'target-teensy-sequential' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_3 [6] = {
  & gWrapperFile_6_targetTemplates,
  & gWrapperFile_7_targetTemplates,
  & gWrapperFile_8_targetTemplates,
  & gWrapperFile_9_targetTemplates,
  & gWrapperFile_10_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'target-teensy-sequential' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_3 [2] = {
  & gWrapperDirectory_4_targetTemplates,
  NULL
} ;

//--- Directory 'target-teensy-sequential'

const cDirectoryWrapper gWrapperDirectory_3_targetTemplates (
  "target-teensy-sequential",
  5,
  gWrapperAllFiles_targetTemplates_3,
  1,
  gWrapperAllDirectories_targetTemplates_3
) ;

//--- File 'target-teensy-sequential-systick/build-as.py'

const char * gWrapperFileContent_14_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"as\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_14_targetTemplates (
  "build-as.py",
  "py",
  true, // Text file
  996, // Text length
  gWrapperFileContent_14_targetTemplates
) ;

//--- File 'target-teensy-sequential-systick/build-verbose.py'

const char * gWrapperFileContent_15_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"all\", \"1\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_15_targetTemplates (
  "build-verbose.py",
  "py",
  true, // Text file
  1002, // Text length
  gWrapperFileContent_15_targetTemplates
) ;

//--- File 'target-teensy-sequential-systick/build.py'

const char * gWrapperFileContent_16_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess, sys, os, copy\n"
  "import urllib, shutil\n"
  "import subprocess, re\n"
  "from time import time\n"
  "import platform\n"
  "import json\n"
  "import threading, operator\n"
  "\n"
  "if sys.version_info >= (2, 6) :\n"
  "  import multiprocessing\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   processorCount                                                                                                     *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def processorCount () :\n"
  "  if sys.version_info >= (2, 6) :\n"
  "    coreCount = multiprocessing.cpu_count ()\n"
  "  else:\n"
  "    coreCount = 1\n"
  "  return coreCount\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   FOR PRINTING IN COLOR                                                                                              *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BLACK () :\n"
  "  return '\\033[90m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def RED () :\n"
  "  return '\\033[91m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def GREEN () :\n"
  "  return '\\033[92m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def YELLOW () :\n"
  "  return '\\033[93m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BLUE () :\n"
  "  return '\\033[94m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def MAGENTA () :\n"
  "  return '\\033[95m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def CYAN () :\n"
  "  return '\\033[96m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def WHITE () :\n"
  "  return '\\033[97m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def ENDC () :\n"
  "  return '\\033[0m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD () :\n"
  "  return '\\033[1m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def UNDERLINE () :\n"
  "  return '\\033[4m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BLINK () :\n"
  "  return '\\033[5m'\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_BLUE () :\n"
  "  return BOLD () + BLUE ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_GREEN () :\n"
  "  return BOLD () + GREEN ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def BOLD_RED () :\n"
  "  return BOLD () + RED ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runHiddenCommand                                                                                                   *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runHiddenCommand (cmd) :\n"
  "  result = \"\"\n"
  "  childProcess = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n"
  "  while True:\n"
  "    line = childProcess.stdout.readline ()\n"
  "    if line != \"\":\n"
  "      result += line\n"
  "    else:\n"
  "      childProcess.wait ()\n"
  "      if childProcess.returncode != 0 :\n"
  "        sys.exit (childProcess.returncode)\n"
  "      return result\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runSingleCommand                                                                                                   *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runSingleCommand (cmd) :\n"
  "  cmdAsString = \"\"\n"
  "  for s in cmd:\n"
  "    if (s == \"\") or (s.find (\" \") >= 0):\n"
  "      cmdAsString += '\"' + s + '\" '\n"
  "    else:\n"
  "      cmdAsString += s + ' '\n"
  "  print cmdAsString\n"
  "  childProcess = subprocess.Popen (cmd)\n"
  "  childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runCommand                                                                                                         *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runCommand (cmd, title, showCommand) :\n"
  "  if title != \"\":\n"
  "    print BOLD_BLUE () + title + ENDC ()\n"
  "  if (title == \"\") or showCommand :\n"
  "    cmdAsString = \"\"\n"
  "    for s in cmd:\n"
  "      if (s == \"\") or (s.find (\" \") >= 0):\n"
  "        cmdAsString += '\"' + s + '\" '\n"
  "      else:\n"
  "        cmdAsString += s + ' '\n"
  "    print cmdAsString\n"
  "  childProcess = subprocess.Popen (cmd)\n"
  "  childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   runInThread                                                                                                        *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def runInThread (job, displayLock, terminationSemaphore):\n"
  "  childProcess = subprocess.Popen (job.mCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n"
  "  while True:\n"
  "    line = childProcess.stdout.readline ()\n"
  "    if line != \"\":\n"
  "      displayLock.acquire ()\n"
  "      sys.stdout.write (line) # Print without newline\n"
  "      displayLock.release ()\n"
  "    else:\n"
  "      childProcess.wait ()\n"
  "      job.mReturnCode = childProcess.returncode\n"
  "      terminationSemaphore.release ()\n"
  "      break\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   modificationDateForFile                                                                                            *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def modificationDateForFile (dateCacheDictionary, file):\n"
  "  absFilePath = os.path.abspath (file)\n"
  "  if dateCacheDictionary.has_key (absFilePath) :\n"
  "    return dateCacheDictionary [absFilePath]\n"
  "  elif not os.path.exists (absFilePath):\n"
  "    date = sys.float_info.max # Very far in future\n"
  "    dateCacheDictionary [absFilePath] = date\n"
  "    return date\n"
  "  else:\n"
  "    date = os.path.getmtime (absFilePath)\n"
  "    dateCacheDictionary [absFilePath] = date\n"
  "    return date\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class PostCommand                                                                                                  *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class PostCommand:\n"
  "  mCommand = []\n"
  "  mTitle = \"\"\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, title = \"\"):\n"
  "    self.mCommand = []\n"
  "    self.mTitle = title\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class Job                                                                                                          *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class Job:\n"
  "  mTarget = \"\"\n"
  "  mCommand = []\n"
  "  mTitle = \"\"\n"
  "  mRequiredFiles = []\n"
  "  mPostCommands = []\n"
  "  mReturnCode = None\n"
  "  mPriority = 0\n"
  "  mState = 0 # 0: waiting for execution\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, target, requiredFiles, command, postCommands, priority, title):\n"
  "    self.mTarget = copy.deepcopy (target)\n"
  "    self.mCommand = copy.deepcopy (command)\n"
  "    self.mRequiredFiles = copy.deepcopy (requiredFiles)\n"
  "    self.mTitle = copy.deepcopy (title)\n"
  "    self.mPostCommands = copy.deepcopy (postCommands)\n"
  "    self.mPriority = priority\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def run (self, displayLock, terminationSemaphore, showCommand):\n"
  "    displayLock.acquire ()\n"
  "    if self.mTitle != \"\":\n"
  "      print BOLD_BLUE () + self.mTitle + ENDC ()\n"
  "    if (self.mTitle == \"\") or showCommand :\n"
  "      cmdAsString = \"\"\n"
  "      for s in self.mCommand:\n"
  "        if (s == \"\") or (s.find (\" \") >= 0):\n"
  "          cmdAsString += '\"' + s + '\" '\n"
  "        else:\n"
  "          cmdAsString += s + ' '\n"
  "      print cmdAsString\n"
  "    displayLock.release ()\n"
  "    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n"
  "    thread.start()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def runPostCommand (self, displayLock, terminationSemaphore, showCommand):\n"
  "    postCommand = self.mPostCommands [0]\n"
  "    self.mCommand = postCommand.mCommand\n"
  "    displayLock.acquire ()\n"
  "    print BOLD_BLUE () + postCommand.mTitle + ENDC ()\n"
  "    if showCommand:\n"
  "      cmdAsString = \"\"\n"
  "      for s in self.mCommand:\n"
  "        if (s == \"\") or (s.find (\" \") >= 0):\n"
  "          cmdAsString += '\"' + s + '\" '\n"
  "        else:\n"
  "          cmdAsString += s + ' '\n"
  "      print cmdAsString\n"
  "    displayLock.release ()\n"
  "    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n"
  "    thread.start()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class Rule                                                                                                         *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class Rule:\n"
  "  mTarget = \"\"\n"
  "  mDependences = []\n"
  "  mCommand = []\n"
  "  mSecondaryMostRecentModificationDate = 0.0 # Far in the past\n"
  "  mTitle = \"\"\n"
  "  mPostCommands = []\n"
  "  mPriority = 0\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def __init__ (self, target, title = \"\"):\n"
  "    self.mTarget = copy.deepcopy (target)\n"
  "    self.mDependences = []\n"
  "    self.mCommand = []\n"
  "    self.mSecondaryMostRecentModificationDate = 0.0\n"
  "    self.mPostCommands = []\n"
  "    self.mPriority = 0\n"
  "    if title == \"\":\n"
  "      self.mTitle = \"Building \" + target\n"
  "    else:\n"
  "      self.mTitle = copy.deepcopy (title)\n"
  "  \n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def enterSecondaryDependanceFile (self, secondaryDependanceFile):\n"
  "    if secondaryDependanceFile != \"\":\n"
  "      filePath = os.path.abspath (secondaryDependanceFile)\n"
  "      if os.path.exists (filePath):\n"
  "        f = open (filePath, \"r\")\n"
  "        s = f.read ().replace (\"\\\\ \", \"\\x01\") # Read and replace escaped spaces by \\0x01\n"
  "        f.close ()\n"
  "        s = s.replace (\"\\\\\\n\", \"\")\n"
  "        liste = s.split (\"\\n\\n\")\n"
  "        dateCacheDictionary = {}\n"
  "        for s in liste:\n"
  "          components = s.split (':')\n"
  "          target = components [0].replace (\"\\x01\", \" \")\n"
  "          #print \"------- Optional dependency rules for target '\" + target + \"'\"\n"
  "          #print \"Secondary target '\" + target + \"'\"\n"
  "          for src in components [1].split ():\n"
  "            secondarySource = src.replace (\"\\x01\", \" \")\n"
  "            #print \"  '\" + secondarySource + \"'\"\n"
  "            modifDate = modificationDateForFile (dateCacheDictionary, secondarySource)\n"
  "            if self.mSecondaryMostRecentModificationDate < modifDate :\n"
  "              self.mSecondaryMostRecentModificationDate = modifDate\n"
  "              #print BOLD_BLUE () + str (modifDate) + ENDC ()\n"
  "    \n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   class Make                                                                                                         *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "class Make:\n"
  "  mRuleList = []\n"
  "  mJobList = []\n"
  "  mErrorCount = 0\n"
  "  mModificationDateDictionary = {}\n"
  "  mGoals = {}\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def addRule (self, rule):\n"
  "    self.mRuleList.append (copy.deepcopy (rule))\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printRules (self):\n"
  "    print BOLD_BLUE () + \"--- Print the \" + str (len (self.mRuleList)) + \" rule\" + (\"s\" if len (self.mRuleList) > 1 else \"\") + \" ---\" + ENDC ()\n"
  "    for rule in self.mRuleList:\n"
  "      print BOLD_GREEN () + \"Target: '\" + rule.mTarget + \"'\" + ENDC ()\n"
  "      for dep in rule.mDependences:\n"
  "        print \"  Dependence: '\" + dep + \"'\"\n"
  "      s = \"  Command: \"\n"
  "      for cmd in rule.mCommand:\n"
  "        s += \" \\\"\" + cmd + \"\\\"\"\n"
  "      print s\n"
  "      print \"  Title: '\" + rule.mTitle + \"'\"\n"
  "      index = 0\n"
  "      for (command, title) in rule.mPostCommands:\n"
  "        index = index + 1\n"
  "        s = \"  Post command \" + str (index) + \": \"\n"
  "        for cmd in command:\n"
  "          s += \" \\\"\" + cmd + \"\\\"\"\n"
  "        print s\n"
  "        print \"  Its title: '\" + title + \"'\"\n"
  "        \n"
  "    print BOLD_BLUE () + \"--- End of print rule ---\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def writeRuleDependancesInDotFile (self, dotFileName):\n"
  "    s = \"digraph G {\\n\"\n"
  "    s += \"  node [fontname=courier]\\n\"\n"
  "    arrowSet = set ()\n"
  "    for rule in self.mRuleList:\n"
  "      s += '  \"' + rule.mTarget + '\" [shape=rectangle]\\n'\n"
  "      for dep in rule.mDependences:\n"
  "        arrowSet.add ('  \"' + rule.mTarget + '\" -> \"' + dep + '\"\\n')\n"
  "    for arrow in arrowSet:\n"
  "      s += arrow\n"
  "    s += \"}\\n\"\n"
  "    f = open (dotFileName, \"w\")\n"
  "    f.write (s)\n"
  "    f.close ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def checkRules (self):\n"
  "    if self.mErrorCount == 0:\n"
  "      ruleList = copy.deepcopy (self.mRuleList)\n"
  "      index = 0\n"
  "      looping = True\n"
  "    #--- loop on rules\n"
  "      while looping:\n"
  "        looping = False\n"
  "        while index < len (ruleList):\n"
  "          aRule = ruleList [index]\n"
  "          index = index + 1\n"
  "        #--- Check dependance files have rule for building, or does exist\n"
  "          depIdx = 0\n"
  "          while depIdx < len (aRule.mDependences):\n"
  "            dep = aRule.mDependences [depIdx]\n"
  "            depIdx = depIdx + 1\n"
  "            hasBuildRule = False\n"
  "            for r in ruleList:\n"
  "              if dep == r.mTarget:\n"
  "                hasBuildRule = True\n"
  "                break\n"
  "            if not hasBuildRule:\n"
  "              looping = True\n"
  "              if not os.path.exists (os.path.abspath (dep)):\n"
  "                self.mErrorCount = self.mErrorCount + 1\n"
  "                print BOLD_RED () + \"Check rules error: '\" + dep + \"' does not exist, and there is no rule for building it.\" + ENDC ()\n"
  "              depIdx = depIdx - 1\n"
  "              aRule.mDependences.pop (depIdx)\n"
  "        #--- Rule with no dependances\n"
  "          if len (aRule.mDependences) == 0 :\n"
  "            looping = True\n"
  "            index = index - 1\n"
  "            ruleList.pop (index)\n"
  "            idx = 0\n"
  "            while idx < len (ruleList):\n"
  "              r = ruleList [idx]\n"
  "              idx = idx + 1\n"
  "              while r.mDependences.count (aRule.mTarget) > 0 :\n"
  "                r.mDependences.remove (aRule.mTarget)\n"
  "    #--- Error if rules remain\n"
  "      if len (ruleList) > 0:\n"
  "        self.mErrorCount = self.mErrorCount + 1\n"
  "        print BOLD_RED () + \"Check rules error; circulary dependances between:\" + ENDC ()\n"
  "        for aRule in ruleList: \n"
  "          print BOLD_RED () + \"  - '\" + aRule.mTarget + \"', depends from:\" + ENDC ()\n"
  "          for dep in aRule.mDependences:\n"
  "            print BOLD_RED () + \"      '\" + dep + \"'\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def existsJobForTarget (self, target):\n"
  "    for job in self.mJobList:\n"
  "      if job.mTarget == target:\n"
  "        return True\n"
  "    return False\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def makeJob (self, target): # Return a bool indicating wheither the target should be built\n"
  "  #--- If there are errors, return immediatly\n"
  "    if self.mErrorCount != 0:\n"
  "      return False\n"
  "  #--- Target already in job list \?\n"
  "    if self.existsJobForTarget (target):\n"
  "      return True # yes, return target will be built\n"
  "  #--- Find a rule for making the target\n"
  "    absTarget = os.path.abspath (target)\n"
  "    rule = None\n"
  "    matchCount = 0\n"
  "    for r in self.mRuleList:\n"
  "      if target == r.mTarget:\n"
  "        matchCount = matchCount + 1\n"
  "        rule = r\n"
  "    if matchCount == 0:\n"
  "      absTarget = os.path.abspath (target)\n"
  "      if not os.path.exists (absTarget):\n"
  "        print BOLD_RED () + \"No rule for making '\" + target + \"'\" + ENDC ()\n"
  "        self.mErrorCount = self.mErrorCount + 1\n"
  "      return False # Error or target exists, and no rule for building it\n"
  "    elif matchCount > 1:\n"
  "      print BOLD_RED () + str (matchCount) + \" rules for making '\" + target + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "      return False # Error\n"
  "  #--- Target file does not exist, and 'rule' variable indicates how build it\n"
  "    appendToJobList = not os.path.exists (absTarget)\n"
  "  #--- Build primary dependences\n"
  "    jobDependenceFiles = []\n"
  "    for dependence in rule.mDependences:\n"
  "      willBeBuilt = self.makeJob (dependence)\n"
  "      if willBeBuilt:\n"
  "        jobDependenceFiles.append (dependence)\n"
  "        appendToJobList = True\n"
  "  #--- Check primary file modification dates\n"
  "    if not appendToJobList:\n"
  "      targetDateModification = os.path.getmtime (absTarget)\n"
  "      for source in rule.mDependences:\n"
  "        sourceDateModification = os.path.getmtime (source)\n"
  "        if targetDateModification < sourceDateModification:\n"
  "          appendToJobList = True\n"
  "          break\n"
  "  #--- Check for secondary dependancy files\n"
  "    if not appendToJobList:\n"
  "      targetDateModification = os.path.getmtime (absTarget)\n"
  "      if targetDateModification < rule.mSecondaryMostRecentModificationDate:\n"
  "        appendToJobList = True\n"
  "  #--- Append to job list\n"
  "    if appendToJobList:\n"
  "      self.mJobList.append (Job (target, jobDependenceFiles, rule.mCommand, rule.mPostCommands, rule.mPriority, rule.mTitle))\n"
  "  #--- Return\n"
  "    return appendToJobList\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "  #Job state\n"
  "  # 0: waiting\n"
  "  # 1:running\n"
  "  # 2: waiting for executing post command\n"
  "  # 3:executing for executing post command\n"
  "  # 4: completed\n"
  "\n"
  "  def runJobs (self, maxConcurrentJobs, showCommand):\n"
  "    if self.mErrorCount == 0:\n"
  "      if len (self.mJobList) == 0:\n"
  "        print BOLD_BLUE () + \"Nothing to make.\" + ENDC ()\n"
  "      else:\n"
  "      #--- Sort jobs following their priorities\n"
  "        self.mJobList = sorted (self.mJobList, key=operator.attrgetter(\"mPriority\"), reverse=True)\n"
  "      #--- Run\n"
  "        if maxConcurrentJobs <= 0:\n"
  "          maxConcurrentJobs = processorCount () - maxConcurrentJobs\n"
  "        jobCount = 0 ;\n"
  "        terminationSemaphore = threading.Semaphore (0)\n"
  "        displayLock = threading.Lock ()\n"
  "        loop = True\n"
  "        returnCode = 0\n"
  "        while loop:\n"
  "        #--- Launch jobs in parallel\n"
  "          for job in self.mJobList:\n"
  "            if (returnCode == 0) and (jobCount < maxConcurrentJobs):\n"
  "              if (job.mState == 0) and (len (job.mRequiredFiles) == 0):\n"
  "                #--- Create target directory if does not exist\n"
  "                absTargetDirectory = os.path.dirname (os.path.abspath (job.mTarget))\n"
  "                if not os.path.exists (absTargetDirectory):\n"
  "                  displayLock.acquire ()\n"
  "                  runCommand ([\"mkdir\", \"-p\", absTargetDirectory], \"Making \" + absTargetDirectory + \" directory\", showCommand)\n"
  "                  displayLock.release ()\n"
  "                #--- Run job\n"
  "                job.run (displayLock, terminationSemaphore, showCommand)\n"
  "                jobCount = jobCount + 1\n"
  "                job.mState = 1 # Means is running\n"
  "              elif job.mState == 2: # Waiting for executing post command\n"
  "                job.mReturnCode = None # Means post command not terminated\n"
  "                job.runPostCommand (displayLock, terminationSemaphore, showCommand)\n"
  "                jobCount = jobCount + 1\n"
  "                job.mState = 3 # Means post command is running\n"
  "        #--- Wait for a job termination\n"
  "          #print \"wait \" + str (jobCount) + \" \" + str (len (self.mJobList))\n"
  "          terminationSemaphore.acquire ()\n"
  "        #--- Checks for terminated jobs\n"
  "          index = 0\n"
  "          while index < len (self.mJobList):\n"
  "            job = self.mJobList [index]\n"
  "            index = index + 1\n"
  "            if (job.mState == 1) and (job.mReturnCode == 0) : # Terminated without error\n"
  "              jobCount = jobCount - 1\n"
  "              if len (job.mPostCommands) > 0:\n"
  "                job.mState = 2 # Ready to execute next post command\n"
  "              else:\n"
  "                job.mState = 4 # Completed\n"
  "                index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 1) and (job.mReturnCode > 0) : # terminated with error : exit\n"
  "              jobCount = jobCount - 1\n"
  "              job.mState = 4 # Means Terminated\n"
  "              index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 3) and (job.mReturnCode == 0): # post command is terminated without error\n"
  "              jobCount = jobCount - 1\n"
  "              job.mPostCommands.pop (0) # Remove completed post command\n"
  "              if len (job.mPostCommands) > 0:\n"
  "                job.mState = 2 # Ready to execute next post command\n"
  "              else:\n"
  "                job.mState = 4 # Completed\n"
  "                index = index - 1 # For removing job from list\n"
  "            elif (job.mState == 3) and (job.mReturnCode > 0): # post command is terminated with error\n"
  "              jobCount = jobCount - 1\n"
  "              job.mState = 4 # Completed\n"
  "              index = index - 1 # For removing job from list\n"
  "            elif job.mState == 4: # Completed: delete job\n"
  "              index = index - 1\n"
  "              self.mJobList.pop (index) # Remove terminated job\n"
  "              #displayLock.acquire ()\n"
  "              #print \"Completed '\" + job.mTitle + \"'\"\n"
  "              #--- Remove dependences from this job\n"
  "              idx = 0\n"
  "              while idx < len (self.mJobList):\n"
  "                aJob = self.mJobList [idx]\n"
  "                idx = idx + 1\n"
  "                while aJob.mRequiredFiles.count (job.mTarget) > 0 :\n"
  "                  aJob.mRequiredFiles.remove (job.mTarget)\n"
  "                  #print \"  Removed from '\" + aJob.mTitle + \"': \" + str (len (aJob.mRequiredFiles))\n"
  "              #displayLock.release ()\n"
  "              #--- Signal error \?\n"
  "              if (job.mReturnCode > 0) and (returnCode == 0):\n"
  "                self.mErrorCount = self.mErrorCount + 1\n"
  "                print BOLD_RED () + \"Return code: \" + str (job.mReturnCode) + ENDC ()\n"
  "                if (returnCode == 0) and (jobCount > 0) :\n"
  "                  print \"Wait for job termination...\"\n"
  "                returnCode = job.mReturnCode\n"
  "          loop = (len (self.mJobList) > 0) if (returnCode == 0) else (jobCount > 0)\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def searchFileInDirectories (self, file, directoryList): # returns \"\" if not found, register error\n"
  "    matchCount = 0\n"
  "    result = \"\"\n"
  "    for sourceDir in directoryList:\n"
  "      sourcePath = sourceDir + \"/\" + file\n"
  "      if os.path.exists (os.path.abspath (sourcePath)):\n"
  "        matchCount = matchCount + 1\n"
  "        result = sourcePath\n"
  "    if matchCount == 0:\n"
  "      print BOLD_RED () + \"Cannot find '\" + file + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "    elif matchCount > 1:\n"
  "      print BOLD_RED () + str (matchCount) + \" source files for making '\" + file + \"'\" + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "      result = \"\"\n"
  "    return result\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def addGoal (self, goal, targetList, message):\n"
  "    self.mGoals [goal] = (targetList, message)\n"
  "    #print '%s' % ', '.join(map(str, self.mGoals))\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printGoals (self):\n"
  "    print BOLD_BLUE () + \"--- Print the \" + str (len (self.mGoals)) + \" goal\" + (\"s\" if len (self.mGoals) > 1 else \"\") + \" ---\" + ENDC ()\n"
  "    for goalKey in self.mGoals.keys ():\n"
  "      print BOLD_GREEN () + \"Goal: '\" + goalKey + \"'\" + ENDC ()\n"
  "      (targetList, message) = self.mGoals [goalKey]\n"
  "      for target in targetList:\n"
  "        print \"  Target: '\" + target + \"'\"\n"
  "      print \"  Message: '\" + message + \"'\"\n"
  "        \n"
  "    print BOLD_BLUE () + \"--- End of print goals ---\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def runGoal (self, goal, maxConcurrentJobs, showCommand):\n"
  "    if self.mGoals.has_key (goal) :\n"
  "      (targetList, message) = self.mGoals [goal]\n"
  "      for target in targetList:\n"
  "        self.makeJob (target)\n"
  "      self.runJobs (maxConcurrentJobs, showCommand)\n"
  "    else:\n"
  "      errorMessage = \"The '\" + goal + \"' goal is not defined; defined goals:\"\n"
  "      for key in self.mGoals:\n"
  "        (targetList, message) = self.mGoals [key]\n"
  "        errorMessage += \"\\n  '\" + key + \"': \" + message\n"
  "      print BOLD_RED () + errorMessage + ENDC ()\n"
  "      self.mErrorCount = self.mErrorCount + 1\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def enterError (self, message):\n"
  "    print BOLD_RED () + message + ENDC ()\n"
  "    self.mErrorCount = self.mErrorCount + 1\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printErrorCountAndExitOnError (self):\n"
  "    if self.mErrorCount == 1:\n"
  "      print BOLD_RED () + \"1 error.\" + ENDC ()\n"
  "      sys.exit (1)\n"
  "    elif self.mErrorCount > 1:\n"
  "      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n"
  "      sys.exit (1)\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def printErrorCount (self):\n"
  "    if self.mErrorCount == 1:\n"
  "      print BOLD_RED () + \"1 error.\" + ENDC ()\n"
  "    elif self.mErrorCount > 1:\n"
  "      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n"
  "\n"
  "  #--------------------------------------------------------------------------*\n"
  "\n"
  "  def errorCount (self):\n"
  "    return self.mErrorCount\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Source files                                                                                                       *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def sourceList ():\n"
  "  return [\"plm.c\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Product directory                                                                                                  *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def productDir ():\n"
  "  return \"product\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#                         Object files directories                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def objectDir ():\n"
  "  return \"objects\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#                         Object files directories                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def asDir ():\n"
  "  return \"as\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Tool dir                                                                                                           *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def toolDir ():\n"
  "  return os.path.expanduser (\"~/plm-tools/plm-teensy-x86_64-Darwin-binutils-2.25-gcc-5.1.0-newlib-2.2.0-libusb-1.0.19\")\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Compiler invocation                                                                                                *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def compiler ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-gcc\", \"-mthumb\", \"-mcpu=cortex-m4\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Display object size invocation                                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def displayObjectSize ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-size\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#    C Compiler options                                                                                                *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def cCompilerOptions ():\n"
  "  result = []\n"
  "  result.append (\"-Wall\")\n"
  "  result.append (\"-Werror\")\n"
  "  result.append (\"-Wreturn-type\")\n"
  "  result.append (\"-Wformat\")\n"
  "  result.append (\"-Wsign-compare\")\n"
  "  result.append (\"-Wpointer-arith\")\n"
  "  result.append (\"-Wparentheses\")\n"
  "  result.append (\"-Wcast-align\")\n"
  "  result.append (\"-Wcast-qual\")\n"
  "  result.append (\"-Wwrite-strings\")\n"
  "  result.append (\"-Wswitch\")\n"
  "  result.append (\"-Wuninitialized\")\n"
  "  result.append (\"-fno-builtin\")\n"
  "  result.append (\"-Wno-aggressive-loop-optimizations\")\n"
  "  result.append (\"-ffunction-sections\")\n"
  "  result.append (\"-fdata-sections\")\n"
  "  result.append (\"-std=c99\")\n"
  "  result.append (\"-Wstrict-prototypes\")\n"
  "  result.append (\"-Wbad-function-cast\")\n"
  "  result.append (\"-Wmissing-declarations\")\n"
  "  result.append (\"-Wimplicit-function-declaration\")\n"
  "  result.append (\"-Wno-int-to-pointer-cast\")\n"
  "  result.append (\"-Wno-pointer-to-int-cast\")\n"
  "  result.append (\"-Wmissing-prototypes\")\n"
  "  result.append (\"-Os\")\n"
  "  result.append (\"-fomit-frame-pointer\")\n"
  "  result.append (\"-foptimize-register-move\") \n"
  "  result.append (\"-I../build\")\n"
  "  return result\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Linker invocation                                                                                                  *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def linker ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-gcc\", \"-mthumb\", \"-mcpu=cortex-m4\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Linker options                                                                                                     *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def linkerOptions ():\n"
  "  result = []\n"
  "  result.append (\"-nostartfiles\")\n"
  "  result.append (\"-Wl,--fatal-warnings\")\n"
  "  result.append (\"-Wl,--warn-common\")\n"
  "  result.append (\"-Wl,--no-undefined\")\n"
  "  result.append (\"-Wl,--cref\")\n"
  "  result.append (\"-lc\")\n"
  "  result.append (\"-lgcc\")\n"
  "  result.append (\"-Wl,-static\")\n"
  "  result.append (\"-Wl,-s\")\n"
  "  result.append (\"-Wl,--gc-sections\")\n"
  "  return result\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   objcopy invocation                                                                                                 *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def objcopy ():\n"
  "  return [toolDir () + \"/bin/arm-eabi-objcopy\"]\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   Teensy loader                                                                                                      *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def teensyLoader ():\n"
  "  return toolDir () + \"/bin/teensy-loader-cli\"\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#   ARCHIVE DOWNLOAD                                                                                                   *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def downloadReportHook (a,b,fileSize): \n"
  "  if fileSize < (1 << 10):\n"
  "    sizeString = str (fileSize)\n"
  "  else:\n"
  "    if fileSize < (1 << 20):\n"
  "      sizeString = str (fileSize >> 10) + \"Ki\"\n"
  "    else:\n"
  "      sizeString = str (fileSize >> 20) + \"Mi\"\n"
  "  # \",\" at the end of the line is important!\n"
  "  print \"% 3.1f%% of %sB\\r\" % (min(100.0, float(a * b) / fileSize * 100.0), sizeString),\n"
  "  sys.stdout.flush()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def downloadArchive (archiveURL, archivePath):\n"
  "  runSingleCommand ([\"rm\", \"-f\", archivePath + \".downloading\"])\n"
  "  runSingleCommand ([\"rm\", \"-f\", archivePath + \".tar.bz2\"])\n"
  "  runSingleCommand ([\"mkdir\", \"-p\", os.path.dirname (archivePath)])\n"
  "  print \"URL: \"+ archiveURL\n"
  "  print \"Downloading... \" + archivePath + \".downloading\"\n"
  "  urllib.urlretrieve (archiveURL,  archivePath + \".downloading\", downloadReportHook)\n"
  "  print \"\"\n"
  "  fileSize = os.path.getsize (archivePath + \".downloading\")\n"
  "  ok = fileSize > 1000000\n"
  "  if ok:\n"
  "    runSingleCommand ([\"mv\", archivePath + \".downloading\", archivePath + \".tar.bz2\"])\n"
  "  else:\n"
  "    print BOLD_RED () + \"Error: cannot download file\" + ENDC ()\n"
  "    sys.exit (1)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "#                                                                                                                      *\n"
  "#   MAIN                                                                                                               *\n"
  "#                                                                                                                      *\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Get max parallel jobs as first argument\n"
  "goal = \"all\"\n"
  "if len (sys.argv) > 1 :\n"
  "  goal = sys.argv [1]\n"
  "#--- Get max parallel jobs as first argument\n"
  "maxParallelJobs = 0 # 0 means use host processor count\n"
  "if len (sys.argv) > 2 :\n"
  "  maxParallelJobs = int (sys.argv [2])\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "#--- Download compiler tool if needed\n"
  "toolDirectory = toolDir ()\n"
  "if not os.path.exists (toolDirectory):\n"
  "  print BOLD_GREEN () + \"Downloading compiler tool chain\" + ENDC ()\n"
  "  archiveName = os.path.basename (toolDirectory)\n"
  "  archiveURL = \"http://crossgcc.rts-software.org/downloads/plm-tools/\" + archiveName + \".tar.bz2\"\n"
  "  downloadArchive (archiveURL, toolDirectory)\n"
  "  installDir = os.path.normpath (toolDirectory + \"/..\")\n"
  "  os.chdir (installDir)\n"
  "  runSingleCommand ([\"bunzip2\", \"-k\", archiveName + \".tar.bz2\"])\n"
  "  runSingleCommand ([\"rm\", archiveName + \".tar.bz2\"])\n"
  "  runSingleCommand ([\"tar\", \"xf\", archiveName + \".tar\"])\n"
  "  runSingleCommand ([\"rm\", archiveName + \".tar\"])\n"
  "#---\n"
  "os.chdir (scriptDir)\n"
  "#--- Build python makefile\n"
  "makefile = Make ()\n"
  "#--- Add C files compile rule\n"
  "objectList = []\n"
  "asObjectList = []\n"
  "for source in sourceList ():\n"
  "#--- Compile\n"
  "  object = objectDir () + \"/\" + source + \".o\"\n"
  "  rule = Rule (object, \"Compiling \" + source)\n"
  "  rule.mDependences.append (\"sources/\" + source)\n"
  "  rule.mCommand += compiler ()\n"
  "  rule.mCommand += cCompilerOptions ()\n"
  "  rule.mCommand += [\"-c\", \"sources/\" + source]\n"
  "  rule.mCommand += [\"-o\", object]\n"
  "  rule.enterSecondaryDependanceFile (object + \".dep\")\n"
  "  makefile.addRule (rule)\n"
  "  objectList.append (object)\n"
  "#--- Assembling\n"
  "  asObject = asDir () + \"/\" + source + \".s\"\n"
  "  rule = Rule (asObject, \"Assembling \" + source)\n"
  "  rule.mDependences.append (\"sources/\" + source)\n"
  "  rule.mCommand += compiler ()\n"
  "  rule.mCommand += cCompilerOptions ()\n"
  "  rule.mCommand += [\"-S\", \"sources/\" + source]\n"
  "  rule.mCommand += [\"-o\", asObject]\n"
  "  rule.enterSecondaryDependanceFile (asObject + \".dep\")\n"
  "  makefile.addRule (rule)\n"
  "  asObjectList.append (asObject)\n"
  "#--- Add linker rule\n"
  "productELF = productDir () + \"/product.elf\"\n"
  "rule = Rule (productELF, \"Linking \" + productELF)\n"
  "rule.mDependences += objectList\n"
  "rule.mCommand += linker ()\n"
  "rule.mCommand += linkerOptions ()\n"
  "rule.mCommand += objectList\n"
  "rule.mCommand += [\"-o\", productELF]\n"
  "rule.mCommand += [\"-Tsources/linker-script.ld\"]\n"
  "rule.mCommand += [\"-Wl,-Map=\" + productELF + \".map\"]\n"
  "makefile.addRule (rule)\n"
  "#--- Add objcopy rule\n"
  "productHEX = productDir () + \"/product.ihex\"\n"
  "rule = Rule (productHEX, \"Hexing \" + productHEX)\n"
  "rule.mDependences += [productELF]\n"
  "rule.mCommand += objcopy ()\n"
  "rule.mCommand += [\"-O\", \"ihex\"]\n"
  "rule.mCommand += [productELF]\n"
  "rule.mCommand += [productHEX]\n"
  "makefile.addRule (rule)\n"
  "#--- Add goals\n"
  "makefile.addGoal (\"run\", [productHEX], \"Building all and run\")\n"
  "makefile.addGoal (\"all\", [productHEX], \"Building all\")\n"
  "makefile.addGoal (\"as\", asObjectList, \"Assembling C files\")\n"
  "makefile.addGoal (\"display-obj-size\", [productHEX], \"Display Object Size\")\n"
  "#--- Build\n"
  "#makefile.printRules ()\n"
  "makefile.runGoal (goal, maxParallelJobs, maxParallelJobs == 1)\n"
  "#--- Build Ok \?\n"
  "makefile.printErrorCountAndExitOnError ()\n"
  "#--- Run \?\n"
  "if goal == \"run\":\n"
  "  print BOLD_BLUE () + \"Loading Teensy...\" + ENDC ()\n"
  "  childProcess = subprocess.Popen ([teensyLoader (), \"-w\", \"-v\", \"-mmcu=mk20dx128\", productHEX])\n"
  "#--- Wait for subprocess termination\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    print BOLD_RED () + \"Error \" + str (childProcess.returncode) + ENDC ()\n"
  "    sys.exit (childProcess.returncode)\n"
  "  else:\n"
  "    print BOLD_GREEN () + \"Success\" + ENDC ()\n"
  "elif goal == \"display-obj-size\":\n"
  "  print BOLD_BLUE () + \"Display Object Sizes\" + ENDC ()\n"
  "  childProcess = subprocess.Popen (displayObjectSize () + objectList + [\"-t\"])\n"
  "#--- Wait for subprocess termination\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.wait ()\n"
  "  if childProcess.returncode != 0 :\n"
  "    print BOLD_RED () + \"Error \" + str (childProcess.returncode) + ENDC ()\n"
  "    sys.exit (childProcess.returncode)\n"
  "  else:\n"
  "    print BOLD_GREEN () + \"Success\" + ENDC ()\n" ;

const cRegularFileWrapper gWrapperFile_16_targetTemplates (
  "build.py",
  "py",
  true, // Text file
  42967, // Text length
  gWrapperFileContent_16_targetTemplates
) ;

//--- File 'target-teensy-sequential-systick/clean.py'

const char * gWrapperFileContent_17_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "#--- Directories to clean\n"
  "dir1 = scriptDir + \"/objects\"\n"
  "dir2 = scriptDir + \"/product\"\n"
  "dir3 = scriptDir + \"/as\"\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"rm\", \"-fr\", dir1, dir2, dir3], cwd=scriptDir)\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_17_targetTemplates (
  "clean.py",
  "py",
  true, // Text file
  1264, // Text length
  gWrapperFileContent_17_targetTemplates
) ;

//--- File 'target-teensy-sequential-systick/display-obj-size.py'

const char * gWrapperFileContent_18_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"display-obj-size\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_18_targetTemplates (
  "display-obj-size.py",
  "py",
  true, // Text file
  1010, // Text length
  gWrapperFileContent_18_targetTemplates
) ;

//--- File 'target-teensy-sequential-systick/flash-teensy-and-run.py'

const char * gWrapperFileContent_19_targetTemplates = "#! /usr/bin/env python\n"
  "# -*- coding: UTF-8 -*-\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "# https://docs.python.org/2/library/subprocess.html#module-subprocess\n"
  "\n"
  "import subprocess\n"
  "import sys\n"
  "import os\n"
  "import atexit\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "def cleanup():\n"
  "  if childProcess.poll () == None :\n"
  "    childProcess.kill ()\n"
  "\n"
  "#------------------------------------------------------------------------------*\n"
  "\n"
  "#--- Register a function for killing subprocess\n"
  "atexit.register (cleanup)\n"
  "#--- Get script absolute path\n"
  "scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n"
  "os.chdir (scriptDir)\n"
  "#---\n"
  "childProcess = subprocess.Popen ([\"python\", \"build.py\", \"run\"])\n"
  "#--- Wait for subprocess termination\n"
  "if childProcess.poll () == None :\n"
  "  childProcess.wait ()\n"
  "if childProcess.returncode != 0 :\n"
  "  sys.exit (childProcess.returncode)\n"
  "\n"
  "#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_19_targetTemplates (
  "flash-teensy-and-run.py",
  "py",
  true, // Text file
  997, // Text length
  gWrapperFileContent_19_targetTemplates
) ;

//--- File 'sources/linker-script.ld'

const char * gWrapperFileContent_20_targetTemplates = "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                   Memory                                   */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "MEMORY {\n"
  "  flash (rx) : ORIGIN = 0, LENGTH = 256k \n"
  "  sram_u (rwx) : ORIGIN = 0x20000000, LENGTH = 32k \n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "__sram_u_end = 0x20000000 + 32k ;\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                ISR Vectors                                 */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .vectors : {\n"
  "    __vectors_start = . ;\n"
  "    KEEP (*(.isr_vector)) ;\n"
  "    __vectors_end = . ;\n"
  "  } > flash\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                    Code                                    */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .text : {\n"
  "    FILL(0xff)\n"
  "    __code_start = . ;\n"
  "  /*--- Tableau des routines d'initialisation */\n"
  "    . = ALIGN (4) ;\n"
  "    __init_routine_array_start = . ;\n"
  "    KEEP (*(init_routine_array)) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __init_routine_array_end = . ;\n"
  "  /*--- Initialisation des objets globaux C++ */\n"
  "    . = ALIGN (4) ;\n"
  "    __constructor_array_start = . ;\n"
  "    KEEP (*(.init_array)) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __constructor_array_end = . ;\n"
  "  /*--- Real Interrupt Service Routine Array */\n"
  "    . = ALIGN (4) ;\n"
  "    __real_time_isr_array_start = . ;\n"
  "    KEEP (*(real_time_isr_array)) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __real_time_isr_array_end = . ;\n"
  "  /*--- Code */\n"
  "    *(.text.*) ;\n"
  "    *(.text) ;\n"
  "    *(text) ;\n"
  "    *(.gnu.linkonce.t.*) ;\n"
  "  /*---- ROM data ----*/\n"
  "    . = ALIGN(4);\n"
  "    *(.rodata);\n"
  "    . = ALIGN(4);\n"
  "    *(.rodata*);\n"
  "    . = ALIGN(4);\n"
  "    *(.gnu.linkonce.r.*);\n"
  "    . = ALIGN(4);\n"
  "    *(.glue_7t);\n"
  "    . = ALIGN(4);\n"
  "    *(.glue_7);\n"
  "    . = ALIGN(4);\n"
  "  } > flash\n"
  "\n"
  "  .ARM.exidx : {\n"
  "    *(.ARM.exidx* .gnu.linkonce.armexidx.*);\n"
  "    __code_end = . ;\n"
  "  } > flash\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                          Data (initialized data)                           */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .data : {\n"
  "    FILL (0xFF)\n"
  "    . = ALIGN (4) ;\n"
  "    __data_start = . ;\n"
  "    * (.data.*init*) ;\n"
  "    * (.data*) ;\n"
  "    . = ALIGN (4) ;\n"
  "    __data_end = . ;\n"
  "  } > sram_u AT > flash\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "__data_load_start = LOADADDR (.data) ;\n"
  "__data_load_end   = LOADADDR (.data) + SIZEOF (.data) ;\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                          BSS (uninitialized data)                          */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .bss : {\n"
  "    . = ALIGN(4);\n"
  "    __bss_start = . ;\n"
  "    * (.bss.*) ;\n"
  "    * (.bss) ;\n"
  "    * (COMMON) ;\n"
  "    . = ALIGN(4);\n"
  "    __bss_end = . ;\n"
  "  } > sram_u\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                System stack                                */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .system_stack :{\n"
  "    . = ALIGN (4) ;\n"
  "    __system_stack_start = . ;\n"
  "    . += 1k ;\n"
  "    . = ALIGN (4) ;\n"
  "    __system_stack_end = . ;\n"
  "  } > sram_u\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "/*                                                                            */\n"
  "/*                                    Heap                                    */\n"
  "/*                                                                            */\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "SECTIONS {\n"
  "  .heap : {\n"
  "    . = ALIGN (4) ;\n"
  "    __heap_start = . ;\n"
  "  } > sram_u\n"
  "}\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n"
  "\n"
  "__heap_end = __sram_u_end ;\n"
  "\n"
  "/*----------------------------------------------------------------------------*/\n" ;

const cRegularFileWrapper gWrapperFile_20_targetTemplates (
  "linker-script.ld",
  "ld",
  true, // Text file
  5218, // Text length
  gWrapperFileContent_20_targetTemplates
) ;

//--- File 'sources/startup-sequential-systick.c'

const char * gWrapperFileContent_21_targetTemplates = "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "// Chapter 12: System Integration Module (SIM)\n"
  "#define SIM_SCGC3\t\t*(volatile uint32_t *)0x40048030 // System Clock Gating Control Register 3\n"
  "#define SIM_SCGC3_ADC1\t\t\t(uint32_t)0x08000000\t\t// ADC1 Clock Gate Control\n"
  "#define SIM_SCGC3_FTM2\t\t\t(uint32_t)0x01000000\t\t// FTM2 Clock Gate Control\n"
  "\n"
  "#define SIM_SCGC5\t\t*(volatile uint32_t *)0x40048038 // System Clock Gating Control Register 5\n"
  "\n"
  "#define SIM_SCGC6\t\t*(volatile uint32_t *)0x4004803C // System Clock Gating Control Register 6\n"
  "#define SIM_SCGC6_RTC\t\t\t(uint32_t)0x20000000\t\t// RTC Access\n"
  "#define SIM_SCGC6_ADC0\t\t\t(uint32_t)0x08000000\t\t// ADC0 Clock Gate Control\n"
  "#define SIM_SCGC6_FTM1\t\t\t(uint32_t)0x02000000\t\t// FTM1 Clock Gate Control\n"
  "#define SIM_SCGC6_FTM0\t\t\t(uint32_t)0x01000000\t\t// FTM0 Clock Gate Control\n"
  "#define SIM_SCGC6_FTFL\t\t\t(uint32_t)0x00000001\t\t// Flash Memory Clock Gate Control\n"
  "\n"
  "#define SIM_CLKDIV1\t\t*(volatile uint32_t *)0x40048044 // System Clock Divider Register 1\n"
  "#define SIM_CLKDIV1_OUTDIV1(n)\t\t(uint32_t)(((n) & 0x0F) << 28)\t// divide value for the core/system clock\n"
  "#define SIM_CLKDIV1_OUTDIV2(n)\t\t(uint32_t)(((n) & 0x0F) << 24)\t// divide value for the peripheral clock\n"
  "#define SIM_CLKDIV1_OUTDIV4(n)\t\t(uint32_t)(((n) & 0x0F) << 16)\t// divide value for the flash clock\n"
  "\n"
  "// Chapter 15: Power Management Controller\n"
  "#define PMC_REGSC\t\t*(volatile uint8_t  *)0x4007D002 // Regulator Status And Control register\n"
  "#define PMC_REGSC_ACKISO\t\t(uint8_t)0x08\t\t\t// Acknowledge Isolation\n"
  "\n"
  "// Chapter 24: Multipurpose Clock Generator (MCG)\n"
  "#define MCG_C1\t\t\t*(volatile uint8_t  *)0x40064000 // MCG Control 1 Register\n"
  "#define MCG_C1_FRDIV(n)\t\t\t(uint8_t)(((n) & 0x07) << 3)\t// FLL External Reference Divider, Selects the amount to divide down the external reference clo"
  "ck for the FLL\n"
  "#define MCG_C1_CLKS(n)\t\t\t(uint8_t)(((n) & 0x03) << 6)\t// Clock Source Select, Selects the clock source for MCGOUTCLK\n"
  "\n"
  "#define MCG_C2\t\t\t*(volatile uint8_t  *)0x40064001 // MCG Control 2 Register\n"
  "#define MCG_C2_RANGE0(n)\t\t(uint8_t)(((n) & 0x03) << 4)\t// Frequency Range Select, Selects the frequency range for the crystal oscillator\n"
  "#define MCG_C2_EREFS\t\t\t(uint8_t)0x04\t\t\t// External Reference Select, Selects the source for the external reference clock. \n"
  "\n"
  "#define MCG_C5\t\t\t*(volatile uint8_t  *)0x40064004 // MCG Control 5 Register\n"
  "#define MCG_C5_PRDIV0(n)\t\t(uint8_t)((n) & 0x1F)\t\t// PLL External Reference Divider\n"
  "\n"
  "#define MCG_C6\t\t\t*(volatile uint8_t  *)0x40064005 // MCG Control 6 Register\n"
  "#define MCG_C6_PLLS\t\t\t(uint8_t)0x40\t\t\t// PLL Select, Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00. \n"
  "#define MCG_C6_VDIV0(n)\t\t\t(uint8_t)((n) & 0x1F)\t\t// VCO 0 Divider\n"
  "\n"
  "// Chapter 25: Oscillator (OSC)\n"
  "#define OSC0_CR\t\t\t*(volatile uint8_t  *)0x40065000 // OSC Control Register\n"
  "#define OSC_SC8P\t\t\t(uint8_t)0x02\t\t\t// Oscillator 8 pF Capacitor Load Configure\n"
  "#define OSC_SC4P\t\t\t(uint8_t)0x04\t\t\t// Oscillator 4 pF Capacitor Load Configure\n"
  "#define OSC_SC2P\t\t\t(uint8_t)0x08\t\t\t// Oscillator 2 pF Capacitor Load Configure\n"
  "\n"
  "// Chapter 23: Watchdog Timer (WDOG)\n"
  "#define WDOG_STCTRLH\t\t*(volatile uint16_t *)0x40052000 // Watchdog Status and Control Register High\n"
  "#define WDOG_UNLOCK\t\t*(volatile uint16_t *)0x4005200E // Watchdog Unlock register\n"
  "#define WDOG_UNLOCK_SEQ1\t\t(uint16_t)0xC520\n"
  "#define WDOG_UNLOCK_SEQ2\t\t(uint16_t)0xD928\n"
  "\n"
  "// Chapter 24: Multipurpose Clock Generator (MCG)\n"
  "#define MCG_S\t\t\t*(volatile uint8_t  *)0x40064006 // MCG Status Register\n"
  "#define MCG_S_IRCST\t\t\t(uint8_t)0x01\t\t\t// Internal Reference Clock Status\n"
  "#define MCG_S_OSCINIT0\t\t\t(uint8_t)0x02\t\t\t// OSC Initialization,\tresets to 0, is set to 1 after the initialization cycles of the crystal oscillator\n"
  "#define MCG_S_CLKST(n)\t\t\t(uint8_t)(((n) & 0x03) << 2)\t// Clock Mode Status, 0=FLL is selected, 1= Internal ref, 2=External ref, 3=PLL\n"
  "#define MCG_S_CLKST_MASK\t\t(uint8_t)0x0C\n"
  "#define MCG_S_IREFST\t\t\t(uint8_t)0x10\t\t\t// Internal Reference Status\n"
  "#define MCG_S_PLLST\t\t\t(uint8_t)0x20\t\t\t// PLL Select Status\n"
  "#define MCG_S_LOCK0\t\t\t(uint8_t)0x40\t\t\t// Lock Status, 0=PLL Unlocked, 1=PLL Locked\n"
  "\n"
  "// Chapter 39: Real Time Clock (RTC)\n"
  "#define RTC_CR\t\t\t*(volatile uint32_t *)0x4003D010 // RTC Control Register\n"
  "#define RTC_CR_SC4P\t\t\t(uint32_t)0x00001000\t\t// \n"
  "#define RTC_CR_SC16P\t\t\t(uint32_t)0x00000400\t\t// \n"
  "#define RTC_CR_OSCE\t\t\t(uint32_t)0x00000100\t\t// \n"
  "\n"
  "#define RTC_SR\t\t\t*(volatile uint32_t *)0x4003D014 // RTC Status Register\n"
  "\n"
  "#define SYST_CSR\t\t*(volatile uint32_t *)0xE000E010 // SysTick Control and Status\n"
  "//#define SYST_CSR_COUNTFLAG\t\t(uint32_t)0x00010000\n"
  "#define SYST_CSR_CLKSOURCE\t\t(uint32_t)0x00000004\n"
  "#define SYST_CSR_TICKINT\t\t(uint32_t)0x00000002\n"
  "#define SYST_CSR_ENABLE\t\t\t(uint32_t)0x00000001\n"
  "#define SYST_RVR\t\t*(volatile uint32_t *)0xE000E014 // SysTick Reload Value Register\n"
  "#define SYST_CVR\t\t*(volatile uint32_t *)0xE000E018 // SysTick Current Value Register\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "static void ResetISR (void) {\n"
  "//---------1- Inhiber le chien de garde\n"
  "  WDOG_UNLOCK = WDOG_UNLOCK_SEQ1 ;\n"
  "  WDOG_UNLOCK = WDOG_UNLOCK_SEQ2 ;\n"
  "  WDOG_STCTRLH = 0x0010 ;\n"
  "  // enable clocks to always-used peripherals\n"
  "  SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;\n"
  "  SIM_SCGC5 = 0x00043F82;    // clocks active to all GPIO\n"
  "  SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;\n"
  "  // if the RTC oscillator isn't enabled, get it started early\n"
  "  if (!(RTC_CR & RTC_CR_OSCE)) {\n"
  "    RTC_SR = 0;\n"
  "    RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;\n"
  "  }\n"
  "\n"
  "  // release I/O pins hold, if we woke up from VLLS mode\n"
  "  if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;\n"
  "\n"
  "  // TODO: do this while the PLL is waiting to lock....\n"
  "//  SCB_VTOR = 0;  // use vector table in flash\n"
  "\n"
  "  // default all interrupts to medium priority level\n"
  "//  for (int32_t i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);\n"
  "//---------2- Initialisation de la PLL\n"
  "  // start in FEI mode\n"
  "  // enable capacitors for crystal\n"
  "  OSC0_CR = OSC_SC8P | OSC_SC2P;\n"
  "  // enable osc, 8-32 MHz range, low power mode\n"
  "  MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;\n"
  "  // switch to crystal as clock source, FLL input = 16 MHz / 512\n"
  "  MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);\n"
  "  // wait for crystal oscillator to begin\n"
  "  while ((MCG_S & MCG_S_OSCINIT0) == 0) ;\n"
  "  // wait for FLL to use oscillator\n"
  "  while ((MCG_S & MCG_S_IREFST) != 0) ;\n"
  "  // wait for MCGOUT to use oscillator\n"
  "  while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;\n"
  "  // now we're in FBE mode\n"
  "  // config PLL input for 16 MHz Crystal / 4 = 4 MHz\n"
  "  MCG_C5 = MCG_C5_PRDIV0(3);\n"
  "  // config PLL for 96 MHz output\n"
  "  MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0);\n"
  "  // wait for PLL to start using xtal as its input\n"
  "  while (!(MCG_S & MCG_S_PLLST)) ;\n"
  "  // wait for PLL to lock\n"
  "  while (!(MCG_S & MCG_S_LOCK0)) ;\n"
  "  // now we're in PBE mode\n"
  "  // config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash\n"
  "  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) |   SIM_CLKDIV1_OUTDIV4(3);\n"
  "  // switch to PLL as clock source, FLL input = 16 MHz / 512\n"
  "  MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);\n"
  "  // wait for PLL clock to be used\n"
  "  while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;\n"
  "  // now we're in PEE mode\n"
  "  // configure USB for 48 MHz clock\n"
  "//  SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1); // USB = 96 MHz PLL / 2\n"
  "  // USB uses PLL clock, trace is CPU clock, CLKOUT=OSCERCLK0\n"
  "//  SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);\n"
  "\n"
  "//---------3- Initialisation de la section .bss\n"
  "  extern unsigned __bss_start ;\n"
  "  extern unsigned __bss_end ;\n"
  "  unsigned * p = & __bss_start ;\n"
  "  while (p != & __bss_end) {\n"
  "    * p = 0 ;\n"
  "    p ++ ;\n"
  "  }\n"
  "//---------4- Copy de la section .data\n"
  "  extern unsigned __data_start ;\n"
  "  extern unsigned __data_end ;\n"
  "  extern unsigned __data_load_start ;\n"
  "  unsigned * pSrc = & __data_load_start ;\n"
  "  unsigned * pDest = & __data_start ;\n"
  "  while (pDest != & __data_end) {\n"
  "    * pDest = * pSrc ;\n"
  "    pDest ++ ;\n"
  "    pSrc ++ ;\n"
  "  }\n"
  "\n"
  "//----------- Configure systick interrupt\n"
  "  SYST_RVR = 96000 - 1 ; // Interrupt every 96000 core clocks, i.e. every ms\n"
  "  SYST_CVR = 0 ;\n"
  "  SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE ;\n"
  "\n"
  "//---------5- Ex\xC3""\xA9""cuter les constructeurs des variables globales\n"
  "/*  extern void (* __constructor_array_start) (void) ;\n"
  "  extern void (* __constructor_array_end) (void) ;\n"
  "  void (** ptr) (void) = & __constructor_array_start ;\n"
  "  while (ptr != & __constructor_array_end) {\n"
  "    (* ptr) () ;\n"
  "    ptr ++ ;\n"
  "  } */\n"
  "//---------6- Ex\xC3""\xA9""cuter les routines d'initialisation de la section init_routine_array\n"
  "/*  extern void (* __init_routine_array_start) (void) ;\n"
  "  extern void (* __init_routine_array_end) (void) ;\n"
  "  ptr = & __init_routine_array_start ;\n"
  "  while (ptr != & __init_routine_array_end) {\n"
  "    (* ptr) () ;\n"
  "    ptr ++ ;\n"
  "  } */\n"
  "  init () ;\n"
  "//---------7- Ex\xC3""\xA9""cuter le programme utilisateur\n"
  "  proc_setup () ;\n"
  "  while (1) {\n"
  "    proc_loop () ;\n"
  "  }\n"
  "}\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "//   Vector table                                                                                                      *\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "typedef struct {\n"
  "  unsigned * mStackPointer ;\n"
  "//--- ARM Core System Handler Vectors\n"
  "  void (* mCoreSystemHandlerVector [15]) (void) ;\n"
  "//--- Non-Core Vectors\n"
  "  void (* mNonCoreHandlerVector [240]) (void) ;\n"
  "//--- Flash magic values\n"
  "  int mFlash [4] ;\n"
  "} vectorStructSeq ;\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "extern unsigned __system_stack_end ;\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n"
  "\n"
  "const vectorStructSeq vector __attribute__ ((section (\".isr_vector\"))) = {\n"
  "  & __system_stack_end, // 0\n"
  "//--- ARM Core System Handler Vectors\n"
  "  { ResetISR, // 1\n"
  "    NULL, // 2\n"
  "    NULL, // 3\n"
  "    NULL, // 4\n"
  "    NULL, // 5\n"
  "    NULL, // 6\n"
  "    NULL, // 7\n"
  "    NULL, // 8\n"
  "    NULL, // 9\n"
  "    NULL, // 10\n"
  "    NULL, // 11 (svc)\n"
  "    NULL, // 12\n"
  "    NULL, // 13\n"
  "    NULL, // 14\n"
  "    proc_systickHandler // 15\n"
  "  },\n"
  "//--- Non-Core Vectors\n"
  "  { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n"
  "    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n"
  "  },\n"
  "//--- Flash magic values\n"
  "  {-1, -1, -1, -2}\n"
  "} ;\n"
  "\n"
  "//---------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_21_targetTemplates (
  "startup-sequential-systick.c",
  "c",
  true, // Text file
  12054, // Text length
  gWrapperFileContent_21_targetTemplates
) ;

//--- All files of 'sources' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_6 [3] = {
  & gWrapperFile_20_targetTemplates,
  & gWrapperFile_21_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'sources' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_6 [1] = {
  NULL
} ;

//--- Directory 'sources'

const cDirectoryWrapper gWrapperDirectory_6_targetTemplates (
  "sources",
  2,
  gWrapperAllFiles_targetTemplates_6,
  0,
  gWrapperAllDirectories_targetTemplates_6
) ;

//--- All files of 'target-teensy-sequential-systick' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_5 [7] = {
  & gWrapperFile_14_targetTemplates,
  & gWrapperFile_15_targetTemplates,
  & gWrapperFile_16_targetTemplates,
  & gWrapperFile_17_targetTemplates,
  & gWrapperFile_18_targetTemplates,
  & gWrapperFile_19_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'target-teensy-sequential-systick' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_5 [2] = {
  & gWrapperDirectory_6_targetTemplates,
  NULL
} ;

//--- Directory 'target-teensy-sequential-systick'

const cDirectoryWrapper gWrapperDirectory_5_targetTemplates (
  "target-teensy-sequential-systick",
  6,
  gWrapperAllFiles_targetTemplates_5,
  1,
  gWrapperAllDirectories_targetTemplates_5
) ;

//--- All files of 'targets' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_2 [3] = {
  & gWrapperFile_4_targetTemplates,
  & gWrapperFile_5_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'targets' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_2 [3] = {
  & gWrapperDirectory_3_targetTemplates,
  & gWrapperDirectory_5_targetTemplates,
  NULL
} ;

//--- Directory 'targets'

const cDirectoryWrapper gWrapperDirectory_2_targetTemplates (
  "targets",
  2,
  gWrapperAllFiles_targetTemplates_2,
  2,
  gWrapperAllDirectories_targetTemplates_2
) ;

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_0 [2] = {
  & gWrapperFile_0_targetTemplates,
  NULL
} ;

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_0 [3] = {
  & gWrapperDirectory_1_targetTemplates,
  & gWrapperDirectory_2_targetTemplates,
  NULL
} ;

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_targetTemplates (
  "",
  1,
  gWrapperAllFiles_targetTemplates_0,
  2,
  gWrapperAllDirectories_targetTemplates_0
) ;


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              Routine 'generateTargets'                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_generateTargets (const GALGAS_string constinArgument_inTargetDirectory,
                              const GALGAS_lstring constinArgument_inTargetName,
                              GALGAS_stringlist & outArgument_outFilesToInclude,
                              C_Compiler * inCompiler
                              COMMA_UNUSED_LOCATION_ARGS) {
  outArgument_outFilesToInclude.drop () ; // Release 'out' argument
  outArgument_outFilesToInclude = GALGAS_stringlist::constructor_emptyList (SOURCE_FILE ("target-generation.galgas", 39)) ;
  GALGAS_filewrapper var_fw = GALGAS_filewrapper (gWrapperDirectory_0_targetTemplates) ;
  GALGAS_string var_targetPath = GALGAS_string ("/targets/").add_operation (constinArgument_inTargetName.mAttribute_string.reader_stringByDeletingPathExtension (SOURCE_FILE ("target-generation.galgas", 41)), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 41)) ;
  const enumGalgasBool test_0 = var_fw.reader_directoryExistsAtPath (var_targetPath, inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 42)).boolEnum () ;
  if (kBoolTrue == test_0) {
    cEnumerator_stringlist enumerator_1922 (var_fw.reader_textFilesAtPath (var_targetPath, inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 43)), kEnumeration_up) ;
    while (enumerator_1922.hasCurrentObject ()) {
      GALGAS_string var_s = var_fw.reader_textFileContentsAtPath (var_targetPath.add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 44)).add_operation (enumerator_1922.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 44)), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 44)) ;
      const enumGalgasBool test_1 = GALGAS_bool (kIsEqual, enumerator_1922.current_mValue (HERE).reader_pathExtension (SOURCE_FILE ("target-generation.galgas", 45)).objectCompare (GALGAS_string ("py"))).boolEnum () ;
      if (kBoolTrue == test_1) {
        GALGAS_bool joker_2123 ; // Joker input parameter
        var_s.method_writeToExecutableFileWhenDifferentContents (constinArgument_inTargetDirectory.add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 46)).add_operation (enumerator_1922.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 46)), joker_2123, inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 46)) ;
      }else if (kBoolFalse == test_1) {
        GALGAS_bool joker_2213 ; // Joker input parameter
        var_s.method_writeToFileWhenDifferentContents (constinArgument_inTargetDirectory.add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 47)).add_operation (enumerator_1922.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 47)), joker_2213, inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 47)) ;
      }
      enumerator_1922.gotoNextObject () ;
    }
    GALGAS_string var_sourcePath = var_targetPath.add_operation (GALGAS_string ("/sources"), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 50)) ;
    cEnumerator_stringlist enumerator_2329 (var_fw.reader_textFilesAtPath (var_sourcePath, inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 51)), kEnumeration_up) ;
    while (enumerator_2329.hasCurrentObject ()) {
      GALGAS_string var_s = var_fw.reader_textFileContentsAtPath (var_sourcePath.add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 52)).add_operation (enumerator_2329.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 52)), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 52)) ;
      GALGAS_bool joker_2483 ; // Joker input parameter
      var_s.method_writeToFileWhenDifferentContents (constinArgument_inTargetDirectory.add_operation (GALGAS_string ("/sources/"), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 53)).add_operation (enumerator_2329.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 53)), joker_2483, inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 53)) ;
      const enumGalgasBool test_2 = GALGAS_bool (kIsEqual, enumerator_2329.current_mValue (HERE).reader_pathExtension (SOURCE_FILE ("target-generation.galgas", 54)).objectCompare (GALGAS_string ("c"))).boolEnum () ;
      if (kBoolTrue == test_2) {
        outArgument_outFilesToInclude.addAssign_operation (enumerator_2329.current_mValue (HERE)  COMMA_SOURCE_FILE ("target-generation.galgas", 55)) ;
      }
      enumerator_2329.gotoNextObject () ;
    }
  }else if (kBoolFalse == test_0) {
    GALGAS_string var_s = GALGAS_string ("cannot find this target; available targets:") ;
    cEnumerator_stringlist enumerator_2689 (var_fw.reader_directoriesAtPath (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 60)), kEnumeration_up) ;
    while (enumerator_2689.hasCurrentObject ()) {
      var_s.dotAssign_operation (GALGAS_string ("\n"
        " - ").add_operation (enumerator_2689.current_mValue (HERE), inCompiler COMMA_SOURCE_FILE ("target-generation.galgas", 61))  COMMA_SOURCE_FILE ("target-generation.galgas", 61)) ;
      enumerator_2689.gotoNextObject () ;
    }
    GALGAS_location location_3 (constinArgument_inTargetName.reader_location (HERE)) ; // Implicit use of 'location' reader
    inCompiler->emitSemanticError (location_3, var_s  COMMA_SOURCE_FILE ("target-generation.galgas", 63)) ;
  }
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              Routine 'compileProject'                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_compileProject (const GALGAS_lstring constinArgument_inSourceFile,
                             const GALGAS_ast constinArgument_inAST,
                             const GALGAS_lstring constinArgument_inTargetName,
                             const GALGAS_location constinArgument_inEndOfSourceFile,
                             const GALGAS_string constinArgument_inCurrentDirectory,
                             const GALGAS_stringset constinArgument_inImportedFileAbsolutePathSet,
                             C_Compiler * inCompiler
                             COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_ast var_ast = constinArgument_inAST ;
  GALGAS_stringset var_importedFileAbsolutePathSet = constinArgument_inImportedFileAbsolutePathSet ;
  {
  routine_addTargetSpecificFiles (constinArgument_inTargetName, var_ast, constinArgument_inCurrentDirectory, var_importedFileAbsolutePathSet, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 72)) ;
  }
  {
  routine_addPredefinedTypes (var_ast.mAttribute_mDeclarationList, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 79)) ;
  }
  GALGAS_declarationListAST var_orderedDeclarationListAST ;
  {
  routine_buildOrderedDeclarationList (var_ast.mAttribute_mDeclarationList, var_ast.mAttribute_mProcedureListAST, constinArgument_inEndOfSourceFile, var_orderedDeclarationListAST, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 81)) ;
  }
  const enumGalgasBool test_0 = GALGAS_bool (kIsEqual, GALGAS_uint::constructor_errorCount (SOURCE_FILE ("program.galgas", 88)).objectCompare (GALGAS_uint ((uint32_t) 0U))).boolEnum () ;
  if (kBoolTrue == test_0) {
    GALGAS_globalLiteralStringMap var_globalLiteralStringMap = GALGAS_globalLiteralStringMap::constructor_emptyMap (SOURCE_FILE ("program.galgas", 89)) ;
    GALGAS_semanticContext var_semanticContext ;
    {
    routine_buildSemanticContext (var_orderedDeclarationListAST, var_ast.mAttribute_mProcedureListAST, var_ast.mAttribute_mFunctionListAST, var_ast.mAttribute_mRequiredProcList, var_globalLiteralStringMap, var_semanticContext, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 90)) ;
    }
    const enumGalgasBool test_1 = GALGAS_bool (kIsEqual, GALGAS_uint::constructor_errorCount (SOURCE_FILE ("program.galgas", 99)).objectCompare (GALGAS_uint ((uint32_t) 0U))).boolEnum () ;
    if (kBoolTrue == test_1) {
      GALGAS_intermediateCodeStruct var_intermediateCodeStruct ;
      {
      routine_semanticAnalysis (var_orderedDeclarationListAST, var_ast.mAttribute_mProcedureListAST, var_ast.mAttribute_mFunctionListAST, var_ast.mAttribute_mInitList, var_ast.mAttribute_mException, var_semanticContext, var_ast.mAttribute_mRequiredProcList, constinArgument_inEndOfSourceFile, var_globalLiteralStringMap, var_intermediateCodeStruct, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 100)) ;
      }
      const enumGalgasBool test_2 = GALGAS_bool (kIsEqual, GALGAS_uint::constructor_errorCount (SOURCE_FILE ("program.galgas", 113)).objectCompare (GALGAS_uint ((uint32_t) 0U))).boolEnum () ;
      if (kBoolTrue == test_2) {
        {
        routine_codeOptimisation (var_intermediateCodeStruct, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 114)) ;
        }
        {
        routine_codeGeneration (constinArgument_inSourceFile.mAttribute_string, var_intermediateCodeStruct, constinArgument_inTargetName, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 115)) ;
        }
      }
    }
  }
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            Routine 'addPredefinedTypes'                                             *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_addPredefinedTypes (GALGAS_declarationListAST & ioArgument_ioDeclarationList,
                                 C_Compiler * inCompiler
                                 COMMA_UNUSED_LOCATION_ARGS) {
  ioArgument_ioDeclarationList.addAssign_operation (GALGAS_literalStringDeclaration::constructor_new (function_staticStringTypeName (inCompiler COMMA_SOURCE_FILE ("program.galgas", 131)).reader_nowhere (SOURCE_FILE ("program.galgas", 131))  COMMA_SOURCE_FILE ("program.galgas", 131))  COMMA_SOURCE_FILE ("program.galgas", 131)) ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          Routine 'addTargetSpecificFiles'                                           *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_addTargetSpecificFiles (const GALGAS_lstring constinArgument_inTargetName,
                                     GALGAS_ast & ioArgument_ioAST,
                                     const GALGAS_string constinArgument_inCurrentDirectory,
                                     GALGAS_stringset & ioArgument_ioImportedFileAbsolutePathSet,
                                     C_Compiler * inCompiler
                                     COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string var_targetFilePath = GALGAS_string ("targets/").add_operation (constinArgument_inTargetName.reader_string (SOURCE_FILE ("program.galgas", 142)), inCompiler COMMA_SOURCE_FILE ("program.galgas", 142)) ;
  {
  GALGAS_lstringlist temp_0 = GALGAS_lstringlist::constructor_emptyList (SOURCE_FILE ("program.galgas", 146)) ;
  temp_0.addAssign_operation (GALGAS_lstring::constructor_new (var_targetFilePath, constinArgument_inTargetName.mAttribute_location  COMMA_SOURCE_FILE ("program.galgas", 146))  COMMA_SOURCE_FILE ("program.galgas", 146)) ;
  routine_recursiveImportFiles (ioArgument_ioAST, constinArgument_inCurrentDirectory, temp_0, ioArgument_ioImportedFileAbsolutePathSet, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 143)) ;
  }
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                           Routine 'recursiveImportFiles'                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

void routine_recursiveImportFiles (GALGAS_ast & ioArgument_ioAST,
                                   GALGAS_string inArgument_inCurrentDirectory,
                                   GALGAS_lstringlist inArgument_inImportedClauseList,
                                   GALGAS_stringset & ioArgument_ioImportedFileAbsolutePathSet,
                                   C_Compiler * inCompiler
                                   COMMA_UNUSED_LOCATION_ARGS) {
  cEnumerator_lstringlist enumerator_5750 (inArgument_inImportedClauseList, kEnumeration_up) ;
  while (enumerator_5750.hasCurrentObject ()) {
    GALGAS_string var_absolutePath = enumerator_5750.current_mValue (HERE).mAttribute_string.reader_absolutePathFromPath (inArgument_inCurrentDirectory COMMA_SOURCE_FILE ("program.galgas", 160)) ;
    const enumGalgasBool test_0 = var_absolutePath.reader_fileExists (SOURCE_FILE ("program.galgas", 161)).boolEnum () ;
    if (kBoolTrue == test_0) {
      const enumGalgasBool test_1 = ioArgument_ioImportedFileAbsolutePathSet.reader_hasKey (var_absolutePath COMMA_SOURCE_FILE ("program.galgas", 162)).operator_not (SOURCE_FILE ("program.galgas", 162)).boolEnum () ;
      if (kBoolTrue == test_1) {
        ioArgument_ioImportedFileAbsolutePathSet.addAssign_operation (var_absolutePath  COMMA_SOURCE_FILE ("program.galgas", 163)) ;
        const enumGalgasBool test_2 = GALGAS_bool (kIsEqual, var_absolutePath.reader_pathExtension (SOURCE_FILE ("program.galgas", 164)).objectCompare (GALGAS_string ("plm"))).boolEnum () ;
        if (kBoolTrue == test_2) {
          GALGAS_lstringlist var_importedFileList ;
          var_importedFileList.drop () ;
          GALGAS_location joker_6253 ; // Joker input parameter
          cGrammar_plm_5F_grammar::_performSourceFileParsing_ (inCompiler, GALGAS_lstring::constructor_new (var_absolutePath, enumerator_5750.current_mValue (HERE).mAttribute_location  COMMA_SOURCE_FILE ("program.galgas", 165)), ioArgument_ioAST, var_importedFileList, joker_6253  COMMA_SOURCE_FILE ("program.galgas", 165)) ;
          {
          routine_recursiveImportFiles (ioArgument_ioAST, inArgument_inCurrentDirectory, var_importedFileList, ioArgument_ioImportedFileAbsolutePathSet, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 169)) ;
          }
        }else if (kBoolFalse == test_2) {
          const enumGalgasBool test_3 = GALGAS_bool (kIsEqual, var_absolutePath.reader_pathExtension (SOURCE_FILE ("program.galgas", 175)).objectCompare (GALGAS_string ("plms"))).boolEnum () ;
          if (kBoolTrue == test_3) {
            GALGAS_lstringlist var_importedFileList ;
            var_importedFileList.drop () ;
            GALGAS_location joker_6720 ; // Joker input parameter
            cGrammar_plms_5F_grammar::_performSourceFileParsing_ (inCompiler, GALGAS_lstring::constructor_new (var_absolutePath, enumerator_5750.current_mValue (HERE).mAttribute_location  COMMA_SOURCE_FILE ("program.galgas", 176)), ioArgument_ioAST, var_importedFileList, joker_6720  COMMA_SOURCE_FILE ("program.galgas", 176)) ;
            {
            routine_recursiveImportFiles (ioArgument_ioAST, inArgument_inCurrentDirectory, var_importedFileList, ioArgument_ioImportedFileAbsolutePathSet, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 180)) ;
            }
          }else if (kBoolFalse == test_3) {
            GALGAS_location location_4 (enumerator_5750.current_mValue (HERE).reader_location (HERE)) ; // Implicit use of 'location' reader
            inCompiler->emitSemanticError (location_4, GALGAS_string ("invalid extension (should be .plm or .plms)")  COMMA_SOURCE_FILE ("program.galgas", 187)) ;
          }
        }
      }
    }else if (kBoolFalse == test_0) {
      GALGAS_filewrapper var_fw = GALGAS_filewrapper (gWrapperDirectory_0_targetTemplates) ;
      const enumGalgasBool test_5 = var_fw.reader_fileExistsAtPath (enumerator_5750.current_mValue (HERE).mAttribute_string, inCompiler COMMA_SOURCE_FILE ("program.galgas", 192)).boolEnum () ;
      if (kBoolTrue == test_5) {
        GALGAS_string var_embeddedPath = GALGAS_string (":").add_operation (enumerator_5750.current_mValue (HERE).reader_string (SOURCE_FILE ("program.galgas", 193)), inCompiler COMMA_SOURCE_FILE ("program.galgas", 193)) ;
        const enumGalgasBool test_6 = ioArgument_ioImportedFileAbsolutePathSet.reader_hasKey (var_embeddedPath COMMA_SOURCE_FILE ("program.galgas", 194)).operator_not (SOURCE_FILE ("program.galgas", 194)).boolEnum () ;
        if (kBoolTrue == test_6) {
          ioArgument_ioImportedFileAbsolutePathSet.addAssign_operation (var_embeddedPath  COMMA_SOURCE_FILE ("program.galgas", 195)) ;
          const enumGalgasBool test_7 = GALGAS_bool (kIsEqual, var_absolutePath.reader_pathExtension (SOURCE_FILE ("program.galgas", 196)).objectCompare (GALGAS_string ("plm"))).boolEnum () ;
          if (kBoolTrue == test_7) {
            GALGAS_lstringlist var_importedFileList ;
            var_importedFileList.drop () ;
            GALGAS_location joker_7577 ; // Joker input parameter
            cGrammar_plm_5F_grammar::_performSourceStringParsing_ (inCompiler, var_fw.reader_textFileContentsAtPath (enumerator_5750.current_mValue (HERE).mAttribute_string, inCompiler COMMA_SOURCE_FILE ("program.galgas", 197)), ioArgument_ioAST, var_importedFileList, joker_7577  COMMA_SOURCE_FILE ("program.galgas", 197)) ;
            {
            routine_recursiveImportFiles (ioArgument_ioAST, inArgument_inCurrentDirectory, var_importedFileList, ioArgument_ioImportedFileAbsolutePathSet, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 201)) ;
            }
          }else if (kBoolFalse == test_7) {
            const enumGalgasBool test_8 = GALGAS_bool (kIsEqual, var_absolutePath.reader_pathExtension (SOURCE_FILE ("program.galgas", 207)).objectCompare (GALGAS_string ("plms"))).boolEnum () ;
            if (kBoolTrue == test_8) {
              GALGAS_lstringlist var_importedFileList ;
              var_importedFileList.drop () ;
              GALGAS_location joker_8063 ; // Joker input parameter
              cGrammar_plms_5F_grammar::_performSourceStringParsing_ (inCompiler, var_fw.reader_textFileContentsAtPath (enumerator_5750.current_mValue (HERE).mAttribute_string, inCompiler COMMA_SOURCE_FILE ("program.galgas", 208)), ioArgument_ioAST, var_importedFileList, joker_8063  COMMA_SOURCE_FILE ("program.galgas", 208)) ;
              {
              routine_recursiveImportFiles (ioArgument_ioAST, inArgument_inCurrentDirectory, var_importedFileList, ioArgument_ioImportedFileAbsolutePathSet, inCompiler  COMMA_SOURCE_FILE ("program.galgas", 212)) ;
              }
            }else if (kBoolFalse == test_8) {
              GALGAS_location location_9 (enumerator_5750.current_mValue (HERE).reader_location (HERE)) ; // Implicit use of 'location' reader
              inCompiler->emitSemanticError (location_9, GALGAS_string ("invalid extension (should be .plm or .plms)")  COMMA_SOURCE_FILE ("program.galgas", 219)) ;
            }
          }
        }
      }else if (kBoolFalse == test_5) {
        GALGAS_location location_10 (enumerator_5750.current_mValue (HERE).reader_location (HERE)) ; // Implicit use of 'location' reader
        inCompiler->emitSemanticError (location_10, GALGAS_string ("cannot find this file in file system and in embedded files")  COMMA_SOURCE_FILE ("program.galgas", 223)) ;
      }
    }
    enumerator_5750.gotoNextObject () ;
  }
}


//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*



typeComparisonResult GALGAS_abstractDeclaration::objectCompare (const GALGAS_abstractDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractDeclaration::GALGAS_abstractDeclaration (void) :
AC_GALGAS_class () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractDeclaration::GALGAS_abstractDeclaration (const cPtr_abstractDeclaration * inSourcePtr) :
AC_GALGAS_class (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_abstractDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @abstractDeclaration class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_abstractDeclaration::cPtr_abstractDeclaration (LOCATION_ARGS) :
acPtr_class (THERE) {
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @abstractDeclaration type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_abstractDeclaration ("abstractDeclaration",
                                            NULL) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_abstractDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_abstractDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_abstractDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_abstractDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractDeclaration GALGAS_abstractDeclaration::extractObject (const GALGAS_object & inObject,
                                                                      C_Compiler * inCompiler
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_abstractDeclaration result ;
  const GALGAS_abstractDeclaration * p = (const GALGAS_abstractDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_abstractDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("abstractDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_booleanDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_booleanDeclaration * p = (const cPtr_booleanDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_booleanDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mBooleanTypeName.objectCompare (p->mAttribute_mBooleanTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mAttributeList.objectCompare (p->mAttribute_mAttributeList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_booleanDeclaration::objectCompare (const GALGAS_booleanDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanDeclaration::GALGAS_booleanDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanDeclaration GALGAS_booleanDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_booleanDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                     GALGAS_lstringlist::constructor_emptyList (HERE)
                                                     COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanDeclaration::GALGAS_booleanDeclaration (const cPtr_booleanDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_booleanDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanDeclaration GALGAS_booleanDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mBooleanTypeName,
                                                                      const GALGAS_lstringlist & inAttribute_mAttributeList
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_booleanDeclaration result ;
  if (inAttribute_mBooleanTypeName.isValid () && inAttribute_mAttributeList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_booleanDeclaration (inAttribute_mBooleanTypeName, inAttribute_mAttributeList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_booleanDeclaration::reader_mBooleanTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_booleanDeclaration * p = (const cPtr_booleanDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_booleanDeclaration) ;
    result = p->mAttribute_mBooleanTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_booleanDeclaration::reader_mBooleanTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mBooleanTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist GALGAS_booleanDeclaration::reader_mAttributeList (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstringlist result ;
  if (NULL != mObjectPtr) {
    const cPtr_booleanDeclaration * p = (const cPtr_booleanDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_booleanDeclaration) ;
    result = p->mAttribute_mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist cPtr_booleanDeclaration::reader_mAttributeList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mAttributeList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                     Pointer class for @booleanDeclaration class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_booleanDeclaration::cPtr_booleanDeclaration (const GALGAS_lstring & in_mBooleanTypeName,
                                                  const GALGAS_lstringlist & in_mAttributeList
                                                  COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mBooleanTypeName (in_mBooleanTypeName),
mAttribute_mAttributeList (in_mAttributeList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_booleanDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_booleanDeclaration ;
}

void cPtr_booleanDeclaration::description (C_String & ioString,
                                           const int32_t inIndentation) const {
  ioString << "[@booleanDeclaration:" ;
  mAttribute_mBooleanTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mAttributeList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_booleanDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_booleanDeclaration (mAttribute_mBooleanTypeName, mAttribute_mAttributeList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @booleanDeclaration type                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_booleanDeclaration ("booleanDeclaration",
                                           & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_booleanDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_booleanDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_booleanDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_booleanDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanDeclaration GALGAS_booleanDeclaration::extractObject (const GALGAS_object & inObject,
                                                                    C_Compiler * inCompiler
                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_booleanDeclaration result ;
  const GALGAS_booleanDeclaration * p = (const GALGAS_booleanDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_booleanDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("booleanDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_enumerationDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_enumerationDeclaration * p = (const cPtr_enumerationDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_enumerationDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mEnumerationName.objectCompare (p->mAttribute_mEnumerationName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mAttributeList.objectCompare (p->mAttribute_mAttributeList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mCaseNameList.objectCompare (p->mAttribute_mCaseNameList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_enumerationDeclaration::objectCompare (const GALGAS_enumerationDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationDeclaration::GALGAS_enumerationDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationDeclaration GALGAS_enumerationDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_enumerationDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                         GALGAS_lstringlist::constructor_emptyList (HERE),
                                                         GALGAS_lstringlist::constructor_emptyList (HERE)
                                                         COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationDeclaration::GALGAS_enumerationDeclaration (const cPtr_enumerationDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_enumerationDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationDeclaration GALGAS_enumerationDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mEnumerationName,
                                                                              const GALGAS_lstringlist & inAttribute_mAttributeList,
                                                                              const GALGAS_lstringlist & inAttribute_mCaseNameList
                                                                              COMMA_LOCATION_ARGS) {
  GALGAS_enumerationDeclaration result ;
  if (inAttribute_mEnumerationName.isValid () && inAttribute_mAttributeList.isValid () && inAttribute_mCaseNameList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_enumerationDeclaration (inAttribute_mEnumerationName, inAttribute_mAttributeList, inAttribute_mCaseNameList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_enumerationDeclaration::reader_mEnumerationName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_enumerationDeclaration * p = (const cPtr_enumerationDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_enumerationDeclaration) ;
    result = p->mAttribute_mEnumerationName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_enumerationDeclaration::reader_mEnumerationName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mEnumerationName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist GALGAS_enumerationDeclaration::reader_mAttributeList (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstringlist result ;
  if (NULL != mObjectPtr) {
    const cPtr_enumerationDeclaration * p = (const cPtr_enumerationDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_enumerationDeclaration) ;
    result = p->mAttribute_mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist cPtr_enumerationDeclaration::reader_mAttributeList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mAttributeList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist GALGAS_enumerationDeclaration::reader_mCaseNameList (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstringlist result ;
  if (NULL != mObjectPtr) {
    const cPtr_enumerationDeclaration * p = (const cPtr_enumerationDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_enumerationDeclaration) ;
    result = p->mAttribute_mCaseNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist cPtr_enumerationDeclaration::reader_mCaseNameList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mCaseNameList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                   Pointer class for @enumerationDeclaration class                                   *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_enumerationDeclaration::cPtr_enumerationDeclaration (const GALGAS_lstring & in_mEnumerationName,
                                                          const GALGAS_lstringlist & in_mAttributeList,
                                                          const GALGAS_lstringlist & in_mCaseNameList
                                                          COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mEnumerationName (in_mEnumerationName),
mAttribute_mAttributeList (in_mAttributeList),
mAttribute_mCaseNameList (in_mCaseNameList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_enumerationDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_enumerationDeclaration ;
}

void cPtr_enumerationDeclaration::description (C_String & ioString,
                                               const int32_t inIndentation) const {
  ioString << "[@enumerationDeclaration:" ;
  mAttribute_mEnumerationName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mAttributeList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mCaseNameList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_enumerationDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_enumerationDeclaration (mAttribute_mEnumerationName, mAttribute_mAttributeList, mAttribute_mCaseNameList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            @enumerationDeclaration type                                             *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_enumerationDeclaration ("enumerationDeclaration",
                                               & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_enumerationDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_enumerationDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_enumerationDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_enumerationDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationDeclaration GALGAS_enumerationDeclaration::extractObject (const GALGAS_object & inObject,
                                                                            C_Compiler * inCompiler
                                                                            COMMA_LOCATION_ARGS) {
  GALGAS_enumerationDeclaration result ;
  const GALGAS_enumerationDeclaration * p = (const GALGAS_enumerationDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_enumerationDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("enumerationDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_globalConstantDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_globalConstantDeclaration * p = (const cPtr_globalConstantDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_globalConstantDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTypeName.objectCompare (p->mAttribute_mTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mConstantName.objectCompare (p->mAttribute_mConstantName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceExpression.objectCompare (p->mAttribute_mSourceExpression) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_globalConstantDeclaration::objectCompare (const GALGAS_globalConstantDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalConstantDeclaration::GALGAS_globalConstantDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalConstantDeclaration::GALGAS_globalConstantDeclaration (const cPtr_globalConstantDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_globalConstantDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalConstantDeclaration GALGAS_globalConstantDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mTypeName,
                                                                                    const GALGAS_lstring & inAttribute_mConstantName,
                                                                                    const GALGAS_expressionAST & inAttribute_mSourceExpression
                                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_globalConstantDeclaration result ;
  if (inAttribute_mTypeName.isValid () && inAttribute_mConstantName.isValid () && inAttribute_mSourceExpression.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_globalConstantDeclaration (inAttribute_mTypeName, inAttribute_mConstantName, inAttribute_mSourceExpression COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_globalConstantDeclaration::reader_mTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalConstantDeclaration * p = (const cPtr_globalConstantDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalConstantDeclaration) ;
    result = p->mAttribute_mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_globalConstantDeclaration::reader_mTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_globalConstantDeclaration::reader_mConstantName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalConstantDeclaration * p = (const cPtr_globalConstantDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalConstantDeclaration) ;
    result = p->mAttribute_mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_globalConstantDeclaration::reader_mConstantName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mConstantName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_globalConstantDeclaration::reader_mSourceExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalConstantDeclaration * p = (const cPtr_globalConstantDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalConstantDeclaration) ;
    result = p->mAttribute_mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_globalConstantDeclaration::reader_mSourceExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                 Pointer class for @globalConstantDeclaration class                                  *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_globalConstantDeclaration::cPtr_globalConstantDeclaration (const GALGAS_lstring & in_mTypeName,
                                                                const GALGAS_lstring & in_mConstantName,
                                                                const GALGAS_expressionAST & in_mSourceExpression
                                                                COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mTypeName (in_mTypeName),
mAttribute_mConstantName (in_mConstantName),
mAttribute_mSourceExpression (in_mSourceExpression) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_globalConstantDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_globalConstantDeclaration ;
}

void cPtr_globalConstantDeclaration::description (C_String & ioString,
                                                  const int32_t inIndentation) const {
  ioString << "[@globalConstantDeclaration:" ;
  mAttribute_mTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mConstantName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceExpression.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_globalConstantDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_globalConstantDeclaration (mAttribute_mTypeName, mAttribute_mConstantName, mAttribute_mSourceExpression COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                           @globalConstantDeclaration type                                           *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_globalConstantDeclaration ("globalConstantDeclaration",
                                                  & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_globalConstantDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_globalConstantDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_globalConstantDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_globalConstantDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalConstantDeclaration GALGAS_globalConstantDeclaration::extractObject (const GALGAS_object & inObject,
                                                                                  C_Compiler * inCompiler
                                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_globalConstantDeclaration result ;
  const GALGAS_globalConstantDeclaration * p = (const GALGAS_globalConstantDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_globalConstantDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("globalConstantDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_globalVarDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_globalVarDeclaration * p = (const cPtr_globalVarDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_globalVarDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mModeList.objectCompare (p->mAttribute_mModeList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mType.objectCompare (p->mAttribute_mType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mVarName.objectCompare (p->mAttribute_mVarName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceExpression.objectCompare (p->mAttribute_mSourceExpression) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_globalVarDeclaration::objectCompare (const GALGAS_globalVarDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalVarDeclaration::GALGAS_globalVarDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalVarDeclaration::GALGAS_globalVarDeclaration (const cPtr_globalVarDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_globalVarDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalVarDeclaration GALGAS_globalVarDeclaration::constructor_new (const GALGAS_lstringlist & inAttribute_mModeList,
                                                                          const GALGAS_generalizedTypeEnumAST & inAttribute_mType,
                                                                          const GALGAS_lstring & inAttribute_mVarName,
                                                                          const GALGAS_expressionAST & inAttribute_mSourceExpression
                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_globalVarDeclaration result ;
  if (inAttribute_mModeList.isValid () && inAttribute_mType.isValid () && inAttribute_mVarName.isValid () && inAttribute_mSourceExpression.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_globalVarDeclaration (inAttribute_mModeList, inAttribute_mType, inAttribute_mVarName, inAttribute_mSourceExpression COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist GALGAS_globalVarDeclaration::reader_mModeList (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstringlist result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalVarDeclaration * p = (const cPtr_globalVarDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalVarDeclaration) ;
    result = p->mAttribute_mModeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist cPtr_globalVarDeclaration::reader_mModeList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mModeList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_generalizedTypeEnumAST GALGAS_globalVarDeclaration::reader_mType (UNUSED_LOCATION_ARGS) const {
  GALGAS_generalizedTypeEnumAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalVarDeclaration * p = (const cPtr_globalVarDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalVarDeclaration) ;
    result = p->mAttribute_mType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_generalizedTypeEnumAST cPtr_globalVarDeclaration::reader_mType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_globalVarDeclaration::reader_mVarName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalVarDeclaration * p = (const cPtr_globalVarDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalVarDeclaration) ;
    result = p->mAttribute_mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_globalVarDeclaration::reader_mVarName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mVarName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_globalVarDeclaration::reader_mSourceExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_globalVarDeclaration * p = (const cPtr_globalVarDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_globalVarDeclaration) ;
    result = p->mAttribute_mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_globalVarDeclaration::reader_mSourceExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @globalVarDeclaration class                                    *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_globalVarDeclaration::cPtr_globalVarDeclaration (const GALGAS_lstringlist & in_mModeList,
                                                      const GALGAS_generalizedTypeEnumAST & in_mType,
                                                      const GALGAS_lstring & in_mVarName,
                                                      const GALGAS_expressionAST & in_mSourceExpression
                                                      COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mModeList (in_mModeList),
mAttribute_mType (in_mType),
mAttribute_mVarName (in_mVarName),
mAttribute_mSourceExpression (in_mSourceExpression) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_globalVarDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_globalVarDeclaration ;
}

void cPtr_globalVarDeclaration::description (C_String & ioString,
                                             const int32_t inIndentation) const {
  ioString << "[@globalVarDeclaration:" ;
  mAttribute_mModeList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mVarName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceExpression.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_globalVarDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_globalVarDeclaration (mAttribute_mModeList, mAttribute_mType, mAttribute_mVarName, mAttribute_mSourceExpression COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             @globalVarDeclaration type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_globalVarDeclaration ("globalVarDeclaration",
                                             & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_globalVarDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_globalVarDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_globalVarDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_globalVarDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_globalVarDeclaration GALGAS_globalVarDeclaration::extractObject (const GALGAS_object & inObject,
                                                                        C_Compiler * inCompiler
                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_globalVarDeclaration result ;
  const GALGAS_globalVarDeclaration * p = (const GALGAS_globalVarDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_globalVarDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("globalVarDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_integerDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_integerDeclaration * p = (const cPtr_integerDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_integerDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mIntegerTypeName.objectCompare (p->mAttribute_mIntegerTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mBaseType.objectCompare (p->mAttribute_mBaseType) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_integerDeclaration::objectCompare (const GALGAS_integerDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerDeclaration::GALGAS_integerDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerDeclaration GALGAS_integerDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_integerDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                     GALGAS_lstring::constructor_default (HERE)
                                                     COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerDeclaration::GALGAS_integerDeclaration (const cPtr_integerDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_integerDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerDeclaration GALGAS_integerDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mIntegerTypeName,
                                                                      const GALGAS_lstring & inAttribute_mBaseType
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_integerDeclaration result ;
  if (inAttribute_mIntegerTypeName.isValid () && inAttribute_mBaseType.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_integerDeclaration (inAttribute_mIntegerTypeName, inAttribute_mBaseType COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_integerDeclaration::reader_mIntegerTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_integerDeclaration * p = (const cPtr_integerDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_integerDeclaration) ;
    result = p->mAttribute_mIntegerTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_integerDeclaration::reader_mIntegerTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mIntegerTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_integerDeclaration::reader_mBaseType (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_integerDeclaration * p = (const cPtr_integerDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_integerDeclaration) ;
    result = p->mAttribute_mBaseType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_integerDeclaration::reader_mBaseType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mBaseType ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                     Pointer class for @integerDeclaration class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_integerDeclaration::cPtr_integerDeclaration (const GALGAS_lstring & in_mIntegerTypeName,
                                                  const GALGAS_lstring & in_mBaseType
                                                  COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mIntegerTypeName (in_mIntegerTypeName),
mAttribute_mBaseType (in_mBaseType) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_integerDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_integerDeclaration ;
}

void cPtr_integerDeclaration::description (C_String & ioString,
                                           const int32_t inIndentation) const {
  ioString << "[@integerDeclaration:" ;
  mAttribute_mIntegerTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mBaseType.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_integerDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_integerDeclaration (mAttribute_mIntegerTypeName, mAttribute_mBaseType COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @integerDeclaration type                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_integerDeclaration ("integerDeclaration",
                                           & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_integerDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_integerDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_integerDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_integerDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerDeclaration GALGAS_integerDeclaration::extractObject (const GALGAS_object & inObject,
                                                                    C_Compiler * inCompiler
                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_integerDeclaration result ;
  const GALGAS_integerDeclaration * p = (const GALGAS_integerDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_integerDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("integerDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_literalStringDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_literalStringDeclaration * p = (const cPtr_literalStringDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_literalStringDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mLiteralStringTypeName.objectCompare (p->mAttribute_mLiteralStringTypeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_literalStringDeclaration::objectCompare (const GALGAS_literalStringDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringDeclaration::GALGAS_literalStringDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringDeclaration GALGAS_literalStringDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_literalStringDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE)
                                                           COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringDeclaration::GALGAS_literalStringDeclaration (const cPtr_literalStringDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_literalStringDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringDeclaration GALGAS_literalStringDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mLiteralStringTypeName
                                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_literalStringDeclaration result ;
  if (inAttribute_mLiteralStringTypeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_literalStringDeclaration (inAttribute_mLiteralStringTypeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_literalStringDeclaration::reader_mLiteralStringTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_literalStringDeclaration * p = (const cPtr_literalStringDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_literalStringDeclaration) ;
    result = p->mAttribute_mLiteralStringTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_literalStringDeclaration::reader_mLiteralStringTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLiteralStringTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                  Pointer class for @literalStringDeclaration class                                  *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_literalStringDeclaration::cPtr_literalStringDeclaration (const GALGAS_lstring & in_mLiteralStringTypeName
                                                              COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mLiteralStringTypeName (in_mLiteralStringTypeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_literalStringDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalStringDeclaration ;
}

void cPtr_literalStringDeclaration::description (C_String & ioString,
                                                 const int32_t inIndentation) const {
  ioString << "[@literalStringDeclaration:" ;
  mAttribute_mLiteralStringTypeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_literalStringDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_literalStringDeclaration (mAttribute_mLiteralStringTypeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                           @literalStringDeclaration type                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_literalStringDeclaration ("literalStringDeclaration",
                                                 & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_literalStringDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalStringDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_literalStringDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_literalStringDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringDeclaration GALGAS_literalStringDeclaration::extractObject (const GALGAS_object & inObject,
                                                                                C_Compiler * inCompiler
                                                                                COMMA_LOCATION_ARGS) {
  GALGAS_literalStringDeclaration result ;
  const GALGAS_literalStringDeclaration * p = (const GALGAS_literalStringDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_literalStringDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("literalStringDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_modeDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_modeDeclaration * p = (const cPtr_modeDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_modeDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mModeName.objectCompare (p->mAttribute_mModeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_modeDeclaration::objectCompare (const GALGAS_modeDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_modeDeclaration::GALGAS_modeDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_modeDeclaration GALGAS_modeDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_modeDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE)
                                                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_modeDeclaration::GALGAS_modeDeclaration (const cPtr_modeDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_modeDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_modeDeclaration GALGAS_modeDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mModeName
                                                                COMMA_LOCATION_ARGS) {
  GALGAS_modeDeclaration result ;
  if (inAttribute_mModeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_modeDeclaration (inAttribute_mModeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_modeDeclaration::reader_mModeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_modeDeclaration * p = (const cPtr_modeDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_modeDeclaration) ;
    result = p->mAttribute_mModeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_modeDeclaration::reader_mModeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mModeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                      Pointer class for @modeDeclaration class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_modeDeclaration::cPtr_modeDeclaration (const GALGAS_lstring & in_mModeName
                                            COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mModeName (in_mModeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_modeDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_modeDeclaration ;
}

void cPtr_modeDeclaration::description (C_String & ioString,
                                        const int32_t inIndentation) const {
  ioString << "[@modeDeclaration:" ;
  mAttribute_mModeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_modeDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_modeDeclaration (mAttribute_mModeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @modeDeclaration type                                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_modeDeclaration ("modeDeclaration",
                                        & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_modeDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_modeDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_modeDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_modeDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_modeDeclaration GALGAS_modeDeclaration::extractObject (const GALGAS_object & inObject,
                                                              C_Compiler * inCompiler
                                                              COMMA_LOCATION_ARGS) {
  GALGAS_modeDeclaration result ;
  const GALGAS_modeDeclaration * p = (const GALGAS_modeDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_modeDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("modeDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_newBaseTypeDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_newBaseTypeDeclaration * p = (const cPtr_newBaseTypeDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_newBaseTypeDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mBaseTypeName.objectCompare (p->mAttribute_mBaseTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mCType.objectCompare (p->mAttribute_mCType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSize.objectCompare (p->mAttribute_mSize) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mIsSigned.objectCompare (p->mAttribute_mIsSigned) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_newBaseTypeDeclaration::objectCompare (const GALGAS_newBaseTypeDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_newBaseTypeDeclaration::GALGAS_newBaseTypeDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_newBaseTypeDeclaration GALGAS_newBaseTypeDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_newBaseTypeDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                         GALGAS_lstring::constructor_default (HERE),
                                                         GALGAS_luint_36__34_::constructor_default (HERE),
                                                         GALGAS_bool::constructor_default (HERE)
                                                         COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_newBaseTypeDeclaration::GALGAS_newBaseTypeDeclaration (const cPtr_newBaseTypeDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_newBaseTypeDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_newBaseTypeDeclaration GALGAS_newBaseTypeDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mBaseTypeName,
                                                                              const GALGAS_lstring & inAttribute_mCType,
                                                                              const GALGAS_luint_36__34_ & inAttribute_mSize,
                                                                              const GALGAS_bool & inAttribute_mIsSigned
                                                                              COMMA_LOCATION_ARGS) {
  GALGAS_newBaseTypeDeclaration result ;
  if (inAttribute_mBaseTypeName.isValid () && inAttribute_mCType.isValid () && inAttribute_mSize.isValid () && inAttribute_mIsSigned.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_newBaseTypeDeclaration (inAttribute_mBaseTypeName, inAttribute_mCType, inAttribute_mSize, inAttribute_mIsSigned COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_newBaseTypeDeclaration::reader_mBaseTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_newBaseTypeDeclaration * p = (const cPtr_newBaseTypeDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_newBaseTypeDeclaration) ;
    result = p->mAttribute_mBaseTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_newBaseTypeDeclaration::reader_mBaseTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mBaseTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_newBaseTypeDeclaration::reader_mCType (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_newBaseTypeDeclaration * p = (const cPtr_newBaseTypeDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_newBaseTypeDeclaration) ;
    result = p->mAttribute_mCType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_newBaseTypeDeclaration::reader_mCType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mCType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_luint_36__34_ GALGAS_newBaseTypeDeclaration::reader_mSize (UNUSED_LOCATION_ARGS) const {
  GALGAS_luint_36__34_ result ;
  if (NULL != mObjectPtr) {
    const cPtr_newBaseTypeDeclaration * p = (const cPtr_newBaseTypeDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_newBaseTypeDeclaration) ;
    result = p->mAttribute_mSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_luint_36__34_ cPtr_newBaseTypeDeclaration::reader_mSize (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSize ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_bool GALGAS_newBaseTypeDeclaration::reader_mIsSigned (UNUSED_LOCATION_ARGS) const {
  GALGAS_bool result ;
  if (NULL != mObjectPtr) {
    const cPtr_newBaseTypeDeclaration * p = (const cPtr_newBaseTypeDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_newBaseTypeDeclaration) ;
    result = p->mAttribute_mIsSigned ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_bool cPtr_newBaseTypeDeclaration::reader_mIsSigned (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mIsSigned ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                   Pointer class for @newBaseTypeDeclaration class                                   *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_newBaseTypeDeclaration::cPtr_newBaseTypeDeclaration (const GALGAS_lstring & in_mBaseTypeName,
                                                          const GALGAS_lstring & in_mCType,
                                                          const GALGAS_luint_36__34_ & in_mSize,
                                                          const GALGAS_bool & in_mIsSigned
                                                          COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mBaseTypeName (in_mBaseTypeName),
mAttribute_mCType (in_mCType),
mAttribute_mSize (in_mSize),
mAttribute_mIsSigned (in_mIsSigned) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_newBaseTypeDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_newBaseTypeDeclaration ;
}

void cPtr_newBaseTypeDeclaration::description (C_String & ioString,
                                               const int32_t inIndentation) const {
  ioString << "[@newBaseTypeDeclaration:" ;
  mAttribute_mBaseTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mCType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSize.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mIsSigned.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_newBaseTypeDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_newBaseTypeDeclaration (mAttribute_mBaseTypeName, mAttribute_mCType, mAttribute_mSize, mAttribute_mIsSigned COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            @newBaseTypeDeclaration type                                             *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_newBaseTypeDeclaration ("newBaseTypeDeclaration",
                                               & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_newBaseTypeDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_newBaseTypeDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_newBaseTypeDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_newBaseTypeDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_newBaseTypeDeclaration GALGAS_newBaseTypeDeclaration::extractObject (const GALGAS_object & inObject,
                                                                            C_Compiler * inCompiler
                                                                            COMMA_LOCATION_ARGS) {
  GALGAS_newBaseTypeDeclaration result ;
  const GALGAS_newBaseTypeDeclaration * p = (const GALGAS_newBaseTypeDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_newBaseTypeDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("newBaseTypeDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_registerDeclaration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_registerDeclaration * p = (const cPtr_registerDeclaration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_registerDeclaration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mRegisterTypeName.objectCompare (p->mAttribute_mRegisterTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mRegisterName.objectCompare (p->mAttribute_mRegisterName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mRegisterAddress.objectCompare (p->mAttribute_mRegisterAddress) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mAttributeList.objectCompare (p->mAttribute_mAttributeList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_registerDeclaration::objectCompare (const GALGAS_registerDeclaration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_registerDeclaration::GALGAS_registerDeclaration (void) :
GALGAS_abstractDeclaration () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_registerDeclaration GALGAS_registerDeclaration::constructor_default (LOCATION_ARGS) {
  return GALGAS_registerDeclaration::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                      GALGAS_lstring::constructor_default (HERE),
                                                      GALGAS_luint_36__34_::constructor_default (HERE),
                                                      GALGAS_lstringlist::constructor_emptyList (HERE)
                                                      COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_registerDeclaration::GALGAS_registerDeclaration (const cPtr_registerDeclaration * inSourcePtr) :
GALGAS_abstractDeclaration (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_registerDeclaration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_registerDeclaration GALGAS_registerDeclaration::constructor_new (const GALGAS_lstring & inAttribute_mRegisterTypeName,
                                                                        const GALGAS_lstring & inAttribute_mRegisterName,
                                                                        const GALGAS_luint_36__34_ & inAttribute_mRegisterAddress,
                                                                        const GALGAS_lstringlist & inAttribute_mAttributeList
                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_registerDeclaration result ;
  if (inAttribute_mRegisterTypeName.isValid () && inAttribute_mRegisterName.isValid () && inAttribute_mRegisterAddress.isValid () && inAttribute_mAttributeList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_registerDeclaration (inAttribute_mRegisterTypeName, inAttribute_mRegisterName, inAttribute_mRegisterAddress, inAttribute_mAttributeList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_registerDeclaration::reader_mRegisterTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_registerDeclaration * p = (const cPtr_registerDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_registerDeclaration) ;
    result = p->mAttribute_mRegisterTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_registerDeclaration::reader_mRegisterTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mRegisterTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_registerDeclaration::reader_mRegisterName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_registerDeclaration * p = (const cPtr_registerDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_registerDeclaration) ;
    result = p->mAttribute_mRegisterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_registerDeclaration::reader_mRegisterName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mRegisterName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_luint_36__34_ GALGAS_registerDeclaration::reader_mRegisterAddress (UNUSED_LOCATION_ARGS) const {
  GALGAS_luint_36__34_ result ;
  if (NULL != mObjectPtr) {
    const cPtr_registerDeclaration * p = (const cPtr_registerDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_registerDeclaration) ;
    result = p->mAttribute_mRegisterAddress ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_luint_36__34_ cPtr_registerDeclaration::reader_mRegisterAddress (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mRegisterAddress ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist GALGAS_registerDeclaration::reader_mAttributeList (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstringlist result ;
  if (NULL != mObjectPtr) {
    const cPtr_registerDeclaration * p = (const cPtr_registerDeclaration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_registerDeclaration) ;
    result = p->mAttribute_mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstringlist cPtr_registerDeclaration::reader_mAttributeList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mAttributeList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @registerDeclaration class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_registerDeclaration::cPtr_registerDeclaration (const GALGAS_lstring & in_mRegisterTypeName,
                                                    const GALGAS_lstring & in_mRegisterName,
                                                    const GALGAS_luint_36__34_ & in_mRegisterAddress,
                                                    const GALGAS_lstringlist & in_mAttributeList
                                                    COMMA_LOCATION_ARGS) :
cPtr_abstractDeclaration (THERE),
mAttribute_mRegisterTypeName (in_mRegisterTypeName),
mAttribute_mRegisterName (in_mRegisterName),
mAttribute_mRegisterAddress (in_mRegisterAddress),
mAttribute_mAttributeList (in_mAttributeList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_registerDeclaration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_registerDeclaration ;
}

void cPtr_registerDeclaration::description (C_String & ioString,
                                            const int32_t inIndentation) const {
  ioString << "[@registerDeclaration:" ;
  mAttribute_mRegisterTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mRegisterName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mRegisterAddress.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mAttributeList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_registerDeclaration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_registerDeclaration (mAttribute_mRegisterTypeName, mAttribute_mRegisterName, mAttribute_mRegisterAddress, mAttribute_mAttributeList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @registerDeclaration type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_registerDeclaration ("registerDeclaration",
                                            & kTypeDescriptor_GALGAS_abstractDeclaration) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_registerDeclaration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_registerDeclaration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_registerDeclaration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_registerDeclaration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_registerDeclaration GALGAS_registerDeclaration::extractObject (const GALGAS_object & inObject,
                                                                      C_Compiler * inCompiler
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_registerDeclaration result ;
  const GALGAS_registerDeclaration * p = (const GALGAS_registerDeclaration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_registerDeclaration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("registerDeclaration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*



typeComparisonResult GALGAS_abstractExpressionIR::objectCompare (const GALGAS_abstractExpressionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractExpressionIR::GALGAS_abstractExpressionIR (void) :
AC_GALGAS_class () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractExpressionIR::GALGAS_abstractExpressionIR (const cPtr_abstractExpressionIR * inSourcePtr) :
AC_GALGAS_class (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_abstractExpressionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @abstractExpressionIR class                                    *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_abstractExpressionIR::cPtr_abstractExpressionIR (LOCATION_ARGS) :
acPtr_class (THERE) {
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             @abstractExpressionIR type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_abstractExpressionIR ("abstractExpressionIR",
                                             NULL) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_abstractExpressionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_abstractExpressionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_abstractExpressionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_abstractExpressionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractExpressionIR GALGAS_abstractExpressionIR::extractObject (const GALGAS_object & inObject,
                                                                        C_Compiler * inCompiler
                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_abstractExpressionIR result ;
  const GALGAS_abstractExpressionIR * p = (const GALGAS_abstractExpressionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_abstractExpressionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("abstractExpressionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*



typeComparisonResult GALGAS_abstractInstructionIR::objectCompare (const GALGAS_abstractInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractInstructionIR::GALGAS_abstractInstructionIR (void) :
AC_GALGAS_class () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractInstructionIR::GALGAS_abstractInstructionIR (const cPtr_abstractInstructionIR * inSourcePtr) :
AC_GALGAS_class (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_abstractInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                   Pointer class for @abstractInstructionIR class                                    *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_abstractInstructionIR::cPtr_abstractInstructionIR (LOCATION_ARGS) :
acPtr_class (THERE) {
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             @abstractInstructionIR type                                             *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_abstractInstructionIR ("abstractInstructionIR",
                                              NULL) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_abstractInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_abstractInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_abstractInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_abstractInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractInstructionIR GALGAS_abstractInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                          C_Compiler * inCompiler
                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_abstractInstructionIR result ;
  const GALGAS_abstractInstructionIR * p = (const GALGAS_abstractInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_abstractInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("abstractInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_asOperatorInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_asOperatorInstructionIR * p = (const cPtr_asOperatorInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_asOperatorInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTemporaryResultVariable.objectCompare (p->mAttribute_mTemporaryResultVariable) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperand.objectCompare (p->mAttribute_mOperand) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_asOperatorInstructionIR::objectCompare (const GALGAS_asOperatorInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asOperatorInstructionIR::GALGAS_asOperatorInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asOperatorInstructionIR::GALGAS_asOperatorInstructionIR (const cPtr_asOperatorInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_asOperatorInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asOperatorInstructionIR GALGAS_asOperatorInstructionIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                                const GALGAS_variableKindIR & inAttribute_mTemporaryResultVariable,
                                                                                const GALGAS_variableKindIR & inAttribute_mOperand
                                                                                COMMA_LOCATION_ARGS) {
  GALGAS_asOperatorInstructionIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mTemporaryResultVariable.isValid () && inAttribute_mOperand.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_asOperatorInstructionIR (inAttribute_mTargetType, inAttribute_mTemporaryResultVariable, inAttribute_mOperand COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_asOperatorInstructionIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_asOperatorInstructionIR * p = (const cPtr_asOperatorInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_asOperatorInstructionIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_asOperatorInstructionIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_asOperatorInstructionIR::reader_mTemporaryResultVariable (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_asOperatorInstructionIR * p = (const cPtr_asOperatorInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_asOperatorInstructionIR) ;
    result = p->mAttribute_mTemporaryResultVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_asOperatorInstructionIR::reader_mTemporaryResultVariable (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTemporaryResultVariable ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_asOperatorInstructionIR::reader_mOperand (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_asOperatorInstructionIR * p = (const cPtr_asOperatorInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_asOperatorInstructionIR) ;
    result = p->mAttribute_mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_asOperatorInstructionIR::reader_mOperand (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperand ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                  Pointer class for @asOperatorInstructionIR class                                   *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_asOperatorInstructionIR::cPtr_asOperatorInstructionIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                                            const GALGAS_variableKindIR & in_mTemporaryResultVariable,
                                                            const GALGAS_variableKindIR & in_mOperand
                                                            COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mTemporaryResultVariable (in_mTemporaryResultVariable),
mAttribute_mOperand (in_mOperand) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_asOperatorInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_asOperatorInstructionIR ;
}

void cPtr_asOperatorInstructionIR::description (C_String & ioString,
                                                const int32_t inIndentation) const {
  ioString << "[@asOperatorInstructionIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTemporaryResultVariable.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperand.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_asOperatorInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_asOperatorInstructionIR (mAttribute_mTargetType, mAttribute_mTemporaryResultVariable, mAttribute_mOperand COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            @asOperatorInstructionIR type                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_asOperatorInstructionIR ("asOperatorInstructionIR",
                                                & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_asOperatorInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_asOperatorInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_asOperatorInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_asOperatorInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asOperatorInstructionIR GALGAS_asOperatorInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                              C_Compiler * inCompiler
                                                                              COMMA_LOCATION_ARGS) {
  GALGAS_asOperatorInstructionIR result ;
  const GALGAS_asOperatorInstructionIR * p = (const GALGAS_asOperatorInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_asOperatorInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("asOperatorInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_assignmentInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_assignmentInstructionIR * p = (const cPtr_assignmentInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_assignmentInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVariable.objectCompare (p->mAttribute_mTargetVariable) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVarType.objectCompare (p->mAttribute_mTargetVarType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceValue.objectCompare (p->mAttribute_mSourceValue) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_assignmentInstructionIR::objectCompare (const GALGAS_assignmentInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionIR::GALGAS_assignmentInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionIR::GALGAS_assignmentInstructionIR (const cPtr_assignmentInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_assignmentInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionIR GALGAS_assignmentInstructionIR::constructor_new (const GALGAS_variableKindIR & inAttribute_mTargetVariable,
                                                                                const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetVarType,
                                                                                const GALGAS_variableKindIR & inAttribute_mSourceValue
                                                                                COMMA_LOCATION_ARGS) {
  GALGAS_assignmentInstructionIR result ;
  if (inAttribute_mTargetVariable.isValid () && inAttribute_mTargetVarType.isValid () && inAttribute_mSourceValue.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_assignmentInstructionIR (inAttribute_mTargetVariable, inAttribute_mTargetVarType, inAttribute_mSourceValue COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_assignmentInstructionIR::reader_mTargetVariable (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_assignmentInstructionIR * p = (const cPtr_assignmentInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_assignmentInstructionIR) ;
    result = p->mAttribute_mTargetVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_assignmentInstructionIR::reader_mTargetVariable (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVariable ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_assignmentInstructionIR::reader_mTargetVarType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_assignmentInstructionIR * p = (const cPtr_assignmentInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_assignmentInstructionIR) ;
    result = p->mAttribute_mTargetVarType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_assignmentInstructionIR::reader_mTargetVarType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVarType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_assignmentInstructionIR::reader_mSourceValue (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_assignmentInstructionIR * p = (const cPtr_assignmentInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_assignmentInstructionIR) ;
    result = p->mAttribute_mSourceValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_assignmentInstructionIR::reader_mSourceValue (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceValue ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                  Pointer class for @assignmentInstructionIR class                                   *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_assignmentInstructionIR::cPtr_assignmentInstructionIR (const GALGAS_variableKindIR & in_mTargetVariable,
                                                            const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetVarType,
                                                            const GALGAS_variableKindIR & in_mSourceValue
                                                            COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetVariable (in_mTargetVariable),
mAttribute_mTargetVarType (in_mTargetVarType),
mAttribute_mSourceValue (in_mSourceValue) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_assignmentInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_assignmentInstructionIR ;
}

void cPtr_assignmentInstructionIR::description (C_String & ioString,
                                                const int32_t inIndentation) const {
  ioString << "[@assignmentInstructionIR:" ;
  mAttribute_mTargetVariable.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTargetVarType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceValue.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_assignmentInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_assignmentInstructionIR (mAttribute_mTargetVariable, mAttribute_mTargetVarType, mAttribute_mSourceValue COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                            @assignmentInstructionIR type                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_assignmentInstructionIR ("assignmentInstructionIR",
                                                & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_assignmentInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_assignmentInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_assignmentInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_assignmentInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionIR GALGAS_assignmentInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                              C_Compiler * inCompiler
                                                                              COMMA_LOCATION_ARGS) {
  GALGAS_assignmentInstructionIR result ;
  const GALGAS_assignmentInstructionIR * p = (const GALGAS_assignmentInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_assignmentInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("assignmentInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_constructorCallIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_constructorCallIR * p = (const cPtr_constructorCallIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_constructorCallIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTargetTemporaryVariable.objectCompare (p->mAttribute_mTargetTemporaryVariable) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mCallExpression.objectCompare (p->mAttribute_mCallExpression) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_constructorCallIR::objectCompare (const GALGAS_constructorCallIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCallIR::GALGAS_constructorCallIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCallIR::GALGAS_constructorCallIR (const cPtr_constructorCallIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_constructorCallIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCallIR GALGAS_constructorCallIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                    const GALGAS_variableKindIR & inAttribute_mTargetTemporaryVariable,
                                                                    const GALGAS_string & inAttribute_mCallExpression
                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_constructorCallIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mTargetTemporaryVariable.isValid () && inAttribute_mCallExpression.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_constructorCallIR (inAttribute_mTargetType, inAttribute_mTargetTemporaryVariable, inAttribute_mCallExpression COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_constructorCallIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_constructorCallIR * p = (const cPtr_constructorCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_constructorCallIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_constructorCallIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_constructorCallIR::reader_mTargetTemporaryVariable (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_constructorCallIR * p = (const cPtr_constructorCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_constructorCallIR) ;
    result = p->mAttribute_mTargetTemporaryVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_constructorCallIR::reader_mTargetTemporaryVariable (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetTemporaryVariable ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_constructorCallIR::reader_mCallExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_constructorCallIR * p = (const cPtr_constructorCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_constructorCallIR) ;
    result = p->mAttribute_mCallExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_constructorCallIR::reader_mCallExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mCallExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                     Pointer class for @constructorCallIR class                                      *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_constructorCallIR::cPtr_constructorCallIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                                const GALGAS_variableKindIR & in_mTargetTemporaryVariable,
                                                const GALGAS_string & in_mCallExpression
                                                COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mTargetTemporaryVariable (in_mTargetTemporaryVariable),
mAttribute_mCallExpression (in_mCallExpression) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_constructorCallIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_constructorCallIR ;
}

void cPtr_constructorCallIR::description (C_String & ioString,
                                          const int32_t inIndentation) const {
  ioString << "[@constructorCallIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTargetTemporaryVariable.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mCallExpression.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_constructorCallIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_constructorCallIR (mAttribute_mTargetType, mAttribute_mTargetTemporaryVariable, mAttribute_mCallExpression COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                               @constructorCallIR type                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_constructorCallIR ("constructorCallIR",
                                          & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_constructorCallIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_constructorCallIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_constructorCallIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_constructorCallIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCallIR GALGAS_constructorCallIR::extractObject (const GALGAS_object & inObject,
                                                                  C_Compiler * inCompiler
                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_constructorCallIR result ;
  const GALGAS_constructorCallIR * p = (const GALGAS_constructorCallIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_constructorCallIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("constructorCallIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_foreverInstructionGeneration::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_foreverInstructionGeneration * p = (const cPtr_foreverInstructionGeneration *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_foreverInstructionGeneration) ;
  if (kOperandEqual == result) {
    result = mAttribute_mInstructionGenerationList.objectCompare (p->mAttribute_mInstructionGenerationList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_foreverInstructionGeneration::objectCompare (const GALGAS_foreverInstructionGeneration & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionGeneration::GALGAS_foreverInstructionGeneration (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionGeneration GALGAS_foreverInstructionGeneration::constructor_default (LOCATION_ARGS) {
  return GALGAS_foreverInstructionGeneration::constructor_new (GALGAS_instructionListIR::constructor_emptyList (HERE)
                                                               COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionGeneration::GALGAS_foreverInstructionGeneration (const cPtr_foreverInstructionGeneration * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_foreverInstructionGeneration) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionGeneration GALGAS_foreverInstructionGeneration::constructor_new (const GALGAS_instructionListIR & inAttribute_mInstructionGenerationList
                                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_foreverInstructionGeneration result ;
  if (inAttribute_mInstructionGenerationList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_foreverInstructionGeneration (inAttribute_mInstructionGenerationList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR GALGAS_foreverInstructionGeneration::reader_mInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_foreverInstructionGeneration * p = (const cPtr_foreverInstructionGeneration *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_foreverInstructionGeneration) ;
    result = p->mAttribute_mInstructionGenerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR cPtr_foreverInstructionGeneration::reader_mInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mInstructionGenerationList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                Pointer class for @foreverInstructionGeneration class                                *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_foreverInstructionGeneration::cPtr_foreverInstructionGeneration (const GALGAS_instructionListIR & in_mInstructionGenerationList
                                                                      COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mInstructionGenerationList (in_mInstructionGenerationList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_foreverInstructionGeneration::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_foreverInstructionGeneration ;
}

void cPtr_foreverInstructionGeneration::description (C_String & ioString,
                                                     const int32_t inIndentation) const {
  ioString << "[@foreverInstructionGeneration:" ;
  mAttribute_mInstructionGenerationList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_foreverInstructionGeneration::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_foreverInstructionGeneration (mAttribute_mInstructionGenerationList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                         @foreverInstructionGeneration type                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_foreverInstructionGeneration ("foreverInstructionGeneration",
                                                     & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_foreverInstructionGeneration::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_foreverInstructionGeneration ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_foreverInstructionGeneration::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_foreverInstructionGeneration (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionGeneration GALGAS_foreverInstructionGeneration::extractObject (const GALGAS_object & inObject,
                                                                                        C_Compiler * inCompiler
                                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_foreverInstructionGeneration result ;
  const GALGAS_foreverInstructionGeneration * p = (const GALGAS_foreverInstructionGeneration *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_foreverInstructionGeneration *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("foreverInstructionGeneration", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_functionCallIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_functionCallIR * p = (const cPtr_functionCallIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_functionCallIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mFunctionName.objectCompare (p->mAttribute_mFunctionName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTempConstantTarget.objectCompare (p->mAttribute_mTempConstantTarget) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mVariableList.objectCompare (p->mAttribute_mVariableList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_functionCallIR::objectCompare (const GALGAS_functionCallIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallIR::GALGAS_functionCallIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallIR::GALGAS_functionCallIR (const cPtr_functionCallIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_functionCallIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallIR GALGAS_functionCallIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                              const GALGAS_string & inAttribute_mFunctionName,
                                                              const GALGAS_variableKindIR & inAttribute_mTempConstantTarget,
                                                              const GALGAS_variableListIR & inAttribute_mVariableList
                                                              COMMA_LOCATION_ARGS) {
  GALGAS_functionCallIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mFunctionName.isValid () && inAttribute_mTempConstantTarget.isValid () && inAttribute_mVariableList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_functionCallIR (inAttribute_mTargetType, inAttribute_mFunctionName, inAttribute_mTempConstantTarget, inAttribute_mVariableList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_functionCallIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_functionCallIR * p = (const cPtr_functionCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_functionCallIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_functionCallIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_functionCallIR::reader_mFunctionName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_functionCallIR * p = (const cPtr_functionCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_functionCallIR) ;
    result = p->mAttribute_mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_functionCallIR::reader_mFunctionName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mFunctionName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_functionCallIR::reader_mTempConstantTarget (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_functionCallIR * p = (const cPtr_functionCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_functionCallIR) ;
    result = p->mAttribute_mTempConstantTarget ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_functionCallIR::reader_mTempConstantTarget (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTempConstantTarget ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableListIR GALGAS_functionCallIR::reader_mVariableList (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_functionCallIR * p = (const cPtr_functionCallIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_functionCallIR) ;
    result = p->mAttribute_mVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableListIR cPtr_functionCallIR::reader_mVariableList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mVariableList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                       Pointer class for @functionCallIR class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_functionCallIR::cPtr_functionCallIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                          const GALGAS_string & in_mFunctionName,
                                          const GALGAS_variableKindIR & in_mTempConstantTarget,
                                          const GALGAS_variableListIR & in_mVariableList
                                          COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mFunctionName (in_mFunctionName),
mAttribute_mTempConstantTarget (in_mTempConstantTarget),
mAttribute_mVariableList (in_mVariableList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_functionCallIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_functionCallIR ;
}

void cPtr_functionCallIR::description (C_String & ioString,
                                       const int32_t inIndentation) const {
  ioString << "[@functionCallIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mFunctionName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTempConstantTarget.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mVariableList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_functionCallIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_functionCallIR (mAttribute_mTargetType, mAttribute_mFunctionName, mAttribute_mTempConstantTarget, mAttribute_mVariableList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @functionCallIR type                                                 *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_functionCallIR ("functionCallIR",
                                       & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_functionCallIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_functionCallIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_functionCallIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_functionCallIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallIR GALGAS_functionCallIR::extractObject (const GALGAS_object & inObject,
                                                            C_Compiler * inCompiler
                                                            COMMA_LOCATION_ARGS) {
  GALGAS_functionCallIR result ;
  const GALGAS_functionCallIR * p = (const GALGAS_functionCallIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_functionCallIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("functionCallIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_ifInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_ifInstructionIR * p = (const cPtr_ifInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_ifInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTestVariable.objectCompare (p->mAttribute_mTestVariable) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mThenInstructionGenerationList.objectCompare (p->mAttribute_mThenInstructionGenerationList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mElseInstructionGenerationList.objectCompare (p->mAttribute_mElseInstructionGenerationList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_ifInstructionIR::objectCompare (const GALGAS_ifInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionIR::GALGAS_ifInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionIR::GALGAS_ifInstructionIR (const cPtr_ifInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_ifInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionIR GALGAS_ifInstructionIR::constructor_new (const GALGAS_variableKindIR & inAttribute_mTestVariable,
                                                                const GALGAS_instructionListIR & inAttribute_mThenInstructionGenerationList,
                                                                const GALGAS_instructionListIR & inAttribute_mElseInstructionGenerationList
                                                                COMMA_LOCATION_ARGS) {
  GALGAS_ifInstructionIR result ;
  if (inAttribute_mTestVariable.isValid () && inAttribute_mThenInstructionGenerationList.isValid () && inAttribute_mElseInstructionGenerationList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_ifInstructionIR (inAttribute_mTestVariable, inAttribute_mThenInstructionGenerationList, inAttribute_mElseInstructionGenerationList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_ifInstructionIR::reader_mTestVariable (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionIR * p = (const cPtr_ifInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionIR) ;
    result = p->mAttribute_mTestVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_ifInstructionIR::reader_mTestVariable (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTestVariable ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR GALGAS_ifInstructionIR::reader_mThenInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionIR * p = (const cPtr_ifInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionIR) ;
    result = p->mAttribute_mThenInstructionGenerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR cPtr_ifInstructionIR::reader_mThenInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mThenInstructionGenerationList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR GALGAS_ifInstructionIR::reader_mElseInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionIR * p = (const cPtr_ifInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionIR) ;
    result = p->mAttribute_mElseInstructionGenerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR cPtr_ifInstructionIR::reader_mElseInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mElseInstructionGenerationList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                      Pointer class for @ifInstructionIR class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_ifInstructionIR::cPtr_ifInstructionIR (const GALGAS_variableKindIR & in_mTestVariable,
                                            const GALGAS_instructionListIR & in_mThenInstructionGenerationList,
                                            const GALGAS_instructionListIR & in_mElseInstructionGenerationList
                                            COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTestVariable (in_mTestVariable),
mAttribute_mThenInstructionGenerationList (in_mThenInstructionGenerationList),
mAttribute_mElseInstructionGenerationList (in_mElseInstructionGenerationList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_ifInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_ifInstructionIR ;
}

void cPtr_ifInstructionIR::description (C_String & ioString,
                                        const int32_t inIndentation) const {
  ioString << "[@ifInstructionIR:" ;
  mAttribute_mTestVariable.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mThenInstructionGenerationList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mElseInstructionGenerationList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_ifInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_ifInstructionIR (mAttribute_mTestVariable, mAttribute_mThenInstructionGenerationList, mAttribute_mElseInstructionGenerationList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @ifInstructionIR type                                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_ifInstructionIR ("ifInstructionIR",
                                        & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_ifInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_ifInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_ifInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_ifInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionIR GALGAS_ifInstructionIR::extractObject (const GALGAS_object & inObject,
                                                              C_Compiler * inCompiler
                                                              COMMA_LOCATION_ARGS) {
  GALGAS_ifInstructionIR result ;
  const GALGAS_ifInstructionIR * p = (const GALGAS_ifInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_ifInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("ifInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_incDecInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_incDecInstructionIR * p = (const cPtr_incDecInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_incDecInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mMin.objectCompare (p->mAttribute_mMin) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mMax.objectCompare (p->mAttribute_mMax) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mKind.objectCompare (p->mAttribute_mKind) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mVariable.objectCompare (p->mAttribute_mVariable) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mVariableLocation.objectCompare (p->mAttribute_mVariableLocation) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_incDecInstructionIR::objectCompare (const GALGAS_incDecInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionIR::GALGAS_incDecInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionIR::GALGAS_incDecInstructionIR (const cPtr_incDecInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_incDecInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionIR GALGAS_incDecInstructionIR::constructor_new (const GALGAS_sint_36__34_ & inAttribute_mMin,
                                                                        const GALGAS_uint_36__34_ & inAttribute_mMax,
                                                                        const GALGAS_incDecKind & inAttribute_mKind,
                                                                        const GALGAS_variableKindIR & inAttribute_mVariable,
                                                                        const GALGAS_location & inAttribute_mVariableLocation
                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_incDecInstructionIR result ;
  if (inAttribute_mMin.isValid () && inAttribute_mMax.isValid () && inAttribute_mKind.isValid () && inAttribute_mVariable.isValid () && inAttribute_mVariableLocation.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_incDecInstructionIR (inAttribute_mMin, inAttribute_mMax, inAttribute_mKind, inAttribute_mVariable, inAttribute_mVariableLocation COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_sint_36__34_ GALGAS_incDecInstructionIR::reader_mMin (UNUSED_LOCATION_ARGS) const {
  GALGAS_sint_36__34_ result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionIR * p = (const cPtr_incDecInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionIR) ;
    result = p->mAttribute_mMin ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_sint_36__34_ cPtr_incDecInstructionIR::reader_mMin (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mMin ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_uint_36__34_ GALGAS_incDecInstructionIR::reader_mMax (UNUSED_LOCATION_ARGS) const {
  GALGAS_uint_36__34_ result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionIR * p = (const cPtr_incDecInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionIR) ;
    result = p->mAttribute_mMax ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_uint_36__34_ cPtr_incDecInstructionIR::reader_mMax (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mMax ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecKind GALGAS_incDecInstructionIR::reader_mKind (UNUSED_LOCATION_ARGS) const {
  GALGAS_incDecKind result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionIR * p = (const cPtr_incDecInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionIR) ;
    result = p->mAttribute_mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecKind cPtr_incDecInstructionIR::reader_mKind (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mKind ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_incDecInstructionIR::reader_mVariable (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionIR * p = (const cPtr_incDecInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionIR) ;
    result = p->mAttribute_mVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_incDecInstructionIR::reader_mVariable (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mVariable ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_incDecInstructionIR::reader_mVariableLocation (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionIR * p = (const cPtr_incDecInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionIR) ;
    result = p->mAttribute_mVariableLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_incDecInstructionIR::reader_mVariableLocation (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mVariableLocation ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @incDecInstructionIR class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_incDecInstructionIR::cPtr_incDecInstructionIR (const GALGAS_sint_36__34_ & in_mMin,
                                                    const GALGAS_uint_36__34_ & in_mMax,
                                                    const GALGAS_incDecKind & in_mKind,
                                                    const GALGAS_variableKindIR & in_mVariable,
                                                    const GALGAS_location & in_mVariableLocation
                                                    COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mMin (in_mMin),
mAttribute_mMax (in_mMax),
mAttribute_mKind (in_mKind),
mAttribute_mVariable (in_mVariable),
mAttribute_mVariableLocation (in_mVariableLocation) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_incDecInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_incDecInstructionIR ;
}

void cPtr_incDecInstructionIR::description (C_String & ioString,
                                            const int32_t inIndentation) const {
  ioString << "[@incDecInstructionIR:" ;
  mAttribute_mMin.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mMax.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mKind.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mVariable.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mVariableLocation.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_incDecInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_incDecInstructionIR (mAttribute_mMin, mAttribute_mMax, mAttribute_mKind, mAttribute_mVariable, mAttribute_mVariableLocation COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @incDecInstructionIR type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_incDecInstructionIR ("incDecInstructionIR",
                                            & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_incDecInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_incDecInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_incDecInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_incDecInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionIR GALGAS_incDecInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                      C_Compiler * inCompiler
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_incDecInstructionIR result ;
  const GALGAS_incDecInstructionIR * p = (const GALGAS_incDecInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_incDecInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("incDecInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_letInstructionWithAssignmentIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_letInstructionWithAssignmentIR * p = (const cPtr_letInstructionWithAssignmentIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_letInstructionWithAssignmentIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTargetConstantIR.objectCompare (p->mAttribute_mTargetConstantIR) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceIR.objectCompare (p->mAttribute_mSourceIR) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_letInstructionWithAssignmentIR::objectCompare (const GALGAS_letInstructionWithAssignmentIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_letInstructionWithAssignmentIR::GALGAS_letInstructionWithAssignmentIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_letInstructionWithAssignmentIR::GALGAS_letInstructionWithAssignmentIR (const cPtr_letInstructionWithAssignmentIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_letInstructionWithAssignmentIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_letInstructionWithAssignmentIR GALGAS_letInstructionWithAssignmentIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                                              const GALGAS_variableKindIR & inAttribute_mTargetConstantIR,
                                                                                              const GALGAS_variableKindIR & inAttribute_mSourceIR
                                                                                              COMMA_LOCATION_ARGS) {
  GALGAS_letInstructionWithAssignmentIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mTargetConstantIR.isValid () && inAttribute_mSourceIR.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_letInstructionWithAssignmentIR (inAttribute_mTargetType, inAttribute_mTargetConstantIR, inAttribute_mSourceIR COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_letInstructionWithAssignmentIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_letInstructionWithAssignmentIR * p = (const cPtr_letInstructionWithAssignmentIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_letInstructionWithAssignmentIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_letInstructionWithAssignmentIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_letInstructionWithAssignmentIR::reader_mTargetConstantIR (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_letInstructionWithAssignmentIR * p = (const cPtr_letInstructionWithAssignmentIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_letInstructionWithAssignmentIR) ;
    result = p->mAttribute_mTargetConstantIR ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_letInstructionWithAssignmentIR::reader_mTargetConstantIR (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetConstantIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_letInstructionWithAssignmentIR::reader_mSourceIR (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_letInstructionWithAssignmentIR * p = (const cPtr_letInstructionWithAssignmentIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_letInstructionWithAssignmentIR) ;
    result = p->mAttribute_mSourceIR ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_letInstructionWithAssignmentIR::reader_mSourceIR (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceIR ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                               Pointer class for @letInstructionWithAssignmentIR class                               *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_letInstructionWithAssignmentIR::cPtr_letInstructionWithAssignmentIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                                                          const GALGAS_variableKindIR & in_mTargetConstantIR,
                                                                          const GALGAS_variableKindIR & in_mSourceIR
                                                                          COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mTargetConstantIR (in_mTargetConstantIR),
mAttribute_mSourceIR (in_mSourceIR) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_letInstructionWithAssignmentIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_letInstructionWithAssignmentIR ;
}

void cPtr_letInstructionWithAssignmentIR::description (C_String & ioString,
                                                       const int32_t inIndentation) const {
  ioString << "[@letInstructionWithAssignmentIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTargetConstantIR.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceIR.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_letInstructionWithAssignmentIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_letInstructionWithAssignmentIR (mAttribute_mTargetType, mAttribute_mTargetConstantIR, mAttribute_mSourceIR COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                        @letInstructionWithAssignmentIR type                                         *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_letInstructionWithAssignmentIR ("letInstructionWithAssignmentIR",
                                                       & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_letInstructionWithAssignmentIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_letInstructionWithAssignmentIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_letInstructionWithAssignmentIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_letInstructionWithAssignmentIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_letInstructionWithAssignmentIR GALGAS_letInstructionWithAssignmentIR::extractObject (const GALGAS_object & inObject,
                                                                                            C_Compiler * inCompiler
                                                                                            COMMA_LOCATION_ARGS) {
  GALGAS_letInstructionWithAssignmentIR result ;
  const GALGAS_letInstructionWithAssignmentIR * p = (const GALGAS_letInstructionWithAssignmentIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_letInstructionWithAssignmentIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("letInstructionWithAssignmentIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_operatorAssignInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_operatorAssignInstructionIR * p = (const cPtr_operatorAssignInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_operatorAssignInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVariable.objectCompare (p->mAttribute_mTargetVariable) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVarType.objectCompare (p->mAttribute_mTargetVarType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperator.objectCompare (p->mAttribute_mOperator) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceValue.objectCompare (p->mAttribute_mSourceValue) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_operatorAssignInstructionIR::objectCompare (const GALGAS_operatorAssignInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorAssignInstructionIR::GALGAS_operatorAssignInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorAssignInstructionIR::GALGAS_operatorAssignInstructionIR (const cPtr_operatorAssignInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_operatorAssignInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorAssignInstructionIR GALGAS_operatorAssignInstructionIR::constructor_new (const GALGAS_variableKindIR & inAttribute_mTargetVariable,
                                                                                        const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetVarType,
                                                                                        const GALGAS_operatorAssignKind & inAttribute_mOperator,
                                                                                        const GALGAS_variableKindIR & inAttribute_mSourceValue
                                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_operatorAssignInstructionIR result ;
  if (inAttribute_mTargetVariable.isValid () && inAttribute_mTargetVarType.isValid () && inAttribute_mOperator.isValid () && inAttribute_mSourceValue.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_operatorAssignInstructionIR (inAttribute_mTargetVariable, inAttribute_mTargetVarType, inAttribute_mOperator, inAttribute_mSourceValue COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_operatorAssignInstructionIR::reader_mTargetVariable (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorAssignInstructionIR * p = (const cPtr_operatorAssignInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorAssignInstructionIR) ;
    result = p->mAttribute_mTargetVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_operatorAssignInstructionIR::reader_mTargetVariable (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVariable ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_operatorAssignInstructionIR::reader_mTargetVarType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorAssignInstructionIR * p = (const cPtr_operatorAssignInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorAssignInstructionIR) ;
    result = p->mAttribute_mTargetVarType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_operatorAssignInstructionIR::reader_mTargetVarType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVarType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorAssignKind GALGAS_operatorAssignInstructionIR::reader_mOperator (UNUSED_LOCATION_ARGS) const {
  GALGAS_operatorAssignKind result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorAssignInstructionIR * p = (const cPtr_operatorAssignInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorAssignInstructionIR) ;
    result = p->mAttribute_mOperator ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorAssignKind cPtr_operatorAssignInstructionIR::reader_mOperator (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperator ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_operatorAssignInstructionIR::reader_mSourceValue (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorAssignInstructionIR * p = (const cPtr_operatorAssignInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorAssignInstructionIR) ;
    result = p->mAttribute_mSourceValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_operatorAssignInstructionIR::reader_mSourceValue (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceValue ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                Pointer class for @operatorAssignInstructionIR class                                 *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_operatorAssignInstructionIR::cPtr_operatorAssignInstructionIR (const GALGAS_variableKindIR & in_mTargetVariable,
                                                                    const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetVarType,
                                                                    const GALGAS_operatorAssignKind & in_mOperator,
                                                                    const GALGAS_variableKindIR & in_mSourceValue
                                                                    COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetVariable (in_mTargetVariable),
mAttribute_mTargetVarType (in_mTargetVarType),
mAttribute_mOperator (in_mOperator),
mAttribute_mSourceValue (in_mSourceValue) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_operatorAssignInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_operatorAssignInstructionIR ;
}

void cPtr_operatorAssignInstructionIR::description (C_String & ioString,
                                                    const int32_t inIndentation) const {
  ioString << "[@operatorAssignInstructionIR:" ;
  mAttribute_mTargetVariable.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTargetVarType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperator.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceValue.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_operatorAssignInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_operatorAssignInstructionIR (mAttribute_mTargetVariable, mAttribute_mTargetVarType, mAttribute_mOperator, mAttribute_mSourceValue COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          @operatorAssignInstructionIR type                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_operatorAssignInstructionIR ("operatorAssignInstructionIR",
                                                    & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_operatorAssignInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_operatorAssignInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_operatorAssignInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_operatorAssignInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorAssignInstructionIR GALGAS_operatorAssignInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                                      C_Compiler * inCompiler
                                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_operatorAssignInstructionIR result ;
  const GALGAS_operatorAssignInstructionIR * p = (const GALGAS_operatorAssignInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_operatorAssignInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("operatorAssignInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_operatorInfixExpressionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mResult.objectCompare (p->mAttribute_mResult) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mLeftOperand.objectCompare (p->mAttribute_mLeftOperand) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperator.objectCompare (p->mAttribute_mOperator) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mRighOperand.objectCompare (p->mAttribute_mRighOperand) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperatorLocation.objectCompare (p->mAttribute_mOperatorLocation) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_operatorInfixExpressionIR::objectCompare (const GALGAS_operatorInfixExpressionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorInfixExpressionIR::GALGAS_operatorInfixExpressionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorInfixExpressionIR::GALGAS_operatorInfixExpressionIR (const cPtr_operatorInfixExpressionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_operatorInfixExpressionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorInfixExpressionIR GALGAS_operatorInfixExpressionIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                                    const GALGAS_variableKindIR & inAttribute_mResult,
                                                                                    const GALGAS_variableKindIR & inAttribute_mLeftOperand,
                                                                                    const GALGAS_infixOperatorIR & inAttribute_mOperator,
                                                                                    const GALGAS_variableKindIR & inAttribute_mRighOperand,
                                                                                    const GALGAS_location & inAttribute_mOperatorLocation
                                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_operatorInfixExpressionIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mResult.isValid () && inAttribute_mLeftOperand.isValid () && inAttribute_mOperator.isValid () && inAttribute_mRighOperand.isValid () && inAttribute_mOperatorLocation.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_operatorInfixExpressionIR (inAttribute_mTargetType, inAttribute_mResult, inAttribute_mLeftOperand, inAttribute_mOperator, inAttribute_mRighOperand, inAttribute_mOperatorLocation COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_operatorInfixExpressionIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_operatorInfixExpressionIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_operatorInfixExpressionIR::reader_mResult (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
    result = p->mAttribute_mResult ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_operatorInfixExpressionIR::reader_mResult (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mResult ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_operatorInfixExpressionIR::reader_mLeftOperand (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
    result = p->mAttribute_mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_operatorInfixExpressionIR::reader_mLeftOperand (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLeftOperand ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperatorIR GALGAS_operatorInfixExpressionIR::reader_mOperator (UNUSED_LOCATION_ARGS) const {
  GALGAS_infixOperatorIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
    result = p->mAttribute_mOperator ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperatorIR cPtr_operatorInfixExpressionIR::reader_mOperator (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperator ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_operatorInfixExpressionIR::reader_mRighOperand (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
    result = p->mAttribute_mRighOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_operatorInfixExpressionIR::reader_mRighOperand (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mRighOperand ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_operatorInfixExpressionIR::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_operatorInfixExpressionIR * p = (const cPtr_operatorInfixExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_operatorInfixExpressionIR) ;
    result = p->mAttribute_mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_operatorInfixExpressionIR::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperatorLocation ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                 Pointer class for @operatorInfixExpressionIR class                                  *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_operatorInfixExpressionIR::cPtr_operatorInfixExpressionIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                                                const GALGAS_variableKindIR & in_mResult,
                                                                const GALGAS_variableKindIR & in_mLeftOperand,
                                                                const GALGAS_infixOperatorIR & in_mOperator,
                                                                const GALGAS_variableKindIR & in_mRighOperand,
                                                                const GALGAS_location & in_mOperatorLocation
                                                                COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mResult (in_mResult),
mAttribute_mLeftOperand (in_mLeftOperand),
mAttribute_mOperator (in_mOperator),
mAttribute_mRighOperand (in_mRighOperand),
mAttribute_mOperatorLocation (in_mOperatorLocation) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_operatorInfixExpressionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_operatorInfixExpressionIR ;
}

void cPtr_operatorInfixExpressionIR::description (C_String & ioString,
                                                  const int32_t inIndentation) const {
  ioString << "[@operatorInfixExpressionIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mResult.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mLeftOperand.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperator.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mRighOperand.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperatorLocation.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_operatorInfixExpressionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_operatorInfixExpressionIR (mAttribute_mTargetType, mAttribute_mResult, mAttribute_mLeftOperand, mAttribute_mOperator, mAttribute_mRighOperand, mAttribute_mOperatorLocation COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                           @operatorInfixExpressionIR type                                           *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_operatorInfixExpressionIR ("operatorInfixExpressionIR",
                                                  & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_operatorInfixExpressionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_operatorInfixExpressionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_operatorInfixExpressionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_operatorInfixExpressionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_operatorInfixExpressionIR GALGAS_operatorInfixExpressionIR::extractObject (const GALGAS_object & inObject,
                                                                                  C_Compiler * inCompiler
                                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_operatorInfixExpressionIR result ;
  const GALGAS_operatorInfixExpressionIR * p = (const GALGAS_operatorInfixExpressionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_operatorInfixExpressionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("operatorInfixExpressionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_prefixOperatorExpressionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_prefixOperatorExpressionIR * p = (const cPtr_prefixOperatorExpressionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_prefixOperatorExpressionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mResult.objectCompare (p->mAttribute_mResult) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperand.objectCompare (p->mAttribute_mOperand) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperator.objectCompare (p->mAttribute_mOperator) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperatorLocation.objectCompare (p->mAttribute_mOperatorLocation) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_prefixOperatorExpressionIR::objectCompare (const GALGAS_prefixOperatorExpressionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionIR::GALGAS_prefixOperatorExpressionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionIR::GALGAS_prefixOperatorExpressionIR (const cPtr_prefixOperatorExpressionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_prefixOperatorExpressionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionIR GALGAS_prefixOperatorExpressionIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                                      const GALGAS_variableKindIR & inAttribute_mResult,
                                                                                      const GALGAS_variableKindIR & inAttribute_mOperand,
                                                                                      const GALGAS_prefixOperatorIR & inAttribute_mOperator,
                                                                                      const GALGAS_location & inAttribute_mOperatorLocation
                                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_prefixOperatorExpressionIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mResult.isValid () && inAttribute_mOperand.isValid () && inAttribute_mOperator.isValid () && inAttribute_mOperatorLocation.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_prefixOperatorExpressionIR (inAttribute_mTargetType, inAttribute_mResult, inAttribute_mOperand, inAttribute_mOperator, inAttribute_mOperatorLocation COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_prefixOperatorExpressionIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionIR * p = (const cPtr_prefixOperatorExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_prefixOperatorExpressionIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_prefixOperatorExpressionIR::reader_mResult (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionIR * p = (const cPtr_prefixOperatorExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionIR) ;
    result = p->mAttribute_mResult ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_prefixOperatorExpressionIR::reader_mResult (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mResult ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_prefixOperatorExpressionIR::reader_mOperand (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionIR * p = (const cPtr_prefixOperatorExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionIR) ;
    result = p->mAttribute_mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_prefixOperatorExpressionIR::reader_mOperand (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperand ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorIR GALGAS_prefixOperatorExpressionIR::reader_mOperator (UNUSED_LOCATION_ARGS) const {
  GALGAS_prefixOperatorIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionIR * p = (const cPtr_prefixOperatorExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionIR) ;
    result = p->mAttribute_mOperator ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorIR cPtr_prefixOperatorExpressionIR::reader_mOperator (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperator ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_prefixOperatorExpressionIR::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionIR * p = (const cPtr_prefixOperatorExpressionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionIR) ;
    result = p->mAttribute_mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_prefixOperatorExpressionIR::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperatorLocation ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                 Pointer class for @prefixOperatorExpressionIR class                                 *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_prefixOperatorExpressionIR::cPtr_prefixOperatorExpressionIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                                                  const GALGAS_variableKindIR & in_mResult,
                                                                  const GALGAS_variableKindIR & in_mOperand,
                                                                  const GALGAS_prefixOperatorIR & in_mOperator,
                                                                  const GALGAS_location & in_mOperatorLocation
                                                                  COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mResult (in_mResult),
mAttribute_mOperand (in_mOperand),
mAttribute_mOperator (in_mOperator),
mAttribute_mOperatorLocation (in_mOperatorLocation) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_prefixOperatorExpressionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_prefixOperatorExpressionIR ;
}

void cPtr_prefixOperatorExpressionIR::description (C_String & ioString,
                                                   const int32_t inIndentation) const {
  ioString << "[@prefixOperatorExpressionIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mResult.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperand.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperator.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperatorLocation.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_prefixOperatorExpressionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_prefixOperatorExpressionIR (mAttribute_mTargetType, mAttribute_mResult, mAttribute_mOperand, mAttribute_mOperator, mAttribute_mOperatorLocation COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          @prefixOperatorExpressionIR type                                           *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_prefixOperatorExpressionIR ("prefixOperatorExpressionIR",
                                                   & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_prefixOperatorExpressionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_prefixOperatorExpressionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_prefixOperatorExpressionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_prefixOperatorExpressionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionIR GALGAS_prefixOperatorExpressionIR::extractObject (const GALGAS_object & inObject,
                                                                                    C_Compiler * inCompiler
                                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_prefixOperatorExpressionIR result ;
  const GALGAS_prefixOperatorExpressionIR * p = (const GALGAS_prefixOperatorExpressionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_prefixOperatorExpressionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("prefixOperatorExpressionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_procCallInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_procCallInstructionIR * p = (const cPtr_procCallInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_procCallInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mProcName.objectCompare (p->mAttribute_mProcName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mParameters.objectCompare (p->mAttribute_mParameters) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_procCallInstructionIR::objectCompare (const GALGAS_procCallInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallInstructionIR::GALGAS_procCallInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallInstructionIR GALGAS_procCallInstructionIR::constructor_default (LOCATION_ARGS) {
  return GALGAS_procCallInstructionIR::constructor_new (GALGAS_string::constructor_default (HERE),
                                                        GALGAS_procCallEffectiveParameterListIR::constructor_emptyList (HERE)
                                                        COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallInstructionIR::GALGAS_procCallInstructionIR (const cPtr_procCallInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_procCallInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallInstructionIR GALGAS_procCallInstructionIR::constructor_new (const GALGAS_string & inAttribute_mProcName,
                                                                            const GALGAS_procCallEffectiveParameterListIR & inAttribute_mParameters
                                                                            COMMA_LOCATION_ARGS) {
  GALGAS_procCallInstructionIR result ;
  if (inAttribute_mProcName.isValid () && inAttribute_mParameters.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_procCallInstructionIR (inAttribute_mProcName, inAttribute_mParameters COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_procCallInstructionIR::reader_mProcName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_procCallInstructionIR * p = (const cPtr_procCallInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_procCallInstructionIR) ;
    result = p->mAttribute_mProcName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_procCallInstructionIR::reader_mProcName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mProcName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallEffectiveParameterListIR GALGAS_procCallInstructionIR::reader_mParameters (UNUSED_LOCATION_ARGS) const {
  GALGAS_procCallEffectiveParameterListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_procCallInstructionIR * p = (const cPtr_procCallInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_procCallInstructionIR) ;
    result = p->mAttribute_mParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallEffectiveParameterListIR cPtr_procCallInstructionIR::reader_mParameters (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mParameters ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                   Pointer class for @procCallInstructionIR class                                    *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_procCallInstructionIR::cPtr_procCallInstructionIR (const GALGAS_string & in_mProcName,
                                                        const GALGAS_procCallEffectiveParameterListIR & in_mParameters
                                                        COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mProcName (in_mProcName),
mAttribute_mParameters (in_mParameters) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_procCallInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_procCallInstructionIR ;
}

void cPtr_procCallInstructionIR::description (C_String & ioString,
                                              const int32_t inIndentation) const {
  ioString << "[@procCallInstructionIR:" ;
  mAttribute_mProcName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mParameters.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_procCallInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_procCallInstructionIR (mAttribute_mProcName, mAttribute_mParameters COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             @procCallInstructionIR type                                             *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_procCallInstructionIR ("procCallInstructionIR",
                                              & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_procCallInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_procCallInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_procCallInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_procCallInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_procCallInstructionIR GALGAS_procCallInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                          C_Compiler * inCompiler
                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_procCallInstructionIR result ;
  const GALGAS_procCallInstructionIR * p = (const GALGAS_procCallInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_procCallInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("procCallInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_varDeclarationIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_varDeclarationIR * p = (const cPtr_varDeclarationIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_varDeclarationIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVar.objectCompare (p->mAttribute_mTargetVar) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_varDeclarationIR::objectCompare (const GALGAS_varDeclarationIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationIR::GALGAS_varDeclarationIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationIR::GALGAS_varDeclarationIR (const cPtr_varDeclarationIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_varDeclarationIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationIR GALGAS_varDeclarationIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                  const GALGAS_variableKindIR & inAttribute_mTargetVar
                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_varDeclarationIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mTargetVar.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_varDeclarationIR (inAttribute_mTargetType, inAttribute_mTargetVar COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_varDeclarationIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_varDeclarationIR * p = (const cPtr_varDeclarationIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_varDeclarationIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_varDeclarationIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_varDeclarationIR::reader_mTargetVar (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_varDeclarationIR * p = (const cPtr_varDeclarationIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_varDeclarationIR) ;
    result = p->mAttribute_mTargetVar ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_varDeclarationIR::reader_mTargetVar (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVar ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                      Pointer class for @varDeclarationIR class                                      *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_varDeclarationIR::cPtr_varDeclarationIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                              const GALGAS_variableKindIR & in_mTargetVar
                                              COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mTargetVar (in_mTargetVar) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_varDeclarationIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_varDeclarationIR ;
}

void cPtr_varDeclarationIR::description (C_String & ioString,
                                         const int32_t inIndentation) const {
  ioString << "[@varDeclarationIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTargetVar.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_varDeclarationIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_varDeclarationIR (mAttribute_mTargetType, mAttribute_mTargetVar COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                               @varDeclarationIR type                                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_varDeclarationIR ("varDeclarationIR",
                                         & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_varDeclarationIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_varDeclarationIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_varDeclarationIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_varDeclarationIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationIR GALGAS_varDeclarationIR::extractObject (const GALGAS_object & inObject,
                                                                C_Compiler * inCompiler
                                                                COMMA_LOCATION_ARGS) {
  GALGAS_varDeclarationIR result ;
  const GALGAS_varDeclarationIR * p = (const GALGAS_varDeclarationIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_varDeclarationIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("varDeclarationIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_varDeclarationInstructionWithSimpleAssignmentIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_varDeclarationInstructionWithSimpleAssignmentIR * p = (const cPtr_varDeclarationInstructionWithSimpleAssignmentIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_varDeclarationInstructionWithSimpleAssignmentIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetType.objectCompare (p->mAttribute_mTargetType) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVar.objectCompare (p->mAttribute_mTargetVar) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceVar.objectCompare (p->mAttribute_mSourceVar) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::objectCompare (const GALGAS_varDeclarationInstructionWithSimpleAssignmentIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::GALGAS_varDeclarationInstructionWithSimpleAssignmentIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::GALGAS_varDeclarationInstructionWithSimpleAssignmentIR (const cPtr_varDeclarationInstructionWithSimpleAssignmentIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_varDeclarationInstructionWithSimpleAssignmentIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationInstructionWithSimpleAssignmentIR GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::constructor_new (const GALGAS_unifiedTypeMap_2D_proxy & inAttribute_mTargetType,
                                                                                                                                const GALGAS_variableKindIR & inAttribute_mTargetVar,
                                                                                                                                const GALGAS_variableKindIR & inAttribute_mSourceVar
                                                                                                                                COMMA_LOCATION_ARGS) {
  GALGAS_varDeclarationInstructionWithSimpleAssignmentIR result ;
  if (inAttribute_mTargetType.isValid () && inAttribute_mTargetVar.isValid () && inAttribute_mSourceVar.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_varDeclarationInstructionWithSimpleAssignmentIR (inAttribute_mTargetType, inAttribute_mTargetVar, inAttribute_mSourceVar COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  GALGAS_unifiedTypeMap_2D_proxy result ;
  if (NULL != mObjectPtr) {
    const cPtr_varDeclarationInstructionWithSimpleAssignmentIR * p = (const cPtr_varDeclarationInstructionWithSimpleAssignmentIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_varDeclarationInstructionWithSimpleAssignmentIR) ;
    result = p->mAttribute_mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_unifiedTypeMap_2D_proxy cPtr_varDeclarationInstructionWithSimpleAssignmentIR::reader_mTargetType (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetType ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::reader_mTargetVar (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_varDeclarationInstructionWithSimpleAssignmentIR * p = (const cPtr_varDeclarationInstructionWithSimpleAssignmentIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_varDeclarationInstructionWithSimpleAssignmentIR) ;
    result = p->mAttribute_mTargetVar ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_varDeclarationInstructionWithSimpleAssignmentIR::reader_mTargetVar (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVar ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::reader_mSourceVar (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_varDeclarationInstructionWithSimpleAssignmentIR * p = (const cPtr_varDeclarationInstructionWithSimpleAssignmentIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_varDeclarationInstructionWithSimpleAssignmentIR) ;
    result = p->mAttribute_mSourceVar ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_varDeclarationInstructionWithSimpleAssignmentIR::reader_mSourceVar (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceVar ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                      Pointer class for @varDeclarationInstructionWithSimpleAssignmentIR class                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_varDeclarationInstructionWithSimpleAssignmentIR::cPtr_varDeclarationInstructionWithSimpleAssignmentIR (const GALGAS_unifiedTypeMap_2D_proxy & in_mTargetType,
                                                                                                            const GALGAS_variableKindIR & in_mTargetVar,
                                                                                                            const GALGAS_variableKindIR & in_mSourceVar
                                                                                                            COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mTargetType (in_mTargetType),
mAttribute_mTargetVar (in_mTargetVar),
mAttribute_mSourceVar (in_mSourceVar) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_varDeclarationInstructionWithSimpleAssignmentIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_varDeclarationInstructionWithSimpleAssignmentIR ;
}

void cPtr_varDeclarationInstructionWithSimpleAssignmentIR::description (C_String & ioString,
                                                                        const int32_t inIndentation) const {
  ioString << "[@varDeclarationInstructionWithSimpleAssignmentIR:" ;
  mAttribute_mTargetType.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTargetVar.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceVar.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_varDeclarationInstructionWithSimpleAssignmentIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_varDeclarationInstructionWithSimpleAssignmentIR (mAttribute_mTargetType, mAttribute_mTargetVar, mAttribute_mSourceVar COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                @varDeclarationInstructionWithSimpleAssignmentIR type                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_varDeclarationInstructionWithSimpleAssignmentIR ("varDeclarationInstructionWithSimpleAssignmentIR",
                                                                        & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_varDeclarationInstructionWithSimpleAssignmentIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_varDeclarationInstructionWithSimpleAssignmentIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varDeclarationInstructionWithSimpleAssignmentIR GALGAS_varDeclarationInstructionWithSimpleAssignmentIR::extractObject (const GALGAS_object & inObject,
                                                                                                                              C_Compiler * inCompiler
                                                                                                                              COMMA_LOCATION_ARGS) {
  GALGAS_varDeclarationInstructionWithSimpleAssignmentIR result ;
  const GALGAS_varDeclarationInstructionWithSimpleAssignmentIR * p = (const GALGAS_varDeclarationInstructionWithSimpleAssignmentIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_varDeclarationInstructionWithSimpleAssignmentIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("varDeclarationInstructionWithSimpleAssignmentIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_whileInstructionIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_whileInstructionIR * p = (const cPtr_whileInstructionIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_whileInstructionIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mLabelIndex.objectCompare (p->mAttribute_mLabelIndex) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTestInstructionGenerationList.objectCompare (p->mAttribute_mTestInstructionGenerationList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTestExpression.objectCompare (p->mAttribute_mTestExpression) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mInstructionGenerationList.objectCompare (p->mAttribute_mInstructionGenerationList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_whileInstructionIR::objectCompare (const GALGAS_whileInstructionIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_whileInstructionIR::GALGAS_whileInstructionIR (void) :
GALGAS_abstractInstructionIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_whileInstructionIR::GALGAS_whileInstructionIR (const cPtr_whileInstructionIR * inSourcePtr) :
GALGAS_abstractInstructionIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_whileInstructionIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_whileInstructionIR GALGAS_whileInstructionIR::constructor_new (const GALGAS_uint & inAttribute_mLabelIndex,
                                                                      const GALGAS_instructionListIR & inAttribute_mTestInstructionGenerationList,
                                                                      const GALGAS_variableKindIR & inAttribute_mTestExpression,
                                                                      const GALGAS_instructionListIR & inAttribute_mInstructionGenerationList
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_whileInstructionIR result ;
  if (inAttribute_mLabelIndex.isValid () && inAttribute_mTestInstructionGenerationList.isValid () && inAttribute_mTestExpression.isValid () && inAttribute_mInstructionGenerationList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_whileInstructionIR (inAttribute_mLabelIndex, inAttribute_mTestInstructionGenerationList, inAttribute_mTestExpression, inAttribute_mInstructionGenerationList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_uint GALGAS_whileInstructionIR::reader_mLabelIndex (UNUSED_LOCATION_ARGS) const {
  GALGAS_uint result ;
  if (NULL != mObjectPtr) {
    const cPtr_whileInstructionIR * p = (const cPtr_whileInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_whileInstructionIR) ;
    result = p->mAttribute_mLabelIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_uint cPtr_whileInstructionIR::reader_mLabelIndex (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLabelIndex ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR GALGAS_whileInstructionIR::reader_mTestInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_whileInstructionIR * p = (const cPtr_whileInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_whileInstructionIR) ;
    result = p->mAttribute_mTestInstructionGenerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR cPtr_whileInstructionIR::reader_mTestInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTestInstructionGenerationList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR GALGAS_whileInstructionIR::reader_mTestExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_variableKindIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_whileInstructionIR * p = (const cPtr_whileInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_whileInstructionIR) ;
    result = p->mAttribute_mTestExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_variableKindIR cPtr_whileInstructionIR::reader_mTestExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTestExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR GALGAS_whileInstructionIR::reader_mInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListIR result ;
  if (NULL != mObjectPtr) {
    const cPtr_whileInstructionIR * p = (const cPtr_whileInstructionIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_whileInstructionIR) ;
    result = p->mAttribute_mInstructionGenerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListIR cPtr_whileInstructionIR::reader_mInstructionGenerationList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mInstructionGenerationList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                     Pointer class for @whileInstructionIR class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_whileInstructionIR::cPtr_whileInstructionIR (const GALGAS_uint & in_mLabelIndex,
                                                  const GALGAS_instructionListIR & in_mTestInstructionGenerationList,
                                                  const GALGAS_variableKindIR & in_mTestExpression,
                                                  const GALGAS_instructionListIR & in_mInstructionGenerationList
                                                  COMMA_LOCATION_ARGS) :
cPtr_abstractInstructionIR (THERE),
mAttribute_mLabelIndex (in_mLabelIndex),
mAttribute_mTestInstructionGenerationList (in_mTestInstructionGenerationList),
mAttribute_mTestExpression (in_mTestExpression),
mAttribute_mInstructionGenerationList (in_mInstructionGenerationList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_whileInstructionIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_whileInstructionIR ;
}

void cPtr_whileInstructionIR::description (C_String & ioString,
                                           const int32_t inIndentation) const {
  ioString << "[@whileInstructionIR:" ;
  mAttribute_mLabelIndex.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTestInstructionGenerationList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTestExpression.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mInstructionGenerationList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_whileInstructionIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_whileInstructionIR (mAttribute_mLabelIndex, mAttribute_mTestInstructionGenerationList, mAttribute_mTestExpression, mAttribute_mInstructionGenerationList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @whileInstructionIR type                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_whileInstructionIR ("whileInstructionIR",
                                           & kTypeDescriptor_GALGAS_abstractInstructionIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_whileInstructionIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_whileInstructionIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_whileInstructionIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_whileInstructionIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_whileInstructionIR GALGAS_whileInstructionIR::extractObject (const GALGAS_object & inObject,
                                                                    C_Compiler * inCompiler
                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_whileInstructionIR result ;
  const GALGAS_whileInstructionIR * p = (const GALGAS_whileInstructionIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_whileInstructionIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("whileInstructionIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*



typeComparisonResult GALGAS_abstractTypeIR::objectCompare (const GALGAS_abstractTypeIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractTypeIR::GALGAS_abstractTypeIR (void) :
AC_GALGAS_class () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractTypeIR::GALGAS_abstractTypeIR (const cPtr_abstractTypeIR * inSourcePtr) :
AC_GALGAS_class (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_abstractTypeIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                       Pointer class for @abstractTypeIR class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_abstractTypeIR::cPtr_abstractTypeIR (LOCATION_ARGS) :
acPtr_class (THERE) {
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @abstractTypeIR type                                                 *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_abstractTypeIR ("abstractTypeIR",
                                       NULL) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_abstractTypeIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_abstractTypeIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_abstractTypeIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_abstractTypeIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_abstractTypeIR GALGAS_abstractTypeIR::extractObject (const GALGAS_object & inObject,
                                                            C_Compiler * inCompiler
                                                            COMMA_LOCATION_ARGS) {
  GALGAS_abstractTypeIR result ;
  const GALGAS_abstractTypeIR * p = (const GALGAS_abstractTypeIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_abstractTypeIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("abstractTypeIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_booleanIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_booleanIR * p = (const cPtr_booleanIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_booleanIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mBooleanTypeName.objectCompare (p->mAttribute_mBooleanTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mActualTypeName.objectCompare (p->mAttribute_mActualTypeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_booleanIR::objectCompare (const GALGAS_booleanIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanIR::GALGAS_booleanIR (void) :
GALGAS_abstractTypeIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanIR GALGAS_booleanIR::constructor_default (LOCATION_ARGS) {
  return GALGAS_booleanIR::constructor_new (GALGAS_string::constructor_default (HERE),
                                            GALGAS_string::constructor_default (HERE)
                                            COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanIR::GALGAS_booleanIR (const cPtr_booleanIR * inSourcePtr) :
GALGAS_abstractTypeIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_booleanIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanIR GALGAS_booleanIR::constructor_new (const GALGAS_string & inAttribute_mBooleanTypeName,
                                                    const GALGAS_string & inAttribute_mActualTypeName
                                                    COMMA_LOCATION_ARGS) {
  GALGAS_booleanIR result ;
  if (inAttribute_mBooleanTypeName.isValid () && inAttribute_mActualTypeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_booleanIR (inAttribute_mBooleanTypeName, inAttribute_mActualTypeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_booleanIR::reader_mBooleanTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_booleanIR * p = (const cPtr_booleanIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_booleanIR) ;
    result = p->mAttribute_mBooleanTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_booleanIR::reader_mBooleanTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mBooleanTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_booleanIR::reader_mActualTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_booleanIR * p = (const cPtr_booleanIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_booleanIR) ;
    result = p->mAttribute_mActualTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_booleanIR::reader_mActualTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mActualTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                         Pointer class for @booleanIR class                                          *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_booleanIR::cPtr_booleanIR (const GALGAS_string & in_mBooleanTypeName,
                                const GALGAS_string & in_mActualTypeName
                                COMMA_LOCATION_ARGS) :
cPtr_abstractTypeIR (THERE),
mAttribute_mBooleanTypeName (in_mBooleanTypeName),
mAttribute_mActualTypeName (in_mActualTypeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_booleanIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_booleanIR ;
}

void cPtr_booleanIR::description (C_String & ioString,
                                  const int32_t inIndentation) const {
  ioString << "[@booleanIR:" ;
  mAttribute_mBooleanTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mActualTypeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_booleanIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_booleanIR (mAttribute_mBooleanTypeName, mAttribute_mActualTypeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                   @booleanIR type                                                   *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_booleanIR ("booleanIR",
                                  & kTypeDescriptor_GALGAS_abstractTypeIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_booleanIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_booleanIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_booleanIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_booleanIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_booleanIR GALGAS_booleanIR::extractObject (const GALGAS_object & inObject,
                                                  C_Compiler * inCompiler
                                                  COMMA_LOCATION_ARGS) {
  GALGAS_booleanIR result ;
  const GALGAS_booleanIR * p = (const GALGAS_booleanIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_booleanIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("booleanIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_enumerationIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_enumerationIR * p = (const cPtr_enumerationIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_enumerationIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mEnumerationName.objectCompare (p->mAttribute_mEnumerationName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mActualTypeName.objectCompare (p->mAttribute_mActualTypeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_enumerationIR::objectCompare (const GALGAS_enumerationIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationIR::GALGAS_enumerationIR (void) :
GALGAS_abstractTypeIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationIR GALGAS_enumerationIR::constructor_default (LOCATION_ARGS) {
  return GALGAS_enumerationIR::constructor_new (GALGAS_string::constructor_default (HERE),
                                                GALGAS_string::constructor_default (HERE)
                                                COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationIR::GALGAS_enumerationIR (const cPtr_enumerationIR * inSourcePtr) :
GALGAS_abstractTypeIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_enumerationIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationIR GALGAS_enumerationIR::constructor_new (const GALGAS_string & inAttribute_mEnumerationName,
                                                            const GALGAS_string & inAttribute_mActualTypeName
                                                            COMMA_LOCATION_ARGS) {
  GALGAS_enumerationIR result ;
  if (inAttribute_mEnumerationName.isValid () && inAttribute_mActualTypeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_enumerationIR (inAttribute_mEnumerationName, inAttribute_mActualTypeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_enumerationIR::reader_mEnumerationName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_enumerationIR * p = (const cPtr_enumerationIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_enumerationIR) ;
    result = p->mAttribute_mEnumerationName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_enumerationIR::reader_mEnumerationName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mEnumerationName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_enumerationIR::reader_mActualTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_enumerationIR * p = (const cPtr_enumerationIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_enumerationIR) ;
    result = p->mAttribute_mActualTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_enumerationIR::reader_mActualTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mActualTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                       Pointer class for @enumerationIR class                                        *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_enumerationIR::cPtr_enumerationIR (const GALGAS_string & in_mEnumerationName,
                                        const GALGAS_string & in_mActualTypeName
                                        COMMA_LOCATION_ARGS) :
cPtr_abstractTypeIR (THERE),
mAttribute_mEnumerationName (in_mEnumerationName),
mAttribute_mActualTypeName (in_mActualTypeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_enumerationIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_enumerationIR ;
}

void cPtr_enumerationIR::description (C_String & ioString,
                                      const int32_t inIndentation) const {
  ioString << "[@enumerationIR:" ;
  mAttribute_mEnumerationName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mActualTypeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_enumerationIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_enumerationIR (mAttribute_mEnumerationName, mAttribute_mActualTypeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                 @enumerationIR type                                                 *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_enumerationIR ("enumerationIR",
                                      & kTypeDescriptor_GALGAS_abstractTypeIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_enumerationIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_enumerationIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_enumerationIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_enumerationIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_enumerationIR GALGAS_enumerationIR::extractObject (const GALGAS_object & inObject,
                                                          C_Compiler * inCompiler
                                                          COMMA_LOCATION_ARGS) {
  GALGAS_enumerationIR result ;
  const GALGAS_enumerationIR * p = (const GALGAS_enumerationIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_enumerationIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("enumerationIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_integerIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_integerIR * p = (const cPtr_integerIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_integerIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mIntegerTypeName.objectCompare (p->mAttribute_mIntegerTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mActualTypeName.objectCompare (p->mAttribute_mActualTypeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_integerIR::objectCompare (const GALGAS_integerIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerIR::GALGAS_integerIR (void) :
GALGAS_abstractTypeIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerIR GALGAS_integerIR::constructor_default (LOCATION_ARGS) {
  return GALGAS_integerIR::constructor_new (GALGAS_string::constructor_default (HERE),
                                            GALGAS_string::constructor_default (HERE)
                                            COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerIR::GALGAS_integerIR (const cPtr_integerIR * inSourcePtr) :
GALGAS_abstractTypeIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_integerIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerIR GALGAS_integerIR::constructor_new (const GALGAS_string & inAttribute_mIntegerTypeName,
                                                    const GALGAS_string & inAttribute_mActualTypeName
                                                    COMMA_LOCATION_ARGS) {
  GALGAS_integerIR result ;
  if (inAttribute_mIntegerTypeName.isValid () && inAttribute_mActualTypeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_integerIR (inAttribute_mIntegerTypeName, inAttribute_mActualTypeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_integerIR::reader_mIntegerTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_integerIR * p = (const cPtr_integerIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_integerIR) ;
    result = p->mAttribute_mIntegerTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_integerIR::reader_mIntegerTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mIntegerTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_integerIR::reader_mActualTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_integerIR * p = (const cPtr_integerIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_integerIR) ;
    result = p->mAttribute_mActualTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_integerIR::reader_mActualTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mActualTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                         Pointer class for @integerIR class                                          *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_integerIR::cPtr_integerIR (const GALGAS_string & in_mIntegerTypeName,
                                const GALGAS_string & in_mActualTypeName
                                COMMA_LOCATION_ARGS) :
cPtr_abstractTypeIR (THERE),
mAttribute_mIntegerTypeName (in_mIntegerTypeName),
mAttribute_mActualTypeName (in_mActualTypeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_integerIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_integerIR ;
}

void cPtr_integerIR::description (C_String & ioString,
                                  const int32_t inIndentation) const {
  ioString << "[@integerIR:" ;
  mAttribute_mIntegerTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mActualTypeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_integerIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_integerIR (mAttribute_mIntegerTypeName, mAttribute_mActualTypeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                   @integerIR type                                                   *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_integerIR ("integerIR",
                                  & kTypeDescriptor_GALGAS_abstractTypeIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_integerIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_integerIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_integerIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_integerIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_integerIR GALGAS_integerIR::extractObject (const GALGAS_object & inObject,
                                                  C_Compiler * inCompiler
                                                  COMMA_LOCATION_ARGS) {
  GALGAS_integerIR result ;
  const GALGAS_integerIR * p = (const GALGAS_integerIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_integerIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("integerIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_literalStringTypeIR::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_literalStringTypeIR * p = (const cPtr_literalStringTypeIR *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_literalStringTypeIR) ;
  if (kOperandEqual == result) {
    result = mAttribute_mLiteralStringTypeName.objectCompare (p->mAttribute_mLiteralStringTypeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_literalStringTypeIR::objectCompare (const GALGAS_literalStringTypeIR & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringTypeIR::GALGAS_literalStringTypeIR (void) :
GALGAS_abstractTypeIR () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringTypeIR GALGAS_literalStringTypeIR::constructor_default (LOCATION_ARGS) {
  return GALGAS_literalStringTypeIR::constructor_new (GALGAS_string::constructor_default (HERE)
                                                      COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringTypeIR::GALGAS_literalStringTypeIR (const cPtr_literalStringTypeIR * inSourcePtr) :
GALGAS_abstractTypeIR (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_literalStringTypeIR) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringTypeIR GALGAS_literalStringTypeIR::constructor_new (const GALGAS_string & inAttribute_mLiteralStringTypeName
                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_literalStringTypeIR result ;
  if (inAttribute_mLiteralStringTypeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_literalStringTypeIR (inAttribute_mLiteralStringTypeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string GALGAS_literalStringTypeIR::reader_mLiteralStringTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_string result ;
  if (NULL != mObjectPtr) {
    const cPtr_literalStringTypeIR * p = (const cPtr_literalStringTypeIR *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_literalStringTypeIR) ;
    result = p->mAttribute_mLiteralStringTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_string cPtr_literalStringTypeIR::reader_mLiteralStringTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLiteralStringTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @literalStringTypeIR class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_literalStringTypeIR::cPtr_literalStringTypeIR (const GALGAS_string & in_mLiteralStringTypeName
                                                    COMMA_LOCATION_ARGS) :
cPtr_abstractTypeIR (THERE),
mAttribute_mLiteralStringTypeName (in_mLiteralStringTypeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_literalStringTypeIR::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalStringTypeIR ;
}

void cPtr_literalStringTypeIR::description (C_String & ioString,
                                            const int32_t inIndentation) const {
  ioString << "[@literalStringTypeIR:" ;
  mAttribute_mLiteralStringTypeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_literalStringTypeIR::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_literalStringTypeIR (mAttribute_mLiteralStringTypeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @literalStringTypeIR type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_literalStringTypeIR ("literalStringTypeIR",
                                            & kTypeDescriptor_GALGAS_abstractTypeIR) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_literalStringTypeIR::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalStringTypeIR ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_literalStringTypeIR::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_literalStringTypeIR (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringTypeIR GALGAS_literalStringTypeIR::extractObject (const GALGAS_object & inObject,
                                                                      C_Compiler * inCompiler
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_literalStringTypeIR result ;
  const GALGAS_literalStringTypeIR * p = (const GALGAS_literalStringTypeIR *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_literalStringTypeIR *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("literalStringTypeIR", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*



typeComparisonResult GALGAS_expressionAST::objectCompare (const GALGAS_expressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST::GALGAS_expressionAST (void) :
AC_GALGAS_class () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST::GALGAS_expressionAST (const cPtr_expressionAST * inSourcePtr) :
AC_GALGAS_class (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_expressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                       Pointer class for @expressionAST class                                        *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_expressionAST::cPtr_expressionAST (LOCATION_ARGS) :
acPtr_class (THERE) {
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                 @expressionAST type                                                 *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_expressionAST ("expressionAST",
                                      NULL) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_expressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_expressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_expressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_expressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_expressionAST::extractObject (const GALGAS_object & inObject,
                                                          C_Compiler * inCompiler
                                                          COMMA_LOCATION_ARGS) {
  GALGAS_expressionAST result ;
  const GALGAS_expressionAST * p = (const GALGAS_expressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_expressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("expressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_asExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_asExpressionAST * p = (const cPtr_asExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_asExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mExpression.objectCompare (p->mAttribute_mExpression) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTypeName.objectCompare (p->mAttribute_mTypeName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_asExpressionAST::objectCompare (const GALGAS_asExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asExpressionAST::GALGAS_asExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asExpressionAST::GALGAS_asExpressionAST (const cPtr_asExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_asExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asExpressionAST GALGAS_asExpressionAST::constructor_new (const GALGAS_expressionAST & inAttribute_mExpression,
                                                                const GALGAS_lstring & inAttribute_mTypeName
                                                                COMMA_LOCATION_ARGS) {
  GALGAS_asExpressionAST result ;
  if (inAttribute_mExpression.isValid () && inAttribute_mTypeName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_asExpressionAST (inAttribute_mExpression, inAttribute_mTypeName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_asExpressionAST::reader_mExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_asExpressionAST * p = (const cPtr_asExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_asExpressionAST) ;
    result = p->mAttribute_mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_asExpressionAST::reader_mExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_asExpressionAST::reader_mTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_asExpressionAST * p = (const cPtr_asExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_asExpressionAST) ;
    result = p->mAttribute_mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_asExpressionAST::reader_mTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                      Pointer class for @asExpressionAST class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_asExpressionAST::cPtr_asExpressionAST (const GALGAS_expressionAST & in_mExpression,
                                            const GALGAS_lstring & in_mTypeName
                                            COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mExpression (in_mExpression),
mAttribute_mTypeName (in_mTypeName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_asExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_asExpressionAST ;
}

void cPtr_asExpressionAST::description (C_String & ioString,
                                        const int32_t inIndentation) const {
  ioString << "[@asExpressionAST:" ;
  mAttribute_mExpression.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTypeName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_asExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_asExpressionAST (mAttribute_mExpression, mAttribute_mTypeName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @asExpressionAST type                                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_asExpressionAST ("asExpressionAST",
                                        & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_asExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_asExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_asExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_asExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_asExpressionAST GALGAS_asExpressionAST::extractObject (const GALGAS_object & inObject,
                                                              C_Compiler * inCompiler
                                                              COMMA_LOCATION_ARGS) {
  GALGAS_asExpressionAST result ;
  const GALGAS_asExpressionAST * p = (const GALGAS_asExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_asExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("asExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_constructorCall::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_constructorCall * p = (const cPtr_constructorCall *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_constructorCall) ;
  if (kOperandEqual == result) {
    result = mAttribute_mOptionalTypeName.objectCompare (p->mAttribute_mOptionalTypeName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mConstructorName.objectCompare (p->mAttribute_mConstructorName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_constructorCall::objectCompare (const GALGAS_constructorCall & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCall::GALGAS_constructorCall (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCall GALGAS_constructorCall::constructor_default (LOCATION_ARGS) {
  return GALGAS_constructorCall::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                  GALGAS_lstring::constructor_default (HERE)
                                                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCall::GALGAS_constructorCall (const cPtr_constructorCall * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_constructorCall) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCall GALGAS_constructorCall::constructor_new (const GALGAS_lstring & inAttribute_mOptionalTypeName,
                                                                const GALGAS_lstring & inAttribute_mConstructorName
                                                                COMMA_LOCATION_ARGS) {
  GALGAS_constructorCall result ;
  if (inAttribute_mOptionalTypeName.isValid () && inAttribute_mConstructorName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_constructorCall (inAttribute_mOptionalTypeName, inAttribute_mConstructorName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_constructorCall::reader_mOptionalTypeName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_constructorCall * p = (const cPtr_constructorCall *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_constructorCall) ;
    result = p->mAttribute_mOptionalTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_constructorCall::reader_mOptionalTypeName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOptionalTypeName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_constructorCall::reader_mConstructorName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_constructorCall * p = (const cPtr_constructorCall *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_constructorCall) ;
    result = p->mAttribute_mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_constructorCall::reader_mConstructorName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mConstructorName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                      Pointer class for @constructorCall class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_constructorCall::cPtr_constructorCall (const GALGAS_lstring & in_mOptionalTypeName,
                                            const GALGAS_lstring & in_mConstructorName
                                            COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mOptionalTypeName (in_mOptionalTypeName),
mAttribute_mConstructorName (in_mConstructorName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_constructorCall::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_constructorCall ;
}

void cPtr_constructorCall::description (C_String & ioString,
                                        const int32_t inIndentation) const {
  ioString << "[@constructorCall:" ;
  mAttribute_mOptionalTypeName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mConstructorName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_constructorCall::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_constructorCall (mAttribute_mOptionalTypeName, mAttribute_mConstructorName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @constructorCall type                                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_constructorCall ("constructorCall",
                                        & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_constructorCall::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_constructorCall ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_constructorCall::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_constructorCall (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_constructorCall GALGAS_constructorCall::extractObject (const GALGAS_object & inObject,
                                                              C_Compiler * inCompiler
                                                              COMMA_LOCATION_ARGS) {
  GALGAS_constructorCall result ;
  const GALGAS_constructorCall * p = (const GALGAS_constructorCall *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_constructorCall *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("constructorCall", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_functionCallInExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_functionCallInExpressionAST * p = (const cPtr_functionCallInExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_functionCallInExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mFunctionVarName.objectCompare (p->mAttribute_mFunctionVarName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mParameterList.objectCompare (p->mAttribute_mParameterList) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_functionCallInExpressionAST::objectCompare (const GALGAS_functionCallInExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallInExpressionAST::GALGAS_functionCallInExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallInExpressionAST GALGAS_functionCallInExpressionAST::constructor_default (LOCATION_ARGS) {
  return GALGAS_functionCallInExpressionAST::constructor_new (GALGAS_lstring::constructor_default (HERE),
                                                              GALGAS_functionCallEffectiveParameterList::constructor_emptyList (HERE)
                                                              COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallInExpressionAST::GALGAS_functionCallInExpressionAST (const cPtr_functionCallInExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_functionCallInExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallInExpressionAST GALGAS_functionCallInExpressionAST::constructor_new (const GALGAS_lstring & inAttribute_mFunctionVarName,
                                                                                        const GALGAS_functionCallEffectiveParameterList & inAttribute_mParameterList
                                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_functionCallInExpressionAST result ;
  if (inAttribute_mFunctionVarName.isValid () && inAttribute_mParameterList.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_functionCallInExpressionAST (inAttribute_mFunctionVarName, inAttribute_mParameterList COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_functionCallInExpressionAST::reader_mFunctionVarName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_functionCallInExpressionAST * p = (const cPtr_functionCallInExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_functionCallInExpressionAST) ;
    result = p->mAttribute_mFunctionVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_functionCallInExpressionAST::reader_mFunctionVarName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mFunctionVarName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallEffectiveParameterList GALGAS_functionCallInExpressionAST::reader_mParameterList (UNUSED_LOCATION_ARGS) const {
  GALGAS_functionCallEffectiveParameterList result ;
  if (NULL != mObjectPtr) {
    const cPtr_functionCallInExpressionAST * p = (const cPtr_functionCallInExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_functionCallInExpressionAST) ;
    result = p->mAttribute_mParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallEffectiveParameterList cPtr_functionCallInExpressionAST::reader_mParameterList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mParameterList ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                Pointer class for @functionCallInExpressionAST class                                 *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_functionCallInExpressionAST::cPtr_functionCallInExpressionAST (const GALGAS_lstring & in_mFunctionVarName,
                                                                    const GALGAS_functionCallEffectiveParameterList & in_mParameterList
                                                                    COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mFunctionVarName (in_mFunctionVarName),
mAttribute_mParameterList (in_mParameterList) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_functionCallInExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_functionCallInExpressionAST ;
}

void cPtr_functionCallInExpressionAST::description (C_String & ioString,
                                                    const int32_t inIndentation) const {
  ioString << "[@functionCallInExpressionAST:" ;
  mAttribute_mFunctionVarName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mParameterList.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_functionCallInExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_functionCallInExpressionAST (mAttribute_mFunctionVarName, mAttribute_mParameterList COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          @functionCallInExpressionAST type                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_functionCallInExpressionAST ("functionCallInExpressionAST",
                                                    & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_functionCallInExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_functionCallInExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_functionCallInExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_functionCallInExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_functionCallInExpressionAST GALGAS_functionCallInExpressionAST::extractObject (const GALGAS_object & inObject,
                                                                                      C_Compiler * inCompiler
                                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_functionCallInExpressionAST result ;
  const GALGAS_functionCallInExpressionAST * p = (const GALGAS_functionCallInExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_functionCallInExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("functionCallInExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_infixOperatorExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_infixOperatorExpressionAST * p = (const cPtr_infixOperatorExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_infixOperatorExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mLeftExpression.objectCompare (p->mAttribute_mLeftExpression) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOperatorLocation.objectCompare (p->mAttribute_mOperatorLocation) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOp.objectCompare (p->mAttribute_mOp) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mRightExpression.objectCompare (p->mAttribute_mRightExpression) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_infixOperatorExpressionAST::objectCompare (const GALGAS_infixOperatorExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperatorExpressionAST::GALGAS_infixOperatorExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperatorExpressionAST::GALGAS_infixOperatorExpressionAST (const cPtr_infixOperatorExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_infixOperatorExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperatorExpressionAST GALGAS_infixOperatorExpressionAST::constructor_new (const GALGAS_expressionAST & inAttribute_mLeftExpression,
                                                                                      const GALGAS_location & inAttribute_mOperatorLocation,
                                                                                      const GALGAS_infixOperator & inAttribute_mOp,
                                                                                      const GALGAS_expressionAST & inAttribute_mRightExpression
                                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_infixOperatorExpressionAST result ;
  if (inAttribute_mLeftExpression.isValid () && inAttribute_mOperatorLocation.isValid () && inAttribute_mOp.isValid () && inAttribute_mRightExpression.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_infixOperatorExpressionAST (inAttribute_mLeftExpression, inAttribute_mOperatorLocation, inAttribute_mOp, inAttribute_mRightExpression COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_infixOperatorExpressionAST::reader_mLeftExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_infixOperatorExpressionAST * p = (const cPtr_infixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_infixOperatorExpressionAST) ;
    result = p->mAttribute_mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_infixOperatorExpressionAST::reader_mLeftExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLeftExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_infixOperatorExpressionAST::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_infixOperatorExpressionAST * p = (const cPtr_infixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_infixOperatorExpressionAST) ;
    result = p->mAttribute_mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_infixOperatorExpressionAST::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperatorLocation ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperator GALGAS_infixOperatorExpressionAST::reader_mOp (UNUSED_LOCATION_ARGS) const {
  GALGAS_infixOperator result ;
  if (NULL != mObjectPtr) {
    const cPtr_infixOperatorExpressionAST * p = (const cPtr_infixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_infixOperatorExpressionAST) ;
    result = p->mAttribute_mOp ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperator cPtr_infixOperatorExpressionAST::reader_mOp (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOp ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_infixOperatorExpressionAST::reader_mRightExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_infixOperatorExpressionAST * p = (const cPtr_infixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_infixOperatorExpressionAST) ;
    result = p->mAttribute_mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_infixOperatorExpressionAST::reader_mRightExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mRightExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                 Pointer class for @infixOperatorExpressionAST class                                 *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_infixOperatorExpressionAST::cPtr_infixOperatorExpressionAST (const GALGAS_expressionAST & in_mLeftExpression,
                                                                  const GALGAS_location & in_mOperatorLocation,
                                                                  const GALGAS_infixOperator & in_mOp,
                                                                  const GALGAS_expressionAST & in_mRightExpression
                                                                  COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mLeftExpression (in_mLeftExpression),
mAttribute_mOperatorLocation (in_mOperatorLocation),
mAttribute_mOp (in_mOp),
mAttribute_mRightExpression (in_mRightExpression) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_infixOperatorExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_infixOperatorExpressionAST ;
}

void cPtr_infixOperatorExpressionAST::description (C_String & ioString,
                                                   const int32_t inIndentation) const {
  ioString << "[@infixOperatorExpressionAST:" ;
  mAttribute_mLeftExpression.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOperatorLocation.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOp.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mRightExpression.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_infixOperatorExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_infixOperatorExpressionAST (mAttribute_mLeftExpression, mAttribute_mOperatorLocation, mAttribute_mOp, mAttribute_mRightExpression COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          @infixOperatorExpressionAST type                                           *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_infixOperatorExpressionAST ("infixOperatorExpressionAST",
                                                   & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_infixOperatorExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_infixOperatorExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_infixOperatorExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_infixOperatorExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_infixOperatorExpressionAST GALGAS_infixOperatorExpressionAST::extractObject (const GALGAS_object & inObject,
                                                                                    C_Compiler * inCompiler
                                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_infixOperatorExpressionAST result ;
  const GALGAS_infixOperatorExpressionAST * p = (const GALGAS_infixOperatorExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_infixOperatorExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("infixOperatorExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_literalIntegerInExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_literalIntegerInExpressionAST * p = (const cPtr_literalIntegerInExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_literalIntegerInExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mLiteralInteger.objectCompare (p->mAttribute_mLiteralInteger) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_literalIntegerInExpressionAST::objectCompare (const GALGAS_literalIntegerInExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalIntegerInExpressionAST::GALGAS_literalIntegerInExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalIntegerInExpressionAST GALGAS_literalIntegerInExpressionAST::constructor_default (LOCATION_ARGS) {
  return GALGAS_literalIntegerInExpressionAST::constructor_new (GALGAS_luint_36__34_::constructor_default (HERE)
                                                                COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalIntegerInExpressionAST::GALGAS_literalIntegerInExpressionAST (const cPtr_literalIntegerInExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_literalIntegerInExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalIntegerInExpressionAST GALGAS_literalIntegerInExpressionAST::constructor_new (const GALGAS_luint_36__34_ & inAttribute_mLiteralInteger
                                                                                            COMMA_LOCATION_ARGS) {
  GALGAS_literalIntegerInExpressionAST result ;
  if (inAttribute_mLiteralInteger.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_literalIntegerInExpressionAST (inAttribute_mLiteralInteger COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_luint_36__34_ GALGAS_literalIntegerInExpressionAST::reader_mLiteralInteger (UNUSED_LOCATION_ARGS) const {
  GALGAS_luint_36__34_ result ;
  if (NULL != mObjectPtr) {
    const cPtr_literalIntegerInExpressionAST * p = (const cPtr_literalIntegerInExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_literalIntegerInExpressionAST) ;
    result = p->mAttribute_mLiteralInteger ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_luint_36__34_ cPtr_literalIntegerInExpressionAST::reader_mLiteralInteger (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLiteralInteger ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                               Pointer class for @literalIntegerInExpressionAST class                                *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_literalIntegerInExpressionAST::cPtr_literalIntegerInExpressionAST (const GALGAS_luint_36__34_ & in_mLiteralInteger
                                                                        COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mLiteralInteger (in_mLiteralInteger) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_literalIntegerInExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalIntegerInExpressionAST ;
}

void cPtr_literalIntegerInExpressionAST::description (C_String & ioString,
                                                      const int32_t inIndentation) const {
  ioString << "[@literalIntegerInExpressionAST:" ;
  mAttribute_mLiteralInteger.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_literalIntegerInExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_literalIntegerInExpressionAST (mAttribute_mLiteralInteger COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                         @literalIntegerInExpressionAST type                                         *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_literalIntegerInExpressionAST ("literalIntegerInExpressionAST",
                                                      & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_literalIntegerInExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalIntegerInExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_literalIntegerInExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_literalIntegerInExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalIntegerInExpressionAST GALGAS_literalIntegerInExpressionAST::extractObject (const GALGAS_object & inObject,
                                                                                          C_Compiler * inCompiler
                                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_literalIntegerInExpressionAST result ;
  const GALGAS_literalIntegerInExpressionAST * p = (const GALGAS_literalIntegerInExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_literalIntegerInExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("literalIntegerInExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_literalStringInExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_literalStringInExpressionAST * p = (const cPtr_literalStringInExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_literalStringInExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mLiteralString.objectCompare (p->mAttribute_mLiteralString) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_literalStringInExpressionAST::objectCompare (const GALGAS_literalStringInExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringInExpressionAST::GALGAS_literalStringInExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringInExpressionAST GALGAS_literalStringInExpressionAST::constructor_default (LOCATION_ARGS) {
  return GALGAS_literalStringInExpressionAST::constructor_new (GALGAS_lstring::constructor_default (HERE)
                                                               COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringInExpressionAST::GALGAS_literalStringInExpressionAST (const cPtr_literalStringInExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_literalStringInExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringInExpressionAST GALGAS_literalStringInExpressionAST::constructor_new (const GALGAS_lstring & inAttribute_mLiteralString
                                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_literalStringInExpressionAST result ;
  if (inAttribute_mLiteralString.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_literalStringInExpressionAST (inAttribute_mLiteralString COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_literalStringInExpressionAST::reader_mLiteralString (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_literalStringInExpressionAST * p = (const cPtr_literalStringInExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_literalStringInExpressionAST) ;
    result = p->mAttribute_mLiteralString ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_literalStringInExpressionAST::reader_mLiteralString (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mLiteralString ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                Pointer class for @literalStringInExpressionAST class                                *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_literalStringInExpressionAST::cPtr_literalStringInExpressionAST (const GALGAS_lstring & in_mLiteralString
                                                                      COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mLiteralString (in_mLiteralString) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_literalStringInExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalStringInExpressionAST ;
}

void cPtr_literalStringInExpressionAST::description (C_String & ioString,
                                                     const int32_t inIndentation) const {
  ioString << "[@literalStringInExpressionAST:" ;
  mAttribute_mLiteralString.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_literalStringInExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_literalStringInExpressionAST (mAttribute_mLiteralString COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                         @literalStringInExpressionAST type                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_literalStringInExpressionAST ("literalStringInExpressionAST",
                                                     & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_literalStringInExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_literalStringInExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_literalStringInExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_literalStringInExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_literalStringInExpressionAST GALGAS_literalStringInExpressionAST::extractObject (const GALGAS_object & inObject,
                                                                                        C_Compiler * inCompiler
                                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_literalStringInExpressionAST result ;
  const GALGAS_literalStringInExpressionAST * p = (const GALGAS_literalStringInExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_literalStringInExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("literalStringInExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_prefixOperatorExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_prefixOperatorExpressionAST * p = (const cPtr_prefixOperatorExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_prefixOperatorExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mOperatorLocation.objectCompare (p->mAttribute_mOperatorLocation) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mOp.objectCompare (p->mAttribute_mOp) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mExpression.objectCompare (p->mAttribute_mExpression) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_prefixOperatorExpressionAST::objectCompare (const GALGAS_prefixOperatorExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionAST::GALGAS_prefixOperatorExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionAST::GALGAS_prefixOperatorExpressionAST (const cPtr_prefixOperatorExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_prefixOperatorExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionAST GALGAS_prefixOperatorExpressionAST::constructor_new (const GALGAS_location & inAttribute_mOperatorLocation,
                                                                                        const GALGAS_prefixOperator & inAttribute_mOp,
                                                                                        const GALGAS_expressionAST & inAttribute_mExpression
                                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_prefixOperatorExpressionAST result ;
  if (inAttribute_mOperatorLocation.isValid () && inAttribute_mOp.isValid () && inAttribute_mExpression.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_prefixOperatorExpressionAST (inAttribute_mOperatorLocation, inAttribute_mOp, inAttribute_mExpression COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_prefixOperatorExpressionAST::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionAST * p = (const cPtr_prefixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionAST) ;
    result = p->mAttribute_mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_prefixOperatorExpressionAST::reader_mOperatorLocation (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOperatorLocation ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperator GALGAS_prefixOperatorExpressionAST::reader_mOp (UNUSED_LOCATION_ARGS) const {
  GALGAS_prefixOperator result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionAST * p = (const cPtr_prefixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionAST) ;
    result = p->mAttribute_mOp ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperator cPtr_prefixOperatorExpressionAST::reader_mOp (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mOp ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_prefixOperatorExpressionAST::reader_mExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_prefixOperatorExpressionAST * p = (const cPtr_prefixOperatorExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_prefixOperatorExpressionAST) ;
    result = p->mAttribute_mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_prefixOperatorExpressionAST::reader_mExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                Pointer class for @prefixOperatorExpressionAST class                                 *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_prefixOperatorExpressionAST::cPtr_prefixOperatorExpressionAST (const GALGAS_location & in_mOperatorLocation,
                                                                    const GALGAS_prefixOperator & in_mOp,
                                                                    const GALGAS_expressionAST & in_mExpression
                                                                    COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mOperatorLocation (in_mOperatorLocation),
mAttribute_mOp (in_mOp),
mAttribute_mExpression (in_mExpression) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_prefixOperatorExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_prefixOperatorExpressionAST ;
}

void cPtr_prefixOperatorExpressionAST::description (C_String & ioString,
                                                    const int32_t inIndentation) const {
  ioString << "[@prefixOperatorExpressionAST:" ;
  mAttribute_mOperatorLocation.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mOp.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mExpression.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_prefixOperatorExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_prefixOperatorExpressionAST (mAttribute_mOperatorLocation, mAttribute_mOp, mAttribute_mExpression COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                          @prefixOperatorExpressionAST type                                          *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_prefixOperatorExpressionAST ("prefixOperatorExpressionAST",
                                                    & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_prefixOperatorExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_prefixOperatorExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_prefixOperatorExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_prefixOperatorExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_prefixOperatorExpressionAST GALGAS_prefixOperatorExpressionAST::extractObject (const GALGAS_object & inObject,
                                                                                      C_Compiler * inCompiler
                                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_prefixOperatorExpressionAST result ;
  const GALGAS_prefixOperatorExpressionAST * p = (const GALGAS_prefixOperatorExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_prefixOperatorExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("prefixOperatorExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_varInExpressionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_varInExpressionAST * p = (const cPtr_varInExpressionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_varInExpressionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mSourceVarName.objectCompare (p->mAttribute_mSourceVarName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_varInExpressionAST::objectCompare (const GALGAS_varInExpressionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varInExpressionAST::GALGAS_varInExpressionAST (void) :
GALGAS_expressionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varInExpressionAST GALGAS_varInExpressionAST::constructor_default (LOCATION_ARGS) {
  return GALGAS_varInExpressionAST::constructor_new (GALGAS_lstring::constructor_default (HERE)
                                                     COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varInExpressionAST::GALGAS_varInExpressionAST (const cPtr_varInExpressionAST * inSourcePtr) :
GALGAS_expressionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_varInExpressionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varInExpressionAST GALGAS_varInExpressionAST::constructor_new (const GALGAS_lstring & inAttribute_mSourceVarName
                                                                      COMMA_LOCATION_ARGS) {
  GALGAS_varInExpressionAST result ;
  if (inAttribute_mSourceVarName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_varInExpressionAST (inAttribute_mSourceVarName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_varInExpressionAST::reader_mSourceVarName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_varInExpressionAST * p = (const cPtr_varInExpressionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_varInExpressionAST) ;
    result = p->mAttribute_mSourceVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_varInExpressionAST::reader_mSourceVarName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceVarName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                     Pointer class for @varInExpressionAST class                                     *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_varInExpressionAST::cPtr_varInExpressionAST (const GALGAS_lstring & in_mSourceVarName
                                                  COMMA_LOCATION_ARGS) :
cPtr_expressionAST (THERE),
mAttribute_mSourceVarName (in_mSourceVarName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_varInExpressionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_varInExpressionAST ;
}

void cPtr_varInExpressionAST::description (C_String & ioString,
                                           const int32_t inIndentation) const {
  ioString << "[@varInExpressionAST:" ;
  mAttribute_mSourceVarName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_varInExpressionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_varInExpressionAST (mAttribute_mSourceVarName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                              @varInExpressionAST type                                               *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_varInExpressionAST ("varInExpressionAST",
                                           & kTypeDescriptor_GALGAS_expressionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_varInExpressionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_varInExpressionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_varInExpressionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_varInExpressionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_varInExpressionAST GALGAS_varInExpressionAST::extractObject (const GALGAS_object & inObject,
                                                                    C_Compiler * inCompiler
                                                                    COMMA_LOCATION_ARGS) {
  GALGAS_varInExpressionAST result ;
  const GALGAS_varInExpressionAST * p = (const GALGAS_varInExpressionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_varInExpressionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("varInExpressionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*



typeComparisonResult GALGAS_instructionAST::objectCompare (const GALGAS_instructionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionAST::GALGAS_instructionAST (void) :
AC_GALGAS_class () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionAST::GALGAS_instructionAST (const cPtr_instructionAST * inSourcePtr) :
AC_GALGAS_class (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_instructionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                       Pointer class for @instructionAST class                                       *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_instructionAST::cPtr_instructionAST (LOCATION_ARGS) :
acPtr_class (THERE) {
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                                @instructionAST type                                                 *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_instructionAST ("instructionAST",
                                       NULL) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_instructionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_instructionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_instructionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_instructionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionAST GALGAS_instructionAST::extractObject (const GALGAS_object & inObject,
                                                            C_Compiler * inCompiler
                                                            COMMA_LOCATION_ARGS) {
  GALGAS_instructionAST result ;
  const GALGAS_instructionAST * p = (const GALGAS_instructionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_instructionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("instructionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_assignmentInstructionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_assignmentInstructionAST * p = (const cPtr_assignmentInstructionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_assignmentInstructionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTargetVarName.objectCompare (p->mAttribute_mTargetVarName) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mSourceExpression.objectCompare (p->mAttribute_mSourceExpression) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_assignmentInstructionAST::objectCompare (const GALGAS_assignmentInstructionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionAST::GALGAS_assignmentInstructionAST (void) :
GALGAS_instructionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionAST::GALGAS_assignmentInstructionAST (const cPtr_assignmentInstructionAST * inSourcePtr) :
GALGAS_instructionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_assignmentInstructionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionAST GALGAS_assignmentInstructionAST::constructor_new (const GALGAS_lstring & inAttribute_mTargetVarName,
                                                                                  const GALGAS_expressionAST & inAttribute_mSourceExpression
                                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_assignmentInstructionAST result ;
  if (inAttribute_mTargetVarName.isValid () && inAttribute_mSourceExpression.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_assignmentInstructionAST (inAttribute_mTargetVarName, inAttribute_mSourceExpression COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_assignmentInstructionAST::reader_mTargetVarName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_assignmentInstructionAST * p = (const cPtr_assignmentInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_assignmentInstructionAST) ;
    result = p->mAttribute_mTargetVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_assignmentInstructionAST::reader_mTargetVarName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTargetVarName ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_assignmentInstructionAST::reader_mSourceExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_assignmentInstructionAST * p = (const cPtr_assignmentInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_assignmentInstructionAST) ;
    result = p->mAttribute_mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_assignmentInstructionAST::reader_mSourceExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mSourceExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                  Pointer class for @assignmentInstructionAST class                                  *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_assignmentInstructionAST::cPtr_assignmentInstructionAST (const GALGAS_lstring & in_mTargetVarName,
                                                              const GALGAS_expressionAST & in_mSourceExpression
                                                              COMMA_LOCATION_ARGS) :
cPtr_instructionAST (THERE),
mAttribute_mTargetVarName (in_mTargetVarName),
mAttribute_mSourceExpression (in_mSourceExpression) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_assignmentInstructionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_assignmentInstructionAST ;
}

void cPtr_assignmentInstructionAST::description (C_String & ioString,
                                                 const int32_t inIndentation) const {
  ioString << "[@assignmentInstructionAST:" ;
  mAttribute_mTargetVarName.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mSourceExpression.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_assignmentInstructionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_assignmentInstructionAST (mAttribute_mTargetVarName, mAttribute_mSourceExpression COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                           @assignmentInstructionAST type                                            *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_assignmentInstructionAST ("assignmentInstructionAST",
                                                 & kTypeDescriptor_GALGAS_instructionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_assignmentInstructionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_assignmentInstructionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_assignmentInstructionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_assignmentInstructionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_assignmentInstructionAST GALGAS_assignmentInstructionAST::extractObject (const GALGAS_object & inObject,
                                                                                C_Compiler * inCompiler
                                                                                COMMA_LOCATION_ARGS) {
  GALGAS_assignmentInstructionAST result ;
  const GALGAS_assignmentInstructionAST * p = (const GALGAS_assignmentInstructionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_assignmentInstructionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("assignmentInstructionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_foreverInstructionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_foreverInstructionAST * p = (const cPtr_foreverInstructionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_foreverInstructionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mWhileInstructionList.objectCompare (p->mAttribute_mWhileInstructionList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mEndOf_5F_while_5F_instruction.objectCompare (p->mAttribute_mEndOf_5F_while_5F_instruction) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_foreverInstructionAST::objectCompare (const GALGAS_foreverInstructionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionAST::GALGAS_foreverInstructionAST (void) :
GALGAS_instructionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionAST GALGAS_foreverInstructionAST::constructor_default (LOCATION_ARGS) {
  return GALGAS_foreverInstructionAST::constructor_new (GALGAS_instructionListAST::constructor_emptyList (HERE),
                                                        GALGAS_location::constructor_nowhere (HERE)
                                                        COMMA_THERE) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionAST::GALGAS_foreverInstructionAST (const cPtr_foreverInstructionAST * inSourcePtr) :
GALGAS_instructionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_foreverInstructionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionAST GALGAS_foreverInstructionAST::constructor_new (const GALGAS_instructionListAST & inAttribute_mWhileInstructionList,
                                                                            const GALGAS_location & inAttribute_mEndOf_5F_while_5F_instruction
                                                                            COMMA_LOCATION_ARGS) {
  GALGAS_foreverInstructionAST result ;
  if (inAttribute_mWhileInstructionList.isValid () && inAttribute_mEndOf_5F_while_5F_instruction.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_foreverInstructionAST (inAttribute_mWhileInstructionList, inAttribute_mEndOf_5F_while_5F_instruction COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListAST GALGAS_foreverInstructionAST::reader_mWhileInstructionList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_foreverInstructionAST * p = (const cPtr_foreverInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_foreverInstructionAST) ;
    result = p->mAttribute_mWhileInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListAST cPtr_foreverInstructionAST::reader_mWhileInstructionList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mWhileInstructionList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_foreverInstructionAST::reader_mEndOf_5F_while_5F_instruction (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_foreverInstructionAST * p = (const cPtr_foreverInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_foreverInstructionAST) ;
    result = p->mAttribute_mEndOf_5F_while_5F_instruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_foreverInstructionAST::reader_mEndOf_5F_while_5F_instruction (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mEndOf_5F_while_5F_instruction ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                   Pointer class for @foreverInstructionAST class                                    *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_foreverInstructionAST::cPtr_foreverInstructionAST (const GALGAS_instructionListAST & in_mWhileInstructionList,
                                                        const GALGAS_location & in_mEndOf_5F_while_5F_instruction
                                                        COMMA_LOCATION_ARGS) :
cPtr_instructionAST (THERE),
mAttribute_mWhileInstructionList (in_mWhileInstructionList),
mAttribute_mEndOf_5F_while_5F_instruction (in_mEndOf_5F_while_5F_instruction) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_foreverInstructionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_foreverInstructionAST ;
}

void cPtr_foreverInstructionAST::description (C_String & ioString,
                                              const int32_t inIndentation) const {
  ioString << "[@foreverInstructionAST:" ;
  mAttribute_mWhileInstructionList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mEndOf_5F_while_5F_instruction.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_foreverInstructionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_foreverInstructionAST (mAttribute_mWhileInstructionList, mAttribute_mEndOf_5F_while_5F_instruction COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             @foreverInstructionAST type                                             *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_foreverInstructionAST ("foreverInstructionAST",
                                              & kTypeDescriptor_GALGAS_instructionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_foreverInstructionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_foreverInstructionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_foreverInstructionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_foreverInstructionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_foreverInstructionAST GALGAS_foreverInstructionAST::extractObject (const GALGAS_object & inObject,
                                                                          C_Compiler * inCompiler
                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_foreverInstructionAST result ;
  const GALGAS_foreverInstructionAST * p = (const GALGAS_foreverInstructionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_foreverInstructionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("foreverInstructionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_ifInstructionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_ifInstructionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mTestExpression.objectCompare (p->mAttribute_mTestExpression) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mTestExpressionEndLocation.objectCompare (p->mAttribute_mTestExpressionEndLocation) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mThenInstructionList.objectCompare (p->mAttribute_mThenInstructionList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mEndOfThenInstructionList.objectCompare (p->mAttribute_mEndOfThenInstructionList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mElseInstructionList.objectCompare (p->mAttribute_mElseInstructionList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mEndOfElseInstructionList.objectCompare (p->mAttribute_mEndOfElseInstructionList) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mEndOf_5F_if_5F_instruction.objectCompare (p->mAttribute_mEndOf_5F_if_5F_instruction) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_ifInstructionAST::objectCompare (const GALGAS_ifInstructionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionAST::GALGAS_ifInstructionAST (void) :
GALGAS_instructionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionAST::GALGAS_ifInstructionAST (const cPtr_ifInstructionAST * inSourcePtr) :
GALGAS_instructionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_ifInstructionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionAST GALGAS_ifInstructionAST::constructor_new (const GALGAS_expressionAST & inAttribute_mTestExpression,
                                                                  const GALGAS_location & inAttribute_mTestExpressionEndLocation,
                                                                  const GALGAS_instructionListAST & inAttribute_mThenInstructionList,
                                                                  const GALGAS_location & inAttribute_mEndOfThenInstructionList,
                                                                  const GALGAS_instructionListAST & inAttribute_mElseInstructionList,
                                                                  const GALGAS_location & inAttribute_mEndOfElseInstructionList,
                                                                  const GALGAS_location & inAttribute_mEndOf_5F_if_5F_instruction
                                                                  COMMA_LOCATION_ARGS) {
  GALGAS_ifInstructionAST result ;
  if (inAttribute_mTestExpression.isValid () && inAttribute_mTestExpressionEndLocation.isValid () && inAttribute_mThenInstructionList.isValid () && inAttribute_mEndOfThenInstructionList.isValid () && inAttribute_mElseInstructionList.isValid () && inAttribute_mEndOfElseInstructionList.isValid () && inAttribute_mEndOf_5F_if_5F_instruction.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_ifInstructionAST (inAttribute_mTestExpression, inAttribute_mTestExpressionEndLocation, inAttribute_mThenInstructionList, inAttribute_mEndOfThenInstructionList, inAttribute_mElseInstructionList, inAttribute_mEndOfElseInstructionList, inAttribute_mEndOf_5F_if_5F_instruction COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST GALGAS_ifInstructionAST::reader_mTestExpression (UNUSED_LOCATION_ARGS) const {
  GALGAS_expressionAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mTestExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_expressionAST cPtr_ifInstructionAST::reader_mTestExpression (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTestExpression ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_ifInstructionAST::reader_mTestExpressionEndLocation (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mTestExpressionEndLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_ifInstructionAST::reader_mTestExpressionEndLocation (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mTestExpressionEndLocation ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListAST GALGAS_ifInstructionAST::reader_mThenInstructionList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mThenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListAST cPtr_ifInstructionAST::reader_mThenInstructionList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mThenInstructionList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_ifInstructionAST::reader_mEndOfThenInstructionList (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mEndOfThenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_ifInstructionAST::reader_mEndOfThenInstructionList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mEndOfThenInstructionList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListAST GALGAS_ifInstructionAST::reader_mElseInstructionList (UNUSED_LOCATION_ARGS) const {
  GALGAS_instructionListAST result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_instructionListAST cPtr_ifInstructionAST::reader_mElseInstructionList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mElseInstructionList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_ifInstructionAST::reader_mEndOfElseInstructionList (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mEndOfElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_ifInstructionAST::reader_mEndOfElseInstructionList (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mEndOfElseInstructionList ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location GALGAS_ifInstructionAST::reader_mEndOf_5F_if_5F_instruction (UNUSED_LOCATION_ARGS) const {
  GALGAS_location result ;
  if (NULL != mObjectPtr) {
    const cPtr_ifInstructionAST * p = (const cPtr_ifInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_ifInstructionAST) ;
    result = p->mAttribute_mEndOf_5F_if_5F_instruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_location cPtr_ifInstructionAST::reader_mEndOf_5F_if_5F_instruction (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mEndOf_5F_if_5F_instruction ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                      Pointer class for @ifInstructionAST class                                      *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_ifInstructionAST::cPtr_ifInstructionAST (const GALGAS_expressionAST & in_mTestExpression,
                                              const GALGAS_location & in_mTestExpressionEndLocation,
                                              const GALGAS_instructionListAST & in_mThenInstructionList,
                                              const GALGAS_location & in_mEndOfThenInstructionList,
                                              const GALGAS_instructionListAST & in_mElseInstructionList,
                                              const GALGAS_location & in_mEndOfElseInstructionList,
                                              const GALGAS_location & in_mEndOf_5F_if_5F_instruction
                                              COMMA_LOCATION_ARGS) :
cPtr_instructionAST (THERE),
mAttribute_mTestExpression (in_mTestExpression),
mAttribute_mTestExpressionEndLocation (in_mTestExpressionEndLocation),
mAttribute_mThenInstructionList (in_mThenInstructionList),
mAttribute_mEndOfThenInstructionList (in_mEndOfThenInstructionList),
mAttribute_mElseInstructionList (in_mElseInstructionList),
mAttribute_mEndOfElseInstructionList (in_mEndOfElseInstructionList),
mAttribute_mEndOf_5F_if_5F_instruction (in_mEndOf_5F_if_5F_instruction) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_ifInstructionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_ifInstructionAST ;
}

void cPtr_ifInstructionAST::description (C_String & ioString,
                                         const int32_t inIndentation) const {
  ioString << "[@ifInstructionAST:" ;
  mAttribute_mTestExpression.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mTestExpressionEndLocation.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mThenInstructionList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mEndOfThenInstructionList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mElseInstructionList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mEndOfElseInstructionList.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mEndOf_5F_if_5F_instruction.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_ifInstructionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_ifInstructionAST (mAttribute_mTestExpression, mAttribute_mTestExpressionEndLocation, mAttribute_mThenInstructionList, mAttribute_mEndOfThenInstructionList, mAttribute_mElseInstructionList, mAttribute_mEndOfElseInstructionList, mAttribute_mEndOf_5F_if_5F_instruction COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                               @ifInstructionAST type                                                *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_ifInstructionAST ("ifInstructionAST",
                                         & kTypeDescriptor_GALGAS_instructionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_ifInstructionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_ifInstructionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_ifInstructionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_ifInstructionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_ifInstructionAST GALGAS_ifInstructionAST::extractObject (const GALGAS_object & inObject,
                                                                C_Compiler * inCompiler
                                                                COMMA_LOCATION_ARGS) {
  GALGAS_ifInstructionAST result ;
  const GALGAS_ifInstructionAST * p = (const GALGAS_ifInstructionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_ifInstructionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("ifInstructionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*
//   Object comparison                                                                                                 *
//---------------------------------------------------------------------------------------------------------------------*

typeComparisonResult cPtr_incDecInstructionAST::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_incDecInstructionAST * p = (const cPtr_incDecInstructionAST *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_incDecInstructionAST) ;
  if (kOperandEqual == result) {
    result = mAttribute_mKind.objectCompare (p->mAttribute_mKind) ;
  }
  if (kOperandEqual == result) {
    result = mAttribute_mVarName.objectCompare (p->mAttribute_mVarName) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*


typeComparisonResult GALGAS_incDecInstructionAST::objectCompare (const GALGAS_incDecInstructionAST & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const int32_t mySlot = mObjectPtr->classDescriptor ()->mSlotID ;
    const int32_t operandSlot = inOperand.mObjectPtr->classDescriptor ()->mSlotID ;
    if (mySlot < operandSlot) {
      result = kFirstOperandLowerThanSecond ;
    }else if (mySlot > operandSlot) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = mObjectPtr->dynamicObjectCompare (inOperand.mObjectPtr) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionAST::GALGAS_incDecInstructionAST (void) :
GALGAS_instructionAST () {
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionAST::GALGAS_incDecInstructionAST (const cPtr_incDecInstructionAST * inSourcePtr) :
GALGAS_instructionAST (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_incDecInstructionAST) ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionAST GALGAS_incDecInstructionAST::constructor_new (const GALGAS_incDecKind & inAttribute_mKind,
                                                                          const GALGAS_lstring & inAttribute_mVarName
                                                                          COMMA_LOCATION_ARGS) {
  GALGAS_incDecInstructionAST result ;
  if (inAttribute_mKind.isValid () && inAttribute_mVarName.isValid ()) {
    macroMyNew (result.mObjectPtr, cPtr_incDecInstructionAST (inAttribute_mKind, inAttribute_mVarName COMMA_THERE)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecKind GALGAS_incDecInstructionAST::reader_mKind (UNUSED_LOCATION_ARGS) const {
  GALGAS_incDecKind result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionAST * p = (const cPtr_incDecInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionAST) ;
    result = p->mAttribute_mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecKind cPtr_incDecInstructionAST::reader_mKind (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mKind ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring GALGAS_incDecInstructionAST::reader_mVarName (UNUSED_LOCATION_ARGS) const {
  GALGAS_lstring result ;
  if (NULL != mObjectPtr) {
    const cPtr_incDecInstructionAST * p = (const cPtr_incDecInstructionAST *) mObjectPtr ;
    macroValidSharedObject (p, cPtr_incDecInstructionAST) ;
    result = p->mAttribute_mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_lstring cPtr_incDecInstructionAST::reader_mVarName (UNUSED_LOCATION_ARGS) const {
  return mAttribute_mVarName ;
}

//---------------------------------------------------------------------------------------------------------------------*
//                                    Pointer class for @incDecInstructionAST class                                    *
//---------------------------------------------------------------------------------------------------------------------*

cPtr_incDecInstructionAST::cPtr_incDecInstructionAST (const GALGAS_incDecKind & in_mKind,
                                                      const GALGAS_lstring & in_mVarName
                                                      COMMA_LOCATION_ARGS) :
cPtr_instructionAST (THERE),
mAttribute_mKind (in_mKind),
mAttribute_mVarName (in_mVarName) {
}

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * cPtr_incDecInstructionAST::classDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_incDecInstructionAST ;
}

void cPtr_incDecInstructionAST::description (C_String & ioString,
                                             const int32_t inIndentation) const {
  ioString << "[@incDecInstructionAST:" ;
  mAttribute_mKind.description (ioString, inIndentation+1) ;
  ioString << ", " ;
  mAttribute_mVarName.description (ioString, inIndentation+1) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------------------------------------------------*

acPtr_class * cPtr_incDecInstructionAST::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = NULL ;
  macroMyNew (ptr, cPtr_incDecInstructionAST (mAttribute_mKind, mAttribute_mVarName COMMA_THERE)) ;
  return ptr ;
}


//---------------------------------------------------------------------------------------------------------------------*
//                                                                                                                     *
//                                             @incDecInstructionAST type                                              *
//                                                                                                                     *
//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_incDecInstructionAST ("incDecInstructionAST",
                                             & kTypeDescriptor_GALGAS_instructionAST) ;

//---------------------------------------------------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_incDecInstructionAST::staticTypeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_incDecInstructionAST ;
}

//---------------------------------------------------------------------------------------------------------------------*

AC_GALGAS_root * GALGAS_incDecInstructionAST::clonedObject (void) const {
  AC_GALGAS_root * result = NULL ;
  if (isValid ()) {
    macroMyNew (result, GALGAS_incDecInstructionAST (*this)) ;
  }
  return result ;
}

//---------------------------------------------------------------------------------------------------------------------*

GALGAS_incDecInstructionAST GALGAS_incDecInstructionAST::extractObject (const GALGAS_object & inObject,
                                                                        C_Compiler * inCompiler
                                                                        COMMA_LOCATION_ARGS) {
  GALGAS_incDecInstructionAST result ;
  const GALGAS_incDecInstructionAST * p = (const GALGAS_incDecInstructionAST *) inObject.embeddedObject () ;
  if (NULL != p) {
    if (NULL != dynamic_cast <const GALGAS_incDecInstructionAST *> (p)) {
      result = *p ;
    }else{
      inCompiler->castError ("incDecInstructionAST", p->dynamicTypeDescriptor () COMMA_THERE) ;
    }  
  }
  return result ;
}

