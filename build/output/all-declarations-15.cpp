#include "galgas2/C_Compiler.h"
#include "galgas2/C_galgas_io.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "utilities/C_PrologueEpilogue.h"

//----------------------------------------------------------------------------------------------------------------------

#include "all-declarations-15.h"

//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@shortCircuitAndOperationIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_shortCircuitAndOperationIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                                      GALGAS_uint & ioArgument_ioMaxBranchOfOnInstructions,
                                                                      C_Compiler * inCompiler
                                                                      COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_shortCircuitAndOperationIR temp_0 = this ;
  extensionMethod_enterAccessibleEntities (temp_0.readProperty_mLeftInstructionList (), ioArgument_ioInvokedRoutineSet, ioArgument_ioMaxBranchOfOnInstructions, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 38)) ;
  const GALGAS_shortCircuitAndOperationIR temp_1 = this ;
  extensionMethod_enterAccessibleEntities (temp_1.readProperty_mRightInstructionList (), ioArgument_ioInvokedRoutineSet, ioArgument_ioMaxBranchOfOnInstructions, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 39)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@shortCircuitAndOperationIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_shortCircuitAndOperationIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                  const GALGAS_generationContext constinArgument_inGenerationContext,
                                                                  GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                                  C_Compiler * inCompiler
                                                                  COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_shortCircuitAndOperationIR temp_0 = this ;
  GALGAS_string var_startLabel_1857 = GALGAS_string ("and.").add_operation (temp_0.readProperty_mLocation ().getter_locationIndex (inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 49)).getter_string (SOURCE_FILE ("intermediate-short-circuit-and.galgas", 49)), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 49)).add_operation (GALGAS_string (".start"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 49)) ;
  const GALGAS_shortCircuitAndOperationIR temp_1 = this ;
  GALGAS_string var_trueLabel_1927 = GALGAS_string ("and.").add_operation (temp_1.readProperty_mLocation ().getter_locationIndex (inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 50)).getter_string (SOURCE_FILE ("intermediate-short-circuit-and.galgas", 50)), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 50)).add_operation (GALGAS_string (".true"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 50)) ;
  const GALGAS_shortCircuitAndOperationIR temp_2 = this ;
  GALGAS_string var_falseLabel_1997 = GALGAS_string ("and.").add_operation (temp_2.readProperty_mLocation ().getter_locationIndex (inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 51)).getter_string (SOURCE_FILE ("intermediate-short-circuit-and.galgas", 51)), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 51)).add_operation (GALGAS_string (".false"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 51)) ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br label %").add_operation (var_startLabel_1857, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 52)).add_operation (GALGAS_string ("\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 52)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 52)) ;
  ioArgument_ioLLVMcode.plusAssign_operation(var_startLabel_1857.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 53)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 53)) ;
  const GALGAS_shortCircuitAndOperationIR temp_3 = this ;
  extensionMethod_instructionListLLVMCode (temp_3.readProperty_mLeftInstructionList (), ioArgument_ioLLVMcode, constinArgument_inGenerationContext, ioArgument_ioGenerationAdds, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 54)) ;
  const GALGAS_shortCircuitAndOperationIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br i1 ").add_operation (temp_4.readProperty_mLeftOperandLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)).add_operation (var_trueLabel_1927, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)).add_operation (var_falseLabel_1997, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)).add_operation (GALGAS_string ("\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 55)) ;
  ioArgument_ioLLVMcode.plusAssign_operation(var_trueLabel_1927.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 56)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 56)) ;
  const GALGAS_shortCircuitAndOperationIR temp_5 = this ;
  extensionMethod_instructionListLLVMCode (temp_5.readProperty_mRightInstructionList (), ioArgument_ioLLVMcode, constinArgument_inGenerationContext, ioArgument_ioGenerationAdds, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 57)) ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br label %").add_operation (var_falseLabel_1997, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 58)).add_operation (GALGAS_string ("\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 58)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 58)) ;
  ioArgument_ioLLVMcode.plusAssign_operation(var_falseLabel_1997.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 59)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 59)) ;
  const GALGAS_shortCircuitAndOperationIR temp_6 = this ;
  const GALGAS_shortCircuitAndOperationIR temp_7 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (extensionGetter_llvmName (temp_6.readProperty_mTargetOperand (), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 60)), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 60)).add_operation (GALGAS_string (" = phi i1 ["), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 60)).add_operation (temp_7.readProperty_mRightOperandLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 61)).add_operation (GALGAS_string (", %"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 61)).add_operation (var_trueLabel_1927, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 61)).add_operation (GALGAS_string ("], [false, %"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 61)).add_operation (var_startLabel_1857, inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 61)).add_operation (GALGAS_string ("]\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 61)), inCompiler  COMMA_SOURCE_FILE ("intermediate-short-circuit-and.galgas", 60)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@loadFromReferenceIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_loadFromReferenceIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                           const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                           GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                           C_Compiler * inCompiler
                                                           COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_loadFromReferenceIR temp_0 = this ;
  GALGAS_string var_llvmType_741 = extensionGetter_llvmTypeName (temp_0.readProperty_mTargetValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 23)) ;
  const GALGAS_loadFromReferenceIR temp_1 = this ;
  const GALGAS_loadFromReferenceIR temp_2 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (extensionGetter_llvmName (temp_1.readProperty_mTargetValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (GALGAS_string (" = load "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (var_llvmType_741, inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (var_llvmType_741, inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (temp_2.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)), inCompiler  COMMA_SOURCE_FILE ("intermediate-load-from-reference.galgas", 24)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@storeToUniversalReferenceIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_storeToUniversalReferenceIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                                       GALGAS_uint & /* ioArgument_ioMaxBranchOfOnInstructions */,
                                                                       C_Compiler * inCompiler
                                                                       COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_storeToUniversalReferenceIR temp_0 = this ;
  switch (temp_0.readProperty_mSourceValue ().enumValue ()) {
  case GALGAS_objectIR::kNotBuilt:
    break ;
  case GALGAS_objectIR::kEnum_void:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_null:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_reference:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmNamedValue:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_literalInteger:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmStructureValue:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayRepeatedDynamicValue:
    {
      const cEnumAssociatedValues_objectIR_llvmArrayRepeatedDynamicValue * extractPtr_1322 = (const cEnumAssociatedValues_objectIR_llvmArrayRepeatedDynamicValue *) (temp_0.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_objectIR extractedValue_1180_value = extractPtr_1322->mAssociatedValue2 ;
      GALGAS_string var_llvmAssignRoutineName_1213 = function_assignmentOperatorFuncName (extensionGetter_type (extractedValue_1180_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 34)), extensionGetter_type (extractedValue_1180_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 34)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 34)) ;
      ioArgument_ioInvokedRoutineSet.addAssign_operation (var_llvmAssignRoutineName_1213  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 35)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayRepeatedStaticValue:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayStaticValues:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayDynamicValues:
    {
      const cEnumAssociatedValues_objectIR_llvmArrayDynamicValues * extractPtr_1692 = (const cEnumAssociatedValues_objectIR_llvmArrayDynamicValues *) (temp_0.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_operandIRList extractedValue_1458_operands = extractPtr_1692->mAssociatedValue1 ;
      cEnumerator_operandIRList enumerator_1476 (extractedValue_1458_operands, kENUMERATION_UP) ;
      while (enumerator_1476.hasCurrentObject ()) {
        enumGalgasBool test_1 = kBoolTrue ;
        if (kBoolTrue == test_1) {
          test_1 = extensionGetter_isStatic (enumerator_1476.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 40)).operator_not (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 40)).boolEnum () ;
          if (kBoolTrue == test_1) {
            GALGAS_string var_llvmAssignRoutineName_1561 = function_assignmentOperatorFuncName (extensionGetter_type (enumerator_1476.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 41)), extensionGetter_type (enumerator_1476.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 41)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 41)) ;
            ioArgument_ioInvokedRoutineSet.addAssign_operation (var_llvmAssignRoutineName_1561  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 42)) ;
          }
        }
        enumerator_1476.gotoNextObject () ;
      }
    }
    break ;
  case GALGAS_objectIR::kEnum_literalString:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_zero:
    {
    }
    break ;
  }
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@storeToUniversalReferenceIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_storeToUniversalReferenceIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                   const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                   GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                                   C_Compiler * inCompiler
                                                                   COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_storeToUniversalReferenceIR temp_0 = this ;
  GALGAS_string var_llvmType_2066 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) temp_0.readProperty_mTargetVarType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 57)) ;
  const GALGAS_storeToUniversalReferenceIR temp_1 = this ;
  switch (temp_1.readProperty_mSourceValue ().enumValue ()) {
  case GALGAS_objectIR::kNotBuilt:
    break ;
  case GALGAS_objectIR::kEnum_void:
    {
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("<< ERROR @storeToUniversalReferenceIR llvmInstructionCode void >>\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 60)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_null:
    {
      const GALGAS_storeToUniversalReferenceIR temp_2 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)).add_operation (GALGAS_string (" null, "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)).add_operation (temp_2.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 62)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_reference:
    {
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("<< ERROR @storeToUniversalReferenceIR llvmInstructionCode reference >>\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 64)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmNamedValue:
    {
      const cEnumAssociatedValues_objectIR_llvmNamedValue * extractPtr_2633 = (const cEnumAssociatedValues_objectIR_llvmNamedValue *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_string extractedValue_2514_llvmName = extractPtr_2633->mAssociatedValue1 ;
      const GALGAS_storeToUniversalReferenceIR temp_3 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (extractedValue_2514_llvmName, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (temp_3.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 66)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_literalInteger:
    {
      const cEnumAssociatedValues_objectIR_literalInteger * extractPtr_2789 = (const cEnumAssociatedValues_objectIR_literalInteger *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_bigint extractedValue_2673_value = extractPtr_2789->mAssociatedValue1 ;
      const GALGAS_storeToUniversalReferenceIR temp_4 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (extractedValue_2673_value.getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (temp_4.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 68)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmStructureValue:
    {
      const cEnumAssociatedValues_objectIR_llvmStructureValue * extractPtr_3337 = (const cEnumAssociatedValues_objectIR_llvmStructureValue *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_sortedOperandIRList extractedValue_2848_operands = extractPtr_3337->mAssociatedValue1 ;
      cEnumerator_sortedOperandIRList enumerator_2872 (extractedValue_2848_operands, kENUMERATION_UP) ;
      while (enumerator_2872.hasCurrentObject ()) {
        GALGAS_string var_tempVar_2906 = GALGAS_string ("%temp.addr.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 71)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 71)) ;
        ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 72)) ;
        const GALGAS_storeToUniversalReferenceIR temp_5 = this ;
        ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_tempVar_2906, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 73)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 73)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 73)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 73)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 73)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 74)).add_operation (temp_5.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 74)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 74)).add_operation (enumerator_2872.current_mIndex (HERE).getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 74)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 74)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 74)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 73)) ;
        GALGAS_string var_valueType_3194 = extensionGetter_llvmTypeName (enumerator_2872.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 75)) ;
        ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_valueType_3194, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (extensionGetter_llvmName (enumerator_2872.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (var_valueType_3194, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (var_tempVar_2906, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 76)) ;
        enumerator_2872.gotoNextObject () ;
      }
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayRepeatedDynamicValue:
    {
      const cEnumAssociatedValues_objectIR_llvmArrayRepeatedDynamicValue * extractPtr_5108 = (const cEnumAssociatedValues_objectIR_llvmArrayRepeatedDynamicValue *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_omnibusType extractedValue_3380_type = extractPtr_5108->mAssociatedValue0 ;
      const GALGAS_uint extractedValue_3385_size = extractPtr_5108->mAssociatedValue1 ;
      const GALGAS_objectIR extractedValue_3391_value = extractPtr_5108->mAssociatedValue2 ;
      GALGAS_string var_indexVarName_3415 = GALGAS_string ("%index.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 79)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 79)) ;
      GALGAS_string var_nextIndexVarName_3484 = GALGAS_string ("%index.next.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 80)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 80)) ;
      GALGAS_string var_ptrVarName_3552 = GALGAS_string ("%element.ptr.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 81)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 81)) ;
      GALGAS_string var_loopTestName_3623 = GALGAS_string ("%continue.loop.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 82)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 82)) ;
      GALGAS_string var_startLabel_3694 = GALGAS_string ("assign.start.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 83)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 83)) ;
      GALGAS_string var_loopLabel_3762 = GALGAS_string ("assign.loop.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 84)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 84)) ;
      GALGAS_string var_exitLabel_3829 = GALGAS_string ("assign.exit.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 85)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 85)) ;
      ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 86)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br label %").add_operation (var_startLabel_3694, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 87)).add_operation (GALGAS_string (" ;--- Assign static array from repeated dynamic value\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 87)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 87)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_startLabel_3694.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 88)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 88)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br label %").add_operation (var_loopLabel_3762, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 89)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 89)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 89)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_loopLabel_3762.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 90)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 90)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_indexVarName_3415, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (GALGAS_string (" = phi i32 [0, %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (var_startLabel_3694, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (GALGAS_string ("], ["), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (var_nextIndexVarName_3484, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (GALGAS_string (", %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (var_loopLabel_3762, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)).add_operation (GALGAS_string ("]\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 91)) ;
      const GALGAS_storeToUniversalReferenceIR temp_6 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_ptrVarName_3552, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extractedValue_3380_type.ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extractedValue_3380_type.ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 93)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 93)).add_operation (temp_6.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 93)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 93)).add_operation (var_indexVarName_3415, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 93)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 93)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 92)) ;
      GALGAS_string var_llvmAssignRoutineName_4513 = function_assignmentOperatorFuncName (extensionGetter_type (extractedValue_3391_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 94)), extensionGetter_type (extractedValue_3391_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 94)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 94)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  call void @").add_operation (var_llvmAssignRoutineName_4513.getter_assemblerRepresentation (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 95)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 95)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 95)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" (").add_operation (extensionGetter_llvmTypeName (extractedValue_3391_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (var_ptrVarName_3552, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (extensionGetter_llvmTypeName (extractedValue_3391_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (extensionGetter_llvmName (extractedValue_3391_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)).add_operation (GALGAS_string (")\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 96)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_nextIndexVarName_3484, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 97)).add_operation (GALGAS_string (" = add i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 97)).add_operation (var_indexVarName_3415, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 97)).add_operation (GALGAS_string (", 1\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 97)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 97)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_loopTestName_3623, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)).add_operation (GALGAS_string (" = icmp ult i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)).add_operation (var_nextIndexVarName_3484, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)).add_operation (extractedValue_3385_size.getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 98)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br i1 ").add_operation (var_loopTestName_3623, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)).add_operation (var_loopLabel_3762, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)).add_operation (var_exitLabel_3829, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 99)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_exitLabel_3829.add_operation (GALGAS_string (":\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 100)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 100)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayRepeatedStaticValue:
    {
      const cEnumAssociatedValues_objectIR_llvmArrayRepeatedStaticValue * extractPtr_6711 = (const cEnumAssociatedValues_objectIR_llvmArrayRepeatedStaticValue *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_omnibusType extractedValue_5150_type = extractPtr_6711->mAssociatedValue0 ;
      const GALGAS_uint extractedValue_5155_size = extractPtr_6711->mAssociatedValue1 ;
      const GALGAS_objectIR extractedValue_5161_value = extractPtr_6711->mAssociatedValue2 ;
      GALGAS_string var_indexVarName_5187 = GALGAS_string ("%index.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 102)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 102)) ;
      GALGAS_string var_nextIndexVarName_5256 = GALGAS_string ("%index.next.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 103)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 103)) ;
      GALGAS_string var_ptrVarName_5324 = GALGAS_string ("%element.ptr.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 104)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 104)) ;
      GALGAS_string var_loopTestName_5395 = GALGAS_string ("%continue.loop.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 105)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 105)) ;
      GALGAS_string var_startLabel_5466 = GALGAS_string ("assign.start.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 106)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 106)) ;
      GALGAS_string var_loopLabel_5534 = GALGAS_string ("assign.loop.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 107)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 107)) ;
      GALGAS_string var_exitLabel_5601 = GALGAS_string ("assign.exit.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 108)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 108)) ;
      ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 109)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br label %").add_operation (var_startLabel_5466, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 110)).add_operation (GALGAS_string (" ;--- Assign static array from repeated static value\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 110)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 110)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_startLabel_5466.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 111)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 111)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br label %").add_operation (var_loopLabel_5534, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 112)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 112)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 112)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_loopLabel_5534.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 113)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 113)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_indexVarName_5187, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (GALGAS_string (" = phi i32 [0, %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (var_startLabel_5466, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (GALGAS_string ("], ["), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (var_nextIndexVarName_5256, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (GALGAS_string (", %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (var_loopLabel_5534, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)).add_operation (GALGAS_string ("]\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 114)) ;
      const GALGAS_storeToUniversalReferenceIR temp_7 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_ptrVarName_5324, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extractedValue_5150_type.ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extractedValue_5150_type.ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 116)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 116)).add_operation (temp_7.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 116)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 116)).add_operation (var_indexVarName_5187, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 116)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 116)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 115)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (extensionGetter_llvmTypeName (extractedValue_5161_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (extensionGetter_llvmName (extractedValue_5161_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (extensionGetter_llvmTypeName (extractedValue_5161_value, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (var_ptrVarName_5324, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 117)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_nextIndexVarName_5256, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 118)).add_operation (GALGAS_string (" = add i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 118)).add_operation (var_indexVarName_5187, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 118)).add_operation (GALGAS_string (", 1\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 118)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 118)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_loopTestName_5395, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)).add_operation (GALGAS_string (" = icmp ult i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)).add_operation (var_nextIndexVarName_5256, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)).add_operation (extractedValue_5155_size.getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 119)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br i1 ").add_operation (var_loopTestName_5395, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)).add_operation (var_loopLabel_5534, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)).add_operation (var_exitLabel_5601, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 120)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_exitLabel_5601.add_operation (GALGAS_string (":\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 121)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 121)) ;
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayStaticValues:
    {
      const cEnumAssociatedValues_objectIR_llvmArrayStaticValues * extractPtr_7325 = (const cEnumAssociatedValues_objectIR_llvmArrayStaticValues *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_operandIRList extractedValue_6767_operands = extractPtr_7325->mAssociatedValue1 ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (";--- Assign static array from static value\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 123)) ;
      cEnumerator_operandIRList enumerator_6852 (extractedValue_6767_operands, kENUMERATION_UP) ;
      GALGAS_uint index_6845 ((uint32_t) 0) ;
      while (enumerator_6852.hasCurrentObject ()) {
        GALGAS_string var_tempVar_6894 = GALGAS_string ("%temp.addr.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 125)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 125)) ;
        ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 126)) ;
        const GALGAS_storeToUniversalReferenceIR temp_8 = this ;
        ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_tempVar_6894, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 127)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 127)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 127)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 127)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 127)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 128)).add_operation (temp_8.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 128)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 128)).add_operation (index_6845.getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 128)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 128)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 128)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 127)) ;
        GALGAS_string var_valueType_7182 = extensionGetter_llvmTypeName (enumerator_6852.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 129)) ;
        ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_valueType_7182, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (extensionGetter_llvmName (enumerator_6852.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (var_valueType_7182, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (var_tempVar_6894, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 130)) ;
        enumerator_6852.gotoNextObject () ;
        index_6845.increment_operation (inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 124)) ;
      }
    }
    break ;
  case GALGAS_objectIR::kEnum_llvmArrayDynamicValues:
    {
      const cEnumAssociatedValues_objectIR_llvmArrayDynamicValues * extractPtr_8284 = (const cEnumAssociatedValues_objectIR_llvmArrayDynamicValues *) (temp_1.readProperty_mSourceValue ().unsafePointer ()) ;
      const GALGAS_operandIRList extractedValue_7382_operands = extractPtr_8284->mAssociatedValue1 ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (";--- Assign static array from dynamic values\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 133)) ;
      cEnumerator_operandIRList enumerator_7467 (extractedValue_7382_operands, kENUMERATION_UP) ;
      GALGAS_uint index_7460 ((uint32_t) 0) ;
      while (enumerator_7467.hasCurrentObject ()) {
        GALGAS_string var_tempVar_7509 = GALGAS_string ("%temp.addr.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 135)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 135)) ;
        ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 136)) ;
        const GALGAS_storeToUniversalReferenceIR temp_9 = this ;
        ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_tempVar_7509, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 137)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 137)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 137)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 137)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 137)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 138)).add_operation (temp_9.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 138)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 138)).add_operation (index_7460.getter_string (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 138)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 138)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 138)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 137)) ;
        GALGAS_string var_valueType_7797 = extensionGetter_llvmTypeName (enumerator_7467.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 139)) ;
        enumGalgasBool test_10 = kBoolTrue ;
        if (kBoolTrue == test_10) {
          test_10 = extensionGetter_isStatic (enumerator_7467.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 140)).boolEnum () ;
          if (kBoolTrue == test_10) {
            ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_valueType_7797, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (extensionGetter_llvmName (enumerator_7467.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (var_valueType_7797, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (var_tempVar_7509, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 141)) ;
          }
        }
        if (kBoolFalse == test_10) {
          GALGAS_string var_llvmAssignRoutineName_8010 = function_assignmentOperatorFuncName (extensionGetter_type (enumerator_7467.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 143)), extensionGetter_type (enumerator_7467.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 143)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 143)) ;
          ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  call void @").add_operation (var_llvmAssignRoutineName_8010.getter_assemblerRepresentation (SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 144)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 144)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 144)) ;
          ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" (").add_operation (var_valueType_7797, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (var_tempVar_7509, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (var_valueType_7797, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (extensionGetter_llvmName (enumerator_7467.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)).add_operation (GALGAS_string (")\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 145)) ;
        }
        enumerator_7467.gotoNextObject () ;
        index_7460.increment_operation (inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 134)) ;
      }
    }
    break ;
  case GALGAS_objectIR::kEnum_literalString:
    {
    }
    break ;
  case GALGAS_objectIR::kEnum_zero:
    {
      const GALGAS_storeToUniversalReferenceIR temp_11 = this ;
      const GALGAS_storeToUniversalReferenceIR temp_12 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (extensionGetter_llvmName (temp_11.readProperty_mSourceValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (var_llvmType_2066, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (temp_12.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-universal-reference.galgas", 150)) ;
    }
    break ;
  }
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@storeFromTemporaryReferenceIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_storeFromTemporaryReferenceIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                     const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                     GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                     C_Compiler * inCompiler
                                                                     COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_storeFromTemporaryReferenceIR temp_0 = this ;
  GALGAS_string var_llvmType_1001 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) temp_0.readProperty_mTargetVarType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 26)) ;
  const GALGAS_storeFromTemporaryReferenceIR temp_1 = this ;
  const GALGAS_storeFromTemporaryReferenceIR temp_2 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  store ").add_operation (var_llvmType_1001, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (extensionGetter_llvmName (temp_1.readProperty_mSourceValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (var_llvmType_1001, inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (temp_2.readProperty_mLLVMTargetVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-to-temporary-reference.galgas", 27)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@standaloneRoutineCallIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_standaloneRoutineCallIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                               const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                               GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                               C_Compiler * inCompiler
                                                               COMMA_UNUSED_LOCATION_ARGS) {
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  "), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 17)) ;
  enumGalgasBool test_0 = kBoolTrue ;
  if (kBoolTrue == test_0) {
    const GALGAS_standaloneRoutineCallIR temp_1 = this ;
    test_0 = GALGAS_bool (kIsEqual, temp_1.readProperty_mResult ().objectCompare (GALGAS_objectIR::constructor_void (SOURCE_FILE ("intermediate-static-routine-call.galgas", 18)))).boolEnum () ;
    if (kBoolTrue == test_0) {
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("call void"), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 19)) ;
    }
  }
  if (kBoolFalse == test_0) {
    const GALGAS_standaloneRoutineCallIR temp_2 = this ;
    const GALGAS_standaloneRoutineCallIR temp_3 = this ;
    ioArgument_ioLLVMcode.plusAssign_operation(extensionGetter_llvmName (temp_2.readProperty_mResult (), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 21)).add_operation (GALGAS_string (" = call "), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 21)).add_operation (extensionGetter_llvmTypeName (temp_3.readProperty_mResult (), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 21)), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 21)), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 21)) ;
  }
  const GALGAS_standaloneRoutineCallIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" @").add_operation (temp_4.readProperty_mFunctionNameForGeneration ().getter_assemblerRepresentation (SOURCE_FILE ("intermediate-static-routine-call.galgas", 23)), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 23)).add_operation (GALGAS_string (" ("), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 23)), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 23)) ;
  const GALGAS_standaloneRoutineCallIR temp_5 = this ;
  cEnumerator_procCallEffectiveParameterListIR enumerator_990 (temp_5.readProperty_mArgumentList (), kENUMERATION_UP) ;
  while (enumerator_990.hasCurrentObject ()) {
    switch (enumerator_990.current_mEffectiveParameterPassingMode (HERE).enumValue ()) {
    case GALGAS_procEffectiveParameterPassingModeIR::kNotBuilt:
      break ;
    case GALGAS_procEffectiveParameterPassingModeIR::kEnum_input:
      {
        ioArgument_ioLLVMcode.plusAssign_operation(extensionGetter_llvmTypeName (enumerator_990.current_mParameter (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 27)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 27)).add_operation (extensionGetter_llvmName (enumerator_990.current_mParameter (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 27)), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 27)), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 27)) ;
      }
      break ;
    case GALGAS_procEffectiveParameterPassingModeIR::kEnum_output:
      {
        ioArgument_ioLLVMcode.plusAssign_operation(extensionGetter_llvmTypeName (enumerator_990.current_mParameter (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 29)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 29)).add_operation (extensionGetter_llvmName (enumerator_990.current_mParameter (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 29)), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 29)) ;
      }
      break ;
    case GALGAS_procEffectiveParameterPassingModeIR::kEnum_outputInput:
      {
        ioArgument_ioLLVMcode.plusAssign_operation(extensionGetter_llvmTypeName (enumerator_990.current_mParameter (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 31)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 31)).add_operation (extensionGetter_llvmName (enumerator_990.current_mParameter (HERE), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 31)), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 31)) ;
      }
      break ;
    }
    if (enumerator_990.hasNextObject ()) {
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (", "), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 34)) ;
    }
    enumerator_990.gotoNextObject () ;
  }
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (")\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 36)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@standaloneRoutineCallIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_standaloneRoutineCallIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                                   GALGAS_uint & /* ioArgument_ioMaxBranchOfOnInstructions */,
                                                                   C_Compiler * /* inCompiler */
                                                                   COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_standaloneRoutineCallIR temp_0 = this ;
  ioArgument_ioInvokedRoutineSet.addAssign_operation (temp_0.readProperty_mFunctionNameForGeneration ()  COMMA_SOURCE_FILE ("intermediate-static-routine-call.galgas", 45)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@releaseIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_releaseIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                 const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                 GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                 C_Compiler * inCompiler
                                                 COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_releaseIR temp_0 = this ;
  const GALGAS_releaseIR temp_1 = this ;
  callExtensionMethod_generateRelease ((cPtr_omnibusType *) temp_0.readProperty_mType ().ptr (), temp_1.readProperty_mOmnibusName ().readProperty_string (), ioArgument_ioLLVMcode, ioArgument_ioGenerationAdds, inCompiler COMMA_SOURCE_FILE ("intermediate-release.galgas", 20)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@computeSubscriptedVolatileRegisterAddress llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_computeSubscriptedVolatileRegisterAddress::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                                 const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                                 GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                                                 C_Compiler * inCompiler
                                                                                 COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string var_registerIndexName_1116 = GALGAS_string ("%register.index.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 29)) ;
  GALGAS_string var_scriptedRegisterOffsetName_1202 = GALGAS_string ("%register.offset.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 30)), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 30)) ;
  ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 31)) ;
  GALGAS_uint var_bitCount_1402 ;
  const GALGAS_computeSubscriptedVolatileRegisterAddress temp_0 = this ;
  GALGAS_bigint joker_1377_3 ; // Joker input parameter
  GALGAS_bigint joker_1377_2 ; // Joker input parameter
  GALGAS_bool joker_1377_1 ; // Joker input parameter
  extensionGetter_type (temp_0.readProperty_mIndexResult (), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 33)).readProperty_kind ().method_integer (joker_1377_3, joker_1377_2, joker_1377_1, var_bitCount_1402, inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 33)) ;
  enumGalgasBool test_1 = kBoolTrue ;
  if (kBoolTrue == test_1) {
    test_1 = GALGAS_bool (kIsStrictInf, var_bitCount_1402.objectCompare (GALGAS_uint (uint32_t (32U)))).boolEnum () ;
    if (kBoolTrue == test_1) {
      const GALGAS_computeSubscriptedVolatileRegisterAddress temp_2 = this ;
      const GALGAS_computeSubscriptedVolatileRegisterAddress temp_3 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_registerIndexName_1116, inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 35)).add_operation (GALGAS_string (" = zext "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 35)).add_operation (extensionGetter_llvmTypeName (temp_2.readProperty_mIndexResult (), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 35)), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 35)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 35)).add_operation (extensionGetter_llvmName (temp_3.readProperty_mIndexResult (), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 36)), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 36)).add_operation (GALGAS_string (" to i32 ; extend index to i32\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 36)), inCompiler  COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 35)) ;
    }
  }
  GALGAS_string temp_4 ;
  const enumGalgasBool test_5 = GALGAS_bool (kIsStrictInf, var_bitCount_1402.objectCompare (GALGAS_uint (uint32_t (32U)))).boolEnum () ;
  if (kBoolTrue == test_5) {
    temp_4 = var_registerIndexName_1116 ;
  }else if (kBoolFalse == test_5) {
    const GALGAS_computeSubscriptedVolatileRegisterAddress temp_6 = this ;
    temp_4 = extensionGetter_llvmName (temp_6.readProperty_mIndexResult (), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 40)) ;
  }
  const GALGAS_computeSubscriptedVolatileRegisterAddress temp_7 = this ;
  const GALGAS_computeSubscriptedVolatileRegisterAddress temp_8 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_scriptedRegisterOffsetName_1202, inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 39)).add_operation (GALGAS_string (" = mul i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 39)).add_operation (temp_4, inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 39)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 40)).add_operation (temp_7.readProperty_mElementSize ().getter_string (SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 41)), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 41)).add_operation (GALGAS_string (" ; multiply index by size "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 41)).add_operation (temp_8.readProperty_mElementSize ().getter_string (SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 41)), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 41)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 41)), inCompiler  COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 39)) ;
  const GALGAS_computeSubscriptedVolatileRegisterAddress temp_9 = this ;
  const GALGAS_computeSubscriptedVolatileRegisterAddress temp_10 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (temp_9.readProperty_mLLVMResultVarName (), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 42)).add_operation (GALGAS_string (" = add i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 42)).add_operation (temp_10.readProperty_mAddressLLVMname (), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 42)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 42)).add_operation (var_scriptedRegisterOffsetName_1202, inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 43)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 43)), inCompiler  COMMA_SOURCE_FILE ("intermediate-compute-subscripted-volatile-register-address.galgas", 42)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@enterRegisterAddressIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_enterRegisterAddressIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                              const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                              GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                              C_Compiler * inCompiler
                                                              COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_enterRegisterAddressIR temp_0 = this ;
  const GALGAS_enterRegisterAddressIR temp_1 = this ;
  const GALGAS_enterRegisterAddressIR temp_2 = this ;
  const GALGAS_enterRegisterAddressIR temp_3 = this ;
  const GALGAS_enterRegisterAddressIR temp_4 = this ;
  const GALGAS_enterRegisterAddressIR temp_5 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (temp_0.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 29)).add_operation (GALGAS_string (" = add i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 29)).add_operation (temp_1.readProperty_mBaseAddress ().getter_string (SOURCE_FILE ("intermediate-enter-register-address.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 29)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 29)).add_operation (temp_2.readProperty_mAddressOffset ().getter_string (SOURCE_FILE ("intermediate-enter-register-address.galgas", 30)), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 30)).add_operation (GALGAS_string (" ; "), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 30)).add_operation (temp_3.readProperty_mRegisterName (), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 30)).add_operation (GALGAS_string (" at "), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 30)).add_operation (temp_4.readProperty_mBaseAddress ().getter_hexString (SOURCE_FILE ("intermediate-enter-register-address.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 31)).add_operation (GALGAS_string (" = "), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 31)).add_operation (temp_5.readProperty_mAddressOffset ().getter_hexString (SOURCE_FILE ("intermediate-enter-register-address.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 31)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 31)), inCompiler  COMMA_SOURCE_FILE ("intermediate-enter-register-address.galgas", 29)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@enterRegisterGroupSubscriptedAddressIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_enterRegisterGroupSubscriptedAddressIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                              const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                              GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                              C_Compiler * inCompiler
                                                                              COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_0 = this ;
  GALGAS_string var_groupArrayName_1045 = function_registerGroupAddressArrayLLVMname (temp_0.readProperty_mGroupName (), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 29)) ;
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_1 = this ;
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_2 = this ;
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_3 = this ;
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (temp_1.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 30)).add_operation (GALGAS_string (".addr = getelementptr inbounds ["), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 30)).add_operation (temp_2.readProperty_mGroupSize ().getter_string (SOURCE_FILE ("intermediate-register-group-address.galgas", 30)), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 30)).add_operation (GALGAS_string (" x i32], ["), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 30)).add_operation (temp_3.readProperty_mGroupSize ().getter_string (SOURCE_FILE ("intermediate-register-group-address.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 31)).add_operation (GALGAS_string (" x i32]* "), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 31)).add_operation (var_groupArrayName_1045, inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 31)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 31)).add_operation (extensionGetter_llvmName (temp_4.readProperty_mIndexIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 32)), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 32)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 32)), inCompiler  COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 30)) ;
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_5 = this ;
  const GALGAS_enterRegisterGroupSubscriptedAddressIR temp_6 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (temp_5.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 33)).add_operation (GALGAS_string (" = load i32, i32* "), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 33)).add_operation (temp_6.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 33)).add_operation (GALGAS_string (".addr\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 33)), inCompiler  COMMA_SOURCE_FILE ("intermediate-register-group-address.galgas", 33)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@loadIndirectVolatileIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_loadIndirectVolatileIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                              const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                              GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                              C_Compiler * inCompiler
                                                              COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_loadIndirectVolatileIR temp_0 = this ;
  GALGAS_string var_llvmType_754 = extensionGetter_llvmTypeName (temp_0.readProperty_mTargetValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 23)) ;
  GALGAS_string var_ptr_799 = GALGAS_string ("%registerPointer.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 24)), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 24)) ;
  ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 25)) ;
  const GALGAS_loadIndirectVolatileIR temp_1 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_ptr_799, inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)).add_operation (GALGAS_string (" = inttoptr i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)).add_operation (temp_1.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)).add_operation (GALGAS_string (" to "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)).add_operation (var_llvmType_754, inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)).add_operation (GALGAS_string ("* ;\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)), inCompiler  COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 26)) ;
  const GALGAS_loadIndirectVolatileIR temp_2 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (extensionGetter_llvmName (temp_2.readProperty_mTargetValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)).add_operation (GALGAS_string (" = load volatile "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)).add_operation (var_llvmType_754, inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)).add_operation (var_llvmType_754, inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)).add_operation (var_ptr_799, inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 28)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 28)), inCompiler  COMMA_SOURCE_FILE ("intermediate-load-indirect-volatile-register.galgas", 27)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@storeIndirectVolatileIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_storeIndirectVolatileIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                               const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                               GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                               C_Compiler * inCompiler
                                                               COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_storeIndirectVolatileIR temp_0 = this ;
  GALGAS_string var_llvmType_852 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) temp_0.readProperty_mTargetVarType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 25)) ;
  GALGAS_string var_ptr_899 = GALGAS_string ("%registerPointer.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 26)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 26)) ;
  ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 27)) ;
  const GALGAS_storeIndirectVolatileIR temp_1 = this ;
  const GALGAS_storeIndirectVolatileIR temp_2 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_ptr_899, inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (GALGAS_string (" = inttoptr i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (temp_1.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (GALGAS_string (" to "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (var_llvmType_852, inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (GALGAS_string ("*\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (GALGAS_string ("  store volatile "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)).add_operation (var_llvmType_852, inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)).add_operation (extensionGetter_llvmName (temp_2.readProperty_mSourceValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)).add_operation (var_llvmType_852, inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 29)).add_operation (var_ptr_899, inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 30)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 30)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-indirect-volatile-register.galgas", 28)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@copyFromReferencesIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_copyFromReferencesIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                            const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                            GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                            C_Compiler * inCompiler
                                                            COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_copyFromReferencesIR temp_0 = this ;
  const GALGAS_copyFromReferencesIR temp_1 = this ;
  GALGAS_string var_assignmentFunctionLLVMName_2085 = function_assignmentOperatorFuncName (temp_0.readProperty_mTarget ().readProperty_type (), temp_1.readProperty_mTarget ().readProperty_type (), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 50)) ;
  const GALGAS_copyFromReferencesIR temp_2 = this ;
  GALGAS_string var_llvmTypeName_2173 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) temp_2.readProperty_mTarget ().readProperty_type ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 51)) ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  call void @").add_operation (var_assignmentFunctionLLVMName_2085.getter_assemblerRepresentation (SOURCE_FILE ("intermediate-copy-from-references.galgas", 52)), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 52)), inCompiler  COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 52)) ;
  const GALGAS_copyFromReferencesIR temp_3 = this ;
  const GALGAS_copyFromReferencesIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" (").add_operation (var_llvmTypeName_2173, inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (temp_3.readProperty_mTarget ().readProperty_llvmName (), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (var_llvmTypeName_2173, inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (temp_4.readProperty_mSourceLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)).add_operation (GALGAS_string (")\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)), inCompiler  COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 53)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@copyFromReferencesIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_copyFromReferencesIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                                GALGAS_uint & /* ioArgument_ioMaxBranchOfOnInstructions */,
                                                                C_Compiler * inCompiler
                                                                COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_copyFromReferencesIR temp_0 = this ;
  const GALGAS_copyFromReferencesIR temp_1 = this ;
  GALGAS_string var_assignmentFunctionLLVMName_2725 = function_assignmentOperatorFuncName (temp_0.readProperty_mTarget ().readProperty_type (), temp_1.readProperty_mTarget ().readProperty_type (), inCompiler COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 62)) ;
  ioArgument_ioInvokedRoutineSet.addAssign_operation (var_assignmentFunctionLLVMName_2725  COMMA_SOURCE_FILE ("intermediate-copy-from-references.galgas", 63)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@getUniversalPropertyReferenceIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_getUniversalPropertyReferenceIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                       const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                       GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                       C_Compiler * inCompiler
                                                                       COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_getUniversalPropertyReferenceIR temp_0 = this ;
  GALGAS_string var_llvmType_1025 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) temp_0.readProperty_mType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 29)) ;
  const GALGAS_getUniversalPropertyReferenceIR temp_1 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (temp_1.readProperty_mElementLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 30)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 30)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 30)) ;
  const GALGAS_getUniversalPropertyReferenceIR temp_2 = this ;
  const GALGAS_getUniversalPropertyReferenceIR temp_3 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(var_llvmType_1025.add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)).add_operation (var_llvmType_1025, inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)).add_operation (temp_2.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)).add_operation (GALGAS_string (", i32 0, i32 "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)).add_operation (temp_3.readProperty_mPropertyIndex ().getter_string (SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 31)) ;
  const GALGAS_getUniversalPropertyReferenceIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" ; ").add_operation (temp_4.readProperty_mPropertyName (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 32)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 32)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-universal-property-reference.galgas", 32)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@getUniversalArrayElementReferenceIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_getUniversalArrayElementReferenceIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                           const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                           GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                           C_Compiler * inCompiler
                                                                           COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_getUniversalArrayElementReferenceIR temp_0 = this ;
  GALGAS_string var_llvmType_1038 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) temp_0.readProperty_mType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 29)) ;
  const GALGAS_getUniversalArrayElementReferenceIR temp_1 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (temp_1.readProperty_mElementLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 30)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 30)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 30)) ;
  const GALGAS_getUniversalArrayElementReferenceIR temp_2 = this ;
  const GALGAS_getUniversalArrayElementReferenceIR temp_3 = this ;
  const GALGAS_getUniversalArrayElementReferenceIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(var_llvmType_1038.add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (var_llvmType_1038, inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (temp_2.readProperty_mLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (GALGAS_string (", i32 0, "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (extensionGetter_llvmTypeName (temp_3.readProperty_mIndexIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (extensionGetter_llvmName (temp_4.readProperty_mIndexIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-universal-array-element-reference.galgas", 31)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@getComputedPropertyValueIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_getComputedPropertyValueIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                  const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                  GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                  C_Compiler * inCompiler
                                                                  COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_getComputedPropertyValueIR temp_0 = this ;
  const GALGAS_getComputedPropertyValueIR temp_1 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (extensionGetter_llvmName (temp_0.readProperty_mResultValueIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)).add_operation (GALGAS_string (" = call "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_1.readProperty_mResultValueIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 29)) ;
  const GALGAS_getComputedPropertyValueIR temp_2 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" @").add_operation (temp_2.readProperty_mLLVMGetterName ().getter_assemblerRepresentation (SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 30)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 30)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 30)) ;
  const GALGAS_getComputedPropertyValueIR temp_3 = this ;
  const GALGAS_getComputedPropertyValueIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" (").add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_3.readProperty_mReceiverIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)).add_operation (extensionGetter_llvmName (temp_4.readProperty_mReceiverIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)).add_operation (GALGAS_string (")\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 31)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@getComputedPropertyValueIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_getComputedPropertyValueIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                                      GALGAS_uint & /* ioArgument_ioMaxBranchOfOnInstructions */,
                                                                      C_Compiler * /* inCompiler */
                                                                      COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_getComputedPropertyValueIR temp_0 = this ;
  ioArgument_ioInvokedRoutineSet.addAssign_operation (temp_0.readProperty_mLLVMGetterName ()  COMMA_SOURCE_FILE ("intermediate-get-computed-property-value.galgas", 40)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@storeComputedPropertyValueIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_storeComputedPropertyValueIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                    const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                    GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                    C_Compiler * inCompiler
                                                                    COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_storeComputedPropertyValueIR temp_0 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  call void @").add_operation (temp_0.readProperty_mLLVMSetterName ().getter_assemblerRepresentation (SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 25)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 25)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 25)) ;
  const GALGAS_storeComputedPropertyValueIR temp_1 = this ;
  const GALGAS_storeComputedPropertyValueIR temp_2 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" (").add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_1.readProperty_mReceiverIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)).add_operation (GALGAS_string ("* "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)).add_operation (extensionGetter_llvmName (temp_2.readProperty_mReceiverIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 26)) ;
  const GALGAS_storeComputedPropertyValueIR temp_3 = this ;
  const GALGAS_storeComputedPropertyValueIR temp_4 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_3.readProperty_mValueIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)).add_operation (extensionGetter_llvmName (temp_4.readProperty_mValueIR (), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)).add_operation (GALGAS_string (")\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)), inCompiler  COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 27)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@storeComputedPropertyValueIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_storeComputedPropertyValueIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                                        GALGAS_uint & /* ioArgument_ioMaxBranchOfOnInstructions */,
                                                                        C_Compiler * /* inCompiler */
                                                                        COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_storeComputedPropertyValueIR temp_0 = this ;
  ioArgument_ioInvokedRoutineSet.addAssign_operation (temp_0.readProperty_mLLVMSetterName ()  COMMA_SOURCE_FILE ("intermediate-store-computed-property-value.galgas", 36)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@getArrayElementReferenceIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_getArrayElementReferenceIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                                  const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                                  GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                                  C_Compiler * inCompiler
                                                                  COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_getArrayElementReferenceIR temp_0 = this ;
  GALGAS_string var_llvmType_1158 = callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_0.readProperty_mArray (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 30)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 30)) ;
  const GALGAS_getArrayElementReferenceIR temp_1 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (extensionGetter_llvmName (temp_1.readProperty_mTarget (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 31)).add_operation (GALGAS_string (" = getelementptr inbounds "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 31)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 31)) ;
  const GALGAS_getArrayElementReferenceIR temp_2 = this ;
  const GALGAS_getArrayElementReferenceIR temp_3 = this ;
  const GALGAS_getArrayElementReferenceIR temp_4 = this ;
  const GALGAS_getArrayElementReferenceIR temp_5 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(var_llvmType_1158.add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (var_llvmType_1158, inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (GALGAS_string (" * "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (extensionGetter_llvmName (temp_2.readProperty_mArray (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (GALGAS_string (", i32 0, "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (extensionGetter_llvmTypeName (temp_3.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)).add_operation (extensionGetter_llvmName (temp_4.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 33)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 33)).add_operation (GALGAS_string (" ; Element of index "), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 33)).add_operation (extensionGetter_llvmName (temp_5.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 34)), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 34)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 34)), inCompiler  COMMA_SOURCE_FILE ("intermediate-get-array-element-reference.galgas", 32)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@selectInstructionIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_selectInstructionIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                           const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                           GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                           C_Compiler * inCompiler
                                                           COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_selectInstructionIR temp_0 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (extensionGetter_llvmName (temp_0.readProperty_mTargetValue (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 27)), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 27)).add_operation (GALGAS_string (" = select "), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 27)), inCompiler  COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 27)) ;
  const GALGAS_selectInstructionIR temp_1 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("i1 ").add_operation (temp_1.readProperty_m_5F_if_5F_variableLLVMName (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 28)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 28)), inCompiler  COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 28)) ;
  const GALGAS_selectInstructionIR temp_2 = this ;
  const GALGAS_selectInstructionIR temp_3 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_2.readProperty_m_5F_then_5F_variable (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)).add_operation (extensionGetter_llvmName (temp_3.readProperty_m_5F_then_5F_variable (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)), inCompiler  COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 29)) ;
  const GALGAS_selectInstructionIR temp_4 = this ;
  const GALGAS_selectInstructionIR temp_5 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_4.readProperty_m_5F_else_5F_variable (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)).add_operation (extensionGetter_llvmName (temp_5.readProperty_m_5F_else_5F_variable (), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)), inCompiler  COMMA_SOURCE_FILE ("intermediate-select-instruction.galgas", 30)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@testArrayIndexIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_testArrayIndexIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                        const GALGAS_generationContext constinArgument_inGenerationContext,
                                                        GALGAS_generationAdds & ioArgument_ioGenerationAdds,
                                                        C_Compiler * inCompiler
                                                        COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bigint var_max_987 ;
  GALGAS_bool var_isUnsigned_1012 ;
  const GALGAS_testArrayIndexIR temp_0 = this ;
  GALGAS_bigint joker_972_1 ; // Joker input parameter
  GALGAS_uint joker_1014_1 ; // Joker input parameter
  extensionGetter_type (temp_0.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 28)).readProperty_kind ().method_integer (joker_972_1, var_max_987, var_isUnsigned_1012, joker_1014_1, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 28)) ;
  enumGalgasBool test_1 = kBoolTrue ;
  if (kBoolTrue == test_1) {
    test_1 = var_isUnsigned_1012.operator_not (SOURCE_FILE ("intermediate-test-array-index.galgas", 30)).boolEnum () ;
    if (kBoolTrue == test_1) {
      GALGAS_string var_testToZero_1101 = GALGAS_string ("%test.index.zero.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 31)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 31)) ;
      GALGAS_string var_testToZeroOk_1176 = GALGAS_string ("test.index.zero.ok.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 32)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 32)) ;
      GALGAS_string var_testToZeroFailure_1258 = GALGAS_string ("test.index.zero.fails.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 33)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 33)) ;
      ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 34)) ;
      const GALGAS_testArrayIndexIR temp_2 = this ;
      const GALGAS_testArrayIndexIR temp_3 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_testToZero_1101, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)).add_operation (GALGAS_string (" = icmp sge "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_2.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)).add_operation (extensionGetter_llvmName (temp_3.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)).add_operation (GALGAS_string (", 0\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 35)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br i1 ").add_operation (var_testToZero_1101, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)).add_operation (var_testToZeroOk_1176, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)).add_operation (var_testToZeroFailure_1258, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)).add_operation (GALGAS_string ("\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 36)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_testToZeroFailure_1258.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 38)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 38)) ;
      const GALGAS_testArrayIndexIR temp_4 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  call void @").add_operation (function_panicRoutineNameForLocationFile (temp_4.readProperty_mErrorLocation (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 39)).getter_assemblerRepresentation (SOURCE_FILE ("intermediate-test-array-index.galgas", 39)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 39)).add_operation (GALGAS_string (" ("), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 39)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 39)) ;
      const GALGAS_testArrayIndexIR temp_5 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) constinArgument_inGenerationContext.readProperty_mPanicLineLLVMType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 40)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 40)).add_operation (temp_5.readProperty_mErrorLocation ().getter_line (inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 40)).getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 40)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 40)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 40)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 40)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) constinArgument_inGenerationContext.readProperty_mPanicCodeLLVMType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 41)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 41)).add_operation (function_panicCodeForNegativeArrayIndex (inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 41)).getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 41)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 41)).add_operation (GALGAS_string (") noreturn \n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 41)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 41)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  unreachable\n\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 42)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_testToZeroOk_1176.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 44)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 44)) ;
    }
  }
  enumGalgasBool test_6 = kBoolTrue ;
  if (kBoolTrue == test_6) {
    const GALGAS_testArrayIndexIR temp_7 = this ;
    test_6 = GALGAS_bool (kIsSupOrEqual, var_max_987.objectCompare (temp_7.readProperty_mSize ())).boolEnum () ;
    if (kBoolTrue == test_6) {
      GALGAS_string var_testToSize_2210 = GALGAS_string ("%test.index.size.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 48)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 48)) ;
      GALGAS_string var_testToSizeOk_2285 = GALGAS_string ("test.index.size.ok.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 49)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 49)) ;
      GALGAS_string var_testToSizeFailure_2367 = GALGAS_string ("test.index.size.fails.").add_operation (ioArgument_ioGenerationAdds.readProperty_mUniqueIndex ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 50)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 50)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  ").add_operation (var_testToSize_2210, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 51)).add_operation (GALGAS_string (" = icmp "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 51)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 51)) ;
      GALGAS_string temp_8 ;
      const enumGalgasBool test_9 = var_isUnsigned_1012.boolEnum () ;
      if (kBoolTrue == test_9) {
        temp_8 = GALGAS_string ("ult") ;
      }else if (kBoolFalse == test_9) {
        temp_8 = GALGAS_string ("slt") ;
      }
      ioArgument_ioLLVMcode.plusAssign_operation(temp_8, inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 52)) ;
      const GALGAS_testArrayIndexIR temp_10 = this ;
      const GALGAS_testArrayIndexIR temp_11 = this ;
      const GALGAS_testArrayIndexIR temp_12 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (" ").add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) extensionGetter_type (temp_10.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)).ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)).add_operation (extensionGetter_llvmName (temp_11.readProperty_mIndex (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)).add_operation (temp_12.readProperty_mSize ().getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 53)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 53)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  br i1 ").add_operation (var_testToSize_2210, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)).add_operation (var_testToSizeOk_2285, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)).add_operation (GALGAS_string (", label %"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)).add_operation (var_testToSizeFailure_2367, inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)).add_operation (GALGAS_string ("\n\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 54)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_testToSizeFailure_2367.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 56)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 56)) ;
      const GALGAS_testArrayIndexIR temp_13 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  call void @").add_operation (function_panicRoutineNameForLocationFile (temp_13.readProperty_mErrorLocation (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 57)).getter_assemblerRepresentation (SOURCE_FILE ("intermediate-test-array-index.galgas", 57)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 57)).add_operation (GALGAS_string (" ("), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 57)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 57)) ;
      const GALGAS_testArrayIndexIR temp_14 = this ;
      ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) constinArgument_inGenerationContext.readProperty_mPanicLineLLVMType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 58)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 58)).add_operation (temp_14.readProperty_mErrorLocation ().getter_line (inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 58)).getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 58)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 58)).add_operation (GALGAS_string (", "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 58)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 58)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) constinArgument_inGenerationContext.readProperty_mPanicCodeLLVMType ().ptr (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 59)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 59)).add_operation (function_panicCodeForTooLargeArrayIndex (inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 59)).getter_string (SOURCE_FILE ("intermediate-test-array-index.galgas", 59)), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 59)).add_operation (GALGAS_string (") noreturn \n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 59)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 59)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string ("  unreachable\n\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 60)) ;
      ioArgument_ioLLVMcode.plusAssign_operation(var_testToSizeOk_2285.add_operation (GALGAS_string (":\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 62)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 62)) ;
    }
  }
  ioArgument_ioGenerationAdds.mProperty_mUniqueIndex.plusAssign_operation(GALGAS_uint (uint32_t (1U)), inCompiler  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 65)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@testArrayIndexIR enterAccessibleEntities'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_testArrayIndexIR::method_enterAccessibleEntities (GALGAS_stringset & ioArgument_ioInvokedRoutineSet,
                                                            GALGAS_uint & /* ioArgument_ioMaxBranchOfOnInstructions */,
                                                            C_Compiler * inCompiler
                                                            COMMA_UNUSED_LOCATION_ARGS) {
  enumGalgasBool test_0 = kBoolTrue ;
  if (kBoolTrue == test_0) {
    test_0 = GALGAS_bool (gOption_omnibus_5F_options_noPanicGeneration.readProperty_value ()).operator_not (SOURCE_FILE ("intermediate-test-array-index.galgas", 74)).boolEnum () ;
    if (kBoolTrue == test_0) {
      const GALGAS_testArrayIndexIR temp_1 = this ;
      ioArgument_ioInvokedRoutineSet.addAssign_operation (function_panicRoutineNameForLocationFile (temp_1.readProperty_mErrorLocation (), inCompiler COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 75))  COMMA_SOURCE_FILE ("intermediate-test-array-index.galgas", 75)) ;
    }
  }
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@sourceLocationIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_sourceLocationIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                        const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                        GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                        C_Compiler * inCompiler
                                                        COMMA_UNUSED_LOCATION_ARGS) {
  enumGalgasBool test_0 = kBoolTrue ;
  if (kBoolTrue == test_0) {
    const GALGAS_sourceLocationIR temp_1 = this ;
    test_0 = temp_1.readProperty_mSourceLocation ().getter_isNowhere (SOURCE_FILE ("intermediate-comment-source-line.galgas", 19)).boolEnum () ;
    if (kBoolTrue == test_0) {
      ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (";---------\n"), inCompiler  COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 20)) ;
    }
  }
  if (kBoolFalse == test_0) {
    const GALGAS_sourceLocationIR temp_2 = this ;
    const GALGAS_sourceLocationIR temp_3 = this ;
    ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (";--------- ").add_operation (temp_2.readProperty_mSourceLocation ().getter_line (inCompiler COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)).getter_string (SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)), inCompiler COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)).add_operation (GALGAS_string (":"), inCompiler COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)).add_operation (temp_3.readProperty_mSourceLocation ().getter_file (inCompiler COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)).getter_lastPathComponent (SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)), inCompiler COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)), inCompiler  COMMA_SOURCE_FILE ("intermediate-comment-source-line.galgas", 22)) ;
  }
}
//----------------------------------------------------------------------------------------------------------------------
//
//Overriding extension method '@freeCommentIR llvmInstructionCode'
//
//----------------------------------------------------------------------------------------------------------------------

void cPtr_freeCommentIR::method_llvmInstructionCode (GALGAS_string & ioArgument_ioLLVMcode,
                                                     const GALGAS_generationContext /* constinArgument_inGenerationContext */,
                                                     GALGAS_generationAdds & /* ioArgument_ioGenerationAdds */,
                                                     C_Compiler * inCompiler
                                                     COMMA_UNUSED_LOCATION_ARGS) {
  const GALGAS_freeCommentIR temp_0 = this ;
  ioArgument_ioLLVMcode.plusAssign_operation(GALGAS_string (";--------- ").add_operation (temp_0.readProperty_mComment (), inCompiler COMMA_SOURCE_FILE ("intermediate-free-comment.galgas", 19)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("intermediate-free-comment.galgas", 19)), inCompiler  COMMA_SOURCE_FILE ("intermediate-free-comment.galgas", 19)) ;
}
//----------------------------------------------------------------------------------------------------------------------
//
//Routine 'codeOptimization'
//
//----------------------------------------------------------------------------------------------------------------------

void routine_codeOptimization (const GALGAS_string constinArgument_inSourceFile,
                               GALGAS_intermediateCodeStruct & ioArgument_ioIntermediateCodeStruct,
                               C_Compiler * inCompiler
                               COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_routineAccessibilityIR var_routineAccessibilityIR_1397 = GALGAS_routineAccessibilityIR::constructor_emptyList (SOURCE_FILE ("dead-code-elimination.galgas", 26)) ;
  GALGAS_stringset var_exploreRoutineSet_1513 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 28)) ;
  GALGAS_stringset var_allRoutineSet_1549 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 29)) ;
  GALGAS_stringset var_definedRoutineSet_1589 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 30)) ;
  cEnumerator_routineListIR enumerator_1651 (ioArgument_ioIntermediateCodeStruct.readProperty_mRoutineListIR (), kENUMERATION_UP) ;
  while (enumerator_1651.hasCurrentObject ()) {
    GALGAS_stringset var_accessibleRoutineSet_1694 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 32)) ;
    callExtensionMethod_enterAccessibleEntities ((cPtr_abstractRoutineIR *) enumerator_1651.current (HERE).readProperty_mRoutine ().ptr (), var_accessibleRoutineSet_1694, ioArgument_ioIntermediateCodeStruct.mProperty_mMaxBranchOfOnInstructions, inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 33)) ;
    var_routineAccessibilityIR_1397.addAssign_operation (enumerator_1651.current (HERE).readProperty_mRoutine (), var_accessibleRoutineSet_1694  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 34)) ;
    var_allRoutineSet_1549.plusAssign_operation(var_accessibleRoutineSet_1694, inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 35)) ;
    var_definedRoutineSet_1589.addAssign_operation (enumerator_1651.current (HERE).readProperty_mRoutine ().readProperty_mRoutineMangledName ().readProperty_string ()  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 36)) ;
    enumGalgasBool test_0 = kBoolTrue ;
    if (kBoolTrue == test_0) {
      test_0 = enumerator_1651.current (HERE).readProperty_mRoutine ().readProperty_isRequired ().boolEnum () ;
      if (kBoolTrue == test_0) {
        var_exploreRoutineSet_1513.addAssign_operation (enumerator_1651.current (HERE).readProperty_mRoutine ().readProperty_mRoutineMangledName ().readProperty_string ()  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 38)) ;
      }
    }
    enumerator_1651.gotoNextObject () ;
  }
  enumGalgasBool test_1 = kBoolTrue ;
  if (kBoolTrue == test_1) {
    test_1 = GALGAS_bool (gOption_omnibus_5F_options_printPasses.readProperty_value ()).boolEnum () ;
    if (kBoolTrue == test_1) {
      GALGAS_string var_m_2180 = GALGAS_string ("** Dead code elimination\n") ;
      var_m_2180.plusAssign_operation(GALGAS_string ("    ").add_operation (ioArgument_ioIntermediateCodeStruct.readProperty_mRoutineListIR ().getter_length (SOURCE_FILE ("dead-code-elimination.galgas", 43)).getter_string (SOURCE_FILE ("dead-code-elimination.galgas", 43)), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 43)).add_operation (GALGAS_string (" routines, "), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 43)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 43)) ;
      var_m_2180.plusAssign_operation(var_exploreRoutineSet_1513.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 44)).getter_string (SOURCE_FILE ("dead-code-elimination.galgas", 44)).add_operation (GALGAS_string (" root routines.\n"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 44)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 44)) ;
      inCompiler->printMessage (var_m_2180  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 45)) ;
    }
  }
  GALGAS_stringset var_undefinedRoutineSet_2505 = var_allRoutineSet_1549.substract_operation (var_definedRoutineSet_1589, inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 48)) ;
  enumGalgasBool test_2 = kBoolTrue ;
  if (kBoolTrue == test_2) {
    test_2 = GALGAS_bool (kIsStrictSup, var_undefinedRoutineSet_2505.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 49)).objectCompare (GALGAS_uint (uint32_t (0U)))).boolEnum () ;
    if (kBoolTrue == test_2) {
      GALGAS_string var_m_2593 = GALGAS_string ("undefined routine(s):") ;
      cEnumerator_stringset enumerator_2636 (var_undefinedRoutineSet_2505, kENUMERATION_UP) ;
      while (enumerator_2636.hasCurrentObject ()) {
        var_m_2593.plusAssign_operation(GALGAS_string ("\n    - ").add_operation (enumerator_2636.current_key (HERE), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 52)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 52)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 52)) ;
        enumerator_2636.gotoNextObject () ;
      }
      TC_Array <C_FixItDescription> fixItArray3 ;
      inCompiler->emitSemanticError (GALGAS_location::constructor_nowhere (SOURCE_FILE ("dead-code-elimination.galgas", 54)), var_m_2593, fixItArray3  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 54)) ;
    }
  }
  enumGalgasBool test_4 = kBoolTrue ;
  if (kBoolTrue == test_4) {
    test_4 = GALGAS_bool (gOption_omnibus_5F_options_noDeadCodeElimination.readProperty_value ()).boolEnum () ;
    if (kBoolTrue == test_4) {
      inCompiler->printMessage (GALGAS_string ("    No dead code elimination (option --").add_operation (GALGAS_string (gOption_omnibus_5F_options_noDeadCodeElimination.readProperty_string ()), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 58)).add_operation (GALGAS_string (")\n"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 58))  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 58)) ;
    }
  }
  if (kBoolFalse == test_4) {
    GALGAS_stringset var_usefulRoutineSet_3036 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 60)) ;
    if (ioArgument_ioIntermediateCodeStruct.readProperty_mRoutineListIR ().getter_length (SOURCE_FILE ("dead-code-elimination.galgas", 61)).add_operation (GALGAS_uint (uint32_t (1U)), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 61)).isValid ()) {
      uint32_t variant_3050 = ioArgument_ioIntermediateCodeStruct.readProperty_mRoutineListIR ().getter_length (SOURCE_FILE ("dead-code-elimination.galgas", 61)).add_operation (GALGAS_uint (uint32_t (1U)), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 61)).uintValue () ;
      bool loop_3050 = true ;
      while (loop_3050) {
        loop_3050 = GALGAS_bool (kIsStrictSup, var_exploreRoutineSet_1513.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 61)).objectCompare (GALGAS_uint (uint32_t (0U)))).isValid () ;
        if (loop_3050) {
          loop_3050 = GALGAS_bool (kIsStrictSup, var_exploreRoutineSet_1513.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 61)).objectCompare (GALGAS_uint (uint32_t (0U)))).boolValue () ;
        }
        if (loop_3050 && (0 == variant_3050)) {
          loop_3050 = false ;
          inCompiler->loopRunTimeVariantError (SOURCE_FILE ("dead-code-elimination.galgas", 61)) ;
        }
        if (loop_3050) {
          variant_3050 -- ;
          GALGAS_stringset var_currentSet_3165 = var_exploreRoutineSet_1513 ;
          var_exploreRoutineSet_1513 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 63)) ;
          cEnumerator_routineAccessibilityIR enumerator_3258 (var_routineAccessibilityIR_1397, kENUMERATION_UP) ;
          while (enumerator_3258.hasCurrentObject ()) {
            GALGAS_lstring var_routineMangledName_3292 = enumerator_3258.current (HERE).readProperty_mRoutine ().readProperty_mRoutineMangledName () ;
            enumGalgasBool test_5 = kBoolTrue ;
            if (kBoolTrue == test_5) {
              test_5 = var_currentSet_3165.getter_hasKey (var_routineMangledName_3292.readProperty_string () COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 66)).operator_and (var_usefulRoutineSet_3036.getter_hasKey (var_routineMangledName_3292.readProperty_string () COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 66)).operator_not (SOURCE_FILE ("dead-code-elimination.galgas", 66)) COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 66)).boolEnum () ;
              if (kBoolTrue == test_5) {
                var_usefulRoutineSet_3036.addAssign_operation (var_routineMangledName_3292.readProperty_string ()  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 67)) ;
                var_exploreRoutineSet_1513.plusAssign_operation(enumerator_3258.current (HERE).readProperty_mAccessibleRoutineSet (), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 68)) ;
              }
            }
            enumerator_3258.gotoNextObject () ;
          }
        }
      }
    }
    cEnumerator_routineAccessibilityIR enumerator_3694 (var_routineAccessibilityIR_1397, kENUMERATION_UP) ;
    while (enumerator_3694.hasCurrentObject ()) {
      GALGAS_lstring var_routineMangledName_3726 = enumerator_3694.current (HERE).readProperty_mRoutine ().readProperty_mRoutineMangledName () ;
      enumGalgasBool test_6 = kBoolTrue ;
      if (kBoolTrue == test_6) {
        test_6 = enumerator_3694.current (HERE).readProperty_mRoutine ().readProperty_warnsIfUnused ().operator_and (var_usefulRoutineSet_3036.getter_hasKey (var_routineMangledName_3726.readProperty_string () COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 75)).operator_not (SOURCE_FILE ("dead-code-elimination.galgas", 75)) COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 75)).boolEnum () ;
        if (kBoolTrue == test_6) {
          TC_Array <C_FixItDescription> fixItArray7 ;
          inCompiler->emitSemanticWarning (var_routineMangledName_3726.readProperty_location (), GALGAS_string ("unused routine"), fixItArray7  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 76)) ;
        }
      }
      enumerator_3694.gotoNextObject () ;
    }
    enumGalgasBool test_8 = kBoolTrue ;
    if (kBoolTrue == test_8) {
      test_8 = GALGAS_bool (gOption_omnibus_5F_options_printPasses.readProperty_value ()).boolEnum () ;
      if (kBoolTrue == test_8) {
        GALGAS_string var_m_4052 = GALGAS_string ("    ").add_operation (var_usefulRoutineSet_3036.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 81)).getter_string (SOURCE_FILE ("dead-code-elimination.galgas", 81)), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 81)).add_operation (GALGAS_string (" useful routines.\n"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 81)) ;
        inCompiler->printMessage (var_m_4052  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 85)) ;
      }
    }
    ioArgument_ioIntermediateCodeStruct.setter_setMRoutineListIR (GALGAS_routineListIR::constructor_emptyList (SOURCE_FILE ("dead-code-elimination.galgas", 88)) COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 88)) ;
    cEnumerator_routineAccessibilityIR enumerator_4375 (var_routineAccessibilityIR_1397, kENUMERATION_UP) ;
    while (enumerator_4375.hasCurrentObject ()) {
      enumGalgasBool test_9 = kBoolTrue ;
      if (kBoolTrue == test_9) {
        test_9 = var_usefulRoutineSet_3036.getter_hasKey (enumerator_4375.current_mRoutine (HERE).readProperty_mRoutineMangledName ().readProperty_string () COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 90)).boolEnum () ;
        if (kBoolTrue == test_9) {
          ioArgument_ioIntermediateCodeStruct.mProperty_mRoutineListIR.addAssign_operation (enumerator_4375.current_mRoutine (HERE)  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 91)) ;
        }
      }
      enumerator_4375.gotoNextObject () ;
    }
  }
  GALGAS_string var_filePath_4603 = constinArgument_inSourceFile.add_operation (GALGAS_string (".routineInvocation.dot"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 96)) ;
  enumGalgasBool test_10 = kBoolTrue ;
  if (kBoolTrue == test_10) {
    test_10 = GALGAS_bool (gOption_omnibus_5F_options_emitRoutineInvocationGraphFile.readProperty_value ()).boolEnum () ;
    if (kBoolTrue == test_10) {
      {
      routine_displayInvocationGraph (ioArgument_ioIntermediateCodeStruct.readProperty_mRoutineListIR (), var_filePath_4603, inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 98)) ;
      }
    }
  }
  if (kBoolFalse == test_10) {
    {
    GALGAS_string::class_method_deleteFileIfExists (var_filePath_4603, inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 100)) ;
    }
  }
}


//----------------------------------------------------------------------------------------------------------------------
//
//Routine 'displayInvocationGraph'
//
//----------------------------------------------------------------------------------------------------------------------

void routine_displayInvocationGraph (const GALGAS_routineListIR constinArgument_inRoutineListIR,
                                     const GALGAS_string constinArgument_inFilePath,
                                     C_Compiler * inCompiler
                                     COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string var_s_5088 = GALGAS_string ("digraph G {\n") ;
  GALGAS_stringset var_definedRoutines_5156 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 112)) ;
  GALGAS_stringset var_allRoutines_5190 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 113)) ;
  cEnumerator_routineListIR enumerator_5210 (constinArgument_inRoutineListIR, kENUMERATION_UP) ;
  while (enumerator_5210.hasCurrentObject ()) {
    var_definedRoutines_5156.addAssign_operation (enumerator_5210.current_mRoutine (HERE).readProperty_mRoutineMangledName ().readProperty_string ()  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 115)) ;
    var_allRoutines_5190.addAssign_operation (enumerator_5210.current_mRoutine (HERE).readProperty_mRoutineMangledName ().readProperty_string ()  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 116)) ;
    GALGAS_stringset var_accessibleRoutineSet_5373 = GALGAS_stringset::constructor_emptySet (SOURCE_FILE ("dead-code-elimination.galgas", 117)) ;
    GALGAS_uint joker_5441 = GALGAS_uint::constructor_default (SOURCE_FILE ("dead-code-elimination.galgas", 118)) ;
    callExtensionMethod_enterAccessibleEntities ((cPtr_abstractRoutineIR *) enumerator_5210.current_mRoutine (HERE).ptr (), var_accessibleRoutineSet_5373, joker_5441, inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 118)) ;
    var_allRoutines_5190.plusAssign_operation(var_accessibleRoutineSet_5373, inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 119)) ;
    var_s_5088.plusAssign_operation(GALGAS_string ("  \"").add_operation (enumerator_5210.current_mRoutine (HERE).readProperty_mRoutineMangledName ().readProperty_string (), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 120)).add_operation (GALGAS_string ("\" [shape=rectangle"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 120)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 120)) ;
    enumGalgasBool test_0 = kBoolTrue ;
    if (kBoolTrue == test_0) {
      test_0 = enumerator_5210.current_mRoutine (HERE).readProperty_isRequired ().boolEnum () ;
      if (kBoolTrue == test_0) {
        var_s_5088.plusAssign_operation(GALGAS_string (", color=blue"), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 122)) ;
      }
    }
    var_s_5088.plusAssign_operation(GALGAS_string ("] ;\n"), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 124)) ;
    cEnumerator_stringset enumerator_5707 (var_accessibleRoutineSet_5373, kENUMERATION_UP) ;
    while (enumerator_5707.hasCurrentObject ()) {
      var_s_5088.plusAssign_operation(GALGAS_string ("  \"").add_operation (enumerator_5210.current_mRoutine (HERE).readProperty_mRoutineMangledName ().readProperty_string (), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 126)).add_operation (GALGAS_string ("\" -> \""), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 126)).add_operation (enumerator_5707.current (HERE), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 126)).add_operation (GALGAS_string ("\" ;\n"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 126)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 126)) ;
      enumerator_5707.gotoNextObject () ;
    }
    enumerator_5210.gotoNextObject () ;
  }
  GALGAS_stringset var_undefinedRoutineSet_5881 = var_allRoutines_5190.substract_operation (var_definedRoutines_5156, inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 130)) ;
  cEnumerator_stringset enumerator_5952 (var_undefinedRoutineSet_5881, kENUMERATION_UP) ;
  while (enumerator_5952.hasCurrentObject ()) {
    var_s_5088.plusAssign_operation(GALGAS_string ("  \"").add_operation (enumerator_5952.current (HERE), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 132)).add_operation (GALGAS_string ("\" [shape=rectangle, color=red] ;\n"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 132)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 132)) ;
    enumerator_5952.gotoNextObject () ;
  }
  var_s_5088.plusAssign_operation(GALGAS_string ("}\n"), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 134)) ;
  GALGAS_bool joker_6096 ; // Joker input parameter
  var_s_5088.method_writeToFileWhenDifferentContents (constinArgument_inFilePath, joker_6096, inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 135)) ;
  enumGalgasBool test_1 = kBoolTrue ;
  if (kBoolTrue == test_1) {
    test_1 = GALGAS_bool (kIsStrictSup, var_undefinedRoutineSet_5881.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 136)).objectCompare (GALGAS_uint (uint32_t (0U)))).boolEnum () ;
    if (kBoolTrue == test_1) {
      GALGAS_string var_m_6150 = var_undefinedRoutineSet_5881.getter_count (SOURCE_FILE ("dead-code-elimination.galgas", 137)).getter_string (SOURCE_FILE ("dead-code-elimination.galgas", 137)).add_operation (GALGAS_string (" undefined routine(s) in routine invocation graph"), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 137)) ;
      cEnumerator_stringset enumerator_6254 (var_undefinedRoutineSet_5881, kENUMERATION_UP) ;
      while (enumerator_6254.hasCurrentObject ()) {
        var_m_6150.plusAssign_operation(GALGAS_string ("\n    - ").add_operation (enumerator_6254.current_key (HERE), inCompiler COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 139)), inCompiler  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 139)) ;
        enumerator_6254.gotoNextObject () ;
      }
      TC_Array <C_FixItDescription> fixItArray2 ;
      inCompiler->emitSemanticError (GALGAS_location::constructor_nowhere (SOURCE_FILE ("dead-code-elimination.galgas", 141)), var_m_6150, fixItArray2  COMMA_SOURCE_FILE ("dead-code-elimination.galgas", 141)) ;
    }
  }
}


//----------------------------------------------------------------------------------------------------------------------
//
//Once function 'llvmSeparatorLine'
//
//----------------------------------------------------------------------------------------------------------------------

static GALGAS_string onceFunction_llvmSeparatorLine (C_Compiler * inCompiler
                                                     COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_result ; // Returned variable
  result_result = GALGAS_string (";-------------------------------------------------------------------------") ;
  result_result.plusAssign_operation(GALGAS_string ("---------------------------------------------*\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 57)) ;
//---
  return result_result ;
}



//----------------------------------------------------------------------------------------------------------------------
//  Function implementation                                                                      
//----------------------------------------------------------------------------------------------------------------------

static bool gOnceFunctionResultAvailable_llvmSeparatorLine = false ;
static GALGAS_string gOnceFunctionResult_llvmSeparatorLine ;

//----------------------------------------------------------------------------------------------------------------------

GALGAS_string function_llvmSeparatorLine (class C_Compiler * inCompiler
              COMMA_LOCATION_ARGS) {
  if (! gOnceFunctionResultAvailable_llvmSeparatorLine) {
    gOnceFunctionResult_llvmSeparatorLine = onceFunction_llvmSeparatorLine (inCompiler COMMA_THERE) ;
    gOnceFunctionResultAvailable_llvmSeparatorLine = true ;
  }
  return gOnceFunctionResult_llvmSeparatorLine ;
}

//----------------------------------------------------------------------------------------------------------------------

static void releaseOnceFunctionResult_llvmSeparatorLine (void) {
  gOnceFunctionResult_llvmSeparatorLine.drop () ;
}

//----------------------------------------------------------------------------------------------------------------------

C_PrologueEpilogue gEpilogueForOnceFunction_llvmSeparatorLine (NULL,
                                                               releaseOnceFunctionResult_llvmSeparatorLine) ;

//----------------------------------------------------------------------------------------------------------------------
//  Function introspection                                                                       
//----------------------------------------------------------------------------------------------------------------------

static const C_galgas_type_descriptor * functionArgs_llvmSeparatorLine [1] = {
  NULL
} ;

//----------------------------------------------------------------------------------------------------------------------

static GALGAS_object functionWithGenericHeader_llvmSeparatorLine (C_Compiler * inCompiler,
                                                                  const cObjectArray & /* inEffectiveParameterArray */,
                                                                  const GALGAS_location & /* inErrorLocation */
                                                                  COMMA_LOCATION_ARGS) {
  return function_llvmSeparatorLine (inCompiler COMMA_THERE).getter_object (THERE) ;
}

//----------------------------------------------------------------------------------------------------------------------

C_galgas_function_descriptor functionDescriptor_llvmSeparatorLine ("llvmSeparatorLine",
                                                                   functionWithGenericHeader_llvmSeparatorLine,
                                                                   & kTypeDescriptor_GALGAS_string,
                                                                   0,
                                                                   functionArgs_llvmSeparatorLine) ;

//----------------------------------------------------------------------------------------------------------------------
//
//Function 'llvmTitleComment'
//
//----------------------------------------------------------------------------------------------------------------------

GALGAS_string function_llvmTitleComment (const GALGAS_string & constinArgument_inTitle,
                                         C_Compiler * inCompiler
                                         COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outTitle ; // Returned variable
  result_outTitle = function_llvmSeparatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 63)) ;
  result_outTitle.plusAssign_operation(GALGAS_string (";    ").add_operation (constinArgument_inTitle.getter_stringByRightPadding (GALGAS_uint (uint32_t (114U)), GALGAS_char (TO_UNICODE (32)) COMMA_SOURCE_FILE ("code-generation.galgas", 64)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 64)).add_operation (GALGAS_string ("*\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 64)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 64)) ;
  result_outTitle.plusAssign_operation(function_llvmSeparatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 65)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 65)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 65)) ;
//---
  return result_outTitle ;
}


//----------------------------------------------------------------------------------------------------------------------
//  Function introspection                                                                       
//----------------------------------------------------------------------------------------------------------------------

static const C_galgas_type_descriptor * functionArgs_llvmTitleComment [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//----------------------------------------------------------------------------------------------------------------------

static GALGAS_object functionWithGenericHeader_llvmTitleComment (C_Compiler * inCompiler,
                                                                 const cObjectArray & inEffectiveParameterArray,
                                                                 const GALGAS_location & /* inErrorLocation */
                                                                 COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_llvmTitleComment (operand0,
                                    inCompiler
                                    COMMA_THERE).getter_object (THERE) ;
}

//----------------------------------------------------------------------------------------------------------------------

C_galgas_function_descriptor functionDescriptor_llvmTitleComment ("llvmTitleComment",
                                                                  functionWithGenericHeader_llvmTitleComment,
                                                                  & kTypeDescriptor_GALGAS_string,
                                                                  1,
                                                                  functionArgs_llvmTitleComment) ;

//----------------------------------------------------------------------------------------------------------------------
//
//Once function 'asSeparatorLine'
//
//----------------------------------------------------------------------------------------------------------------------

static GALGAS_string onceFunction_asSeparatorLine (C_Compiler * inCompiler
                                                   COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_result ; // Returned variable
  result_result = GALGAS_string ("@-------------------------------------------------------------------------") ;
  result_result.plusAssign_operation(GALGAS_string ("---------------------------------------------*\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 72)) ;
//---
  return result_result ;
}



//----------------------------------------------------------------------------------------------------------------------
//  Function implementation                                                                      
//----------------------------------------------------------------------------------------------------------------------

static bool gOnceFunctionResultAvailable_asSeparatorLine = false ;
static GALGAS_string gOnceFunctionResult_asSeparatorLine ;

//----------------------------------------------------------------------------------------------------------------------

GALGAS_string function_asSeparatorLine (class C_Compiler * inCompiler
              COMMA_LOCATION_ARGS) {
  if (! gOnceFunctionResultAvailable_asSeparatorLine) {
    gOnceFunctionResult_asSeparatorLine = onceFunction_asSeparatorLine (inCompiler COMMA_THERE) ;
    gOnceFunctionResultAvailable_asSeparatorLine = true ;
  }
  return gOnceFunctionResult_asSeparatorLine ;
}

//----------------------------------------------------------------------------------------------------------------------

static void releaseOnceFunctionResult_asSeparatorLine (void) {
  gOnceFunctionResult_asSeparatorLine.drop () ;
}

//----------------------------------------------------------------------------------------------------------------------

C_PrologueEpilogue gEpilogueForOnceFunction_asSeparatorLine (NULL,
                                                             releaseOnceFunctionResult_asSeparatorLine) ;

//----------------------------------------------------------------------------------------------------------------------
//  Function introspection                                                                       
//----------------------------------------------------------------------------------------------------------------------

static const C_galgas_type_descriptor * functionArgs_asSeparatorLine [1] = {
  NULL
} ;

//----------------------------------------------------------------------------------------------------------------------

static GALGAS_object functionWithGenericHeader_asSeparatorLine (C_Compiler * inCompiler,
                                                                const cObjectArray & /* inEffectiveParameterArray */,
                                                                const GALGAS_location & /* inErrorLocation */
                                                                COMMA_LOCATION_ARGS) {
  return function_asSeparatorLine (inCompiler COMMA_THERE).getter_object (THERE) ;
}

//----------------------------------------------------------------------------------------------------------------------

C_galgas_function_descriptor functionDescriptor_asSeparatorLine ("asSeparatorLine",
                                                                 functionWithGenericHeader_asSeparatorLine,
                                                                 & kTypeDescriptor_GALGAS_string,
                                                                 0,
                                                                 functionArgs_asSeparatorLine) ;

//----------------------------------------------------------------------------------------------------------------------
//
//Function 'asTitleComment'
//
//----------------------------------------------------------------------------------------------------------------------

GALGAS_string function_asTitleComment (const GALGAS_string & constinArgument_inTitle,
                                       C_Compiler * inCompiler
                                       COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_string result_outTitle ; // Returned variable
  result_outTitle = function_asSeparatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 78)) ;
  result_outTitle.plusAssign_operation(GALGAS_string ("@    ").add_operation (constinArgument_inTitle.getter_stringByRightPadding (GALGAS_uint (uint32_t (114U)), GALGAS_char (TO_UNICODE (32)) COMMA_SOURCE_FILE ("code-generation.galgas", 79)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 79)).add_operation (GALGAS_string ("*\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 79)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 79)) ;
  result_outTitle.plusAssign_operation(function_asSeparatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 80)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 80)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 80)) ;
//---
  return result_outTitle ;
}


//----------------------------------------------------------------------------------------------------------------------
//  Function introspection                                                                       
//----------------------------------------------------------------------------------------------------------------------

static const C_galgas_type_descriptor * functionArgs_asTitleComment [2] = {
  & kTypeDescriptor_GALGAS_string,
  NULL
} ;

//----------------------------------------------------------------------------------------------------------------------

static GALGAS_object functionWithGenericHeader_asTitleComment (C_Compiler * inCompiler,
                                                               const cObjectArray & inEffectiveParameterArray,
                                                               const GALGAS_location & /* inErrorLocation */
                                                               COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  return function_asTitleComment (operand0,
                                  inCompiler
                                  COMMA_THERE).getter_object (THERE) ;
}

//----------------------------------------------------------------------------------------------------------------------

C_galgas_function_descriptor functionDescriptor_asTitleComment ("asTitleComment",
                                                                functionWithGenericHeader_asTitleComment,
                                                                & kTypeDescriptor_GALGAS_string,
                                                                1,
                                                                functionArgs_asTitleComment) ;

//----------------------------------------------------------------------------------------------------------------------
//
//Routine 'codeGeneration'
//
//----------------------------------------------------------------------------------------------------------------------

void routine_codeGeneration (const GALGAS_string constinArgument_inCurrentDirectory,
                             const GALGAS_string constinArgument_inSourceFileName,
                             const GALGAS_location constinArgument_inEndOfSourceFileLocation,
                             const GALGAS_intermediateCodeStruct constinArgument_inIntermediateCodeStruct,
                             const GALGAS_userLLVMTypeDefinitionListIR constinArgument_inUserLLVMTypeDefinitionListIR,
                             const GALGAS_lstring constinArgument_inTargetName,
                             const GALGAS_omnibusType constinArgument_inPanicCodeType,
                             const GALGAS_omnibusType constinArgument_inPanicLineType,
                             const GALGAS_availableInterruptMap constinArgument_inAvailableInterruptMap,
                             const GALGAS_staticListInitializationMap constinArgument_inStaticListValueMap,
                             const GALGAS_targetParameters constinArgument_inTargetParameters,
                             C_Compiler * inCompiler
                             COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_timer var_generationTime_4522 = GALGAS_timer::constructor_start (SOURCE_FILE ("code-generation.galgas", 98)) ;
  GALGAS_string var_homeDir_4546 = GALGAS_string::constructor_homeDirectory (SOURCE_FILE ("code-generation.galgas", 99)).add_operation (GALGAS_string ("/omnibus-products/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 99)) ;
  GALGAS_string temp_0 ;
  const enumGalgasBool test_1 = GALGAS_bool (gOption_omnibus_5F_options_noPanicGeneration.readProperty_value ()).boolEnum () ;
  if (kBoolTrue == test_1) {
    temp_0 = GALGAS_string ("no-panic") ;
  }else if (kBoolFalse == test_1) {
    temp_0 = GALGAS_string::makeEmptyString () ;
  }
  GALGAS_string var_productDirectory_4665 = var_homeDir_4546.add_operation (temp_0, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 101)).add_operation (constinArgument_inSourceFileName.getter_stringByDeletingPathExtension (SOURCE_FILE ("code-generation.galgas", 103)).getter_stringByReplacingStringByString (GALGAS_string ("/"), GALGAS_string ("+"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 103)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 102)) ;
  GALGAS_string var_sourceDirectory_4882 = var_productDirectory_4665.add_operation (GALGAS_string ("/sources"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 104)) ;
  var_sourceDirectory_4882.method_makeDirectory (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 105)) ;
  {
  routine_generateTarget (constinArgument_inCurrentDirectory, var_productDirectory_4665, constinArgument_inTargetName, constinArgument_inIntermediateCodeStruct.readProperty_mTargetParameters (), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 107)) ;
  }
  {
  routine_generateCodeFiles (constinArgument_inCurrentDirectory, var_productDirectory_4665, constinArgument_inIntermediateCodeStruct, constinArgument_inUserLLVMTypeDefinitionListIR, constinArgument_inTargetName, constinArgument_inPanicCodeType, constinArgument_inPanicLineType, constinArgument_inAvailableInterruptMap, constinArgument_inStaticListValueMap, constinArgument_inTargetParameters, inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 114)) ;
  }
  enumGalgasBool test_2 = kBoolTrue ;
  if (kBoolTrue == test_2) {
    test_2 = GALGAS_bool (gOption_omnibus_5F_options_printPasses.readProperty_value ()).boolEnum () ;
    if (kBoolTrue == test_2) {
      inCompiler->printMessage (GALGAS_string ("** Code generation: ").add_operation (var_generationTime_4522.getter_string (SOURCE_FILE ("code-generation.galgas", 127)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 127)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 127))  COMMA_SOURCE_FILE ("code-generation.galgas", 127)) ;
    }
  }
  enumGalgasBool test_3 = kBoolTrue ;
  if (kBoolTrue == test_3) {
    test_3 = GALGAS_bool (kIsEqual, GALGAS_uint::constructor_errorCount (SOURCE_FILE ("code-generation.galgas", 130)).objectCompare (GALGAS_uint (uint32_t (0U)))).boolEnum () ;
    if (kBoolTrue == test_3) {
      GALGAS_timer var_scriptTime_5883 = GALGAS_timer::constructor_start (SOURCE_FILE ("code-generation.galgas", 131)) ;
      GALGAS_string temp_4 ;
      const enumGalgasBool test_5 = GALGAS_bool (gOption_omnibus_5F_option_5F_not_5F_appearing_5F_in_5F_cocoa_performFlashing.readProperty_value ()).boolEnum () ;
      if (kBoolTrue == test_5) {
        temp_4 = GALGAS_string ("run") ;
      }else if (kBoolFalse == test_5) {
        temp_4 = GALGAS_string ("build") ;
      }
      GALGAS_string var_script_5908 = temp_4 ;
      GALGAS_string var_fullScript_6029 = GALGAS_string ("python ").add_operation (var_productDirectory_4665, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 133)).add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 133)).add_operation (var_script_5908, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 133)).add_operation (GALGAS_string (".py"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 133)) ;
      GALGAS_sint var_result_6104 = var_fullScript_6029.getter_system (SOURCE_FILE ("code-generation.galgas", 134)) ;
      enumGalgasBool test_6 = kBoolTrue ;
      if (kBoolTrue == test_6) {
        test_6 = GALGAS_bool (kIsNotEqual, var_result_6104.objectCompare (GALGAS_sint (int32_t (0L)))).boolEnum () ;
        if (kBoolTrue == test_6) {
          TC_Array <C_FixItDescription> fixItArray7 ;
          inCompiler->emitSemanticError (constinArgument_inEndOfSourceFileLocation, GALGAS_string ("error during LLVM compilation or flashing"), fixItArray7  COMMA_SOURCE_FILE ("code-generation.galgas", 136)) ;
        }
      }
      enumGalgasBool test_8 = kBoolTrue ;
      if (kBoolTrue == test_8) {
        test_8 = GALGAS_bool (gOption_omnibus_5F_options_printPasses.readProperty_value ()).boolEnum () ;
        if (kBoolTrue == test_8) {
          inCompiler->printMessage (GALGAS_string ("** Compilation script: ").add_operation (var_scriptTime_5883.getter_string (SOURCE_FILE ("code-generation.galgas", 139)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 139)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 139))  COMMA_SOURCE_FILE ("code-generation.galgas", 139)) ;
        }
      }
    }
  }
}


//----------------------------------------------------------------------------------------------------------------------
//
//Routine 'generateCodeFiles'
//
//----------------------------------------------------------------------------------------------------------------------

void routine_generateCodeFiles (const GALGAS_string constinArgument_inCurrentDirectory,
                                const GALGAS_string constinArgument_inProductDirectory,
                                const GALGAS_intermediateCodeStruct constinArgument_inIntermediateCodeStruct,
                                const GALGAS_userLLVMTypeDefinitionListIR constinArgument_inUserLLVMTypeDefinitionListIR,
                                const GALGAS_lstring constinArgument_inTargetName,
                                const GALGAS_omnibusType constinArgument_inPanicCodeType,
                                const GALGAS_omnibusType constinArgument_inPanicLineType,
                                const GALGAS_availableInterruptMap constinArgument_inAvailableInterruptMap,
                                const GALGAS_staticListInitializationMap constinArgument_inStaticListValueMap,
                                const GALGAS_targetParameters constinArgument_inTargetParameters,
                                C_Compiler * inCompiler
                                COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_generationAdds var_generationAdds_7565 = GALGAS_generationAdds::constructor_default (SOURCE_FILE ("code-generation.galgas", 168)) ;
  var_generationAdds_7565.setter_setMStaticEntityMap (constinArgument_inIntermediateCodeStruct.readProperty_mStaticEntityMap () COMMA_SOURCE_FILE ("code-generation.galgas", 169)) ;
  GALGAS_generationContext var_generationContext_7697 = GALGAS_generationContext::constructor_new (constinArgument_inPanicCodeType, constinArgument_inPanicLineType, constinArgument_inTargetParameters.readProperty_mNopInstructionStringInLLVM ().readProperty_string (), constinArgument_inIntermediateCodeStruct.readProperty_mGlobalTaskVariableList (), constinArgument_inAvailableInterruptMap  COMMA_SOURCE_FILE ("code-generation.galgas", 170)) ;
  GALGAS_string var_sourceDirectory_7916 = constinArgument_inProductDirectory.add_operation (GALGAS_string ("/sources"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 177)) ;
  enumGalgasBool test_0 = kBoolTrue ;
  if (kBoolTrue == test_0) {
    test_0 = constinArgument_inTargetParameters.readProperty_mHandleDynamicArray ().boolEnum () ;
    if (kBoolTrue == test_0) {
      var_generationAdds_7565.mProperty_mExternFunctionDeclarationSet.addAssign_operation (GALGAS_string ("void @arc.retain (%ptrtype %inPtr)")  COMMA_SOURCE_FILE ("code-generation.galgas", 180)) ;
      var_generationAdds_7565.mProperty_mExternFunctionDeclarationSet.addAssign_operation (GALGAS_string ("void @arc.release (%ptrtype %inPtr)")  COMMA_SOURCE_FILE ("code-generation.galgas", 181)) ;
      var_generationAdds_7565.mProperty_mExternFunctionDeclarationSet.addAssign_operation (GALGAS_string ("%ptrtype @arc.insulate (%ptrtype %inPtr)")  COMMA_SOURCE_FILE ("code-generation.galgas", 182)) ;
      GALGAS_string var_insertFunction_8376 = GALGAS_string ("%ptrtype @arc.insert.at.index ").add_operation (GALGAS_string ("(%ptrtype %inPointer, i32 %inIndex, i32 %inElementSize, %ptrtype* %outElementPtr)"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 183)) ;
      var_generationAdds_7565.mProperty_mExternFunctionDeclarationSet.addAssign_operation (var_insertFunction_8376  COMMA_SOURCE_FILE ("code-generation.galgas", 185)) ;
      var_generationAdds_7565.mProperty_mExternFunctionDeclarationSet.addAssign_operation (GALGAS_string ("i32 @arc.length (%ptrtype %inPointer)")  COMMA_SOURCE_FILE ("code-generation.galgas", 186)) ;
    }
  }
  GALGAS_string var_asCode_8775 = function_asTitleComment (GALGAS_string ("Target specific code"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 189)) ;
  GALGAS_string var_asFileContents_8839 = GALGAS_string::makeEmptyString () ;
  cEnumerator_lstringlist enumerator_8864 (constinArgument_inTargetParameters.readProperty_m_5F_S_5F_definitionFiles (), kENUMERATION_UP) ;
  while (enumerator_8864.hasCurrentObject ()) {
    var_asFileContents_8839.plusAssign_operation(function_getTargetTextFile (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string ().add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 194)).add_operation (enumerator_8864.current_mValue (HERE).readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 194)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 192)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 192)) ;
    enumerator_8864.gotoNextObject () ;
  }
  GALGAS_string var_x_9062 = var_asFileContents_8839.getter_stringByReplacingStringByString (GALGAS_string ("!FUNC!"), function_llvmNameForFunction (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 197)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 197)) ;
  var_asCode_8775.plusAssign_operation(var_x_9062.getter_stringByReplacingStringByString (GALGAS_string ("!ISR!"), function_llvmNameForSectionInterrupt (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 198)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 198)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 198)) ;
  var_asCode_8775.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 199)) ;
  GALGAS_string var_llvmCode_9344 = function_llvmTitleComment (GALGAS_string ("Target specific code"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 201)) ;
  GALGAS_string var_targetLLVMcode_9410 = GALGAS_string::makeEmptyString () ;
  cEnumerator_lstringlist enumerator_9435 (constinArgument_inTargetParameters.readProperty_m_5F_LL_5F_definitionFiles (), kENUMERATION_UP) ;
  while (enumerator_9435.hasCurrentObject ()) {
    var_targetLLVMcode_9410.plusAssign_operation(function_getTargetTextFile (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string ().add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 206)).add_operation (enumerator_9435.current_mValue (HERE).readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 206)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 204)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 204)) ;
    enumerator_9435.gotoNextObject () ;
  }
  var_llvmCode_9344.plusAssign_operation(var_targetLLVMcode_9410.getter_stringByReplacingStringByString (GALGAS_string ("!FUNC!"), function_llvmNameForFunction (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 209)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 209)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 209)) ;
  var_llvmCode_9344.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 210)) ;
  {
  routine_declareLLVMTypes (constinArgument_inUserLLVMTypeDefinitionListIR, var_llvmCode_9344, inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 212)) ;
  }
  cEnumerator_driverListIR enumerator_9974 (constinArgument_inIntermediateCodeStruct.readProperty_mDriverList (), kENUMERATION_UP) ;
  const bool bool_1 = true ;
  if (enumerator_9974.hasCurrentObject () && bool_1) {
    var_llvmCode_9344.plusAssign_operation(function_llvmTitleComment (GALGAS_string ("Driver variable definitions"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 215)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 215)) ;
    while (enumerator_9974.hasCurrentObject () && bool_1) {
      extensionMethod_generateLLVMDriverVariableDefinition (enumerator_9974.current (HERE), var_llvmCode_9344, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 216)) ;
      enumerator_9974.gotoNextObject () ;
    }
    var_llvmCode_9344.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 217)) ;
  }
  extensionMethod_generateLLVMcode (constinArgument_inIntermediateCodeStruct.readProperty_mControlRegisterGroupArrayList (), var_llvmCode_9344, constinArgument_inTargetParameters.readProperty_mPointerSize (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 220)) ;
  cEnumerator_globalSyncInstanceMapIR enumerator_10478 (constinArgument_inIntermediateCodeStruct.readProperty_mGlobalSyncInstanceMap (), kENUMERATION_UP) ;
  const bool bool_2 = true ;
  if (enumerator_10478.hasCurrentObject () && bool_2) {
    var_llvmCode_9344.plusAssign_operation(function_llvmTitleComment (GALGAS_string ("Global synchronization tool instances"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 223)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 223)) ;
    while (enumerator_10478.hasCurrentObject () && bool_2) {
      extensionMethod_generateLLVM (enumerator_10478.current (HERE), var_llvmCode_9344, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 224)) ;
      enumerator_10478.gotoNextObject () ;
    }
    var_llvmCode_9344.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 225)) ;
  }
  extensionMethod_generateLLVMForStaticLists (constinArgument_inStaticListValueMap, constinArgument_inIntermediateCodeStruct.readProperty_mStaticArrayMapForIntermediate (), var_llvmCode_9344, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 228)) ;
  extensionMethod_generateLLVMDriverCode (constinArgument_inIntermediateCodeStruct.readProperty_mDriverList (), var_llvmCode_9344, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 230)) ;
  extensionMethod_llvmRoutineGeneration (constinArgument_inIntermediateCodeStruct.readProperty_mRoutineListIR (), var_llvmCode_9344, var_generationContext_7697, var_generationAdds_7565, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 232)) ;
  GALGAS_string var_undefinedInterruptString_11234 = function_getTargetTextFile (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string ().add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 240)).add_operation (constinArgument_inTargetParameters.readProperty_mUndefinedInterruptHandler ().readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 240)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 238)) ;
  GALGAS_string var_XTRInterruptHandlerString_11411 = function_getTargetTextFile (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string ().add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 244)).add_operation (constinArgument_inTargetParameters.readProperty_mXtrInterruptHandler ().readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 244)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 242)) ;
  extensionMethod_interruptCodeGeneration (constinArgument_inIntermediateCodeStruct.readProperty_mInterruptMapIR (), var_llvmCode_9344, var_asCode_8775, var_undefinedInterruptString_11234, var_XTRInterruptHandlerString_11411, var_generationContext_7697, var_generationAdds_7565, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 246)) ;
  extensionMethod_llvmPrototypeGeneration (constinArgument_inIntermediateCodeStruct.readProperty_mExternProcedureMapIR (), var_llvmCode_9344, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 255)) ;
  GALGAS_primitiveAndServiceIRlist var_primitiveAndServiceList_11959 = GALGAS_primitiveAndServiceIRlist::constructor_emptyList (SOURCE_FILE ("code-generation.galgas", 256)) ;
  enumGalgasBool test_3 = kBoolTrue ;
  if (kBoolTrue == test_3) {
    test_3 = var_generationAdds_7565.readProperty_mUsesGuards ().boolEnum () ;
    if (kBoolTrue == test_3) {
      GALGAS_string var_waitForGuardChange_12084 = function_waitForGuardChangeFunctionName (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 259)) ;
      var_primitiveAndServiceList_11959.addAssign_operation (function_llvmNameForServiceCall (var_waitForGuardChange_12084, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 261)), function_llvmNameForServiceImplementation (var_waitForGuardChange_12084, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 262)), GALGAS_bool (true)  COMMA_SOURCE_FILE ("code-generation.galgas", 260)) ;
      var_generationAdds_7565.mProperty_mExternFunctionDeclarationSet.addAssign_operation (GALGAS_string ("i1 @").add_operation (function_llvmNameForServiceCall (var_waitForGuardChange_12084, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 265)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 265)).add_operation (GALGAS_string (" ()"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 265))  COMMA_SOURCE_FILE ("code-generation.galgas", 264)) ;
    }
  }
  GALGAS_sectionIRlist var_sectionIRlist_12527 = GALGAS_sectionIRlist::constructor_emptyList (SOURCE_FILE ("code-generation.galgas", 268)) ;
  cEnumerator_routineListIR enumerator_12589 (constinArgument_inIntermediateCodeStruct.readProperty_mRoutineListIR (), kENUMERATION_UP) ;
  while (enumerator_12589.hasCurrentObject ()) {
    callExtensionMethod_svcDeclarationGeneration ((cPtr_abstractRoutineIR *) enumerator_12589.current (HERE).readProperty_mRoutine ().ptr (), var_primitiveAndServiceList_11959, var_sectionIRlist_12527, var_generationAdds_7565, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 270)) ;
    enumerator_12589.gotoNextObject () ;
  }
  extensionMethod_generateCode (constinArgument_inIntermediateCodeStruct.readProperty_mTaskMapIR (), var_llvmCode_9344, var_generationContext_7697, var_generationAdds_7565, var_primitiveAndServiceList_11959, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 277)) ;
  {
  routine_generatePrimitiveAndServiceDispatcher (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string (), var_asCode_8775, var_primitiveAndServiceList_11959, constinArgument_inTargetParameters, inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 284)) ;
  }
  enumGalgasBool test_4 = kBoolTrue ;
  if (kBoolTrue == test_4) {
    test_4 = GALGAS_bool (gOption_omnibus_5F_options_noPanicGeneration.readProperty_value ()).operator_not (SOURCE_FILE ("code-generation.galgas", 292)).boolEnum () ;
    if (kBoolTrue == test_4) {
      {
      routine_generatePanicCode (var_llvmCode_9344, var_generationContext_7697, var_generationAdds_7565, inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 293)) ;
      }
    }
  }
  enumGalgasBool test_5 = kBoolTrue ;
  if (kBoolTrue == test_5) {
    test_5 = var_generationAdds_7565.readProperty_mNeedsDynamicMemoryAllocation ().boolEnum () ;
    if (kBoolTrue == test_5) {
      var_sectionIRlist_12527.addAssign_operation (function_llvmNameForSectionCall (function_memoryAllocSectionName (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 302)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 302)), function_llvmNameForSectionImplementation (function_memoryAllocSectionName (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 303)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 303)), GALGAS_bool (true)  COMMA_SOURCE_FILE ("code-generation.galgas", 301)) ;
      var_sectionIRlist_12527.addAssign_operation (function_llvmNameForSectionCall (function_memoryFreeSectionName (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 306)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 306)), function_llvmNameForSectionImplementation (function_memoryFreeSectionName (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 307)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 307)), GALGAS_bool (true)  COMMA_SOURCE_FILE ("code-generation.galgas", 305)) ;
    }
  }
  {
  routine_generateSectionDispatcher (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string (), constinArgument_inTargetParameters, var_asCode_8775, var_sectionIRlist_12527, inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 310)) ;
  }
  var_llvmCode_9344.plusAssign_operation(function_llvmTitleComment (GALGAS_string ("LLVM extern functions"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 318)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 318)) ;
  cEnumerator_stringset enumerator_14212 (var_generationAdds_7565.readProperty_mExternFunctionDeclarationSet (), kENUMERATION_UP) ;
  while (enumerator_14212.hasCurrentObject ()) {
    var_llvmCode_9344.plusAssign_operation(GALGAS_string ("declare ").add_operation (enumerator_14212.current_key (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 320)).add_operation (GALGAS_string ("\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 320)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 320)) ;
    enumerator_14212.gotoNextObject () ;
  }
  var_llvmCode_9344.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 322)) ;
  enumGalgasBool test_6 = kBoolTrue ;
  if (kBoolTrue == test_6) {
    test_6 = GALGAS_bool (kIsStrictSup, var_generationAdds_7565.readProperty_mStaticEntityMap ().readProperty_mStaticStringMap ().getter_count (SOURCE_FILE ("code-generation.galgas", 324)).objectCompare (GALGAS_uint (uint32_t (0U)))).boolEnum () ;
    if (kBoolTrue == test_6) {
      var_llvmCode_9344.plusAssign_operation(function_llvmTitleComment (GALGAS_string ("Static strings"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 325)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 325)) ;
      cEnumerator_staticStringMap enumerator_14530 (var_generationAdds_7565.readProperty_mStaticEntityMap ().readProperty_mStaticStringMap (), kENUMERATION_UP) ;
      while (enumerator_14530.hasCurrentObject ()) {
        GALGAS_string var_lgStr_14602 = enumerator_14530.current_lkey (HERE).readProperty_string ().getter_utf_38_Length (SOURCE_FILE ("code-generation.galgas", 327)).add_operation (GALGAS_uint (uint32_t (1U)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 327)).getter_string (SOURCE_FILE ("code-generation.galgas", 327)) ;
        var_llvmCode_9344.plusAssign_operation(function_literalCharacterArrayName (enumerator_14530.current_mIndex (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 328)).add_operation (GALGAS_string (" = private unnamed_addr constant ["), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 328)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 328)) ;
        var_llvmCode_9344.plusAssign_operation(var_lgStr_14602.add_operation (GALGAS_string (" x i8] c\""), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 329)).add_operation (enumerator_14530.current_lkey (HERE).readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 329)).add_operation (GALGAS_string ("\\00\", align 1\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 329)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 329)) ;
        var_llvmCode_9344.plusAssign_operation(function_literalStringName (enumerator_14530.current_mIndex (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 330)).add_operation (GALGAS_string (" = private constant i8* getelementptr inbounds (["), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 330)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 330)) ;
        var_llvmCode_9344.plusAssign_operation(var_lgStr_14602.add_operation (GALGAS_string (" x i8], ["), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 331)).add_operation (var_lgStr_14602, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 331)).add_operation (GALGAS_string (" x i8]* "), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 331)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 331)) ;
        var_llvmCode_9344.plusAssign_operation(function_literalCharacterArrayName (enumerator_14530.current_mIndex (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 332)).add_operation (GALGAS_string (", i32 0, i32 0), align 4\n\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 332)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 332)) ;
        enumerator_14530.gotoNextObject () ;
      }
    }
  }
  enumGalgasBool test_7 = kBoolTrue ;
  if (kBoolTrue == test_7) {
    test_7 = GALGAS_bool (kIsStrictSup, var_generationAdds_7565.readProperty_mStaticEntityMap ().readProperty_mGlobalStructuredConstantList ().getter_length (SOURCE_FILE ("code-generation.galgas", 336)).objectCompare (GALGAS_uint (uint32_t (0U)))).boolEnum () ;
    if (kBoolTrue == test_7) {
      var_llvmCode_9344.plusAssign_operation(function_llvmTitleComment (GALGAS_string ("Global structured constants"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 337)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 337)) ;
      cEnumerator_globalStructuredConstantList enumerator_15322 (var_generationAdds_7565.readProperty_mStaticEntityMap ().readProperty_mGlobalStructuredConstantList (), kENUMERATION_UP) ;
      GALGAS_uint index_15300 ((uint32_t) 0) ;
      while (enumerator_15322.hasCurrentObject ()) {
        var_llvmCode_9344.plusAssign_operation(GALGAS_string ("@gconst.").add_operation (index_15300.getter_string (SOURCE_FILE ("code-generation.galgas", 339)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 339)).add_operation (GALGAS_string (" = private unnamed_addr constant "), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 339)).add_operation (callExtensionGetter_llvmTypeName ((const cPtr_omnibusType *) enumerator_15322.current_mType (HERE).ptr (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 339)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 339)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 339)) ;
        var_llvmCode_9344.plusAssign_operation(GALGAS_string (" ["), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 340)) ;
        cEnumerator_operandIRList enumerator_15536 (enumerator_15322.current_mOperandIRList (HERE), kENUMERATION_UP) ;
        while (enumerator_15536.hasCurrentObject ()) {
          var_llvmCode_9344.plusAssign_operation(extensionGetter_llvmTypeName (enumerator_15536.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 342)).add_operation (GALGAS_string (" "), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 342)).add_operation (extensionGetter_llvmName (enumerator_15536.current_mOperand (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 342)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 342)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 342)) ;
          if (enumerator_15536.hasNextObject ()) {
            var_llvmCode_9344.plusAssign_operation(GALGAS_string (", "), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 343)) ;
          }
          enumerator_15536.gotoNextObject () ;
        }
        var_llvmCode_9344.plusAssign_operation(GALGAS_string ("]\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 345)) ;
        enumerator_15322.gotoNextObject () ;
        index_15300.increment_operation (inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 338)) ;
      }
      var_llvmCode_9344.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 347)) ;
    }
  }
  var_llvmCode_9344.plusAssign_operation(function_llvmSeparatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 350)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 350)) ;
  GALGAS_bool joker_15902 ; // Joker input parameter
  var_llvmCode_9344.method_writeToFileWhenDifferentContents (var_sourceDirectory_7916.add_operation (GALGAS_string ("/src.ll"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 351)), joker_15902, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 351)) ;
  var_asCode_8775.plusAssign_operation(function_asSeparatorLine (inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 353)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 353)) ;
  GALGAS_bool joker_16073 ; // Joker input parameter
  var_asCode_8775.method_writeToFileWhenDifferentContents (var_sourceDirectory_7916.add_operation (GALGAS_string ("/src.s"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 354)), joker_16073, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 354)) ;
  GALGAS_string var_s_30__16181 = GALGAS_string::makeEmptyString () ;
  cEnumerator_lstringlist enumerator_16206 (constinArgument_inTargetParameters.readProperty_m_5F_C_5F_definitionFiles (), kENUMERATION_UP) ;
  while (enumerator_16206.hasCurrentObject ()) {
    var_s_30__16181.plusAssign_operation(function_getTargetTextFile (constinArgument_inCurrentDirectory, constinArgument_inTargetName.readProperty_string ().add_operation (GALGAS_string ("/"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 360)).add_operation (enumerator_16206.current_mValue (HERE).readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 360)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 358)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 358)) ;
    enumerator_16206.gotoNextObject () ;
  }
  GALGAS_string var_s_31__16393 = var_s_30__16181.getter_stringByReplacingStringByString (GALGAS_string ("!TASKCOUNT!"), constinArgument_inIntermediateCodeStruct.readProperty_mTaskMapIR ().getter_count (SOURCE_FILE ("code-generation.galgas", 363)).getter_string (SOURCE_FILE ("code-generation.galgas", 363)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 363)) ;
  GALGAS_string var_s_32__16510 = var_s_31__16393.getter_stringByReplacingStringByString (GALGAS_string ("!GUARDCOUNT!"), constinArgument_inIntermediateCodeStruct.readProperty_mMaxBranchOfOnInstructions ().getter_string (SOURCE_FILE ("code-generation.galgas", 364)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 364)) ;
  GALGAS_string var_s_33__16636 = var_s_32__16510.getter_stringByReplacingStringByString (GALGAS_string ("!FUNC!"), function_llvmNameForFunction (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 365)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 365)) ;
  GALGAS_string var_s_34__16721 = var_s_33__16636.getter_stringByReplacingStringByString (GALGAS_string ("!SERVICEIMPLEMENTATION!"), function_llvmNameForServiceImplementation (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 366)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 366)) ;
  GALGAS_string var_s_35__16836 = var_s_34__16721.getter_stringByReplacingStringByString (GALGAS_string ("!SERVICECALL!"), function_llvmNameForServiceCall (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 367)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 367)) ;
  GALGAS_string var_s_36__16931 = var_s_35__16836.getter_stringByReplacingStringByString (GALGAS_string ("!SECTIONIMPLEMENTATION!"), function_llvmNameForSectionImplementation (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 368)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 368)) ;
  GALGAS_string var_cppCode_17051 = var_s_36__16931.getter_stringByReplacingStringByString (GALGAS_string ("!SECTIONCALL!"), function_llvmNameForSectionCall (GALGAS_string::makeEmptyString (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 369)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 369)) ;
  GALGAS_bool joker_17466 ; // Joker input parameter
  var_cppCode_17051.method_writeToFileWhenDifferentContents (var_sourceDirectory_7916.add_operation (GALGAS_string ("/src.cpp"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 375)), joker_17466, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 375)) ;
  GALGAS_string var_json_17559 = GALGAS_string ("{\n") ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"system-stack-size\" : ").add_operation (constinArgument_inIntermediateCodeStruct.readProperty_mTargetParameters ().readProperty_mSystemStackSize ().readProperty_bigint ().getter_string (SOURCE_FILE ("code-generation.galgas", 379)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 379)).add_operation (GALGAS_string (",\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 379)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 379)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"stacked-register-size-on-user-stack\" : ").add_operation (constinArgument_inIntermediateCodeStruct.readProperty_mTargetParameters ().readProperty_mStackedUserRegisterOnInterruptByteSize ().readProperty_bigint ().getter_string (SOURCE_FILE ("code-generation.galgas", 380)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 380)).add_operation (GALGAS_string (",\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 381)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 380)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"service-stack-needs\" : ").add_operation (constinArgument_inIntermediateCodeStruct.readProperty_mTargetParameters ().readProperty_mServicePushedRegisterByteSize ().readProperty_bigint ().getter_string (SOURCE_FILE ("code-generation.galgas", 382)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 382)).add_operation (GALGAS_string (",\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 382)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 382)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"section-stack-needs\" : ").add_operation (constinArgument_inIntermediateCodeStruct.readProperty_mTargetParameters ().readProperty_mSectionPushedRegisterByteSize ().readProperty_bigint ().getter_string (SOURCE_FILE ("code-generation.galgas", 383)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 383)).add_operation (GALGAS_string (",\n"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 383)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 383)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"tasks\" : {"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 385)) ;
  cEnumerator_taskMapIR enumerator_18223 (constinArgument_inIntermediateCodeStruct.readProperty_mTaskMapIR (), kENUMERATION_UP) ;
  while (enumerator_18223.hasCurrentObject ()) {
    var_json_17559.plusAssign_operation(GALGAS_string ("\n    \"").add_operation (enumerator_18223.current (HERE).readProperty_lkey ().readProperty_string ().getter_assemblerRepresentation (SOURCE_FILE ("code-generation.galgas", 387)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 387)).add_operation (GALGAS_string ("\" : "), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 387)).add_operation (enumerator_18223.current (HERE).readProperty_mStackSize ().getter_string (SOURCE_FILE ("code-generation.galgas", 387)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 387)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 387)) ;
    if (enumerator_18223.hasNextObject ()) {
      var_json_17559.plusAssign_operation(GALGAS_string (","), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 388)) ;
    }
    enumerator_18223.gotoNextObject () ;
  }
  var_json_17559.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 390)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  },\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 391)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"services\" : ["), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 393)) ;
  cEnumerator_primitiveAndServiceIRlist enumerator_18457 (var_primitiveAndServiceList_11959, kENUMERATION_UP) ;
  const bool bool_8 = true ;
  if (enumerator_18457.hasCurrentObject () && bool_8) {
    while (enumerator_18457.hasCurrentObject () && bool_8) {
      var_json_17559.plusAssign_operation(GALGAS_string ("\n    \"").add_operation (enumerator_18457.current_mImplementationName (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 395)).add_operation (GALGAS_string ("\""), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 395)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 395)) ;
      enumerator_18457.gotoNextObject () ;
      if (enumerator_18457.hasCurrentObject () && bool_8) {
        var_json_17559.plusAssign_operation(GALGAS_string (","), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 396)) ;
      }
    }
    var_json_17559.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 397)) ;
  }
  var_json_17559.plusAssign_operation(GALGAS_string ("  ],\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 399)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"sections\" : ["), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 401)) ;
  cEnumerator_sectionIRlist enumerator_18690 (var_sectionIRlist_12527, kENUMERATION_UP) ;
  const bool bool_9 = true ;
  if (enumerator_18690.hasCurrentObject () && bool_9) {
    while (enumerator_18690.hasCurrentObject () && bool_9) {
      var_json_17559.plusAssign_operation(GALGAS_string ("\n    \"").add_operation (enumerator_18690.current (HERE).readProperty_mSectionImplementationName (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 403)).add_operation (GALGAS_string ("\""), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 403)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 403)) ;
      enumerator_18690.gotoNextObject () ;
      if (enumerator_18690.hasCurrentObject () && bool_9) {
        var_json_17559.plusAssign_operation(GALGAS_string (","), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 404)) ;
      }
    }
    var_json_17559.plusAssign_operation(GALGAS_string ("\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 405)) ;
  }
  var_json_17559.plusAssign_operation(GALGAS_string ("  ],\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 407)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("  \"isr\" : ["), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 409)) ;
  GALGAS_bool var_first_18879 = GALGAS_bool (true) ;
  cEnumerator_interruptMapIR enumerator_18916 (constinArgument_inIntermediateCodeStruct.readProperty_mInterruptMapIR (), kENUMERATION_UP) ;
  while (enumerator_18916.hasCurrentObject ()) {
    enumGalgasBool test_10 = kBoolTrue ;
    if (kBoolTrue == test_10) {
      test_10 = var_first_18879.boolEnum () ;
      if (kBoolTrue == test_10) {
        var_first_18879 = GALGAS_bool (false) ;
      }
    }
    if (kBoolFalse == test_10) {
      var_json_17559.plusAssign_operation(GALGAS_string (","), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 415)) ;
    }
    GALGAS_string temp_11 ;
    const enumGalgasBool test_12 = GALGAS_bool (kIsEqual, enumerator_18916.current_mMode (HERE).objectCompare (GALGAS_mode::constructor_serviceMode (SOURCE_FILE ("code-generation.galgas", 417)))).boolEnum () ;
    if (kBoolTrue == test_12) {
      temp_11 = function_llvmNameForServiceInterrupt (enumerator_18916.current_lkey (HERE), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 418)).readProperty_string () ;
    }else if (kBoolFalse == test_12) {
      temp_11 = function_llvmNameForSectionInterrupt (enumerator_18916.current_lkey (HERE).readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 420)) ;
    }
    GALGAS_string var_interruptImplementationName_19073 = temp_11 ;
    var_json_17559.plusAssign_operation(GALGAS_string ("\n    \"").add_operation (var_interruptImplementationName_19073, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 422)).add_operation (GALGAS_string ("\""), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 422)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 422)) ;
    enumerator_18916.gotoNextObject () ;
  }
  enumGalgasBool test_13 = kBoolTrue ;
  if (kBoolTrue == test_13) {
    test_13 = GALGAS_bool (gOption_omnibus_5F_options_noPanicGeneration.readProperty_value ()).operator_not (SOURCE_FILE ("code-generation.galgas", 424)).boolEnum () ;
    if (kBoolTrue == test_13) {
      cEnumerator_availableInterruptMap enumerator_19391 (constinArgument_inAvailableInterruptMap, kENUMERATION_UP) ;
      while (enumerator_19391.hasCurrentObject ()) {
        enumGalgasBool test_14 = kBoolTrue ;
        if (kBoolTrue == test_14) {
          test_14 = constinArgument_inIntermediateCodeStruct.readProperty_mInterruptMapIR ().getter_hasKey (enumerator_19391.current_lkey (HERE).readProperty_string () COMMA_SOURCE_FILE ("code-generation.galgas", 426)).operator_not (SOURCE_FILE ("code-generation.galgas", 426)).boolEnum () ;
          if (kBoolTrue == test_14) {
            switch (enumerator_19391.current_mInterruptionPanicCode (HERE).enumValue ()) {
            case GALGAS_interruptionPanicCode::kNotBuilt:
              break ;
            case GALGAS_interruptionPanicCode::kEnum_noCode:
              {
              }
              break ;
            case GALGAS_interruptionPanicCode::kEnum_code:
              {
                enumGalgasBool test_15 = kBoolTrue ;
                if (kBoolTrue == test_15) {
                  test_15 = var_first_18879.boolEnum () ;
                  if (kBoolTrue == test_15) {
                    var_first_18879 = GALGAS_bool (false) ;
                  }
                }
                if (kBoolFalse == test_15) {
                  var_json_17559.plusAssign_operation(GALGAS_string (","), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 433)) ;
                }
                var_json_17559.plusAssign_operation(GALGAS_string ("\n    \"").add_operation (function_llvmNameForSectionInterrupt (enumerator_19391.current_lkey (HERE).readProperty_string (), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 435)), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 435)).add_operation (GALGAS_string ("\""), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 435)), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 435)) ;
              }
              break ;
            }
          }
        }
        enumerator_19391.gotoNextObject () ;
      }
    }
  }
  var_json_17559.plusAssign_operation(GALGAS_string ("\n  ]\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 440)) ;
  var_json_17559.plusAssign_operation(GALGAS_string ("}\n"), inCompiler  COMMA_SOURCE_FILE ("code-generation.galgas", 442)) ;
  GALGAS_bool joker_19932 ; // Joker input parameter
  var_json_17559.method_writeToFileWhenDifferentContents (var_sourceDirectory_7916.add_operation (GALGAS_string ("/provided-stacks.json"), inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 443)), joker_19932, inCompiler COMMA_SOURCE_FILE ("code-generation.galgas", 443)) ;
}


//----------------------------------------------------------------------------------------------------------------------
//
//Filewrapper 'targetTemplates'
//
//----------------------------------------------------------------------------------------------------------------------

//--- File '/c-deadline-list-32-tasks.cpp'

const char * gWrapperFileContent_4_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//   D E A D L I N E    L I S T    M A N A G E M E N T\n//----------------------------------------------------------------------------------------------------------------------\n\n#if TASK_COUNT > 32\n  #error \"This type of list supports at most 32 tasks\"\n#endif\n\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct { unsigned mDeadlineList ; } DeadlineList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n//   FORWARD DECLARATION\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void kernel_makeTaskReady (TaskControlBlock * inTaskDescriptor) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n//   ENTER TASK IN DEADLINE LIST\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void deadlinelist_enterTask (DeadlineList & ioTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\nstatic inline void deadlinelist_enterTask (DeadlineList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned mask = 1 << runningTaskIndex ;\n  ioTaskList.mDeadlineList |= mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   REMOVE TASK FROM DEADLINE LIST\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void deadlinelist_removeTask (DeadlineList & ioTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\nstatic inline void deadlinelist_removeTask (DeadlineList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned mask = 1 << runningTaskIndex ;\n  ioTaskList.mDeadlineList &= ~ mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  TEST IF A DEADLINE LIST CONTAINS A TASK\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline bool deadlinelist_containsTask (const DeadlineList & inTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\nstatic inline bool deadlinelist_containsTask (const DeadlineList & inTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned mask = 1 << runningTaskIndex ;\n  return (inTaskList.mDeadlineList & mask) != 0 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   ITERATE OVER DEADLINE LIST\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef unsigned DeadlineListIterator ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline DeadlineListIterator deadlinelist_makeIterator (const DeadlineList & inList) __attribute__((always_inline)) ;\n\nstatic inline DeadlineListIterator deadlinelist_makeIterator (const DeadlineList & inList) {\n  return inList.mDeadlineList ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * deadlinelistIterator_nextTask (DeadlineListIterator & ioIterator) __attribute__((always_inline)) ;\n\nstatic inline TaskControlBlock * deadlinelistIterator_nextTask (DeadlineListIterator & ioIterator) {\n  TaskControlBlock * task = nullptr ;\n  if (ioIterator != 0) {\n    const unsigned taskIndex = __builtin_ctz (ioIterator) ;\n    const unsigned mask = 1 << taskIndex ;\n    ioIterator &= ~ mask ;\n    task = & gTaskDescriptorArray [taskIndex] ;\n  }\n  return task ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_4_targetTemplates (
  "c-deadline-list-32-tasks.cpp",
  "cpp",
  true, // Text file
  4340, // Text length
  gWrapperFileContent_4_targetTemplates
) ;

//--- File '/c-deadline-list-64-tasks.cpp'

const char * gWrapperFileContent_5_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//   D E A D L I N E    L I S T    M A N A G E M E N T\n//----------------------------------------------------------------------------------------------------------------------\n\n#if TASK_COUNT > 64\n  #error \"This type of list supports at most 64 tasks\"\n#endif\n\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct { unsigned long long mDeadlineList ; } DeadlineList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n// FORWARD DECLARATION\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void kernel_makeTaskReady (TaskControlBlock * inTaskDescriptor) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n//   ENTER TASK IN DEADLINE LIST\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void deadlinelist_enterTask (DeadlineList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned long long mask = 1ULL << runningTaskIndex ;\n  ioTaskList.mDeadlineList |= mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   REMOVE TASK FROM DEADLINE LIST\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void deadlinelist_removeTask (DeadlineList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned long long mask = 1ULL << runningTaskIndex ;\n  ioTaskList.mDeadlineList &= ~ mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  TEST IF A DEADLINE LIST CONTAINS A TASK\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline bool deadlinelist_containsTask (const DeadlineList & inTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline bool deadlinelist_containsTask (const DeadlineList & inTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned long long mask = 1ULL << runningTaskIndex ;\n  return (inTaskList.mDeadlineList & mask) != 0 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   ITERATE OVER DEADLINE LIST\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef unsigned long long DeadlineListIterator ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline DeadlineListIterator deadlinelist_makeIterator (const DeadlineList & inList) {\n  return inList.mDeadlineList ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * deadlinelistIterator_nextTask (DeadlineListIterator & ioIterator) {\n  TaskControlBlock * task = nullptr ;\n  if (ioIterator != 0ULL) {\n    const unsigned taskIndex = __builtin_ctzll (ioIterator) ;\n    const unsigned long long mask = 1ULL << taskIndex ;\n    ioIterator &= ~ mask ;\n    task = & gTaskDescriptorArray [taskIndex] ;\n\n  }\n  return task ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_5_targetTemplates (
  "c-deadline-list-64-tasks.cpp",
  "cpp",
  true, // Text file
  4017, // Text length
  gWrapperFileContent_5_targetTemplates
) ;

//--- File '/c-guard-code.cpp'

const char * gWrapperFileContent_3_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//  G U A R D S\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic DeadlineList gDeadlineWaitingInGuardTaskList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void removeTaskFromGuards (TaskControlBlock * inTask) {\n  guardDescriptor_removeAllGuards (inTask->mGuardDescriptor, inTask) ;\n  deadlinelist_removeTask (gDeadlineWaitingInGuardTaskList, inTask) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid acceptGuard (void) asm (\"accept.guard\") ;\n\nvoid acceptGuard (void) {\n  gRunningTaskControlBlockPtr->mGuardState = GUARD_EVALUATING_OR_OUTSIDE ;\n  removeTaskFromGuards (gRunningTaskControlBlockPtr) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_handleGuardedCommand (GuardList * ioGuardListPtr) asm (\"!FUNC!handleGuardedCommand\") ;\n\nvoid kernel_handleGuardedCommand (GuardList * ioGuardListPtr) {\n  if (gRunningTaskControlBlockPtr->mGuardState == GUARD_EVALUATING_OR_OUTSIDE) {\n    guardlist_enterTask (* (ioGuardListPtr), gRunningTaskControlBlockPtr) ;\n    guardDescriptor_appendGuard (gRunningTaskControlBlockPtr->mGuardDescriptor, ioGuardListPtr) ;\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid waitForGuardChange (void) asm (\"!SERVICECALL!guard.wait.for.change\") ;\n\nvoid kernel_waitForGuardChange (void) asm (\"!SERVICEIMPLEMENTATION!guard.wait.for.change\") ;\n\nvoid kernel_waitForGuardChange (void) {\n  gRunningTaskControlBlockPtr->mUserResult = gRunningTaskControlBlockPtr->mGuardState == GUARD_DID_CHANGE ;\n  if (gRunningTaskControlBlockPtr->mUserResult) { // GUARD_DID_CHANGE\n    gRunningTaskControlBlockPtr->mGuardState = GUARD_EVALUATING_OR_OUTSIDE ;\n  }else{ // GUARD_EVALUATING_OR_OUTSIDE\n    bool hasGuards = deadlinelist_containsTask (gDeadlineWaitingInGuardTaskList, gRunningTaskControlBlockPtr) ;\n    if (! hasGuards) {\n      hasGuards = gRunningTaskControlBlockPtr->mGuardDescriptor.mCount > 0 ;\n    }\n    if (hasGuards) {\n      gRunningTaskControlBlockPtr->mGuardState = GUARD_WAITING_FOR_CHANGE ;\n      kernel_makeNoTaskRunning () ;\n    }\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_guardDidChange (GuardList & ioGuardList) asm (\"!FUNC!notify.change.from.guard.list\") ;\n\nvoid kernel_guardDidChange (GuardList & ioGuardList) {\n  TaskControlBlock * task ;\n  while ((task = guardlist_removeFirstTask (ioGuardList))) {\n    removeTaskFromGuards (task) ;\n    if (task->mGuardState == GUARD_WAITING_FOR_CHANGE) {\n      task->mGuardState = GUARD_EVALUATING_OR_OUTSIDE ;\n      kernel_makeTaskReady (task) ;\n    }else if (task->mGuardState == GUARD_EVALUATING_OR_OUTSIDE) {\n      task->mGuardState = GUARD_DID_CHANGE ;\n    }else{ // GUARD_DID_CHANGE\n      // Nothing to do\n    }\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid handleGuardedWaitUntil (const unsigned inDeadline) asm (\"!FUNC!guard.handle.wait.until\") ;\n\nvoid handleGuardedWaitUntil (const unsigned inDeadline) {\n  if (gRunningTaskControlBlockPtr->mGuardState == GUARD_EVALUATING_OR_OUTSIDE) {\n    if (!deadlinelist_containsTask (gDeadlineWaitingInGuardTaskList, gRunningTaskControlBlockPtr)) {\n      deadlinelist_enterTask (gDeadlineWaitingInGuardTaskList, gRunningTaskControlBlockPtr) ;\n      gRunningTaskControlBlockPtr->mTaskDeadline = inDeadline ;\n    }else if (gRunningTaskControlBlockPtr->mTaskDeadline > inDeadline) {\n      gRunningTaskControlBlockPtr->mTaskDeadline = inDeadline ;\n    }\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid tickHandlerForGuardedWaitUntil (const unsigned inUptime)\nasm (\"!FUNC!notify.change.for.guarded.wait.until\") ;\n\nvoid tickHandlerForGuardedWaitUntil (const unsigned inUptime) {\n  DeadlineListIterator iterator = deadlinelist_makeIterator (gDeadlineWaitingInGuardTaskList) ;\n  TaskControlBlock * task ;\n  while ((task = deadlinelistIterator_nextTask (iterator))) {\n    if (inUptime >= task->mTaskDeadline) {\n      removeTaskFromGuards (task) ;\n      if (task->mGuardState == GUARD_WAITING_FOR_CHANGE) {\n        task->mGuardState = GUARD_EVALUATING_OR_OUTSIDE ;\n        kernel_makeTaskReady (task) ;\n      }else if (task->mGuardState == GUARD_EVALUATING_OR_OUTSIDE) {\n        task->mGuardState = GUARD_DID_CHANGE ;\n      }else{ // GUARD_DID_CHANGE\n        // Nothing to do\n      }\n    }\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_3_targetTemplates (
  "c-guard-code.cpp",
  "cpp",
  true, // Text file
  5043, // Text length
  gWrapperFileContent_3_targetTemplates
) ;

//--- File '/c-guard-list-32-tasks.cpp'

const char * gWrapperFileContent_10_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n// ENTER TASK IN LIST: inTask should be not null\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_enterTask (GuardList & ioTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_enterTask (GuardList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned mask = 1 << runningTaskIndex ;\n  ioTaskList.mGuardList |= mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  REMOVE FIRST TASK GUARD LIST: returns nullptr if list is empty\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * guardlist_removeFirstTask (GuardList & ioTaskList) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * guardlist_removeFirstTask (GuardList & ioTaskList) {\n  TaskControlBlock * result = nullptr ;\n  if (ioTaskList.mGuardList != 0) {\n    const unsigned taskIndex = __builtin_ctz (ioTaskList.mGuardList) ;\n    const unsigned mask = 1 << taskIndex ;\n    ioTaskList.mGuardList &= ~ mask ;\n    result = & gTaskDescriptorArray [taskIndex] ;\n  }\n  return result ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  REMOVE TASK FROM LIST: inTask should not be null\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_removeTask (GuardList & ioList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_removeTask (GuardList & ioList, TaskControlBlock * inTask) {\n  const unsigned mask = 1 << inTask->mTaskIndex ;\n  ioList.mGuardList &= ~ mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_10_targetTemplates (
  "c-guard-list-32-tasks.cpp",
  "cpp",
  true, // Text file
  2550, // Text length
  gWrapperFileContent_10_targetTemplates
) ;

//--- File '/c-guard-list-64-tasks.cpp'

const char * gWrapperFileContent_11_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n// ENTER TASK IN LIST: inTask should be not null\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_enterTask (GuardList & ioTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_enterTask (GuardList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned long long mask = 1ULL << runningTaskIndex ;\n  ioTaskList.mGuardList |= mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  REMOVE FIRST TASK GUARD LIST: returns nullptr if list is empty\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * guardlist_removeFirstTask (GuardList & ioTaskList) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * guardlist_removeFirstTask (GuardList & ioTaskList) {\n  TaskControlBlock * result = nullptr ;\n  if (ioTaskList.mGuardList != 0UL) {\n    const unsigned taskIndex = __builtin_ctzll (ioTaskList.mGuardList) ;\n    const unsigned long long mask = 1ULL << taskIndex ;\n    ioTaskList.mGuardList &= ~ mask ;\n    result = & gTaskDescriptorArray [taskIndex] ;\n  }\n  return result ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  REMOVE TASK FROM LIST: inTask should not be null\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_removeTask (GuardList & ioList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_removeTask (GuardList & ioList, TaskControlBlock * inTask) {\n  const unsigned long long mask = 1ULL << inTask->mTaskIndex ;\n  ioList.mGuardList &= ~ mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_11_targetTemplates (
  "c-guard-list-64-tasks.cpp",
  "cpp",
  true, // Text file
  2593, // Text length
  gWrapperFileContent_11_targetTemplates
) ;

//--- File '/c-guard-types-32-tasks.cpp'

const char * gWrapperFileContent_24_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct { unsigned mGuardList ; } GuardList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic const unsigned GUARD_COUNT = !GUARDCOUNT! ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct {\n  unsigned mCount ;\n  GuardList * mListArray [GUARD_COUNT] ;\n} GuardDescriptor ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstruct TaskControlBlock ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void guardDescriptor_appendGuard (GuardDescriptor & ioGuardDescriptor, GuardList * ioGuardListPtr) {\n  const unsigned guardCount = ioGuardDescriptor.mCount ;\n  ioGuardDescriptor.mListArray [guardCount] = ioGuardListPtr ;\n  ioGuardDescriptor.mCount = guardCount + 1 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_removeTask (GuardList & ioList, TaskControlBlock * inTask) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void guardDescriptor_removeAllGuards (GuardDescriptor & ioGuardDescriptor, TaskControlBlock * inTask) {\n  const unsigned guardCount = ioGuardDescriptor.mCount ;\n  for (unsigned i=0 ; i<guardCount ; i++) {\n    guardlist_removeTask (* (ioGuardDescriptor.mListArray [i]), inTask) ;\n  }\n  ioGuardDescriptor.mCount = 0 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_24_targetTemplates (
  "c-guard-types-32-tasks.cpp",
  "cpp",
  true, // Text file
  1901, // Text length
  gWrapperFileContent_24_targetTemplates
) ;

//--- File '/c-guard-types-64-tasks.cpp'

const char * gWrapperFileContent_31_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct { unsigned long long mGuardList ; } GuardList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic const unsigned GUARD_COUNT = !GUARDCOUNT! ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct {\n  unsigned mCount ;\n  GuardList * mListArray [GUARD_COUNT] ;\n} GuardDescriptor ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstruct TaskControlBlock ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void guardlist_removeTask (GuardList & ioList, TaskControlBlock * inTask) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void guardDescriptor_removeAllGuards (GuardDescriptor & ioGuardDescriptor, TaskControlBlock * inTask) {\n  const unsigned guardCount = ioGuardDescriptor.mCount ;\n  for (unsigned i=0 ; i<guardCount ; i++) {\n    guardlist_removeTask (* (ioGuardDescriptor.mListArray [i]), inTask) ;\n  }\n  ioGuardDescriptor.mCount = 0 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void guardDescriptor_appendGuard (GuardDescriptor & ioGuardDescriptor, GuardList * ioGuardListPtr) {\n  const unsigned guardCount = ioGuardDescriptor.mCount ;\n  ioGuardDescriptor.mListArray [guardCount] = ioGuardListPtr ;\n  ioGuardDescriptor.mCount = guardCount + 1 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_31_targetTemplates (
  "c-guard-types-64-tasks.cpp",
  "cpp",
  true, // Text file
  1911, // Text length
  gWrapperFileContent_31_targetTemplates
) ;

//--- File '/c-real-time-kernel-code.cpp'

const char * gWrapperFileContent_9_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//   S C H E D U L E R\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic TaskList gReadyTaskList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void kernel_makeNoTaskRunning (void) {\n  gRunningTaskControlBlockPtr = nullptr ; // No running task\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic void kernel_makeTaskReady (TaskControlBlock * inTaskControlBlockPtr) {\n  list_enterTask (gReadyTaskList, inTaskControlBlockPtr) ;\n  inTaskControlBlockPtr->mUserResult = 1 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_selectTaskToRun (void) asm (\"kernel_selectTaskToRun\") ;\n\nvoid kernel_selectTaskToRun (void) {\n  if (gRunningTaskControlBlockPtr != nullptr) {\n    list_enterTask (gReadyTaskList, gRunningTaskControlBlockPtr) ;\n  }\n  gRunningTaskControlBlockPtr = list_removeFirstTask (gReadyTaskList) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nbool userResult (void) asm (\"xtr.user.result\") ;\n\nbool userResult (void) {\n  return gRunningTaskControlBlockPtr->mUserResult ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   kernel_create_task\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_create_task (const unsigned inTaskIndex,\n                         const char * inTaskName,\n                         unsigned * inStackBufferAddress,\n                         unsigned inStackBufferSize,\n                         RoutineTaskType inTaskRoutine) asm (\"kernel_create_task\") ;\n\nvoid kernel_create_task (const unsigned inTaskIndex,\n                         const char * inTaskName,\n                         unsigned * inStackBufferAddress,\n                         unsigned inStackBufferSize,\n                         RoutineTaskType inTaskRoutine) {\n  TaskControlBlock * taskControlBlockPtr = & gTaskDescriptorArray [inTaskIndex] ;\n  taskControlBlockPtr->mTaskIndex = (unsigned char) inTaskIndex ;\n  taskControlBlockPtr->mTaskName = inTaskName ;\n//  taskControlBlockPtr->mTaskDeadline = 0 ; // statically initialized to 0\n//  taskControlBlockPtr->mGuardCount = 0 ; // statically initialized to 0\n//  taskControlBlockPtr->mHaveDeadlineGuard = false ; // statically initialized to 0\n//  taskControlBlockPtr->mUserResult = false ; // statically initialized to 0\n//  taskControlBlockPtr->mGuardState = GUARD_EVALUATING_OR_OUTSIDE ; // statically initialized to GUARD_EVALUATING_OR_OUTSIDE\n//  taskControlBlockPtr->mActivationCount = 0 ;  // statically initialized to 0\n//--- Store stack parameters\n  taskControlBlockPtr->mStackBufferAddress = inStackBufferAddress ;\n  taskControlBlockPtr->mStackBufferSize = inStackBufferSize ;\n//--- Initial free stack size\n  taskControlBlockPtr->mStackFreeSize = inStackBufferSize ;\n//--- Initialize Context\n  const bool hasFloatingPointContext = false ;\n  kernel_set_task_context (taskControlBlockPtr->mTaskContext,\n                           (unsigned) inStackBufferAddress,\n                           inStackBufferSize,\n                           inTaskRoutine,\n                           hasFloatingPointContext) ;\n//--- Make task ready\n  kernel_makeTaskReady (taskControlBlockPtr) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   D E A D L I N E    L I S T    M A N A G E M E N T\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic DeadlineList gDeadlineWaitingTaskList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void deadlinelist_enterRunningTask (const unsigned inDeadline) {\n  gRunningTaskControlBlockPtr->mTaskDeadline = inDeadline ;\n  deadlinelist_enterTask (gDeadlineWaitingTaskList, gRunningTaskControlBlockPtr) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void deadlinelist_makeTasksReadyFromCurrentDate (const unsigned inCurrentDate) {\n  DeadlineListIterator iterator = deadlinelist_makeIterator (gDeadlineWaitingTaskList) ;\n  TaskControlBlock * task ;\n  while ((task = deadlinelistIterator_nextTask (iterator))) {\n    if (inCurrentDate >= task->mTaskDeadline) {\n    //--- Remove task from deadline list\n      deadlinelist_removeTask (gDeadlineWaitingTaskList, task) ;\n   //--- Make task ready\n      kernel_makeTaskReady (task) ;\n    }\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  B L O C K I N G    R U N N I N G    T A S K\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid blockInList (TaskList & ioWaitingList) asm (\"!FUNC!blockInList\") ;\n\nvoid blockInList (TaskList & ioWaitingList) {\n//--- Insert in tool list\n  list_enterTask (ioWaitingList, gRunningTaskControlBlockPtr) ;\n//--- Block task\n  kernel_makeNoTaskRunning () ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid blockOnDeadline (const unsigned inDeadline) asm (\"!FUNC!blockOnDeadline\") ;\n\nvoid blockOnDeadline (const unsigned inDeadline) {\n//--- Insert in deadline list\n  deadlinelist_enterRunningTask (inDeadline) ;\n//--- Block task\n  kernel_makeNoTaskRunning () ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  M A K E    T A S K    R E A D Y\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid makeTaskReadyFromBlockingList (TaskList & ioWaitingList, bool & outFound) asm (\"!FUNC!makeTaskReady\") ;\n\nvoid makeTaskReadyFromBlockingList (TaskList & ioWaitingList, bool & outFound) {\n  TaskControlBlock * taskControlBlockPtr = list_removeFirstTask (ioWaitingList) ;\n  outFound = taskControlBlockPtr != nullptr ;\n  if (outFound) { //--- Make task ready\n    kernel_makeTaskReady (taskControlBlockPtr) ;\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid makeTasksReadyFromCurrentDate (const unsigned inCurrentDate) asm (\"!FUNC!makeTasksReadyFromCurrentDate\") ;\n\nvoid makeTasksReadyFromCurrentDate (const unsigned inCurrentDate) {\n  deadlinelist_makeTasksReadyFromCurrentDate (inCurrentDate) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  ACTIVATION\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_activate_task (const unsigned char inTaskIndex) asm (\"!SERVICEIMPLEMENTATION!xtr.activate.task\") ;\n\nvoid kernel_activate_task (const unsigned char inTaskIndex) {\n  TaskControlBlock * taskPtr = & gTaskDescriptorArray [inTaskIndex] ;\n  taskPtr->mActivationCount ++ ;\n  if (taskPtr->mActivationCount == 0) {\n    kernel_makeTaskReady (taskPtr) ;\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//   kernel_wait_for_activation\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_wait_for_activation (void) asm (\"!SERVICEIMPLEMENTATION!xtr.wait.for.activation\") ;\n\nvoid kernel_wait_for_activation (void) {\n  gRunningTaskControlBlockPtr->mActivationCount -- ;\n  if (gRunningTaskControlBlockPtr->mActivationCount < 0) {\n    kernel_makeNoTaskRunning () ;\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_9_targetTemplates (
  "c-real-time-kernel-code.cpp",
  "cpp",
  true, // Text file
  8345, // Text length
  gWrapperFileContent_9_targetTemplates
) ;

//--- File '/c-real-time-kernel-utilities.cpp'

const char * gWrapperFileContent_20_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//  G E T T I N G    F R E E    S T A C K    S I Z E\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned freeStackSize (void) asm (\"!FUNC!freeStackSize\") ;\n\nunsigned freeStackSize (void) {\n  return gRunningTaskControlBlockPtr->mStackFreeSize ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  N O T E    F R E E    S T A C K    S I Z E  (callable by task)\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid noteFreeStackSize (void) asm (\"!FUNC!noteFreeStackSize\") ;\n\nvoid noteFreeStackSize (void) {\n//--- Get stack pointer current value\n  unsigned stackPointer ; __asm__ (\"mov %0, sp\" : \"=r\" (stackPointer)) ;\n//--- Compute current free stack size\n  const unsigned currentFreeStack = stackPointer - (unsigned) gRunningTaskControlBlockPtr->mStackBufferAddress ;\n//--- If current free stack size lower than registered free stack size, assign new value\n  if (currentFreeStack < gRunningTaskControlBlockPtr->mStackFreeSize) {\n    gRunningTaskControlBlockPtr->mStackFreeSize = currentFreeStack ;\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  T A S K    C O U N T\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned taskCount (void) asm (\"!FUNC!taskCount\") ;\n\nunsigned taskCount (void) {\n  return !TASKCOUNT! ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  T A S K    G U A R D   S T A T E\n//----------------------------------------------------------------------------------------------------------------------\n\nGuardState taskGuardState (const unsigned inIndex) asm (\"!FUNC!taskGuardState\") ;\n\nGuardState taskGuardState (const unsigned inIndex) {\n  return gTaskDescriptorArray [inIndex].mGuardState ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  T A S K    N A M E\n//----------------------------------------------------------------------------------------------------------------------\n\nconst char * taskName (const unsigned inIndex) asm (\"!FUNC!taskName\") ;\n\nconst char * taskName (const unsigned inIndex) {\n  return gTaskDescriptorArray [inIndex].mTaskName ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  T A S K    F R E E   S T A S K    S I Z E\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned taskFreeStackSize (const unsigned inIndex) asm (\"!FUNC!taskFreeStackSize\") ;\n\nunsigned taskFreeStackSize (const unsigned inIndex) {\n  return gTaskDescriptorArray [inIndex].mStackFreeSize ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  T A S K    A L L O C A T E D   S T A S K    S I Z E\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned taskAllocatedStackSize (const unsigned inIndex) asm (\"!FUNC!taskAllocatedStackSize\") ;\n\nunsigned taskAllocatedStackSize (const unsigned inIndex) {\n  return gTaskDescriptorArray [inIndex].mStackBufferSize ;\n}\n" ;

const cRegularFileWrapper gWrapperFile_20_targetTemplates (
  "c-real-time-kernel-utilities.cpp",
  "cpp",
  true, // Text file
  3650, // Text length
  gWrapperFileContent_20_targetTemplates
) ;

//--- File '/c-task-control-block-type.cpp'

const char * gWrapperFileContent_21_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n\n// GUARD_EVALUATING_OR_OUTSIDE should be the first constant\ntypedef enum {GUARD_EVALUATING_OR_OUTSIDE, GUARD_DID_CHANGE, GUARD_WAITING_FOR_CHANGE} GuardState ;\n\n//----------------------------------------------------------------------------------------------------------------------\n//   T A S K    C O N T R O L    B L O C K\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct TaskControlBlock {\n//--- Context buffer\n  TaskContext mTaskContext ; // SHOULD BE THE FIRST FIELD\n//--- Task name\n  const char * mTaskName ;\n//--- This field is used for deadline\n  unsigned mTaskDeadline ;\n//--- Stack buffer parameters\n  unsigned * mStackBufferAddress ;\n  unsigned mStackBufferSize ; // In bytes\n  unsigned mStackFreeSize ; // In bytes\n//--- Guards\n  GuardDescriptor mGuardDescriptor ;\n  GuardState mGuardState ;\n//--- Task index\n  unsigned char mTaskIndex ;\n//--- ActivationCount\n  signed char mActivationCount ;\n//--- User result\n  bool mUserResult ;\n//---\n} TaskControlBlock ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic TaskControlBlock gTaskDescriptorArray [!TASKCOUNT!] ;\n\n//----------------------------------------------------------------------------------------------------------------------\n//   RUNNING TASK DESCRIPTOR POINTER\n//----------------------------------------------------------------------------------------------------------------------\n\nTaskControlBlock * gRunningTaskControlBlockPtr ; // Shared with assembly code (arm_context.s)\n\n" ;

const cRegularFileWrapper gWrapperFile_21_targetTemplates (
  "c-task-control-block-type.cpp",
  "cpp",
  true, // Text file
  1741, // Text length
  gWrapperFileContent_21_targetTemplates
) ;

//--- File '/c-task-list-32-tasks.cpp'

const char * gWrapperFileContent_16_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n// ENTER TASK IN LIST: inTask should be not null\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void list_enterTask (TaskList & ioTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void list_enterTask (TaskList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned mask = 1 << runningTaskIndex ;\n  ioTaskList.mList |= mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  REMOVE FIRST TASK FROM LIST: returns nullptr if list is empty\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * list_removeFirstTask (TaskList & ioTaskList) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * list_removeFirstTask (TaskList & ioTaskList) {\n  TaskControlBlock * result = nullptr ;\n  if (ioTaskList.mList != 0) {\n    const unsigned taskIndex = __builtin_ctz (ioTaskList.mList) ;\n    const unsigned mask = 1 << taskIndex ;\n    ioTaskList.mList &= ~ mask ;\n    result = & gTaskDescriptorArray [taskIndex] ;\n  }\n  return result ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_16_targetTemplates (
  "c-task-list-32-tasks.cpp",
  "cpp",
  true, // Text file
  1790, // Text length
  gWrapperFileContent_16_targetTemplates
) ;

//--- File '/c-task-list-64-tasks.cpp'

const char * gWrapperFileContent_17_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n// ENTER TASK IN LIST: inTask should be not null\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void list_enterTask (TaskList & ioTaskList, TaskControlBlock * inTask) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline void list_enterTask (TaskList & ioTaskList, TaskControlBlock * inTask) {\n  const unsigned runningTaskIndex = inTask->mTaskIndex ;\n  const unsigned long long mask = 1ULL << runningTaskIndex ;\n  ioTaskList.mList |= mask ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  REMOVE FIRST TASK FROM LIST: returns nullptr if list is empty\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * list_removeFirstTask (TaskList & ioTaskList) __attribute__((always_inline)) ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic inline TaskControlBlock * list_removeFirstTask (TaskList & ioTaskList) {\n  TaskControlBlock * result = nullptr ;\n  if (ioTaskList.mList != 0ULL) {\n    const unsigned taskIndex = __builtin_ctzll (ioTaskList.mList) ;\n    const unsigned long long mask = 1ULL << taskIndex ;\n    ioTaskList.mList &= ~ mask ;\n    result = & gTaskDescriptorArray [taskIndex] ;\n  }\n  return result ;\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_17_targetTemplates (
  "c-task-list-64-tasks.cpp",
  "cpp",
  true, // Text file
  1699, // Text length
  gWrapperFileContent_17_targetTemplates
) ;

//--- File '/c-task-list-type-32-tasks.cpp'

const char * gWrapperFileContent_8_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct { unsigned mList ; } TaskList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\n#if TASK_COUNT > 32\n  #error \"This type of list supports at most 32 tasks\"\n#endif\n\n//----------------------------------------------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_8_targetTemplates (
  "c-task-list-type-32-tasks.cpp",
  "cpp",
  true, // Text file
  496, // Text length
  gWrapperFileContent_8_targetTemplates
) ;

//--- File '/c-task-list-type-64-tasks.cpp'

const char * gWrapperFileContent_7_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct { unsigned long long mList ; } TaskList ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\n#if TASK_COUNT > 64\n  #error \"This type of list supports at most 64 tasks\"\n#endif\n\n//----------------------------------------------------------------------------------------------------------------------\n\n" ;

const cRegularFileWrapper gWrapperFile_7_targetTemplates (
  "c-task-list-type-64-tasks.cpp",
  "cpp",
  true, // Text file
  507, // Text length
  gWrapperFileContent_7_targetTemplates
) ;

//--- File '/class.cpp'

const char * gWrapperFileContent_26_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//\n//  CLASS ALLOCATION\n//\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned classAllocation (const unsigned inObjectSize) asm (\"class.allocation\") ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned classAllocation (const unsigned inObjectSize) {\n  const unsigned blockSize = inObjectSize - sizeof (DataBufferHeaderType) ;\n//--- Get the power of 2 greater or equal to block size\n  unsigned s = blockSize ;\n  unsigned smallestPowerOfTwo = 0 ;\n  while (s > 0) {\n    smallestPowerOfTwo += 1 ;\n    s >>= 1 ;\n  }\n//--- Get block size index\n  unsigned blockSizeIndex = 0 ; // kMinSizePowerOfTwo\n  if (smallestPowerOfTwo > kMinSizePowerOfTwo) {\n    blockSizeIndex = smallestPowerOfTwo - kMinSizePowerOfTwo ;\n  }\n//--- Allocate\n  DataBufferHeaderType * ptr = memoryAlloc (blockSizeIndex) ;\n//--- Return\n  return (unsigned) ptr ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_26_targetTemplates (
  "class.cpp",
  "cpp",
  true, // Text file
  1230, // Text length
  gWrapperFileContent_26_targetTemplates
) ;

//--- File '/dynamic-buffer.cpp'

const char * gWrapperFileContent_6_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//   GENERIC DYNAMIC BUFFER FUNCTIONS\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid retain (unsigned inPointer) asm (\"arc.retain\") ;\n\nvoid release (unsigned inPointer) asm (\"arc.release\") ;\n\nunsigned insulate (unsigned inPointer) asm (\"arc.insulate\") ;\n\nunsigned insertAtIndex (unsigned inPointer, unsigned inIndex, unsigned inElementSize, unsigned* outElementPtr)\nasm (\"arc.insert.at.index\") ;\n\nunsigned bufferLength (unsigned inPointer) asm (\"arc.length\") ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid retain (unsigned inPointer) {\n  if (inPointer != 0) {\n    DataBufferHeaderType * p = (DataBufferHeaderType *) inPointer ;\n    p->mReferenceCount += 1 ;\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid release (unsigned inPointer) {\n  if (inPointer != 0) {\n    DataBufferHeaderType * p = (DataBufferHeaderType *) inPointer ;\n    if (p->mReferenceCount > 1) {\n      p->mReferenceCount -= 1 ;\n    }else{\n      memoryFree (p) ;\n    }\n  }\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned insulate (unsigned inPointer) {\n  return (unsigned) internalInsulate ((DataBufferHeaderType *) inPointer) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  BUFFER LENGTH\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned bufferLength (unsigned inPointer) {\n  unsigned length = 0 ;\n  if (inPointer != 0) {\n    const DataBufferHeaderType * p = (const DataBufferHeaderType *) inPointer ;\n    length = p->mLength ;\n  }\n  return length ;\n}\n\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned insertAtIndex (unsigned inPointer, unsigned inIndex, unsigned inElementSize, unsigned* outElementPtr) {\n  DataBufferHeaderType * ptr = (DataBufferHeaderType *) inPointer ;\n  if (inPointer == 0) {\n    ptr = memoryAlloc (blockSizeIndexForSize (inElementSize)) ;\n  }else{\n    const unsigned currentLength = bufferLength (inPointer) ;\n    const unsigned requiredSize = (currentLength + 1) * inElementSize ;\n    const unsigned currentSize = blockSize (ptr) ;\n  //--- Need to realloc, or insulate \?\n    if (requiredSize > currentSize) {\n      ptr = reallocBlock (ptr, blockSizeIndexForSize (requiredSize)) ;\n    }else{\n      ptr = (DataBufferHeaderType *) insulate ((unsigned) ptr) ;\n    }\n  //--- Move elements beyond insert index\n    for (unsigned i= (currentLength * inElementSize) ; i > (inIndex * inElementSize) ; i--) {\n      ptr->mBuffer8 [i] = ptr->mBuffer8 [i - inElementSize] ;\n    }\n  }\n//--- Zero insert zone\n  for (unsigned i= (inIndex * inElementSize) ; i < ((inIndex + 1) * inElementSize) ; i++) {\n    ptr->mBuffer8 [i] = 0 ;\n  }\n//--- Increment length\n  ptr->mLength += 1 ;\n//--- Set inserted element pointer\n  *outElementPtr = (unsigned) & ptr->mBuffer8 [inIndex * inElementSize] ;\n//--- Return\n  return (unsigned) ptr ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_6_targetTemplates (
  "dynamic-buffer.cpp",
  "cpp",
  true, // Text file
  3527, // Text length
  gWrapperFileContent_6_targetTemplates
) ;

//--- File '/heap.cpp'

const char * gWrapperFileContent_15_targetTemplates = "//----------------------------------------------------------------------------------------------------------------------\n//\n//  DYNAMIC ALLOCATION\n//\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned heapEndAddress (void) asm (\"!FUNC!heap.end.address\") ;\nunsigned heapStartAddress (void) asm (\"!FUNC!heap.start.address\") ;\nunsigned heapAllocAddress (void) asm (\"!FUNC!heap.alloc.address\") ;\nunsigned freeByteCount (void) asm (\"!FUNC!heap.free.byte.count\") ;\n\nunsigned currentlyAllocatedObjectCount (void) asm (\"!FUNC!heap.currently.allocated.object.count\") ;\nunsigned totalAllocationObjectCount (void)  asm (\"!FUNC!heap.total.allocation.object.count\") ;\n\nunsigned freeListCount (void) asm (\"!FUNC!heap.free.list.count\") ;\nunsigned freeObjectCountForFreeList (const unsigned inFreeListIndex) asm (\"!FUNC!heap.free.object.count.for.free.list\") ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic const unsigned kMinSizePowerOfTwo =  4 ; // Smallest block being allocated = 2 ** kMinSizePowerOfTwo\nstatic const unsigned kMaxSizePowerOfTwo = 16 ; // Biggest block being allocated = 2 ** kMaxSizePowerOfTwo\nstatic const unsigned kSegregatedAllocationListCount = kMaxSizePowerOfTwo - kMinSizePowerOfTwo + 1 ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nextern unsigned __heap_start ;\nextern unsigned __heap_end ;\n\n//----------------------------------------------------------------------------------------------------------------------\n//         Heap adresses\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned gFirstFreeAddress = (unsigned) & __heap_start ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned heapAllocAddress (void) {\n  return gFirstFreeAddress ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned heapStartAddress (void) {\n  return (unsigned) & __heap_start ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned heapEndAddress (void) {\n  return (unsigned) & __heap_end ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned freeByteCount (void) {\n  return heapEndAddress () - gFirstFreeAddress ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//         Allocation count\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned gCurrentlyAllocatedCount ;\nunsigned gTotalAllocationCount ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned currentlyAllocatedObjectCount (void) {\n  return gCurrentlyAllocatedCount ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned totalAllocationObjectCount (void) {\n  return gTotalAllocationCount ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  FREE BLOCK SEGREGATED LIST\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct structFreeBlock {\n  struct structFreeBlock * mNextFreeBlock ;\n} tFreeBlock ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct {\n  tFreeBlock * mFreeBlockList ;\n  unsigned mFreeBlockCount ;\n} tFreeBlockListDescriptor ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\ntFreeBlockListDescriptor gFreeBlockDescriptorArray [kSegregatedAllocationListCount] ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned freeObjectCountForFreeList (const unsigned inFreeListIndex) {\n  return (inFreeListIndex < kSegregatedAllocationListCount)\n    \? gFreeBlockDescriptorArray [inFreeListIndex].mFreeBlockCount\n    : 0\n  ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nunsigned freeListCount (void) {\n  return kSegregatedAllocationListCount ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//  ALLOCATION / DEALLOCATION\n//----------------------------------------------------------------------------------------------------------------------\n\ntypedef struct {\n  unsigned short mBlockSizeIndex ;\n  unsigned short mLength ;\n  unsigned mReferenceCount ;\n  unsigned char mBuffer8 [] ;\n} DataBufferHeaderType ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nDataBufferHeaderType * memoryAlloc (unsigned inBlockSizeIndex) asm (\"!SECTIONCALL!heap.memory.alloc\") ;\n\nDataBufferHeaderType * kernel_memoryAlloc (unsigned inBlockSizeIndex) asm (\"!SECTIONIMPLEMENTATION!heap.memory.alloc\") ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nDataBufferHeaderType * kernel_memoryAlloc (unsigned inBlockSizeIndex) {\n  DataBufferHeaderType * result = (DataBufferHeaderType *) 0 ;\n  tFreeBlockListDescriptor * descriptorPtr = & gFreeBlockDescriptorArray [inBlockSizeIndex] ;\n  if (descriptorPtr->mFreeBlockCount > 0) { // Allocate from free list\n    descriptorPtr->mFreeBlockCount -= 1 ;\n    tFreeBlock * p = descriptorPtr->mFreeBlockList ;\n    descriptorPtr->mFreeBlockList = p->mNextFreeBlock ;\n    result = (DataBufferHeaderType *) p ;\n  }else{ // Allocate from heap\n    const unsigned allocationSize = (1 << (inBlockSizeIndex + kMinSizePowerOfTwo)) + sizeof (DataBufferHeaderType) ;\n    if ((gFirstFreeAddress + allocationSize) <= heapEndAddress ()) { // No Heap overflow\n      result = (DataBufferHeaderType *) gFirstFreeAddress ;\n      gFirstFreeAddress += allocationSize ;\n    }\n  }\n//---\n  if (result != (DataBufferHeaderType *) 0) {\n    result->mBlockSizeIndex = (unsigned short) inBlockSizeIndex ;\n    result->mLength = 0 ;\n    result->mReferenceCount = 1 ;\n    gCurrentlyAllocatedCount += 1 ;\n    gTotalAllocationCount += 1 ;\n  }\n//---\n  return result ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid memoryFree (DataBufferHeaderType * inPointer) asm (\"!SECTIONCALL!heap.memory.free\") ;\n\nvoid kernel_memoryFree (DataBufferHeaderType * inPointer) asm (\"!SECTIONIMPLEMENTATION!heap.memory.free\") ;\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvoid kernel_memoryFree (DataBufferHeaderType * inPointer) {\n  const unsigned idx = inPointer->mBlockSizeIndex ;\n  tFreeBlock * freeBlockPtr = (tFreeBlock *) inPointer ;\n  freeBlockPtr->mNextFreeBlock = gFreeBlockDescriptorArray [idx].mFreeBlockList ;\n  gFreeBlockDescriptorArray [idx].mFreeBlockList = freeBlockPtr ;\n  gFreeBlockDescriptorArray [idx].mFreeBlockCount += 1 ;\n  gCurrentlyAllocatedCount -= 1 ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic unsigned blockSize (DataBufferHeaderType * inPointer) {\n  unsigned size = 0 ;\n  if (inPointer != (DataBufferHeaderType *) 0) {\n    size = 1 << (inPointer->mBlockSizeIndex + kMinSizePowerOfTwo) ;\n  }\n  return size ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic unsigned blockSizeIndexForSize (const unsigned inRequiredBlockSize) {\n  unsigned powerOfTwo = 0 ;\n  if (inRequiredBlockSize > 0) {\n    unsigned s = inRequiredBlockSize - 1 ;\n    while (s > 0) {\n      powerOfTwo += 1 ;\n      s >>= 1 ;\n    }\n  }\n  return (powerOfTwo <= kMinSizePowerOfTwo) \? 0 : (powerOfTwo - kMinSizePowerOfTwo) ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic DataBufferHeaderType * reallocBlock (DataBufferHeaderType * inPointer, const unsigned inBlockSizeIndex) {\n//--- Allocate next size block\n  DataBufferHeaderType * newBlock = memoryAlloc (inBlockSizeIndex) ;\n//--- Copy buffer content to new block\n  for (unsigned i=0 ; i<inPointer->mLength ; i++) {\n    newBlock->mBuffer8 [i] = inPointer->mBuffer8 [i] ;\n  }\n  newBlock->mLength = inPointer->mLength ;\n//--- Free old block \?\n  if (inPointer->mReferenceCount == 1) {\n    memoryFree (inPointer) ;\n  }else{\n    inPointer->mReferenceCount -= 1 ;\n  }\n//---\n  return newBlock ;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic DataBufferHeaderType * internalInsulate (DataBufferHeaderType * inPointer) {\n  DataBufferHeaderType * result = inPointer ;\n  if ((inPointer != (DataBufferHeaderType *) 0) && (inPointer->mReferenceCount > 1)) {\n    result = reallocBlock (inPointer, inPointer->mBlockSizeIndex) ;\n  }\n  return result ;\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_15_targetTemplates (
  "heap.cpp",
  "cpp",
  true, // Text file
  9579, // Text length
  gWrapperFileContent_15_targetTemplates
) ;

//--- File '/heap.omnibus-import'

const char * gWrapperFileContent_2_targetTemplates = "//\n//   HEAP FUNCTIONS (IMPLEMENTED IN heap.c)\n//\n\n//--- Heap stats\nextern func heapEndAddress () -> $u32 : \"heap.end.address\"\nextern func heapStartAddress () -> $u32 : \"heap.start.address\"\nextern func heapAllocAddress () -> $u32 : \"heap.alloc.address\"\nextern func freeByteCount () -> $u32 : \"heap.free.byte.count\"\n\nextern func currentlyAllocatedObjectCount () -> $u32 : \"heap.currently.allocated.object.count\"\nextern func totalAllocationObjectCount () -> $u32 : \"heap.total.allocation.object.count\"\n\nextern func freeListCount () -> $u32 : \"heap.free.list.count\"\nextern func freeObjectCount (\?ForFreeList: inFreeListIndex $u32) -> $u32 : \"heap.free.object.count.for.free.list\"\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_2_targetTemplates (
  "heap.omnibus-import",
  "omnibus-import",
  true, // Text file
  1035, // Text length
  gWrapperFileContent_2_targetTemplates
) ;

//--- File '/ll-clear-bss.ll'

const char * gWrapperFileContent_25_targetTemplates = ";----------------------------------------------------------------------------------------------------------------------*\n;   Clear BSS                                                                                                          *\n;----------------------------------------------------------------------------------------------------------------------*\n;void clearBSS (void) {\n;  extern unsigned __bss_start ;\n;  extern unsigned __bss_end ;\n;  unsigned * p = & __bss_start ;\n;  while (p != & __bss_end) {\n;    * p = 0 ;\n;    p ++ ;\n;  }\n;}\n;----------------------------------------------------------------------------------------------------------------------*\n\n@__bss_start = external global [0 x i32]\n@__bss_end   = external global [0 x i32]\n\n;----------------------------------------------------------------------------------------------------------------------*\n\ndefine internal void @clear.bss () nounwind minsize optsize {\nentry:\n  %startPtr = getelementptr [0 x i32], [0 x i32]* @__bss_start, i32 0, i32 0\n  %endPtr   = getelementptr [0 x i32], [0 x i32]* @__bss_end,   i32 0, i32 0\n  br label %bss.loop.test\nbss.loop.test:\n  %p = phi i32* [%startPtr, %entry], [%p.next, %bss.loop]\n  %completed = icmp eq i32* %p, %endPtr\n  br i1 %completed, label %bss.loop.completed, label %bss.loop\nbss.loop:\n  store i32 0, i32* %p, align 4\n  %p.next = getelementptr inbounds i32, i32* %p, i32 1\n  br label %bss.loop.test\nbss.loop.completed:\n  ret void\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_25_targetTemplates (
  "ll-clear-bss.ll",
  "ll",
  true, // Text file
  1459, // Text length
  gWrapperFileContent_25_targetTemplates
) ;

//--- File '/ll-configuration-on-boot.ll'

const char * gWrapperFileContent_23_targetTemplates = ";----------------------------------------------------------------------------------------------------------------------*\n;   boot.routines                                                                                                      *\n;----------------------------------------------------------------------------------------------------------------------*\n\ndefine void @boot.routines () nounwind minsize optsize {\n  call void @boot ()\n  call void @clear.bss ()\n  call void @copy.data ()\n  ret  void\n}\n\n;----------------------------------------------------------------------------------------------------------------------*\n;   startup.routines                                                                                                   *\n;----------------------------------------------------------------------------------------------------------------------*\n\ndefine void @startup.routines () nounwind minsize optsize {\n  call void @startup ()\n  call void @start.tasks ()\n  ret  void\n}\n" ;

const cRegularFileWrapper gWrapperFile_23_targetTemplates (
  "ll-configuration-on-boot.ll",
  "ll",
  true, // Text file
  999, // Text length
  gWrapperFileContent_23_targetTemplates
) ;

//--- File '/ll-copy-byte-array.ll'

const char * gWrapperFileContent_0_targetTemplates = ";----------------------------------------------------------------------------------------------------------------------*\n;   Copy Byte Array                                                                                                    *\n;----------------------------------------------------------------------------------------------------------------------*\n\ndefine internal void @copy.byte.array (i8* %target.initial, i8* %source.initial, i32 %byte.count.initial) nounwind {\nentry:\n  br label %loop\nloop:\n  %source.current = phi i8* [%source.initial, %entry], [%source.next, %loop.next]\n  %target.current = phi i8* [%target.initial, %entry], [%target.next, %loop.next]\n  %byte.count.current = phi i32 [%byte.count.initial, %entry], [%byte.count.next, %loop.next]\n  %v = load i8, i8* %source.current\n  store i8 %v, i8* %target.current\n  %byte.count.next = sub i32 %byte.count.current, 1\n  %byte.count.is.zero = icmp eq i32 %byte.count.next, 0\n  br i1 %byte.count.is.zero, label %loop.completed, label %loop.next\nloop.next:\n  %source.next = getelementptr inbounds i8, i8* %source.current, i32 1\n  %target.next = getelementptr inbounds i8, i8* %target.current, i32 1\n  br label %loop\nloop.completed:\n  ret void\n}\n" ;

const cRegularFileWrapper gWrapperFile_0_targetTemplates (
  "ll-copy-byte-array.ll",
  "ll",
  true, // Text file
  1216, // Text length
  gWrapperFileContent_0_targetTemplates
) ;

//--- File '/ll-copy-data-section.ll'

const char * gWrapperFileContent_1_targetTemplates = ";----------------------------------------------------------------------------------------------------------------------*\n;   Copy .data section                                                                                                 *\n;----------------------------------------------------------------------------------------------------------------------*\n;void copyData (void) {\n;  extern unsigned __data_start ;\n;  extern unsigned __data_end ;\n;  extern unsigned __data_load_start ;\n;  unsigned * pSrc = & __data_load_start ;\n;  unsigned * pDest = & __data_start ;\n;  while (pDest != & __data_end) {\n;    * pDest = * pSrc ;\n;    pDest ++ ;\n;    pSrc ++ ;\n;  }\n;}\n;----------------------------------------------------------------------------------------------------------------------*\n\n@__data_start = external global [0 x i32]\n@__data_end = external global [0 x i32]\n@__data_load_start = external global [0 x i32]\n\n;----------------------------------------------------------------------------------------------------------------------*\n\ndefine internal void @copy.data () nounwind minsize optsize {\nentry:\n  %data_start = getelementptr  [0 x i32], [0 x i32]* @__data_start, i32 0, i32 0\n  %data_end = getelementptr  [0 x i32], [0 x i32]* @__data_end, i32 0, i32 0\n  %data_load_start = getelementptr  [0 x i32], [0 x i32]* @__data_load_start, i32 0, i32 0\n  br label %copy.loop.test\n\ncopy.loop.test:\n  %pDest = phi i32* [%data_start, %entry], [%pDestInct, %copy.loop]\n  %pSource = phi i32* [%data_load_start, %entry], [%pSourceInc, %copy.loop]\n  %equal = icmp eq i32* %pDest, %data_end\n  br i1 %equal, label %copy.completed, label %copy.loop\n\ncopy.loop:\n  %value = load i32, i32* %pSource\n  store i32 %value, i32* %pDest, align 4\n  %pDestInct = getelementptr inbounds i32, i32* %pDest, i32 1\n  %pSourceInc = getelementptr inbounds i32, i32* %pSource, i32 1\n  br label %copy.loop.test\n\ncopy.completed:\n  ret void\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_1_targetTemplates (
  "ll-copy-data-section.ll",
  "ll",
  true, // Text file
  1923, // Text length
  gWrapperFileContent_1_targetTemplates
) ;

//--- File '/ll-copy-word-array.ll'

const char * gWrapperFileContent_13_targetTemplates = ";----------------------------------------------------------------------------------------------------------------------*\n;   Copy Word Array                                                                                                    *\n;----------------------------------------------------------------------------------------------------------------------*\n\ndefine internal void @copy.word.array (i32* %target.initial, i32* %source.initial, i32 %word.count.initial) nounwind {\nentry:\n  br label %loop\nloop:\n  %source.current = phi i32* [%source.initial, %entry], [%source.next, %loop.next]\n  %target.current = phi i32* [%target.initial, %entry], [%target.next, %loop.next]\n  %word.count.current = phi i32 [%word.count.initial, %entry], [%word.count.next, %loop.next]\n  %v = load i32, i32* %source.current\n  store i32 %v, i32* %target.current\n  %word.count.next = sub i32 %word.count.current, 1\n  %word.count.is.zero = icmp eq i32 %word.count.next, 0\n  br i1 %word.count.is.zero, label %loop.completed, label %loop.next\nloop.next:\n  %source.next = getelementptr inbounds i32, i32* %source.current, i32 1\n  %target.next = getelementptr inbounds i32, i32* %target.current, i32 1\n  br label %loop\nloop.completed:\n  ret void\n}\n" ;

const cRegularFileWrapper gWrapperFile_13_targetTemplates (
  "ll-copy-word-array.ll",
  "ll",
  true, // Text file
  1228, // Text length
  gWrapperFileContent_13_targetTemplates
) ;

//--- File '/memory-utilities.cpp'

const char * gWrapperFileContent_32_targetTemplates = "//\n//   CLEAR WORD ARRAY\n//\n\nvoid clearWordArray (unsigned * inTargetPtr,\n                     const unsigned inWordCount) asm (\"clear.word.array\") ;\n\n//\n\nvoid clearWordArray (unsigned * inTargetPtr,\n                     const unsigned inWordCount) {\n  unsigned wordCount = inWordCount ;\n  while (wordCount > 0) {\n    *inTargetPtr = 0 ;\n    inTargetPtr ++ ;\n    wordCount -= 1 ;\n  }\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_32_targetTemplates (
  "memory-utilities.cpp",
  "cpp",
  true, // Text file
  861, // Text length
  gWrapperFileContent_32_targetTemplates
) ;

//--- File '/py-build-verbose.txt'

const char * gWrapperFileContent_33_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport subprocess\nimport sys\nimport os\nimport atexit\n\n#------------------------------------------------------------------------------*\n\ndef cleanup():\n  if childProcess.poll () == None :\n    childProcess.kill ()\n\n#------------------------------------------------------------------------------*\n\n#--- Register a function for killing subprocess\natexit.register (cleanup)\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\nos.chdir (scriptDir)\n#---\nchildProcess = subprocess.Popen ([\"python\", \"build.py\", \"all\", \"1\"])\n#--- Wait for subprocess termination\nif childProcess.poll () == None :\n  childProcess.wait ()\nif childProcess.returncode != 0 :\n  sys.exit (childProcess.returncode)\n\n#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_33_targetTemplates (
  "py-build-verbose.txt",
  "txt",
  true, // Text file
  1003, // Text length
  gWrapperFileContent_33_targetTemplates
) ;

//--- File '/py-check-stacks.txt'

const char * gWrapperFileContent_18_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport sys, os, json\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef printUTF8 (s) :\n  print s.encode ('utf-8')\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef dictionaryFromJsonFile (file) :\n  result = {}\n  if not os.path.exists (os.path.abspath (file)):\n    printUTF8 (u\"Error: the '\" + file + u\"' file does not exist\")\n    sys.exit (1)\n  try:\n    f = open (file, \"r\")\n    result = json.loads (f.read ())\n    f.close ()\n  except:\n    printUTF8 (u\"Syntax error in '\" + file + u\"' JSON file\")\n    sys.exit (1)\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#    MAIN                                                                                                              *\n#----------------------------------------------------------------------------------------------------------------------*\n\nok = True\nprovidedStacksJSONFile = sys.argv [1]\n# print u\"providedStacksJSONFile '\" + providedStacksJSONFile + u\"'\"\nstackAnalysisJSONFile = sys.argv [2]\n# print u\"stackAnalysisJSONFile '\" + stackAnalysisJSONFile + u\"'\"\nresultFile = sys.argv [3]\n# print u\"resultFile '\" + resultFile + u\"'\"\nresultContents = \"\"\n#--- Read JSON file\nrequirementsDictionary = dictionaryFromJsonFile (providedStacksJSONFile)\nstackAnalysisDictionary = dictionaryFromJsonFile (stackAnalysisJSONFile)\nsolvedFunctionDictionary = stackAnalysisDictionary [\"solved\"]\n#--- Saved register byte count in user stack\nsavedRegisterInUserStackByteCount = requirementsDictionary [\"stacked-register-size-on-user-stack\"]\nsystemStackSize = requirementsDictionary [\"system-stack-size\"]\nserviceStackRequirement = requirementsDictionary [\"service-stack-needs\"]\nsectionStackRequirement = requirementsDictionary [\"section-stack-needs\"]\n#--- Check task stacks\nresultContents += u\"*----------------------------------------------------------------*\\n\"\nresultContents += u\"*   CHECK TASK STACKS                                            *\\n\"\nresultContents += u\"*----------------------------------------------------------------*\\n\\n\"\nresultContents += u\"  Interrupt stacked register size: \" + str (savedRegisterInUserStackByteCount) + u\" bytes\\n\\n\"\ntaskDictionary = requirementsDictionary [\"tasks\"]\nfor taskName in taskDictionary :\n  unicodeTaskName = (taskName)\n  availableStackSize = taskDictionary [unicodeTaskName]\n  taskFunctionName = u\"task.main.\" + unicodeTaskName\n  if solvedFunctionDictionary.has_key (taskFunctionName) :\n    stackRequirement = solvedFunctionDictionary [taskFunctionName] + savedRegisterInUserStackByteCount\n    resultContents += u\"  task '\" + taskName + u\"', provided stack: \"\n    resultContents += str (availableStackSize) + u\" bytes, required: \" + str (stackRequirement) + u\"\\n\"\n    if stackRequirement > availableStackSize:\n      ok = False\n      printUTF8 (u\"Error: insufficient stack size for '\" + unicodeTaskName + u\"' task\")\n      resultContents += u\"Error: insufficient stack size for '\" + unicodeTaskName + u\"' task\\n\"\n  else:\n    printUTF8 (u\"Error: \" + unicodeTaskName + u\": unsolved '\" + taskFunctionName + u\"', cannot compute\")\n    resultContents += u\"Error: \" + unicodeTaskName + u\": unsolved '\" + taskFunctionName + u\"', cannot compute\\n\"\n    ok = False\nresultContents += u\"\\n\"\n#--- Check services\nresultContents += u\"*----------------------------------------------------------------*\\n\"\nresultContents += u\"*   CHECK SERVICE STACK                                          *\\n\"\nresultContents += u\"*----------------------------------------------------------------*\\n\\n\"\nresultContents += u\"  System stack: \" + str (systemStackSize) + u\" bytes\\n\"\nresultContents += u\"  Service handler stack needs: \" + str (serviceStackRequirement) + u\" bytes\\n\\n\"\nfor serviceName in requirementsDictionary [\"services\"]:\n  if solvedFunctionDictionary.has_key (serviceName) :\n    stackRequirement = solvedFunctionDictionary [serviceName] + serviceStackRequirement\n    resultContents += u\"  Service '\" + serviceName + u\"', required stack: \" + str (stackRequirement) + u\"\\n\"\n    if stackRequirement > systemStackSize:\n      ok = False\n      printUTF8 (u\"Error: insufficient stack size for service '\" + serviceName + u\"' task\")\n      resultContents += u\"Error: insufficient stack size for service '\" + serviceName + u\"' task\\n\"\n  else:\n    printUTF8 (u\"Error: service u\" + serviceName + u\": unsolved\")\n    resultContents += u\"Error: service \" + serviceName + u\": unsolved\\n\"\n    ok = False\nresultContents += u\"\\n\"\n#--- Check sections\nresultContents += u\"*----------------------------------------------------------------*\\n\"\nresultContents += u\"*   CHECK SECTION STACK                                          *\\n\"\nresultContents += u\"*----------------------------------------------------------------*\\n\\n\"\nresultContents += u\"  System stack: \" + str (systemStackSize) + u\" bytes\\n\"\nresultContents += u\"  Section handler stack needs: \" + str (sectionStackRequirement) + u\" bytes\\n\\n\"\nfor sectionName in requirementsDictionary [\"sections\"]:\n  if solvedFunctionDictionary.has_key (sectionName) :\n    stackRequirement = solvedFunctionDictionary [sectionName] + sectionStackRequirement\n    resultContents += u\"  Section '\" + sectionName + u\"', required stack: \" + str (stackRequirement) + u\"\\n\"\n    if stackRequirement > systemStackSize:\n      ok = False\n      printUTF8 (u\"Error: insufficient stack size for section '\" + sectionName + u\"' task\")\n      resultContents += u\"Error: insufficient stack size for section '\" + sectionName + u\"' task\\n\"\n  else:\n    printUTF8 (u\"Error: section \" + sectionName + u\": unsolved\")\n    resultContents += u\"Error: section \" + sectionName + u\": unsolved\\n\"\n    ok = False\nresultContents += u\"\\n\"\n#--- Check sections\nresultContents += u\"*----------------------------------------------------------------*\\n\"\nresultContents += u\"*   CHECK INTERRUPT SERVICE ROUTINE STACKS                       *\\n\"\nresultContents += u\"*----------------------------------------------------------------*\\n\\n\"\nresultContents += u\"  System stack: \" + str (systemStackSize) + u\" bytes\\n\"\n#resultContents += u\"  Section handler stack needs: \" + str (sectionStackRequirement) + u\" bytes\\n\\n\"\nfor isr in requirementsDictionary [\"isr\"]:\n  if solvedFunctionDictionary.has_key (isr) :\n    stackRequirement = solvedFunctionDictionary [isr]\n    resultContents += u\"  ISR '\" + isr + u\"', required stack: \" + str (stackRequirement) + u\"\\n\"\n    if stackRequirement > systemStackSize:\n      ok = False\n      printUTF8 (u\"Error: insufficient stack size for isr '\" + isr + u\"' task\")\n      resultContents += u\"Error: insufficient stack size for isr '\" + isr + u\"' task\\n\"\n  else:\n    printUTF8 (u\"Error: isr \" + isr + u\": unsolved\")\n    resultContents += u\"Error: isr \" + isr + u\": unsolved\\n\"\n    ok = False\nresultContents += u\"\\n\"\n#--- Write result file\nresultContents += u\"*----------------------------------------------------------------*\\n\"\nf = open (resultFile, 'w')\nf.write (resultContents.encode ('utf-8'))\nf.close ()\n#--- return\nif not ok :\n  sys.exit (1)\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_18_targetTemplates (
  "py-check-stacks.txt",
  "txt",
  true, // Text file
  7470, // Text length
  gWrapperFileContent_18_targetTemplates
) ;

//--- File '/py-clean.txt'

const char * gWrapperFileContent_28_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport subprocess\nimport sys\nimport os\nimport atexit\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef cleanup():\n  if childProcess.poll () == None :\n    childProcess.kill ()\n\n#----------------------------------------------------------------------------------------------------------------------*\n\n#--- Register a function for killing subprocess\natexit.register (cleanup)\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n#--- Directories to clean\ndir1 = scriptDir + \"/objects\"\ndir2 = scriptDir + \"/product\"\ndir3 = scriptDir + \"/as\"\n#---\nchildProcess = subprocess.Popen ([\"rm\", \"-fr\", dir1, dir2, dir3], cwd=scriptDir)\n#--- Wait for subprocess termination\nif childProcess.poll () == None :\n  childProcess.wait ()\nif childProcess.returncode != 0 :\n  sys.exit (childProcess.returncode)\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_28_targetTemplates (
  "py-clean.txt",
  "txt",
  true, // Text file
  1265, // Text length
  gWrapperFileContent_28_targetTemplates
) ;

//--- File '/py-makefile.txt'

const char * gWrapperFileContent_22_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#*\n#   Releases                                                                                                           *\n#*\n# 1.0: march 18th, 2015\n#        first release\n# 2.0: october 2th, 2015\n#        added several target definition for rules\n# 2.1: october 5th, 2015\n#        added checking routine formal argument run-time types\n# 2.2: october 24th, 2015\n#        changed subprocess.Popen to subprocess.call in runCommand\n#        added command tool checking using 'find_executable' function\n#        added optional argument to Make class initializer to log command utility tool path\n# 2.3: april 16th, 2016\n#        added advance percentage\n#\n#*\n\nimport subprocess, sys, os, copy\nimport urllib, shutil, subprocess\nimport platform, json, operator\nimport threading, types, traceback\n\nif sys.version_info >= (2, 6) :\n  import multiprocessing\n\n#*\n#   find_executable                                                                                                    *\n# From:                                                                                                                *\n# https://gist.github.com/4368898                                                                                      *\n# Public domain code by anatoly techtonik <techtonik@gmail.com>                                                        *\n#*\n\ndef find_executable(executable, path=None):\n    \"\"\"Try to find 'executable' in the directories listed in 'path' (a\n    string listing directories separated by 'os.pathsep'; defaults to\n    os.environ['PATH']).  Returns the complete filename or None if not\n    found\n    \"\"\"\n    if path is None:\n        path = os.environ['PATH']\n    paths = path.split(os.pathsep)\n    extlist = ['']\n    if os.name == 'os2':\n        (base, ext) = os.path.splitext(executable)\n        # executable files on OS/2 can have an arbitrary extension, but\n        # .exe is automatically appended if no dot is present in the name\n        if not ext:\n            executable = executable + \".exe\"\n    elif sys.platform == 'win32':\n        pathext = os.environ['PATHEXT'].lower().split(os.pathsep)\n        (base, ext) = os.path.splitext(executable)\n        if ext.lower() not in pathext:\n            extlist = pathext\n    for ext in extlist:\n        execname = executable + ext\n        if os.path.isfile(execname):\n            return execname\n        else:\n            for p in paths:\n                f = os.path.join(p, execname)\n                if os.path.isfile(f):\n                    return f\n    else:\n        return None\n\n#*\n#   processorCount                                                                                                     *\n#*\n\ndef processorCount () :\n  if sys.version_info >= (2, 6) :\n    coreCount = multiprocessing.cpu_count ()\n  else:\n    coreCount = 1\n  return coreCount\n\n#*\n#   FOR PRINTING IN COLOR                                                                                              *\n#*\n\ndef BLACK () :\n  return '\\033[90m'\n\n#*\n\ndef RED () :\n  return '\\033[91m'\n\n#*\n\ndef GREEN () :\n  return '\\033[92m'\n\n#*\n\ndef YELLOW () :\n  return '\\033[93m'\n\n#*\n\ndef BLUE () :\n  return '\\033[94m'\n\n#*\n\ndef MAGENTA () :\n  return '\\033[95m'\n\n#*\n\ndef CYAN () :\n  return '\\033[96m'\n\n#*\n\ndef WHITE () :\n  return '\\033[97m'\n\n#*\n\ndef ENDC () :\n  return '\\033[0m'\n\n#*\n\ndef BOLD () :\n  return '\\033[1m'\n\n#*\n\ndef UNDERLINE () :\n  return '\\033[4m'\n\n#*\n\ndef BLINK () :\n  return '\\033[5m'\n\n#*\n\ndef BOLD_BLUE () :\n  return BOLD () + BLUE ()\n\n#*\n\ndef BOLD_GREEN () :\n  return BOLD () + GREEN ()\n\n#*\n\ndef BOLD_RED () :\n  return BOLD () + RED ()\n\n#*\n#   runHiddenCommand                                                                                                   *\n#*\n\ndef runHiddenCommand (cmd, logUtilityTool=False) :\n  executable = find_executable (cmd [0])\n  if executable == None:\n    print BOLD_RED () + \"*** Cannot find '\" + cmd[0] + \"' executable ***\" + ENDC ()\n    sys.exit (1)\n  if logUtilityTool:\n    print \"Utility tool is '\" + executable + \"'\"\n  result = \"\"\n  childProcess = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n  while True:\n    line = childProcess.stdout.readline ()\n    if line != \"\":\n      result += line\n    else:\n      childProcess.wait ()\n      if childProcess.returncode != 0 :\n        sys.exit (childProcess.returncode)\n      return result\n\n#*\n#   runCommand                                                                                                         *\n#*\n\ndef runCommand (cmd, title, showCommand, logUtilityTool) :\n  if title != \"\":\n    print BOLD_BLUE () + title + ENDC ()\n  if (title == \"\") or showCommand :\n    cmdAsString = \"\"\n    for s in cmd:\n      if (s == \"\") or (s.find (\" \") >= 0):\n        cmdAsString += '\"' + s + '\" '\n      else:\n        cmdAsString += s + ' '\n    print cmdAsString\n  executable = find_executable (cmd [0])\n  if executable == None:\n    print BOLD_RED () + \"*** Cannot find '\" + cmd[0] + \"' executable ***\" + ENDC ()\n    sys.exit (1)\n  if logUtilityTool:\n    print \"Utility tool is '\" + executable + \"'\"\n  returncode = subprocess.call (cmd)\n  if returncode != 0 :\n    sys.exit (returncode)\n\n#*\n#   runInThread                                                                                                        *\n#*\n\ndef runInThread (job, displayLock, terminationSemaphore):\n  executable = find_executable (job.mCommand [0])\n  if executable == None:\n    print BOLD_RED () + \"*** Cannot find '\" + job.mCommand[0] + \"' executable ***\" + ENDC ()\n    job.mReturnCode = 1\n    terminationSemaphore.release ()\n  else:\n    if job.mLogUtilityTool :\n      print \"Utility tool is '\" + executable + \"'\"\n    childProcess = subprocess.Popen (job.mCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    while True:\n      line = childProcess.stdout.readline ()\n      if line != \"\":\n        job.mOutputLines.append (line)\n        displayLock.acquire ()\n        sys.stdout.write (line) # Print without newline\n        displayLock.release ()\n      else:\n        childProcess.wait ()\n        job.mReturnCode = childProcess.returncode\n        terminationSemaphore.release ()\n        break\n\n#*\n#   modificationDateForFile                                                                                            *\n#*\n\ndef modificationDateForFile (dateCacheDictionary, file):\n  absFilePath = os.path.abspath (file)\n  if dateCacheDictionary.has_key (absFilePath) :\n    return dateCacheDictionary [absFilePath]\n  elif not os.path.exists (absFilePath):\n    date = sys.float_info.max # Very far in future\n    dateCacheDictionary [absFilePath] = date\n    return date\n  else:\n    date = os.path.getmtime (absFilePath)\n    dateCacheDictionary [absFilePath] = date\n    return date\n\n#*\n#   class PostCommand                                                                                                  *\n#*\n\nclass PostCommand:\n  mCommand = []\n  mTitle = \"\"\n\n  #*\n\n  def __init__ (self, title = \"\"):\n    self.mCommand = []\n    self.mTitle = title\n\n#*\n#   class Job                                                                                                          *\n#*\n\nclass Job:\n  mTargets = []\n  mCommand = []\n  mTitle = \"\"\n  mRequiredFiles = []\n  mPostCommands = []\n  mReturnCode = None\n  mPriority = 0\n  mState = 0 # 0: waiting for execution\n  mOutputLines = []\n  mOpenSourceOnError = False # Do not try to open source file on error\n  mLogUtilityTool = False\n\n  #*\n\n  def __init__ (self, targets, requiredFiles, command, postCommands, priority, title, openSourceOnError, logUtilityTool):\n    self.mTargets = copy.deepcopy (targets)\n    self.mCommand = copy.deepcopy (command)\n    self.mRequiredFiles = copy.deepcopy (requiredFiles)\n    self.mTitle = copy.deepcopy (title)\n    self.mPostCommands = copy.deepcopy (postCommands)\n    self.mPriority = priority\n    self.mOutputLines = []\n    self.mOpenSourceOnError = openSourceOnError\n    self.mLogUtilityTool = logUtilityTool\n\n  #*\n\n  def run (self, displayLock, terminationSemaphore, showCommand, progressString):\n    displayLock.acquire ()\n    if self.mTitle != \"\":\n      print progressString + BOLD_BLUE () + self.mTitle + ENDC ()\n    if (self.mTitle == \"\") or showCommand :\n      cmdAsString = \"\"\n      for s in self.mCommand:\n        if (s == \"\") or (s.find (\" \") >= 0):\n          cmdAsString += '\"' + s + '\" '\n        else:\n          cmdAsString += s + ' '\n      print progressString + cmdAsString\n    displayLock.release ()\n    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n    thread.start()\n\n  #*\n\n  def runPostCommand (self, displayLock, terminationSemaphore, showCommand):\n    postCommand = self.mPostCommands [0]\n    self.mCommand = postCommand.mCommand\n    displayLock.acquire ()\n    print BOLD_BLUE () + postCommand.mTitle + ENDC ()\n    if showCommand:\n      cmdAsString = \"\"\n      for s in self.mCommand:\n        if (s == \"\") or (s.find (\" \") >= 0):\n          cmdAsString += '\"' + s + '\" '\n        else:\n          cmdAsString += s + ' '\n      print cmdAsString\n    displayLock.release ()\n    thread = threading.Thread (target=runInThread, args=(self, displayLock, terminationSemaphore))\n    thread.start()\n\n#*\n#   class Rule                                                                                                         *\n#*\n\nclass Rule:\n  mTargets = []\n  mDependences = []\n  mCommand = []\n  mSecondaryMostRecentModificationDate = 0.0 # Far in the past\n  mTitle = \"\"\n  mPostCommands = []\n  mPriority = 0\n  mDeleteTargetOnError = False # No operation on error\n  mCleanOperation = 0 # No operation on clean\n  mOpenSourceOnError = False # Do not try to open source file on error\n\n  #*\n\n  def __init__ (self, targets, title = \"\"):\n    if not isinstance (targets, types.ListType):\n      print BOLD_RED () + \"*** Rule type instanciation: first argument 'targets' is not a list ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    else:\n      for aTarget in targets:\n        if not isinstance (aTarget, types.StringTypes):\n          print BOLD_RED () + \"*** Rule type instanciation: an element of first argument 'targets' is not a string ***\" + ENDC ()\n          traceback.print_stack ()\n          sys.exit (1)\n    if not isinstance (title, types.StringTypes):\n      print BOLD_RED () + \"*** Rule type instanciation: second argument 'title' is not a string ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    self.mTargets = copy.deepcopy (targets)\n    self.mDependences = []\n    self.mCommand = []\n    self.mSecondaryMostRecentModificationDate = 0.0\n    self.mPostCommands = []\n    self.mPriority = 0\n    self.mDeleteTargetOnError = False # No operation on error\n    self.mOpenSourceOnError = False # Do not try to open source file on error\n    self.mCleanOperation = 0 # No operation on clean\n    if title == \"\":\n      self.mTitle = \"Building\"\n      for s in targets:\n        self.mTitle += \" \" + s\n    else:\n      self.mTitle = copy.deepcopy (title)\n\n  #*\n\n  def deleteTargetFileOnClean (self):\n    self.mCleanOperation = 1\n\n  #*\n\n  def deleteTargetDirectoryOnClean (self):\n    self.mCleanOperation = 2\n\n  #*\n\n  def enterSecondaryDependanceFile (self, secondaryDependanceFile, make):\n    if not isinstance (secondaryDependanceFile, types.StringTypes):\n      print BOLD_RED () + \"*** Rule.enterSecondaryDependanceFile: 'secondaryDependanceFile' argument is not a string ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    if make.mSelectedGoal != \"clean\":\n      filePath = os.path.abspath (secondaryDependanceFile)\n      if not os.path.exists (filePath):\n        self.mSecondaryMostRecentModificationDate = sys.float_info.max # Very far in future\n      else:\n        f = open (filePath, \"r\")\n        s = f.read ()\n        f.close ()\n        s = s.replace (\"\\\\ \", \"\\x01\") # Replace escaped spaces by \\0x01\n        s = s.replace (\"\\\\\\n\", \"\") # Suppress \\ at the end of lines\n        liste = s.split (\"\\n\\n\")\n        for s in liste:\n          components = s.split (':')\n          target = components [0].replace (\"\\x01\", \" \")\n          #print \"------- Optional dependency rules for target '\" + target + \"'\"\n          #print \"Secondary target '\" + target + \"'\"\n          for src in components [1].split ():\n            secondarySource = src.replace (\"\\x01\", \" \")\n            #print \"  '\" + secondarySource + \"'\"\n            modifDate = modificationDateForFile (make.mModificationDateDictionary, secondarySource)\n            if self.mSecondaryMostRecentModificationDate < modifDate :\n              self.mSecondaryMostRecentModificationDate = modifDate\n              #print BOLD_BLUE () + str (modifDate) + ENDC ()\n\n#*\n#   class Make                                                                                                         *\n#*\n\nclass Make:\n  mRuleList = []\n  mJobList = []\n  mErrorCount = 0\n  mModificationDateDictionary = {}\n  mGoals = {}\n  mSelectedGoal = \"\"\n  mLinuxTextEditor = \"\"\n  mMacTextEditor = \"\"\n  mSimulateClean = False\n  mLogUtilityTool = True\n  mShowProgressString = True\n\n  #*\n\n  def __init__ (self, goal, logUtilityTool=False):\n    if not isinstance (goal, types.StringTypes):\n      print BOLD_RED () + \"*** Make instanciation: 'goal' argument is not a string ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    self.mRuleList = []\n    self.mJobList = []\n    self.mErrorCount = 0\n    self.mModificationDateDictionary = {}\n    self.mGoals = {}\n    self.mSelectedGoal = goal\n    self.mLinuxTextEditor = \"gEdit\"\n    self.mMacTextEditor = \"TextEdit\"\n    self.mLogUtilityTool = logUtilityTool\n\n  #*\n\n  def doNotShowProgressString (self) :\n     self.mShowProgressString = False\n\n  #*\n\n  def addRule (self, rule):\n    if not isinstance (rule, Rule):\n      print BOLD_RED () + \"*** Make.addRule: 'rule' argument is not an instance of Rule type ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    self.mRuleList.append (copy.deepcopy (rule))\n\n  #*\n\n  def printRules (self):\n    print BOLD_BLUE () + \"--- Print \" + str (len (self.mRuleList)) + \" rule\" + (\"s\" if len (self.mRuleList) > 1 else \"\") + \" ---\" + ENDC ()\n    for rule in self.mRuleList:\n      message = \"\"\n      for s in rule.mTargets:\n        message += \" \\\"\" + s + \"\\\"\"\n      print BOLD_GREEN () + \"Target:\" + message +  ENDC ()\n      for dep in rule.mDependences:\n        print \"  Dependence: \\\"\" + dep + \"\\\"\"\n      s = \"  Command: \"\n      for cmd in rule.mCommand:\n        s += \" \\\"\" + cmd + \"\\\"\"\n      print s\n      print \"  Title: \\\"\" + rule.mTitle + \"\\\"\"\n      print \"  Delete target on error: \" + (\"yes\" if rule.mDeleteTargetOnError else \"no\")\n      cleanOp = \"none\"\n      if rule.mCleanOperation == 1:\n        cleanOp = \"delete target file(s)\"\n      elif rule.mCleanOperation == 2:\n        dirSet = set ()\n        for s in rule.mTargets:\n          path = os.path.dirname (s)\n          if path != \"\":\n            dirSet.add (path)\n        cleanOp = \"delete target directory:\"\n        for s in dirSet:\n          cleanOp += \" \\\"\" + s + \"\\\"\"\n      print \"  Clean operation: \" + cleanOp\n      index = 0\n      for postCommand in rule.mPostCommands:\n         index = index + 1\n         s = \"  Post command \" + str (index) + \": \"\n         for cmd in postCommand.mCommand:\n           s += \" \\\"\" + cmd + \"\\\"\"\n         print s\n         print \"    Title: \\\"\" + postCommand.mTitle + \"\\\"\"\n\n    print BOLD_BLUE () + \"--- End of print rule ---\" + ENDC ()\n\n  #*\n\n  def writeRuleDependancesInDotFile (self, dotFileName):\n    s = \"digraph G {\\n\"\n    s += \"  node [fontname=courier]\\n\"\n    arrowSet = set ()\n    for rule in self.mRuleList:\n      for target in rule.mTargets:\n        s += '  \"' + target + '\" [shape=rectangle]\\n'\n        for dep in rule.mDependences:\n          arrowSet.add ('  \"' + target + '\" -> \"' + dep + '\"\\n')\n    for arrow in arrowSet:\n      s += arrow\n    s += \"}\\n\"\n    f = open (dotFileName, \"w\")\n    f.write (s)\n    f.close ()\n\n  #*\n\n  def checkRules (self):\n    if self.mErrorCount == 0:\n      ruleList = copy.deepcopy (self.mRuleList)\n      index = 0\n      looping = True\n    #--- loop on rules\n      while looping:\n        looping = False\n        while index < len (ruleList):\n          aRule = ruleList [index]\n          index = index + 1\n        #--- Check dependance files have rule for building, or does exist\n          depIdx = 0\n          while depIdx < len (aRule.mDependences):\n            dep = aRule.mDependences [depIdx]\n            depIdx = depIdx + 1\n            hasBuildRule = False\n            for r in ruleList:\n              for target in r.mTargets:\n                if dep == target:\n                  hasBuildRule = True\n                  break\n            if not hasBuildRule:\n              looping = True\n              if not os.path.exists (os.path.abspath (dep)):\n                self.mErrorCount = self.mErrorCount + 1\n                print BOLD_RED () + \"Check rules error: '\" + dep + \"' does not exist, and there is no rule for building it.\" + ENDC ()\n              depIdx = depIdx - 1\n              aRule.mDependences.pop (depIdx)\n        #--- Rule with no dependances\n          if len (aRule.mDependences) == 0 :\n            looping = True\n            index = index - 1\n            ruleList.pop (index)\n            idx = 0\n            while idx < len (ruleList):\n              r = ruleList [idx]\n              idx = idx + 1\n              for target in aRule.mTargets:\n                while r.mDependences.count (target) > 0 :\n                  r.mDependences.remove (target)\n    #--- Error if rules remain\n      if len (ruleList) > 0:\n        self.mErrorCount = self.mErrorCount + 1\n        print BOLD_RED () + \"Check rules error; circulary dependances between:\" + ENDC ()\n        for aRule in ruleList:\n          targetList = \"\"\n          for target in aRule.mTargets:\n            targetList += \" '\" + aRule.mTarget + \"'\"\n          print BOLD_RED () + \"  - \" + targetList + \", depends from:\" + ENDC ()\n          for dep in aRule.mDependences:\n            print BOLD_RED () + \"      '\" + dep + \"'\" + ENDC ()\n\n  #*\n\n  def existsJobForTarget (self, target):\n    for job in self.mJobList:\n      for aTarget in job.mTargets:\n        if aTarget == target:\n          return True\n    return False\n\n  #*\n\n  def makeJob (self, target): # Return a bool indicating wheither the target should be built\n  #--- If there are errors, return immediatly\n    if self.mErrorCount != 0:\n      return False\n  #--- Target already in job list \?\n    if self.existsJobForTarget (target):\n      return True # yes, return target will be built\n  #--- Find a rule for making the target\n    absTarget = os.path.abspath (target)\n    rule = None\n    matchCount = 0\n    for r in self.mRuleList:\n      for aTarget in r.mTargets:\n        if target == aTarget:\n          matchCount = matchCount + 1\n          rule = r\n    if matchCount == 0:\n      absTarget = os.path.abspath (target)\n      if not os.path.exists (absTarget):\n        print BOLD_RED () + \"No rule for making '\" + target + \"'\" + ENDC ()\n        self.mErrorCount = self.mErrorCount + 1\n      return False # Error or target exists, and no rule for building it\n    elif matchCount > 1:\n      print BOLD_RED () + str (matchCount) + \" rules for making '\" + target + \"'\" + ENDC ()\n      self.mErrorCount = self.mErrorCount + 1\n      return False # Error\n  #--- Target file does not exist, and 'rule' variable indicates how build it\n    appendToJobList = not os.path.exists (absTarget)\n  #--- Build primary dependences\n    jobDependenceFiles = []\n    for dependence in rule.mDependences:\n      willBeBuilt = self.makeJob (dependence)\n      if willBeBuilt:\n        jobDependenceFiles.append (dependence)\n        appendToJobList = True\n  #--- Check primary file modification dates\n    if not appendToJobList:\n      targetDateModification = os.path.getmtime (absTarget)\n      for source in rule.mDependences:\n        sourceDateModification = os.path.getmtime (source)\n        if targetDateModification < sourceDateModification:\n          appendToJobList = True\n          break\n  #--- Check for secondary dependancy files\n    if not appendToJobList:\n      targetDateModification = os.path.getmtime (absTarget)\n      if targetDateModification < rule.mSecondaryMostRecentModificationDate:\n        appendToJobList = True\n  #--- Append to job list\n    if appendToJobList:\n      self.mJobList.append (Job (\n        rule.mTargets,\n        jobDependenceFiles,\n        rule.mCommand,\n        rule.mPostCommands,\n        rule.mPriority,\n        rule.mTitle,\n        rule.mOpenSourceOnError,\n        self.mLogUtilityTool\n      ))\n  #--- Return\n    return appendToJobList\n\n  #*\n  #Job state\n  # 0: waiting\n  # 1:running\n  # 2: waiting for executing post command\n  # 3:executing for executing post command\n  # 4: completed\n\n  def runJobs (self, maxConcurrentJobs, showCommand):\n    if self.mErrorCount == 0:\n      if len (self.mJobList) == 0:\n        print BOLD_BLUE () + \"Nothing to make.\" + ENDC ()\n      else:\n      #--- Sort jobs following their priorities\n        self.mJobList = sorted (self.mJobList, key=operator.attrgetter(\"mPriority\"), reverse=True)\n      #--- Run\n        if maxConcurrentJobs <= 0:\n          maxConcurrentJobs = processorCount () - maxConcurrentJobs\n        jobCount = 0 ;\n        terminationSemaphore = threading.Semaphore (0)\n        displayLock = threading.Lock ()\n        loop = True\n        returnCode = 0\n        totalJobCount = float (len (self.mJobList))\n        launchedJobCount = 0.0\n        while loop:\n        #--- Launch jobs in parallel\n          for job in self.mJobList:\n            if (returnCode == 0) and (jobCount < maxConcurrentJobs):\n              if (job.mState == 0) and (len (job.mRequiredFiles) == 0):\n                #--- Create target directory if does not exist\n                for aTarget in job.mTargets:\n                  absTargetDirectory = os.path.dirname (os.path.abspath (aTarget))\n                  if not os.path.exists (absTargetDirectory):\n                    displayLock.acquire ()\n                    runCommand (\n                      [\"mkdir\", \"-p\", os.path.dirname (aTarget)], \"Making \\\"\" + os.path.dirname (aTarget) + \"\\\" directory\",\n                      showCommand,\n                      job.mLogUtilityTool\n                    )\n                    displayLock.release ()\n                #--- Progress string\n                launchedJobCount += 1.0\n                if self.mShowProgressString:\n                  progressString = \"[{0:3d}%] \".format (int (100.0 * launchedJobCount / totalJobCount))\n                else:\n                  progressString = \"\"\n                #--- Run job\n                job.run (displayLock, terminationSemaphore, showCommand, progressString)\n                jobCount = jobCount + 1\n                job.mState = 1 # Means is running\n              elif job.mState == 2: # Waiting for executing post command\n                job.mReturnCode = None # Means post command not terminated\n                job.runPostCommand (displayLock, terminationSemaphore, showCommand)\n                jobCount = jobCount + 1\n                job.mState = 3 # Means post command is running\n        #--- Wait for a job termination\n          #print \"wait \" + str (jobCount) + \" \" + str (len (self.mJobList))\n          terminationSemaphore.acquire ()\n        #--- Checks for terminated jobs\n          index = 0\n          while index < len (self.mJobList):\n            job = self.mJobList [index]\n            index = index + 1\n            if (job.mState == 1) and (job.mReturnCode == 0) : # Terminated without error\n              jobCount = jobCount - 1\n              for aTarget in job.mTargets:\n                if not os.path.exists (os.path.abspath (aTarget)): # Warning: target does not exist\n                  displayLock.acquire ()\n                  print MAGENTA () + BOLD () + \"Warning: target \\\"\" + aTarget + \"\\\" was not created by rule execution.\" + ENDC ()\n                  displayLock.release ()\n              if len (job.mPostCommands) > 0:\n                job.mState = 2 # Ready to execute next post command\n              else:\n                job.mState = 4 # Completed\n                index = index - 1 # For removing job from list\n            elif (job.mState == 1) and (job.mReturnCode > 0) : # terminated with error : exit\n              jobCount = jobCount - 1\n              job.mState = 4 # Means Terminated\n              index = index - 1 # For removing job from list\n              if job.mOpenSourceOnError:\n                for line in job.mOutputLines:\n                  components = line.split (':')\n                  if (len (components) > 1) and os.path.exists (os.path.abspath (components [0])) :\n                    if sys.platform == \"darwin\":\n                      os.system (\"open -a \\\"\" + self.mMacTextEditor + \"\\\" \\\"\" + components [0] + \"\\\"\")\n                    elif sys.platform == \"linux2\":\n                      os.system (\"\\\"\" + self.mLinuxTextEditor + \"\\\" \\\"\" + components [0] + \"\\\"\")\n            elif (job.mState == 3) and (job.mReturnCode == 0): # post command is terminated without error\n              jobCount = jobCount - 1\n              job.mPostCommands.pop (0) # Remove completed post command\n              if len (job.mPostCommands) > 0:\n                job.mState = 2 # Ready to execute next post command\n              else:\n                job.mState = 4 # Completed\n                index = index - 1 # For removing job from list\n            elif (job.mState == 3) and (job.mReturnCode > 0): # post command is terminated with error\n              jobCount = jobCount - 1\n              job.mState = 4 # Completed\n              index = index - 1 # For removing job from list\n            elif job.mState == 4: # Completed: delete job\n              index = index - 1\n              self.mJobList.pop (index) # Remove terminated job\n              #displayLock.acquire ()\n              #print \"Completed '\" + job.mTitle + \"'\"\n              #--- Remove dependences from this job\n              idx = 0\n              while idx < len (self.mJobList):\n                aJob = self.mJobList [idx]\n                idx = idx + 1\n                for aTarget in job.mTargets:\n                  while aJob.mRequiredFiles.count (aTarget) > 0 :\n                    aJob.mRequiredFiles.remove (aTarget)\n                  #print \"  Removed from '\" + aJob.mTitle + \"': \" + str (len (aJob.mRequiredFiles))\n              #displayLock.release ()\n              #--- Signal error \?\n              if (job.mReturnCode > 0) and (returnCode == 0):\n                self.mErrorCount = self.mErrorCount + 1\n                print BOLD_RED () + \"Return code: \" + str (job.mReturnCode) + ENDC ()\n                if (returnCode == 0) and (jobCount > 0) :\n                  print \"Wait for job termination...\"\n                returnCode = job.mReturnCode\n          loop = (len (self.mJobList) > 0) if (returnCode == 0) else (jobCount > 0)\n\n  #*\n\n  def searchFileInDirectories (self, file, directoryList): # returns \"\" if not found, register error\n    matchCount = 0\n    result = \"\"\n    for sourceDir in directoryList:\n      sourcePath = sourceDir + \"/\" + file\n      if os.path.exists (os.path.abspath (sourcePath)):\n        matchCount = matchCount + 1\n        result = sourcePath\n    if matchCount == 0:\n      print BOLD_RED () + \"Cannot find '\" + file + \"'\" + ENDC ()\n      self.mErrorCount = self.mErrorCount + 1\n    elif matchCount > 1:\n      print BOLD_RED () + str (matchCount) + \" source files for making '\" + file + \"'\" + ENDC ()\n      self.mErrorCount = self.mErrorCount + 1\n      result = \"\"\n    return result\n\n  #*\n\n  def addGoal (self, goal, targetList, message):\n    if not isinstance (goal, types.StringTypes):\n      print BOLD_RED () + \"*** Make.addGoal: 'goal' first argument is not a string ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    if not isinstance (targetList, types.ListType):\n      print BOLD_RED () + \"*** Make.addGoal: 'targetList' second argument is not a list ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    else:\n      for aTarget in targetList:\n        if not isinstance (aTarget, types.StringTypes):\n          print BOLD_RED () + \"*** Make.addGoal: an element of 'targetList' second argument 'targets' is not a string ***\" + ENDC ()\n          traceback.print_stack ()\n          sys.exit (1)\n    if not isinstance (message, types.StringTypes):\n      print BOLD_RED () + \"*** Make.addGoal: 'message' third argument is not a string ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    if self.mGoals.has_key (goal) or (goal == \"clean\") :\n      self.enterError (\"The '\" + goal + \"' goal is already defined\")\n    else:\n      self.mGoals [goal] = (targetList, message)\n    #print '%s' % ', '.join(map(str, self.mGoals))\n\n  #*\n\n  def printGoals (self):\n    print BOLD_BLUE () + \"--- Print \" + str (len (self.mGoals)) + \" goal\" + (\"s\" if len (self.mGoals) > 1 else \"\") + \" ---\" + ENDC ()\n    for goalKey in self.mGoals.keys ():\n      print BOLD_GREEN () + \"Goal: \\\"\" + goalKey + \"\\\"\" + ENDC ()\n      (targetList, message) = self.mGoals [goalKey]\n      for target in targetList:\n        print \"  Target: \\\"\" + target + \"\\\"\"\n      print \"  Message: \\\"\" + message + \"\\\"\"\n\n    print BOLD_BLUE () + \"--- End of print goals ---\" + ENDC ()\n\n  #*\n\n  def runGoal (self, maxConcurrentJobs, showCommand):\n    if not isinstance (maxConcurrentJobs, types.IntType):\n      print BOLD_RED () + \"*** Make.runGoal: 'maxConcurrentJobs' first argument is not an integer ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    if not isinstance (showCommand, types.BooleanType):\n      print BOLD_RED () + \"*** Make.runGoal: 'showCommand' second argument is not a boolean ***\" + ENDC ()\n      traceback.print_stack ()\n      sys.exit (1)\n    if self.mGoals.has_key (self.mSelectedGoal) :\n      (targetList, message) = self.mGoals [self.mSelectedGoal]\n      for target in targetList:\n        self.makeJob (target)\n      self.runJobs (maxConcurrentJobs, showCommand)\n      if self.mErrorCount > 0:\n        for rule in self.mRuleList:\n          for aTarget in rule.mTargets:\n            if rule.mDeleteTargetOnError and os.path.exists (os.path.abspath (aTarget)):\n              runCommand ([\"rm\", aTarget], \"Delete \\\"\" + aTarget + \"\\\" on error\", showCommand, self.mLogUtilityTool)\n    elif self.mSelectedGoal == \"clean\" :\n      filesToRemoveList = []\n      directoriesToRemoveSet = set ()\n      for rule in self.mRuleList:\n        if rule.mCleanOperation == 1: # Delete target\n          for aTarget in rule.mTargets:\n            filesToRemoveList.append (aTarget)\n        elif rule.mCleanOperation == 2: # Delete target directories\n          for aTarget in rule.mTargets:\n            dirPath = os.path.dirname (aTarget)\n            if dirPath == \"\":\n              filesToRemoveList.append (aTarget)\n            else:\n              directoriesToRemoveSet.add (dirPath)\n      for dir in directoriesToRemoveSet:\n        if os.path.exists (os.path.abspath (dir)):\n          if self.mSimulateClean:\n            print MAGENTA () + BOLD () + \"Simulated clean command: \" + ENDC () + \"rm -fr '\" + dir + \"'\"\n          else:\n            runCommand ([\"rm\", \"-fr\", dir], \"Removing \\\"\" + dir + \"\\\"\", showCommand, self.mLogUtilityTool)\n      for file in filesToRemoveList:\n        if os.path.exists (os.path.abspath (file)):\n          if self.mSimulateClean:\n            print MAGENTA () + BOLD () + \"Simulated clean command: \" + ENDC () + \"rm -f '\" + file + \"'\"\n          else:\n            runCommand ([\"rm\", \"-f\", file], \"Deleting \\\"\" + file + \"\\\"\", showCommand, self.mLogUtilityTool)\n    else:\n      errorMessage = \"The '\" + self.mSelectedGoal + \"' goal is not defined; defined goals:\"\n      for key in self.mGoals:\n        (targetList, message) = self.mGoals [key]\n        errorMessage += \"\\n  '\" + key + \"': \" + message\n      print BOLD_RED () + errorMessage + ENDC ()\n      self.mErrorCount = self.mErrorCount + 1\n\n  #*\n\n  def simulateClean (self):\n    self.mSimulateClean = True\n\n  #*\n\n  def enterError (self, message):\n    print BOLD_RED () + message + ENDC ()\n    self.mErrorCount = self.mErrorCount + 1\n\n  #*\n\n  def printErrorCountAndExitOnError (self):\n    if self.mErrorCount == 1:\n      print BOLD_RED () + \"1 error.\" + ENDC ()\n      sys.exit (1)\n    elif self.mErrorCount > 1:\n      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n      sys.exit (1)\n\n  #*\n\n  def printErrorCount (self):\n    if self.mErrorCount == 1:\n      print BOLD_RED () + \"1 error.\" + ENDC ()\n    elif self.mErrorCount > 1:\n      print BOLD_RED () + str (self.mErrorCount) + \" errors.\" + ENDC ()\n\n  #*\n\n  def errorCount (self):\n    return self.mErrorCount\n\n#*\n" ;

const cRegularFileWrapper gWrapperFile_22_targetTemplates (
  "py-makefile.txt",
  "txt",
  true, // Text file
  40349, // Text length
  gWrapperFileContent_22_targetTemplates
) ;

//--- File '/py-objdump.txt'

const char * gWrapperFileContent_30_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport subprocess\nimport sys\nimport os\nimport atexit\n\n#------------------------------------------------------------------------------*\n\ndef cleanup():\n  if childProcess.poll () == None :\n    childProcess.kill ()\n\n#------------------------------------------------------------------------------*\n\n#--- Register a function for killing subprocess\natexit.register (cleanup)\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\nos.chdir (scriptDir)\n#---\nchildProcess = subprocess.Popen ([\"python\", \"build.py\", \"object-dump\"])\n#--- Wait for subprocess termination\nif childProcess.poll () == None :\n  childProcess.wait ()\nif childProcess.returncode != 0 :\n  sys.exit (childProcess.returncode)\n\n#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_30_targetTemplates (
  "py-objdump.txt",
  "txt",
  true, // Text file
  1006, // Text length
  gWrapperFileContent_30_targetTemplates
) ;

//--- File '/py-objsize.txt'

const char * gWrapperFileContent_29_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport subprocess\nimport sys\nimport os\nimport atexit\n\n#------------------------------------------------------------------------------*\n\ndef cleanup():\n  if childProcess.poll () == None :\n    childProcess.kill ()\n\n#------------------------------------------------------------------------------*\n\n#--- Register a function for killing subprocess\natexit.register (cleanup)\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\nos.chdir (scriptDir)\n#---\nchildProcess = subprocess.Popen ([\"python\", \"build.py\", \"display-object-size\"])\n#--- Wait for subprocess termination\nif childProcess.poll () == None :\n  childProcess.wait ()\nif childProcess.returncode != 0 :\n  sys.exit (childProcess.returncode)\n\n#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_29_targetTemplates (
  "py-objsize.txt",
  "txt",
  true, // Text file
  1014, // Text length
  gWrapperFileContent_29_targetTemplates
) ;

//--- File '/py-omnibus.txt'

const char * gWrapperFileContent_19_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport sys, os, subprocess, urllib\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport makefile\n\n#----------------------------------------------------------------------------------------------------------------------*\n#   Run process and wait for termination                                                                               *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef runProcess (command) :\n  childProcess = subprocess.Popen (command)\n#--- Wait for subprocess termination\n  if childProcess.poll () == None :\n    childProcess.wait ()\n  if childProcess.returncode != 0 :\n    print makefile.BOLD_RED () + \"Error \" + str (childProcess.returncode) + makefile.ENDC ()\n    sys.exit (childProcess.returncode)\n\n#----------------------------------------------------------------------------------------------------------------------*\n#   Run process, get output and wait for termination                                                                   *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef runProcessAndGetOutput (command) :\n  result = \"\"\n  childProcess = subprocess.Popen (command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n  while True:\n    out = childProcess.stdout.read(1)\n    if out == '' and childProcess.poll() != None:\n      break\n    if out != '':\n      result += out\n#--- Wait for subprocess termination\n  if childProcess.poll () == None :\n    childProcess.wait ()\n  if childProcess.returncode != 0 :\n    print makefile.BOLD_RED () + \"Error \" + str (childProcess.returncode) + makefile.ENDC ()\n    sys.exit (childProcess.returncode)\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#   ARCHIVE DOWNLOAD                                                                                                   *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndownloadProgression = 0.0\n\ndef downloadReportHook (a, b, fileSize) :\n  global downloadProgression\n  newProgression = min (100.0, float(a * b) / fileSize * 100.0)\n  if newProgression > downloadProgression :\n    downloadProgression = downloadProgression + 1.0\n    sys.stdout.write(\".\")\n    sys.stdout.flush()\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef downloadArchive (archiveURL, archivePath):\n  global downloadProgression\n  downloadProgression = 0.0\n  makefile.runHiddenCommand ([\"rm\", \"-f\", archivePath + \".downloading\"])\n  makefile.runHiddenCommand ([\"rm\", \"-f\", archivePath + \".tar.bz2\"])\n  makefile.runHiddenCommand ([\"mkdir\", \"-p\", os.path.dirname (archivePath)])\n  #print \"URL: \"+ archiveURL\n  #print \"Downloading... \" + archivePath + \".downloading\"\n  try:\n    urllib.urlretrieve (archiveURL,  archivePath + \".downloading\", downloadReportHook)\n    print \"\"\n    fileSize = os.path.getsize (archivePath + \".downloading\")\n    ok = fileSize > 1000000\n    if ok:\n      makefile.runHiddenCommand ([\"mv\", archivePath + \".downloading\", archivePath + \".tar.bz2\"])\n    else:\n      print makefile.BOLD_RED () + \"Error: cannot download file\" + makefile.ENDC ()\n      sys.exit (1)\n  except:\n    print makefile.BOLD_RED () + \"Error: no network connection\" + makefile.ENDC ()\n    sys.exit (1)\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef runMakefile (toolDirectory, archiveBaseURL, LLVMsourceList, assemblerSourceList, \\\n                 objectDir, LLCcompiler, llvmOptimizerCompiler, \\\n                 asAssembler, \\\n                 productDir, linker, linkerScripts, linkerLibraries, objcopy, \\\n                 dumpObjectCode, displayObjectSize, runExecutableOnTarget, \\\n                 CLANGcompiler, CsourceList, LLVMLinkerCompiler, \\\n                 currentFile, arm_stack_computations, check_stack_utility) :\n  #--- Get max parallel jobs as first argument\n  goal = \"all\"\n  if len (sys.argv) > 1 :\n    goal = sys.argv [1]\n  #--- Get max parallel jobs as first argument\n  maxParallelJobs = 0 # 0 means use host processor count\n  if len (sys.argv) > 2 :\n    maxParallelJobs = int (sys.argv [2])\n  #--- Get script absolute path\n  scriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\n  #--- Download compiler tool if needed\n  if not os.path.exists (toolDirectory):\n    print makefile.BOLD_GREEN () + \"Downloading compiler tool chain\" + makefile.ENDC ()\n    archiveName = os.path.basename (toolDirectory)\n    archiveURL = archiveBaseURL + archiveName + \".tar.bz2\"\n    downloadArchive (archiveURL, toolDirectory)\n    installDir = os.path.normpath (toolDirectory + \"/..\")\n    os.chdir (installDir)\n    makefile.runHiddenCommand ([\"bunzip2\", \"-k\", archiveName + \".tar.bz2\"])\n    makefile.runHiddenCommand ([\"rm\", archiveName + \".tar.bz2\"])\n    makefile.runHiddenCommand ([\"tar\", \"xf\", archiveName + \".tar\"])\n    makefile.runHiddenCommand ([\"rm\", archiveName + \".tar\"])\n  #---\n  os.chdir (scriptDir)\n  #print \"Product directory: \" + scriptDir\n  #--- Build python makefile\n  make = makefile.Make (goal, maxParallelJobs == 1) # Display command utility tool if sequential build\n  #---------------------------------------------- Add C files compile rule\n  llvmSourceFileList = []\n  for source in CsourceList:\n  #--- Compile C --> LLVM\n    llvmSource = objectDir + \"/\" + source + \".ll\"\n    rule = makefile.Rule ([llvmSource], \"Compiling \" + source)\n    rule.mDependences.append (\"sources/\" + source)\n    rule.mDependences.append (currentFile)\n    rule.mCommand += CLANGcompiler\n    rule.mCommand += [\"-emit-llvm\", \"-S\"]\n    rule.mCommand += [\"sources/\" + source]\n    rule.mCommand += [\"-o\", llvmSource]\n    make.addRule (rule)\n    llvmSourceFileList.append (source + \".ll\")\n  #---------------------------------------------- LLVM Linking\n  llvmLinkedSource = objectDir + \"/all.ll\"\n  title = \"LLVM Link\"\n  for source in LLVMsourceList:\n    title += \" sources/\" + source\n  for source in llvmSourceFileList:\n    title += \" \" + objectDir + \"/\" + source\n  rule = makefile.Rule ([llvmLinkedSource], title)\n  rule.mCommand += LLVMLinkerCompiler\n  rule.mDependences.append (currentFile)\n  for source in LLVMsourceList:\n    rule.mCommand += [\"sources/\" + source]\n    rule.mDependences.append (\"sources/\" + source)\n  for source in llvmSourceFileList:\n    rule.mCommand += [objectDir + \"/\" + source]\n    rule.mDependences.append (objectDir + \"/\" + source)\n  rule.mCommand += [\"-o\", llvmLinkedSource]\n  make.addRule (rule)\n  LLVMsourceList = [\"all.ll\"]\n  #---------------------------------------------- Add LLVM files compile rule\n  objectList = []\n  for source in LLVMsourceList:\n  #--- Optimize LLVM source\n    optimizedSource = objectDir + \"/opt.\" + source\n    rule = makefile.Rule ([optimizedSource], \"Optimizing \" + source)\n    rule.mDependences.append (objectDir + \"/\" + source)\n    rule.mDependences.append (currentFile)\n    rule.mCommand += llvmOptimizerCompiler\n    rule.mCommand += [objectDir + \"/\" + source]\n    rule.mCommand += [\"-o\", optimizedSource]\n    make.addRule (rule)\n  #--- Compile optimized LLVM source\n    asSource = objectDir + \"/opt.\" + source + \".s\"\n    rule = makefile.Rule ([asSource], \"Compiling \" + optimizedSource)\n    rule.mDependences.append (optimizedSource)\n    rule.mCommand += LLCcompiler\n    rule.mCommand += [optimizedSource]\n    rule.mCommand += [\"-o\", asSource]\n    make.addRule (rule)\n  #--- Assembling\n    asObject = objectDir + \"/opt.\" + source + \".s.o\"\n    listingFile = objectDir + \"/opt.\" + source + \".s.list\"\n    rule = makefile.Rule ([asObject, listingFile], \"Assembling \" + asSource)\n    rule.mDependences.append (asSource)\n    rule.mCommand += asAssembler\n    rule.mCommand += [asSource]\n    rule.mCommand += [\"-o\", asObject]\n    rule.mCommand += [\"-aln=\" + listingFile]\n    make.addRule (rule)\n    objectList.append (asObject)\n  #---------------------------------------------- Add assembler files compile rule\n  for source in assemblerSourceList:\n    object = objectDir + \"/\" + source + \".o\"\n    listingFile = objectDir + \"/opt.\" + source + \".list\"\n    rule = makefile.Rule ([object, listingFile], \"Assembling \" + source)\n    rule.mDependences.append (\"sources/\" + source)\n    rule.mCommand += asAssembler\n    rule.mCommand += [\"sources/\" + source]\n    rule.mCommand += [\"-o\", object]\n    rule.mCommand += [\"-aln=\" + listingFile]\n    make.addRule (rule)\n    objectList.append (object)\n  #---------------------------------------------- Add linker rule\n  for lkScript in linkerScripts:\n    productELF = productDir + \"/product-\" + lkScript + \".elf\"\n    rule = makefile.Rule ([productELF], \"Linking \" + productELF)\n    rule.mDependences += objectList\n    rule.mCommand += linker\n    rule.mCommand += objectList\n    for library in linkerLibraries:\n      rule.mCommand += [toolDirectory + \"/libgcc/\" + library]\n    rule.mCommand += [\"-o\", productELF]\n    rule.mCommand += [\"-Tsources/\" + lkScript + \".ld\"]\n    rule.mDependences += [\"sources/\" + lkScript + \".ld\"]\n    rule.mCommand += [\"-Map=\" + productELF + \".map\"]\n    make.addRule (rule)\n    #--- Add objcopy rule\n    productHEX = productDir + \"/product.ihex\"\n    rule = makefile.Rule ([productHEX], \"Hexing \" + productHEX)\n    rule.mDependences += [productELF]\n    rule.mCommand += objcopy\n    rule.mCommand += [\"-O\", \"ihex\"]\n    rule.mCommand += [productELF]\n    rule.mCommand += [productHEX]\n    make.addRule (rule)\n  #---------------------------------------------- Add stack computation rule\n#  stackComputationResultFile = objectDir + \"/stack-computations.json\"\n#  rule = makefile.Rule ([stackComputationResultFile], \"Stack requirements\")\n#  rule.mCommand += arm_stack_computations\n#  for source in assemblerSourceList:\n#    rule.mDependences.append (\"sources/\" + source)\n#    rule.mCommand += [\"sources/\" + source]\n#  for source in LLVMsourceList:\n#    src = objectDir + \"/opt.\" + source + \".s\"\n#    rule.mDependences.append (src)\n#    rule.mCommand += [src]\n#  rule.mCommand += [\"-o\", stackComputationResultFile]\n#  make.addRule (rule)\n  #---------------------------------------------- Add stacks check rule\n#  checkStackResultFile = productDir + \"/check-stacks-result.txt\"\n#  rule = makefile.Rule ([checkStackResultFile], \"Check stacks\")\n#  rule.mCommand.append (\"python\")\n#  rule.mCommand += check_stack_utility\n#  rule.mDependences.append (\"sources/provided-stacks.json\")\n#  rule.mCommand += [\"sources/provided-stacks.json\"]\n#  rule.mDependences.append (stackComputationResultFile)\n#  rule.mCommand += [stackComputationResultFile]\n#  rule.mCommand += [checkStackResultFile]\n#  make.addRule (rule)\n  #---------------------------------------------- Add goals\n#  make.addGoal (\"run\", [productHEX, checkStackResultFile], \"Building all and run\")\n#  make.addGoal (\"all\", [productHEX, checkStackResultFile], \"Building all\")\n#  make.addGoal (\"display-object-size\", [productHEX, checkStackResultFile], \"Display Object Size\")\n#  make.addGoal (\"object-dump\", [productHEX, checkStackResultFile], \"Dump Object Code\")\n  make.addGoal (\"run\", [productHEX], \"Building all and run\")\n  make.addGoal (\"all\", [productHEX], \"Building all\")\n  make.addGoal (\"display-object-size\", [productHEX], \"Display Object Size\")\n  make.addGoal (\"object-dump\", [productHEX], \"Dump Object Code\")\n  #---------------------------------------------- Build\n  #make.printRules ()\n  make.doNotShowProgressString ()\n  make.runGoal (maxParallelJobs, maxParallelJobs == 1)\n  #---------------------------------------------- Build Ok \?\n  make.printErrorCountAndExitOnError ()\n  #---------------------------------------------- Run or all \? Display size\n  if (goal == \"run\") or (goal == \"all\") :\n    s = runProcessAndGetOutput (displayObjectSize + [productELF])\n    secondLine = s.split('\\n')[1]\n    numbers = [int(s) for s in secondLine.split() if s.isdigit()]\n    print \"Code:        \" + str (numbers [0]) + \" bytes\"\n    print \"ROM data:    \" + str (numbers [1]) + \" bytes\"\n    print \"RAM + STACK: \" + str (numbers [2]) + \" bytes\"\n  #----------------------------------------------- Run \?\n  if goal == \"run\":\n    print makefile.BOLD_BLUE () + \"Loading Teensy...\" + makefile.ENDC ()\n    runProcess (runExecutableOnTarget + [productHEX])\n    print makefile.BOLD_GREEN () + \"Success\" + makefile.ENDC ()\n  elif goal == \"display-object-size\":\n    print makefile.BOLD_BLUE () + \"Display Object Sizes\" + makefile.ENDC ()\n    runProcess (displayObjectSize + objectList)\n    print makefile.BOLD_GREEN () + \"Success\" + makefile.ENDC ()\n  elif goal == \"object-dump\":\n    print makefile.BOLD_BLUE () + \"Dump Object Code\" + makefile.ENDC ()\n    runProcess (dumpObjectCode + [productELF])\n    print makefile.BOLD_GREEN () + \"Success\" + makefile.ENDC ()\n\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_19_targetTemplates (
  "py-omnibus.txt",
  "txt",
  true, // Text file
  13294, // Text length
  gWrapperFileContent_19_targetTemplates
) ;

//--- File '/py-toolpath.txt'

const char * gWrapperFileContent_27_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport os\n\n#----------------------------------------------------------------------------------------------------------------------*\n#   Tool dir                                                                                                           *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef toolDir ():\n  (SYSTEM_NAME, MODE_NAME, RELEASE, VERSION, MACHINE) = os.uname ()\n  if SYSTEM_NAME == \"Darwin\":\n    MACHINE = \"i386\"\n  return os.path.expanduser (\"~/omnibus-tools/omnibus-\" + SYSTEM_NAME + \"-\" + MACHINE + \"-llvm-10.0.1-binutils-2.35-openocd-0.10.0-libusb-1.0.23\")\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_27_targetTemplates (
  "py-toolpath.txt",
  "txt",
  true, // Text file
  950, // Text length
  gWrapperFileContent_27_targetTemplates
) ;

//--- File '/registers-cortex-m4.omnibus-import'

const char * gWrapperFileContent_14_targetTemplates = "\n//\n//! Nested Vectored $interrupt Controller Table 3-4 & ARMv7 ref appendix B3.4 (page 750)\n//\n\nregisters NVIC @at 0xE000_E000 {\n  ISER [4 @offset 0x100 @inc 4] $u32 // $interrupt Set-enable Registers\n\n  ICER [4 @offset 0x180 @inc 4] $u32 //Interrupt Clear-enable Registers\n\n  // 0 = highest priority\n  // Cortex-M4: 0163248648096112128144160176192208224240\n  IPR [128 @offset 0x400 @inc 1] $u8 // $interrupt priority\n//}\n//\n//registers NVIC @at 0xE000_E000 {\n//  ISER [4 @offset  0x100 @inc 4] $u32 // $interrupt Set-enable Registers\n//  ICER [4 @offset  0x180 @inc 4] $u32 //Interrupt Clear-enable Registers\n//  IPR [128 @offset 0x400 @inc 1] $u8 // $interrupt priority\n\n  ICSR @offset 0xD04 $u32 { // $interrupt Control and State\n    NMIPENDSET 2 PENDSVSET PENDSVCLR PENDSTSET PENDSTCLR 1 ISRPREEMPT\n    ISRPENDING 1 VECTPENDING:9 RETTOBASE 2 VECTACTIVE:9\n  }\n\n  VTOR @offset 0xD08 $u32 // Vector Table Offset\n\n  AIRCR @offset 0xD0C $u32 { // Application $interrupt and Reset Control\n    VECTKEY:16 ENDIANNESS 4 PRIGROUP:3\n    5 SYSRESETREQ VECTCLRACTIVE VECTRESET\n  }\n}\n\n//\n//! SCB System Control Space (SCS) ARMv7 ref manual B3.2 page 708\n//\n\nregisters SCB @at 0xE000_E000 {\n  CPUID @offset 0xD00 $u32 // CPUID Base Register\n\n  ICSR @offset 0xD04 $u32 { // $interrupt Control and State\n    NMIPENDSET 2 PENDSVSET PENDSVCLR PENDSTSET PENDSTCLR 1 ISRPREEMPT\n    ISRPENDING 1 VECTPENDING:9 RETTOBASE 2 VECTACTIVE:9\n  }\n\n  VTOR @offset 0xD08 $u32 // Vector Table Offset\n\n  AIRCR @offset 0xD0C $u32 { // Application $interrupt and Reset Control\n    VECTKEY:16 ENDIANNESS 4 PRIGROUP:3\n    5 SYSRESETREQ VECTCLRACTIVE VECTRESET\n  }\n\n  CPACR @offset 0xD88 $u32 // Coprocessor Access Control\n\n  FPCCR @offset 0xF34 $u32 // FP Context Control\n\n  SCR @offset 0xD10 $u32 // System Control Register\n  CCR @offset 0xD14 $u32 // Configuration and Control\n  SHPR1 @offset 0xD18 $u32 // System Handler Priority registers 1\n  SHPR2 @offset 0xD1C $u32 // System Handler Priority registers 2\n  SHPR3 @offset 0xD20 $u32 // System Handler Priority registers 3\n  SHCSR @offset 0xD24 $u32 // System Handler Control and State\n  CFSR @offset 0xD28 $u32 // Configurable Fault Status Register\n  HFSR @offset 0xD2C $u32 // HardFault Status\n  DFSR @offset 0xD30 $u32 // Debug Fault Status\n  MMFAR @offset 0xD34 $u32 // MemManage Fault Address\n}\n\n//\n//! SYSTICK\n//\n\nregisters SYST @at 0xE000_E000 {\n//--- SysTick Control and Status Register\n  CSR @offset 0x010 $u32 {15 COUNTFLAG 13 CLKSOURCE TICKINT ENABLE}\n\n//--- SysTick Reload Value Register\n  RVR @offset 0x014 $u32\n\n//--- SysTick Current Value Register\n  CVR @offset 0x018 $u32\n\n//--- SysTick Calibration Value Register\n  CALIB @offset 0x01C @ro $u32\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_14_targetTemplates (
  "registers-cortex-m4.omnibus-import",
  "omnibus-import",
  true, // Text file
  3518, // Text length
  gWrapperFileContent_14_targetTemplates
) ;

//--- File '/semaphore.omnibus-import'

const char * gWrapperFileContent_12_targetTemplates = "//\n\nsync $Semaphore {\n  var value $u32\n  var list = $TaskList ()\n  var guardList = $GuardList ()\n\n  //\n\n  public service signal @noUnusedWarning @mutating () {\n    makeTaskReady (!\?fromList:self.list \?found:let found)\n    if not found {\n      self.value += 1\n      notifyChange (!\?forGuard:self.guardList)\n    }\n  }\n\n  //\n\n  public primitive wait @noUnusedWarning @mutating () {\n    if self.value > 0 {\n      self.value -= 1\n    }else{\n      block (!\?inList:self.list)\n    }\n  }\n\n  //\n\n  public func wait @noUnusedWarning @mutating (\?until: inDeadline $u32) -> $bool {\n     sync{\n     when event self.wait () :\n       result = yes\n     when event time.wait (!until: inDeadline) :\n       result = no\n     }\n   }\n\n  //\n\n  public guard wait @noUnusedWarning () {\n    accept = self.value > 0\n    if accept {\n      self.value -= 1\n    }else{\n      handle (!\?guard:self.guardList)\n    }\n  }\n\n  //\n\n}\n\n//\n\n" ;

const cRegularFileWrapper gWrapperFile_12_targetTemplates (
  "semaphore.omnibus-import",
  "omnibus-import",
  true, // Text file
  1715, // Text length
  gWrapperFileContent_12_targetTemplates
) ;

//--- File 'LPC-L2294/+config.omnibus-target'

const char * gWrapperFileContent_43_targetTemplates = "PYTHON_UTILITIES:\n  \"../py-toolpath.txt\" -> \"sources/toolpath.py\"\n  \"../py-makefile.txt\" -> \"sources/makefile.py\"\n  \"../py-check-stacks.txt\" -> \"sources/check-stacks.py\"\n  \"../py-omnibus.txt\" -> \"sources/omnibus.py\"\n  \"../py-build-verbose.txt\" -> \"build-verbose.py\"\n  \"../py-clean.txt\" -> \"clean.py\"\n  \"../py-objdump.txt\" -> \"objdump.py\"\n  \"../py-objsize.txt\" -> \"objsize.py\"\n  \"py-run.txt\" -> \"run.py\"\n\nPYTHON_BUILD: \"py-build.txt\"\n\nLINKER_SCRIPT: \"ld-linker.txt\"\n\nPANIC_CODE_TYPE_NAME: $u32\nPANIC_LINE_TYPE_NAME: $u32\n\nPOINTER_BIT_COUNT: 32\n\nDYNAMIC_ARRAY: no\n\nSYSTEM_STACK_SIZE: 1024\n\nNOP: \"call void asm sideeffect \\\"nop\\\", \\\"\\\"() nounwind\"\n\nBIT_BAND:no\n\nSERVICE_HANDLER: \"service-handler.s\"\nSERVICE_SYSTEM_STACK_SIZE: 16 // as_swi_handler saves 4 32-bits registers on system stack\nSERVICE_DISPATCHER_HEADER: \"service-dispatcher-header.s\"\nSERVICE_DISPATCHER_ENTRY: \"service-dispatcher-entry.s\"\nSERVICE_ENTRY_NO_RETURNED_VALUE: \"service-entry-no-return.s\"\nSERVICE_ENTRY_WITH_RETURNED_VALUE: \"service-entry-return-value.s\"\n\nSECTION_HANDLER: \"udfcoded-section-dispatcher-code.s\"\nSECTION_SYSTEM_STACK_SIZE:  8 // saves 2 registers on system stack\nSECTION_DISPATCHER_HEADER: \"udfcoded-section-dispatcher-header.s\"\nSECTION_DISPATCHER_ENTRY: \"udfcoded-section-dispatcher-entry.s\"\nSECTION_ENTRY_FROM_UNKNOWN_MODE: \"udfcoded-section-invocation-from-unknown-mode.s\"\nSECTION_ENTRY_FROM_USER_MODE: \"udfcoded-section-invocation-from-user-mode.s\"\n\nINTERRUPT_HANDLER: \"xtr-interrupt-handler.s\"\nINTERRUPT_USER_STACK_SIZE: 0 // ARM7TDMI save no reg in user stack on interrupt\nUNUSED_INTERRUPT: \"undefined-interrupt.s\"\n\nCPP_FILES:\n  \"c-arm7tdmi-vectors.cpp\"\n  \"c-arm7tdmi-context.cpp\"\n  \"../c-task-list-type-32-tasks.cpp\"\n  \"../c-guard-types-32-tasks.cpp\"\n  \"../c-task-control-block-type.cpp\"\n  \"../c-guard-list-32-tasks.cpp\"\n  \"../c-task-list-32-tasks.cpp\"\n  \"../c-deadline-list-32-tasks.cpp\"\n  \"../c-real-time-kernel-code.cpp\"\n  \"../c-guard-code.cpp\"\n  \"../c-real-time-kernel-utilities.cpp\"\n  \"../memory-utilities.cpp\"\n\nS_FILES:\n  \"s-target.s\"\n\nLL_FILES:\n   \"ll-arm7tdmi.ll\"\n   \"../ll-clear-bss.ll\"\n   \"../ll-copy-data-section.ll\"\n   \"../ll-copy-byte-array.ll\"\n   \"../ll-copy-word-array.ll\"\n   \"../ll-configuration-on-boot.ll\"\n   \"ll-install-interrupts.ll\"\n\nOMNIBUS_FILES:\n  \"registers-lpc2294.omnibus-import\"\n  \"lpc2294-xtr.omnibus-import\"\n  \"../semaphore.omnibus-import\"\n\nINTERRUPTS:\n  WDT\n  ARMCore0\n  ARMCore1\n  TIMER0\n  TIMER1\n  UART0\n  UART1\n  PWM0\n  I2C\n  SPI0\n  SPI1_SSP\n  PLL\n  RTC\n  EINT0\n  EINT1\n  EINT2\n  EINT3\n  ADC\n  CAN_COMMON\n  CAN0_TX\n  CAN1_TX\n  CAN2_TX\n  CAN3_TX\n  FULLCAN\n  CAN0_RX\n  CAN1_RX\n  CAN2_RX\n  CAN3_RX\n  PAbort -> 40\n  DAbort -> 41\n  FIQ -> 42\n" ;

const cRegularFileWrapper gWrapperFile_43_targetTemplates (
  "+config.omnibus-target",
  "omnibus-target",
  true, // Text file
  2662, // Text length
  gWrapperFileContent_43_targetTemplates
) ;

//--- File 'LPC-L2294/c-arm7tdmi-context.cpp'

const char * gWrapperFileContent_54_targetTemplates = "//---------------------------------------------------------------------------------------------------------------------*\n//                                                                                                                     *\n//   T A S K    R O U T I N E    T Y P E                                                                               *\n//                                                                                                                     *\n//---------------------------------------------------------------------------------------------------------------------*\n\ntypedef void (* RoutineTaskType) (void) ;\n\n//---------------------------------------------------------------------------------------------------------------------*\n//                                                                                                                     *\n//   T A S K    C O N T E X T                                                                                          *\n//                                                                                                                     *\n//---------------------------------------------------------------------------------------------------------------------*\n//                                           *---------------------* +68\n//                                           | PC_USR              | +64 [16]\n//                                           | R12                 | +60 [15]\n//                                           | R11                 | +56 [14]\n//                                           | R10                 | +52 [13]\n//                                           | R9                  | +48 [12]\n//                                           | R8                  | +44 [11]\n//                                           | R7                  | +40 [10]\n//                                           | R6                  | +36 [ 9]\n//                                           | R5                  | +32 [ 8]\n//                                           | R4                  | +28 [ 7]\n//                                           | R3                  | +24 [ 6]\n//                                           | R2                  | +20 [ 5]\n//                                           | R1                  | +16 [ 4]\n//                                           | R0                  | +12 [ 3]\n//                                           | LR_USR              | + 8 [ 2]\n// *--------------------------------*        | SP_USR              | + 4 [ 1]\n// |                                +------> | CPSR                | + 0 [ 0]\n// *--------------------------------*        *---------------------*\n\n//---------------------------------------------------------------------------------------------------------------------*\n\ntypedef struct {\n  unsigned mCPSR ;\n  unsigned mSP_USR ;\n  unsigned mLR_USR ;\n  unsigned mR0 ;\n  unsigned mR1 ;\n  unsigned mR2 ;\n  unsigned mR3 ;\n  unsigned mR4 ;\n  unsigned mR5 ;\n  unsigned mR6 ;\n  unsigned mR7 ;\n  unsigned mR8 ;\n  unsigned mR9 ;\n  unsigned mR10 ;\n  unsigned mR11 ;\n  unsigned mR12 ;\n  unsigned mPC_USR ;\n} TaskContext ;\n\n//---------------------------------------------------------------------------------------------------------------------*\n\nstatic void kernel_set_task_context (TaskContext & ioTaskContext,\n                                     const unsigned inStackBufferAddress,\n                                     const unsigned inStackBufferSize,\n                                     RoutineTaskType inTaskRoutine,\n                                     const bool /* inHasFloatingPointContext */) {\n//--- Initialize PC\n  ioTaskContext.mPC_USR = (unsigned) inTaskRoutine ;\n//--- Initialize SP\n  ioTaskContext.mSP_USR = inStackBufferAddress + inStackBufferSize ;\n//--- Initialize CPSR\n  ioTaskContext.mCPSR = 0x10 ; // ARM USER MODE, IRQ and FIRQ interrupts enabled\n}\n\n//---------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_54_targetTemplates (
  "c-arm7tdmi-context.cpp",
  "cpp",
  true, // Text file
  4058, // Text length
  gWrapperFileContent_54_targetTemplates
) ;

//--- File 'LPC-L2294/c-arm7tdmi-vectors.cpp'

const char * gWrapperFileContent_55_targetTemplates = "//\n\n#define VICIntEnClr    (*((volatile unsigned *) 0xFFFFF014))\n#define VICIntEnable   (*((volatile unsigned *) 0xFFFFF010))\n#define VICVect(INDEX) (*((volatile unsigned *) (0xFFFFF100 + ((INDEX) << 2))))\n#define VICVectCntl(INDEX) (*((volatile unsigned *) (0xFFFFF200 + ((INDEX) << 2))))\n\n//\n\nstatic unsigned gSlotID ;\n\n//\n\nstatic void installInterruptServiceRoutine (const unsigned irq_routine, const unsigned inSourceID) {\n//---\n  VICVect (gSlotID) = irq_routine ;\n  VICVectCntl (gSlotID) = 0x20 | inSourceID ;\n//---\n  VICIntEnClr   = 1 << inSourceID ;\n  VICIntEnable |= 1 << inSourceID ;\n//---\n  gSlotID ++ ;\n}\n\n//\n\nextern unsigned __omnibus_interrupt_vectors [30] ;\n\nvoid installInterrupts (void) ;\n\nvoid installInterrupts (void) {\n  for (unsigned i=0 ; i<30 ; i++) {\n    if (__omnibus_interrupt_vectors [i] != 0) {\n      installInterruptServiceRoutine (__omnibus_interrupt_vectors [i], i) ;\n    }\n  }\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_55_targetTemplates (
  "c-arm7tdmi-vectors.cpp",
  "cpp",
  true, // Text file
  1504, // Text length
  gWrapperFileContent_55_targetTemplates
) ;

//--- File 'LPC-L2294/flash.ld'

const char * gWrapperFileContent_57_targetTemplates = "/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                   Memory                                                                           */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nMEMORY {\n  flash (rx) : ORIGIN = 0, LENGTH = 248k \n  internalRam (rwx) : ORIGIN = 0x40000000, LENGTH = 16k \n  externalRam (rwx) : ORIGIN = 0x81000000, LENGTH = 1M \n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n__internalRam_end = 0x40000000 + 16k ;\n__externalRam_end = 0x81000000 + 1M ;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                ISR Vectors                                                                         */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .vectors : {\n    __vectors_start = . ;\n    KEEP (*(.isr_vector)) ;\n    __vectors_end = . ;\n  } > flash\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                    Code                                                                            */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .text : {\n    FILL(0xff)\n    __code_start = . ;\n  /*--- Tableau des routines d'initialisation */\n    . = ALIGN (4) ;\n    __init_routine_array_start = . ;\n    KEEP (*(init_routine_array)) ;\n    . = ALIGN (4) ;\n    __init_routine_array_end = . ;\n  /*--- Initialisation des objets globaux C++ */\n    . = ALIGN (4) ;\n    __constructor_array_start = . ;\n    KEEP (*(.init_array)) ;\n    . = ALIGN (4) ;\n    __constructor_array_end = . ;\n  /*--- Real Interrupt Service Routine Array */\n    . = ALIGN (4) ;\n    __real_time_isr_array_start = . ;\n    KEEP (*(real_time_isr_array)) ;\n    . = ALIGN (4) ;\n    __real_time_isr_array_end = . ;\n  /*--- Code */\n    *(.text.*) ;\n    *(.text) ;\n    *(text) ;\n    *(.gnu.linkonce.t.*) ;\n  /*---- ROM data ----*/\n    . = ALIGN(4);\n    *(.rodata);\n    . = ALIGN(4);\n    *(.rodata*);\n    . = ALIGN(4);\n    *(.gnu.linkonce.r.*);\n    . = ALIGN(4);\n    *(.glue_7t);\n    . = ALIGN(4);\n    *(.glue_7);\n    . = ALIGN(4);\n    __code_end = . ;\n  } > flash\n\n  /DISCARD/ : {\n    *(rel.ARM.*);\n    *(.ARM.*);\n    *(.gnu.linkonce.armexidx.*);\n  }\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                          Data (initialized data)                                                                   */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .data : {\n    FILL (0xFF)\n    . = ALIGN (4) ;\n    __data_start = . ;\n    * (.data.*init*) ;\n    * (.data*) ;\n    . = ALIGN (4) ;\n    __data_end = . ;\n  } > externalRam AT > flash\n}\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n__data_load_start = LOADADDR (.data) ;\n__data_load_end   = LOADADDR (.data) + SIZEOF (.data) ;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                          BSS (zero initialized data)                                                               */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .bss : {\n    . = ALIGN(4);\n    __bss_start = . ;\n    * (.bss.*) ;\n    * (.bss) ;\n    * (COMMON) ;\n    . = ALIGN(4);\n    __bss_end = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                Stacks                                                                              */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 1k ;\n    . = ALIGN (4) ;\n    __irq_stack_end = . ;\n    __svc_stack_end = . ;\n  } > internalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 1k ;\n    . = ALIGN (4) ;\n    __und_stack_end = . ;\n  } > internalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 512 ;\n    . = ALIGN (4) ;\n    __abt_stack_end = . ;\n  } > internalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 512 ;\n    . = ALIGN (4) ;\n    __fiq_stack_end = . ;\n  } > internalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                    Heap                                                                            */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .heap : {\n    . = ALIGN (4) ;\n    __heap_start = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n__heap_end = __externalRam_end ;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n" ;

const cRegularFileWrapper gWrapperFile_57_targetTemplates (
  "flash.ld",
  "ld",
  true, // Text file
  7649, // Text length
  gWrapperFileContent_57_targetTemplates
) ;

//--- File 'LPC-L2294/ld-linker.txt'

const char * gWrapperFileContent_48_targetTemplates = "/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                   Memory                                                                           */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nMEMORY {\n  flash (rx) : ORIGIN = 0, LENGTH = 248k \n  internalRam (rwx) : ORIGIN = 0x40000000, LENGTH = 16k \n  externalRam (rwx) : ORIGIN = 0x81000000, LENGTH = 1M \n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n__internalRam_end = 0x40000000 + 16k ;\n__externalRam_end = 0x81000000 + 1M ;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                ISR Vectors                                                                         */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .vectors : {\n    __vectors_start = . ;\n    KEEP (*(.isr_vector)) ;\n    __vectors_end = . ;\n  } > internalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                    Code                                                                            */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .text : {\n    FILL(0xff)\n    __code_start = . ;\n  /*--- Code */\n    *(.text.*) ;\n    *(.text) ;\n    *(text) ;\n    *(.gnu.linkonce.t.*) ;\n  /*---- ROM data ----*/\n    . = ALIGN(4);\n    *(.rodata);\n    . = ALIGN(4);\n    *(.rodata*);\n    . = ALIGN(4);\n    *(.gnu.linkonce.r.*);\n    . = ALIGN(4);\n    *(.glue_7t);\n    . = ALIGN(4);\n    *(.glue_7);\n    . = ALIGN(4);\n    __code_end = . ;\n  } > externalRam\n\n  /DISCARD/ : {\n    *(rel.ARM.*);\n    *(.ARM.*);\n    *(.gnu.linkonce.armexidx.*);\n  }\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                          Data (initialized data)                                                                   */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .data : AT (__code_end) {\n    FILL (0xFF)\n    . = ALIGN (4) ;\n    __data_start = . ;\n    * (.data*) ;\n    . = ALIGN (4) ;\n    __data_end = . ;\n  } > externalRam\n}\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n__data_load_start = LOADADDR (.data) ;\n__data_load_end   = LOADADDR (.data) + SIZEOF (.data) ;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                          BSS (zero initialized data)                                                               */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .bss : {\n    . = ALIGN(4);\n    __bss_start = . ;\n    * (.bss*) ;\n    * (COMMON) ;\n    . = ALIGN(4);\n    __bss_end = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                Stacks                                                                              */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += !SYSTEMSTACKSIZE! ;\n    . = ALIGN (4) ;\n    __irq_stack_end = . ;\n    __svc_stack_end = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 1k ;\n    . = ALIGN (4) ;\n    __und_stack_end = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 512 ;\n    . = ALIGN (4) ;\n    __abt_stack_end = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .stacks :{\n    . = ALIGN (4) ;\n    . += 512 ;\n    . = ALIGN (4) ;\n    __fiq_stack_end = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*                                                                                                                    */\n/*                                    Heap                                                                            */\n/*                                                                                                                    */\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nSECTIONS {\n  .heap : {\n    . = ALIGN (4) ;\n    __heap_start = . ;\n  } > externalRam\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n__heap_end = ORIGIN(externalRam) + LENGTH(externalRam) ;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n" ;

const cRegularFileWrapper gWrapperFile_48_targetTemplates (
  "ld-linker.txt",
  "txt",
  true, // Text file
  7085, // Text length
  gWrapperFileContent_48_targetTemplates
) ;

//--- File 'LPC-L2294/ll-arm7tdmi.ll'

const char * gWrapperFileContent_56_targetTemplates = ";--- For LLVM < 9.0.0\n;target datalayout = \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\"\n\n;--- For LLVM >= 9.0.0\ntarget datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\n\n;---\ntarget triple = \"armv4-none-unknown-eabi\"\n" ;

const cRegularFileWrapper gWrapperFile_56_targetTemplates (
  "ll-arm7tdmi.ll",
  "ll",
  true, // Text file
  239, // Text length
  gWrapperFileContent_56_targetTemplates
) ;

//--- File 'LPC-L2294/ll-install-interrupts.ll'

const char * gWrapperFileContent_44_targetTemplates = ";----------------------------------------------------------------------------------------------------------------------*\n\ndeclare void @installInterrupts () nounwind\n\n" ;

const cRegularFileWrapper gWrapperFile_44_targetTemplates (
  "ll-install-interrupts.ll",
  "ll",
  true, // Text file
  167, // Text length
  gWrapperFileContent_44_targetTemplates
) ;

//--- File 'LPC-L2294/lpc2294-xtr.omnibus-import'

const char * gWrapperFileContent_40_targetTemplates = "//\n//   SYNCHRONIZATION TOOLS ROUTINES\n//\n\nopaque $TaskList @instantiable {32}\n\n//--- Block running task\nextern func block primitive (\?!inList:ioWaitingList $TaskList) : \"blockInList\"\n\nextern func block primitive (\?onDeadline:inDeadline $u32) : \"blockOnDeadline\"\n\n//--- Make task Ready\nextern func\nmakeTaskReady service (\?!fromList:ioWaitingList $TaskList\n               !found: outFound $bool) : \"makeTaskReady\"\n\nextern func makeTasksReady service (\?fromCurrentDate:inCurrentDate $u32) : \"makeTasksReadyFromCurrentDate\"\n\n//\n//   GUARD\n//\n\nopaque $GuardList @instantiable {32}\n\nextern func handle guard (\?!guard:ioGuard $GuardList) : \"handleGuardedCommand\"\n\nextern func handle guard (\?guardedDeadline:inDeadline $u32) : \"guard.handle.wait.until\"\n\nextern func notifyChange service (\?!forGuard:ioGuard $GuardList) : \"notify.change.from.guard.list\"\n\nextern func notifyChangeForGuardedWaitUntil service (\?withCurrentDate:inCurrentDate $u32) : \"notify.change.for.guarded.wait.until\"\n\n//\n\nlet TIMER_PRESCALER = 6\nlet TICKS_PER_MILLISECONDS = 10000\n\n//\n\ndriver time ()\n\n//\n\ndriver time {\n\n  //\n\n  startup {\n  //--- Program pin P1.23 as an output (STAT led)\n    IO1.DIR |= 1 << 23\n    IO1.CLR  = 1 << 23 // Led On\n  //-------------------------------- Timer 1\n  //--- 1. Set Prescaler\n    TIMER1.PR = TIMER_PRESCALER - 1\n  //--- 2. Set Match Register 0\n  //    We want an interrupt every millisecond\n    TIMER1.MR0 = TICKS_PER_MILLISECONDS - 1\n  //--- 2. Set Count control Register\n  //    Bits 1-0: 00 (timer mode)\n  //    Bits 3-2: XX (any value, because timer mode)\n    TIMER1.CCR = 0\n  //--- 3. Match Control Register\n  //    Bit 0: 1 (interrupt on MR0 match)\n  //    Bit 1: 1 (reset on MR0 match)\n  //    Bit 2: 0 (do not stop on MR0 match)\n  //    Bit 5-3: 000 (MR1 not used)\n  //    Bit 8-6: 000 (MR2 not used)\n  //    Bit 11-9: 000 (MR3 not used)\n    TIMER1.MCR = 3\n  //--- 4. Use vector 9 for TIMER1 interrupt\n  //  sys_installInterruptServiceRoutine (MODE_ TIMER1InterruptServiceRoutine, 5) ;\n  //  VICVectAddr9 = (uint32_t) TIMER1InterruptServiceRoutine ;\n  //  VICVectCntl9 = 0x20 | 5 ; // Timer interrupt number is #5\n  //--- 5. Use IRQ for tracking MR0 matches\n  //  TIMER1 gets interruption #5 (mask: 0x20)\n  //  VICIntEnClr   = 1 << 5 ; // Timer1 interrupt generates IRQ\n  //  VICIntEnable |= 1 << 5 ; // Enable Timer1 interrupt\n  //--- 6. Start Counter 0 (Timer Control Register)\n  // Bit 0 : 1 (Enables counting)\n  // Bit 1 : 0 (No reset)\n    TIMER1.TCR = 1\n  }\n\n  //\n\n  var mUptime $u32 = 0\n\n  //\n\n  public section now safe @noUnusedWarning () -> $u32 {\n    result = self.mUptime\n  }\n\n  //\n\n  interrupt service TIMER1 {\n    TIMER1.IR = 1 // Clears MR0 interrupt\n    let now = self.mUptime +% 1\n    self.mUptime = now\n    makeTasksReady (!fromCurrentDate:now)\n    notifyChangeForGuardedWaitUntil (!withCurrentDate:now)\n  }\n\n  //\n\n  public primitive wait @noUnusedWarning (\?until: inDate $u32) {\n    if inDate > self.now () {\n      block (!onDeadline:inDate)\n    }\n  }\n\n  //\n\n  public func wait user @noUnusedWarning @mutating (\?during: inDelay $u32) {\n    self.wait (!until:self.now () + inDelay)\n  }\n\n  //\n\n  public guard wait @noUnusedWarning (\?until:inDeadline $u32) {\n    accept = inDeadline  self.now ()\n    if not accept {\n      handle (!guardedDeadline:inDeadline)\n    }\n  }\n\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_40_targetTemplates (
  "lpc2294-xtr.omnibus-import",
  "omnibus-import",
  true, // Text file
  4545, // Text length
  gWrapperFileContent_40_targetTemplates
) ;

//--- File 'LPC-L2294/py-build.txt'

const char * gWrapperFileContent_51_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport sys, os\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nsys.path.append (os.path.dirname (os.path.abspath (sys.argv [0])) + \"/sources\")\nimport omnibus\nimport toolpath\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef archiveBaseURL ():\n  return \"http://www.pcmolinaro.name/omnibus-tools/\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM optimizer invocation                                                                                          *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef llvmOptimizerCompiler ():\n  return [toolpath.toolDir () + \"/bin/opt\", \"-Oz\", \"-disable-simplify-libcalls\", \"-S\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLC Compiler invocation                                                                                            *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLCcompiler ():\n  return [toolpath.toolDir () + \"/bin/llc\", \"-function-sections\", \"-data-sections\", \"-O2\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM Linker invocation                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLVMLinkercompiler ():\n  return [toolpath.toolDir () + \"/bin/llvm-link\", \"-S\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   CLANG Compiler invocation                                                                                          *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef CLANGcompiler ():\n  result = [toolpath.toolDir () + \"/bin/clang\"]\n  result.append (\"--target=armv4-none--eabi\")\n  result.append (\"-Oz\")\n  result.append (\"-fomit-frame-pointer\")\n  result.append (\"-fshort-enums\")\n  result.append (\"-Wall\")\n  result.append (\"-fno-rtti\")\n  result.append (\"-fno-exceptions\")\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   AS assembler invocation                                                                                            *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef asAssembler ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-as\", \"-mcpu=arm7tdmi-s\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Display object size invocation                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef displayObjectSize ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-size\", \"-t\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Object Dump invocation                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef dumpObjectCode ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-objdump\", \"-Sdh\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker invocation                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerInvocation ():\n  result = [toolpath.toolDir () + \"/bin/arm-eabi-ld\"]\n  result.append (\"-nostartfiles\")\n  result.append (\"--fatal-warnings\")\n  result.append (\"--warn-common\")\n  result.append (\"--no-undefined\")\n  result.append (\"--cref\")\n  result.append (\"-static\")\n  result.append (\"--gc-sections\")\n  result.append (\"--sort-common=descending\")\n  result.append (\"--sort-section=alignment\")\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker scripts                                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerScripts ():\n#  result = [\"external-ram\"] # Linker script is external-ram.ld\n  result = [\"linker\"] # Linker script is linker.ld\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker libraries                                                                                                   *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerLibraries ():\n  result = [\"libgcc-armv4.a\"]\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   objcopy invocation                                                                                                 *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef objcopy ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-objcopy\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   C Source files                                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef CsourceList ():\n  return [\"src.cpp\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM Source files                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLVMsourceList ():\n  return [\"src.ll\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Assembler Source files                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef assemblerSourceList ():\n  return [\"src.s\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Product directory                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef productDir ():\n  return \"product\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#                         Object files directories                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef objectDir ():\n  return \"objects\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Run executable                                                                                                      *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef runExecutableOnTarget ():\n  return [toolpath.toolDir () + \"/bin/teensy_loader_cli\", \"-w\", \"-v\", \"-mmcu=mk20dx256\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   ARM stack computations utility                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef arm_stack_computations ():\n  return [toolpath.toolDir () + \"/bin/arm-stack-computations\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   check stack utility                                                                                                *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef check_stack_utility ():\n  return [\"sources/check-stacks.py\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   MAIN                                                                                                               *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ncurrentFile = os.path.abspath (sys.argv [0])\nomnibus.runMakefile (toolpath.toolDir (), archiveBaseURL (), LLVMsourceList (), assemblerSourceList (), objectDir (), \\\n                 LLCcompiler (), llvmOptimizerCompiler (), \\\n                 asAssembler (), productDir (), \\\n                 linkerInvocation (), linkerScripts (), linkerLibraries (), \\\n                 objcopy (), dumpObjectCode (), displayObjectSize (), runExecutableOnTarget (), \\\n                 CLANGcompiler (), CsourceList (), LLVMLinkercompiler (), \\\n                 currentFile, arm_stack_computations (), check_stack_utility ())\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_51_targetTemplates (
  "py-build.txt",
  "txt",
  true, // Text file
  15585, // Text length
  gWrapperFileContent_51_targetTemplates
) ;

//--- File 'LPC-L2294/py-run.txt'

const char * gWrapperFileContent_36_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport subprocess, sys, time, os, socket\n\n#----------------------------------------------------------------------------------------------------------------------*\n#   Colors                                                                                                           *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef RED () :\n  return '\\033[91m'\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef GREEN () :\n  return '\\033[92m'\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef BLUE () :\n  return '\\033[94m'\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef ENDC () :\n  return '\\033[0m'\n\n#----------------------------------------------------------------------------------------------------------------------*\n\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\nos.chdir (scriptDir)\nsys.path.append (scriptDir + \"/sources\")\nimport toolpath\n#--- Build project\nreturncode = subprocess.call ([\"python\", \"build.py\"])\nif returncode != 0 :\n  sys.exit (returncode)\n#---\nopenOCD = [\n  toolpath.toolDir () + \"/bin/openocd\",\n  \"--search\",\n  toolpath.toolDir (),\n  \"-f\",\n  \"openocd-interfaces/olimex-arm-usb-ocd.cfg\",\n  \"-f\",\n  \"openocd-boards/olimex-lpc-l2294-1Mo.cfg\",\n]\nstr = \"+\"\nfor s in openOCD :\n  str += \" \" + s\nprint BLUE () + str + ENDC ()\nopenOCDProcess = subprocess.Popen (openOCD, cwd=scriptDir)\n#--- Wait for openOCD is listening on port 4444\ntime.sleep (1)\n#print (\"openOCD pid: \", openOCDProcess.pid)\n#--- OpenOCD Script\nopenOCDScript  = \"reset halt\\n\"\nopenOCDScript += \"mww 0xE01FC040 0\\n\"\nopenOCDScript += \"mdw 0xE01FC040\\n\"\nopenOCDScript += \"mww 0xE002C014 0x0F804924\\n\"\nopenOCDScript += \"mdw 0xE002C014\\n\"\nopenOCDScript += \"mww 0xFFE00004 0x20000400\\n\"\nopenOCDScript += \"mdw 0xFFE00004\\n\"\nopenOCDScript += \"load_image product/product-linker.elf\\n\"\nopenOCDScript += \"mww 0xE01FC040 2\\n\"\nopenOCDScript += \"mdw 0xE01FC040\\n\"\nopenOCDScript += \"soft_reset_halt\\n\"\nopenOCDScript += \"resume\\n\"\nopenOCDScript += \"shutdown\\n\"\n#---\nclient = socket.socket (socket.AF_INET, socket.SOCK_STREAM)\nok = False\nif openOCDProcess.poll () == None :\n  try:\n    client.connect (('localhost', 4444))\n    try:\n      client.send (openOCDScript)\n      ok = True\n    except:\n      print (\"Cannot send data\")\n  except:\n    print (\"Connection refused\")\n#--- Wait for openOCD to exit\nif openOCDProcess.poll () == None :\n  openOCDProcess.wait ()\nif openOCDProcess.returncode == 0 :\n  print GREEN () + \"Success\" + ENDC ()\nelse:\n  print RED () + \"Error\" + ENDC ()\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_36_targetTemplates (
  "py-run.txt",
  "txt",
  true, // Text file
  3092, // Text length
  gWrapperFileContent_36_targetTemplates
) ;

//--- File 'LPC-L2294/registers-lpc2294.omnibus-import'

const char * gWrapperFileContent_39_targetTemplates = "//------------------------------------------------------------------------------\n\n// Vectored $interrupt Controller (VIC)\nregisters VIC @at 0xFFFF_F000 {\n  IRQStatus   @offset 0x000 $u32\n  FIQStatus   @offset 0x000 $u32\n  RawIntr     @offset 0x008 $u32\n  IntSelect   @offset 0x00C $u32\n  IntEnable   @offset 0x010 $u32\n  IntEnClr    @offset 0x014 $u32\n  SoftInt     @offset 0x018 $u32\n  SoftIntClr  @offset 0x01C $u32\n  Protection  @offset 0x020 $u32\n  VectAddr    @offset 0x030 $u32\n  DefVectAddr @offset 0x034 $u32\n\n  VectAddr0   @offset 0x100 $u32\n  VectAddr1   @offset 0x104 $u32\n  VectAddr2   @offset 0x108 $u32\n  VectAddr3   @offset 0x10C $u32\n  VectAddr4   @offset 0x110 $u32\n  VectAddr5   @offset 0x114 $u32\n  VectAddr6   @offset 0x118 $u32\n  VectAddr7   @offset 0x11C $u32\n  VectAddr8   @offset 0x120 $u32\n  VectAddr9   @offset 0x124 $u32\n  VectAddr10  @offset 0x128 $u32\n  VectAddr11  @offset 0x12C $u32\n  VectAddr12  @offset 0x130 $u32\n  VectAddr13  @offset 0x134 $u32\n  VectAddr14  @offset 0x138 $u32\n  VectAddr15  @offset 0x13C $u32\n\n  VectCntl0   @offset 0x200 $u32\n  VectCntl1   @offset 0x204 $u32\n  VectCntl2   @offset 0x208 $u32\n  VectCntl3   @offset 0x20C $u32\n  VectCntl4   @offset 0x210 $u32\n  VectCntl5   @offset 0x214 $u32\n  VectCntl6   @offset 0x218 $u32\n  VectCntl7   @offset 0x21C $u32\n  VectCntl8   @offset 0x220 $u32\n  VectCntl9   @offset 0x224 $u32\n  VectCntl10  @offset 0x228 $u32\n  VectCntl11  @offset 0x22C $u32\n  VectCntl12  @offset 0x230 $u32\n  VectCntl13  @offset 0x234 $u32\n  VectCntl14  @offset 0x238 $u32\n  VectCntl15  @offset 0x23C $u32\n}\n\n//------------------------------------------------------------------------------\n\n// Watchdog\nregisters WD @at 0xE000_0000 {\n  MOD            @offset 0x00 $u8\n  TC             @offset 0x04 $u32\n  FEED           @offset 0x08 $u8\n  TV             @offset 0x0C $u32\n}\n\n// Pin Connect Block\nregisters PIN @at 0xE002_C000 {\n  SEL0        @offset 0x00 $u32\n  SEL1        @offset 0x04 $u32\n  SEL2        @offset 0x14 $u32\n}\n\n// General Purpose Input/Output (GPIO)\nregisters IO0 @at 0xE002_8000 {\n  PIN          @offset 0x00 $u32\n  SET          @offset 0x04 $u32\n  DIR          @offset 0x08 $u32\n  CLR          @offset 0x0C $u32\n}\n\nregisters IO1 @at 0xE002_8010 {\n  PIN          @offset 0x00 $u32\n  SET          @offset 0x04 $u32\n  DIR          @offset 0x08 $u32\n  CLR          @offset 0x0C $u32\n}\n\nregisters IO2 @at 0xE002_8020 {\n  PIN          @offset 0x00 $u32\n  SET          @offset 0x04 $u32\n  DIR          @offset 0x08 $u32\n  CLR          @offset 0x0C $u32\n}\n\nregisters IO3 @at 0xE002_8030 {\n  PIN          @offset 0x00 $u32\n  SET          @offset 0x04 $u32\n  DIR          @offset 0x08 $u32\n  CLR          @offset 0x0C $u32\n}\n\n// Memory Accelerator Module (MAM)\nregisters MAM @at 0xE01F_C000 {\n  CR            @offset 0x00 $u8\n  TIM           @offset 0x04 $u8\n}\n\nregisters MEM @at 0xE01F_C000 {\n  MAP           @offset 0x40 $u8\n}\n\n// Phase Locked Loop (PLL)\nregisters PLL @at 0xE01F_C000 {\n  CON           @offset 0x80 $u8\n  CFG           @offset 0x84 $u8\n  STAT          @offset 0x88 $u16\n  FEED          @offset 0x8C $u8\n}\n\n// VPB Divider */\nregisters VPB @at 0xE01F_C100 {\n  DIV           @offset 0x0 $u8\n}\n\n// Power Control */\nregisters PC @at 0xE01F_C0C0 {\n  ON             @offset 0x0 $u8\n  ONP            @offset 0x4 $u32\n}\n\n// External $interrupts\nregisters EXT @at 0xE01F_C140 {\n  INT           @offset 0x0 $u8\n  WAKE          @offset 0x4 $u8\n  MODE          @offset 0x8 $u8\n  POLAR         @offset 0xC $u8\n}\n\n// Timer 0\nregisters TIMER0 @at 0xE000_4000 {\n  IR      @offset 0x00 $u32\n  TCR     @offset 0x04 $u32\n  TC      @offset 0x08 $u32\n  PR      @offset 0x0C $u32\n  PC      @offset 0x10 $u32\n  MCR     @offset 0x14 $u32\n  MR0     @offset 0x18 $u32\n  MR1     @offset 0x1C $u32\n  MR2     @offset 0x20 $u32\n  MR3     @offset 0x24 $u32\n  CCR     @offset 0x28 $u32\n  CR0     @offset 0x2C $u32\n  CR1     @offset 0x30 $u32\n  CR2     @offset 0x34 $u32\n  CR3     @offset 0x38 $u32\n  EMR     @offset 0x3C $u32\n}\n\n// Timer 1\nregisters TIMER1 @at 0xE000_8000 {\n  IR      @offset 0x00 $u32\n  TCR     @offset 0x04 $u32\n  TC      @offset 0x08 $u32\n  PR      @offset 0x0C $u32\n  PC      @offset 0x10 $u32\n  MCR     @offset 0x14 $u32\n  MR0     @offset 0x18 $u32\n  MR1     @offset 0x1C $u32\n  MR2     @offset 0x20 $u32\n  MR3     @offset 0x24 $u32\n  CCR     @offset 0x28 $u32\n  CR0     @offset 0x2C $u32\n  CR1     @offset 0x30 $u32\n  CR2     @offset 0x34 $u32\n  CR3     @offset 0x38 $u32\n  EMR     @offset 0x3C $u32\n}\n\n// Pulse Width Modulator (PWM)\nregisters PWM @at 0xE001_4000 {\n  IR         @offset 0x00 $u32\n  TCR        @offset 0x04 $u32\n  TC         @offset 0x08 $u32\n  PR         @offset 0x0C $u32\n  PC         @offset 0x10 $u32\n  MCR        @offset 0x14 $u32\n  MR0        @offset 0x18 $u32\n  MR1        @offset 0x1C $u32\n  MR2        @offset 0x20 $u32\n  MR3        @offset 0x24 $u32\n  MR4        @offset 0x40 $u32\n  MR5        @offset 0x44 $u32\n  MR6        @offset 0x48 $u32\n  CCR        @offset 0x28 $u32\n  CR0        @offset 0x2C $u32\n  CR1        @offset 0x30 $u32\n  CR2        @offset 0x34 $u32\n  CR3        @offset 0x38 $u32\n  EMR        @offset 0x3C $u32\n  PCR        @offset 0x4C $u32\n  LER        @offset 0x50 $u32\n}\n\n// Universal Asynchronous Receiver Transmitter 0 (UART0)\nregisters U0 @at 0xE000_C000 {\n  RBR        @offset 0x00 $u8\n  THR        @offset 0x00 $u8\n  DLL        @offset 0x00 $u8\n  DLM        @offset 0x04 $u8\n  IER        @offset 0x04 $u32\n  IIR        @offset 0x08 $u32\n  FCR        @offset 0x08 $u8\n  LCR        @offset 0x0C $u8\n  LSR        @offset 0x14 $u8\n  SCR        @offset 0x1C $u8\n  ACR        @offset 0x20 $u32\n  FDR        @offset 0x28 $u32\n  TER        @offset 0x30 $u8\n}\n\n// Universal Asynchronous Receiver Transmitter 1 (UART1)\nregisters U1 @at 0xE001_0000 {\n  RBR        @offset 0x00 $u8\n  THR        @offset 0x00 $u8\n  DLL        @offset 0x00 $u8\n  DLM        @offset 0x04 $u8\n  IER        @offset 0x04 $u32\n  IIR        @offset 0x08 $u32\n  FCR        @offset 0x08 $u8\n  LCR        @offset 0x0C $u8\n  MCR        @offset 0x10 $u8\n  LSR        @offset 0x14 $u8\n  MSR        @offset 0x18 $u8\n  SCR        @offset 0x1C $u8\n  ACR        @offset 0x20 $u32\n  FDR        @offset 0x28 $u32\n  TER        @offset 0x30 $u8\n}\n\n// I2C $interface\nregisters I2C @at 0xE001_C000 {\n  I2CONSET     @offset 0x00 $u8\n  I2STAT       @offset 0x04 $u8\n  I2DAT        @offset 0x08 $u8\n  I2ADR        @offset 0x0C $u8\n  I2SCLH       @offset 0x10 $u16\n  I2SCLL       @offset 0x14 $u16\n  I2CONCLR     @offset 0x18 $u8\n}\n\n// SPI 0 (Serial Peripheral $interface 0)\nregisters SPI0 @at 0xE002_0000 {\n  SPCR          @offset 0x00 $u16\n  SPSR          @offset 0x04 $u8\n  SPDR          @offset 0x08 $u16\n  SPCCR         @offset 0x0C $u8\n  // SPTCR        @offset 0x10 $u8\n  // SPTSR        @offset 0x14 $u8\n  // SPTOR        @offset 0x18 $u8\n  SPINT         @offset 0x1C $u8\n}\n\n// SPI 1 (Serial Peripheral $interface 1)\nregisters SPI1 @at 0xE003_0000 {\n  SPCR          @offset 0x00 $u16\n  SPSR          @offset 0x04 $u8\n  SPDR          @offset 0x08 $u16\n  SPCCR         @offset 0x0C $u8\n  // SPTCR        @offset 0x10 $u8\n  // SPTSR        @offset 0x14 $u8\n  // SPTOR        @offset 0x18 $u8\n  SPINT         @offset 0x1C $u8\n}\n\n// Real Time Clock\nregisters RTC @at 0xE002_4000 {\n  ILR          @offset 0x00 $u8\n  CTC          @offset 0x04 $u16\n  CCR          @offset 0x08 $u8\n  CIIR         @offset 0x0C $u8\n  AMR          @offset 0x10 $u8\n  CTIME0       @offset 0x14 $u32\n  CTIME1       @offset 0x18 $u32\n  CTIME2       @offset 0x1C $u32\n  SEC          @offset 0x20 $u8\n  MIN          @offset 0x24 $u8\n  HOUR         @offset 0x28 $u8\n  DOM          @offset 0x2C $u8\n  DOW          @offset 0x30 $u8\n  DOY          @offset 0x34 $u16\n  MONTH        @offset 0x38 $u8\n  YEAR         @offset 0x3C $u16\n  ALSEC        @offset 0x60 $u8\n  ALMIN        @offset 0x64 $u8\n  ALHOUR       @offset 0x68 $u8\n  ALDOM        @offset 0x6C $u8\n  ALDOW        @offset 0x70 $u8\n  ALDOY        @offset 0x74 $u16\n  ALMON        @offset 0x78 $u8\n  ALYEAR       @offset 0x7C $u16\n  PREINT       @offset 0x80 $u16\n  PREFRAC      @offset 0x84 $u16\n}\n\n// Bank Configuration registers\nregisters BCF @at 0xFFE0_0000 {\n  G0          @offset 0x00 $u32\n  G1          @offset 0x04 $u32\n  G2          @offset 0x08 $u32\n  G3          @offset 0x0C $u32\n}\n\n// CAN Controllers\nregisters CAN @at 0xE004_4000 {\n  CMR [4 @offset 0x4 @inc 1 << 14] $u8 {\n    STB3 STB2 STB1 SRR CDO RRB AT TR\n  }\n//  AMFR          @offset 0xE003_C000 $u32\n//  SFF_SA        @offset 0xE003_C004 $u32\n//  SFF_GRP_SA    0xE003_C008 $u32\n//  EFF_SA        0xE003_C00C $u32\n//  EFF_GRP_SA    0xE003_C010 $u32\n//  END_OF_TABLES 0xE003_C014 $u32\n}\n\n// Analog/Digital Converter (ADC)\nregisters AD @at 0xE003_4000 {\n  CR           @offset 0x00 $u32\n  GDR          @offset 0x04 $u32\n  INTEN        @offset 0x0C $u32\n}\n\n//------------------------------------------------------------------------------\n" ;

const cRegularFileWrapper gWrapperFile_39_targetTemplates (
  "registers-lpc2294.omnibus-import",
  "omnibus-import",
  true, // Text file
  8941, // Text length
  gWrapperFileContent_39_targetTemplates
) ;

//--- File 'LPC-L2294/s-target.s'

const char * gWrapperFileContent_53_targetTemplates = "  .code 32\n	.text\n	.syntax unified\n	.cpu	arm7tdmi-s\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@       A C T I V I T Y    L E D    M A N A G E M E N T                                                                *\n@                                                                                                                      *\n@  This file provides macros for managing activity led.                                                                *\n@  It is included by sources/xtr/arm-context.s file.                                                                   *\n@  On the LPC-L2294 card, we use 'STAT' led (formely P1.23):                                                           *\n@    P1.23 low: led on;                                                                                                *\n@    P1.23 high: led off.                                                                                              *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  IO0CLR      = 0xE002800C\n  IO0SET      = 0xE0028004\n  IO1CLR      = 0xE002801C\n  IO1SET      = 0xE0028014\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@       A C T I V I T Y    L E D    O N                                                                                *\n@                                                                                                                      *\n@  When this macro is used, we can only use R6 and R7 registers.                                                       *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .macro ACTIVITY_LED_ON\n@    ldr   r7, =IO1CLR\n@    mov   r6, #(1 << 23)\n@    str   r6, [r7]\n  .endm\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@       A C T I V I T Y    L E D    O F F                                                                              *\n@                                                                                                                      *\n@  When this macro is used, we can only use R6 and R7 registers.                                                       *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .macro ACTIVITY_LED_OFF\n@    ldr   r7, =IO1SET\n@    mov   r6, #(1 << 23)\n@    str   r6, [r7]\n  .endm\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 R E S E T    H A N D L E R                                                                           *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n@--- Modes defined status Register\n   ARM_MODE_USER  = 0x10      @ Normal User Mode\n   ARM_MODE_FIQ   = 0x11      @ FIQ Interrupt Mode\n   ARM_MODE_IRQ   = 0x12      @ IRQ Interrupt Mode\n   ARM_MODE_SVC   = 0x13      @ SWI Interrupt Mode\n   ARM_MODE_ABORT = 0x17      @ Abort Processing memory Fault Mode\n   ARM_MODE_UNDEF = 0x1B      @ Undefined Instruction Mode\n\n@--- Interrupt masks for status Register\n   I_BIT          = 0x80      @ IRQ (IRQ is disabled when I bit is set)\n   F_BIT          = 0x40      @ FIQ (FIQ is disabled when F bit is set)\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@               Vector table and reset entry                                                                           *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n   .section .isr_vector, \"ax\"\n\n   ldr pc, ResetAddr    @ Reset\n   ldr pc, UndefAddr    @ Undefined instruction\n   ldr pc, SWIAddr      @ Software interrupt\n   ldr pc, PAbortAddr   @ Prefetch abort\n   ldr pc, DAbortAddr   @ Data abort\n   .word   0xb8a06f60   @ Checksum\n   ldr pc, IRQAddr      @ IRQ interrupt\n   ldr pc, FIQAddr      @ FIQ interrupt\nResetAddr:     .word as_reset_handler\nUndefAddr:     .word as_undef_handler\nSWIAddr:       .word as_swi_handler\nPAbortAddr:    .word !ISR!PAbort\nDAbortAddr:    .word !ISR!DAbort\nIRQAddr:       .word as_irq_handler\nFIQAddr:       .word !ISR!FIQ\n               .word 0xFFFFFFFF @ pad word to get 64 bytes in isr_vector section\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                           Reset handler                                                                              *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n   .section .text.as_reset_handler, \"ax\"\n\n   .global as_reset_handler\n\nas_reset_handler:\n@-------------------------- Setup a stack and  status register for each mode\n   msr   CPSR_c, #ARM_MODE_UNDEF | I_BIT | F_BIT  @ Undefined Instruction Mode\n   ldr   sp, =__und_stack_end\n\n   msr   CPSR_c, #ARM_MODE_ABORT | I_BIT | F_BIT  @ Abort Mode\n   ldr   sp, =__abt_stack_end\n\n   msr   CPSR_c, #ARM_MODE_FIQ | I_BIT | F_BIT @ FIQ Mode\n   ldr   sp, =__fiq_stack_end\n\n   msr   CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT  @ IRQ Mode\n   ldr   sp, =__irq_stack_end\n\n   msr   CPSR_c, #ARM_MODE_SVC | I_BIT | F_BIT @ Supervisor Mode\n   ldr   sp, =__svc_stack_end\n\n@---------------------------------------- Initialize system (boot, init)\n   bl    boot.routines\n   bl    startup.routines\n\n@---------------------------------------- Call entry point\n   b    __entry_point\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@              I N T E R R U P T    V E C T O R S                                                                      *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n   .section .text.__omnibus_interrupt_vectors, \"ax\"\n\n  .global __omnibus_interrupt_vectors\n\n__omnibus_interrupt_vectors :\n  .word !ISR!WDT      @ 0\n  .word 0             @ 1\n  .word !ISR!ARMCore0 @ 2\n  .word !ISR!ARMCore1 @ 3\n  .word !ISR!TIMER0   @ 4\n  .word !ISR!TIMER1   @ 5\n  .word !ISR!UART0    @ 6\n  .word !ISR!UART1    @ 7\n  .word !ISR!PWM0     @ 8\n  .word !ISR!I2C      @ 9\n  .word !ISR!SPI0     @ 10\n  .word !ISR!SPI1_SSP @ 11\n  .word !ISR!PLL      @ 12\n  .word !ISR!RTC      @ 13\n  .word !ISR!EINT0    @ 14\n  .word !ISR!EINT1    @ 15\n  .word !ISR!EINT2    @ 16\n  .word !ISR!EINT3    @ 17\n  .word !ISR!ADC      @ 18\n  .word !ISR!CAN_COMMON @ 19\n  .word !ISR!CAN0_TX @ 20\n  .word !ISR!CAN1_TX @ 21\n  .word !ISR!CAN2_TX @ 22\n  .word !ISR!CAN3_TX @ 23\n  .word 0            @ 24\n  .word !ISR!FULLCAN @ 25\n  .word !ISR!CAN0_RX @ 26\n  .word !ISR!CAN1_RX @ 27\n  .word !ISR!CAN2_RX @ 28\n  .word !ISR!CAN3_RX @ 29\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@        C O N T R O L   R E G I S T E R                                                                               *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  VICVectAddr = 0xFFFFF030\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@        I R Q    H A N D L E R                                                                                        *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global as_irq_handler\n  .global __entry_point\n  .type __entry_point, %function\n  .global kernel_selectTaskToRun\n  .type kernel_selectTaskToRun, %function\n\nas_irq_handler:\n@--------------------------- Adjust return address\n  sub   r14, r14, #4\n@--------------------------- Save r0 on IRQ stack\n  stmfd sp!, {r0}\n@--------------------------- Context save\n@--- R0 <- Address of current task context save\n  ldr   r0, =gRunningTaskControlBlockPtr\n  ldr   r0, [r0]\n@--- If r0 is NULL, there is no context to save\n  movs  r0, r0\n  beq   __no_context_to_save_on_irq\n@--- Save registers R1, ..., R12, LR\n  add   r0, r0, #4*4 @ Make room for sp_usr, lr_usr, cpsr_usr and r0\n  stmia r0, {r1-r12, lr}\n@--- cpsr_usr -> R8\n  mrs   r8, spsr\n@--- Save sp_usr (R8)\n  sub   r0, r0, #4*4 @ Restore original value\n  str   r8, [r0]\n@--- Store sp_usr, lr_usr\n  add   r0, r0, #4\n  stmia r0, {r13, r14}^\n@--- Store user task r0\n  add   r0, r0, #8\n  ldr   r1, [sp]\n  str   r1, [r0]\n@--------------------------- Adjust IRQ stack\n__no_context_to_save_on_irq:\n  add   sp, sp, #4\n@--------------------------- Led On (uses only r6 and r7)\n  ACTIVITY_LED_ON @ macro defined in activity_led_management.s file\n@--------------------------- IRQ Body : run interrupt service routine\n@--- R1 <- contenu du registre VICVectAddr (call interrupt routine service)\n  ldr   r1, =VICVectAddr\n  ldr   r1, [r1]\n@--- Call interrupt routine service\n  mov   lr, pc @--- Link Register -> return address\n  bx    r1\n@--- Acknowledge interrupt service (write any value into VICVectAddr register)\n  ldr   r0, =VICVectAddr\n  str   r0, [r0]\n@--------------------------- Select Running Task\n__entry_point: @ This entry point is kernel start routine\n  bl    kernel_selectTaskToRun\n@--------------------------- Context restore\n@--- r0 <- Address of current running task context save\n  ldr   r0, =gRunningTaskControlBlockPtr\n  ldr   r0, [r0]\n  movs  r0, r0\n  beq   __no_context_to_restore\n@--- Restore cpsr_usr (r1)\n  ldr   r1, [r0]\n@--- Restore cpsr_usr from r1\n  msr   spsr, r1\n@--- Restore sp_usr, lr_usr\n  add   r0, r0, #4\n  ldmia r0, {r13, r14}^\n@--- Restore registers R0, ..., R12, PC\n@    ('^' and 'pc' means return from interrupt)\n  add   r0, r0, #8\n  ldmia r0, {r0-r12, pc}^\n\n" ;

const cRegularFileWrapper gWrapperFile_53_targetTemplates (
  "s-target.s",
  "s",
  true, // Text file
  12037, // Text length
  gWrapperFileContent_53_targetTemplates
) ;

//--- File 'LPC-L2294/service-dispatcher-entry.s'

const char * gWrapperFileContent_50_targetTemplates = "  .word  \"!ENTRY!\" @ !IDX!\n" ;

const cRegularFileWrapper gWrapperFile_50_targetTemplates (
  "service-dispatcher-entry.s",
  "s",
  true, // Text file
  27, // Text length
  gWrapperFileContent_50_targetTemplates
) ;

//--- File 'LPC-L2294/service-dispatcher-header.s'

const char * gWrapperFileContent_35_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S V C    D I S P A T C H E R    T A B L E                                                            *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n__swi_dispatcher_table:\n" ;

const cRegularFileWrapper gWrapperFile_35_targetTemplates (
  "service-dispatcher-header.s",
  "s",
  true, // Text file
  630, // Text length
  gWrapperFileContent_35_targetTemplates
) ;

//--- File 'LPC-L2294/service-entry-no-return.s'

const char * gWrapperFileContent_42_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Service !ENTRY!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!ENTRY!\", \"ax\", %progbits\n	.globl	\"!ENTRY!\"\n	.align	2\n	.type	\"!ENTRY!\", %function\n	.code	32\n\n\"!ENTRY!\":\n	.fnstart\n  swi #!IDX!\n  bx  lr\n\n\".Lfunc_end_!ENTRY!\":\n  .size	\"!ENTRY!\", \".Lfunc_end_!ENTRY!\" - \"!ENTRY!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_42_targetTemplates (
  "service-entry-no-return.s",
  "s",
  true, // Text file
  513, // Text length
  gWrapperFileContent_42_targetTemplates
) ;

//--- File 'LPC-L2294/service-entry-return-value.s'

const char * gWrapperFileContent_49_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Service !ENTRY!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!ENTRY!\", \"ax\", %progbits\n	.globl	\"!ENTRY!\"\n	.align	2\n	.type	\"!ENTRY!\", %function\n	.code	32\n\n\"!ENTRY!\":\n	.fnstart\n  swi #!IDX!\n  b   xtr.user.result\n\n\".Lfunc_end_!ENTRY!\":\n  .size	\"!ENTRY!\", \".Lfunc_end_!ENTRY!\" - \"!ENTRY!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_49_targetTemplates (
  "service-entry-return-value.s",
  "s",
  true, // Text file
  526, // Text length
  gWrapperFileContent_49_targetTemplates
) ;

//--- File 'LPC-L2294/service-handler.s'

const char * gWrapperFileContent_46_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@              A R M 4    C O N T E X T                                                                                *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@ ARM4 task context is stored is an 17 * 4 byte buffer.                                                                *\n@                                                                                                                      *\n@ The gRunningTaskControlBlockPtr shared variable points to the buffer associated to the current task.                    *\n@                                                                                                                      *\n@                                                                      offset                                          *\n@                                              *---------------------*                                                 *\n@                                              | PC_USR              | +64                                             *\n@                                              | R12                 | +60                                             *\n@                                              | R11                 | +56                                             *\n@                                              | R10                 | +52                                             *\n@                                              | R9                  | +48                                             *\n@                                              | R8                  | +44                                             *\n@                                              | R7                  | +40                                             *\n@                                              | R6                  | +36                                             *\n@                                              | R5                  | +32                                             *\n@                                              | R4                  | +28                                             *\n@                                              | R3                  | +24                                             *\n@                                              | R2                  | +20                                             *\n@                                              | R1                  | +16                                             *\n@                                              | R0                  | +12                                             *\n@                                              | LR_USR              | + 8                                             *\n@    *--------------------------------*        | SP_USR              | + 4                                             *\n@    | gRunningTaskControlBlockPtr    +------> | CPSR                | + 0                                             *\n@    *--------------------------------*        *---------------------*                                                 *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@        A R M    A B I                                                                                                *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@    From document ARM IHI 0042C, current through ABI release 2.07                                                     *\n@                                                                                                                      *\n@ The first four registers r0-r3 are used to pass argument values into a subroutine and to return a result value from  *\n@ a function. They may also be used to hold intermediate values within a routine (but, in general, only between        *\n@ subroutine calls).                                                                                                   *\n@                                                                                                                      *\n@ A subroutine must preserve the contents of the registers r4-r8, r10, r11 and SP (and r9 in PCS variants that         *\n@ designate r9 as v6).                                                                                                 *\n@                                                                                                                      *\n@ So we can freely use r9 in SWI handler \? No, we preserve r4-r11                                                      *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@        S W I    H A N D L E R                                                                                        *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	.text.as_swi_handler,\"ax\",%progbits\n\n  .global as_swi_handler\n\nas_swi_handler:\n@ Here :\n@  - lr points to the next instruction after the SWI instruction\n@  - the user sp can be retrieved into reg register using mrs reg, spsr\n@  - do not modify r0-r3, they contain actual parameters\n@-------------------------- Save working registers\n  stmfd sp!, {r6-r8, lr}\n@-------------------------- Led On (uses only r6 and r7)\n  ACTIVITY_LED_ON @ macro defined in activity_led_management.s file\n@--------------------------- Get SWI Immediat value\n@   LDRH loads a halfword from memory and zero-extends it to a 32-bit word.\n  ldrh  r6, [lr, #-4] @ Get 16 last bits of swi instruction\n@--------------------------- r8 <- address of sys_xxx routine to call\n  ldr   r8, =__swi_dispatcher_table\n  ldr   r8, [r8, r6, LSL #2]\n@--------------------------- R6 <- address of gRunningTaskControlBlockPtr variable\n  ldr   r6, =gRunningTaskControlBlockPtr\n@--------------------------- Save context pointer of current running task in R7\n  ldr   r7, [r6]\n@--------------------------- Call sys_xxx routine\n  mov   lr, pc\n  bx    r8\n@--------------------------- Save 32-bit return value in R8\n  mov   r8, r0\n@--------------------------- Select Running Task\n  bl    kernel_selectTaskToRun\n@--------------------------- Restore return value from r8\n  mov   r0, r8\n@--------------------------- R2 <- address of new running task context\n@  R7: context of running task on SWI call\n@  R6: 'gRunningTaskControlBlockPtr' address\n  ldr   r2, [r6] @ R2 <- address of new running task context\n  mov   r3, r7 @ R3: context of running task on SWI call\n@--------------------------- Restore task registers\n  ldmfd sp!, {r6-r8, lr}\n@--------------------------- Context Switch\n  teq    r2, r3 @ Compare R2 (new task), with R3 (calling task)\n  moveq  pc, lr @ Return from interrupt if no context swith\n@--------------------------- Perform the context switch\n@----------- First save context of calling task\n@--- If sp is NULL, there is no context to save\n  movs  r3, r3\n  beq   __restore_context_of_running_task\n@--- Save registers R0, ..., R12, LR of calling task\n  add   r3, r3, #12 @ Make room for sp_usr, lr_usr and cpsr_usr\n  stmia r3, {r0-r12, lr}\n@--- cpsr_usr -> R8\n  mrs   r8, spsr\n@--- Save sp_usr (R8)\n  str   r8, [r3, #-12]\n@--- Store sp_usr, lr_usr\n  sub   r3, r3, #8 @ Restore original value of R8\n  stmia r3, {r13, r14}^\n@---------------------------------- Restore context of the new running task\n__restore_context_of_running_task:\n  movs  r2, r2\n  beq   __no_context_to_restore\n@--- Restore cpsr_usr from R8\n  ldr   r8, [r2]\n  msr   spsr, r8\n@--- Restore sp_usr, lr_usr\n  add   r2, r2, #4\n  ldmia r2, {r13, r14}^\n@--- Restore registers R0, ..., R12, and PC\n@    (^ and pc using perform here return from interrupt)\n  add   r2, r2, #8\n  ldmia r2, {r0-r12, pc}^\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n__no_context_to_restore:\n@--- Led Off (uses only r6 and r7)\n  ACTIVITY_LED_OFF @ macro defined in activity_led_management.s file\n@--- Set User Mode, interrupts enabled\n  msr   CPSR_c, #ARM_MODE_USER\n@--- Wait for interrupt\n__wait_interrupt:\n  b     __wait_interrupt\n\n" ;

const cRegularFileWrapper gWrapperFile_46_targetTemplates (
  "service-handler.s",
  "s",
  true, // Text file
  9642, // Text length
  gWrapperFileContent_46_targetTemplates
) ;

//--- File 'LPC-L2294/udfcoded-section-dispatcher-code.s'

const char * gWrapperFileContent_47_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@        U N D E F I N E D    I N S T R U C T I O N    H A N D L E R                                                   *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@ We use some arm undefined instructions for performing kernel defined operations that do not use context switchs.     *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@           In ARM Architecture ReferenceManual, page A3-39                                                            *\n@          A3.16.5 Architecturally Undefined Instruction space                                                         *\n@                                                                                                                      *\n@ In general, Undefined instructions might be used to extend the ARM instruction set in the future. However, it is     *\n@ intended that instructions with the following encoding will not be used for this:                                    *\n@                                                                                                                      *\n@ 3322 2222 2222 1111  1111 1100 0000 0000                                                                             *\n@ 1098 7654 3210 9876  5432 1098 7654 3210                                                                             *\n@ ---- ---- ---- ----  ---- ---- ---- ----                                                                             *\n@ cond 0111 1111 xxxx  xxxx xxxx 1111 xxxx                                                                             *\n@                                                                                                                      *\n@ If a programmer wants to use an Undefined instruction for software, purposes with minimal risk that future hardware  *\n@ will treat it as a defined instruction, one of the instructions with this encoding must be used.                     *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	.text.as_undef_handler,\"ax\",%progbits\n\n  .global as_undef_handler\n\nas_undef_handler:\n@--- Save preserved registers\n  stmfd r13!, {r7, lr}\n@--- r7 <- bits 15-8 of undef instruction\n@    LDRB loads a byte from memory and zero-extends the byte to a 32-bit word.\n  ldrb  r7, [lr, #-4 + 1] @ -4 for undef instruction, +1 for getting second byte\n@--- r12 <- address of routine to call\n  ldr   r12, =__section_dispatcher_table\n  ldr   r12, [r12, r7, LSL #2]\n@--- Call routine\n  mov   lr, pc\n  bx    r12\n@--- Return from interrupt\n  ldmfd r13!, {r7, pc}^\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n" ;

const cRegularFileWrapper gWrapperFile_47_targetTemplates (
  "udfcoded-section-dispatcher-code.s",
  "s",
  true, // Text file
  3706, // Text length
  gWrapperFileContent_47_targetTemplates
) ;

//--- File 'LPC-L2294/udfcoded-section-dispatcher-entry.s'

const char * gWrapperFileContent_45_targetTemplates = "  .word  \"!IMPLEMENTATION_ROUTINE!\" @ !IDX!, user routine !USER_ROUTINE!\n" ;

const cRegularFileWrapper gWrapperFile_45_targetTemplates (
  "udfcoded-section-dispatcher-entry.s",
  "s",
  true, // Text file
  73, // Text length
  gWrapperFileContent_45_targetTemplates
) ;

//--- File 'LPC-L2294/udfcoded-section-dispatcher-header.s'

const char * gWrapperFileContent_34_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S E C T I O N   T A B L E                                                                            *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  UNDEFINED_INSTRUCTION = 0xE7F000F0\n  I_BIT_MASK = 0x80      @ IRQ is disabled when I bit is set\n\n__section_dispatcher_table:\n" ;

const cRegularFileWrapper gWrapperFile_34_targetTemplates (
  "udfcoded-section-dispatcher-header.s",
  "s",
  true, // Text file
  733, // Text length
  gWrapperFileContent_34_targetTemplates
) ;

//--- File 'LPC-L2294/udfcoded-section-invocation-from-unknown-mode.s'

const char * gWrapperFileContent_38_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Section !USER_ROUTINE!, implemented by !IMPLEMENTATION_ROUTINE!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!USER_ROUTINE!\", \"ax\", %progbits\n	.global	\"!USER_ROUTINE!\"\n	.type	\"!USER_ROUTINE!\", %function\n\n	.align 4\n	.code	32\n\n\"!USER_ROUTINE!\":\n	.fnstart\n  mrs    r12, cpsr\n  ands   r12, r12, #I_BIT_MASK\n  beq    \"!IMPLEMENTATION_ROUTINE!\"\n  .word  UNDEFINED_INSTRUCTION + (!IDX! << 8)\n  bx  lr\n\n\".Lfunc_end_!USER_ROUTINE!\":\n  .size	\"!USER_ROUTINE!\", \".Lfunc_end_!USER_ROUTINE!\" - \"!USER_ROUTINE!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_38_targetTemplates (
  "udfcoded-section-invocation-from-unknown-mode.s",
  "s",
  true, // Text file
  738, // Text length
  gWrapperFileContent_38_targetTemplates
) ;

//--- File 'LPC-L2294/udfcoded-section-invocation-from-user-mode.s'

const char * gWrapperFileContent_37_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Section !USER_ROUTINE!, implemented by !IMPLEMENTATION_ROUTINE!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!USER_ROUTINE!\", \"ax\", %progbits\n	.global	\"!USER_ROUTINE!\"\n	.type	\"!USER_ROUTINE!\", %function\n\n	.align	2\n	.code	32\n\n\"!USER_ROUTINE!\":\n	.fnstart\n  .word  UNDEFINED_INSTRUCTION + (!IDX! << 8)\n  bx  lr\n\n\".Lfunc_end_!USER_ROUTINE!\":\n  .size	\"!USER_ROUTINE!\", \".Lfunc_end_!USER_ROUTINE!\" - \"!USER_ROUTINE!\"\n  .cantunwind\n	.fnend\n" ;

const cRegularFileWrapper gWrapperFile_37_targetTemplates (
  "udfcoded-section-invocation-from-user-mode.s",
  "s",
  true, // Text file
  651, // Text length
  gWrapperFileContent_37_targetTemplates
) ;

//--- File 'LPC-L2294/undefined-interrupt.s'

const char * gWrapperFileContent_52_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Undefined interrupt !ISR!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	!ISR! = 0xFFFFFFFF\n\n" ;

const cRegularFileWrapper gWrapperFile_52_targetTemplates (
  "undefined-interrupt.s",
  "s",
  true, // Text file
  293, // Text length
  gWrapperFileContent_52_targetTemplates
) ;

//--- File 'LPC-L2294/xtr-interrupt-handler.s'

const char * gWrapperFileContent_41_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@   I N T E R R U P T   H A N D L E R                                                                                  *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global \"!ISR!\"\n  .type \"!ISR!\", %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global \"!HANDLER!\"\n  .type \"!HANDLER!\", %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n\"!ISR!\":\n@----------------------------------------- Call Interrupt handler\n  b    \"!HANDLER!\"\n\n" ;

const cRegularFileWrapper gWrapperFile_41_targetTemplates (
  "xtr-interrupt-handler.s",
  "s",
  true, // Text file
  1045, // Text length
  gWrapperFileContent_41_targetTemplates
) ;

//--- All files of 'LPC-L2294' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_1 [25] = {
  & gWrapperFile_43_targetTemplates,
  & gWrapperFile_54_targetTemplates,
  & gWrapperFile_55_targetTemplates,
  & gWrapperFile_57_targetTemplates,
  & gWrapperFile_48_targetTemplates,
  & gWrapperFile_56_targetTemplates,
  & gWrapperFile_44_targetTemplates,
  & gWrapperFile_40_targetTemplates,
  & gWrapperFile_51_targetTemplates,
  & gWrapperFile_36_targetTemplates,
  & gWrapperFile_39_targetTemplates,
  & gWrapperFile_53_targetTemplates,
  & gWrapperFile_50_targetTemplates,
  & gWrapperFile_35_targetTemplates,
  & gWrapperFile_42_targetTemplates,
  & gWrapperFile_49_targetTemplates,
  & gWrapperFile_46_targetTemplates,
  & gWrapperFile_47_targetTemplates,
  & gWrapperFile_45_targetTemplates,
  & gWrapperFile_34_targetTemplates,
  & gWrapperFile_38_targetTemplates,
  & gWrapperFile_37_targetTemplates,
  & gWrapperFile_52_targetTemplates,
  & gWrapperFile_41_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'LPC-L2294' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_1 [1] = {
  NULL
} ;

//--- Directory 'LPC-L2294'

const cDirectoryWrapper gWrapperDirectory_1_targetTemplates (
  "LPC-L2294",
  24,
  gWrapperAllFiles_targetTemplates_1,
  0,
  gWrapperAllDirectories_targetTemplates_1
) ;

//--- File 'teensy-3-1/MK20D7-pm.svd.omnibus-import'

const char * gWrapperFileContent_73_targetTemplates = "//------------------------------------------------------------------------------\n// MK20D7: MK20D7 Freescale Microcontroller\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: ADC [2]\n//        ADC0 at 0x4003b000\n//        ADC1 at 0x400bb000\n//------------------------------------------------------------------------------\n\nregisters ADC [2 @at 0x4003b000 0x400bb000]\n          ADC0 @at 0x4003b000\n          ADC1 @at 0x400bb000 {\n//---  Registers SC1(A,B): ADC status and control registers 1\n  SC1 [2 @offset 0x0 @inc 0x4]\n  SC1A @offset 0x0\n  SC1B @offset 0x4 $u32 {\n    24\n    COCO // at 7: Conversion complete flag\n    AIEN // at 6: Interrupt enable\n    DIFF // at 5: Differential mode enable\n    ADCH:5 // at 0: Input channel select\n  }\n\n//---  Register CFG1: ADC configuration register 1\n  CFG1 @offset 0x8 $u32 {\n    24\n    ADLPC // at 7: Low-power configuration\n    ADIV:2 // at 5: Clock divide select\n    ADLSMP // at 4: Sample time configuration\n    MODE:2 // at 2: Conversion mode selection\n    ADICLK:2 // at 0: Input clock select\n  }\n\n//---  Register CFG2: Configuration register 2\n  CFG2 @offset 0xc $u32 {\n    27\n    MUXSEL // at 4: ADC Mux select\n    ADACKEN // at 3: Asynchronous clock output enable\n    ADHSC // at 2: High speed configuration\n    ADLSTS:2 // at 0: Long sample time select\n  }\n\n//---  Registers R(A,B): ADC data result register\n  R [2 @offset 0x10 @inc 0x4]\n  RA @offset 0x10\n  RB @offset 0x14 $u32 {\n    16\n    D:16 // at 0: Data result\n  }\n\n//---  Registers CV(1,2): Compare value registers\n  CV [2 @offset 0x18 @inc 0x4]\n  CV1 @offset 0x18\n  CV2 @offset 0x1c $u32 {\n    16\n    CV:16 // at 0: Compare value\n  }\n\n//---  Register SC2: Status and control register 2\n  SC2 @offset 0x20 $u32 {\n    24\n    ADACT // at 7: Conversion active\n    ADTRG // at 6: Conversion trigger select\n    ACFE // at 5: Compare function enable\n    ACFGT // at 4: Compare function greater than enable\n    ACREN // at 3: Compare function range enable\n    DMAEN // at 2: DMA enable\n    REFSEL:2 // at 0: Voltage reference selection\n  }\n\n//---  Register SC3: Status and control register 3\n  SC3 @offset 0x24 $u32 {\n    24\n    CAL // at 7: Calibration\n    CALF // at 6: Calibration failed flag\n    2\n    ADCO // at 3: Continuous conversion enable\n    AVGE // at 2: Hardware average enable\n    AVGS:2 // at 0: Hardware average select\n  }\n\n//---  Register OFS: ADC offset correction register\n  OFS @offset 0x28 $u32 {\n    16\n    OFS:16 // at 0: Offset error correction value\n  }\n\n//---  Register PG: ADC plus-side gain register\n  PG @offset 0x2c $u32 {\n    16\n    PG:16 // at 0: Plus-side gain\n  }\n\n//---  Register MG: ADC minus-side gain register\n  MG @offset 0x30 $u32 {\n    16\n    MG:16 // at 0: Minus-side gain\n  }\n\n//---  Register CLPD: ADC plus-side general calibration value register\n  CLPD @offset 0x34 $u32 {\n    26\n    CLPD:6 // at 0: no description available\n  }\n\n//---  Register CLPS: ADC plus-side general calibration value register\n  CLPS @offset 0x38 $u32 {\n    26\n    CLPS:6 // at 0: no description available\n  }\n\n//---  Register CLP4: ADC plus-side general calibration value register\n  CLP4 @offset 0x3c $u32 {\n    22\n    CLP4:10 // at 0: no description available\n  }\n\n//---  Register CLP3: ADC plus-side general calibration value register\n  CLP3 @offset 0x40 $u32 {\n    23\n    CLP3:9 // at 0: no description available\n  }\n\n//---  Register CLP2: ADC plus-side general calibration value register\n  CLP2 @offset 0x44 $u32 {\n    24\n    CLP2:8 // at 0: no description available\n  }\n\n//---  Register CLP1: ADC plus-side general calibration value register\n  CLP1 @offset 0x48 $u32 {\n    25\n    CLP1:7 // at 0: no description available\n  }\n\n//---  Register CLP0: ADC plus-side general calibration value register\n  CLP0 @offset 0x4c $u32 {\n    26\n    CLP0:6 // at 0: no description available\n  }\n\n//---  Register PGA: ADC PGA register\n  PGA @offset 0x50 $u32 {\n    8\n    PGAEN // at 23: PGA enable\n    2\n    PGALPb // at 20: PGA low-power mode control\n    PGAG:4 // at 16: PGA gain setting\n    16\n  }\n\n//---  Register CLMD: ADC minus-side general calibration value register\n  CLMD @offset 0x54 $u32 {\n    26\n    CLMD:6 // at 0: no description available\n  }\n\n//---  Register CLMS: ADC minus-side general calibration value register\n  CLMS @offset 0x58 $u32 {\n    26\n    CLMS:6 // at 0: no description available\n  }\n\n//---  Register CLM4: ADC minus-side general calibration value register\n  CLM4 @offset 0x5c $u32 {\n    22\n    CLM4:10 // at 0: no description available\n  }\n\n//---  Register CLM3: ADC minus-side general calibration value register\n  CLM3 @offset 0x60 $u32 {\n    23\n    CLM3:9 // at 0: no description available\n  }\n\n//---  Register CLM2: ADC minus-side general calibration value register\n  CLM2 @offset 0x64 $u32 {\n    24\n    CLM2:8 // at 0: no description available\n  }\n\n//---  Register CLM1: ADC minus-side general calibration value register\n  CLM1 @offset 0x68 $u32 {\n    25\n    CLM1:7 // at 0: no description available\n  }\n\n//---  Register CLM0: ADC minus-side general calibration value register\n  CLM0 @offset 0x6c $u32 {\n    26\n    CLM0:6 // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: AIPS [2]\n//        AIPS0 at 0x40000000\n//        AIPS1 at 0x40080000\n//------------------------------------------------------------------------------\n\nregisters AIPS [2 @at 0x40000000 0x40080000]\n          AIPS0 @at 0x40000000\n          AIPS1 @at 0x40080000 {\n//---  Register MPRA: Master Privilege Register A\n  MPRA @offset 0x0 $u32 {\n    1\n    MTR0 // at 30: Master trusted for read\n    MTW0 // at 29: Master trusted for writes\n    MPL0 // at 28: Master privilege level\n    1\n    MTR1 // at 26: Master trusted for read\n    MTW1 // at 25: Master trusted for writes\n    MPL1 // at 24: Master privilege level\n    1\n    MTR2 // at 22: Master trusted for read\n    MTW2 // at 21: Master trusted for writes\n    MPL2 // at 20: Master privilege level\n    1\n    MTR3 // at 18: Master trusted for read\n    MTW3 // at 17: Master trusted for writes\n    MPL3 // at 16: Master privilege level\n    16\n  }\n\n//---  Register PACRA: Peripheral Access Control Register\n  PACRA @offset 0x20 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRB: Peripheral Access Control Register\n  PACRB @offset 0x24 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRC: Peripheral Access Control Register\n  PACRC @offset 0x28 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRD: Peripheral Access Control Register\n  PACRD @offset 0x2c $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRE: Peripheral Access Control Register\n  PACRE @offset 0x40 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRF: Peripheral Access Control Register\n  PACRF @offset 0x44 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRG: Peripheral Access Control Register\n  PACRG @offset 0x48 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRH: Peripheral Access Control Register\n  PACRH @offset 0x4c $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRI: Peripheral Access Control Register\n  PACRI @offset 0x50 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRJ: Peripheral Access Control Register\n  PACRJ @offset 0x54 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRK: Peripheral Access Control Register\n  PACRK @offset 0x58 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRL: Peripheral Access Control Register\n  PACRL @offset 0x5c $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRM: Peripheral Access Control Register\n  PACRM @offset 0x60 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRN: Peripheral Access Control Register\n  PACRN @offset 0x64 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRO: Peripheral Access Control Register\n  PACRO @offset 0x68 $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n//---  Register PACRP: Peripheral Access Control Register\n  PACRP @offset 0x6c $u32 {\n    1\n    SP0 // at 30: Supervisor protect\n    WP0 // at 29: Write protect\n    TP0 // at 28: Trusted protect\n    1\n    SP1 // at 26: Supervisor protect\n    WP1 // at 25: Write protect\n    TP1 // at 24: Trusted protect\n    1\n    SP2 // at 22: Supervisor protect\n    WP2 // at 21: Write protect\n    TP2 // at 20: Trusted protect\n    1\n    SP3 // at 18: Supervisor protect\n    WP3 // at 17: Write protect\n    TP3 // at 16: Trusted protect\n    1\n    SP4 // at 14: Supervisor protect\n    WP4 // at 13: Write protect\n    TP4 // at 12: Trusted protect\n    1\n    SP5 // at 10: Supervisor protect\n    WP5 // at 9: Write protect\n    TP5 // at 8: Trusted protect\n    1\n    SP6 // at 6: Supervisor protect\n    WP6 // at 5: Write protect\n    TP6 // at 4: Trusted protect\n    1\n    SP7 // at 2: Supervisor protect\n    WP7 // at 1: Write protect\n    TP7 // at 0: Trusted protect\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral AXBS: Crossbar switch\n//------------------------------------------------------------------------------\n\nregisters AXBS @at 0x40004000 {\n//---  Registers PRS(0,1,2,3): Priority Registers Slave\n  PRS [4 @offset 0x0 @inc 0x100]\n  PRS0 @offset 0x0\n  PRS1 @offset 0x100\n  PRS2 @offset 0x200\n  PRS3 @offset 0x300 $u32 {\n    9\n    M5:3 // at 20: Master 5 priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M4:3 // at 16: Master 4 priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M3:3 // at 12: Master 3 priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M2:3 // at 8: Master 2 priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M1:3 // at 4: Master 1 priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M0:3 // at 0: Master 0 priority. Sets the arbitration priority for this port on the associated slave port.\n  }\n\n//---  Registers CRS(0,1,2,3): Control Register\n  CRS [4 @offset 0x10 @inc 0x100]\n  CRS0 @offset 0x10\n  CRS1 @offset 0x110\n  CRS2 @offset 0x210\n  CRS3 @offset 0x310 $u32 {\n    RO // at 31: Read only\n    HLP // at 30: Halt low priority\n    20\n    ARB:2 // at 8: Arbitration mode\n    2\n    PCTL:2 // at 4: Parking control\n    1\n    PARK:3 // at 0: Park\n  }\n\n//---  Registers MGPCR(0,1,2,3): Master General Purpose Control Register\n  MGPCR [4 @offset 0x800 @inc 0x100]\n  MGPCR0 @offset 0x800\n  MGPCR1 @offset 0x900\n  MGPCR2 @offset 0xa00\n  MGPCR3 @offset 0xb00 $u32 {\n    29\n    AULB:3 // at 0: Arbitrates on undefined length bursts\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral CAN0: Flex Controller Area Network module\n//------------------------------------------------------------------------------\n\nregisters CAN0 @at 0x40024000 {\n//---  Register MCR: Module Configuration Register\n  MCR @offset 0x0 $u32 {\n    MDIS // at 31: Module Disable\n    FRZ // at 30: Freeze Enable\n    RFEN // at 29: Rx FIFO Enable\n    HALT // at 28: Halt FlexCAN\n    NOTRDY // at 27: FlexCAN Not Ready\n    WAKMSK // at 26: Wake Up Interrupt Mask\n    SOFTRST // at 25: Soft Reset\n    FRZACK // at 24: Freeze Mode Acknowledge\n    SUPV // at 23: Supervisor Mode\n    SLFWAK // at 22: Self Wake Up\n    WRNEN // at 21: Warning Interrupt Enable\n    LPMACK // at 20: Low Power Mode Acknowledge\n    2\n    SRXDIS // at 17: Self Reception Disable\n    IRMQ // at 16: Individual Rx Masking and Queue Enable\n    2\n    LPRIOEN // at 13: Local Priority Enable\n    AEN // at 12: Abort Enable\n    2\n    IDAM:2 // at 8: ID Acceptance Mode\n    1\n    MAXMB:7 // at 0: Number of the Last Message Buffer\n  }\n\n//---  Register CTRL1: Control 1 Register\n  CTRL1 @offset 0x4 $u32 {\n    PRESDIV:8 // at 24: Prescaler Division Factor\n    RJW:2 // at 22: Resync Jump Width\n    PSEG1:3 // at 19: Phase Segment 1\n    PSEG2:3 // at 16: Phase Segment 2\n    BOFFMSK // at 15: Bus Off Mask\n    ERRMSK // at 14: Error Mask\n    CLKSRC // at 13: CAN Engine Clock Source\n    LPB // at 12: Loop Back Mode\n    TWRNMSK // at 11: Tx Warning Interrupt Mask\n    RWRNMSK // at 10: Rx Warning Interrupt Mask\n    2\n    SMP // at 7: CAN Bit Sampling\n    BOFFREC // at 6: Bus Off Recovery\n    TSYN // at 5: Timer Sync\n    LBUF // at 4: Lowest Buffer Transmitted First\n    LOM // at 3: Listen-Only Mode\n    PROPSEG:3 // at 0: Propagation Segment\n  }\n\n//---  Register TIMER: Free Running Timer\n  TIMER @offset 0x8 $u32 {\n    16\n    TIMER:16 // at 0: Timer value\n  }\n\n//---  Register RXMGMASK: Rx Mailboxes Global Mask Register\n  RXMGMASK @offset 0x10 $u32 {\n    MG:32 // at 0: Rx Mailboxes Global Mask Bits\n  }\n\n//---  Register RX14MASK: Rx 14 Mask Register\n  RX14MASK @offset 0x14 $u32 {\n    RX14M:32 // at 0: Rx Buffer 14 Mask Bits\n  }\n\n//---  Register RX15MASK: Rx 15 Mask Register\n  RX15MASK @offset 0x18 $u32 {\n    RX15M:32 // at 0: Rx Buffer 15 Mask Bits\n  }\n\n//---  Register ECR: Error Counter\n  ECR @offset 0x1c $u32 {\n    16\n    RXERRCNT:8 // at 8: Receive Error Counter\n    TXERRCNT:8 // at 0: Transmit Error Counter\n  }\n\n//---  Register ESR1: Error and Status 1 Register\n  ESR1 @offset 0x20 $u32 {\n    13\n    SYNCH // at 18: CAN Synchronization Status\n    TWRNINT // at 17: Tx Warning Interrupt Flag\n    RWRNINT // at 16: Rx Warning Interrupt Flag\n    BIT1ERR // at 15: Bit1 Error\n    BIT0ERR // at 14: Bit0 Error\n    ACKERR // at 13: Acknowledge Error\n    CRCERR // at 12: Cyclic Redundancy Check Error\n    FRMERR // at 11: Form Error\n    STFERR // at 10: Stuffing Error\n    TXWRN // at 9: TX Error Warning\n    RXWRN // at 8: Rx Error Warning\n    IDLE // at 7: no description available\n    TX // at 6: FlexCAN in Transmission\n    FLTCONF:2 // at 4: Fault Confinement State\n    RX // at 3: FlexCAN in Reception\n    BOFFINT // at 2: 'Bus Off' Interrupt\n    ERRINT // at 1: Error Interrupt\n    WAKINT // at 0: Wake-Up Interrupt\n  }\n\n//---  Register IMASK2: Interrupt Masks 2 Register\n  IMASK2 @offset 0x24 $u32 {\n    BUFHM:32 // at 0: Buffer MBi Mask\n  }\n\n//---  Register IMASK1: Interrupt Masks 1 Register\n  IMASK1 @offset 0x28 $u32 {\n    BUFLM:32 // at 0: Buffer MBi Mask\n  }\n\n//---  Register IFLAG2: Interrupt Flags 2 Register\n  IFLAG2 @offset 0x2c $u32 {\n    BUFHI:32 // at 0: Buffer MBi Interrupt\n  }\n\n//---  Register IFLAG1: Interrupt Flags 1 Register\n  IFLAG1 @offset 0x30 $u32 {\n    BUF31TO8I:24 // at 8: Buffer MBi Interrupt\n    BUF7I // at 7: Buffer MB7 Interrupt or \"Rx FIFO Overflow\"\n    BUF6I // at 6: Buffer MB6 Interrupt or \"Rx FIFO Warning\"\n    BUF5I // at 5: Buffer MB5 Interrupt or \"Frames available in Rx FIFO\"\n    BUF4TO0I:5 // at 0: Buffer MBi Interrupt or \"reserved\"\n  }\n\n//---  Register CTRL2: Control 2 Register\n  CTRL2 @offset 0x34 $u32 {\n    3\n    WRMFRZ // at 28: Write-Access to Memory in Freeze mode\n    RFFN:4 // at 24: Number of Rx FIFO Filters\n    TASD:5 // at 19: Tx Arbitration Start Delay\n    MRP // at 18: Mailboxes Reception Priority\n    RRS // at 17: Remote Request Storing\n    EACEN // at 16: Entire Frame Arbitration Field Comparison Enable for Rx Mailboxes\n    16\n  }\n\n//---  Register ESR2: Error and Status 2 Register\n  ESR2 @offset 0x38 $u32 {\n    9\n    LPTM:7 // at 16: Lowest Priority Tx Mailbox\n    1\n    VPS // at 14: Valid Priority Status\n    IMB // at 13: Inactive Mailbox\n    13\n  }\n\n//---  Register CRCR: CRC Register\n  CRCR @offset 0x44 $u32 {\n    9\n    MBCRC:7 // at 16: CRC Mailbox\n    1\n    TXCRC:15 // at 0: CRC Transmitted\n  }\n\n//---  Register RXFGMASK: Rx FIFO Global Mask Register\n  RXFGMASK @offset 0x48 $u32 {\n    FGM:32 // at 0: Rx FIFO Global Mask Bits\n  }\n\n//---  Register RXFIR: Rx FIFO Information Register\n  RXFIR @offset 0x4c $u32 {\n    23\n    IDHIT:9 // at 0: Identifier Acceptance Filter Hit Indicator\n  }\n\n//---  Register CS0: Message Buffer 0 CS Register\n  CS0 @offset 0x80 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID0: Message Buffer 0 ID Register\n  ID0 @offset 0x84 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD00: Message Buffer 0 WORD0 Register\n  WORD00 @offset 0x88 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD10: Message Buffer 0 WORD1 Register\n  WORD10 @offset 0x8c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS1: Message Buffer 1 CS Register\n  CS1 @offset 0x90 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID1: Message Buffer 1 ID Register\n  ID1 @offset 0x94 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD01: Message Buffer 1 WORD0 Register\n  WORD01 @offset 0x98 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD11: Message Buffer 1 WORD1 Register\n  WORD11 @offset 0x9c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS2: Message Buffer 2 CS Register\n  CS2 @offset 0xa0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID2: Message Buffer 2 ID Register\n  ID2 @offset 0xa4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD02: Message Buffer 2 WORD0 Register\n  WORD02 @offset 0xa8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD12: Message Buffer 2 WORD1 Register\n  WORD12 @offset 0xac $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS3: Message Buffer 3 CS Register\n  CS3 @offset 0xb0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID3: Message Buffer 3 ID Register\n  ID3 @offset 0xb4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD03: Message Buffer 3 WORD0 Register\n  WORD03 @offset 0xb8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD13: Message Buffer 3 WORD1 Register\n  WORD13 @offset 0xbc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS4: Message Buffer 4 CS Register\n  CS4 @offset 0xc0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID4: Message Buffer 4 ID Register\n  ID4 @offset 0xc4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD04: Message Buffer 4 WORD0 Register\n  WORD04 @offset 0xc8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD14: Message Buffer 4 WORD1 Register\n  WORD14 @offset 0xcc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS5: Message Buffer 5 CS Register\n  CS5 @offset 0xd0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID5: Message Buffer 5 ID Register\n  ID5 @offset 0xd4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD05: Message Buffer 5 WORD0 Register\n  WORD05 @offset 0xd8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD15: Message Buffer 5 WORD1 Register\n  WORD15 @offset 0xdc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS6: Message Buffer 6 CS Register\n  CS6 @offset 0xe0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID6: Message Buffer 6 ID Register\n  ID6 @offset 0xe4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD06: Message Buffer 6 WORD0 Register\n  WORD06 @offset 0xe8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD16: Message Buffer 6 WORD1 Register\n  WORD16 @offset 0xec $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS7: Message Buffer 7 CS Register\n  CS7 @offset 0xf0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID7: Message Buffer 7 ID Register\n  ID7 @offset 0xf4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD07: Message Buffer 7 WORD0 Register\n  WORD07 @offset 0xf8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD17: Message Buffer 7 WORD1 Register\n  WORD17 @offset 0xfc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS8: Message Buffer 8 CS Register\n  CS8 @offset 0x100 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID8: Message Buffer 8 ID Register\n  ID8 @offset 0x104 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD08: Message Buffer 8 WORD0 Register\n  WORD08 @offset 0x108 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD18: Message Buffer 8 WORD1 Register\n  WORD18 @offset 0x10c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS9: Message Buffer 9 CS Register\n  CS9 @offset 0x110 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID9: Message Buffer 9 ID Register\n  ID9 @offset 0x114 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD09: Message Buffer 9 WORD0 Register\n  WORD09 @offset 0x118 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD19: Message Buffer 9 WORD1 Register\n  WORD19 @offset 0x11c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS10: Message Buffer 10 CS Register\n  CS10 @offset 0x120 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID10: Message Buffer 10 ID Register\n  ID10 @offset 0x124 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD010: Message Buffer 10 WORD0 Register\n  WORD010 @offset 0x128 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD110: Message Buffer 10 WORD1 Register\n  WORD110 @offset 0x12c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS11: Message Buffer 11 CS Register\n  CS11 @offset 0x130 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID11: Message Buffer 11 ID Register\n  ID11 @offset 0x134 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD011: Message Buffer 11 WORD0 Register\n  WORD011 @offset 0x138 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD111: Message Buffer 11 WORD1 Register\n  WORD111 @offset 0x13c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS12: Message Buffer 12 CS Register\n  CS12 @offset 0x140 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID12: Message Buffer 12 ID Register\n  ID12 @offset 0x144 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD012: Message Buffer 12 WORD0 Register\n  WORD012 @offset 0x148 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD112: Message Buffer 12 WORD1 Register\n  WORD112 @offset 0x14c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS13: Message Buffer 13 CS Register\n  CS13 @offset 0x150 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID13: Message Buffer 13 ID Register\n  ID13 @offset 0x154 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD013: Message Buffer 13 WORD0 Register\n  WORD013 @offset 0x158 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD113: Message Buffer 13 WORD1 Register\n  WORD113 @offset 0x15c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS14: Message Buffer 14 CS Register\n  CS14 @offset 0x160 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID14: Message Buffer 14 ID Register\n  ID14 @offset 0x164 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD014: Message Buffer 14 WORD0 Register\n  WORD014 @offset 0x168 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD114: Message Buffer 14 WORD1 Register\n  WORD114 @offset 0x16c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS15: Message Buffer 15 CS Register\n  CS15 @offset 0x170 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID15: Message Buffer 15 ID Register\n  ID15 @offset 0x174 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD015: Message Buffer 15 WORD0 Register\n  WORD015 @offset 0x178 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD115: Message Buffer 15 WORD1 Register\n  WORD115 @offset 0x17c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Registers RXIMR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Rx Individual Mask Registers\n  RXIMR [16 @offset 0x880 @inc 0x4]\n  RXIMR0 @offset 0x880\n  RXIMR1 @offset 0x884\n  RXIMR2 @offset 0x888\n  RXIMR3 @offset 0x88c\n  RXIMR4 @offset 0x890\n  RXIMR5 @offset 0x894\n  RXIMR6 @offset 0x898\n  RXIMR7 @offset 0x89c\n  RXIMR8 @offset 0x8a0\n  RXIMR9 @offset 0x8a4\n  RXIMR10 @offset 0x8a8\n  RXIMR11 @offset 0x8ac\n  RXIMR12 @offset 0x8b0\n  RXIMR13 @offset 0x8b4\n  RXIMR14 @offset 0x8b8\n  RXIMR15 @offset 0x8bc $u32 {\n    MI:32 // at 0: Individual Mask Bits\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: CMP [3]\n//        CMP0 at 0x40073000\n//        CMP1 at 0x40073008\n//        CMP2 at 0x40073010\n//------------------------------------------------------------------------------\n\nregisters CMP [3 @at 0x40073000 0x40073008 0x40073010]\n          CMP0 @at 0x40073000\n          CMP1 @at 0x40073008\n          CMP2 @at 0x40073010 {\n//---  Register CR0: CMP Control Register 0\n  CR0 @offset 0x0 $u8 {\n    1\n    FILTER_CNT:3 // at 4: Filter Sample Count\n    2\n    HYSTCTR:2 // at 0: Comparator hard block hysteresis control\n  }\n\n//---  Register CR1: CMP Control Register 1\n  CR1 @offset 0x1 $u8 {\n    SE // at 7: Sample Enable\n    WE // at 6: Windowing Enable\n    1\n    PMODE // at 4: Power Mode Select\n    INV // at 3: Comparator INVERT\n    COS // at 2: Comparator Output Select\n    OPE // at 1: Comparator Output Pin Enable\n    EN // at 0: Comparator Module Enable\n  }\n\n//---  Register FPR: CMP Filter Period Register\n  FPR @offset 0x2 $u8 {\n    FILT_PER:8 // at 0: Filter Sample Period\n  }\n\n//---  Register SCR: CMP Status and Control Register\n  SCR @offset 0x3 $u8 {\n    1\n    DMAEN // at 6: DMA Enable Control\n    1\n    IER // at 4: Comparator Interrupt Enable Rising\n    IEF // at 3: Comparator Interrupt Enable Falling\n    CFR // at 2: Analog Comparator Flag Rising\n    CFF // at 1: Analog Comparator Flag Falling\n    COUT // at 0: Analog Comparator Output\n  }\n\n//---  Register DACCR: DAC Control Register\n  DACCR @offset 0x4 $u8 {\n    DACEN // at 7: DAC Enable\n    VRSEL // at 6: Supply Voltage Reference Source Select\n    VOSEL:6 // at 0: DAC Output Voltage Select\n  }\n\n//---  Register MUXCR: MUX Control Register\n  MUXCR @offset 0x5 $u8 {\n    2\n    PSEL:3 // at 3: Plus Input MUX Control\n    MSEL:3 // at 0: Minus Input MUX Control\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral CMT: Carrier Modulator Transmitter\n//------------------------------------------------------------------------------\n\nregisters CMT @at 0x40062000 {\n//---  Register CGH1: CMT Carrier Generator High Data Register 1\n  CGH1 @offset 0x0 $u8 {\n    PH:8 // at 0: Primary Carrier High Time Data Value\n  }\n\n//---  Register CGL1: CMT Carrier Generator Low Data Register 1\n  CGL1 @offset 0x1 $u8 {\n    PL:8 // at 0: Primary Carrier Low Time Data Value\n  }\n\n//---  Register CGH2: CMT Carrier Generator High Data Register 2\n  CGH2 @offset 0x2 $u8 {\n    SH:8 // at 0: Secondary Carrier High Time Data Value\n  }\n\n//---  Register CGL2: CMT Carrier Generator Low Data Register 2\n  CGL2 @offset 0x3 $u8 {\n    SL:8 // at 0: Secondary Carrier Low Time Data Value\n  }\n\n//---  Register OC: CMT Output Control Register\n  OC @offset 0x4 $u8 {\n    IROL // at 7: IRO Latch Control\n    CMTPOL // at 6: CMT Output Polarity\n    IROPEN // at 5: IRO Pin Enable\n    5\n  }\n\n//---  Register MSC: CMT Modulator Status and Control Register\n  MSC @offset 0x5 $u8 {\n    EOCF // at 7: End Of Cycle Status Flag\n    CMTDIV:2 // at 5: CMT Clock Divide Prescaler\n    EXSPC // at 4: Extended Space Enable\n    BASE // at 3: Baseband Enable\n    FSK // at 2: FSK Mode Select\n    EOCIE // at 1: End of Cycle Interrupt Enable\n    MCGEN // at 0: Modulator and Carrier Generator Enable\n  }\n\n//---  Register CMD1: CMT Modulator Data Register Mark High\n  CMD1 @offset 0x6 $u8 {\n    MB:8 // at 0: no description available\n  }\n\n//---  Register CMD2: CMT Modulator Data Register Mark Low\n  CMD2 @offset 0x7 $u8 {\n    MB:8 // at 0: no description available\n  }\n\n//---  Register CMD3: CMT Modulator Data Register Space High\n  CMD3 @offset 0x8 $u8 {\n    SB:8 // at 0: no description available\n  }\n\n//---  Register CMD4: CMT Modulator Data Register Space Low\n  CMD4 @offset 0x9 $u8 {\n    SB:8 // at 0: no description available\n  }\n\n//---  Register PPS: CMT Primary Prescaler Register\n  PPS @offset 0xa $u8 {\n    4\n    PPSDIV:4 // at 0: Primary Prescaler Divider\n  }\n\n//---  Register DMA: CMT Direct Memory Access\n  DMA @offset 0xb $u8 {\n    7\n    DMA // at 0: DMA Enable\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral CRC: Cyclic Redundancy Check\n//------------------------------------------------------------------------------\n\nregisters CRC @at 0x40032000 {\n//---  Register CRCLL: CRC_CRCLL register.\n  CRCLL @offset 0x0 $u8 {\n    CRCLL:8 // at 0: CRCLL stores the first 8 bits of the 32 bit CRC\n  }\n\n//---  Register CRC: CRC Data Register\n  CRC @offset 0x0 $u32 {\n    HU:8 // at 24: CRC High Upper Byte\n    HL:8 // at 16: CRC High Lower Byte\n    LU:8 // at 8: CRC Low Upper Byte\n    LL:8 // at 0: CRC Low Lower Byte\n  }\n\n//---  Register CRCL: CRC_CRCL register.\n  CRCL @offset 0x0 $u16 {\n    CRCL:16 // at 0: CRCL stores the lower 16 bits of the 16/32 bit CRC\n  }\n\n//---  Register CRCLU: CRC_CRCLU register.\n  CRCLU @offset 0x1 $u8 {\n    CRCLU:8 // at 0: CRCLL stores the second 8 bits of the 32 bit CRC\n  }\n\n//---  Register CRCHL: CRC_CRCHL register.\n  CRCHL @offset 0x2 $u8 {\n    CRCHL:8 // at 0: CRCHL stores the third 8 bits of the 32 bit CRC\n  }\n\n//---  Register CRCH: CRC_CRCH register.\n  CRCH @offset 0x2 $u16 {\n    CRCH:16 // at 0: CRCL stores the high 16 bits of the 16/32 bit CRC\n  }\n\n//---  Register CRCHU: CRC_CRCHU register.\n  CRCHU @offset 0x3 $u8 {\n    CRCHU:8 // at 0: CRCHU stores the fourth 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLY: CRC Polynomial Register\n  GPOLY @offset 0x4 $u32 {\n    HIGH:16 // at 16: High polynominal half-word\n    LOW:16 // at 0: Low polynominal half-word\n  }\n\n//---  Register GPOLYLL: CRC_GPOLYLL register.\n  GPOLYLL @offset 0x4 $u8 {\n    GPOLYLL:8 // at 0: POLYLL stores the first 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLYL: CRC_GPOLYL register.\n  GPOLYL @offset 0x4 $u16 {\n    GPOLYL:16 // at 0: POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value\n  }\n\n//---  Register GPOLYLU: CRC_GPOLYLU register.\n  GPOLYLU @offset 0x5 $u8 {\n    GPOLYLU:8 // at 0: POLYLL stores the second 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLYH: CRC_GPOLYH register.\n  GPOLYH @offset 0x6 $u16 {\n    GPOLYH:16 // at 0: POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value\n  }\n\n//---  Register GPOLYHL: CRC_GPOLYHL register.\n  GPOLYHL @offset 0x6 $u8 {\n    GPOLYHL:8 // at 0: POLYHL stores the third 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLYHU: CRC_GPOLYHU register.\n  GPOLYHU @offset 0x7 $u8 {\n    GPOLYHU:8 // at 0: POLYHU stores the fourth 8 bits of the 32 bit CRC\n  }\n\n//---  Register CTRL: CRC Control Register\n  CTRL @offset 0x8 $u32 {\n    TOT:2 // at 30: Type of Transpose for Writes\n    TOTR:2 // at 28: Type of Transpose for Read\n    1\n    FXOR // at 26: Complement Read of CRC data register\n    WAS // at 25: Write CRC data register as seed\n    TCRC // at 24: no description available\n    24\n  }\n\n//---  Register CTRLHU: CRC_CTRLHU register.\n  CTRLHU @offset 0xb $u8 {\n    TOT:2 // at 6: no description available\n    TOTR:2 // at 4: no description available\n    1\n    FXOR // at 2: no description available\n    WAS // at 1: no description available\n    TCRC // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral DAC0: 12-Bit Digital-to-Analog Converter\n//------------------------------------------------------------------------------\n\nregisters DAC0 @at 0x400cc000 {\n//---  Registers DATL(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data Low Register\n  DATL [16 @offset 0x0 @inc 0x2]\n  DAT0L @offset 0x0\n  DAT1L @offset 0x2\n  DAT2L @offset 0x4\n  DAT3L @offset 0x6\n  DAT4L @offset 0x8\n  DAT5L @offset 0xa\n  DAT6L @offset 0xc\n  DAT7L @offset 0xe\n  DAT8L @offset 0x10\n  DAT9L @offset 0x12\n  DAT10L @offset 0x14\n  DAT11L @offset 0x16\n  DAT12L @offset 0x18\n  DAT13L @offset 0x1a\n  DAT14L @offset 0x1c\n  DAT15L @offset 0x1e $u8 {\n    DATA:8 // at 0: no description available\n  }\n\n//---  Registers DATH(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data High Register\n  DATH [16 @offset 0x1 @inc 0x2]\n  DAT0H @offset 0x1\n  DAT1H @offset 0x3\n  DAT2H @offset 0x5\n  DAT3H @offset 0x7\n  DAT4H @offset 0x9\n  DAT5H @offset 0xb\n  DAT6H @offset 0xd\n  DAT7H @offset 0xf\n  DAT8H @offset 0x11\n  DAT9H @offset 0x13\n  DAT10H @offset 0x15\n  DAT11H @offset 0x17\n  DAT12H @offset 0x19\n  DAT13H @offset 0x1b\n  DAT14H @offset 0x1d\n  DAT15H @offset 0x1f $u8 {\n    4\n    DATA:4 // at 0: no description available\n  }\n\n//---  Register SR: DAC Status Register\n  SR @offset 0x20 $u8 {\n    5\n    DACBFWMF // at 2: DAC buffer watermark flag\n    DACBFRPTF // at 1: DAC buffer read pointer top position flag\n    DACBFRPBF // at 0: DAC buffer read pointer bottom position flag\n  }\n\n//---  Register C0: DAC Control Register\n  C0 @offset 0x21 $u8 {\n    DACEN // at 7: DAC enable\n    DACRFS // at 6: DAC Reference Select\n    DACTRGSEL // at 5: DAC trigger select\n    DACSWTRG // at 4: DAC software trigger\n    LPEN // at 3: DAC low power control\n    DACBWIEN // at 2: DAC buffer watermark interrupt enable\n    DACBTIEN // at 1: DAC buffer read pointer top flag interrupt enable\n    DACBBIEN // at 0: DAC buffer read pointer bottom flag interrupt enable\n  }\n\n//---  Register C1: DAC Control Register 1\n  C1 @offset 0x22 $u8 {\n    DMAEN // at 7: DMA enable select\n    2\n    DACBFWM:2 // at 3: DAC buffer watermark select\n    DACBFMD:2 // at 1: DAC buffer work mode select\n    DACBFEN // at 0: DAC buffer enable\n  }\n\n//---  Register C2: DAC Control Register 2\n  C2 @offset 0x23 $u8 {\n    DACBFRP:4 // at 4: DAC buffer read pointer\n    DACBFUP:4 // at 0: DAC buffer upper limit\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral DMA: Enhanced direct memory access controller\n//------------------------------------------------------------------------------\n\nregisters DMA @at 0x40008000 {\n//---  Register CR: Control Register\n  CR @offset 0x0 $u32 {\n    14\n    CX // at 17: Cancel Transfer\n    ECX // at 16: Error Cancel Transfer\n    8\n    EMLM // at 7: Enable Minor Loop Mapping\n    CLM // at 6: Continuous Link Mode\n    HALT // at 5: Halt DMA Operations\n    HOE // at 4: Halt On Error\n    1\n    ERCA // at 2: Enable Round Robin Channel Arbitration\n    EDBG // at 1: Enable Debug\n    1\n  }\n\n//---  Register ES: Error Status Register\n  ES @offset 0x4 $u32 {\n    VLD // at 31: no description available\n    14\n    ECX // at 16: Transfer Cancelled\n    1\n    CPE // at 14: Channel Priority Error\n    2\n    ERRCHN:4 // at 8: Error Channel Number or Cancelled Channel Number\n    SAE // at 7: Source Address Error\n    SOE // at 6: Source Offset Error\n    DAE // at 5: Destination Address Error\n    DOE // at 4: Destination Offset Error\n    NCE // at 3: NBYTES/CITER Configuration Error\n    SGE // at 2: Scatter/Gather Configuration Error\n    SBE // at 1: Source Bus Error\n    DBE // at 0: Destination Bus Error\n  }\n\n//---  Register ERQ: Enable Request Register\n  ERQ @offset 0xc $u32 {\n    16\n    ERQ15 // at 15: Enable DMA Request 15\n    ERQ14 // at 14: Enable DMA Request 14\n    ERQ13 // at 13: Enable DMA Request 13\n    ERQ12 // at 12: Enable DMA Request 12\n    ERQ11 // at 11: Enable DMA Request 11\n    ERQ10 // at 10: Enable DMA Request 10\n    ERQ9 // at 9: Enable DMA Request 9\n    ERQ8 // at 8: Enable DMA Request 8\n    ERQ7 // at 7: Enable DMA Request 7\n    ERQ6 // at 6: Enable DMA Request 6\n    ERQ5 // at 5: Enable DMA Request 5\n    ERQ4 // at 4: Enable DMA Request 4\n    ERQ3 // at 3: Enable DMA Request 3\n    ERQ2 // at 2: Enable DMA Request 2\n    ERQ1 // at 1: Enable DMA Request 1\n    ERQ0 // at 0: Enable DMA Request 0\n  }\n\n//---  Register EEI: Enable Error Interrupt Register\n  EEI @offset 0x14 $u32 {\n    16\n    EEI15 // at 15: Enable Error Interrupt 15\n    EEI14 // at 14: Enable Error Interrupt 14\n    EEI13 // at 13: Enable Error Interrupt 13\n    EEI12 // at 12: Enable Error Interrupt 12\n    EEI11 // at 11: Enable Error Interrupt 11\n    EEI10 // at 10: Enable Error Interrupt 10\n    EEI9 // at 9: Enable Error Interrupt 9\n    EEI8 // at 8: Enable Error Interrupt 8\n    EEI7 // at 7: Enable Error Interrupt 7\n    EEI6 // at 6: Enable Error Interrupt 6\n    EEI5 // at 5: Enable Error Interrupt 5\n    EEI4 // at 4: Enable Error Interrupt 4\n    EEI3 // at 3: Enable Error Interrupt 3\n    EEI2 // at 2: Enable Error Interrupt 2\n    EEI1 // at 1: Enable Error Interrupt 1\n    EEI0 // at 0: Enable Error Interrupt 0\n  }\n\n//---  Register CEEI: Clear Enable Error Interrupt Register\n  CEEI @offset 0x18 $u8 {\n    NOP // at 7: no description available\n    CAEE // at 6: Clear All Enable Error Interrupts\n    2\n    CEEI:4 // at 0: Clear Enable Error Interrupt\n  }\n\n//---  Register SEEI: Set Enable Error Interrupt Register\n  SEEI @offset 0x19 $u8 {\n    NOP // at 7: no description available\n    SAEE // at 6: Sets All Enable Error Interrupts\n    2\n    SEEI:4 // at 0: Set Enable Error Interrupt\n  }\n\n//---  Register CERQ: Clear Enable Request Register\n  CERQ @offset 0x1a $u8 {\n    NOP // at 7: no description available\n    CAER // at 6: Clear All Enable Requests\n    2\n    CERQ:4 // at 0: Clear Enable Request\n  }\n\n//---  Register SERQ: Set Enable Request Register\n  SERQ @offset 0x1b $u8 {\n    NOP // at 7: no description available\n    SAER // at 6: Set All Enable Requests\n    2\n    SERQ:4 // at 0: Set enable request\n  }\n\n//---  Register CDNE: Clear DONE Status Bit Register\n  CDNE @offset 0x1c $u8 {\n    NOP // at 7: no description available\n    CADN // at 6: Clears All DONE Bits\n    2\n    CDNE:4 // at 0: Clear DONE Bit\n  }\n\n//---  Register SSRT: Set START Bit Register\n  SSRT @offset 0x1d $u8 {\n    NOP // at 7: no description available\n    SAST // at 6: Set All START Bits (activates all channels)\n    2\n    SSRT:4 // at 0: Set START Bit\n  }\n\n//---  Register CERR: Clear Error Register\n  CERR @offset 0x1e $u8 {\n    NOP // at 7: no description available\n    CAEI // at 6: Clear All Error Indicators\n    2\n    CERR:4 // at 0: Clear Error Indicator\n  }\n\n//---  Register CINT: Clear Interrupt Request Register\n  CINT @offset 0x1f $u8 {\n    NOP // at 7: no description available\n    CAIR // at 6: Clear All Interrupt Requests\n    2\n    CINT:4 // at 0: Clear Interrupt Request\n  }\n\n//---  Register INT: Interrupt Request Register\n  INT @offset 0x24 $u32 {\n    16\n    INT15 // at 15: Interrupt Request 15\n    INT14 // at 14: Interrupt Request 14\n    INT13 // at 13: Interrupt Request 13\n    INT12 // at 12: Interrupt Request 12\n    INT11 // at 11: Interrupt Request 11\n    INT10 // at 10: Interrupt Request 10\n    INT9 // at 9: Interrupt Request 9\n    INT8 // at 8: Interrupt Request 8\n    INT7 // at 7: Interrupt Request 7\n    INT6 // at 6: Interrupt Request 6\n    INT5 // at 5: Interrupt Request 5\n    INT4 // at 4: Interrupt Request 4\n    INT3 // at 3: Interrupt Request 3\n    INT2 // at 2: Interrupt Request 2\n    INT1 // at 1: Interrupt Request 1\n    INT0 // at 0: Interrupt Request 0\n  }\n\n//---  Register ERR: Error Register\n  ERR @offset 0x2c $u32 {\n    16\n    ERR15 // at 15: Error In Channel 15\n    ERR14 // at 14: Error In Channel 14\n    ERR13 // at 13: Error In Channel 13\n    ERR12 // at 12: Error In Channel 12\n    ERR11 // at 11: Error In Channel 11\n    ERR10 // at 10: Error In Channel 10\n    ERR9 // at 9: Error In Channel 9\n    ERR8 // at 8: Error In Channel 8\n    ERR7 // at 7: Error In Channel 7\n    ERR6 // at 6: Error In Channel 6\n    ERR5 // at 5: Error In Channel 5\n    ERR4 // at 4: Error In Channel 4\n    ERR3 // at 3: Error In Channel 3\n    ERR2 // at 2: Error In Channel 2\n    ERR1 // at 1: Error In Channel 1\n    ERR0 // at 0: Error In Channel 0\n  }\n\n//---  Register HRS: Hardware Request Status Register\n  HRS @offset 0x34 $u32 {\n    16\n    HRS15 // at 15: Hardware Request Status Channel 15\n    HRS14 // at 14: Hardware Request Status Channel 14\n    HRS13 // at 13: Hardware Request Status Channel 13\n    HRS12 // at 12: Hardware Request Status Channel 12\n    HRS11 // at 11: Hardware Request Status Channel 11\n    HRS10 // at 10: Hardware Request Status Channel 10\n    HRS9 // at 9: Hardware Request Status Channel 9\n    HRS8 // at 8: Hardware Request Status Channel 8\n    HRS7 // at 7: Hardware Request Status Channel 7\n    HRS6 // at 6: Hardware Request Status Channel 6\n    HRS5 // at 5: Hardware Request Status Channel 5\n    HRS4 // at 4: Hardware Request Status Channel 4\n    HRS3 // at 3: Hardware Request Status Channel 3\n    HRS2 // at 2: Hardware Request Status Channel 2\n    HRS1 // at 1: Hardware Request Status Channel 1\n    HRS0 // at 0: Hardware Request Status Channel 0\n  }\n\n//---  Registers DCHPRI(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12): Channel n Priority Register\n  DCHPRI [16 @offset 0x100 @inc 0x1]\n  DCHPRI3 @offset 0x100\n  DCHPRI2 @offset 0x101\n  DCHPRI1 @offset 0x102\n  DCHPRI0 @offset 0x103\n  DCHPRI7 @offset 0x104\n  DCHPRI6 @offset 0x105\n  DCHPRI5 @offset 0x106\n  DCHPRI4 @offset 0x107\n  DCHPRI11 @offset 0x108\n  DCHPRI10 @offset 0x109\n  DCHPRI9 @offset 0x10a\n  DCHPRI8 @offset 0x10b\n  DCHPRI15 @offset 0x10c\n  DCHPRI14 @offset 0x10d\n  DCHPRI13 @offset 0x10e\n  DCHPRI12 @offset 0x10f $u8 {\n    ECP // at 7: Enable Channel Preemption\n    DPA // at 6: Disable Preempt Ability\n    2\n    CHPRI:4 // at 0: Channel n Arbitration Priority\n  }\n\n//---  Registers TCD_SADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Source Address\n  TCD_SADDR [16 @offset 0x1000 @inc 0x20]\n  TCD0_SADDR @offset 0x1000\n  TCD1_SADDR @offset 0x1020\n  TCD2_SADDR @offset 0x1040\n  TCD3_SADDR @offset 0x1060\n  TCD4_SADDR @offset 0x1080\n  TCD5_SADDR @offset 0x10a0\n  TCD6_SADDR @offset 0x10c0\n  TCD7_SADDR @offset 0x10e0\n  TCD8_SADDR @offset 0x1100\n  TCD9_SADDR @offset 0x1120\n  TCD10_SADDR @offset 0x1140\n  TCD11_SADDR @offset 0x1160\n  TCD12_SADDR @offset 0x1180\n  TCD13_SADDR @offset 0x11a0\n  TCD14_SADDR @offset 0x11c0\n  TCD15_SADDR @offset 0x11e0 $u32 {\n    SADDR:32 // at 0: Source Address\n  }\n\n//---  Registers TCD_SOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Source Address Offset\n  TCD_SOFF [16 @offset 0x1004 @inc 0x20]\n  TCD0_SOFF @offset 0x1004\n  TCD1_SOFF @offset 0x1024\n  TCD2_SOFF @offset 0x1044\n  TCD3_SOFF @offset 0x1064\n  TCD4_SOFF @offset 0x1084\n  TCD5_SOFF @offset 0x10a4\n  TCD6_SOFF @offset 0x10c4\n  TCD7_SOFF @offset 0x10e4\n  TCD8_SOFF @offset 0x1104\n  TCD9_SOFF @offset 0x1124\n  TCD10_SOFF @offset 0x1144\n  TCD11_SOFF @offset 0x1164\n  TCD12_SOFF @offset 0x1184\n  TCD13_SOFF @offset 0x11a4\n  TCD14_SOFF @offset 0x11c4\n  TCD15_SOFF @offset 0x11e4 $u16 {\n    SOFF:16 // at 0: Source address signed offset\n  }\n\n//---  Registers TCD_ATTR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Transfer Attributes\n  TCD_ATTR [16 @offset 0x1006 @inc 0x20]\n  TCD0_ATTR @offset 0x1006\n  TCD1_ATTR @offset 0x1026\n  TCD2_ATTR @offset 0x1046\n  TCD3_ATTR @offset 0x1066\n  TCD4_ATTR @offset 0x1086\n  TCD5_ATTR @offset 0x10a6\n  TCD6_ATTR @offset 0x10c6\n  TCD7_ATTR @offset 0x10e6\n  TCD8_ATTR @offset 0x1106\n  TCD9_ATTR @offset 0x1126\n  TCD10_ATTR @offset 0x1146\n  TCD11_ATTR @offset 0x1166\n  TCD12_ATTR @offset 0x1186\n  TCD13_ATTR @offset 0x11a6\n  TCD14_ATTR @offset 0x11c6\n  TCD15_ATTR @offset 0x11e6 $u16 {\n    SMOD:5 // at 11: Source Address Modulo.\n    SSIZE:3 // at 8: Source data transfer size\n    DMOD:5 // at 3: Destination Address Modulo\n    DSIZE:3 // at 0: Destination Data Transfer Size\n  }\n\n//---  Registers TCD_NBYTES_MLOFFYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)\n  TCD_NBYTES_MLOFFYES [16 @offset 0x1008 @inc 0x20]\n  TCD0_NBYTES_MLOFFYES @offset 0x1008\n  TCD1_NBYTES_MLOFFYES @offset 0x1028\n  TCD2_NBYTES_MLOFFYES @offset 0x1048\n  TCD3_NBYTES_MLOFFYES @offset 0x1068\n  TCD4_NBYTES_MLOFFYES @offset 0x1088\n  TCD5_NBYTES_MLOFFYES @offset 0x10a8\n  TCD6_NBYTES_MLOFFYES @offset 0x10c8\n  TCD7_NBYTES_MLOFFYES @offset 0x10e8\n  TCD8_NBYTES_MLOFFYES @offset 0x1108\n  TCD9_NBYTES_MLOFFYES @offset 0x1128\n  TCD10_NBYTES_MLOFFYES @offset 0x1148\n  TCD11_NBYTES_MLOFFYES @offset 0x1168\n  TCD12_NBYTES_MLOFFYES @offset 0x1188\n  TCD13_NBYTES_MLOFFYES @offset 0x11a8\n  TCD14_NBYTES_MLOFFYES @offset 0x11c8\n  TCD15_NBYTES_MLOFFYES @offset 0x11e8 $u32 {\n    SMLOE // at 31: Source Minor Loop Offset Enable\n    DMLOE // at 30: Destination Minor Loop Offset enable\n    MLOFF:20 // at 10: If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.\n    NBYTES:10 // at 0: Minor Byte Transfer Count\n  }\n\n//---  Registers TCD_NBYTES_MLOFFNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)\n  TCD_NBYTES_MLOFFNO [16 @offset 0x1008 @inc 0x20]\n  TCD0_NBYTES_MLOFFNO @offset 0x1008\n  TCD1_NBYTES_MLOFFNO @offset 0x1028\n  TCD2_NBYTES_MLOFFNO @offset 0x1048\n  TCD3_NBYTES_MLOFFNO @offset 0x1068\n  TCD4_NBYTES_MLOFFNO @offset 0x1088\n  TCD5_NBYTES_MLOFFNO @offset 0x10a8\n  TCD6_NBYTES_MLOFFNO @offset 0x10c8\n  TCD7_NBYTES_MLOFFNO @offset 0x10e8\n  TCD8_NBYTES_MLOFFNO @offset 0x1108\n  TCD9_NBYTES_MLOFFNO @offset 0x1128\n  TCD10_NBYTES_MLOFFNO @offset 0x1148\n  TCD11_NBYTES_MLOFFNO @offset 0x1168\n  TCD12_NBYTES_MLOFFNO @offset 0x1188\n  TCD13_NBYTES_MLOFFNO @offset 0x11a8\n  TCD14_NBYTES_MLOFFNO @offset 0x11c8\n  TCD15_NBYTES_MLOFFNO @offset 0x11e8 $u32 {\n    SMLOE // at 31: Source Minor Loop Offset Enable\n    DMLOE // at 30: Destination Minor Loop Offset enable\n    NBYTES:30 // at 0: Minor Byte Transfer Count\n  }\n\n//---  Registers TCD_NBYTES_MLNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Minor Byte Count (Minor Loop Disabled)\n  TCD_NBYTES_MLNO [16 @offset 0x1008 @inc 0x20]\n  TCD0_NBYTES_MLNO @offset 0x1008\n  TCD1_NBYTES_MLNO @offset 0x1028\n  TCD2_NBYTES_MLNO @offset 0x1048\n  TCD3_NBYTES_MLNO @offset 0x1068\n  TCD4_NBYTES_MLNO @offset 0x1088\n  TCD5_NBYTES_MLNO @offset 0x10a8\n  TCD6_NBYTES_MLNO @offset 0x10c8\n  TCD7_NBYTES_MLNO @offset 0x10e8\n  TCD8_NBYTES_MLNO @offset 0x1108\n  TCD9_NBYTES_MLNO @offset 0x1128\n  TCD10_NBYTES_MLNO @offset 0x1148\n  TCD11_NBYTES_MLNO @offset 0x1168\n  TCD12_NBYTES_MLNO @offset 0x1188\n  TCD13_NBYTES_MLNO @offset 0x11a8\n  TCD14_NBYTES_MLNO @offset 0x11c8\n  TCD15_NBYTES_MLNO @offset 0x11e8 $u32 {\n    NBYTES:32 // at 0: Minor Byte Transfer Count\n  }\n\n//---  Registers TCD_SLAST(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Last Source Address Adjustment\n  TCD_SLAST [16 @offset 0x100c @inc 0x20]\n  TCD0_SLAST @offset 0x100c\n  TCD1_SLAST @offset 0x102c\n  TCD2_SLAST @offset 0x104c\n  TCD3_SLAST @offset 0x106c\n  TCD4_SLAST @offset 0x108c\n  TCD5_SLAST @offset 0x10ac\n  TCD6_SLAST @offset 0x10cc\n  TCD7_SLAST @offset 0x10ec\n  TCD8_SLAST @offset 0x110c\n  TCD9_SLAST @offset 0x112c\n  TCD10_SLAST @offset 0x114c\n  TCD11_SLAST @offset 0x116c\n  TCD12_SLAST @offset 0x118c\n  TCD13_SLAST @offset 0x11ac\n  TCD14_SLAST @offset 0x11cc\n  TCD15_SLAST @offset 0x11ec $u32 {\n    SLAST:32 // at 0: Last source Address Adjustment\n  }\n\n//---  Registers TCD_DADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Destination Address\n  TCD_DADDR [16 @offset 0x1010 @inc 0x20]\n  TCD0_DADDR @offset 0x1010\n  TCD1_DADDR @offset 0x1030\n  TCD2_DADDR @offset 0x1050\n  TCD3_DADDR @offset 0x1070\n  TCD4_DADDR @offset 0x1090\n  TCD5_DADDR @offset 0x10b0\n  TCD6_DADDR @offset 0x10d0\n  TCD7_DADDR @offset 0x10f0\n  TCD8_DADDR @offset 0x1110\n  TCD9_DADDR @offset 0x1130\n  TCD10_DADDR @offset 0x1150\n  TCD11_DADDR @offset 0x1170\n  TCD12_DADDR @offset 0x1190\n  TCD13_DADDR @offset 0x11b0\n  TCD14_DADDR @offset 0x11d0\n  TCD15_DADDR @offset 0x11f0 $u32 {\n    DADDR:32 // at 0: Destination Address\n  }\n\n//---  Registers TCD_DOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Signed Destination Address Offset\n  TCD_DOFF [16 @offset 0x1014 @inc 0x20]\n  TCD0_DOFF @offset 0x1014\n  TCD1_DOFF @offset 0x1034\n  TCD2_DOFF @offset 0x1054\n  TCD3_DOFF @offset 0x1074\n  TCD4_DOFF @offset 0x1094\n  TCD5_DOFF @offset 0x10b4\n  TCD6_DOFF @offset 0x10d4\n  TCD7_DOFF @offset 0x10f4\n  TCD8_DOFF @offset 0x1114\n  TCD9_DOFF @offset 0x1134\n  TCD10_DOFF @offset 0x1154\n  TCD11_DOFF @offset 0x1174\n  TCD12_DOFF @offset 0x1194\n  TCD13_DOFF @offset 0x11b4\n  TCD14_DOFF @offset 0x11d4\n  TCD15_DOFF @offset 0x11f4 $u16 {\n    DOFF:16 // at 0: Destination Address Signed offset\n  }\n\n//---  Registers TCD_CITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)\n  TCD_CITER_ELINKYES [16 @offset 0x1016 @inc 0x20]\n  TCD0_CITER_ELINKYES @offset 0x1016\n  TCD1_CITER_ELINKYES @offset 0x1036\n  TCD2_CITER_ELINKYES @offset 0x1056\n  TCD3_CITER_ELINKYES @offset 0x1076\n  TCD4_CITER_ELINKYES @offset 0x1096\n  TCD5_CITER_ELINKYES @offset 0x10b6\n  TCD6_CITER_ELINKYES @offset 0x10d6\n  TCD7_CITER_ELINKYES @offset 0x10f6\n  TCD8_CITER_ELINKYES @offset 0x1116\n  TCD9_CITER_ELINKYES @offset 0x1136\n  TCD10_CITER_ELINKYES @offset 0x1156\n  TCD11_CITER_ELINKYES @offset 0x1176\n  TCD12_CITER_ELINKYES @offset 0x1196\n  TCD13_CITER_ELINKYES @offset 0x11b6\n  TCD14_CITER_ELINKYES @offset 0x11d6\n  TCD15_CITER_ELINKYES @offset 0x11f6 $u16 {\n    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete\n    2\n    LINKCH:4 // at 9: Link Channel Number\n    CITER:9 // at 0: Current Major Iteration Count\n  }\n\n//---  Registers TCD_CITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)\n  TCD_CITER_ELINKNO [16 @offset 0x1016 @inc 0x20]\n  TCD0_CITER_ELINKNO @offset 0x1016\n  TCD1_CITER_ELINKNO @offset 0x1036\n  TCD2_CITER_ELINKNO @offset 0x1056\n  TCD3_CITER_ELINKNO @offset 0x1076\n  TCD4_CITER_ELINKNO @offset 0x1096\n  TCD5_CITER_ELINKNO @offset 0x10b6\n  TCD6_CITER_ELINKNO @offset 0x10d6\n  TCD7_CITER_ELINKNO @offset 0x10f6\n  TCD8_CITER_ELINKNO @offset 0x1116\n  TCD9_CITER_ELINKNO @offset 0x1136\n  TCD10_CITER_ELINKNO @offset 0x1156\n  TCD11_CITER_ELINKNO @offset 0x1176\n  TCD12_CITER_ELINKNO @offset 0x1196\n  TCD13_CITER_ELINKNO @offset 0x11b6\n  TCD14_CITER_ELINKNO @offset 0x11d6\n  TCD15_CITER_ELINKNO @offset 0x11f6 $u16 {\n    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete\n    CITER:15 // at 0: Current Major Iteration Count\n  }\n\n//---  Registers TCD_DLASTSGA(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Last Destination Address Adjustment/Scatter Gather Address\n  TCD_DLASTSGA [16 @offset 0x1018 @inc 0x20]\n  TCD0_DLASTSGA @offset 0x1018\n  TCD1_DLASTSGA @offset 0x1038\n  TCD2_DLASTSGA @offset 0x1058\n  TCD3_DLASTSGA @offset 0x1078\n  TCD4_DLASTSGA @offset 0x1098\n  TCD5_DLASTSGA @offset 0x10b8\n  TCD6_DLASTSGA @offset 0x10d8\n  TCD7_DLASTSGA @offset 0x10f8\n  TCD8_DLASTSGA @offset 0x1118\n  TCD9_DLASTSGA @offset 0x1138\n  TCD10_DLASTSGA @offset 0x1158\n  TCD11_DLASTSGA @offset 0x1178\n  TCD12_DLASTSGA @offset 0x1198\n  TCD13_DLASTSGA @offset 0x11b8\n  TCD14_DLASTSGA @offset 0x11d8\n  TCD15_DLASTSGA @offset 0x11f8 $u32 {\n    DLASTSGA:32 // at 0: no description available\n  }\n\n//---  Registers TCD_CSR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Control and Status\n  TCD_CSR [16 @offset 0x101c @inc 0x20]\n  TCD0_CSR @offset 0x101c\n  TCD1_CSR @offset 0x103c\n  TCD2_CSR @offset 0x105c\n  TCD3_CSR @offset 0x107c\n  TCD4_CSR @offset 0x109c\n  TCD5_CSR @offset 0x10bc\n  TCD6_CSR @offset 0x10dc\n  TCD7_CSR @offset 0x10fc\n  TCD8_CSR @offset 0x111c\n  TCD9_CSR @offset 0x113c\n  TCD10_CSR @offset 0x115c\n  TCD11_CSR @offset 0x117c\n  TCD12_CSR @offset 0x119c\n  TCD13_CSR @offset 0x11bc\n  TCD14_CSR @offset 0x11dc\n  TCD15_CSR @offset 0x11fc $u16 {\n    BWC:2 // at 14: Bandwidth Control\n    2\n    MAJORLINKCH:4 // at 8: Link Channel Number\n    DONE // at 7: Channel Done\n    ACTIVE // at 6: Channel Active\n    MAJORELINK // at 5: Enable channel-to-channel linking on major loop complete\n    ESG // at 4: Enable Scatter/Gather Processing\n    DREQ // at 3: Disable Request\n    INTHALF // at 2: Enable an interrupt when major counter is half complete.\n    INTMAJOR // at 1: Enable an interrupt when major iteration count completes\n    START // at 0: Channel Start\n  }\n\n//---  Registers TCD_BITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)\n  TCD_BITER_ELINKYES [16 @offset 0x101e @inc 0x20]\n  TCD0_BITER_ELINKYES @offset 0x101e\n  TCD1_BITER_ELINKYES @offset 0x103e\n  TCD2_BITER_ELINKYES @offset 0x105e\n  TCD3_BITER_ELINKYES @offset 0x107e\n  TCD4_BITER_ELINKYES @offset 0x109e\n  TCD5_BITER_ELINKYES @offset 0x10be\n  TCD6_BITER_ELINKYES @offset 0x10de\n  TCD7_BITER_ELINKYES @offset 0x10fe\n  TCD8_BITER_ELINKYES @offset 0x111e\n  TCD9_BITER_ELINKYES @offset 0x113e\n  TCD10_BITER_ELINKYES @offset 0x115e\n  TCD11_BITER_ELINKYES @offset 0x117e\n  TCD12_BITER_ELINKYES @offset 0x119e\n  TCD13_BITER_ELINKYES @offset 0x11be\n  TCD14_BITER_ELINKYES @offset 0x11de\n  TCD15_BITER_ELINKYES @offset 0x11fe $u16 {\n    ELINK // at 15: Enables channel-to-channel linking on minor loop complete\n    2\n    LINKCH:4 // at 9: Link Channel Number\n    BITER:9 // at 0: Starting Major Iteration Count\n  }\n\n//---  Registers TCD_BITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)\n  TCD_BITER_ELINKNO [16 @offset 0x101e @inc 0x20]\n  TCD0_BITER_ELINKNO @offset 0x101e\n  TCD1_BITER_ELINKNO @offset 0x103e\n  TCD2_BITER_ELINKNO @offset 0x105e\n  TCD3_BITER_ELINKNO @offset 0x107e\n  TCD4_BITER_ELINKNO @offset 0x109e\n  TCD5_BITER_ELINKNO @offset 0x10be\n  TCD6_BITER_ELINKNO @offset 0x10de\n  TCD7_BITER_ELINKNO @offset 0x10fe\n  TCD8_BITER_ELINKNO @offset 0x111e\n  TCD9_BITER_ELINKNO @offset 0x113e\n  TCD10_BITER_ELINKNO @offset 0x115e\n  TCD11_BITER_ELINKNO @offset 0x117e\n  TCD12_BITER_ELINKNO @offset 0x119e\n  TCD13_BITER_ELINKNO @offset 0x11be\n  TCD14_BITER_ELINKNO @offset 0x11de\n  TCD15_BITER_ELINKNO @offset 0x11fe $u16 {\n    ELINK // at 15: Enables channel-to-channel linking on minor loop complete\n    BITER:15 // at 0: Starting Major Iteration Count\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral DMAMUX: DMA channel multiplexor\n//------------------------------------------------------------------------------\n\nregisters DMAMUX @at 0x40021000 {\n//---  Registers CHCFG(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Channel Configuration Register\n  CHCFG [16 @offset 0x0 @inc 0x1]\n  CHCFG0 @offset 0x0\n  CHCFG1 @offset 0x1\n  CHCFG2 @offset 0x2\n  CHCFG3 @offset 0x3\n  CHCFG4 @offset 0x4\n  CHCFG5 @offset 0x5\n  CHCFG6 @offset 0x6\n  CHCFG7 @offset 0x7\n  CHCFG8 @offset 0x8\n  CHCFG9 @offset 0x9\n  CHCFG10 @offset 0xa\n  CHCFG11 @offset 0xb\n  CHCFG12 @offset 0xc\n  CHCFG13 @offset 0xd\n  CHCFG14 @offset 0xe\n  CHCFG15 @offset 0xf $u8 {\n    ENBL // at 7: DMA Channel Enable\n    TRIG // at 6: DMA Channel Trigger Enable\n    SOURCE:6 // at 0: DMA Channel Source (slot)\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral EWM: External Watchdog Monitor\n//------------------------------------------------------------------------------\n\nregisters EWM @at 0x40061000 {\n//---  Register CTRL: Control Register\n  CTRL @offset 0x0 $u8 {\n    4\n    INTEN // at 3: Interrupt Enable.\n    INEN // at 2: Input Enable.\n    ASSIN // at 1: EWM_in's Assertion State Select.\n    EWMEN // at 0: EWM enable.\n  }\n\n//---  Register SERV: Service Register\n  SERV @offset 0x1 $u8 {\n    SERVICE:8 // at 0: no description available\n  }\n\n//---  Register CMPL: Compare Low Register\n  CMPL @offset 0x2 $u8 {\n    COMPAREL:8 // at 0: no description available\n  }\n\n//---  Register CMPH: Compare High Register\n  CMPH @offset 0x3 $u8 {\n    COMPAREH:8 // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FB: FlexBus external bus interface\n//------------------------------------------------------------------------------\n\nregisters FB @at 0x4000c000 {\n//---  Registers CSAR(0,1,2,3,4,5): Chip select address register\n  CSAR [6 @offset 0x0 @inc 0xc]\n  CSAR0 @offset 0x0\n  CSAR1 @offset 0xc\n  CSAR2 @offset 0x18\n  CSAR3 @offset 0x24\n  CSAR4 @offset 0x30\n  CSAR5 @offset 0x3c $u32 {\n    BA:16 // at 16: Base address\n    16\n  }\n\n//---  Registers CSMR(0,1,2,3,4,5): Chip select mask register\n  CSMR [6 @offset 0x4 @inc 0xc]\n  CSMR0 @offset 0x4\n  CSMR1 @offset 0x10\n  CSMR2 @offset 0x1c\n  CSMR3 @offset 0x28\n  CSMR4 @offset 0x34\n  CSMR5 @offset 0x40 $u32 {\n    BAM:16 // at 16: Base address mask\n    7\n    WP // at 8: Write protect\n    7\n    V // at 0: Valid\n  }\n\n//---  Registers CSCR(0,1,2,3,4,5): Chip select control register\n  CSCR [6 @offset 0x8 @inc 0xc]\n  CSCR0 @offset 0x8\n  CSCR1 @offset 0x14\n  CSCR2 @offset 0x20\n  CSCR3 @offset 0x2c\n  CSCR4 @offset 0x38\n  CSCR5 @offset 0x44 $u32 {\n    SWS:6 // at 26: Secondary wait states\n    2\n    SWSEN // at 23: Secondary wait state enable\n    EXTS // at 22: no description available\n    ASET:2 // at 20: Address setup\n    RDAH:2 // at 18: Read address hold or deselect\n    WRAH:2 // at 16: Write address hold or deselect\n    WS:6 // at 10: Wait states\n    BLS // at 9: Byte-lane shift\n    AA // at 8: Auto-acknowledge enable\n    PS:2 // at 6: Port size\n    BEM // at 5: Byte-enable mode\n    BSTR // at 4: Burst-read enable\n    BSTW // at 3: Burst-write enable\n    3\n  }\n\n//---  Register CSPMCR: Chip select port multiplexing control register\n  CSPMCR @offset 0x60 $u32 {\n    GROUP1:4 // at 28: FlexBus signal group 1 multiplex control\n    GROUP2:4 // at 24: FlexBus signal group 2 multiplex control\n    GROUP3:4 // at 20: FlexBus signal group 3 multiplex control\n    GROUP4:4 // at 16: FlexBus signal group 4 multiplex control\n    GROUP5:4 // at 12: FlexBus signal group 5 multiplex control\n    12\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FMC: Flash Memory Controller\n//------------------------------------------------------------------------------\n\nregisters FMC @at 0x4001f000 {\n//---  Register PFAPR: Flash Access Protection Register\n  PFAPR @offset 0x0 $u32 {\n    8\n    M7PFD // at 23: Master 7 Prefetch Disable\n    M6PFD // at 22: Master 6 Prefetch Disable\n    M5PFD // at 21: Master 5 Prefetch Disable\n    M4PFD // at 20: Master 4 Prefetch Disable\n    M3PFD // at 19: Master 3 Prefetch Disable\n    M2PFD // at 18: Master 2 Prefetch Disable\n    M1PFD // at 17: Master 1 Prefetch Disable\n    M0PFD // at 16: Master 0 Prefetch Disable\n    M7AP:2 // at 14: Master 7 Access Protection\n    M6AP:2 // at 12: Master 6 Access Protection\n    M5AP:2 // at 10: Master 5 Access Protection\n    M4AP:2 // at 8: Master 4 Access Protection\n    M3AP:2 // at 6: Master 3 Access Protection\n    M2AP:2 // at 4: Master 2 Access Protection\n    M1AP:2 // at 2: Master 1 Access Protection\n    M0AP:2 // at 0: Master 0 Access Protection\n  }\n\n//---  Register PFB0CR: Flash Bank 0 Control Register\n  PFB0CR @offset 0x4 $u32 {\n    B0RWSC:4 // at 28: Bank 0 Read Wait State Control\n    CLCK_WAY:4 // at 24: Cache Lock Way x\n    CINV_WAY:4 // at 20: Cache Invalidate Way x\n    S_B_INV // at 19: Invalidate Prefetch Speculation Buffer\n    B0MW:2 // at 17: Bank 0 Memory Width\n    9\n    CRC:3 // at 5: Cache Replacement Control\n    B0DCE // at 4: Bank 0 Data Cache Enable\n    B0ICE // at 3: Bank 0 Instruction Cache Enable\n    B0DPE // at 2: Bank 0 Data Prefetch Enable\n    B0IPE // at 1: Bank 0 Instruction Prefetch Enable\n    B0SEBE // at 0: Bank 0 Single Entry Buffer Enable\n  }\n\n//---  Register PFB1CR: Flash Bank 1 Control Register\n  PFB1CR @offset 0x8 $u32 {\n    B1RWSC:4 // at 28: Bank 1 Read Wait State Control\n    9\n    B1MW:2 // at 17: Bank 1 Memory Width\n    12\n    B1DCE // at 4: Bank 1 Data Cache Enable\n    B1ICE // at 3: Bank 1 Instruction Cache Enable\n    B1DPE // at 2: Bank 1 Data Prefetch Enable\n    B1IPE // at 1: Bank 1 Instruction Prefetch Enable\n    B1SEBE // at 0: Bank 1 Single Entry Buffer Enable\n  }\n\n//---  Registers TAGVDW0S(0,1,2,3,4,5,6,7): Cache Tag Storage\n  TAGVDW0S [8 @offset 0x100 @inc 0x4]\n  TAGVDW0S0 @offset 0x100\n  TAGVDW0S1 @offset 0x104\n  TAGVDW0S2 @offset 0x108\n  TAGVDW0S3 @offset 0x10c\n  TAGVDW0S4 @offset 0x110\n  TAGVDW0S5 @offset 0x114\n  TAGVDW0S6 @offset 0x118\n  TAGVDW0S7 @offset 0x11c $u32 {\n    13\n    tag:13 // at 6: 13-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers TAGVDW1S(0,1,2,3,4,5,6,7): Cache Tag Storage\n  TAGVDW1S [8 @offset 0x120 @inc 0x4]\n  TAGVDW1S0 @offset 0x120\n  TAGVDW1S1 @offset 0x124\n  TAGVDW1S2 @offset 0x128\n  TAGVDW1S3 @offset 0x12c\n  TAGVDW1S4 @offset 0x130\n  TAGVDW1S5 @offset 0x134\n  TAGVDW1S6 @offset 0x138\n  TAGVDW1S7 @offset 0x13c $u32 {\n    13\n    tag:13 // at 6: 13-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers TAGVDW2S(0,1,2,3,4,5,6,7): Cache Tag Storage\n  TAGVDW2S [8 @offset 0x140 @inc 0x4]\n  TAGVDW2S0 @offset 0x140\n  TAGVDW2S1 @offset 0x144\n  TAGVDW2S2 @offset 0x148\n  TAGVDW2S3 @offset 0x14c\n  TAGVDW2S4 @offset 0x150\n  TAGVDW2S5 @offset 0x154\n  TAGVDW2S6 @offset 0x158\n  TAGVDW2S7 @offset 0x15c $u32 {\n    13\n    tag:13 // at 6: 13-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers TAGVDW3S(0,1,2,3,4,5,6,7): Cache Tag Storage\n  TAGVDW3S [8 @offset 0x160 @inc 0x4]\n  TAGVDW3S0 @offset 0x160\n  TAGVDW3S1 @offset 0x164\n  TAGVDW3S2 @offset 0x168\n  TAGVDW3S3 @offset 0x16c\n  TAGVDW3S4 @offset 0x170\n  TAGVDW3S5 @offset 0x174\n  TAGVDW3S6 @offset 0x178\n  TAGVDW3S7 @offset 0x17c $u32 {\n    13\n    tag:13 // at 6: 13-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers DATAW0SU(0,1,2,3,4,5,6,7): Cache Data Storage (upper word)\n  DATAW0SU [8 @offset 0x200 @inc 0x8]\n  DATAW0S0U @offset 0x200\n  DATAW0S1U @offset 0x208\n  DATAW0S2U @offset 0x210\n  DATAW0S3U @offset 0x218\n  DATAW0S4U @offset 0x220\n  DATAW0S5U @offset 0x228\n  DATAW0S6U @offset 0x230\n  DATAW0S7U @offset 0x238 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW0SL(0,1,2,3,4,5,6,7): Cache Data Storage (lower word)\n  DATAW0SL [8 @offset 0x204 @inc 0x8]\n  DATAW0S0L @offset 0x204\n  DATAW0S1L @offset 0x20c\n  DATAW0S2L @offset 0x214\n  DATAW0S3L @offset 0x21c\n  DATAW0S4L @offset 0x224\n  DATAW0S5L @offset 0x22c\n  DATAW0S6L @offset 0x234\n  DATAW0S7L @offset 0x23c $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n//---  Registers DATAW1SU(0,1,2,3,4,5,6,7): Cache Data Storage (upper word)\n  DATAW1SU [8 @offset 0x240 @inc 0x8]\n  DATAW1S0U @offset 0x240\n  DATAW1S1U @offset 0x248\n  DATAW1S2U @offset 0x250\n  DATAW1S3U @offset 0x258\n  DATAW1S4U @offset 0x260\n  DATAW1S5U @offset 0x268\n  DATAW1S6U @offset 0x270\n  DATAW1S7U @offset 0x278 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW1SL(0,1,2,3,4,5,6,7): Cache Data Storage (lower word)\n  DATAW1SL [8 @offset 0x244 @inc 0x8]\n  DATAW1S0L @offset 0x244\n  DATAW1S1L @offset 0x24c\n  DATAW1S2L @offset 0x254\n  DATAW1S3L @offset 0x25c\n  DATAW1S4L @offset 0x264\n  DATAW1S5L @offset 0x26c\n  DATAW1S6L @offset 0x274\n  DATAW1S7L @offset 0x27c $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n//---  Registers DATAW2SU(0,1,2,3,4,5,6,7): Cache Data Storage (upper word)\n  DATAW2SU [8 @offset 0x280 @inc 0x8]\n  DATAW2S0U @offset 0x280\n  DATAW2S1U @offset 0x288\n  DATAW2S2U @offset 0x290\n  DATAW2S3U @offset 0x298\n  DATAW2S4U @offset 0x2a0\n  DATAW2S5U @offset 0x2a8\n  DATAW2S6U @offset 0x2b0\n  DATAW2S7U @offset 0x2b8 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW2SL(0,1,2,3,4,5,6,7): Cache Data Storage (lower word)\n  DATAW2SL [8 @offset 0x284 @inc 0x8]\n  DATAW2S0L @offset 0x284\n  DATAW2S1L @offset 0x28c\n  DATAW2S2L @offset 0x294\n  DATAW2S3L @offset 0x29c\n  DATAW2S4L @offset 0x2a4\n  DATAW2S5L @offset 0x2ac\n  DATAW2S6L @offset 0x2b4\n  DATAW2S7L @offset 0x2bc $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n//---  Registers DATAW3SU(0,1,2,3,4,5,6,7): Cache Data Storage (upper word)\n  DATAW3SU [8 @offset 0x2c0 @inc 0x8]\n  DATAW3S0U @offset 0x2c0\n  DATAW3S1U @offset 0x2c8\n  DATAW3S2U @offset 0x2d0\n  DATAW3S3U @offset 0x2d8\n  DATAW3S4U @offset 0x2e0\n  DATAW3S5U @offset 0x2e8\n  DATAW3S6U @offset 0x2f0\n  DATAW3S7U @offset 0x2f8 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW3SL(0,1,2,3,4,5,6,7): Cache Data Storage (lower word)\n  DATAW3SL [8 @offset 0x2c4 @inc 0x8]\n  DATAW3S0L @offset 0x2c4\n  DATAW3S1L @offset 0x2cc\n  DATAW3S2L @offset 0x2d4\n  DATAW3S3L @offset 0x2dc\n  DATAW3S4L @offset 0x2e4\n  DATAW3S5L @offset 0x2ec\n  DATAW3S6L @offset 0x2f4\n  DATAW3S7L @offset 0x2fc $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FTFL: Flash Memory Interface\n//------------------------------------------------------------------------------\n\nregisters FTFL @at 0x40020000 {\n//---  Register FSTAT: Flash Status Register\n  FSTAT @offset 0x0 $u8 {\n    CCIF // at 7: Command Complete Interrupt Flag\n    RDCOLERR // at 6: FTFL Read Collision Error Flag\n    ACCERR // at 5: Flash Access Error Flag\n    FPVIOL // at 4: Flash Protection Violation Flag\n    3\n    MGSTAT0 // at 0: Memory Controller Command Completion Status Flag\n  }\n\n//---  Register FCNFG: Flash Configuration Register\n  FCNFG @offset 0x1 $u8 {\n    CCIE // at 7: Command Complete Interrupt Enable\n    RDCOLLIE // at 6: Read Collision Error Interrupt Enable\n    ERSAREQ // at 5: Erase All Request\n    ERSSUSP // at 4: Erase Suspend\n    SWAP // at 3: Swap\n    PFLSH // at 2: FTFL configuration\n    RAMRDY // at 1: RAM Ready\n    EEERDY // at 0: no description available\n  }\n\n//---  Register FSEC: Flash Security Register\n  FSEC @offset 0x2 $u8 {\n    KEYEN:2 // at 6: Backdoor Key Security Enable\n    MEEN:2 // at 4: Mass Erase Enable Bits\n    FSLACC:2 // at 2: Freescale Failure Analysis Access Code\n    SEC:2 // at 0: Flash Security\n  }\n\n//---  Register FOPT: Flash Option Register\n  FOPT @offset 0x3 $u8 {\n    OPT:8 // at 0: Nonvolatile Option\n  }\n\n//---  Registers FCCOB(3,2,1,0,7,6,5,4,B,A,9,8): Flash Common Command Object Registers\n  FCCOB [12 @offset 0x4 @inc 0x1]\n  FCCOB3 @offset 0x4\n  FCCOB2 @offset 0x5\n  FCCOB1 @offset 0x6\n  FCCOB0 @offset 0x7\n  FCCOB7 @offset 0x8\n  FCCOB6 @offset 0x9\n  FCCOB5 @offset 0xa\n  FCCOB4 @offset 0xb\n  FCCOBB @offset 0xc\n  FCCOBA @offset 0xd\n  FCCOB9 @offset 0xe\n  FCCOB8 @offset 0xf $u8 {\n    CCOBn:8 // at 0: no description available\n  }\n\n//---  Registers FPROT(3,2,1,0): Program Flash Protection Registers\n  FPROT [4 @offset 0x10 @inc 0x1]\n  FPROT3 @offset 0x10\n  FPROT2 @offset 0x11\n  FPROT1 @offset 0x12\n  FPROT0 @offset 0x13 $u8 {\n    PROT:8 // at 0: Program Flash Region Protect\n  }\n\n//---  Register FEPROT: EEPROM Protection Register\n  FEPROT @offset 0x16 $u8 {\n    EPROT:8 // at 0: EEPROM Region Protect\n  }\n\n//---  Register FDPROT: Data Flash Protection Register\n  FDPROT @offset 0x17 $u8 {\n    DPROT:8 // at 0: Data Flash Region Protect\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FTFL_FlashConfig: Flash Memory Interface\n//------------------------------------------------------------------------------\n\nregisters FTFL_FlashConfig @at 0x400 {\n//---  Register BACKKEY3: Backdoor Comparison Key 3.\n  BACKKEY3 @offset 0x0 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY2: Backdoor Comparison Key 2.\n  BACKKEY2 @offset 0x1 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY1: Backdoor Comparison Key 1.\n  BACKKEY1 @offset 0x2 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY0: Backdoor Comparison Key 0.\n  BACKKEY0 @offset 0x3 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY7: Backdoor Comparison Key 7.\n  BACKKEY7 @offset 0x4 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY6: Backdoor Comparison Key 6.\n  BACKKEY6 @offset 0x5 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY5: Backdoor Comparison Key 5.\n  BACKKEY5 @offset 0x6 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY4: Backdoor Comparison Key 4.\n  BACKKEY4 @offset 0x7 $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register FPROT3: Non-volatile P-Flash Protection 1 - Low Register\n  FPROT3 @offset 0x8 $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FPROT2: Non-volatile P-Flash Protection 1 - High Register\n  FPROT2 @offset 0x9 $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FPROT1: Non-volatile P-Flash Protection 0 - Low Register\n  FPROT1 @offset 0xa $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FPROT0: Non-volatile P-Flash Protection 0 - High Register\n  FPROT0 @offset 0xb $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FSEC: Non-volatile Flash Security Register\n  FSEC @offset 0xc $u8 {\n    KEYEN:2 // at 6: Backdoor Key Security Enable\n    MEEN:2 // at 4: no description available\n    FSLACC:2 // at 2: Freescale Failure Analysis Access Code\n    SEC:2 // at 0: Flash Security\n  }\n\n//---  Register FOPT: Non-volatile Flash Option Register\n  FOPT @offset 0xd $u8 {\n    6\n    EZPORT_DIS // at 1: no description available\n    LPBOOT // at 0: no description available\n  }\n\n//---  Register FEPROT: Non-volatile EERAM Protection Register\n  FEPROT @offset 0xe $u8 {\n    EPROT:8 // at 0: no description available\n  }\n\n//---  Register FDPROT: Non-volatile D-Flash Protection Register\n  FDPROT @offset 0xf $u8 {\n    DPROT:8 // at 0: D-Flash Region Protect\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: FTM [3]\n//        FTM0 at 0x40038000\n//        FTM1 at 0x40039000\n//        FTM2 at 0x400b8000\n//------------------------------------------------------------------------------\n\nregisters FTM [3 @at 0x40038000 0x40039000 0x400b8000]\n          FTM0 @at 0x40038000\n          FTM1 @at 0x40039000\n          FTM2 @at 0x400b8000 {\n//---  Register SC: Status and Control\n  SC @offset 0x0 $u32 {\n    24\n    TOF // at 7: Timer Overflow Flag\n    TOIE // at 6: Timer Overflow Interrupt Enable\n    CPWMS // at 5: Center-aligned PWM Select\n    CLKS:2 // at 3: Clock Source Selection\n    PS:3 // at 0: Prescale Factor Selection\n  }\n\n//---  Register CNT: Counter\n  CNT @offset 0x4 $u32 {\n    16\n    COUNT:16 // at 0: Counter value\n  }\n\n//---  Register MOD: Modulo\n  MOD @offset 0x8 $u32 {\n    16\n    MOD:16 // at 0: no description available\n  }\n\n//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status and Control\n  CSC [8 @offset 0xc @inc 0x8]\n  C0SC @offset 0xc\n  C1SC @offset 0x14\n  C2SC @offset 0x1c\n  C3SC @offset 0x24\n  C4SC @offset 0x2c\n  C5SC @offset 0x34\n  C6SC @offset 0x3c\n  C7SC @offset 0x44 $u32 {\n    24\n    CHF // at 7: Channel Flag\n    CHIE // at 6: Channel Interrupt Enable\n    MSB // at 5: Channel Mode Select\n    MSA // at 4: Channel Mode Select\n    ELSB // at 3: Edge or Level Select\n    ELSA // at 2: Edge or Level Select\n    1\n    DMA // at 0: DMA Enable\n  }\n\n//---  Registers CV(0,1,2,3,4,5,6,7): Channel (n) Value\n  CV [8 @offset 0x10 @inc 0x8]\n  C0V @offset 0x10\n  C1V @offset 0x18\n  C2V @offset 0x20\n  C3V @offset 0x28\n  C4V @offset 0x30\n  C5V @offset 0x38\n  C6V @offset 0x40\n  C7V @offset 0x48 $u32 {\n    16\n    VAL:16 // at 0: Channel Value\n  }\n\n//---  Register CNTIN: Counter Initial Value\n  CNTIN @offset 0x4c $u32 {\n    16\n    INIT:16 // at 0: no description available\n  }\n\n//---  Register STATUS: Capture and Compare Status\n  STATUS @offset 0x50 $u32 {\n    24\n    CH7F // at 7: Channel 7 Flag\n    CH6F // at 6: Channel 6 Flag\n    CH5F // at 5: Channel 5 Flag\n    CH4F // at 4: Channel 4 Flag\n    CH3F // at 3: Channel 3 Flag\n    CH2F // at 2: Channel 2 Flag\n    CH1F // at 1: Channel 1 Flag\n    CH0F // at 0: Channel 0 Flag\n  }\n\n//---  Register MODE: Features Mode Selection\n  MODE @offset 0x54 $u32 {\n    24\n    FAULTIE // at 7: Fault Interrupt Enable\n    FAULTM:2 // at 5: Fault Control Mode\n    CAPTEST // at 4: Capture Test Mode Enable\n    PWMSYNC // at 3: PWM Synchronization Mode\n    WPDIS // at 2: Write Protection Disable\n    INIT // at 1: Initialize the Channels Output\n    FTMEN // at 0: FTM Enable\n  }\n\n//---  Register SYNC: Synchronization\n  SYNC @offset 0x58 $u32 {\n    24\n    SWSYNC // at 7: PWM Synchronization Software Trigger\n    TRIG2 // at 6: PWM Synchronization Hardware Trigger 2\n    TRIG1 // at 5: PWM Synchronization Hardware Trigger 1\n    TRIG0 // at 4: PWM Synchronization Hardware Trigger 0\n    SYNCHOM // at 3: Output Mask Synchronization\n    REINIT // at 2: FTM Counter Reinitialization by Synchronization (FTM Counter Synchronization)\n    CNTMAX // at 1: Maximum loading point enable\n    CNTMIN // at 0: Minimum loading point enable\n  }\n\n//---  Register OUTINIT: Initial State for Channels Output\n  OUTINIT @offset 0x5c $u32 {\n    24\n    CH7OI // at 7: Channel 7 Output Initialization Value\n    CH6OI // at 6: Channel 6 Output Initialization Value\n    CH5OI // at 5: Channel 5 Output Initialization Value\n    CH4OI // at 4: Channel 4 Output Initialization Value\n    CH3OI // at 3: Channel 3 Output Initialization Value\n    CH2OI // at 2: Channel 2 Output Initialization Value\n    CH1OI // at 1: Channel 1 Output Initialization Value\n    CH0OI // at 0: Channel 0 Output Initialization Value\n  }\n\n//---  Register OUTMASK: Output Mask\n  OUTMASK @offset 0x60 $u32 {\n    24\n    CH7OM // at 7: Channel 7 Output Mask\n    CH6OM // at 6: Channel 6 Output Mask\n    CH5OM // at 5: Channel 5 Output Mask\n    CH4OM // at 4: Channel 4 Output Mask\n    CH3OM // at 3: Channel 3 Output Mask\n    CH2OM // at 2: Channel 2 Output Mask\n    CH1OM // at 1: Channel 1 Output Mask\n    CH0OM // at 0: Channel 0 Output Mask\n  }\n\n//---  Register COMBINE: Function for Linked Channels\n  COMBINE @offset 0x64 $u32 {\n    1\n    FAULTEN3 // at 30: Fault Control Enable for n = 6\n    SYNCEN3 // at 29: Synchronization Enable for n = 6\n    DTEN3 // at 28: Deadtime Enable for n = 6\n    DECAP3 // at 27: Dual Edge Capture Mode Captures for n = 6\n    DECAPEN3 // at 26: Dual Edge Capture Mode Enable for n = 6\n    COMP3 // at 25: Complement of Channel (n) for n = 6\n    COMBINE3 // at 24: Combine Channels for n = 6\n    1\n    FAULTEN2 // at 22: Fault Control Enable for n = 4\n    SYNCEN2 // at 21: Synchronization Enable for n = 4\n    DTEN2 // at 20: Deadtime Enable for n = 4\n    DECAP2 // at 19: Dual Edge Capture Mode Captures for n = 4\n    DECAPEN2 // at 18: Dual Edge Capture Mode Enable for n = 4\n    COMP2 // at 17: Complement of Channel (n) for n = 4\n    COMBINE2 // at 16: Combine Channels for n = 4\n    1\n    FAULTEN1 // at 14: Fault Control Enable for n = 2\n    SYNCEN1 // at 13: Synchronization Enable for n = 2\n    DTEN1 // at 12: Deadtime Enable for n = 2\n    DECAP1 // at 11: Dual Edge Capture Mode Captures for n = 2\n    DECAPEN1 // at 10: Dual Edge Capture Mode Enable for n = 2\n    COMP1 // at 9: Complement of Channel (n) for n = 2\n    COMBINE1 // at 8: Combine Channels for n = 2\n    1\n    FAULTEN0 // at 6: Fault Control Enable for n = 0\n    SYNCEN0 // at 5: Synchronization Enable for n = 0\n    DTEN0 // at 4: Deadtime Enable for n = 0\n    DECAP0 // at 3: Dual Edge Capture Mode Captures for n = 0\n    DECAPEN0 // at 2: Dual Edge Capture Mode Enable for n = 0\n    COMP0 // at 1: Complement of Channel (n) for n = 0\n    COMBINE0 // at 0: Combine Channels for n = 0\n  }\n\n//---  Register DEADTIME: Deadtime Insertion Control\n  DEADTIME @offset 0x68 $u32 {\n    24\n    DTPS:2 // at 6: Deadtime Prescaler Value\n    DTVAL:6 // at 0: Deadtime Value\n  }\n\n//---  Register EXTTRIG: FTM External Trigger\n  EXTTRIG @offset 0x6c $u32 {\n    24\n    TRIGF // at 7: Channel Trigger Flag\n    INITTRIGEN // at 6: Initialization Trigger Enable\n    CH1TRIG // at 5: Channel 1 Trigger Enable\n    CH0TRIG // at 4: Channel 0 Trigger Enable\n    CH5TRIG // at 3: Channel 5 Trigger Enable\n    CH4TRIG // at 2: Channel 4 Trigger Enable\n    CH3TRIG // at 1: Channel 3 Trigger Enable\n    CH2TRIG // at 0: Channel 2 Trigger Enable\n  }\n\n//---  Register POL: Channels Polarity\n  POL @offset 0x70 $u32 {\n    24\n    POL7 // at 7: Channel 7 Polarity\n    POL6 // at 6: Channel 6 Polarity\n    POL5 // at 5: Channel 5 Polarity\n    POL4 // at 4: Channel 4 Polarity\n    POL3 // at 3: Channel 3 Polarity\n    POL2 // at 2: Channel 2 Polarity\n    POL1 // at 1: Channel 1 Polarity\n    POL0 // at 0: Channel 0 Polarity\n  }\n\n//---  Register FMS: Fault Mode Status\n  FMS @offset 0x74 $u32 {\n    24\n    FAULTF // at 7: Fault Detection Flag\n    WPEN // at 6: Write Protection Enable\n    FAULTIN // at 5: Fault Inputs\n    1\n    FAULTF3 // at 3: Fault Detection Flag 3\n    FAULTF2 // at 2: Fault Detection Flag 2\n    FAULTF1 // at 1: Fault Detection Flag 1\n    FAULTF0 // at 0: Fault Detection Flag 0\n  }\n\n//---  Register FILTER: Input Capture Filter Control\n  FILTER @offset 0x78 $u32 {\n    16\n    CH3FVAL:4 // at 12: Channel 3 Input Filter\n    CH2FVAL:4 // at 8: Channel 2 Input Filter\n    CH1FVAL:4 // at 4: Channel 1 Input Filter\n    CH0FVAL:4 // at 0: Channel 0 Input Filter\n  }\n\n//---  Register FLTCTRL: Fault Control\n  FLTCTRL @offset 0x7c $u32 {\n    20\n    FFVAL:4 // at 8: Fault Input Filter\n    FFLTR3EN // at 7: Fault Input 3 Filter Enable\n    FFLTR2EN // at 6: Fault Input 2 Filter Enable\n    FFLTR1EN // at 5: Fault Input 1 Filter Enable\n    FFLTR0EN // at 4: Fault Input 0 Filter Enable\n    FAULT3EN // at 3: Fault Input 3 Enable\n    FAULT2EN // at 2: Fault Input 2 Enable\n    FAULT1EN // at 1: Fault Input 1 Enable\n    FAULT0EN // at 0: Fault Input 0 Enable\n  }\n\n//---  Register QDCTRL: Quadrature Decoder Control and Status\n  QDCTRL @offset 0x80 $u32 {\n    24\n    PHAFLTREN // at 7: Phase A Input Filter Enable\n    PHBFLTREN // at 6: Phase B Input Filter Enable\n    PHAPOL // at 5: Phase A Input Polarity\n    PHBPOL // at 4: Phase B Input Polarity\n    QUADMODE // at 3: Quadrature Decoder Mode\n    QUADIR // at 2: FTM Counter Direction in Quadrature Decoder Mode\n    TOFDIR // at 1: Timer Overflow Direction in Quadrature Decoder Mode\n    QUADEN // at 0: Quadrature Decoder Mode Enable\n  }\n\n//---  Register CONF: Configuration\n  CONF @offset 0x84 $u32 {\n    21\n    GTBEOUT // at 10: Global time base output\n    GTBEEN // at 9: Global time base enable\n    1\n    BDMMODE:2 // at 6: BDM Mode\n    1\n    NUMTOF:5 // at 0: TOF Frequency\n  }\n\n//---  Register FLTPOL: FTM Fault Input Polarity\n  FLTPOL @offset 0x88 $u32 {\n    28\n    FLT3POL // at 3: Fault Input 3 Polarity\n    FLT2POL // at 2: Fault Input 2 Polarity\n    FLT1POL // at 1: Fault Input 1 Polarity\n    FLT0POL // at 0: Fault Input 0 Polarity\n  }\n\n//---  Register SYNCONF: Synchronization Configuration\n  SYNCONF @offset 0x8c $u32 {\n    11\n    HWSOC // at 20: no description available\n    HWINVC // at 19: no description available\n    HWOM // at 18: no description available\n    HWWRBUF // at 17: no description available\n    HWRSTCNT // at 16: no description available\n    3\n    SWSOC // at 12: no description available\n    SWINVC // at 11: no description available\n    SWOM // at 10: no description available\n    SWWRBUF // at 9: no description available\n    SWRSTCNT // at 8: no description available\n    SYNCMODE // at 7: Synchronization Mode\n    1\n    SWOC // at 5: SWOCTRL register synchronization\n    INVC // at 4: INVCTRL register synchronization\n    1\n    CNTINC // at 2: CNTIN register synchronization\n    1\n    HWTRIGMODE // at 0: Hardware Trigger Mode\n  }\n\n//---  Register INVCTRL: FTM Inverting Control\n  INVCTRL @offset 0x90 $u32 {\n    28\n    INV3EN // at 3: Pair Channels 3 Inverting Enable\n    INV2EN // at 2: Pair Channels 2 Inverting Enable\n    INV1EN // at 1: Pair Channels 1 Inverting Enable\n    INV0EN // at 0: Pair Channels 0 Inverting Enable\n  }\n\n//---  Register SWOCTRL: FTM Software Output Control\n  SWOCTRL @offset 0x94 $u32 {\n    16\n    CH7OCV // at 15: Channel 7 Software Output Control Value\n    CH6OCV // at 14: Channel 6 Software Output Control Value\n    CH5OCV // at 13: Channel 5 Software Output Control Value\n    CH4OCV // at 12: Channel 4 Software Output Control Value\n    CH3OCV // at 11: Channel 3 Software Output Control Value\n    CH2OCV // at 10: Channel 2 Software Output Control Value\n    CH1OCV // at 9: Channel 1 Software Output Control Value\n    CH0OCV // at 8: Channel 0 Software Output Control Value\n    CH7OC // at 7: Channel 7 Software Output Control Enable\n    CH6OC // at 6: Channel 6 Software Output Control Enable\n    CH5OC // at 5: Channel 5 Software Output Control Enable\n    CH4OC // at 4: Channel 4 Software Output Control Enable\n    CH3OC // at 3: Channel 3 Software Output Control Enable\n    CH2OC // at 2: Channel 2 Software Output Control Enable\n    CH1OC // at 1: Channel 1 Software Output Control Enable\n    CH0OC // at 0: Channel 0 Software Output Control Enable\n  }\n\n//---  Register PWMLOAD: FTM PWM Load\n  PWMLOAD @offset 0x98 $u32 {\n    22\n    LDOK // at 9: Load Enable\n    1\n    CH7SEL // at 7: Channel 7 Select\n    CH6SEL // at 6: Channel 6 Select\n    CH5SEL // at 5: Channel 5 Select\n    CH4SEL // at 4: Channel 4 Select\n    CH3SEL // at 3: Channel 3 Select\n    CH2SEL // at 2: Channel 2 Select\n    CH1SEL // at 1: Channel 1 Select\n    CH0SEL // at 0: Channel 0 Select\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: GPIO [5]\n//        GPIOA at 0x400ff000\n//        GPIOB at 0x400ff040\n//        GPIOC at 0x400ff080\n//        GPIOD at 0x400ff0c0\n//        GPIOE at 0x400ff100\n//------------------------------------------------------------------------------\n\nregisters GPIO [5 @at 0x400ff000 0x400ff040 0x400ff080 0x400ff0c0 0x400ff100]\n          GPIOA @at 0x400ff000\n          GPIOB @at 0x400ff040\n          GPIOC @at 0x400ff080\n          GPIOD @at 0x400ff0c0\n          GPIOE @at 0x400ff100 {\n//---  Register PDOR: Port Data Output Register\n  PDOR @offset 0x0 $u32 {\n    PDO:32 // at 0: Port Data Output\n  }\n\n//---  Register PSOR: Port Set Output Register\n  PSOR @offset 0x4 $u32 {\n    PTSO:32 // at 0: Port Set Output\n  }\n\n//---  Register PCOR: Port Clear Output Register\n  PCOR @offset 0x8 $u32 {\n    PTCO:32 // at 0: Port Clear Output\n  }\n\n//---  Register PTOR: Port Toggle Output Register\n  PTOR @offset 0xc $u32 {\n    PTTO:32 // at 0: Port Toggle Output\n  }\n\n//---  Register PDIR: Port Data Input Register\n  PDIR @offset 0x10 $u32 {\n    PDI:32 // at 0: Port Data Input\n  }\n\n//---  Register PDDR: Port Data Direction Register\n  PDDR @offset 0x14 $u32 {\n    PDD:32 // at 0: Port data direction\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: I2C [2]\n//        I2C0 at 0x40066000\n//        I2C1 at 0x40067000\n//------------------------------------------------------------------------------\n\nregisters I2C [2 @at 0x40066000 0x40067000]\n          I2C0 @at 0x40066000\n          I2C1 @at 0x40067000 {\n//---  Register A1: I2C Address Register 1\n  A1 @offset 0x0 $u8 {\n    AD:7 // at 1: Address\n    1\n  }\n\n//---  Register F: I2C Frequency Divider register\n  F @offset 0x1 $u8 {\n    MULT:2 // at 6: no description available\n    ICR:6 // at 0: Clock rate\n  }\n\n//---  Register C1: I2C Control Register 1\n  C1 @offset 0x2 $u8 {\n    IICEN // at 7: I2C enable\n    IICIE // at 6: I2C interrupt enable\n    MST // at 5: Master mode select\n    TX // at 4: Transmit mode select\n    TXAK // at 3: Transmit acknowledge enable\n    RSTA // at 2: Repeat START\n    WUEN // at 1: Wakeup enable\n    DMAEN // at 0: DMA enable\n  }\n\n//---  Register S: I2C Status Register\n  S @offset 0x3 $u8 {\n    TCF // at 7: Transfer complete flag\n    IAAS // at 6: Addressed as a slave\n    BUSY // at 5: Bus busy\n    ARBL // at 4: Arbitration lost\n    RAM // at 3: Range address match\n    SRW // at 2: Slave read/write\n    IICIF // at 1: Interrupt flag\n    RXAK // at 0: Receive acknowledge\n  }\n\n//---  Register D: I2C Data I/O register\n  D @offset 0x4 $u8 {\n    DATA:8 // at 0: Data\n  }\n\n//---  Register C2: I2C Control Register 2\n  C2 @offset 0x5 $u8 {\n    GCAEN // at 7: General call address enable\n    ADEXT // at 6: Address extension\n    HDRS // at 5: High drive select\n    SBRC // at 4: Slave baud rate control\n    RMEN // at 3: Range address matching enable\n    AD:3 // at 0: Slave address\n  }\n\n//---  Register FLT: I2C Programmable Input Glitch Filter register\n  FLT @offset 0x6 $u8 {\n    3\n    FLT:5 // at 0: I2C programmable filter factor\n  }\n\n//---  Register RA: I2C Range Address register\n  RA @offset 0x7 $u8 {\n    RAD:7 // at 1: Range slave address\n    1\n  }\n\n//---  Register SMB: I2C SMBus Control and Status register\n  SMB @offset 0x8 $u8 {\n    FACK // at 7: Fast NACK/ACK enable\n    ALERTEN // at 6: SMBus alert response address enable\n    SIICAEN // at 5: Second I2C address enable\n    TCKSEL // at 4: Timeout counter clock select\n    SLTF // at 3: SCL low timeout flag\n    SHTF1 // at 2: SCL high timeout flag 1\n    SHTF2 // at 1: SCL high timeout flag 2\n    SHTF2IE // at 0: SHTF2 interrupt enable\n  }\n\n//---  Register A2: I2C Address Register 2\n  A2 @offset 0x9 $u8 {\n    SAD:7 // at 1: SMBus address\n    1\n  }\n\n//---  Register SLTH: I2C SCL Low Timeout Register High\n  SLTH @offset 0xa $u8 {\n    SSLT:8 // at 0: no description available\n  }\n\n//---  Register SLTL: I2C SCL Low Timeout Register Low\n  SLTL @offset 0xb $u8 {\n    SSLT:8 // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral I2S0: Inter-IC Sound / Synchronous Audio Interface\n//------------------------------------------------------------------------------\n\nregisters I2S0 @at 0x4002f000 {\n//---  Register TCSR: SAI Transmit Control Register\n  TCSR @offset 0x0 $u32 {\n    TE // at 31: Transmitter enable\n    STOPE // at 30: Stop enable\n    DBGE // at 29: Debug enable\n    BCE // at 28: Bit Clock Enable\n    2\n    FR // at 25: FIFO reset\n    SR // at 24: Software reset\n    3\n    WSF // at 20: Word start flag\n    SEF // at 19: Sync error flag\n    FEF // at 18: FIFO error flag\n    FWF // at 17: FIFO warning flag\n    FRF // at 16: FIFO request flag\n    3\n    WSIE // at 12: Word start interrupt enable\n    SEIE // at 11: Sync error interrupt enable\n    FEIE // at 10: FIFO error interrupt enable\n    FWIE // at 9: FIFO warning interrupt enable\n    FRIE // at 8: FIFO request interrupt enable\n    6\n    FWDE // at 1: FIFO warning DMA enable\n    FRDE // at 0: FIFO request DMA enable\n  }\n\n//---  Register TCR1: SAI Transmit Configuration 1 Register\n  TCR1 @offset 0x4 $u32 {\n    29\n    TFW:3 // at 0: Transmit FIFO watermark\n  }\n\n//---  Register TCR2: SAI Transmit Configuration 2 Register\n  TCR2 @offset 0x8 $u32 {\n    SYNC:2 // at 30: Synchronous Mode\n    BCS // at 29: Bit Clock Swap\n    BCI // at 28: Bit Clock Input\n    MSEL:2 // at 26: MCLK Select\n    BCP // at 25: Bit clock polarity\n    BCD // at 24: Bit clock direction\n    16\n    DIV:8 // at 0: Bit clock divide\n  }\n\n//---  Register TCR3: SAI Transmit Configuration 3 Register\n  TCR3 @offset 0xc $u32 {\n    14\n    TCE:2 // at 16: Transmit channel enable\n    11\n    WDFL:5 // at 0: Word flag configuration\n  }\n\n//---  Register TCR4: SAI Transmit Configuration 4 Register\n  TCR4 @offset 0x10 $u32 {\n    11\n    FRSZ:5 // at 16: Frame size\n    3\n    SYWD:5 // at 8: Sync width\n    3\n    MF // at 4: MSB first\n    FSE // at 3: Frame sync early\n    1\n    FSP // at 1: Frame sync polarity\n    FSD // at 0: Frame sync direction\n  }\n\n//---  Register TCR5: SAI Transmit Configuration 5 Register\n  TCR5 @offset 0x14 $u32 {\n    3\n    WNW:5 // at 24: Word N width\n    3\n    W0W:5 // at 16: Word 0 width\n    3\n    FBT:5 // at 8: First bit shifted\n    8\n  }\n\n//---  Registers TDR(0,1): SAI Transmit Data Register\n  TDR [2 @offset 0x20 @inc 0x4]\n  TDR0 @offset 0x20\n  TDR1 @offset 0x24 $u32 {\n    TDR:32 // at 0: Transmit data register\n  }\n\n//---  Registers TFR(0,1): SAI Transmit FIFO Register\n  TFR [2 @offset 0x40 @inc 0x4]\n  TFR0 @offset 0x40\n  TFR1 @offset 0x44 $u32 {\n    12\n    WFP:4 // at 16: Write FIFO pointer\n    12\n    RFP:4 // at 0: Read FIFO pointer\n  }\n\n//---  Register TMR: SAI Transmit Mask Register\n  TMR @offset 0x60 $u32 {\n    TWM:32 // at 0: Transmit word mask\n  }\n\n//---  Register RCSR: SAI Receive Control Register\n  RCSR @offset 0x80 $u32 {\n    RE // at 31: Receiver enable\n    STOPE // at 30: Stop enable\n    DBGE // at 29: Debug enable\n    BCE // at 28: Bit Clock enable\n    2\n    FR // at 25: FIFO reset\n    SR // at 24: Software reset\n    3\n    WSF // at 20: Word start flag\n    SEF // at 19: Sync error flag\n    FEF // at 18: FIFO error flag\n    FWF // at 17: FIFO warning flag\n    FRF // at 16: FIFO request flag\n    3\n    WSIE // at 12: Word start interrupt enable\n    SEIE // at 11: Sync error interrupt enable\n    FEIE // at 10: FIFO error interrupt enable\n    FWIE // at 9: FIFO warning interrupt enable\n    FRIE // at 8: FIFO request interrupt enable\n    6\n    FWDE // at 1: FIFO warning DMA enable\n    FRDE // at 0: FIFO request DMA enable\n  }\n\n//---  Register RCR1: SAI Receive Configuration 1 Register\n  RCR1 @offset 0x84 $u32 {\n    29\n    RFW:3 // at 0: Receive FIFO watermark\n  }\n\n//---  Register RCR2: SAI Receive Configuration 2 Register\n  RCR2 @offset 0x88 $u32 {\n    SYNC:2 // at 30: Synchronous Mode\n    BCS // at 29: Bit Clock Swap\n    BCI // at 28: Bit Clock Input\n    MSEL:2 // at 26: MCLK Select\n    BCP // at 25: Bit clock polarity\n    BCD // at 24: Bit clock direction\n    16\n    DIV:8 // at 0: Bit clock divide\n  }\n\n//---  Register RCR3: SAI Receive Configuration 3 Register\n  RCR3 @offset 0x8c $u32 {\n    14\n    RCE:2 // at 16: Receive channel enable\n    11\n    WDFL:5 // at 0: Word flag configuration\n  }\n\n//---  Register RCR4: SAI Receive Configuration 4 Register\n  RCR4 @offset 0x90 $u32 {\n    11\n    FRSZ:5 // at 16: Frame size\n    3\n    SYWD:5 // at 8: Sync width\n    3\n    MF // at 4: MSB first\n    FSE // at 3: Frame sync early\n    1\n    FSP // at 1: Frame sync polarity\n    FSD // at 0: Frame sync direction\n  }\n\n//---  Register RCR5: SAI Receive Configuration 5 Register\n  RCR5 @offset 0x94 $u32 {\n    3\n    WNW:5 // at 24: Word N width\n    3\n    W0W:5 // at 16: Word 0 width\n    3\n    FBT:5 // at 8: First bit shifted\n    8\n  }\n\n//---  Registers RDR(0,1): SAI Receive Data Register\n  RDR [2 @offset 0xa0 @inc 0x4]\n  RDR0 @offset 0xa0\n  RDR1 @offset 0xa4 $u32 {\n    RDR:32 // at 0: Receive data register\n  }\n\n//---  Registers RFR(0,1): SAI Receive FIFO Register\n  RFR [2 @offset 0xc0 @inc 0x4]\n  RFR0 @offset 0xc0\n  RFR1 @offset 0xc4 $u32 {\n    12\n    WFP:4 // at 16: Write FIFO pointer\n    12\n    RFP:4 // at 0: Read FIFO pointer\n  }\n\n//---  Register RMR: SAI Receive Mask Register\n  RMR @offset 0xe0 $u32 {\n    RWM:32 // at 0: Receive word mask\n  }\n\n//---  Register MCR: SAI MCLK Control Register\n  MCR @offset 0x100 $u32 {\n    DUF // at 31: Divider Update Flag\n    MOE // at 30: MCLK Output Enable\n    4\n    MICS:2 // at 24: MCLK Input Clock Select\n    24\n  }\n\n//---  Register MDR: MCLK Divide Register\n  MDR @offset 0x104 $u32 {\n    12\n    FRACT:8 // at 12: MCLK Fraction\n    DIVIDE:12 // at 0: MCLK Divide\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral LLWU: Low leakage wakeup unit\n//------------------------------------------------------------------------------\n\nregisters LLWU @at 0x4007c000 {\n//---  Register PE1: LLWU Pin Enable 1 Register\n  PE1 @offset 0x0 $u8 {\n    WUPE3:2 // at 6: Wakeup Pin Enable for LLWU_P3\n    WUPE2:2 // at 4: Wakeup Pin Enable for LLWU_P2\n    WUPE1:2 // at 2: Wakeup Pin Enable for LLWU_P1\n    WUPE0:2 // at 0: Wakeup Pin Enable for LLWU_P0\n  }\n\n//---  Register PE2: LLWU Pin Enable 2 Register\n  PE2 @offset 0x1 $u8 {\n    WUPE7:2 // at 6: Wakeup Pin Enable for LLWU_P7\n    WUPE6:2 // at 4: Wakeup Pin Enable for LLWU_P6\n    WUPE5:2 // at 2: Wakeup Pin Enable for LLWU_P5\n    WUPE4:2 // at 0: Wakeup Pin Enable for LLWU_P4\n  }\n\n//---  Register PE3: LLWU Pin Enable 3 Register\n  PE3 @offset 0x2 $u8 {\n    WUPE11:2 // at 6: Wakeup Pin Enable for LLWU_P11\n    WUPE10:2 // at 4: Wakeup Pin Enable for LLWU_P10\n    WUPE9:2 // at 2: Wakeup Pin Enable for LLWU_P9\n    WUPE8:2 // at 0: Wakeup Pin Enable for LLWU_P8\n  }\n\n//---  Register PE4: LLWU Pin Enable 4 Register\n  PE4 @offset 0x3 $u8 {\n    WUPE15:2 // at 6: Wakeup Pin Enable for LLWU_P15\n    WUPE14:2 // at 4: Wakeup Pin Enable for LLWU_P14\n    WUPE13:2 // at 2: Wakeup Pin Enable for LLWU_P13\n    WUPE12:2 // at 0: Wakeup Pin Enable for LLWU_P12\n  }\n\n//---  Register ME: LLWU Module Enable Register\n  ME @offset 0x4 $u8 {\n    WUME7 // at 7: Wakeup Module Enable for Module 7\n    WUME6 // at 6: Wakeup Module Enable for Module 6\n    WUME5 // at 5: Wakeup Module Enable for Module 5\n    WUME4 // at 4: Wakeup Module Enable for Module 4\n    WUME3 // at 3: Wakeup Module Enable for Module 3\n    WUME2 // at 2: Wakeup Module Enable for Module 2\n    WUME1 // at 1: Wakeup Module Enable for Module 1\n    WUME0 // at 0: Wakeup Module Enable for Module 0\n  }\n\n//---  Register F1: LLWU Flag 1 Register\n  F1 @offset 0x5 $u8 {\n    WUF7 // at 7: Wakeup Flag for LLWU_P7\n    WUF6 // at 6: Wakeup Flag for LLWU_P6\n    WUF5 // at 5: Wakeup Flag for LLWU_P5\n    WUF4 // at 4: Wakeup Flag for LLWU_P4\n    WUF3 // at 3: Wakeup Flag for LLWU_P3\n    WUF2 // at 2: Wakeup Flag for LLWU_P2\n    WUF1 // at 1: Wakeup Flag for LLWU_P1\n    WUF0 // at 0: Wakeup Flag for LLWU_P0\n  }\n\n//---  Register F2: LLWU Flag 2 Register\n  F2 @offset 0x6 $u8 {\n    WUF15 // at 7: Wakeup Flag for LLWU_P15\n    WUF14 // at 6: Wakeup Flag for LLWU_P14\n    WUF13 // at 5: Wakeup Flag for LLWU_P13\n    WUF12 // at 4: Wakeup Flag for LLWU_P12\n    WUF11 // at 3: Wakeup Flag for LLWU_P11\n    WUF10 // at 2: Wakeup Flag for LLWU_P10\n    WUF9 // at 1: Wakeup Flag for LLWU_P9\n    WUF8 // at 0: Wakeup Flag for LLWU_P8\n  }\n\n//---  Register F3: LLWU Flag 3 Register\n  F3 @offset 0x7 $u8 {\n    MWUF7 // at 7: Wakeup flag for module 7\n    MWUF6 // at 6: Wakeup flag for module 6\n    MWUF5 // at 5: Wakeup flag for module 5\n    MWUF4 // at 4: Wakeup flag for module 4\n    MWUF3 // at 3: Wakeup flag for module 3\n    MWUF2 // at 2: Wakeup flag for module 2\n    MWUF1 // at 1: Wakeup flag for module 1\n    MWUF0 // at 0: Wakeup flag for module 0\n  }\n\n//---  Register FILT1: LLWU Pin Filter 1 Register\n  FILT1 @offset 0x8 $u8 {\n    FILTF // at 7: Filter Detect Flag\n    FILTE:2 // at 5: Digital Filter on External Pin\n    1\n    FILTSEL:4 // at 0: Filter pin select\n  }\n\n//---  Register FILT2: LLWU Pin Filter 2 Register\n  FILT2 @offset 0x9 $u8 {\n    FILTF // at 7: Filter Detect Flag\n    FILTE:2 // at 5: Digital Filter on External Pin\n    1\n    FILTSEL:4 // at 0: Filter pin select\n  }\n\n//---  Register RST: LLWU Reset Enable Register\n  RST @offset 0xa $u8 {\n    6\n    LLRSTE // at 1: Low Leakage mode RESET enable\n    RSTFILT // at 0: Digital Filter on RESET Pin\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral LPTMR0: Low Power Timer\n//------------------------------------------------------------------------------\n\nregisters LPTMR0 @at 0x40040000 {\n//---  Register CSR: Low Power Timer Control Status Register\n  CSR @offset 0x0 $u32 {\n    24\n    TCF // at 7: Timer Compare Flag\n    TIE // at 6: Timer Interrupt Enable\n    TPS:2 // at 4: Timer Pin Select\n    TPP // at 3: Timer Pin Polarity\n    TFC // at 2: Timer Free Running Counter\n    TMS // at 1: Timer Mode Select\n    TEN // at 0: Timer Enable\n  }\n\n//---  Register PSR: Low Power Timer Prescale Register\n  PSR @offset 0x4 $u32 {\n    25\n    PRESCALE:4 // at 3: Prescale Value\n    PBYP // at 2: Prescaler Bypass\n    PCS:2 // at 0: Prescaler Clock Select\n  }\n\n//---  Register CMR: Low Power Timer Compare Register\n  CMR @offset 0x8 $u32 {\n    16\n    COMPARE:16 // at 0: Compare Value\n  }\n\n//---  Register CNR: Low Power Timer Counter Register\n  CNR @offset 0xc $u32 {\n    16\n    COUNTER:16 // at 0: Counter Value\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral MCG: Multipurpose Clock Generator module\n//------------------------------------------------------------------------------\n\nregisters MCG @at 0x40064000 {\n//---  Register C1: MCG Control 1 Register\n  C1 @offset 0x0 $u8 {\n    CLKS:2 // at 6: Clock Source Select\n    FRDIV:3 // at 3: FLL External Reference Divider\n    IREFS // at 2: Internal Reference Select\n    IRCLKEN // at 1: Internal Reference Clock Enable\n    IREFSTEN // at 0: Internal Reference Stop Enable\n  }\n\n//---  Register C2: MCG Control 2 Register\n  C2 @offset 0x1 $u8 {\n    LOCRE0 // at 7: Loss of Clock Reset Enable\n    1\n    RANGE0:2 // at 4: Frequency Range Select\n    HGO0 // at 3: High Gain Oscillator Select\n    EREFS0 // at 2: External Reference Select\n    LP // at 1: Low Power Select\n    IRCS // at 0: Internal Reference Clock Select\n  }\n\n//---  Register C3: MCG Control 3 Register\n  C3 @offset 0x2 $u8 {\n    SCTRIM:8 // at 0: Slow Internal Reference Clock Trim Setting\n  }\n\n//---  Register C4: MCG Control 4 Register\n  C4 @offset 0x3 $u8 {\n    DMX32 // at 7: DCO Maximum Frequency with 32.768 kHz Reference\n    DRST_DRS:2 // at 5: DCO Range Select\n    FCTRIM:4 // at 1: Fast Internal Reference Clock Trim Setting\n    SCFTRIM // at 0: Slow Internal Reference Clock Fine Trim\n  }\n\n//---  Register C5: MCG Control 5 Register\n  C5 @offset 0x4 $u8 {\n    1\n    PLLCLKEN0 // at 6: PLL Clock Enable\n    PLLSTEN0 // at 5: PLL Stop Enable\n    PRDIV0:5 // at 0: PLL External Reference Divider\n  }\n\n//---  Register C6: MCG Control 6 Register\n  C6 @offset 0x5 $u8 {\n    LOLIE0 // at 7: Loss of Lock Interrrupt Enable\n    PLLS // at 6: PLL Select\n    CME0 // at 5: Clock Monitor Enable\n    VDIV0:5 // at 0: VCO 0 Divider\n  }\n\n//---  Register S: MCG Status Register\n  S @offset 0x6 $u8 {\n    LOLS0 // at 7: Loss of Lock Status\n    LOCK0 // at 6: Lock Status\n    PLLST // at 5: PLL Select Status\n    IREFST // at 4: Internal Reference Status\n    CLKST:2 // at 2: Clock Mode Status\n    OSCINIT0 // at 1: OSC Initialization\n    IRCST // at 0: Internal Reference Clock Status\n  }\n\n//---  Register SC: MCG Status and Control Register\n  SC @offset 0x8 $u8 {\n    ATME // at 7: Automatic Trim Machine Enable\n    ATMS // at 6: Automatic Trim Machine Select\n    ATMF // at 5: Automatic Trim machine Fail Flag\n    FLTPRSRV // at 4: FLL Filter Preserve Enable\n    FCRDIV:3 // at 1: Fast Clock Internal Reference Divider\n    LOCS0 // at 0: OSC0 Loss of Clock Status\n  }\n\n//---  Register ATCVH: MCG Auto Trim Compare Value High Register\n  ATCVH @offset 0xa $u8 {\n    ATCVH:8 // at 0: ATM Compare Value High\n  }\n\n//---  Register ATCVL: MCG Auto Trim Compare Value Low Register\n  ATCVL @offset 0xb $u8 {\n    ATCVL:8 // at 0: ATM Compare Value Low\n  }\n\n//---  Register C7: MCG Control 7 Register\n  C7 @offset 0xc $u8 {\n    7\n    OSCSEL // at 0: MCG OSC Clock Select\n  }\n\n//---  Register C8: MCG Control 8 Register\n  C8 @offset 0xd $u8 {\n    LOCRE1 // at 7: Loss of Clock Reset Enable\n    LOLRE // at 6: no description available\n    CME1 // at 5: Clock Monitor Enable1\n    4\n    LOCS1 // at 0: RTC Loss of Clock Status\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral MCM: Core Platform Miscellaneous Control Module\n//------------------------------------------------------------------------------\n\nregisters MCM @at 0xe0080000 {\n//---  Register PLASC: Crossbar switch (AXBS) slave configuration\n  PLASC @offset 0x8 $u16 {\n    8\n    ASC:8 // at 0: Each bit in the ASC field indicates if there is a corresponding connection to the crossbar switch's slave input port.\n  }\n\n//---  Register PLAMC: Crossbar switch (AXBS) master configuration\n  PLAMC @offset 0xa $u16 {\n    8\n    AMC:8 // at 0: Each bit in the AMC field indicates if there is a corresponding connection to the AXBS master input port.\n  }\n\n//---  Register CR: Control register\n  CR @offset 0xc $u32 {\n    1\n    SRAMLWP // at 30: SRAM_L write protect\n    SRAMLAP:2 // at 28: SRAM_L arbitration priority\n    1\n    SRAMUWP // at 26: SRAM_U write protect\n    SRAMUAP:2 // at 24: SRAM_U arbitration priority\n    24\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral OSC: Oscillator\n//------------------------------------------------------------------------------\n\nregisters OSC @at 0x40065000 {\n//---  Register CR: OSC Control Register\n  CR @offset 0x0 $u8 {\n    ERCLKEN // at 7: External Reference Enable\n    1\n    EREFSTEN // at 5: External Reference Stop Enable\n    1\n    SC2P // at 3: Oscillator 2 pF Capacitor Load Configure\n    SC4P // at 2: Oscillator 4 pF Capacitor Load Configure\n    SC8P // at 1: Oscillator 8 pF Capacitor Load Configure\n    SC16P // at 0: Oscillator 16 pF Capacitor Load Configure\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral PDB0: Programmable Delay Block\n//------------------------------------------------------------------------------\n\nregisters PDB0 @at 0x40036000 {\n//---  Register SC: Status and Control Register\n  SC @offset 0x0 $u32 {\n    12\n    LDMOD:2 // at 18: Load Mode Select\n    PDBEIE // at 17: PDB Sequence Error Interrupt Enable\n    SWTRIG // at 16: Software Trigger\n    DMAEN // at 15: DMA Enable\n    PRESCALER:3 // at 12: Prescaler Divider Select\n    TRGSEL:4 // at 8: Trigger Input Source Select\n    PDBEN // at 7: PDB Enable\n    PDBIF // at 6: PDB Interrupt Flag\n    PDBIE // at 5: PDB Interrupt Enable.\n    1\n    MULT:2 // at 2: Multiplication Factor Select for Prescaler\n    CONT // at 1: Continuous Mode Enable\n    LDOK // at 0: Load OK\n  }\n\n//---  Register MOD: Modulus Register\n  MOD @offset 0x4 $u32 {\n    16\n    MOD:16 // at 0: PDB Modulus.\n  }\n\n//---  Register CNT: Counter Register\n  CNT @offset 0x8 $u32 {\n    16\n    CNT:16 // at 0: PDB Counter\n  }\n\n//---  Register IDLY: Interrupt Delay Register\n  IDLY @offset 0xc $u32 {\n    16\n    IDLY:16 // at 0: PDB Interrupt Delay\n  }\n\n//---  Registers CHC1(0,1): Channel n Control Register 1\n  CHC1 [2 @offset 0x10 @inc 0x28]\n  CH0C1 @offset 0x10\n  CH1C1 @offset 0x38 $u32 {\n    8\n    BB:8 // at 16: PDB Channel Pre-Trigger Back-to-Back Operation Enable\n    TOS:8 // at 8: PDB Channel Pre-Trigger Output Select\n    EN:8 // at 0: PDB Channel Pre-Trigger Enable\n  }\n\n//---  Registers CHS(0,1): Channel n Status Register\n  CHS [2 @offset 0x14 @inc 0x28]\n  CH0S @offset 0x14\n  CH1S @offset 0x3c $u32 {\n    8\n    CF:8 // at 16: PDB Channel Flags\n    8\n    ERR:8 // at 0: PDB Channel Sequence Error Flags\n  }\n\n//---  Registers CHDLY0(0,1): Channel n Delay 0 Register\n  CHDLY0 [2 @offset 0x18 @inc 0x28]\n  CH0DLY0 @offset 0x18\n  CH1DLY0 @offset 0x40 $u32 {\n    16\n    DLY:16 // at 0: PDB Channel Delay\n  }\n\n//---  Registers CHDLY1(0,1): Channel n Delay 1 Register\n  CHDLY1 [2 @offset 0x1c @inc 0x28]\n  CH0DLY1 @offset 0x1c\n  CH1DLY1 @offset 0x44 $u32 {\n    16\n    DLY:16 // at 0: PDB Channel Delay\n  }\n\n//---  Register DACINTC: DAC Interval Trigger n Control Register\n  DACINTC @offset 0x150 $u32 {\n    30\n    EXT // at 1: DAC External Trigger Input Enable\n    TOE // at 0: DAC Interval Trigger Enable\n  }\n\n//---  Register DACINT: DAC Interval n Register\n  DACINT @offset 0x154 $u32 {\n    16\n    INT:16 // at 0: DAC Interval\n  }\n\n//---  Register POEN: Pulse-Out n Enable Register\n  POEN @offset 0x190 $u32 {\n    24\n    POEN:8 // at 0: PDB Pulse-Out Enable\n  }\n\n//---  Registers PODLY(0,1,2): Pulse-Out n Delay Register\n  PODLY [3 @offset 0x194 @inc 0x4]\n  PO0DLY @offset 0x194\n  PO1DLY @offset 0x198\n  PO2DLY @offset 0x19c $u32 {\n    DLY1:16 // at 16: PDB Pulse-Out Delay 1\n    DLY2:16 // at 0: PDB Pulse-Out Delay 2\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral PIT: Periodic Interrupt Timer\n//------------------------------------------------------------------------------\n\nregisters PIT @at 0x40037000 {\n//---  Register MCR: PIT Module Control Register\n  MCR @offset 0x0 $u32 {\n    30\n    MDIS // at 1: Module Disable\n    FRZ // at 0: Freeze\n  }\n\n//---  Registers LDVAL(0,1,2,3): Timer Load Value Register\n  LDVAL [4 @offset 0x100 @inc 0x10]\n  LDVAL0 @offset 0x100\n  LDVAL1 @offset 0x110\n  LDVAL2 @offset 0x120\n  LDVAL3 @offset 0x130 $u32 {\n    TSV:32 // at 0: Timer Start Value Bits\n  }\n\n//---  Registers CVAL(0,1,2,3): Current Timer Value Register\n  CVAL [4 @offset 0x104 @inc 0x10]\n  CVAL0 @offset 0x104\n  CVAL1 @offset 0x114\n  CVAL2 @offset 0x124\n  CVAL3 @offset 0x134 $u32 {\n    TVL:32 // at 0: Current Timer Value\n  }\n\n//---  Registers TCTRL(0,1,2,3): Timer Control Register\n  TCTRL [4 @offset 0x108 @inc 0x10]\n  TCTRL0 @offset 0x108\n  TCTRL1 @offset 0x118\n  TCTRL2 @offset 0x128\n  TCTRL3 @offset 0x138 $u32 {\n    30\n    TIE // at 1: Timer Interrupt Enable Bit.\n    TEN // at 0: Timer Enable Bit.\n  }\n\n//---  Registers TFLG(0,1,2,3): Timer Flag Register\n  TFLG [4 @offset 0x10c @inc 0x10]\n  TFLG0 @offset 0x10c\n  TFLG1 @offset 0x11c\n  TFLG2 @offset 0x12c\n  TFLG3 @offset 0x13c $u32 {\n    31\n    TIF // at 0: Timer Interrupt Flag.\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral PMC: Power Management Controller\n//------------------------------------------------------------------------------\n\nregisters PMC @at 0x4007d000 {\n//---  Register LVDSC1: Low Voltage Detect Status and Control 1 Register\n  LVDSC1 @offset 0x0 $u8 {\n    LVDF // at 7: Low-Voltage Detect Flag\n    LVDACK // at 6: Low-Voltage Detect Acknowledge\n    LVDIE // at 5: Low-Voltage Detect Interrupt Enable\n    LVDRE // at 4: Low-Voltage Detect Reset Enable\n    2\n    LVDV:2 // at 0: Low-Voltage Detect Voltage Select\n  }\n\n//---  Register LVDSC2: Low Voltage Detect Status and Control 2 Register\n  LVDSC2 @offset 0x1 $u8 {\n    LVWF // at 7: Low-Voltage Warning Flag\n    LVWACK // at 6: Low-Voltage Warning Acknowledge\n    LVWIE // at 5: Low-Voltage Warning Interrupt Enable\n    3\n    LVWV:2 // at 0: Low-Voltage Warning Voltage Select\n  }\n\n//---  Register REGSC: Regulator Status and Control Register\n  REGSC @offset 0x2 $u8 {\n    3\n    BGEN // at 4: Bandgap enable in VLPx operation\n    ACKISO // at 3: Acknowledge Isolation\n    REGONS // at 2: Regulator in Run Regulation Status\n    1\n    BGBE // at 0: Bandgap Buffer Enable\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: PORT [5]\n//        PORTA at 0x40049000\n//        PORTB at 0x4004a000\n//        PORTC at 0x4004b000\n//        PORTD at 0x4004c000\n//        PORTE at 0x4004d000\n//------------------------------------------------------------------------------\n\nregisters PORT [5 @at 0x40049000 0x4004a000 0x4004b000 0x4004c000 0x4004d000]\n          PORTA @at 0x40049000\n          PORTB @at 0x4004a000\n          PORTC @at 0x4004b000\n          PORTD @at 0x4004c000\n          PORTE @at 0x4004d000 {\n//---  Registers PCR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Pin Control Register n\n  PCR [32 @offset 0x0 @inc 0x4]\n  PCR0 @offset 0x0\n  PCR1 @offset 0x4\n  PCR2 @offset 0x8\n  PCR3 @offset 0xc\n  PCR4 @offset 0x10\n  PCR5 @offset 0x14\n  PCR6 @offset 0x18\n  PCR7 @offset 0x1c\n  PCR8 @offset 0x20\n  PCR9 @offset 0x24\n  PCR10 @offset 0x28\n  PCR11 @offset 0x2c\n  PCR12 @offset 0x30\n  PCR13 @offset 0x34\n  PCR14 @offset 0x38\n  PCR15 @offset 0x3c\n  PCR16 @offset 0x40\n  PCR17 @offset 0x44\n  PCR18 @offset 0x48\n  PCR19 @offset 0x4c\n  PCR20 @offset 0x50\n  PCR21 @offset 0x54\n  PCR22 @offset 0x58\n  PCR23 @offset 0x5c\n  PCR24 @offset 0x60\n  PCR25 @offset 0x64\n  PCR26 @offset 0x68\n  PCR27 @offset 0x6c\n  PCR28 @offset 0x70\n  PCR29 @offset 0x74\n  PCR30 @offset 0x78\n  PCR31 @offset 0x7c $u32 {\n    7\n    ISF // at 24: Interrupt Status Flag\n    4\n    IRQC:4 // at 16: Interrupt Configuration\n    LK // at 15: Lock Register\n    4\n    MUX:3 // at 8: Pin Mux Control\n    1\n    DSE // at 6: Drive Strength Enable\n    ODE // at 5: Open Drain Enable\n    PFE // at 4: Passive Filter Enable\n    1\n    SRE // at 2: Slew Rate Enable\n    PE // at 1: Pull Enable\n    PS // at 0: Pull Select\n  }\n\n//---  Register GPCLR: Global Pin Control Low Register\n  GPCLR @offset 0x80 $u32 {\n    GPWE:16 // at 16: Global Pin Write Enable\n    GPWD:16 // at 0: Global Pin Write Data\n  }\n\n//---  Register GPCHR: Global Pin Control High Register\n  GPCHR @offset 0x84 $u32 {\n    GPWE:16 // at 16: Global Pin Write Enable\n    GPWD:16 // at 0: Global Pin Write Data\n  }\n\n//---  Register ISFR: Interrupt Status Flag Register\n  ISFR @offset 0xa0 $u32 {\n    ISF:32 // at 0: Interrupt Status Flag\n  }\n\n//---  Register DFER: Digital Filter Enable Register\n  DFER @offset 0xc0 $u32 {\n    DFE:32 // at 0: Digital Filter Enable\n  }\n\n//---  Register DFCR: Digital Filter Clock Register\n  DFCR @offset 0xc4 $u32 {\n    31\n    CS // at 0: Clock Source\n  }\n\n//---  Register DFWR: Digital Filter Width Register\n  DFWR @offset 0xc8 $u32 {\n    27\n    FILT:5 // at 0: Filter Length\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RCM: Reset Control Module\n//------------------------------------------------------------------------------\n\nregisters RCM @at 0x4007f000 {\n//---  Register SRS0: System Reset Status Register 0\n  SRS0 @offset 0x0 $u8 {\n    POR // at 7: Power-on reset\n    PIN // at 6: External reset pin\n    WDOG // at 5: Watchdog\n    1\n    LOL // at 3: Loss-of-lock reset\n    LOC // at 2: Loss-of-clock reset\n    LVD // at 1: Low-voltage detect reset\n    WAKEUP // at 0: Low leakage wakeup reset\n  }\n\n//---  Register SRS1: System Reset Status Register 1\n  SRS1 @offset 0x1 $u8 {\n    2\n    SACKERR // at 5: Stop Mode Acknowledge Error Reset\n    EZPT // at 4: EzPort Reset\n    MDM_AP // at 3: MDM-AP system reset request\n    SW // at 2: Software\n    LOCKUP // at 1: Core Lockup\n    JTAG // at 0: JTAG generated reset\n  }\n\n//---  Register RPFC: Reset Pin Filter Control Register\n  RPFC @offset 0x4 $u8 {\n    5\n    RSTFLTSS // at 2: Reset pin filter select in stop mode\n    RSTFLTSRW:2 // at 0: Reset pin filter select in run and wait modes\n  }\n\n//---  Register RPFW: Reset Pin Filter Width Register\n  RPFW @offset 0x5 $u8 {\n    3\n    RSTFLTSEL:5 // at 0: Reset pin filter bus clock select\n  }\n\n//---  Register MR: Mode Register\n  MR @offset 0x7 $u8 {\n    6\n    EZP_MS // at 1: EZP_MS_B pin state\n    1\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RFSYS: System register file\n//------------------------------------------------------------------------------\n\nregisters RFSYS @at 0x40041000 {\n//---  Registers REG(0,1,2,3,4,5,6,7): Register file register\n  REG [8 @offset 0x0 @inc 0x4]\n  REG0 @offset 0x0\n  REG1 @offset 0x4\n  REG2 @offset 0x8\n  REG3 @offset 0xc\n  REG4 @offset 0x10\n  REG5 @offset 0x14\n  REG6 @offset 0x18\n  REG7 @offset 0x1c $u32 {\n    HH:8 // at 24: no description available\n    HL:8 // at 16: no description available\n    LH:8 // at 8: no description available\n    LL:8 // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RFVBAT: VBAT register file\n//------------------------------------------------------------------------------\n\nregisters RFVBAT @at 0x4003e000 {\n//---  Registers REG(0,1,2,3,4,5,6,7): VBAT register file register\n  REG [8 @offset 0x0 @inc 0x4]\n  REG0 @offset 0x0\n  REG1 @offset 0x4\n  REG2 @offset 0x8\n  REG3 @offset 0xc\n  REG4 @offset 0x10\n  REG5 @offset 0x14\n  REG6 @offset 0x18\n  REG7 @offset 0x1c $u32 {\n    HH:8 // at 24: no description available\n    HL:8 // at 16: no description available\n    LH:8 // at 8: no description available\n    LL:8 // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RTC: Secure Real Time Clock\n//------------------------------------------------------------------------------\n\nregisters RTC @at 0x4003d000 {\n//---  Register TSR: RTC Time Seconds Register\n  TSR @offset 0x0 $u32 {\n    TSR:32 // at 0: Time Seconds Register\n  }\n\n//---  Register TPR: RTC Time Prescaler Register\n  TPR @offset 0x4 $u32 {\n    16\n    TPR:16 // at 0: Time Prescaler Register\n  }\n\n//---  Register TAR: RTC Time Alarm Register\n  TAR @offset 0x8 $u32 {\n    TAR:32 // at 0: Time Alarm Register\n  }\n\n//---  Register TCR: RTC Time Compensation Register\n  TCR @offset 0xc $u32 {\n    CIC:8 // at 24: Compensation Interval Counter\n    TCV:8 // at 16: Time Compensation Value\n    CIR:8 // at 8: Compensation Interval Register\n    TCR:8 // at 0: Time Compensation Register\n  }\n\n//---  Register CR: RTC Control Register\n  CR @offset 0x10 $u32 {\n    18\n    SC2P // at 13: Oscillator 2pF load configure\n    SC4P // at 12: Oscillator 4pF load configure\n    SC8P // at 11: Oscillator 8pF load configure\n    SC16P // at 10: Oscillator 16pF load configure\n    CLKO // at 9: Clock Output\n    OSCE // at 8: Oscillator Enable\n    4\n    UM // at 3: Update Mode\n    SUP // at 2: Supervisor Access\n    WPE // at 1: Wakeup Pin Enable\n    SWR // at 0: Software Reset\n  }\n\n//---  Register SR: RTC Status Register\n  SR @offset 0x14 $u32 {\n    27\n    TCE // at 4: Time Counter Enable\n    1\n    TAF // at 2: Time Alarm Flag\n    TOF // at 1: Time Overflow Flag\n    TIF // at 0: Time Invalid Flag\n  }\n\n//---  Register LR: RTC Lock Register\n  LR @offset 0x18 $u32 {\n    25\n    LRL // at 6: Lock Register Lock\n    SRL // at 5: Status Register Lock\n    CRL // at 4: Control Register Lock\n    TCL // at 3: Time Compensation Lock\n    3\n  }\n\n//---  Register IER: RTC Interrupt Enable Register\n  IER @offset 0x1c $u32 {\n    27\n    TSIE // at 4: Time Seconds Interrupt Enable\n    1\n    TAIE // at 2: Time Alarm Interrupt Enable\n    TOIE // at 1: Time Overflow Interrupt Enable\n    TIIE // at 0: Time Invalid Interrupt Enable\n  }\n\n//---  Register WAR: RTC Write Access Register\n  WAR @offset 0x800 $u32 {\n    24\n    IERW // at 7: Interrupt Enable Register Write\n    LRW // at 6: Lock Register Write\n    SRW // at 5: Status Register Write\n    CRW // at 4: Control Register Write\n    TCRW // at 3: Time Compensation Register Write\n    TARW // at 2: Time Alarm Register Write\n    TPRW // at 1: Time Prescaler Register Write\n    TSRW // at 0: Time Seconds Register Write\n  }\n\n//---  Register RAR: RTC Read Access Register\n  RAR @offset 0x804 $u32 {\n    24\n    IERR // at 7: Interrupt Enable Register Read\n    LRR // at 6: Lock Register Read\n    SRR // at 5: Status Register Read\n    CRR // at 4: Control Register Read\n    TCRR // at 3: Time Compensation Register Read\n    TARR // at 2: Time Alarm Register Read\n    TPRR // at 1: Time Prescaler Register Read\n    TSRR // at 0: Time Seconds Register Read\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SIM: System Integration Module\n//------------------------------------------------------------------------------\n\nregisters SIM @at 0x40047000 {\n//---  Register SOPT1: System Options Register 1\n  SOPT1 @offset 0x0 $u32 {\n    USBREGEN // at 31: USB voltage regulator enable\n    USBSSTBY // at 30: USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.\n    USBVSTBY // at 29: USB voltage regulator in standby mode during VLPR and VLPW modes\n    9\n    OSC32KSEL:2 // at 18: 32K oscillator clock select\n    2\n    RAMSIZE:4 // at 12: RAM size\n    12\n  }\n\n//---  Register SOPT1CFG: SOPT1 Configuration Register\n  SOPT1CFG @offset 0x4 $u32 {\n    5\n    USSWE // at 26: USB voltage regulator stop standby write enable\n    UVSWE // at 25: USB voltage regulator VLP standby write enable\n    URWE // at 24: USB voltage regulator enable write enable\n    24\n  }\n\n//---  Register SOPT2: System Options Register 2\n  SOPT2 @offset 0x1004 $u32 {\n    13\n    USBSRC // at 18: USB clock source select\n    1\n    PLLFLLSEL // at 16: PLL/FLL clock select\n    3\n    TRACECLKSEL // at 12: Debug trace clock select\n    PTD7PAD // at 11: PTD7 pad drive strength\n    1\n    FBSL:2 // at 8: FlexBus security level\n    CLKOUTSEL:3 // at 5: CLKOUT select\n    RTCCLKOUTSEL // at 4: RTC clock out select\n    4\n  }\n\n//---  Register SOPT4: System Options Register 4\n  SOPT4 @offset 0x100c $u32 {\n    2\n    FTM0TRG1SRC // at 29: FlexTimer 0 Hardware Trigger 1 Source Select\n    FTM0TRG0SRC // at 28: FlexTimer 0 Hardware Trigger 0 Source Select\n    1\n    FTM2CLKSEL // at 26: FlexTimer 2 External Clock Pin Select\n    FTM1CLKSEL // at 25: FTM1 External Clock Pin Select\n    FTM0CLKSEL // at 24: FlexTimer 0 External Clock Pin Select\n    2\n    FTM2CH0SRC:2 // at 20: FTM2 channel 0 input capture source select\n    FTM1CH0SRC:2 // at 18: FTM1 channel 0 input capture source select\n    9\n    FTM2FLT0 // at 8: FTM2 Fault 0 Select\n    3\n    FTM1FLT0 // at 4: FTM1 Fault 0 Select\n    1\n    FTM0FLT2 // at 2: FTM0 Fault 2 Select\n    FTM0FLT1 // at 1: FTM0 Fault 1 Select\n    FTM0FLT0 // at 0: FTM0 Fault 0 Select\n  }\n\n//---  Register SOPT5: System Options Register 5\n  SOPT5 @offset 0x1010 $u32 {\n    24\n    UART1RXSRC:2 // at 6: UART 1 receive data source select\n    UART1TXSRC:2 // at 4: UART 1 transmit data source select\n    UART0RXSRC:2 // at 2: UART 0 receive data source select\n    UART0TXSRC:2 // at 0: UART 0 transmit data source select\n  }\n\n//---  Register SOPT7: System Options Register 7\n  SOPT7 @offset 0x1018 $u32 {\n    16\n    ADC1ALTTRGEN // at 15: ADC1 alternate trigger enable\n    2\n    ADC1PRETRGSEL // at 12: ADC1 pre-trigger select\n    ADC1TRGSEL:4 // at 8: ADC1 trigger select\n    ADC0ALTTRGEN // at 7: ADC0 alternate trigger enable\n    2\n    ADC0PRETRGSEL // at 4: ADC0 pretrigger select\n    ADC0TRGSEL:4 // at 0: ADC0 trigger select\n  }\n\n//---  Register SDID: System Device Identification Register\n  SDID @offset 0x1024 $u32 {\n    16\n    REVID:4 // at 12: Device revision number\n    5\n    FAMID:3 // at 4: Kinetis family identification\n    PINID:4 // at 0: Pincount identification\n  }\n\n//---  Register SCGC1: System Clock Gating Control Register 1\n  SCGC1 @offset 0x1028 $u32 {\n    21\n    UART4 // at 10: UART4 Clock Gate Control\n    10\n  }\n\n//---  Register SCGC2: System Clock Gating Control Register 2\n  SCGC2 @offset 0x102c $u32 {\n    19\n    DAC0 // at 12: DAC0 Clock Gate Control\n    12\n  }\n\n//---  Register SCGC3: System Clock Gating Control Register 3\n  SCGC3 @offset 0x1030 $u32 {\n    4\n    ADC1 // at 27: ADC1 Clock Gate Control\n    2\n    FTM2 // at 24: FTM2 Clock Gate Control\n    24\n  }\n\n//---  Register SCGC4: System Clock Gating Control Register 4\n  SCGC4 @offset 0x1034 $u32 {\n    11\n    VREF // at 20: VREF Clock Gate Control\n    CMP // at 19: Comparator Clock Gate Control\n    USBOTG // at 18: USB Clock Gate Control\n    4\n    UART3 // at 13: UART3 Clock Gate Control\n    UART2 // at 12: UART2 Clock Gate Control\n    UART1 // at 11: UART1 Clock Gate Control\n    UART0 // at 10: UART0 Clock Gate Control\n    2\n    I2C1 // at 7: I2C1 Clock Gate Control\n    I2C0 // at 6: I2C0 Clock Gate Control\n    3\n    CMT // at 2: CMT Clock Gate Control\n    EWM // at 1: EWM Clock Gate Control\n    1\n  }\n\n//---  Register SCGC5: System Clock Gating Control Register 5\n  SCGC5 @offset 0x1038 $u32 {\n    18\n    PORTE // at 13: Port E Clock Gate Control\n    PORTD // at 12: Port D Clock Gate Control\n    PORTC // at 11: Port C Clock Gate Control\n    PORTB // at 10: Port B Clock Gate Control\n    PORTA // at 9: Port A Clock Gate Control\n    3\n    TSI // at 5: TSI Clock Gate Control\n    4\n    LPTIMER // at 0: Low Power Timer Access Control\n  }\n\n//---  Register SCGC6: System Clock Gating Control Register 6\n  SCGC6 @offset 0x103c $u32 {\n    2\n    RTC // at 29: RTC Access Control\n    1\n    ADC0 // at 27: ADC0 Clock Gate Control\n    1\n    FTM1 // at 25: FTM1 Clock Gate Control\n    FTM0 // at 24: FTM0 Clock Gate Control\n    PIT // at 23: PIT Clock Gate Control\n    PDB // at 22: PDB Clock Gate Control\n    USBDCD // at 21: USB DCD Clock Gate Control\n    2\n    CRC // at 18: CRC Clock Gate Control\n    2\n    I2S // at 15: I2S Clock Gate Control\n    1\n    SPI1 // at 13: SPI1 Clock Gate Control\n    SPI0 // at 12: SPI0 Clock Gate Control\n    7\n    FLEXCAN0 // at 4: FlexCAN0 Clock Gate Control\n    2\n    DMAMUX // at 1: DMA Mux Clock Gate Control\n    FTFL // at 0: Flash Memory Clock Gate Control\n  }\n\n//---  Register SCGC7: System Clock Gating Control Register 7\n  SCGC7 @offset 0x1040 $u32 {\n    30\n    DMA // at 1: DMA Clock Gate Control\n    FLEXBUS // at 0: FlexBus Clock Gate Control\n  }\n\n//---  Register CLKDIV1: System Clock Divider Register 1\n  CLKDIV1 @offset 0x1044 $u32 {\n    OUTDIV1:4 // at 28: Clock 1 output divider value\n    OUTDIV2:4 // at 24: Clock 2 output divider value\n    OUTDIV3:4 // at 20: Clock 3 output divider value\n    OUTDIV4:4 // at 16: Clock 4 output divider value\n    16\n  }\n\n//---  Register CLKDIV2: System Clock Divider Register 2\n  CLKDIV2 @offset 0x1048 $u32 {\n    28\n    USBDIV:3 // at 1: USB clock divider divisor\n    USBFRAC // at 0: USB clock divider fraction\n  }\n\n//---  Register FCFG1: Flash Configuration Register 1\n  FCFG1 @offset 0x104c $u32 {\n    NVMSIZE:4 // at 28: FlexNVM size\n    PFSIZE:4 // at 24: Program flash size\n    4\n    EESIZE:4 // at 16: EEPROM size\n    4\n    DEPART:4 // at 8: FlexNVM partition\n    6\n    FLASHDOZE // at 1: Flash Doze\n    FLASHDIS // at 0: Flash Disable\n  }\n\n//---  Register FCFG2: Flash Configuration Register 2\n  FCFG2 @offset 0x1050 $u32 {\n    SWAPPFLSH // at 31: Swap program flash\n    MAXADDR0:7 // at 24: Max address block 0\n    PFLSH // at 23: Program flash\n    MAXADDR1:7 // at 16: Max address block 1\n    16\n  }\n\n//---  Register UIDH: Unique Identification Register High\n  UIDH @offset 0x1054 $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register UIDMH: Unique Identification Register Mid-High\n  UIDMH @offset 0x1058 $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register UIDML: Unique Identification Register Mid Low\n  UIDML @offset 0x105c $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register UIDL: Unique Identification Register Low\n  UIDL @offset 0x1060 $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SMC: System Mode Controller\n//------------------------------------------------------------------------------\n\nregisters SMC @at 0x4007e000 {\n//---  Register PMPROT: Power Mode Protection Register\n  PMPROT @offset 0x0 $u8 {\n    2\n    AVLP // at 5: Allow very low power modes\n    1\n    ALLS // at 3: Allow low leakage stop mode\n    1\n    AVLLS // at 1: Allow very low leakage stop mode\n    1\n  }\n\n//---  Register PMCTRL: Power Mode Control Register\n  PMCTRL @offset 0x1 $u8 {\n    1\n    RUNM:2 // at 5: Run Mode Control\n    1\n    STOPA // at 3: Stop Aborted\n    STOPM:3 // at 0: Stop Mode Control\n  }\n\n//---  Register VLLSCTRL: VLLS Control Register\n  VLLSCTRL @offset 0x2 $u8 {\n    5\n    VLLSM:3 // at 0: VLLS Mode Control\n  }\n\n//---  Register PMSTAT: Power Mode Status Register\n  PMSTAT @offset 0x3 $u8 {\n    1\n    PMSTAT:7 // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: SPI [2]\n//        SPI0 at 0x4002c000\n//        SPI1 at 0x4002d000\n//------------------------------------------------------------------------------\n\nregisters SPI [2 @at 0x4002c000 0x4002d000]\n          SPI0 @at 0x4002c000\n          SPI1 @at 0x4002d000 {\n//---  Register MCR: DSPI Module Configuration Register\n  MCR @offset 0x0 $u32 {\n    MSTR // at 31: Master/Slave Mode Select\n    CONT_SCKE // at 30: Continuous SCK Enable\n    DCONF:2 // at 28: DSPI Configuration\n    FRZ // at 27: Freeze\n    MTFE // at 26: Modified Timing Format Enable\n    PCSSE // at 25: Peripheral Chip Select Strobe Enable\n    ROOE // at 24: Receive FIFO Overflow Overwrite Enable\n    2\n    PCSIS:6 // at 16: Peripheral Chip Select x Inactive State\n    DOZE // at 15: Doze Enable\n    MDIS // at 14: Module Disable\n    DIS_TXF // at 13: Disable Transmit FIFO\n    DIS_RXF // at 12: Disable Receive FIFO\n    CLR_TXF // at 11: Clear TX FIFO\n    CLR_RXF // at 10: no description available\n    SMPL_PT:2 // at 8: Sample Point\n    7\n    HALT // at 0: Halt\n  }\n\n//---  Register TCR: DSPI Transfer Count Register\n  TCR @offset 0x8 $u32 {\n    SPI_TCNT:16 // at 16: SPI Transfer Counter\n    16\n  }\n\n//---  Register CTAR_SLAVE: DSPI Clock and Transfer Attributes Register (In Slave Mode)\n  CTAR_SLAVE @offset 0xc $u32 {\n    FMSZ:5 // at 27: Frame Size\n    CPOL // at 26: Clock Polarity\n    CPHA // at 25: Clock Phase\n    25\n  }\n\n//---  Registers CTAR(0,1): DSPI Clock and Transfer Attributes Register (In Master Mode)\n  CTAR [2 @offset 0xc @inc 0x4]\n  CTAR0 @offset 0xc\n  CTAR1 @offset 0x10 $u32 {\n    DBR // at 31: Double Baud Rate\n    FMSZ:4 // at 27: Frame Size\n    CPOL // at 26: Clock Polarity\n    CPHA // at 25: Clock Phase\n    LSBFE // at 24: LBS First\n    PCSSCK:2 // at 22: PCS to SCK Delay Prescaler\n    PASC:2 // at 20: After SCK Delay Prescaler\n    PDT:2 // at 18: Delay after Transfer Prescaler\n    PBR:2 // at 16: Baud Rate Prescaler\n    CSSCK:4 // at 12: PCS to SCK Delay Scaler\n    ASC:4 // at 8: After SCK Delay Scaler\n    DT:4 // at 4: Delay After Transfer Scaler\n    BR:4 // at 0: Baud Rate Scaler\n  }\n\n//---  Register SR: DSPI Status Register\n  SR @offset 0x2c $u32 {\n    TCF // at 31: Transfer Complete Flag\n    TXRXS // at 30: TX and RX Status\n    1\n    EOQF // at 28: End of Queue Flag\n    TFUF // at 27: Transmit FIFO Underflow Flag\n    1\n    TFFF // at 25: Transmit FIFO Fill Flag\n    5\n    RFOF // at 19: Receive FIFO Overflow Flag\n    1\n    RFDF // at 17: Receive FIFO Drain Flag\n    1\n    TXCTR:4 // at 12: TX FIFO Counter\n    TXNXTPTR:4 // at 8: Transmit Next Pointer\n    RXCTR:4 // at 4: RX FIFO Counter\n    POPNXTPTR:4 // at 0: Pop Next Pointer\n  }\n\n//---  Register RSER: DSPI DMA/Interrupt Request Select and Enable Register\n  RSER @offset 0x30 $u32 {\n    TCF_RE // at 31: Transmission Complete Request Enable\n    2\n    EOQF_RE // at 28: DSPI Finished Request Enable\n    TFUF_RE // at 27: Transmit FIFO Underflow Request Enable\n    1\n    TFFF_RE // at 25: Transmit FIFO Fill Request Enable\n    TFFF_DIRS // at 24: Transmit FIFO Fill DMA or Interrupt Request Select\n    4\n    RFOF_RE // at 19: Receive FIFO Overflow Request Enable\n    1\n    RFDF_RE // at 17: Receive FIFO Drain Request Enable\n    RFDF_DIRS // at 16: Receive FIFO Drain DMA or Interrupt Request Select.\n    16\n  }\n\n//---  Register PUSHR: DSPI PUSH TX FIFO Register In Master Mode\n  PUSHR @offset 0x34 $u32 {\n    CONT // at 31: Continuous Peripheral Chip Select Enable\n    CTAS:3 // at 28: Clock and Transfer Attributes Select.\n    EOQ // at 27: End Of Queue\n    CTCNT // at 26: Clear Transfer Counter.\n    4\n    PCS:6 // at 16: no description available\n    TXDATA:16 // at 0: Transmit Data\n  }\n\n//---  Register PUSHR_SLAVE: DSPI PUSH TX FIFO Register In Slave Mode\n  PUSHR_SLAVE @offset 0x34 $u32 {\n    TXDATA:32 // at 0: Transmit Data\n  }\n\n//---  Register POPR: DSPI POP RX FIFO Register\n  POPR @offset 0x38 $u32 {\n    RXDATA:32 // at 0: Received Data\n  }\n\n//---  Registers TXFR(0,1,2,3): DSPI Transmit FIFO Registers\n  TXFR [4 @offset 0x3c @inc 0x4]\n  TXFR0 @offset 0x3c\n  TXFR1 @offset 0x40\n  TXFR2 @offset 0x44\n  TXFR3 @offset 0x48 $u32 {\n    TXCMD_TXDATA:16 // at 16: Transmit Command or Transmit Data\n    TXDATA:16 // at 0: Transmit Data\n  }\n\n//---  Registers RXFR(0,1,2,3): DSPI Receive FIFO Registers\n  RXFR [4 @offset 0x7c @inc 0x4]\n  RXFR0 @offset 0x7c\n  RXFR1 @offset 0x80\n  RXFR2 @offset 0x84\n  RXFR3 @offset 0x88 $u32 {\n    RXDATA:32 // at 0: Receive Data\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SysTick: System timer\n//------------------------------------------------------------------------------\n\nregisters SysTick @at 0xe000e010 {\n//---  Register CSR: SysTick Control and Status Register\n  CSR @offset 0x0 $u32 {\n    15\n    COUNTFLAG // at 16: no description available\n    13\n    CLKSOURCE // at 2: no description available\n    TICKINT // at 1: no description available\n    ENABLE // at 0: no description available\n  }\n\n//---  Register RVR: SysTick Reload Value Register\n  RVR @offset 0x4 $u32 {\n    8\n    RELOAD:24 // at 0: Value to load into the SysTick Current Value Register when the counter reaches 0\n  }\n\n//---  Register CVR: SysTick Current Value Register\n  CVR @offset 0x8 $u32 {\n    8\n    CURRENT:24 // at 0: Current value at the time the register is accessed\n  }\n\n//---  Register CALIB: SysTick Calibration Value Register\n  CALIB @offset 0xc $u32 {\n    NOREF // at 31: no description available\n    SKEW // at 30: no description available\n    6\n    TENMS:24 // at 0: Reload value to use for 10ms timing\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SystemControl: System Control Registers\n//------------------------------------------------------------------------------\n\nregisters SystemControl @at 0xe000e000 {\n//---  Register ACTLR: Auxiliary Control Register,\n  ACTLR @offset 0x8 $u32 {\n    29\n    DISFOLD // at 2: Disables folding of IT instructions.\n    DISDEFWBUF // at 1: Disables write buffer use during default memory map accesses.\n    DISMCYCINT // at 0: Disables interruption of multi-cycle instructions.\n  }\n\n//---  Register CPUID: CPUID Base Register\n  CPUID @offset 0xd00 $u32 {\n    IMPLEMENTER:8 // at 24: Implementer code\n    VARIANT:4 // at 20: Indicates processor revision: 0x2 = Revision 2\n    4\n    PARTNO:12 // at 4: Indicates part number\n    REVISION:4 // at 0: Indicates patch release: 0x0 = Patch 0\n  }\n\n//---  Register ICSR: Interrupt Control and State Register\n  ICSR @offset 0xd04 $u32 {\n    NMIPENDSET // at 31: no description available\n    2\n    PENDSVSET // at 28: no description available\n    PENDSVCLR // at 27: no description available\n    PENDSTSET // at 26: no description available\n    PENDSTCLR // at 25: no description available\n    1\n    ISRPREEMPT // at 23: no description available\n    ISRPENDING // at 22: no description available\n    4\n    VECTPENDING:6 // at 12: Exception number of the highest priority pending enabled exception\n    RETTOBASE // at 11: no description available\n    2\n    VECTACTIVE:9 // at 0: Active exception number\n  }\n\n//---  Register VTOR: Vector Table Offset Register\n  VTOR @offset 0xd08 $u32 {\n    TBLOFF:25 // at 7: Vector table base offset\n    7\n  }\n\n//---  Register AIRCR: Application Interrupt and Reset Control Register\n  AIRCR @offset 0xd0c $u32 {\n    VECTKEY:16 // at 16: Register key\n    ENDIANNESS // at 15: no description available\n    4\n    PRIGROUP:3 // at 8: Interrupt priority grouping field. This field determines the split of group priority from subpriority.\n    5\n    SYSRESETREQ // at 2: no description available\n    VECTCLRACTIVE // at 1: no description available\n    VECTRESET // at 0: no description available\n  }\n\n//---  Register SCR: System Control Register\n  SCR @offset 0xd10 $u32 {\n    27\n    SEVONPEND // at 4: no description available\n    1\n    SLEEPDEEP // at 2: no description available\n    SLEEPONEXIT // at 1: no description available\n    1\n  }\n\n//---  Register CCR: Configuration and Control Register\n  CCR @offset 0xd14 $u32 {\n    22\n    STKALIGN // at 9: Indicates stack alignment on exception entry\n    BFHFNMIGN // at 8: Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.\n    3\n    DIV_0_TRP // at 4: Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0\n    UNALIGN_TRP // at 3: Enables unaligned access traps\n    1\n    USERSETMPEND // at 1: Enables unprivileged software access to the STIR\n    NONBASETHRDENA // at 0: no description available\n  }\n\n//---  Register SHPR1: System Handler Priority Register 1\n  SHPR1 @offset 0xd18 $u32 {\n    8\n    PRI_6:8 // at 16: Priority of system handler 6, UsageFault\n    PRI_5:8 // at 8: Priority of system handler 5, BusFault\n    PRI_4:8 // at 0: Priority of system handler 4, MemManage\n  }\n\n//---  Register SHPR2: System Handler Priority Register 2\n  SHPR2 @offset 0xd1c $u32 {\n    PRI_11:8 // at 24: Priority of system handler 11, SVCall\n    24\n  }\n\n//---  Register SHPR3: System Handler Priority Register 3\n  SHPR3 @offset 0xd20 $u32 {\n    PRI_15:8 // at 24: Priority of system handler 15, SysTick exception\n    PRI_14:8 // at 16: Priority of system handler 14, PendSV\n    16\n  }\n\n//---  Register SHCSR: System Handler Control and State Register\n  SHCSR @offset 0xd24 $u32 {\n    13\n    USGFAULTENA // at 18: no description available\n    BUSFAULTENA // at 17: no description available\n    MEMFAULTENA // at 16: no description available\n    SVCALLPENDED // at 15: no description available\n    BUSFAULTPENDED // at 14: no description available\n    MEMFAULTPENDED // at 13: no description available\n    USGFAULTPENDED // at 12: no description available\n    SYSTICKACT // at 11: no description available\n    PENDSVACT // at 10: no description available\n    1\n    MONITORACT // at 8: no description available\n    SVCALLACT // at 7: no description available\n    3\n    USGFAULTACT // at 3: no description available\n    1\n    BUSFAULTACT // at 1: no description available\n    MEMFAULTACT // at 0: no description available\n  }\n\n//---  Register CFSR: Configurable Fault Status Registers\n  CFSR @offset 0xd28 $u32 {\n    6\n    DIVBYZERO // at 25: no description available\n    UNALIGNED // at 24: no description available\n    4\n    NOCP // at 19: no description available\n    INVPC // at 18: no description available\n    INVSTATE // at 17: no description available\n    UNDEFINSTR // at 16: no description available\n    BFARVALID // at 15: no description available\n    1\n    LSPERR // at 13: no description available\n    STKERR // at 12: no description available\n    UNSTKERR // at 11: no description available\n    IMPRECISERR // at 10: no description available\n    PRECISERR // at 9: no description available\n    IBUSERR // at 8: no description available\n    MMARVALID // at 7: no description available\n    1\n    MLSPERR // at 5: no description available\n    MSTKERR // at 4: no description available\n    MUNSTKERR // at 3: no description available\n    1\n    DACCVIOL // at 1: no description available\n    IACCVIOL // at 0: no description available\n  }\n\n//---  Register HFSR: HardFault Status register\n  HFSR @offset 0xd2c $u32 {\n    DEBUGEVT // at 31: no description available\n    FORCED // at 30: no description available\n    28\n    VECTTBL // at 1: no description available\n    1\n  }\n\n//---  Register DFSR: Debug Fault Status Register\n  DFSR @offset 0xd30 $u32 {\n    27\n    EXTERNAL // at 4: no description available\n    VCATCH // at 3: no description available\n    DWTTRAP // at 2: no description available\n    BKPT // at 1: no description available\n    HALTED // at 0: no description available\n  }\n\n//---  Register MMFAR: MemManage Address Register\n  MMFAR @offset 0xd34 $u32 {\n    ADDRESS:32 // at 0: Address of MemManage fault location\n  }\n\n//---  Register BFAR: BusFault Address Register\n  BFAR @offset 0xd38 $u32 {\n    ADDRESS:32 // at 0: Address of the BusFault location\n  }\n\n//---  Register AFSR: Auxiliary Fault Status Register\n  AFSR @offset 0xd3c $u32 {\n    AUXFAULT:32 // at 0: Latched version of the AUXFAULT inputs\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral TSI0: Touch Sensing Input\n//------------------------------------------------------------------------------\n\nregisters TSI0 @at 0x40045000 {\n//---  Register GENCS: General Control and Status Register\n  GENCS @offset 0x0 $u32 {\n    3\n    LPCLKS // at 28: Low Power Mode Clock Source Selection.\n    LPSCNITV:4 // at 24: TSI Low Power Mode Scan Interval.\n    NSCN:5 // at 19: Number of Consecutive Scans per Electrode electrode.\n    PS:3 // at 16: Electrode Oscillator prescaler. .\n    EOSF // at 15: End of Scan Flag.\n    OUTRGF // at 14: Out of Range Flag.\n    EXTERF // at 13: External Electrode error occurred\n    OVRF // at 12: Overrun error Flag. This flag is set when a scan trigger occurs while a scan is still in progress. Write \"1\", when this flag is set, to clear it.\n    2\n    SCNIP // at 9: Scan In Progress status\n    SWTS // at 8: Software Trigger Start\n    TSIEN // at 7: Touch Sensing Input Module Enable\n    TSIIE // at 6: Touch Sensing Input Interrupt Module Enable\n    ERIE // at 5: Error Interrupt Enable\n    ESOR // at 4: End-of-Scan or Out-of-Range Interrupt select\n    2\n    STM // at 1: Scan Trigger Mode. This bit-field can only be changed if the TSI module is disabled (TSIEN bit = 0).\n    STPE // at 0: no description available\n  }\n\n//---  Register SCANC: SCAN Control Register\n  SCANC @offset 0x4 $u32 {\n    4\n    REFCHRG:4 // at 24: Ref OSC Charge Current select\n    4\n    EXTCHRG:4 // at 16: External OSC Charge Current select\n    SMOD:8 // at 8: Scan Module\n    3\n    AMCLKS:2 // at 3: Active Mode Clock Source\n    AMPSC:3 // at 0: Active Mode Prescaler\n  }\n\n//---  Register PEN: Pin Enable Register\n  PEN @offset 0x8 $u32 {\n    12\n    LPSP:4 // at 16: Low Power Scan Pin\n    PEN15 // at 15: Touch Sensing Input Pin Enable Register 15\n    PEN14 // at 14: Touch Sensing Input Pin Enable Register 14\n    PEN13 // at 13: Touch Sensing Input Pin Enable Register 13\n    PEN12 // at 12: Touch Sensing Input Pin Enable Register 12\n    PEN11 // at 11: Touch Sensing Input Pin Enable Register 11\n    PEN10 // at 10: Touch Sensing Input Pin Enable Register 10\n    PEN9 // at 9: Touch Sensing Input Pin Enable Register 9\n    PEN8 // at 8: Touch Sensing Input Pin Enable Register 8\n    PEN7 // at 7: Touch Sensing Input Pin Enable Register 7\n    PEN6 // at 6: Touch Sensing Input Pin Enable Register 6\n    PEN5 // at 5: Touch Sensing Input Pin Enable Register 5\n    PEN4 // at 4: Touch Sensing Input Pin Enable Register 4\n    PEN3 // at 3: Touch Sensing Input Pin Enable Register 3\n    PEN2 // at 2: Touch Sensing Input Pin Enable Register 2\n    PEN1 // at 1: Touch Sensing Input Pin Enable Register 1\n    PEN0 // at 0: Touch Sensing Input Pin Enable Register 0\n  }\n\n//---  Register WUCNTR: Wake-Up Channel Counter Register\n  WUCNTR @offset 0xc $u32 {\n    16\n    WUCNT:16 // at 0: TouchSensing wake-up Channel 16bit counter value\n  }\n\n//---  Registers CNTR(1,3,5,7,9,11,13,15): Counter Register\n  CNTR [8 @offset 0x100 @inc 0x4]\n  CNTR1 @offset 0x100\n  CNTR3 @offset 0x104\n  CNTR5 @offset 0x108\n  CNTR7 @offset 0x10c\n  CNTR9 @offset 0x110\n  CNTR11 @offset 0x114\n  CNTR13 @offset 0x118\n  CNTR15 @offset 0x11c $u32 {\n    CTN:16 // at 16: TouchSensing Channel n 16-bit counter value\n    CTN1:16 // at 0: TouchSensing Channel n-1 16-bit counter value\n  }\n\n//---  Register THRESHOLD: Low Power Channel Threshold Register\n  THRESHOLD @offset 0x120 $u32 {\n    LTHH:16 // at 16: Touch Sensing Channel Low Threshold value\n    HTHH:16 // at 0: Touch Sensing Channel High Threshold value\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: UART [5]\n//        UART0 at 0x4006a000\n//        UART1 at 0x4006b000\n//        UART2 at 0x4006c000\n//        UART3 at 0x4006d000\n//        UART4 at 0x400ea000\n//------------------------------------------------------------------------------\n\nregisters UART [5 @at 0x4006a000 0x4006b000 0x4006c000 0x4006d000 0x400ea000]\n          UART0 @at 0x4006a000\n          UART1 @at 0x4006b000\n          UART2 @at 0x4006c000\n          UART3 @at 0x4006d000\n          UART4 @at 0x400ea000 {\n//---  Register BDH: UART Baud Rate Registers:High\n  BDH @offset 0x0 $u8 {\n    LBKDIE // at 7: LIN Break Detect Interrupt Enable\n    RXEDGIE // at 6: RxD Input Active Edge Interrupt Enable\n    1\n    SBR:5 // at 0: UART Baud Rate Bits\n  }\n\n//---  Register BDL: UART Baud Rate Registers: Low\n  BDL @offset 0x1 $u8 {\n    SBR:8 // at 0: UART Baud Rate Bits\n  }\n\n//---  Register C1: UART Control Register 1\n  C1 @offset 0x2 $u8 {\n    LOOPS // at 7: Loop Mode Select\n    UARTSWAI // at 6: UART Stops in Wait Mode\n    RSRC // at 5: Receiver Source Select\n    M // at 4: 9-bit or 8-bit Mode Select\n    WAKE // at 3: Receiver Wakeup Method Select\n    ILT // at 2: Idle Line Type Select\n    PE // at 1: Parity Enable\n    PT // at 0: Parity Type\n  }\n\n//---  Register C2: UART Control Register 2\n  C2 @offset 0x3 $u8 {\n    TIE // at 7: Transmitter Interrupt or DMA Transfer Enable.\n    TCIE // at 6: Transmission Complete Interrupt Enable\n    RIE // at 5: Receiver Full Interrupt or DMA Transfer Enable\n    ILIE // at 4: Idle Line Interrupt Enable\n    TE // at 3: Transmitter Enable\n    RE // at 2: Receiver Enable\n    RWU // at 1: Receiver Wakeup Control\n    SBK // at 0: Send Break\n  }\n\n//---  Register S1: UART Status Register 1\n  S1 @offset 0x4 $u8 {\n    TDRE // at 7: Transmit Data Register Empty Flag\n    TC // at 6: Transmit Complete Flag\n    RDRF // at 5: Receive Data Register Full Flag\n    IDLE // at 4: Idle Line Flag\n    OR // at 3: Receiver Overrun Flag\n    NF // at 2: Noise Flag\n    FE // at 1: Framing Error Flag\n    PF // at 0: Parity Error Flag\n  }\n\n//---  Register S2: UART Status Register 2\n  S2 @offset 0x5 $u8 {\n    LBKDIF // at 7: LIN Break Detect Interrupt Flag\n    RXEDGIF // at 6: RxD Pin Active Edge Interrupt Flag\n    MSBF // at 5: Most Significant Bit First\n    RXINV // at 4: Receive Data Inversion\n    RWUID // at 3: Receive Wakeup Idle Detect\n    BRK13 // at 2: Break Transmit Character Length\n    LBKDE // at 1: LIN Break Detection Enable\n    RAF // at 0: Receiver Active Flag\n  }\n\n//---  Register C3: UART Control Register 3\n  C3 @offset 0x6 $u8 {\n    R8 // at 7: Received Bit 8\n    T8 // at 6: Transmit Bit 8\n    TXDIR // at 5: Transmitter Pin Data Direction in Single-Wire mode\n    TXINV // at 4: Transmit Data Inversion.\n    ORIE // at 3: Overrun Error Interrupt Enable\n    NEIE // at 2: Noise Error Interrupt Enable\n    FEIE // at 1: Framing Error Interrupt Enable\n    PEIE // at 0: Parity Error Interrupt Enable\n  }\n\n//---  Register D: UART Data Register\n  D @offset 0x7 $u8 {\n    RT:8 // at 0: no description available\n  }\n\n//---  Register MA1: UART Match Address Registers 1\n  MA1 @offset 0x8 $u8 {\n    MA:8 // at 0: Match Address\n  }\n\n//---  Register MA2: UART Match Address Registers 2\n  MA2 @offset 0x9 $u8 {\n    MA:8 // at 0: Match Address\n  }\n\n//---  Register C4: UART Control Register 4\n  C4 @offset 0xa $u8 {\n    MAEN1 // at 7: Match Address Mode Enable 1\n    MAEN2 // at 6: Match Address Mode Enable 2\n    M10 // at 5: 10-bit Mode select\n    BRFA:5 // at 0: Baud Rate Fine Adjust\n  }\n\n//---  Register C5: UART Control Register 5\n  C5 @offset 0xb $u8 {\n    TDMAS // at 7: Transmitter DMA Select\n    1\n    RDMAS // at 5: Receiver Full DMA Select\n    5\n  }\n\n//---  Register ED: UART Extended Data Register\n  ED @offset 0xc $u8 {\n    NOISY // at 7: no description available\n    PARITYE // at 6: no description available\n    6\n  }\n\n//---  Register MODEM: UART Modem Register\n  MODEM @offset 0xd $u8 {\n    4\n    RXRTSE // at 3: Receiver request-to-send enable\n    TXRTSPOL // at 2: Transmitter request-to-send polarity\n    TXRTSE // at 1: Transmitter request-to-send enable\n    TXCTSE // at 0: Transmitter clear-to-send enable\n  }\n\n//---  Register IR: UART Infrared Register\n  IR @offset 0xe $u8 {\n    5\n    IREN // at 2: Infrared enable\n    TNP:2 // at 0: Transmitter narrow pulse\n  }\n\n//---  Register PFIFO: UART FIFO Parameters\n  PFIFO @offset 0x10 $u8 {\n    TXFE // at 7: Transmit FIFO Enable\n    TXFIFOSIZE:3 // at 4: Transmit FIFO. Buffer Depth\n    RXFE // at 3: Receive FIFO Enable\n    RXFIFOSIZE:3 // at 0: Receive FIFO. Buffer Depth\n  }\n\n//---  Register CFIFO: UART FIFO Control Register\n  CFIFO @offset 0x11 $u8 {\n    TXFLUSH // at 7: Transmit FIFO/Buffer Flush\n    RXFLUSH // at 6: Receive FIFO/Buffer Flush\n    4\n    TXOFE // at 1: Transmit FIFO Overflow Interrupt Enable\n    RXUFE // at 0: Receive FIFO Underflow Interrupt Enable\n  }\n\n//---  Register SFIFO: UART FIFO Status Register\n  SFIFO @offset 0x12 $u8 {\n    TXEMPT // at 7: Transmit Buffer/FIFO Empty\n    RXEMPT // at 6: Receive Buffer/FIFO Empty\n    4\n    TXOF // at 1: Transmitter Buffer Overflow Flag\n    RXUF // at 0: Receiver Buffer Underflow Flag\n  }\n\n//---  Register TWFIFO: UART FIFO Transmit Watermark\n  TWFIFO @offset 0x13 $u8 {\n    TXWATER:8 // at 0: Transmit Watermark\n  }\n\n//---  Register TCFIFO: UART FIFO Transmit Count\n  TCFIFO @offset 0x14 $u8 {\n    TXCOUNT:8 // at 0: Transmit Counter\n  }\n\n//---  Register RWFIFO: UART FIFO Receive Watermark\n  RWFIFO @offset 0x15 $u8 {\n    RXWATER:8 // at 0: Receive Watermark\n  }\n\n//---  Register RCFIFO: UART FIFO Receive Count\n  RCFIFO @offset 0x16 $u8 {\n    RXCOUNT:8 // at 0: Receive Counter\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USB0: Universal Serial Bus, OTG Capable Controller\n//------------------------------------------------------------------------------\n\nregisters USB0 @at 0x40072000 {\n//---  Register PERID: Peripheral ID Register\n  PERID @offset 0x0 $u8 {\n    2\n    ID:6 // at 0: Peripheral identification bits\n  }\n\n//---  Register IDCOMP: Peripheral ID Complement Register\n  IDCOMP @offset 0x4 $u8 {\n    2\n    NID:6 // at 0: no description available\n  }\n\n//---  Register REV: Peripheral Revision Register\n  REV @offset 0x8 $u8 {\n    REV:8 // at 0: Revision\n  }\n\n//---  Register ADDINFO: Peripheral Additional Info Register\n  ADDINFO @offset 0xc $u8 {\n    IRQNUM:5 // at 3: Assigned Interrupt Request Number\n    2\n    IEHOST // at 0: no description available\n  }\n\n//---  Register OTGISTAT: OTG Interrupt Status Register\n  OTGISTAT @offset 0x10 $u8 {\n    IDCHG // at 7: no description available\n    ONEMSEC // at 6: no description available\n    LINE_STATE_CHG // at 5: no description available\n    1\n    SESSVLDCHG // at 3: no description available\n    B_SESS_CHG // at 2: no description available\n    1\n    AVBUSCHG // at 0: no description available\n  }\n\n//---  Register OTGICR: OTG Interrupt Control Register\n  OTGICR @offset 0x14 $u8 {\n    IDEN // at 7: ID interrupt enable\n    ONEMSECEN // at 6: 1 millisecond interrupt enable\n    LINESTATEEN // at 5: Line State change interrupt enable\n    1\n    SESSVLDEN // at 3: Session valid interrupt enable\n    BSESSEN // at 2: B Session END interrupt enable\n    1\n    AVBUSEN // at 0: A VBUS Valid interrupt enable\n  }\n\n//---  Register OTGSTAT: OTG Status Register\n  OTGSTAT @offset 0x18 $u8 {\n    ID // at 7: no description available\n    ONEMSECEN // at 6: no description available\n    LINESTATESTABLE // at 5: no description available\n    1\n    SESS_VLD // at 3: Session valid\n    BSESSEND // at 2: B Session END\n    1\n    AVBUSVLD // at 0: A VBUS Valid\n  }\n\n//---  Register OTGCTL: OTG Control Register\n  OTGCTL @offset 0x1c $u8 {\n    DPHIGH // at 7: D+ Data Line pullup resistor enable\n    1\n    DPLOW // at 5: D+ Data Line pull-down resistor enable\n    DMLOW // at 4: D- Data Line pull-down resistor enable\n    1\n    OTGEN // at 2: On-The-Go pullup/pulldown resistor enable\n    2\n  }\n\n//---  Register ISTAT: Interrupt Status Register\n  ISTAT @offset 0x80 $u8 {\n    STALL // at 7: Stall Interrupt\n    ATTACH // at 6: Attach Interrupt\n    RESUME // at 5: no description available\n    SLEEP // at 4: no description available\n    TOKDNE // at 3: no description available\n    SOFTOK // at 2: no description available\n    ERROR // at 1: no description available\n    USBRST // at 0: no description available\n  }\n\n//---  Register INTEN: Interrupt Enable Register\n  INTEN @offset 0x84 $u8 {\n    STALLEN // at 7: STALL Interrupt Enable\n    ATTACHEN // at 6: ATTACH Interrupt Enable\n    RESUMEEN // at 5: RESUME Interrupt Enable\n    SLEEPEN // at 4: SLEEP Interrupt Enable\n    TOKDNEEN // at 3: TOKDNE Interrupt Enable\n    SOFTOKEN // at 2: SOFTOK Interrupt Enable\n    ERROREN // at 1: ERROR Interrupt Enable\n    USBRSTEN // at 0: USBRST Interrupt Enable\n  }\n\n//---  Register ERRSTAT: Error Interrupt Status Register\n  ERRSTAT @offset 0x88 $u8 {\n    BTSERR // at 7: no description available\n    1\n    DMAERR // at 5: no description available\n    BTOERR // at 4: no description available\n    DFN8 // at 3: no description available\n    CRC16 // at 2: no description available\n    CRC5EOF // at 1: no description available\n    PIDERR // at 0: no description available\n  }\n\n//---  Register ERREN: Error Interrupt Enable Register\n  ERREN @offset 0x8c $u8 {\n    BTSERREN // at 7: BTSERR Interrupt Enable\n    1\n    DMAERREN // at 5: DMAERR Interrupt Enable\n    BTOERREN // at 4: BTOERR Interrupt Enable\n    DFN8EN // at 3: DFN8 Interrupt Enable\n    CRC16EN // at 2: CRC16 Interrupt Enable\n    CRC5EOFEN // at 1: CRC5/EOF Interrupt Enable\n    PIDERREN // at 0: PIDERR Interrupt Enable\n  }\n\n//---  Register STAT: Status Register\n  STAT @offset 0x90 $u8 {\n    ENDP:4 // at 4: no description available\n    TX // at 3: Transmit Indicator\n    ODD // at 2: no description available\n    2\n  }\n\n//---  Register CTL: Control Register\n  CTL @offset 0x94 $u8 {\n    JSTATE // at 7: Live USB differential receiver JSTATE signal\n    SE0 // at 6: Live USB Single Ended Zero signal\n    TXSUSPENDTOKENBUSY // at 5: no description available\n    RESET // at 4: no description available\n    HOSTMODEEN // at 3: no description available\n    RESUME // at 2: no description available\n    ODDRST // at 1: no description available\n    USBENSOFEN // at 0: USB Enable\n  }\n\n//---  Register ADDR: Address Register\n  ADDR @offset 0x98 $u8 {\n    LSEN // at 7: Low Speed Enable bit\n    ADDR:7 // at 0: USB address\n  }\n\n//---  Register BDTPAGE1: BDT Page Register 1\n  BDTPAGE1 @offset 0x9c $u8 {\n    BDTBA:7 // at 1: no description available\n    1\n  }\n\n//---  Register FRMNUML: Frame Number Register Low\n  FRMNUML @offset 0xa0 $u8 {\n    FRM:8 // at 0: no description available\n  }\n\n//---  Register FRMNUMH: Frame Number Register High\n  FRMNUMH @offset 0xa4 $u8 {\n    5\n    FRM:3 // at 0: no description available\n  }\n\n//---  Register TOKEN: Token Register\n  TOKEN @offset 0xa8 $u8 {\n    TOKENPID:4 // at 4: no description available\n    TOKENENDPT:4 // at 0: no description available\n  }\n\n//---  Register SOFTHLD: SOF Threshold Register\n  SOFTHLD @offset 0xac $u8 {\n    CNT:8 // at 0: no description available\n  }\n\n//---  Register BDTPAGE2: BDT Page Register 2\n  BDTPAGE2 @offset 0xb0 $u8 {\n    BDTBA:8 // at 0: no description available\n  }\n\n//---  Register BDTPAGE3: BDT Page Register 3\n  BDTPAGE3 @offset 0xb4 $u8 {\n    BDTBA:8 // at 0: no description available\n  }\n\n//---  Registers ENDPT(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Endpoint Control Register\n  ENDPT [16 @offset 0xc0 @inc 0x4]\n  ENDPT0 @offset 0xc0\n  ENDPT1 @offset 0xc4\n  ENDPT2 @offset 0xc8\n  ENDPT3 @offset 0xcc\n  ENDPT4 @offset 0xd0\n  ENDPT5 @offset 0xd4\n  ENDPT6 @offset 0xd8\n  ENDPT7 @offset 0xdc\n  ENDPT8 @offset 0xe0\n  ENDPT9 @offset 0xe4\n  ENDPT10 @offset 0xe8\n  ENDPT11 @offset 0xec\n  ENDPT12 @offset 0xf0\n  ENDPT13 @offset 0xf4\n  ENDPT14 @offset 0xf8\n  ENDPT15 @offset 0xfc $u8 {\n    HOSTWOHUB // at 7: no description available\n    RETRYDIS // at 6: no description available\n    1\n    EPCTLDIS // at 4: no description available\n    EPRXEN // at 3: no description available\n    EPTXEN // at 2: no description available\n    EPSTALL // at 1: no description available\n    EPHSHK // at 0: no description available\n  }\n\n//---  Register USBCTRL: USB Control Register\n  USBCTRL @offset 0x100 $u8 {\n    SUSP // at 7: no description available\n    PDE // at 6: no description available\n    6\n  }\n\n//---  Register OBSERVE: USB OTG Observe Register\n  OBSERVE @offset 0x104 $u8 {\n    DPPU // at 7: no description available\n    DPPD // at 6: no description available\n    1\n    DMPD // at 4: no description available\n    4\n  }\n\n//---  Register CONTROL: USB OTG Control Register\n  CONTROL @offset 0x108 $u8 {\n    3\n    DPPULLUPNONOTG // at 4: no description available\n    4\n  }\n\n//---  Register USBTRC0: USB Transceiver Control Register 0\n  USBTRC0 @offset 0x10c $u8 {\n    USBRESET // at 7: USB reset\n    1\n    USBRESMEN // at 5: Asynchronous Resume Interrupt Enable\n    3\n    SYNC_DET // at 1: Synchronous USB Interrupt Detect\n    USB_RESUME_INT // at 0: USB Asynchronous Interrupt\n  }\n\n//---  Register USBFRMADJUST: Frame Adjust Register\n  USBFRMADJUST @offset 0x114 $u8 {\n    ADJ:8 // at 0: Frame Adjustment\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USBDCD: USB Device Charger Detection module\n//------------------------------------------------------------------------------\n\nregisters USBDCD @at 0x40035000 {\n//---  Register CONTROL: Control Register\n  CONTROL @offset 0x0 $u32 {\n    6\n    SR // at 25: Software Reset\n    START // at 24: Start Change Detection Sequence\n    7\n    IE // at 16: Interrupt Enable\n    7\n    IF // at 8: Interrupt Flag\n    7\n    IACK // at 0: Interrupt Acknowledge\n  }\n\n//---  Register CLOCK: Clock Register\n  CLOCK @offset 0x4 $u32 {\n    20\n    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary\n    1\n    CLOCK_UNIT // at 0: Unit of measurement encoding for Clock Speed\n  }\n\n//---  Register STATUS: Status Register\n  STATUS @offset 0x8 $u32 {\n    9\n    ACTIVE // at 22: Active Status Indicator\n    TO // at 21: Timeout Flag\n    ERR // at 20: Error Flag\n    SEQ_STAT:2 // at 18: Charger Detection Sequence Status\n    SEQ_RES:2 // at 16: Charger Detection Sequence Results\n    16\n  }\n\n//---  Register TIMER0: TIMER0 Register\n  TIMER0 @offset 0x10 $u32 {\n    6\n    TSEQ_INIT:10 // at 16: Sequence Initiation Time\n    4\n    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)\n  }\n\n//---  Register TIMER1: no description available\n  TIMER1 @offset 0x14 $u32 {\n    6\n    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal\n    6\n    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled\n  }\n\n//---  Register TIMER2: no description available\n  TIMER2 @offset 0x18 $u32 {\n    6\n    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup\n    12\n    CHECK_DM:4 // at 0: Time Before Check of D- Line\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral VREF: Voltage Reference\n//------------------------------------------------------------------------------\n\nregisters VREF @at 0x40074000 {\n//---  Register TRM: VREF Trim Register\n  TRM @offset 0x0 $u8 {\n    1\n    CHOPEN // at 6: Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.\n    TRIM:6 // at 0: Trim bits\n  }\n\n//---  Register SC: VREF Status and Control Register\n  SC @offset 0x1 $u8 {\n    VREFEN // at 7: Internal Voltage Reference enable\n    REGEN // at 6: Regulator enable\n    3\n    VREFST // at 2: Internal Voltage Reference stable\n    MODE_LV:2 // at 0: Buffer Mode selection\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral WDOG: Generation 2008 Watchdog Timer\n//------------------------------------------------------------------------------\n\nregisters WDOG @at 0x40052000 {\n//---  Register STCTRLH: Watchdog Status and Control Register High\n  STCTRLH @offset 0x0 $u16 {\n    1\n    DISTESTWDOG // at 14: no description available\n    BYTESEL:2 // at 12: no description available\n    TESTSEL // at 11: no description available\n    TESTWDOG // at 10: no description available\n    2\n    WAITEN // at 7: no description available\n    STOPEN // at 6: no description available\n    DBGEN // at 5: no description available\n    ALLOWUPDATE // at 4: no description available\n    WINEN // at 3: no description available\n    IRQRSTEN // at 2: no description available\n    CLKSRC // at 1: no description available\n    WDOGEN // at 0: no description available\n  }\n\n//---  Register STCTRLL: Watchdog Status and Control Register Low\n  STCTRLL @offset 0x2 $u16 {\n    INTFLG // at 15: no description available\n    15\n  }\n\n//---  Register TOVALH: Watchdog Time-out Value Register High\n  TOVALH @offset 0x4 $u16 {\n    TOVALHIGH:16 // at 0: no description available\n  }\n\n//---  Register TOVALL: Watchdog Time-out Value Register Low\n  TOVALL @offset 0x6 $u16 {\n    TOVALLOW:16 // at 0: no description available\n  }\n\n//---  Register WINH: Watchdog Window Register High\n  WINH @offset 0x8 $u16 {\n    WINHIGH:16 // at 0: no description available\n  }\n\n//---  Register WINL: Watchdog Window Register Low\n  WINL @offset 0xa $u16 {\n    WINLOW:16 // at 0: no description available\n  }\n\n//---  Register REFRESH: Watchdog Refresh Register\n  REFRESH @offset 0xc $u16 {\n    WDOGREFRESH:16 // at 0: no description available\n  }\n\n//---  Register UNLOCK: Watchdog Unlock Register\n  UNLOCK @offset 0xe $u16 {\n    WDOGUNLOCK:16 // at 0: no description available\n  }\n\n//---  Register TMROUTH: Watchdog Timer Output Register High\n  TMROUTH @offset 0x10 $u16 {\n    TIMEROUTHIGH:16 // at 0: no description available\n  }\n\n//---  Register TMROUTL: Watchdog Timer Output Register Low\n  TMROUTL @offset 0x12 $u16 {\n    TIMEROUTLOW:16 // at 0: no description available\n  }\n\n//---  Register RSTCNT: Watchdog Reset Count Register\n  RSTCNT @offset 0x14 $u16 {\n    RSTCNT:16 // at 0: no description available\n  }\n\n//---  Register PRESC: Watchdog Prescaler Register\n  PRESC @offset 0x16 $u16 {\n    5\n    PRESCVAL:3 // at 8: no description available\n    8\n  }\n\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_73_targetTemplates (
  "MK20D7-pm.svd.omnibus-import",
  "omnibus-import",
  true, // Text file
  189748, // Text length
  gWrapperFileContent_73_targetTemplates
) ;

//--- File 'teensy-3-1/c-cortex-m4-context.cpp'

const char * gWrapperFileContent_61_targetTemplates = "//\n//   T A S K    R O U T I N E    T Y P E\n//\n\ntypedef void (* RoutineTaskType) (void) ;\n\n//\n//                C O R T E X    M 4    S T A C K E D    R E G I S T E R S\n//\n//\n//         PSP+32 -> |                            |\n//                   |----------------------------| \\\n//         PSP+28 -> | xPSR                       |  |\n//                   |----------------------------|  |\n//         PSP+24 -> | PC (after SVC instruction) |  |\n//                   |----------------------------|  |\n//         PSP+20 -> | LR                         |  |\n//                   |----------------------------|  |\n//         PSP+16 -> | R12                        |  |  Saved by interrupt response\n//                   |----------------------------|  |\n//         PSP+12 -> | R3                         |  |\n//                   |----------------------------|  |\n//         PSP+8  -> | R2                         |  |\n//                   |----------------------------|  |\n//         PSP+4  -> | R1                         |  |\n//                   |----------------------------|  |\n//   /---- PSP ----> | R0                         |  |\n//   |               |----------------------------| /\n//   |\n//   |                                        *---------------------*\n//   |                                        | LR return code      | +36 [ 9]\n//   |                                        *---------------------*\n//   \\----------------------------------------| R13 (PSP)           | +32 [ 8]\n//                                            *---------------------*\n//                                            | R11                 | +28 [ 7]\n//                                            *---------------------*\n//                                            | R10                 | +24 [ 6]\n//                                            *---------------------*\n//                                            | R9                  | +20 [ 5]\n//                                            *---------------------*\n//                                            | R8                  | +16 [ 4]\n//                                            *---------------------*\n//                                            | R7                  | +12 [ 3]\n//                                            *---------------------*\n//                                            | R6                  | + 8 [ 2]\n//                                            *---------------------*\n//                                            | R5                  | + 4 [ 1]\n//  *--------------------------------*        *---------------------*\n//  | gRunningTaskContextSaveAddress +------> | R4                  | + 0 [ 0]\n//  *--------------------------------*        *---------------------*\n//\n//\n\ntypedef struct {\n  unsigned mR0 ;\n  unsigned mR1 ;\n  unsigned mR2 ;\n  unsigned mR3 ;\n  unsigned mR12 ;\n  unsigned mLR ;\n  unsigned mPC ;\n  unsigned mXPSR ;\n} StackedRegisters ;\n\n//\n\ntypedef struct {\n  unsigned mR4 ;\n  unsigned mR5 ;\n  unsigned mR6 ;\n  unsigned mR7 ;\n  unsigned mR8 ;\n  unsigned mR9 ;\n  unsigned mR10 ;\n  unsigned mR11 ;\n  StackedRegisters * mSP_USR ;\n  unsigned mLR_RETURN_CODE ;\n} TaskContext ;\n\n//\n\nstatic void kernel_set_task_context (TaskContext & ioTaskContext,\n                                     const unsigned inStackBufferAddress,\n                                     const unsigned inStackBufferSize,\n                                     RoutineTaskType inTaskRoutine,\n                                     const bool /* inHasFloatingPointContext */) {\n//--- Initialize LR\n  ioTaskContext.mLR_RETURN_CODE = 0xFFFFFFFD ; // Thread mode, process stack\n//--- Stack Pointer initial value\n  const unsigned initialTopOfStack = inStackBufferAddress + inStackBufferSize - sizeof (StackedRegisters) ; // 8 stacked registers\n//--- Initialize SP\n  StackedRegisters * ptr = (StackedRegisters *) (initialTopOfStack) ;\n  ioTaskContext.mSP_USR = ptr ;\n//--- Initialize PC\n  ptr->mPC = (unsigned) inTaskRoutine ;\n//--- Initialize CPSR\n  ptr->mXPSR = 1 << 24 ; // Thumb bit\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_61_targetTemplates (
  "c-cortex-m4-context.cpp",
  "cpp",
  true, // Text file
  4876, // Text length
  gWrapperFileContent_61_targetTemplates
) ;

//--- File 'teensy-3-1/driver-digital-teensy-3-1.omnibus-import'

const char * gWrapperFileContent_62_targetTemplates = "//\n\nctAssert target \"teensy-3-1/unprivileged\"\n\n//\n\nregisters @user PORTA (PCR, GPCLR, GPCHR)\nregisters @user PORTB (PCR, GPCLR, GPCHR)\nregisters @user PORTC (PCR, GPCLR, GPCHR)\nregisters @user PORTD (PCR, GPCLR, GPCHR)\n\nregisters @user GPIOA (PDOR, PSOR, PCOR, PTOR, PDDR)\nregisters @user GPIOB (PDOR, PSOR, PCOR, PTOR, PDDR)\nregisters @user GPIOC (PDOR, PSOR, PCOR, PTOR, PDDR)\nregisters @user GPIOD (PDOR, PSOR, PCOR, PTOR, PDDR)\n\n//\n\nenum $DigitalPort {\n  case D0  // PTB16\n  case D1  // PTB17\n  case D2  // PTD0\n  case D3  // PTA12\n  case D4  // PTA13\n  case D5  // PTD7\n  case D6  // PTD4\n  case D7  // PTD2\n  case D8  // PTD3\n  case D9  // PTC3\n  case D10 // PTC4\n  case D11 // PTC6\n  case D12 // PTC7\n  case D13 // PTC5\n  case D14 // PTD1\n  case D15 // PTC0\n  case D16 // PTB0\n  case D17 // PTB1\n  case D18 // PTB3\n  case D19 // PTB2\n  case D20 // PTD5\n  case D21 // PTD6\n  case D22 // PTC1\n  case D23 // PTC2\n}\n\n//\n\nenum $DigitalMode {\n  case output\n  case outputOpenCollector\n  case input\n  case inputPullUp\n}\n\n//\n\ndriver digital ()\n\n//\n\ndriver digital > root {\n\n  //\n  // By default, the 32 PORTA:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_9000 --> 0x4004_907C\n  // This corresponds to AIPS slot 73 (4.5.1)\n  // By default, the 32 PORTB:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_A000 --> 0x4004_A07C\n  // This corresponds to AIPS slot 74 (4.5.1)\n  // By default, the 32 PORTC:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_B000 --> 0x4004_B07C\n  // This corresponds to AIPS slot 75 (4.5.1)\n  // By default, the 32 PORTD:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_C000 --> 0x4004_C07C\n  // This corresponds to AIPS slot 76 (4.5.1)\n  //\n\n  boot { // See 19.2.2 page 351\n  // Slot 73 is accessible in user mode by resetting bits 27:24 of AIPS0.PACRJ\n  // Slot 74 is accessible in user mode by resetting bits 23:20 of AIPS0.PACRJ\n  // Slot 75 is accessible in user mode by resetting bits 19:16 of AIPS0.PACRJ\n  // Slot 76 is accessible in user mode by resetting bits 15:12 of AIPS0.PACRJ\n  // Simplification: all bits of AIPS0.PACRJ are reseted\n    AIPS0.PACRJ = 0\n  }\n\n  //\n\n  public func set safe @noUnusedWarning (\?mode:mode $DigitalMode\n                                         \?toPort:port $DigitalPort) {\n  //--- Set config and dir to apply\n   var config $u32\n    var dir $u1\n    switch mode {\n    case output :\n      config = {PORTC.PCR !MUX:1}\n      dir = 1\n    case outputOpenCollector :\n      config = {PORTC.PCR !MUX:1 !ODE:1}\n      dir = 1\n    case input :\n      config = {PORTC.PCR !MUX:1}\n      dir = 0\n    case inputPullUp :\n      config = {PORTC.PCR !MUX:1 !PE:1 !PS:1}\n      dir = 0\n    }\n  //---Apply\n    switch port {\n    case D0 : // PTB16\n      PORTB.PCR [16] = config\n      GPIOB.PDDR @bit 16 = dir\n    case D1 : // PTB17\n      PORTB.PCR [17] = config\n      GPIOB.PDDR @bit 17 = dir\n    case D2 : // PTD0\n      PORTD.PCR [0] = config\n      GPIOD.PDDR @bit 0 = dir\n    case D3 : // PTA12\n      PORTA.PCR [12] = config\n      GPIOA.PDDR @bit 12 = dir\n    case D4 : // PTA13\n      PORTA.PCR [13] = config\n      GPIOA.PDDR @bit 13 = dir\n    case D5 : // PTD7\n      PORTD.PCR [7] = config\n      GPIOD.PDDR @bit 7 = dir\n    case D6 : // PTD4\n      PORTD.PCR [4] = config\n      GPIOD.PDDR @bit 4 = dir\n    case D7 : // PTD2\n      PORTD.PCR [2] = config\n      GPIOD.PDDR @bit 2 = dir\n    case D8 : // PTD3\n      PORTD.PCR [3] = config\n      GPIOD.PDDR @bit 3 = dir\n    case D9  : // PTC3\n      PORTC.PCR [3] = config\n      GPIOC.PDDR @bit 3 = dir\n    case D10 : // PTC4\n      PORTC.PCR [4] = config\n      GPIOC.PDDR @bit 4 = dir\n    case D11 : // PTC6\n      PORTC.PCR [6] = config\n      GPIOC.PDDR @bit 6 = dir\n    case D12 : // PTC7\n      PORTC.PCR [7] = config\n      GPIOC.PDDR @bit 7 = dir\n    case D13 : // PTC5\n      PORTC.PCR [5] = config\n      GPIOC.PDDR @bit 5 = dir\n    case D14 : // PTD1\n      PORTD.PCR [1] = config\n      GPIOD.PDDR @bit 1 = dir\n    case D15 : // PTC0\n      PORTC.PCR [0] = config\n      GPIOC.PDDR @bit 0 = dir\n    case D16 : // PTB0\n      PORTB.PCR [0] = config\n      GPIOB.PDDR @bit 0 = dir\n    case D17 : // PTB1\n      PORTB.PCR [1] = config\n      GPIOB.PDDR @bit 1 = dir\n    case D18 : // PTB3\n      PORTB.PCR [3] = config\n      GPIOB.PDDR @bit 3 = dir\n    case D19 : // PTB2\n      PORTB.PCR [2] = config\n      GPIOB.PDDR @bit 2 = dir\n    case D20 : // PTD5\n      PORTD.PCR [5] = config\n      GPIOD.PDDR @bit 5 = dir\n    case D21 : // PTD6\n      PORTD.PCR [6] = config\n      GPIOD.PDDR @bit 6 = dir\n    case D22 : // PTC1\n      PORTC.PCR [1] = config\n      GPIOC.PDDR @bit 1 = dir\n    case D23 : // PTC2\n      PORTC.PCR [2] = config\n      GPIOC.PDDR @bit 2 = dir\n    }\n  }\n\n  //\n\n  public func write safe @noUnusedWarning (\?value $bool\n                                           \?toPort: port $DigitalPort) {\n    switch port {\n    case D0 : // PTB16\n      if value {\n        GPIOB.PSOR = 1 << 16\n      }else{\n        GPIOB.PCOR = 1 << 16\n      }\n    case D1 : // PTB17\n      if value {\n        GPIOB.PSOR = 1 << 17\n      }else{\n        GPIOB.PCOR = 1 << 17\n      }\n    case D2 : // PTD0\n      if value {\n        GPIOD.PSOR = 1 << 0\n      }else{\n        GPIOD.PCOR = 1 << 0\n      }\n    case D3 : // PTA12\n      if value {\n        GPIOA.PSOR = 1 << 12\n      }else{\n        GPIOA.PCOR = 1 << 12\n      }\n    case D4 : // PTA13\n      if value {\n        GPIOA.PSOR = 1 << 13\n      }else{\n        GPIOA.PCOR = 1 << 13\n      }\n    case D5 : // PTD7\n      if value {\n        GPIOD.PSOR = 1 << 7\n      }else{\n        GPIOD.PCOR = 1 << 7\n      }\n    case D6 : // PTD4\n      if value {\n        GPIOD.PSOR = 1 << 4\n      }else{\n        GPIOD.PCOR = 1 << 4\n      }\n    case D7 : // PTD2\n      if value {\n        GPIOD.PSOR = 1 << 2\n      }else{\n        GPIOD.PCOR = 1 << 2\n      }\n    case D8 : // PTD3\n      if value {\n        GPIOD.PSOR = 1 << 3\n      }else{\n        GPIOD.PCOR = 1 << 3\n      }\n    case D9  : // PTC3\n      if value {\n        GPIOC.PSOR = 1 << 3\n      }else{\n        GPIOC.PCOR = 1 << 3\n      }\n    case D10 : // PTC4\n      if value {\n        GPIOC.PSOR = 1 << 4\n      }else{\n        GPIOC.PCOR = 1 << 4\n      }\n    case D11 : // PTC6\n      if value {\n        GPIOC.PSOR = 1 << 6\n      }else{\n        GPIOC.PCOR = 1 << 6\n      }\n    case D12 : // PTC7\n      if value {\n        GPIOC.PSOR = 1 << 7\n      }else{\n        GPIOC.PCOR = 1 << 7\n      }\n    case D13 : // PTC5\n      if value {\n        GPIOC.PSOR = 1 << 5\n      }else{\n        GPIOC.PCOR = 1 << 5\n      }\n    case D14 : // PTD1\n      if value {\n        GPIOD.PSOR = 1 << 1\n      }else{\n        GPIOD.PCOR = 1 << 1\n      }\n    case D15 : // PTC0\n      if value {\n        GPIOC.PSOR = 1 << 0\n      }else{\n        GPIOC.PCOR = 1 << 0\n      }\n    case D16 : // PTB0\n      if value {\n        GPIOB.PSOR = 1 << 0\n      }else{\n        GPIOB.PCOR = 1 << 0\n      }\n    case D17 : // PTB1\n      if value {\n        GPIOB.PSOR = 1 << 1\n      }else{\n        GPIOB.PCOR = 1 << 1\n      }\n    case D18 : // PTB3\n      if value {\n        GPIOB.PSOR = 1 << 3\n      }else{\n        GPIOB.PCOR = 1 << 3\n      }\n    case D19 : // PTB2\n      if value {\n        GPIOB.PSOR = 1 << 2\n      }else{\n        GPIOB.PCOR = 1 << 2\n      }\n    case D20 : // PTD5\n      if value {\n        GPIOD.PSOR = 1 << 5\n      }else{\n        GPIOD.PCOR = 1 << 5\n      }\n    case D21 : // PTD6\n      if value {\n        GPIOD.PSOR = 1 << 6\n      }else{\n        GPIOD.PCOR = 1 << 6\n      }\n    case D22 : // PTC1\n      if value {\n        GPIOC.PSOR = 1 << 1\n      }else{\n        GPIOC.PCOR = 1 << 1\n      }\n    case D23 : // PTC2\n      if value {\n        GPIOC.PSOR = 1 << 2\n      }else{\n        GPIOC.PCOR = 1 << 2\n      }\n    }\n  }\n\n  //\n\n  public func read safe @noUnusedWarning (\?port:port $DigitalPort) -> $bool {\n    switch port {\n    case D0 : // PTB16\n      result = (GPIOB.PDIR & (1 << 16))  0\n    case D1 : // PTB17\n      result = (GPIOB.PDIR & (1 << 17))  0\n    case D2 : // PTD0\n      result = (GPIOD.PDIR & (1 << 0))  0\n    case D3 : // PTA12\n      result = (GPIOA.PDIR & (1 << 12))  0\n    case D4 : // PTA13\n      result = (GPIOA.PDIR & (1 << 13))  0\n    case D5 : // PTD7\n      result = (GPIOD.PDIR & (1 << 7))  0\n    case D6 : // PTD4\n      result = (GPIOD.PDIR & (1 << 4))  0\n    case D7 : // PTD2\n      result = (GPIOD.PDIR & (1 << 2))  0\n    case D8 : // PTD3\n      result = (GPIOD.PDIR & (1 << 3))  0\n    case D9  : // PTC3\n      result = (GPIOC.PDIR & (1 << 3))  0\n    case D10 : // PTC4\n      result = (GPIOC.PDIR & (1 << 4))  0\n    case D11 : // PTC6\n      result = (GPIOC.PDIR & (1 << 6))  0\n    case D12 : // PTC7\n      result = (GPIOC.PDIR & (1 << 7))  0\n    case D13 : // PTC5\n      result = (GPIOC.PDIR & (1 << 5))  0\n    case D14 : // PTD1\n      result = (GPIOD.PDIR & (1 << 1))  0\n    case D15 : // PTC0\n      result = (GPIOC.PDIR & (1 << 0))  0\n    case D16 : // PTB0\n      result = (GPIOB.PDIR & (1 << 0))  0\n    case D17 : // PTB1\n      result = (GPIOB.PDIR & (1 << 1))  0\n    case D18 : // PTB3\n      result = (GPIOB.PDIR & (1 << 3))  0\n    case D19 : // PTB2\n      result = (GPIOB.PDIR & (1 << 2))  0\n    case D20 : // PTD5\n      result = (GPIOD.PDIR & (1 << 5))  0\n    case D21 : // PTD6\n      result = (GPIOD.PDIR & (1 << 6))  0\n    case D22 : // PTC1\n      result = (GPIOC.PDIR & (1 << 1))  0\n    case D23 : // PTC2\n      result = (GPIOC.PDIR & (1 << 2))  0\n    }\n  }\n\n  //\n\n  public func toggle safe @noUnusedWarning (\?port:port $DigitalPort) {\n    switch port {\n    case D0 : // PTB16\n      GPIOB.PTOR = 1 << 16\n    case D1 : // PTB17\n      GPIOB.PTOR = 1 << 17\n    case D2 : // PTD0\n      GPIOD.PTOR = 1 << 0\n    case D3 : // PTA12\n      GPIOA.PTOR = 1 << 12\n    case D4 : // PTA13\n      GPIOA.PTOR = 1 << 13\n    case D5 : // PTD7\n      GPIOD.PTOR = 1 << 7\n    case D6 : // PTD4\n      GPIOD.PTOR = 1 << 4\n    case D7 : // PTD2\n      GPIOD.PTOR = 1 << 2\n    case D8 : // PTD3\n      GPIOD.PTOR = 1 << 3\n    case D9  : // PTC3\n      GPIOC.PTOR = 1 << 3\n    case D10 : // PTC4\n      GPIOC.PTOR = 1 << 4\n    case D11 : // PTC6\n      GPIOC.PTOR = 1 << 6\n    case D12 : // PTC7\n      GPIOC.PTOR = 1 << 7\n    case D13 : // PTC5\n      GPIOC.PTOR = 1 << 5\n    case D14 : // PTD1\n      GPIOD.PTOR = 1 << 1\n    case D15 : // PTC0\n      GPIOC.PTOR = 1 << 0\n    case D16 : // PTB0\n      GPIOB.PTOR = 1 << 0\n    case D17 : // PTB1\n      GPIOB.PTOR = 1 << 1\n    case D18 : // PTB3\n      GPIOB.PTOR = 1 << 3\n    case D19 : // PTB2\n      GPIOB.PTOR = 1 << 2\n    case D20 : // PTD5\n      GPIOD.PTOR = 1 << 5\n    case D21 : // PTD6\n      GPIOD.PTOR = 1 << 6\n    case D22 : // PTC1\n      GPIOC.PTOR = 1 << 1\n    case D23 : // PTC2\n      GPIOC.PTOR = 1 << 2\n    }\n  }\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_62_targetTemplates (
  "driver-digital-teensy-3-1.omnibus-import",
  "omnibus-import",
  true, // Text file
  12199, // Text length
  gWrapperFileContent_62_targetTemplates
) ;

//--- File 'teensy-3-1/driver-root-teensy-3-1.omnibus-import'

const char * gWrapperFileContent_63_targetTemplates = "\nctAssert target \"teensy-3-1/unprivileged\"\n\n//\n\ndriver root {\n  boot {\n  //---------1- Inhiber le chien de garde\n    WDOG.UNLOCK = WDOG_UNLOCK_SEQ1\n    WDOG.UNLOCK = WDOG_UNLOCK_SEQ2\n    WDOG.STCTRLH = 0x0010\n  //--- Enable clocks to always-used peripherals\n    SIM.SCGC3 = {SIM.SCGC3 !ADC1:1 !FTM2:1}\n    SIM.SCGC5 = 0x00043F82    // clocks active to all GPIO\n    SIM.SCGC6 = {SIM.SCGC6 !RTC:1 !FTM0:1 !FTM1:1 !ADC0:1 !FTFL:1}\n  //--- If the RTC oscillator isn't enabled, get it started early\n    if RTC.CR.OSCE == 0 {\n      RTC.SR = 0\n      RTC.CR = {RTC.CR !SC16P:1 !SC4P:1 !OSCE:1}\n    }\n  //--- Release I/O pins hold, if we woke up from VLLS mode\n    if PMC.REGSC.ACKISO  0 {\n      PMC.REGSC |= {PMC.REGSC !ACKISO:1}\n    }\n    NVIC.VTOR = 0  // use vector table in flash\n  //---------2- Initialisation de la PLL\n  // start in FEI mode\n  //--- Enable capacitors for crystal\n    OSC.CR = {OSC.CR !SC8P:1 !SC2P:1}\n  //--- Enable osc, 8-32 MHz range, low power mode\n    MCG.C2 = {MCG.C2 !RANGE0:2 !EREFS0:1}\n  //--- Switch to crystal as clock source, FLL input = 16 MHz / 512\n    MCG.C1 = {MCG.C1 !CLKS:2 !FRDIV:4}\n  //--- Wait for crystal oscillator to begin\n    while MCG.S.OSCINIT0 == 0 {}\n  //--- Wait for FLL to use oscillator\n    while MCG.S.IREFST  0 {}\n  //--- Wait for MCGOUT to use oscillator\n    while MCG.S.CLKST  {MCG.S !CLKST:2} {}\n  //--- Now we're in FBE mode\n  //    Config PLL input for 16 MHz Crystal / 4 = 4 MHz\n    MCG.C5 = {MCG.C5 !PRDIV0:3}\n  //--- Config PLL for 96 MHz output\n    MCG.C6 = {MCG.C6 !PLLS:1 !VDIV0:1}\n  //--- Wait for PLL to start using xtal as its input\n    while MCG.S.PLLST == 0 {}\n  //--- Wait for PLL to lock\n    while MCG.S.LOCK0 == 0 {}\n  //--- Now we're in PBE mode\n  //    Config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash\n    SIM.CLKDIV1 = {SIM.CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:3}\n    SIM.CLKDIV2 = {SIM.CLKDIV2 !USBDIV:1}\n  //--- Switch to PLL as clock source, FLL input = 16 MHz / 512\n    MCG.C1 = {MCG.C1 !CLKS:0 !FRDIV:4}\n  //--- Wait for PLL clock to be used\n    while MCG.S.CLKST  {MCG.S !CLKST:3} {}\n  //--- USB clock\n    SIM.SOPT2 = {SIM.SOPT2\n      !USBSRC:1\n      !PLLFLLSEL:1\n      !TRACECLKSEL:1\n      !CLKOUTSEL:6 // Selects the clock to output on the CLKOUT pin: OSCERCLK0\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------*\n\ndriver root ()\n\n//-----------------------------------------------------------------------------*\n\n" ;

const cRegularFileWrapper gWrapperFile_63_targetTemplates (
  "driver-root-teensy-3-1.omnibus-import",
  "omnibus-import",
  true, // Text file
  2565, // Text length
  gWrapperFileContent_63_targetTemplates
) ;

//--- File 'teensy-3-1/ld-linker.txt'

const char * gWrapperFileContent_64_targetTemplates = "/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                   Memory                                   */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nMEMORY {\n  flash (rx) : ORIGIN = 0, LENGTH = 256k \n  sram (rwx) : ORIGIN = 0x20000000, LENGTH = 32k \n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                Discard                                     */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  /DISCARD/ : {\n    *(.gnu.linkonce.t.*) ;\n    *(.glue_7t);\n    *(.glue_7);\n    *(.ARM.*);\n    *(.comment);\n    *(.debug_frame);\n    *(.v4_bx);\n    *(.iplt);\n    *(.rel.*);\n    *(.igot.plt);\n    *(.note.GNU-stack);\n  }\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                ISR Vectors                                 */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .vectors : {\n    __vectors_start = . ;\n    KEEP (*(.isr_vector)) ;\n    __vectors_end = . ;\n  } > flash\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                    Code                                    */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .text : {\n    FILL(0xff)\n    __code_start = . ;\n  /*--- Code */\n    *(.text*) ;\n    *(text*) ;\n    *(.vfp11_veneer);\n  /*---- ROM data ----*/\n    . = ALIGN(4);\n    *(.rodata*);\n    . = ALIGN(4);\n    *(.shstrtab);\n    . = ALIGN(4);\n    __code_end = . ;\n  } > flash\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                          BSS (uninitialized data)                          */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .bss (NOLOAD) : {\n    . = ALIGN(4);\n    __bss_start = . ;\n    * (.bss*) ;\n    * (COMMON) ;\n    . = ALIGN(4);\n    __bss_end = . ;\n  } > sram\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                          Data (initialized data)                           */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .data : {\n    FILL (0xFF)\n    . = ALIGN (4) ;\n    __data_start = . ;\n    * (.data*) ;\n    . = ALIGN (4) ;\n    __data_end = . ;\n  } > sram AT > flash\n}\n\n\n/*----------------------------------------------------------------------------*/\n\n__data_load_start = LOADADDR (.data) ;\n__data_load_end   = LOADADDR (.data) + SIZEOF (.data) ;\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                System stack                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .system_stack :{\n    . = ALIGN (4) ;\n    __system_stack_start = . ;\n    . += !SYSTEMSTACKSIZE! ;\n    . = ALIGN (4) ;\n    __system_stack_end = . ;\n  } > sram\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                    Heap                                    */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .heap : {\n    . = ALIGN (4) ;\n    __heap_start = . ;\n  } > sram\n}\n\n/*----------------------------------------------------------------------------*/\n\n__heap_end = ORIGIN(sram) + LENGTH(sram) ;\n\n/*----------------------------------------------------------------------------*/\n" ;

const cRegularFileWrapper gWrapperFile_64_targetTemplates (
  "ld-linker.txt",
  "txt",
  true, // Text file
  4944, // Text length
  gWrapperFileContent_64_targetTemplates
) ;

//--- File 'teensy-3-1/ll-cortex-m4.ll'

const char * gWrapperFileContent_68_targetTemplates = ";--- For LLVM < 9.0.0\n;target datalayout = \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\"\n\n;--- For LLVM >= 9.0.0\ntarget datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\n\n;---\ntarget triple = \"thumbv7em-none--eabi\"\n" ;

const cRegularFileWrapper gWrapperFile_68_targetTemplates (
  "ll-cortex-m4.ll",
  "ll",
  true, // Text file
  236, // Text length
  gWrapperFileContent_68_targetTemplates
) ;

//--- File 'teensy-3-1/py-build.txt'

const char * gWrapperFileContent_66_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport sys, os\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nsys.path.append (os.path.dirname (os.path.abspath (sys.argv [0])) + \"/sources\")\nimport omnibus\nimport toolpath\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef archiveBaseURL ():\n  return \"http://www.pcmolinaro.name/omnibus-tools/\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM optimizer invocation                                                                                          *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef llvmOptimizerCompiler ():\n  return [toolpath.toolDir () + \"/bin/opt\", \"-Oz\", \"-disable-simplify-libcalls\", \"-S\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLC Compiler invocation                                                                                            *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLCcompiler ():\n  return [toolpath.toolDir () + \"/bin/llc\", \"-function-sections\", \"-data-sections\", \"-O2\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM Linker invocation                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLVMLinkercompiler ():\n  return [toolpath.toolDir () + \"/bin/llvm-link\", \"-S\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   CLANG Compiler invocation                                                                                          *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef CLANGcompiler ():\n  result = [toolpath.toolDir () + \"/bin/clang\"]\n  result.append (\"--target=armv7-none--eabi\")\n  result.append (\"-mcpu=cortex-m4\")\n  result.append (\"-Oz\")\n  result.append (\"-fomit-frame-pointer\")\n  result.append (\"-fshort-enums\")\n  result.append (\"-Wall\")\n  result.append (\"-fno-rtti\")\n  result.append (\"-fno-exceptions\")\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   AS assembler invocation                                                                                            *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef asAssembler ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-as\", \"-mthumb\", \"-mcpu=cortex-m4\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Display object size invocation                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef displayObjectSize ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-size\", \"-t\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Object Dump invocation                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef dumpObjectCode ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-objdump\", \"-Sdh\", \"-Mforce-thumb\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker invocation                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linker ():\n  result = [toolpath.toolDir () + \"/bin/arm-eabi-ld\"]\n  result.append (\"-nostartfiles\")\n  result.append (\"--fatal-warnings\")\n  result.append (\"--warn-common\")\n  result.append (\"--no-undefined\")\n  result.append (\"--cref\")\n  result.append (\"-static\")\n  result.append (\"--gc-sections\")\n  result.append (\"--sort-common=descending\")\n  result.append (\"--sort-section=alignment\")\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker scripts                                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerScripts ():\n  result = [\"linker\"] # Linker script is linker.ld\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker libraries                                                                                                   *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerLibraries ():\n  result = [\"libgcc-armv7e-m.a\"]\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   objcopy invocation                                                                                                 *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef objcopy ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-objcopy\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   C Source files                                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef CsourceList ():\n  return [\"src.cpp\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM Source files                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLVMsourceList ():\n  return [\"src.ll\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Assembler Source files                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef assemblerSourceList ():\n  return [\"src.s\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Product directory                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef productDir ():\n  return \"product\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#                         Object files directories                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef objectDir ():\n  return \"objects\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Run executable                                                                                                      *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef runExecutableOnTarget ():\n  return [toolpath.toolDir () + \"/bin/teensy_loader_cli\", \"-w\", \"-v\", \"-mmcu=mk20dx256\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   ARM stack computations utility                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef arm_stack_computations ():\n  return [toolpath.toolDir () + \"/bin/arm-stack-computations\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   check stack utility                                                                                                *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef check_stack_utility ():\n  return [\"sources/check-stacks.py\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   MAIN                                                                                                               *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ncurrentFile = os.path.abspath (sys.argv [0])\nomnibus.runMakefile (toolpath.toolDir (), archiveBaseURL (), LLVMsourceList (), assemblerSourceList (), objectDir (), \\\n                 LLCcompiler (), llvmOptimizerCompiler (), \\\n                 asAssembler (), productDir (), \\\n                 linker (), linkerScripts (), linkerLibraries (), \\\n                 objcopy (), dumpObjectCode (), displayObjectSize (), runExecutableOnTarget (), \\\n                 CLANGcompiler (), CsourceList (), LLVMLinkercompiler (), \\\n                 currentFile, arm_stack_computations (), check_stack_utility ())\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_66_targetTemplates (
  "py-build.txt",
  "txt",
  true, // Text file
  15567, // Text length
  gWrapperFileContent_66_targetTemplates
) ;

//--- File 'teensy-3-1/py-run.txt'

const char * gWrapperFileContent_58_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport subprocess\nimport sys\nimport os\n\n#------------------------------------------------------------------------------*\n\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\nos.chdir (scriptDir)\n#---\nreturncode = subprocess.call ([\"python\", \"build.py\", \"run\"])\nif returncode != 0 :\n    sys.exit (returncode)\n\n#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_58_targetTemplates (
  "py-run.txt",
  "txt",
  true, // Text file
  630, // Text length
  gWrapperFileContent_58_targetTemplates
) ;

//--- File 'teensy-3-1/registers-mk20dx256-complement.omnibus-import'

const char * gWrapperFileContent_69_targetTemplates = "\nctAssert target \"teensy-3-1/unprivileged\"\n\n//\n\nlet f_cpu $u32 = 96_000_000\nlet f_bus $u32 = 48_000_000\nlet f_mem $u32 = 24_000_000\n\n//\n\nlet WDOG_UNLOCK_SEQ1 $u16 = 0xC520\nlet WDOG_UNLOCK_SEQ2 $u16 = 0xD928\n\n//\n\nlet DMAMUX_SOURCE_UART0_RX $u6 =  2\nlet DMAMUX_SOURCE_UART0_TX $u6 =  3\nlet DMAMUX_SOURCE_UART1_RX $u6 =  4\nlet DMAMUX_SOURCE_UART1_TX $u6 =  5\nlet DMAMUX_SOURCE_UART2_RX $u6 =  6\nlet DMAMUX_SOURCE_UART2_TX $u6 =  7\nlet DMAMUX_SOURCE_I2S0_RX  $u6 = 14\nlet DMAMUX_SOURCE_I2S0_TX  $u6 = 15\nlet DMAMUX_SOURCE_SPI0_RX  $u6 = 16\nlet DMAMUX_SOURCE_SPI0_TX  $u6 = 17\nlet DMAMUX_SOURCE_I2C0     $u6 = 22\nlet DMAMUX_SOURCE_I2C1     $u6 = 23\nlet DMAMUX_SOURCE_FTM0_CH0 $u6 = 24\nlet DMAMUX_SOURCE_FTM0_CH1 $u6 = 25\nlet DMAMUX_SOURCE_FTM0_CH2 $u6 = 26\nlet DMAMUX_SOURCE_FTM0_CH3 $u6 = 27\nlet DMAMUX_SOURCE_FTM0_CH4 $u6 = 28\nlet DMAMUX_SOURCE_FTM0_CH5 $u6 = 29\nlet DMAMUX_SOURCE_FTM0_CH6 $u6 = 30\nlet DMAMUX_SOURCE_FTM0_CH7 $u6 = 31\nlet DMAMUX_SOURCE_FTM1_CH0 $u6 = 32\nlet DMAMUX_SOURCE_FTM1_CH1 $u6 = 33\nlet DMAMUX_SOURCE_FTM2_CH0 $u6 = 34\nlet DMAMUX_SOURCE_FTM2_CH1 $u6 = 35\nlet DMAMUX_SOURCE_ADC0     $u6 = 40\nlet DMAMUX_SOURCE_ADC1     $u6 = 41\nlet DMAMUX_SOURCE_CMP0     $u6 = 42\nlet DMAMUX_SOURCE_CMP1     $u6 = 43\nlet DMAMUX_SOURCE_CMP2     $u6 = 44\nlet DMAMUX_SOURCE_DAC0     $u6 = 45\nlet DMAMUX_SOURCE_CMT      $u6 = 47\nlet DMAMUX_SOURCE_PDB      $u6 = 48\nlet DMAMUX_SOURCE_PORTA    $u6 = 49\nlet DMAMUX_SOURCE_PORTB    $u6 = 50\nlet DMAMUX_SOURCE_PORTC    $u6 = 51\nlet DMAMUX_SOURCE_PORTD    $u6 = 52\nlet DMAMUX_SOURCE_PORTE    $u6 = 53\nlet DMAMUX_SOURCE_ALWAYS0  $u6 = 54\nlet DMAMUX_SOURCE_ALWAYS1  $u6 = 55\nlet DMAMUX_SOURCE_ALWAYS2  $u6 = 56\nlet DMAMUX_SOURCE_ALWAYS3  $u6 = 57\nlet DMAMUX_SOURCE_ALWAYS4  $u6 = 58\nlet DMAMUX_SOURCE_ALWAYS5  $u6 = 59\nlet DMAMUX_SOURCE_ALWAYS6  $u6 = 60\nlet DMAMUX_SOURCE_ALWAYS7  $u6 = 61\nlet DMAMUX_SOURCE_ALWAYS8  $u6 = 62\nlet DMAMUX_SOURCE_ALWAYS9  $u6 = 63\n\n//\n\nlet DMA_TCD_ATTR_SIZE_8BIT   $u4 = 0\nlet DMA_TCD_ATTR_SIZE_16BIT  $u4 = 1\nlet DMA_TCD_ATTR_SIZE_32BIT  $u4 = 2\nlet DMA_TCD_ATTR_SIZE_16BYTE $u4 = 4\nlet DMA_TCD_ATTR_SIZE_32BYTE $u4 = 5\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_69_targetTemplates (
  "registers-mk20dx256-complement.omnibus-import",
  "omnibus-import",
  true, // Text file
  2488, // Text length
  gWrapperFileContent_69_targetTemplates
) ;

//--- File 'teensy-3-1/registers-mk20dx256.omnibus-import'

const char * gWrapperFileContent_71_targetTemplates = "\nlet f_cpu $u32 = 96_000_000\nlet f_bus $u32 = 48_000_000\nlet f_mem $u32 = 24_000_000\n\n// chapter 11: Port control and interrupts (PORT) Pin Control registers n\nregisters PORTA @at 0x4004_9000 {\n  PCR [32 @offset 0x00 @inc 4] $u32 {\n    7 ISF 4 IRQC:4 LK 4 MUX:3 1 DSE ODE PFE 1 SRE PE PS\n  }\n\n  GPCLR @offset 0x80 $u32 // Global Pin Control Low Register\n  GPCHR @offset 0x84 $u32 // Global Pin Control High Register\n  ISFR  @offset 0xA0 $u32 // $interrupt Status Flag Register\n}\n\nregisters PORTB @at 0x4004_A000 {\n  PCR [32 @offset 0x00 @inc 4] $u32 {\n    7 ISF 4 IRQC:4 LK 4 MUX:3 1 DSE ODE PFE 1 SRE PE PS\n  }\n  GPCLR @offset 0x80 $u32 // Global Pin Control Low Register\n  GPCHR @offset 0x84 $u32 // Global Pin Control High Register\n  ISFR  @offset 0xA0 $u32 // $interrupt Status Flag Register\n}\n\nregisters PORTC @at 0x4004_B000 {\n  PCR [32 @offset 0x00 @inc 4] $u32 {\n    7 ISF 4 IRQC:4 LK 4 MUX:3 1 DSE ODE PFE 1 SRE PE PS\n  }\n  GPCLR @offset 0x80 $u32 // Global Pin Control Low Register\n  GPCHR @offset 0x84 $u32 // Global Pin Control High Register\n  ISFR  @offset 0xA0 $u32 // $interrupt Status Flag Register\n}\n\nregisters PORTD @at 0x4004_C000 {\n  PCR [32 @offset 0x00 @inc 4] $u32 {\n    7 ISF 4 IRQC:4 LK 4 MUX:3 1 DSE ODE PFE 1 SRE PE PS\n  }\n  GPCLR @offset 0x80 $u32 // Global Pin Control Low Register\n  GPCHR @offset 0x84 $u32 // Global Pin Control High Register\n  ISFR  @offset 0xA0 $u32 // $interrupt Status Flag Register\n}\n\n// Chapter 12: System $integration Module (SIM)\nlet SIM_SOPT2_USBSRC      $u32 = 0x40000  // 0=USB_CLKIN 1=FFL/PLL\nlet SIM_SOPT2_PLLFLLSEL   $u32 = 0x10000 // 0=FLL 1=PLL\nlet SIM_SOPT2_TRACECLKSEL $u32 = 0x1000  // 0=MCGOUTCLK 1=CPU\nlet SIM_SOPT2_PTD7PAD     $u32 = 0x800  // 0=normal 1=double drive PTD7\nlet SIM_SOPT2_RTCCLKOUTSEL $u32 = 0x00000010  // RTC clock out select\n\nlet SIM_SCGC2_DAC0  $u32 =  0x00001000 // DAC0 Clock Gate Control\n\nlet SIM_SCGC3_ADC1 $u32 =  0x08000000 // ADC1 Clock Gate Control\nlet SIM_SCGC3_FTM2 $u32 =  0x01000000 // FTM2 Clock Gate Control\n\nlet SIM_SCGC4_VREF  $u32 =  0x00100000  // VREF Clock Gate Control\nlet SIM_SCGC4_CMP   $u32 = 0x00080000  // Comparator Clock Gate Control\nlet SIM_SCGC4_USBOTG  $u32 = 0x00040000  // USB Clock Gate Control\nlet SIM_SCGC4_UART2  $u32 =  0x00001000  // UART2 Clock Gate Control\nlet SIM_SCGC4_UART1  $u32 =  0x00000800  // UART1 Clock Gate Control\nlet SIM_SCGC4_UART0  $u32 =  0x00000400  // UART0 Clock Gate Control\nlet SIM_SCGC4_I2C1  $u32 =  0x00000080  // I2C1 Clock Gate Control\nlet SIM_SCGC4_I2C0  $u32 =  0x00000040  // I2C0 Clock Gate Control\nlet SIM_SCGC4_CMT  $u32 =  0x00000004  // CMT Clock Gate Control\nlet SIM_SCGC4_EWM  $u32 =  0x00000002  // EWM Clock Gate Control\n\nlet SIM_SCGC5_PORTE  $u32 =  0x00002000  // Port E Clock Gate Control\nlet SIM_SCGC5_PORTD  $u32 =  0x00001000  // Port D Clock Gate Control\nlet SIM_SCGC5_PORTC  $u32 =  0x00000800  // Port C Clock Gate Control\nlet SIM_SCGC5_PORTB  $u32 =  0x00000400  // Port B Clock Gate Control\nlet SIM_SCGC5_PORTA  $u32 =  0x00000200  // Port A Clock Gate Control\nlet SIM_SCGC5_TSI  $u32 =  0x00000020  // Touch Sense Input TSI Clock Gate Control\nlet SIM_SCGC5_LPTIMER  $u32 =  0x00000001  // Low Power Timer Access Control\n\nlet SIM_SCGC6_RTC  $u32 = 0x20000000  // RTC Access\nlet SIM_SCGC6_ADC0 $u32 =   0x08000000  // ADC0 Clock Gate Control\nlet SIM_SCGC6_FTM1 $u32 =   0x02000000  // FTM1 Clock Gate Control\nlet SIM_SCGC6_FTM0 $u32 =   0x01000000  // FTM0 Clock Gate Control\nlet SIM_SCGC6_PIT $u32 =  0x00800000  // PIT Clock Gate Control\nlet SIM_SCGC6_PDB $u32 =  0x00400000  // PDB Clock Gate Control\nlet SIM_SCGC6_USBDCD $u32 =  0x00200000  // USB DCD Clock Gate Control\nlet SIM_SCGC6_CRC $u32 =  0x00040000  // CRC Clock Gate Control\nlet SIM_SCGC6_I2S $u32 =  0x00008000  // I2S Clock Gate Control\nlet SIM_SCGC6_SPI1 $u32 =   0x00002000  // SPI1 Clock Gate Control\nlet SIM_SCGC6_SPI0 $u32 =   0x00001000  // SPI0 Clock Gate Control\nlet SIM_SCGC6_FLEXCAN0 $u32 =  0x00000010  // FlexCAN0 Clock Gate Control\nlet SIM_SCGC6_DMAMUX$u32 =  0x00000002  // DMA Mux Clock Gate Control\nlet SIM_SCGC6_FTFL $u32 =  0x00000001  // Flash Memory Clock Gate Control\n\nlet SIM_SCGC7_DMA $u32 =  0x00000002  // DMA Clock Gate Control\n\nlet SIM_CLKDIV2_USBFRAC $u32 =  0x01\n\nregisters SIM @at 0x4004_7000 {\n  SOPT1    @offset 0x00 $u32 // System Options registers 1\n  SOPT1CFG @offset 0x04 $u32 // SOPT1 Configuration Register\n\n//--- System Options registers 2\n   SOPT2 @offset 0x1004 $u32 {\n    13\n    USBSRC // 0=USB_CLKIN 1=FFL/PLL\n    1\n    PLLFLLSEL // 0=FLL 1=PLL\n    3\n    TRACECLKSEL // 0=MCGOUTCLK 1=CPU\n    PTD7PAD\n    3\n    CLKOUTSEL:3 // Selects the clock to output on the CLKOUT pin.\n    RTCCLKOUTSEL // RTC clock out select\n    4\n  }\n\n  SOPT4  @offset 0x100C $u32 // System Options registers 4\n  SOPT5  @offset 0x1010 $u32 // System Options registers 5\n  SOPT7  @offset 0x1018 $u32 // System Options registers 7\n  SDID   @offset 0x1024 @ro $u32 // System Device Identification Register\n  SCGC2  @offset 0x102C $u32 // System Clock Gating Control registers 2\n  SCGC3  @offset 0x1030 $u32 // System Clock Gating Control registers 3\n\n//--- System Clock Gating Control registers 4\n  SCGC4 @offset 0x1034 $u32 {\n    11\n    VREF\n    CMP\n    USBOTG\n    5\n    UART2\n    UART1\n    UART0\n    2\n    I2C1\n    I2C0\n    3\n    CMT\n    EWM\n    1\n  }\n\n  SCGC5 @offset 0x1038 $u32 // System Clock Gating Control registers 5\n  SCGC6 @offset 0x103C $u32 // System Clock Gating Control registers 6\n  SCGC7 @offset 0x1040 $u32 // System Clock Gating Control registers 7\n\n  CLKDIV1 @offset 0x1044 $u32 {// System Clock Divider registers 1\n    OUTDIV1:4 // Divide value for the core/system clock\n    OUTDIV2:4 // Divide value for the peripheral clock\n    4\n    OUTDIV4:4 // Divide value for the flash clock\n    16\n  }\n\n//--- System Clock Divider registers 2\n   CLKDIV2 @offset 0x1048 $u32 {\n    28\n    USBDIV:3\n    USBFRAC\n  }\n\n  FCFG1 @offset 0x104C @ro $u32 // Flash Configuration registers 1\n  FCFG2 @offset 0x1050 @ro $u32 // Flash Configuration registers 2\n  UIDH  @offset 0x1054 @ro $u32 // Unique Identification registers High\n  UIDMH @offset 0x1058 @ro $u32 // Unique Identification registers Mid-High\n  UIDML @offset 0x105C @ro $u32 // Unique Identification registers Mid Low\n  UIDL  @offset 0x1060 @ro $u32 // Unique Identification registers Low\n}\n\n// Chapter 13: Reset Control Module (RCM)\nregisters RCM @at 0x4007F000 {\n  SRS0 @offset 0x00 $u8 // System Reset Status registers 0\n  SRS1 @offset 0x01 $u8 // System Reset Status registers 1\n  RPFC @offset 0x04 $u8 // Reset Pin Filter Control Register\n  RPFW @offset 0x05 $u8 // Reset Pin Filter Width Register\n  MR   @offset 0x07 $u8 // Mode Register\n}\n\n// Chapter 14: System Mode Controller\nlet SMC_PMPROT_AVLP  $u8 = 0x20   // Allow very low power modes\nlet SMC_PMPROT_ALLS  $u8 = 0x08   // Allow low leakage stop mode\nlet SMC_PMPROT_AVLLS $u8 =0x02   // Allow very low leakage stop mode\n\nlet SMC_PMCTRL_LPWUI  $u8 =0x80   // Low Power Wake Up on $interrupt\nlet SMC_PMCTRL_STOPA  $u8 =0x08   // Stop Aborted\n\nlet SMC_VLLSCTRL_PORPO $u8 =0x20   // POR Power Option\n\nlet SMC_PMSTAT_RUN  $u8 =0x01   // Current power mode is RUN\nlet SMC_PMSTAT_STOP $u8 =0x02   // Current power mode is STOP\nlet SMC_PMSTAT_VLPR $u8 =0x04   // Current power mode is VLPR\nlet SMC_PMSTAT_VLPW $u8 =0x08   // Current power mode is VLPW\nlet SMC_PMSTAT_VLPS $u8 =0x10   // Current power mode is VLPS\nlet SMC_PMSTAT_LLS  $u8 =0x20   // Current power mode is LLS\nlet SMC_PMSTAT_VLLS $u8 =0x40   // Current power mode is VLLS\n\nregisters SMC @at 0x4007_E000 {\n  PMPROT  @offset 0x00 $u8 // Power Mode Protection Register\n  PMCTRL  @offset 0x01 $u8 // Power Mode Control Register\n  VLLSCTRL @offset 0x02 $u8 // VLLS Control Register\n  PMST @offset 0x03 $u8 // Power Mode Status Register\n}\n\n// Chapter 15: Power Management Controller\nlet PMC_LVDSC1_LVDF $u8 = 0x80   // Low-Voltage Detect Flag\nlet PMC_LVDSC1_LVDACK $u8 = 0x40   // Low-Voltage Detect Acknowledge\nlet PMC_LVDSC1_LVDIE $u8 = 0x20   // Low-Voltage Detect $interrupt Enable\nlet PMC_LVDSC1_LVDRE $u8 = 0x10   // Low-Voltage Detect Reset Enable\n\nlet PMC_LVDSC2_LVWF $u8 = 0x80   // Low-Voltage Warning Flag\nlet PMC_LVDSC2_LVWACK $u8 = 0x40   // Low-Voltage Warning Acknowledge\nlet PMC_LVDSC2_LVWIE $u8 = 0x20   // Low-Voltage Warning $interrupt Enable\n\nregisters PMC @at 0x4007_D000 {\n  LVDSC1 @offset 0x00 $u8 // Low Voltage Detect Status And Control 1 register\n  LVDSC2 @offset 0x01 $u8 // Low Voltage Detect Status And Control 2 register\n  REGSC  @offset 0x02 $u8 { // Regulator Status And Control register\n    3 BGEN ACKISO REGONS BGBE 1\n  }\n}\n\n// Chapter 16: Low-Leakage Wakeup Unit (LLWU)\nregisters LLWU @at 0x4007_C000 {\n  PE1  @offset 0x00 $u8 // LLWU Pin Enable 1 register\n  PE2  @offset 0x01 $u8 // LLWU Pin Enable 2 register\n  PE3  @offset 0x02 $u8 // LLWU Pin Enable 3 register\n  PE4  @offset 0x03 $u8 // LLWU Pin Enable 4 register\n  ME   @offset 0x04 $u8 // LLWU Module Enable register\n  F1   @offset 0x05 $u8 // LLWU Flag 1 register\n  F2   @offset 0x06 $u8 // LLWU Flag 2 register\n  F3   @offset 0x07 $u8 // LLWU Flag 3 register\n  FILT1 @offset 0x08 $u8 // LLWU Pin Filter 1 register\n  FILT2 @offset 0x09 $u8 // LLWU Pin Filter 2 register\n  RST  @offset 0x0A $u8 // LLWU Reset Enable register\n}\n\n// Chapter 17: Miscellaneous Control Module (MCM)\nlet MCM_PLACR_ARG  $u32 = 0x00000200  // Arbitration select 0=fixed 1=round-robin\nlet MCMCR_SRAMLWP  $u32 =  0x4000_0000  // SRAM_L write protect\n//let $u32 MCM_CR_SRAMLAP(n)   (((n) & 0x03) << 28) // SRAM_L priority 0=RR 1=favor DMA 2=CPU 3=DMA\nlet MCMCR_SRAMUWP $u32 =  0x0400_0000  // SRAM_U write protect\n//let $u32 MCM_CR_SRAMUAP(n)   (((n) & 0x03) << 24) // SRAM_U priority 0=RR 1=favor DMA 2=CPU 3=DMA\n\nregisters MCM @at 0xE008_0000 {\n  PLASC @offset 0x08 @ro $u16 // Crossbar Switch (AXBS) Slave Configuration\n  PLAMC @offset 0x0A @ro $u16 // Crossbar Switch (AXBS) Master Configuration\n  CR @offset 0x0C $u32 // RAM arbitration control registers (MK20DX256)\n}\n\n// Crossbar Switch (AXBS) - only programmable on MK20DX256\nlet AXBS_CRS_READONLY  $u32 =  0x80000000\nlet AXBS_CRS_HALTLOWPRIORITY $u32 = 0x40000000\nlet AXBS_CRS_ARB_FIXED $u32 = 0x00000000\nlet AXBS_CRS_ARB_ROUNDROBIN $u32 = 0x00010000\nlet AXBS_CRS_PARK_FIXED $u32 =  0x00000000\nlet AXBS_CRS_PARK_PREVIOUS $u32 =  0x00000010\nlet AXBS_CRS_PARK_NONE $u32 =  0x00000020\n\nregisters AXBS @at 0x4000_4000 {\n  PRS0   @offset 0x000 $u32 // Priority Registers Slave 0\n  CRS0   @offset 0x010 $u32 // Control registers 0\n  PRS1   @offset 0x100 $u32 // Priority Registers Slave 1\n  CRS1   @offset 0x110 $u32 // Control registers 1\n  PRS2   @offset 0x200 $u32 // Priority Registers Slave 2\n  CRS2   @offset 0x210 $u32 // Control registers 2\n  PRS3   @offset 0x300 $u32 // Priority Registers Slave 3\n  CRS3   @offset 0x310 $u32 // Control registers 3\n  PRS4   @offset 0x400 $u32 // Priority Registers Slave 4\n  CRS4   @offset 0x410 $u32 // Control registers 4\n  PRS5   @offset 0x500 $u32 // Priority Registers Slave 5\n  CRS5   @offset 0x510 $u32 // Control registers 5\n  PRS6   @offset 0x600 $u32 // Priority Registers Slave 6\n  CRS6   @offset 0x610 $u32 // Control registers 6\n  PRS7   @offset 0x700 $u32 // Priority Registers Slave 7\n  CRS7   @offset 0x710 $u32 // Control registers 7\n  MGPCR0 @offset 0x800 $u32 // Master 0 General Purpose Control Register\n  MGPCR1 @offset 0x900 $u32 // Master 1 General Purpose Control Register\n  MGPCR2 @offset 0xA00 $u32 // Master 2 General Purpose Control Register\n  MGPCR3 @offset 0xB00 $u32 // Master 3 General Purpose Control Register\n  MGPCR4 @offset 0xC00 $u32 // Master 4 General Purpose Control Register\n  MGPCR5 @offset 0xD00 $u32 // Master 5 General Purpose Control Register\n  MGPCR6 @offset 0xE00 $u32 // Master 6 General Purpose Control Register\n  MGPCR7 @offset 0xF00 $u32 // Master 7 General Purpose Control Register\n}\n\n\n// Chapter 20: Direct Memory Access Multiplexer (DMAMUX)\nlet DMA_CHANNEL_COUNT = 16\n\nregisters DMAMUX0 @at 0x4002_1000 {\n  CHCFG [DMA_CHANNEL_COUNT @offset 0x0 @inc 1] $u8 {\n    ENABLE TRIG SOURCE:6\n  }\n}\n\nlet DMAMUX_SOURCE_UART0_RX $u6 =  2\nlet DMAMUX_SOURCE_UART0_TX $u6 =  3\nlet DMAMUX_SOURCE_UART1_RX $u6 =  4\nlet DMAMUX_SOURCE_UART1_TX $u6 =  5\nlet DMAMUX_SOURCE_UART2_RX $u6 =  6\nlet DMAMUX_SOURCE_UART2_TX $u6 =  7\nlet DMAMUX_SOURCE_I2S0_RX  $u6 = 14\nlet DMAMUX_SOURCE_I2S0_TX  $u6 = 15\nlet DMAMUX_SOURCE_SPI0_RX  $u6 = 16\nlet DMAMUX_SOURCE_SPI0_TX  $u6 = 17\nlet DMAMUX_SOURCE_I2C0     $u6 = 22\nlet DMAMUX_SOURCE_I2C1     $u6 = 23\nlet DMAMUX_SOURCE_FTM0_CH0 $u6 = 24\nlet DMAMUX_SOURCE_FTM0_CH1 $u6 = 25\nlet DMAMUX_SOURCE_FTM0_CH2 $u6 = 26\nlet DMAMUX_SOURCE_FTM0_CH3 $u6 = 27\nlet DMAMUX_SOURCE_FTM0_CH4 $u6 = 28\nlet DMAMUX_SOURCE_FTM0_CH5 $u6 = 29\nlet DMAMUX_SOURCE_FTM0_CH6 $u6 = 30\nlet DMAMUX_SOURCE_FTM0_CH7 $u6 = 31\nlet DMAMUX_SOURCE_FTM1_CH0 $u6 = 32\nlet DMAMUX_SOURCE_FTM1_CH1 $u6 = 33\nlet DMAMUX_SOURCE_FTM2_CH0 $u6 = 34\nlet DMAMUX_SOURCE_FTM2_CH1 $u6 = 35\nlet DMAMUX_SOURCE_ADC0     $u6 = 40\nlet DMAMUX_SOURCE_ADC1     $u6 = 41\nlet DMAMUX_SOURCE_CMP0     $u6 = 42\nlet DMAMUX_SOURCE_CMP1     $u6 = 43\nlet DMAMUX_SOURCE_CMP2     $u6 = 44\nlet DMAMUX_SOURCE_DAC0     $u6 = 45\nlet DMAMUX_SOURCE_CMT      $u6 = 47\nlet DMAMUX_SOURCE_PDB      $u6 = 48\nlet DMAMUX_SOURCE_PORTA    $u6 = 49\nlet DMAMUX_SOURCE_PORTB    $u6 = 50\nlet DMAMUX_SOURCE_PORTC    $u6 = 51\nlet DMAMUX_SOURCE_PORTD    $u6 = 52\nlet DMAMUX_SOURCE_PORTE    $u6 = 53\nlet DMAMUX_SOURCE_ALWAYS0  $u6 = 54\nlet DMAMUX_SOURCE_ALWAYS1  $u6 = 55\nlet DMAMUX_SOURCE_ALWAYS2  $u6 = 56\nlet DMAMUX_SOURCE_ALWAYS3  $u6 = 57\nlet DMAMUX_SOURCE_ALWAYS4  $u6 = 58\nlet DMAMUX_SOURCE_ALWAYS5  $u6 = 59\nlet DMAMUX_SOURCE_ALWAYS6  $u6 = 60\nlet DMAMUX_SOURCE_ALWAYS7  $u6 = 61\nlet DMAMUX_SOURCE_ALWAYS8  $u6 = 62\nlet DMAMUX_SOURCE_ALWAYS9  $u6 = 63\n\n// Chapter 21: Direct Memory Access Controller (eDMA)\n\n// Control Register\nlet DMA_TCD_ATTR_SIZE_8BIT   $u4 = 0\nlet DMA_TCD_ATTR_SIZE_16BIT  $u4 = 1\nlet DMA_TCD_ATTR_SIZE_32BIT  $u4 = 2\nlet DMA_TCD_ATTR_SIZE_16BYTE $u4 = 4\nlet DMA_TCD_ATTR_SIZE_32BYTE $u4 = 5\n\nregisters DMA @at 0x4000_8000 {\n  CR @offset 0x00 $u32 {\n    14\n    CX // Cancel Transfer\n    ECX // Error Cancel Transfer\n    5\n    GRP1PRI\n    1\n    GRP0PRI\n    EMLM // Enable Minor Loop Mapping\n    CLM // Continuous Link Mode\n    HALT // Halt DMA Operations\n    HOE // Halt On Error\n    ERGA // Enable Round Robin Group Arbitration\n    ERCA // Enable Round Robin Channel Arbitration\n    EDBG // Enable Debug\n    1\n  }\n\n  // Error Status Register\n  ES  @offset 0x04 $u32 {\n    VLD 14 ECX 1 CPE 2 ERRCHN :4 SAE SOE DAE DOE NCE SGE SBE DBE\n  }\n\n  ERQ @offset 0x0C $u32 { // Enable Request Register\n   16\n   ERQ15 ERQ14 ERQ13 ERQ12 ERQ11 ERQ10 ERQ9  ERQ8\n   ERQ7  ERQ6  ERQ5  ERQ4  ERQ3  ERQ2  ERQ1  ERQ0\n  }\n\n  EEI @offset 0x14 $u32 { // Enable Error $interrupt Register\n   16\n   EEI15 EEI14 EEI13 EEI12 EEI11 EEI10 EEI9  EEI8\n   EEI7  EEI6  EEI5  EEI4  EEI3  EEI2  EEI1  EEI0\n  }\n\n  CEEI @offset 0x18 $u8 { // Clear Enable Error $interrupt Register\n   NOP CAAE 2 CEEI:4\n  }\n\n  SEEI @offset 0x19 $u8 { // Set Enable Error $interrupt Register\n   NOP SAAE 2 SEEI:4\n  }\n\n  CERQ @offset 0x1A $u8 { // Clear Enable Request Register\n   NOP CAER 2 CERQ:4\n  }\n\n  SERQ @offset 0x1B $u8 { // Set Enable Request Register\n   NOP SAER 2 SERQ:4\n  }\n\n  CDNE @offset 0x1C $u8 { // Clear DONE Status Bit Register\n   NOP CADN 2 CDNE:4\n  }\n\n  SSRT @offset 0x1D $u8 { // Set START Bit Register\n   NOP SAST 2 SSRT:4\n  }\n\n  CERR @offset 0x1E $u8 { // Clear Error Register\n   NOP CAEI 2 CERR:4\n  }\n\n  CINT @offset 0x1F $u8 { // Clear $interrupt Request Register\n   NOP CAIR 2 CINT:4\n  }\n\n  INT @offset 0x24 $u32 { // $interrupt Request Register\n   16\n   INT15 INT14 INT13 INT12 INT11 INT10 INT9  INT8\n   INT7  INT6  INT5  INT4  INT3  INT2  INT1  INT0\n  }\n\n  ERR @offset 0x2C $u32 { // Error Register\n   16\n   ERR15 ERR14 ERR13 ERR12 ERR11 ERR10 ERR9  ERR8\n   ERR7  ERR6  ERR5  ERR4  ERR3  ERR2  ERR1  ERR0\n  }\n\n  HRS @offset 0x34 $u32 { // Hardware Request Status Register\n   16\n   HRS15 HRS14 HRS13 HRS12 HRS11 HRS10 HRS9  HRS8\n   HRS7  HRS6  HRS5  HRS4  HRS3  HRS2  HRS1  HRS0\n  }\n\n  DCHPRI [DMA_CHANNEL_COUNT @offset 0x100 @inc 1] $u8 { // Channel n Priority Register\n   ECP DPA 2 CHPRI:4\n  }\n\n  TCD_SADDR [DMA_CHANNEL_COUNT @offset 0x1000 @inc 32] $u32 // TCD Source Address\n\n  TCD_SOFF [DMA_CHANNEL_COUNT @offset 0x1004 @inc 32] $i16 // TCD Signed Source Address Offset\n\n  TCD_ATTR [DMA_CHANNEL_COUNT @offset 0x1006 @inc 32] $u16 { // TCD Transfer Attributes\n    SMOD:4 SSIZE:4 DMOD:4 DSIZE:4\n  }\n\n  // TCD Minor Byte Count (Minor Loop Disabled)\n  TCD_NBYTES_MLNO [DMA_CHANNEL_COUNT @offset 0x1008 @inc 32] $u32\n\n  // TCD Last Source Address Adjustment\n  TCD_SLAST [DMA_CHANNEL_COUNT @offset 0x100C @inc 32] $i32\n\n  // TCD Destination Address\n  TCD_DADDR [DMA_CHANNEL_COUNT @offset 0x1010 @inc 32] $u32\n\n  // TCD Signed Destination Address Offset\n  TCD_DOFF [DMA_CHANNEL_COUNT @offset 0x1014 @inc 32] $i16\n\n  // TCD Current Minor Loop Link Major Loop Count (Channel Linking Disabled)\n  TCD_CITER_ELINKNO [DMA_CHANNEL_COUNT @offset 0x1016 @inc 32] $u16 {\n    ELINK CITER:15\n  }\n\n  // TCD Last Destination Address Adjustment/Scatter Gather Address\n  TCD_DLASTSGA [DMA_CHANNEL_COUNT @offset 0x1018 @inc 32] $i32\n\n  // TCD Control and Status\n  TCD_CSR [DMA_CHANNEL_COUNT @offset 0x101C @inc 32] $u16 {\n    BWC:2 2 MAJORLINKCH:4\n    DONE ACTIVE MAJORLINK ESG DREQ INTHALF INTMAJOR START\n  }\n\n  // TCD Beginning Minor Loop Link Major Loop Count (Channel Linking Disabled)\n  TCD_BITER_ELINKNO [DMA_CHANNEL_COUNT @offset 0x101E @inc 32] $u16 {\n    ELINK BITER:15\n  }\n}\n\n//// Chapter 22: External Watchdog Monitor (EWM)\n//registers EWM_CTRL  *(volatile $u8_t  *)0x40061000 // Control Register\n//registers EWM_SERV  *(volatile $u8_t  *)0x40061001 // Service Register\n//registers EWM_CMPL  *(volatile $u8_t  *)0x40061002 // Compare Low Register\n//registers EWM_CMPH  *(volatile $u8_t  *)0x40061003 // Compare High Register\n//\n//// Chapter 23: Watchdog Timer (WDOG)\nlet WDOG_STCTRLH_DISTESTWDOG $u16 = 0x4000  // Allows the WDOG's functional test mode to be disabled permanently.\n\nlet WDOG_STCTRLH_TESTSEL  $u16 = 0x0800\nlet WDOG_STCTRLH_TESTWDOG $u16 = 0x0400\nlet WDOG_STCTRLH_WAITEN   $u16 = 0x0080\nlet WDOG_STCTRLH_STOPEN   $u16 = 0x0040\nlet WDOG_STCTRLH_DBGEN    $u16 = 0x0020\nlet WDOG_STCTRLH_ALLOWUPDATE $u16 = 0x0010\nlet WDOG_STCTRLH_WINEN   $u16 = 0x0008\nlet WDOG_STCTRLH_IRQRSTEN  $u16 = 0x0004\nlet WDOG_STCTRLH_CLKSRC $u16 = 0x0002\nlet WDOG_STCTRLH_WDOGEN $u16 = 0x0001\n\nlet WDOG_UNLOCK_SEQ1   $u16 = 0xC520\nlet WDOG_UNLOCK_SEQ2   $u16 = 0xD928\n\nregisters WDOG @at 0x4005_2000 {\n  STCTRLH  @offset 0x00 $u16 // Watchdog Status and Control registers High\n  STCTRLL  @offset 0x02 $u16 // Watchdog Status and Control registers Low\n  TOVALH   @offset 0x04 $u16 // Watchdog Time-out Value registers High\n  TOVALL   @offset 0x06 $u16 // Watchdog Time-out Value registers Low\n  WINH     @offset 0x08 $u16 // Watchdog Window registers High\n  WINL     @offset 0x0A $u16 // Watchdog Window registers Low\n  REFRESH  @offset 0x0C $u16 // Watchdog Refresh register\n  UNLOCK   @offset 0x0E $u16 // Watchdog Unlock register\n  TMROUTH  @offset 0x10 $u16 // Watchdog Timer Output registers High\n  TMROUTL  @offset 0x12 $u16 // Watchdog Timer Output registers Low\n  RSTCNT   @offset 0x14 $u16 // Watchdog Reset Count register\n  PRESC    @offset 0x16 $u16 // Watchdog Prescaler register\n}\n\n// Chapter 24: Multipurpose Clock Generator (MCG)\nlet MCG_C4_SCFTRIM $u8 = 0x01   // Slow $internal Reference Clock Fine Trim\nlet MCG_C4_DMX32 $u8 = 0x80   // DCO Maximum Frequency with 32.768 kHz Reference controls whether the DCO frequency range is narrowed\nlet MCG_SC_LOCS0 $u8 = 0x01   // OSC0 Loss of Clock Status\n//SC_FCRDIV(n)  (UInt8_t)(((n) & 0x07) << 1) // Fast Clock $internal Reference Divider\nlet MCG_SC_FLTPRSRV  $u8 = 0x10   // FLL Filter Preserve Enable\nlet MCG_SC_ATMF $u8 = 0x20   // Automatic Trim Machine Fail Flag\nlet MCG_SC_ATMS $u8 = 0x40   // Automatic Trim Machine Select\nlet MCG_SC_ATME $u8 = 0x80   // Automatic Trim Machine Enable\n\nregisters MCG @at 0x4006_4000 {\n  C1 @offset 0x00 $u8 { // MCG Control 1 Register\n    CLKS:2 // Clock Source Select Selects the clock source for MCGOUTCLK\n    FRDIV:3 // FLL External Reference Divider Selects the amount to divide down the external reference clock for the FLL\n    IREFS // $internal Reference Select Selects the reference clock source for the FLL\n    IRCLKEN // $internal Reference Clock Enable Enables the internal reference clock for use as MCGIRCLK\n    IREFSTEN // $internal Reference Stop Enable Controls whether or not the internal reference clock remains enabled when the MCG enters Stop mode\n  }\n\n  C2 @offset 0x01 $u8 { // MCG Control 2 Register\n    LOCRE0 // Loss of Clock Reset Enable Determines whether an interrupt\n            // or a reset request is made following a loss of OSC0\n    1\n    RANGE0:2 // Frequency Range Select Selects the frequency range\n               // for the crystal oscillator\n    HGO0 // High Gain Oscillator Select Controls the crystal oscillator mode of operation\n    EREFS // External Reference Select selects the source for the external reference clock\n    LP // Low Power Select Controls whether the FLL or PLL is disabled in BLPI and BLPE modes.\n    IRCS // $internal Reference Clock Select Selects between the fast or slow internal reference clock source.\n  }\n\n  C3 @offset 0x02 $u8 // MCG Control 3 Register\n  //C3_SCTRIM(n)  (UInt8_t)(n)   // Slow $internal Reference Clock Trim Setting\n  C4 @offset 0x03 $u8 // MCG Control 4 Register\n  //C4_FCTRIM(n)  (UInt8_t)(((n) & 0x0F) << 1) // Fast $internal Reference Clock Trim Setting\n  //C4_DRST_DRS(n)  (UInt8_t)(((n) & 0x03) << 5) // DCO Range Select\n\n  C5 @offset 0x04 $u8 { // MCG Control 5 Register\n   1\n   PLLCLKEN0 // PLL Clock Enable\n   PLLSTEN0  // PLL Stop Enable\n   PRDIV0:5 // PLL External Reference Divider\n  }\n\n  C6 @offset 0x05 $u8 { // MCG Control 6 Register\n   LOLIE0 // Loss of Lock $interrrupt Enable\n   PLLS // PLL Select Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00\n   CME0   // Clock Monitor Enable\n   VDIV0:5 // VCO 0 Divider\n  }\n\n  S @offset 0x06 @ro $u8 { // MCG Status Register\n   LOLS0 // Loss of Lock Status\n   LOCK0 // Lock Status 0=PLL Unlocked 1=PLL Locked\n   PLLST // PLL Select Status\n   IREFST // $internal Reference Status\n   CLKST:2 // Clock Mode Status 0=FLL is selected 1= $internal ref 2=External ref 3=PLL\n   OSCINIT0 // OSC Initialization resets to 0 is set to 1 after the initialization cycles of the crystal oscillator\n   IRCST   // $internal Reference Clock Status\n  }\n\n  SC @offset 0x08 $u8 // MCG Status and Control Register\n\n  ATCVH @offset 0x0A $u8 // MCG Auto Trim Compare Value High Register\n  ATCVL @offset 0x0B $u8 // MCG Auto Trim Compare Value Low Register\n  C7    @offset 0x0C $u8 // MCG Control 7 Register\n  C8    @offset 0x0D $u8 // MCG Control 8 Register\n}\n\n//// Chapter 25: Oscillator (OSC)\nlet OSC_SC16P $u8 = 0x01\n\nregisters OSC @at 0x4006_5000 {\n  CR @offset 0x00 $u8 {// OSC Control Register\n    ERCLKEN // External Reference Enable Enables external reference clock (OSCERCLK)\n    1\n    EREFSTEN // External Reference Stop Enable Controls whether or not\n              // the external reference clock (OSCERCLK) remains enabled when\n              // MCU enters Stop mode.\n    1\n    SC2P // Oscillator 2 pF Capacitor Load Configure\n    SC4P // Oscillator 4 pF Capacitor Load Configure\n    SC8P // Oscillator 8 pF Capacitor Load Configure\n    SC16P // Oscillator 16 pF Capacitor Load Configure\n  }\n}\n\n//// Chapter 27: Flash Memory Controller (FMC)\nregisters FMC @at 0x4001_F000 {\n  PFAPR     @offset 0x000 $u32 // Flash Access Protection\n  PFB0CR    @offset 0x004 $u32 // Flash Control\n  TAGVDW0S0 @offset 0x100 $u32 // Cache Tag Storage\n  TAGVDW0S1 @offset 0x104 $u32 // Cache Tag Storage\n  TAGVDW1S0 @offset 0x108 $u32 // Cache Tag Storage\n  TAGVDW1S1 @offset 0x10C $u32 // Cache Tag Storage\n  TAGVDW2S0 @offset 0x110 $u32 // Cache Tag Storage\n  TAGVDW2S1 @offset 0x114 $u32 // Cache Tag Storage\n  TAGVDW3S0 @offset 0x118 $u32 // Cache Tag Storage\n  TAGVDW3S1 @offset 0x11C $u32 // Cache Tag Storage\n  DATAW0S0  @offset 0x200 $u32 // Cache Data Storage\n  DATAW0S1  @offset 0x204 $u32 // Cache Data Storage\n  DATAW1S0  @offset 0x208 $u32 // Cache Data Storage\n  DATAW1S1  @offset 0x20C $u32 // Cache Data Storage\n  DATAW2S0  @offset 0x210 $u32 // Cache Data Storage\n  DATAW2S1  @offset 0x214 $u32 // Cache Data Storage\n  DATAW3S0  @offset 0x218 $u32 // Cache Data Storage\n  DATAW3S1  @offset 0x21C $u32 // Cache Data Storage\n}\n\n\n//// Chapter 28: Flash Memory Module (FTFL)\n//registers FTFL_FST *(volatile $u8_t  *)0x40020000      // Flash Status Register\n//registers FTFL_FSTAT_CCIF   (UInt8_t)0x80   // Command Complete $interrupt Flag\n//registers FTFL_FSTAT_RDCOLERR  (UInt8_t)0x40   // Flash Read Collision Error Flag\n//registers FTFL_FSTAT_ACCERR  (UInt8_t)0x20   // Flash Access Error Flag\n//registers FTFL_FSTAT_FPVIOL  (UInt8_t)0x10   // Flash Protection Violation Flag\n//registers FTFL_FSTAT_MGSTAT0  (UInt8_t)0x01   // Memory Controller Command Completion Status Flag\n//registers FTFL_FCNFG  *(volatile $u8_t  *)0x40020001      // Flash Configuration Register\n//registers FTFL_FCNFG_CCIE   (UInt8_t)0x80   // Command Complete $interrupt Enable\n//registers FTFL_FCNFG_RDCOLLIE  (UInt8_t)0x40   // Read Collision Error $interrupt Enable\n//registers FTFL_FCNFG_ERSAREQ  (UInt8_t)0x20   // Erase All Request\n//registers FTFL_FCNFG_ERSSUSP  (UInt8_t)0x10   // Erase Suspend\n//registers FTFL_FCNFG_PFLSH  (UInt8_t)0x04   // Flash memory configuration\n//registers FTFL_FCNFG_RAMRDY  (UInt8_t)0x02   // RAM Ready\n//registers FTFL_FCNFG_EEERDY  (UInt8_t)0x01   // EEPROM Ready\n//registers FTFL_FSEC  *(const    $u8_t  *)0x40020002      // Flash Security Register\n//registers FTFL_FOPT  *(const    $u8_t  *)0x40020003      // Flash Option Register\n//registers FTFL_FCCOB3  *(volatile $u8_t  *)0x40020004      // Flash Common Command Object Registers\n//registers FTFL_FCCOB2  *(volatile $u8_t  *)0x40020005\n//registers FTFL_FCCOB1  *(volatile $u8_t  *)0x40020006\n//registers FTFL_FCCOB0  *(volatile $u8_t  *)0x40020007\n//registers FTFL_FCCOB7  *(volatile $u8_t  *)0x40020008\n//registers FTFL_FCCOB6  *(volatile $u8_t  *)0x40020009\n//registers FTFL_FCCOB5  *(volatile $u8_t  *)0x4002000A\n//registers FTFL_FCCOB4  *(volatile $u8_t  *)0x4002000B\n//registers FTFL_FCCOBB  *(volatile $u8_t  *)0x4002000C\n//registers FTFL_FCCOBA  *(volatile $u8_t  *)0x4002000D\n//registers FTFL_FCCOB9  *(volatile $u8_t  *)0x4002000E\n//registers FTFL_FCCOB8  *(volatile $u8_t  *)0x4002000F\n//registers FTFL_FPROT3  *(volatile $u8_t  *)0x40020010      // Program Flash Protection Registers\n//registers FTFL_FPROT2  *(volatile $u8_t  *)0x40020011      // Program Flash Protection Registers\n//registers FTFL_FPROT1  *(volatile $u8_t  *)0x40020012      // Program Flash Protection Registers\n//registers FTFL_FPROT0  *(volatile $u8_t  *)0x40020013      // Program Flash Protection Registers\n//registers FTFL_FEPROT  *(volatile $u8_t  *)0x40020016      // EEPROM Protection Register\n//registers FTFL_FDPROT  *(volatile $u8_t  *)0x40020017      // Data Flash Protection Register\n\n// Chapter 30: Cyclic Redundancy Check (CRC)\nregisters CRC @at 0x4003_2000 {\n  CRC   @offset 0x00 $u32 // CRC Data register\n  GPOLY @offset 0x04 $u32 // CRC Polynomial register\n  CTRL  @offset 0x08 $u32 // CRC Control register\n}\n\n// Chapter 31: Analog-to-Digital Converter (ADC)\nlet ADC_SC1_COCO $u32 = 0x80   // Conversion complete flag\nlet ADC_SC1_AIEN $u32 = 0x40   // $interrupt enable\nlet ADC_SC1_DIFF $u32 = 0x20   // Differential mode enable\n\nlet ADC_CFG1_ADLPC $u32 = 0x80   // Low-power configuration\nlet ADC_CFG1_ADLSMP $u32 = 0x10   // Sample time configuration 0$u32 =Short 1=Long\n\nlet ADC_CFG2_MUXSEL  $u32 = 0x10   // 0=a channels 1=b channels\nlet ADC_CFG2_ADACKEN $u32 = 0x08   // async clock enable\nlet ADC_CFG2_ADHSC   $u32 = 0x04   // High speed configuration\n\nlet ADC_SC2_ADACT $u32 = 0x80   // Conversion active\nlet ADC_SC2_ADTRG $u32 = 0x40   // Conversion trigger select 0=software 1=hardware\nlet ADC_SC2_ACFE  $u32 = 0x20   // Compare function enable\nlet ADC_SC2_ACFGT $u32 = 0x10   // Compare function greater than enable\nlet ADC_SC2_ACREN $u32 = 0x08   // Compare function range enable\nlet ADC_SC2_DMAEN $u32 = 0x04   // DMA enable\n\nlet ADC_SC3_CAL  $u32 = 0x80   // Calibration 1=begin stays set while cal in progress\nlet ADC_SC3_CALF $u32 = 0x40   // Calibration failed flag\nlet ADC_SC3_ADCO $u32 = 0x08   // Continuous conversion enable\nlet ADC_SC3_AVGE $u32 = 0x04   // Hardware average enable\n\nlet ADC0_PGA_PGAEN $u32 = 0x00800000  // Enable\nlet ADC0_PGA_PGALPB $u32 = 0x00100000  // Low-Power Mode Control 0=low power 1=normal\n\nregisters ADC0 @at 0x4003_B000 {\n  SC1A   @offset 0x00 $u32 // ADC status and control registers 1\n  SC1B   @offset 0x04 $u32 // ADC status and control registers 1\n  CFG1   @offset 0x08 $u32 // ADC configuration registers 1\n  CFG2  @offset 0x0C $u32 // Configuration registers 2\n  RA    @offset 0x10 $u32 // ADC data result register\n  RB    @offset 0x14 $u32 // ADC data result register\n  CV1   @offset 0x18 $u32 // Compare value registers\n  CV2   @offset 0x1C $u32 // Compare value registers\n  SC2   @offset 0x20 $u32 // Status and control registers 2\n  SC3   @offset 0x24 $u32 // Status and control registers 3\n  OFS   @offset 0x28 $u32 // ADC offset correction register\n  PG    @offset 0x2C $u32 // ADC plus-side gain register\n  MG    @offset 0x30 $u32 // ADC minus-side gain register\n  CLPD  @offset 0x34 $u32 // ADC plus-side general calibration value register\n  CLPS  @offset 0x38 $u32 // ADC plus-side general calibration value register\n  CLP4  @offset 0x3C $u32 // ADC plus-side general calibration value register\n  CLP3  @offset 0x40 $u32 // ADC plus-side general calibration value register\n  CLP2  @offset 0x44 $u32 // ADC plus-side general calibration value register\n  CLP1  @offset 0x48 $u32 // ADC plus-side general calibration value register\n  CLP0  @offset 0x4C $u32 // ADC plus-side general calibration value register\n  PGA   @offset 0x50 $u32 // ADC Programmable Gain Amplifier\n  CLMD   @offset 0x54 $u32 // ADC minus-side general calibration value register\n  CLMS   @offset 0x58 $u32 // ADC minus-side general calibration value register\n  CLM4   @offset 0x5C $u32 // ADC minus-side general calibration value register\n  CLM3   @offset 0x60 $u32 // ADC minus-side general calibration value register\n  CLM2   @offset 0x64 $u32 // ADC minus-side general calibration value register\n  CLM1   @offset 0x68 $u32 // ADC minus-side general calibration value register\n  CLM0   @offset 0x6C $u32 // ADC minus-side general calibration value register\n}\n\nregisters ADC1 @at 0x400B_B000 {\n  SC1A   @offset 0x00 $u32 // ADC status and control registers 1\n  SC1B   @offset 0x04 $u32 // ADC status and control registers 1\n  CFG1   @offset 0x08 $u32 // ADC configuration registers 1\n  CFG2   @offset 0x0C $u32 // Configuration registers 2\n  RA     @offset 0x10 $u32 // ADC data result register\n  RB     @offset 0x14 $u32 // ADC data result register\n  CV1    @offset 0x18 $u32 // Compare value registers\n  CV2    @offset 0x1C $u32 // Compare value registers\n  SC2    @offset 0x20 $u32 // Status and control registers 2\n  SC3    @offset 0x24 $u32 // Status and control registers 3\n  OFS    @offset 0x28 $u32 // ADC offset correction register\n  PG     @offset 0x2C $u32 // ADC plus-side gain register\n  MG     @offset 0x30 $u32 // ADC minus-side gain register\n  CLPD   @offset 0x34 $u32 // ADC plus-side general calibration value register\n  CLPS   @offset 0x38 $u32 // ADC plus-side general calibration value register\n  CLP4   @offset 0x3C $u32 // ADC plus-side general calibration value register\n  CLP3   @offset 0x40 $u32 // ADC plus-side general calibration value register\n  CLP2   @offset 0x44 $u32 // ADC plus-side general calibration value register\n  CLP1   @offset 0x48 $u32 // ADC plus-side general calibration value register\n  CLP0   @offset 0x4C $u32 // ADC plus-side general calibration value register\n  PGA    @offset 0x50 $u32 // ADC Programmable Gain Amplifier\n  CLMD   @offset 0x54 $u32 // ADC minus-side general calibration value register\n  CLMS   @offset 0x58 $u32 // ADC minus-side general calibration value register\n  CLM4   @offset 0x5C $u32 // ADC minus-side general calibration value register\n  CLM3   @offset 0x60 $u32 // ADC minus-side general calibration value register\n  CLM2   @offset 0x64 $u32 // ADC minus-side general calibration value register\n  CLM1   @offset 0x68 $u32 // ADC minus-side general calibration value register\n  CLM0   @offset 0x6C $u32 // ADC minus-side general calibration value register\n}\n\nlet DAC_C1_DMAEN $u8 = 0x80    // DMA Enable Select\nlet DAC_C1_DACBFEN $u8 = 0x00    // DAC Buffer Enable\n\nlet DAC_C0_DACEN  $u8 = 0x80    // DAC Enable\nlet DAC_C0_DACRFS $u8 = 0x40    // DAC Reference Select\nlet DAC_C0_DACTRGSEL $u8 = 0x20    // DAC Trigger Select\nlet DAC_C0_DACSWTRG  $u8 = 0x10    // DAC Software Trigger\nlet DAC_C0_LPEN      $u8 = 0x08    // DAC Low Power Control\nlet DAC_C0_DACBWIEN  $u8 = 0x04    // DAC Buffer Watermark $interrupt Enable\nlet DAC_C0_DACBTIEN  $u8 = 0x02    // DAC Buffer Read Pointer Top Flag $interrupt Enable\nlet DAC_C0_DACBBIEN  $u8 = 0x01    // DAC Buffer Read Pointer Bottom Flag $interrupt Enable\n\nregisters DAC0 @at 0x400C_C000 {\n  DAT0L @offset 0x00 $u8 // DAC Data Low registers\n  DATH  @offset 0x01 $u8 // DAC Data High registers\n  DAT1L @offset 0x02 $u8 // DAC Data Low registers\n  DAT2L @offset 0x04 $u8 // DAC Data Low registers\n  DAT3L @offset 0x06 $u8 // DAC Data Low registers\n  DAT4L @offset 0x08 $u8 // DAC Data Low registers\n  DAT5L @offset 0x0A $u8 // DAC Data Low registers\n  DAT6L @offset 0x0C $u8 // DAC Data Low registers\n  DAT7L @offset 0x0E $u8 // DAC Data Low registers\n  DAT8L @offset 0x10 $u8 // DAC Data Low registers\n  DAT9L @offset 0x12 $u8 // DAC Data Low registers\n  DAT10L @offset 0x14 $u8 // DAC Data Low registers\n  DAT11L @offset 0x16 $u8 // DAC Data Low registers\n  DAT12L @offset 0x18 $u8 // DAC Data Low registers\n  DAT13L @offset 0x1A $u8 // DAC Data Low registers\n  DAT14L @offset 0x1C $u8 // DAC Data Low registers\n  DAT15L @offset 0x1E $u8 // DAC Data Low registers\n  SR     @offset 0x20 $u8 // DAC Status registers\n  C0     @offset 0x21 $u8 // DAC Control registers\n  C1  @offset 0x22 $u8 // DAC Control registers 1\n  C2  @offset 0x23 $u8 // DAC Control registers 2\n}\n//// Chapter 32: Comparator (CMP)\nregisters CMP0 @at 0x4007_3000 {\n  CR0   @offset 0x00 $u8 // CMP Control registers 0\n  CR1   @offset 0x01 $u8 // CMP Control registers 1\n  FPR   @offset 0x02 $u8 // CMP Filter Period Register\n  SCR   @offset 0x03 $u8 // CMP Status and Control Register\n  DACCR @offset 0x04 $u8 // DAC Control Register\n  MUXCR @offset 0x05 $u8 // MUX Control Register\n}\n\nregisters CMP1 @at 0x4007_3000 {\n  CR0   @offset 0x08 $u8 // CMP Control registers 0\n  CR1   @offset 0x09 $u8 // CMP Control registers 1\n  FPR   @offset 0x0A $u8 // CMP Filter Period Register\n  SCR   @offset 0x0B $u8 // CMP Status and Control Register\n  DACCR @offset 0x0C $u8 // DAC Control Register\n  MUXCR @offset 0x0D $u8 // MUX Control Register\n}\n\n//// Chapter 33: Voltage Reference (VREFV1)\nregisters VREF @at 0x4007_4000 {\n  TRM  @offset 0x00 $u8 // VREF Trim Register\n  SC   @offset 0x01 $u8 // VREF Status and Control Register\n}\n\n// Chapter 34: Programmable Delay Block (PDB)\n//registers PDB0_SC    0x40036000 // Status and Control Register\n//registers PDB_SC_LDMOD(n)   (((n) & 3) << 18) // Load Mode Select\n//registers PDB_SC_PDBEIE   0x00020000  // Sequence Error $interrupt Enable\n//registers PDB_SC_SWTRIG   0x00010000  // Software Trigger\n//registers PDB_SC_DMAEN   0x00008000  // DMA Enable\n//registers PDB_SC_PRESCALER(n)  (((n) & 7) << 12) // Prescaler Divider Select\n//registers PDB_SC_TRGSEL(n)  (((n) & 15) << 8) // Trigger Input Source Select\n//registers PDB_SC_PDBEN   0x00000080  // PDB Enable\n//registers PDB_SC_PDBIF   0x00000040  // PDB $interrupt Flag\n//registers PDB_SC_PDBIE   0x00000020  // PDB $interrupt Enable.\n//registers PDB_SC_MULT(n)   (((n) & 3) << 2) // Multiplication Factor\n//registers PDB_SC_CONT   0x00000002  // Continuous Mode Enable\n//registers PDB_SC_LDOK   0x00000001  // Load OK\n//registers PDB0_MOD   0x40036004 // Modulus Register\n//registers PDB0_CNT   0x40036008 // Counter Register\n//registers PDB0_IDLY   0x4003600C // $interrupt Delay Register\n//registers PDB0_CH0C1   0x40036010 // Channel n Control registers 1\n//registers PDB0_CH0S   0x40036014 // Channel n Status Register\n//registers PDB0_CH0DLY0   0x40036018 // Channel n Delay 0 Register\n//registers PDB0_CH0DLY1   0x4003601C // Channel n Delay 1 Register\n//registers PDB0_POEN   0x40036190 // Pulse-Out n Enable Register\n//registers PDB0_PO0DLY   0x40036194 // Pulse-Out n Delay Register\n//registers PDB0_PO1DLY   0x40036198 // Pulse-Out n Delay Register\n//\n//// Chapter 35: FlexTimer Module (FTM)\n//registers FTM0_SC    0x40038000 // Status And Control\n//registers FTM_SC_TOF   0x80    // Timer Overflow Flag\n//registers FTM_SC_TOIE   0x40    // Timer Overflow $interrupt Enable\n//registers FTM_SC_CPWMS   0x20    // Center-Aligned PWM Select\n//registers FTM_SC_CLKS(n)   (((n) & 3) << 3)  // Clock Source Selection\n//registers FTM_SC_PS(n)   (((n) & 7) << 0)  // Prescale Factor Selection\n//registers FTM0_CNT   0x40038004 // Counter\n//registers FTM0_MOD   0x40038008 // Modulo\n//registers FTM0_C0SC   0x4003800C // Channel 0 Status And Control\n//registers FTM0_C0V   0x40038010 // Channel 0 Value\n//registers FTM0_C1SC   0x40038014 // Channel 1 Status And Control\n//registers FTM0_C1V   0x40038018 // Channel 1 Value\n//registers FTM0_C2SC   0x4003801C // Channel 2 Status And Control\n//registers FTM0_C2V   0x40038020 // Channel 2 Value\n//registers FTM0_C3SC   0x40038024 // Channel 3 Status And Control\n//registers FTM0_C3V   0x40038028 // Channel 3 Value\n//registers FTM0_C4SC   0x4003802C // Channel 4 Status And Control\n//registers FTM0_C4V   0x40038030 // Channel 4 Value\n//registers FTM0_C5SC   0x40038034 // Channel 5 Status And Control\n//registers FTM0_C5V   0x40038038 // Channel 5 Value\n//registers FTM0_C6SC   0x4003803C // Channel 6 Status And Control\n//registers FTM0_C6V   0x40038040 // Channel 6 Value\n//registers FTM0_C7SC   0x40038044 // Channel 7 Status And Control\n//registers FTM0_C7V   0x40038048 // Channel 7 Value\n//registers FTM0_CNTIN   0x4003804C // Counter Initial Value\n//registers FTM0_STATUS   0x40038050 // Capture And Compare Status\n//registers FTM0_MODE   0x40038054 // Features Mode Selection\n//registers FTM_MODE_FAULTIE  0x80    // Fault $interrupt Enable\n//registers FTM_MODE_FAULTM(n)  (((n) & 3) << 5)  // Fault Control Mode\n//registers FTM_MODE_CAPTEST  0x10    // Capture Test Mode Enable\n//registers FTM_MODE_PWMSYNC  0x08    // PWM Synchronization Mode\n//registers FTM_MODE_WPDIS   0x04    // Write Protection Disable\n//registers FTM_MODE_INIT   0x02    // Initialize The Channels Output\n//registers FTM_MODE_FTMEN   0x01    // FTM Enable\n//registers FTM0_SYNC   0x40038058 // Synchronization\n//registers FTM_SYNC_SWSYNC   0x80    //\n//registers FTM_SYNC_TRIG2   0x40    //\n//registers FTM_SYNC_TRIG1   0x20    //\n//registers FTM_SYNC_TRIG0   0x10    //\n//registers FTM_SYNC_SYNCHOM  0x08    //\n//registers FTM_SYNC_REINIT   0x04    //\n//registers FTM_SYNC_CNTMAX   0x02    //\n//registers FTM_SYNC_CNTMIN   0x01    //\n//registers FTM0_OUTINIT   0x4003805C // Initial State For Channels Output\n//registers FTM0_OUTMASK   0x40038060 // Output Mask\n//registers FTM0_COMBINE   0x40038064 // Function For Linked Channels\n//registers FTM0_DEADTIME   0x40038068 // Deadtime Insertion Control\n//registers FTM0_EXTTRIG   0x4003806C // FTM External Trigger\n//registers FTM0_POL   0x40038070 // Channels Polarity\n//registers FTM0_FMS   0x40038074 // Fault Mode Status\n//registers FTM0_FILTER   0x40038078 // Input Capture Filter Control\n//registers FTM0_FLTCTRL   0x4003807C // Fault Control\n//registers FTM0_QDCTRL   0x40038080 // Quadrature Decoder Control And Status\n//registers FTM0_CONF   0x40038084 // Configuration\n//registers FTM0_FLTPOL   0x40038088 // FTM Fault Input Polarity\n//registers FTM0_SYNCONF   0x4003808C // Synchronization Configuration\n//registers FTM0_INVCTRL   0x40038090 // FTM Inverting Control\n//registers FTM0_SWOCTRL   0x40038094 // FTM Software Output Control\n//registers FTM0_PWMLOAD   0x40038098 // FTM PWM Load\n//registers FTM1_SC    0x40039000 // Status And Control\n//registers FTM1_CNT   0x40039004 // Counter\n//registers FTM1_MOD   0x40039008 // Modulo\n//registers FTM1_C0SC   0x4003900C // Channel 0 Status And Control\n//registers FTM1_C0V   0x40039010 // Channel 0 Value\n//registers FTM1_C1SC   0x40039014 // Channel 1 Status And Control\n//registers FTM1_C1V   0x40039018 // Channel 1 Value\n//registers FTM1_CNTIN   0x4003904C // Counter Initial Value\n//registers FTM1_STATUS   0x40039050 // Capture And Compare Status\n//registers FTM1_MODE   0x40039054 // Features Mode Selection\n//registers FTM1_SYNC   0x40039058 // Synchronization\n//registers FTM1_OUTINIT   0x4003905C // Initial State For Channels Output\n//registers FTM1_OUTMASK   0x40039060 // Output Mask\n//registers FTM1_COMBINE   0x40039064 // Function For Linked Channels\n//registers FTM1_DEADTIME   0x40039068 // Deadtime Insertion Control\n//registers FTM1_EXTTRIG   0x4003906C // FTM External Trigger\n//registers FTM1_POL   0x40039070 // Channels Polarity\n//registers FTM1_FMS   0x40039074 // Fault Mode Status\n//registers FTM1_FILTER   0x40039078 // Input Capture Filter Control\n//registers FTM1_FLTCTRL   0x4003907C // Fault Control\n//registers FTM1_QDCTRL   0x40039080 // Quadrature Decoder Control And Status\n//registers FTM1_CONF   0x40039084 // Configuration\n//registers FTM1_FLTPOL   0x40039088 // FTM Fault Input Polarity\n//registers FTM1_SYNCONF   0x4003908C // Synchronization Configuration\n//registers FTM1_INVCTRL   0x40039090 // FTM Inverting Control\n//registers FTM1_SWOCTRL   0x40039094 // FTM Software Output Control\n//registers FTM1_PWMLOAD   0x40039098 // FTM PWM Load\n//registers FTM2_SC    0x400B8000 // Status And Control\n//registers FTM2_CNT   0x400B8004 // Counter\n//registers FTM2_MOD   0x400B8008 // Modulo\n//registers FTM2_C0SC   0x400B800C // Channel 0 Status And Control\n//registers FTM2_C0V   0x400B8010 // Channel 0 Value\n//registers FTM2_C1SC   0x400B8014 // Channel 1 Status And Control\n//registers FTM2_C1V   0x400B8018 // Channel 1 Value\n//registers FTM2_CNTIN   0x400B804C // Counter Initial Value\n//registers FTM2_STATUS   0x400B8050 // Capture And Compare Status\n//registers FTM2_MODE   0x400B8054 // Features Mode Selection\n//registers FTM2_SYNC   0x400B8058 // Synchronization\n//registers FTM2_OUTINIT   0x400B805C // Initial State For Channels Output\n//registers FTM2_OUTMASK   0x400B8060 // Output Mask\n//registers FTM2_COMBINE   0x400B8064 // Function For Linked Channels\n//registers FTM2_DEADTIME   0x400B8068 // Deadtime Insertion Control\n//registers FTM2_EXTTRIG   0x400B806C // FTM External Trigger\n//registers FTM2_POL   0x400B8070 // Channels Polarity\n//registers FTM2_FMS   0x400B8074 // Fault Mode Status\n//registers FTM2_FILTER   0x400B8078 // Input Capture Filter Control\n//registers FTM2_FLTCTRL   0x400B807C // Fault Control\n//registers FTM2_QDCTRL   0x400B8080 // Quadrature Decoder Control And Status\n//registers FTM2_CONF   0x400B8084 // Configuration\n//registers FTM2_FLTPOL   0x400B8088 // FTM Fault Input Polarity\n//registers FTM2_SYNCONF   0x400B808C // Synchronization Configuration\n//registers FTM2_INVCTRL   0x400B8090 // FTM Inverting Control\n//registers FTM2_SWOCTRL   0x400B8094 // FTM Software Output Control\n//registers FTM2_PWMLOAD   0x400B8098 // FTM PWM Load\n\n\n// Chapter 36: Periodic $interrupt Timer (PIT)\n\n// PIT Module Control Register\nlet PIT_COUNT = 4\n\nregisters PIT @at 0x4003_7000 {\n  MCR @offset 0x00 $u32 {\n    30 MDIS FRZ\n  }\n\n  // Timer Load Value Register\n  LDVAL [PIT_COUNT @offset 0x100 @inc 16] $u32\n\n  // Current Timer Value Register\n  LCVAL [PIT_COUNT @offset 0x104 @inc 16] $u32\n\n  // Timer Control Register\n  TCTRL [PIT_COUNT @offset 0x108 @inc 16] $u32 {\n    29 CHN TIE TEN\n  }\n\n  // Timer Flag Register\n  TFLG [PIT_COUNT @offset 0x10C @inc 16] $u32 {\n    31 TIF\n  }\n}\n\n//\n//// Chapter 37: Low-Power Timer (LPTMR)\n//registers LPTMR0_CSR   0x40040000 // Low Power Timer Control Status Register\n//registers LPTMR0_PSR   0x40040004 // Low Power Timer Prescale Register\n//registers LPTMR0_CMR   0x40040008 // Low Power Timer Compare Register\n//registers LPTMR0_CNR   0x4004000C // Low Power Timer Counter Register\n//\n//// Chapter 38: Carrier Modulator Transmitter (CMT)\n//registers CMT_CGH1  *(volatile $u8_t  *)0x40062000 // CMT Carrier Generator High Data registers 1\n//registers CMT_CGL1  *(volatile $u8_t  *)0x40062001 // CMT Carrier Generator Low Data registers 1\n//registers CMT_CGH2  *(volatile $u8_t  *)0x40062002 // CMT Carrier Generator High Data registers 2\n//registers CMT_CGL2  *(volatile $u8_t  *)0x40062003 // CMT Carrier Generator Low Data registers 2\n//registers CMT_OC   *(volatile $u8_t  *)0x40062004 // CMT Output Control Register\n//registers CMT_MSC   *(volatile $u8_t  *)0x40062005 // CMT Modulator Status and Control Register\n//registers CMT_CMD1  *(volatile $u8_t  *)0x40062006 // CMT Modulator Data registers Mark High\n//registers CMT_CMD2  *(volatile $u8_t  *)0x40062007 // CMT Modulator Data registers Mark Low\n//registers CMT_CMD3  *(volatile $u8_t  *)0x40062008 // CMT Modulator Data registers Space High\n//registers CMT_CMD4  *(volatile $u8_t  *)0x40062009 // CMT Modulator Data registers Space Low\n//registers CMT_PPS   *(volatile $u8_t  *)0x4006200A // CMT Primary Prescaler Register\n//registers CMT_DMA   *(volatile $u8_t  *)0x4006200B // CMT Direct Memory Access Register\n//\n//// Chapter 39: Real Time Clock (RTC)\nlet RTC_SR_TCE $u32 = 0x00000010\nlet RTC_SR_TAF $u32 = 0x00000004  //\nlet RTC_SR_TOF $u32 = 0x00000002  //\nlet RTC_SR_TIF $u32 = 0x00000001  //\n\nregisters RTC @at 0x4003_D000 {\n  TSR  @offset 0x000 $u32 // RTC Time Seconds Register\n  TPR  @offset 0x004 $u32 // RTC Time Prescaler Register\n  TAR  @offset 0x008 $u32 // RTC Time Alarm Register\n  TCR  @offset 0x00C $u32 // RTC Time Compensation Register\n  CR   @offset 0x010 $u32 {// RTC Control Register\n    18 SC2P SC4P SC8P SC16P CKLO OSCE 4 UM SUP WPE SWR\n  }\n  SR  @offset 0x014 $u32 // RTC Status Register\n  LR  @offset 0x018 $u32 // RTC Lock Register\n  IER @offset 0x01C $u32 // RTC $interrupt Enable Register\n  WAR @offset 0x800 $u32 // RTC Write Access Register\n  RAR @offset 0x804 $u32 // RTC Read Access Register\n}\n\n//\n// Chapter 40: Universal Serial Bus Full Speed OTG Controller (USBFSOTG)\n//\n\nregisters USB0 @at 0x4007_2000 {\n//--- Peripheral ID Register\n  PERID @offset 0x000 @ro $u8 {2 ID:6}\n\n//--- Peripheral ID Complement Register\n  IDCOMP @offset 0x004 @ro $u8 {2 NID:6}\n\n//--- Peripheral Revision Register\n  REV @offset 0x008 @ro $u8\n\n//--- Peripheral Additional Info Register\n  ADDINFO @offset 0x00C @ro $u8 {IRQNUM:5 2 IEHOST}\n\n//--- OTG $interrupt Status Register\n  OTGISTAT @offset 0x010 $u8 {IDCHG ONEMSEC LINE_STAT_CHG 1 SESSVLDCHG B_SESS_CHG 1 AVBUSHG}\n\n//--- OTG $interrupt Control Register\n  OTGICR @offset 0x014 $u8 {IDEN ONEMSECEN LINESTATEEN 1 SESSVLDEN BSESSEN 1 AVBUSEN}\n\n//--- OTG Status Register\n  OTGSTAT @offset 0x018 $u8 {ID ONEMSECEN LINESTATESTABLE 1 SESS_VLD BSESSEND 1 AVBUSVLD}\n\n//--- OTG Control Register\n  OTGCTL @offset 0x01C $u8 {DPHIGH 1 DPLOW DMLOW 1 OTGEN 2}\n\n//--- $interrupt Status Register\n  ISTAT @offset 0x080 $u8 {STALL ATTACH RESUME SLEEP TOKDNE SOFTOK ERROR USBRST}\n\n//--- $interrupt Enable Register\n  INTEN @offset 0x084 $u8 {STALLEN ATTACHEN RESUMEEN SLEEPEN TOKDNEEN SOFTOKEN ERROREN USBRSTEN}\n\n//--- $interrupt Error Register\n  ERRSTAT @offset 0x088 $u8 {BSTERR 1 DMAERR BTOERR DFN8 CRC16 CRC5EOF PIDERR}\n\n//--- Error $interrupt Enable Register\n  ERREN @offset 0x08C $u8 {BSTERREN 1 DMAERREN BTOERREN DFN8EN CRC16EN CRC5EOFEN PIDERREN}\n\n//--- Status Register\n  STAT @offset 0x090 $u8 {ENDP:4 TX ODD 2}\n\n//--- Control Register\n  CTL @offset 0x094 $u8 {JSTATE SE0 TXSUSPENDTOKENBUSY RESET HOSTMODEEN RESUME ODDRST USBENOFEN}\n\n//--- Address Register\n  ADDR @offset 0x098 $u8 {LSEN ADDR:7}\n\n//--- BDT Page Register 1\n  BDTPAGE1 @offset 0x09C $u8 {BDTBA:7 1}\n\n//--- Frame Number Register Low\n  FRMNUML @offset 0x0A0 $u8\n\n//--- Frame Number Register High\n  FRMNUMH @offset 0x0A4 $u8 {5 FRM:3}\n\n//--- Token Register\n  TOKEN @offset 0x0A8 $u8 {TOKENPID:4 TOKENDPT:4}\n\n//--- SOF Threshold Register\n  SOFTHLD @offset 0x0AC $u8\n\n//--- BDT Page Register 2\n  BDTPAGE2 @offset 0x0B0 $u8\n\n//--- BDT Page Register 3\n  BDTPAGE3 @offset 0x0B4 $u8\n\n//--- Endpoint Control\n  ENDPT [16 @offset 0x0C0 @inc 4] $u8 {HOSTWCHUB RETRYDIS 1 EPCTLDIS EPRXEN EPTXEN EPSTALL EPHSHK}\n\n//--- USB Control Register\n  USBCTRL @offset 0x100 $u8 {SUSP PDE 6}\n\n//--- USB OTG Observe Register\n  OBSERVE @offset 0x104 @ro $u8 {DPPU DPPD 1 DMPD 4}\n\n//--- USB OTG Control Register\n  CONTROL @offset 0x108 $u8 {3 DPPULLNONOTG 4}\n\n//--- USB Transceiver Control Register 0\n  USBTRC0 @offset 0x10C $u8 {USBRESET 1 USBRESMEM 3 SYNC_DET USB_RESUME_INT}\n\n//--- Frame Adjust Register\n  USBFRMADJUST @offset 0x114 $u8\n}\n\n\n//\n// Chapter 47: General-Purpose Input/Output (GPIO)\n//\n\nregisters GPIOA @at 0x400F_F000 {\n  PDOR @offset 0x00 $u32 // Port Data Output Register\n  PSOR @offset 0x04 $u32 // Port Set Output Register\n  PCOR @offset 0x08 $u32 // Port Clear Output Register\n  PTOR @offset 0x0C $u32 // Port Toggle Output Register\n  PDIR @offset 0x10 $u32 // Port Data Input Register\n  PDDR @offset 0x14 $u32 // Port Data Direction Register\n}\n\nregisters GPIOB @at 0x400F_F040 {\n  PDOR @offset 0x00 $u32 // Port Data Output Register\n  PSOR @offset 0x04 $u32 // Port Set Output Register\n  PCOR @offset 0x08 $u32 // Port Clear Output Register\n  PTOR @offset 0x0C $u32 // Port Toggle Output Register\n  PDIR @offset 0x10 $u32 // Port Data Input Register\n  PDDR @offset 0x14 $u32 // Port Data Direction Register\n}\n\nregisters GPIOC @at 0x400F_F080 {\n  PDOR @offset 0x00 $u32 // Port Data Output Register\n  PSOR @offset 0x04 $u32 // Port Set Output Register\n  PCOR @offset 0x08 $u32 // Port Clear Output Register\n  PTOR @offset 0x0C $u32 // Port Toggle Output Register\n  PDIR @offset 0x10 $u32 // Port Data Input Register\n  PDDR @offset 0x14 $u32 // Port Data Direction Register\n}\n\nregisters GPIOD @at 0x400F_F0C0 {\n  PDOR @offset 0x00 $u32 // Port Data Output Register\n  PSOR @offset 0x04 $u32 // Port Set Output Register\n  PCOR @offset 0x08 $u32 // Port Clear Output Register\n  PTOR @offset 0x0C $u32 // Port Toggle Output Register\n  PDIR @offset 0x10 $u32 // Port Data Input Register\n  PDDR @offset 0x14 $u32 // Port Data Direction Register\n}\n\n//// Chapter 48: Touch sense input (TSI)\n//registers TSI0_GENCS   0x40045000 // General Control and Status Register\n//registers TSI_GENCS_LPCLKS   0x10000000  //\n//registers TSI_GENCS_LPSCNITV(n)  (((n) & 15) << 24)  //\n//registers TSI_GENCS_NSCN(n)  (((n) & 31) << 19)  //\n//registers TSI_GENCS_PS(n)   (((n) & 7) << 16)  //\n//registers TSI_GENCS_EOSF    0x00008000  //\n//registers TSI_GENCS_OUTRGF   0x00004000  //\n//registers TSI_GENCS_EXTERF   0x00002000  //\n//registers TSI_GENCS_OVRF    0x00001000  //\n//registers TSI_GENCS_SCNIP    0x00000200  //\n//registers TSI_GENCS_SWTS    0x00000100  //\n//registers TSI_GENCS_TSIEN    0x00000080  //\n//registers TSI_GENCS_TSIIE    0x00000040  //\n//registers TSI_GENCS_ERIE    0x00000020  //\n//registers TSI_GENCS_ESOR    0x00000010  //\n//registers TSI_GENCS_STM    0x00000002  //\n//registers TSI_GENCS_STPE    0x00000001  //\n//registers TSI0_SCANC   0x40045004 // SCAN Control Register\n//registers TSI_SCANC_REFCHRG(n)  (((n) & 15) << 24)  //\n//registers TSI_SCANC_EXTCHRG(n)  (((n) & 7) << 16)  //\n//registers TSI_SCANC_SMOD(n)  (((n) & 255) << 8)  //\n//registers TSI_SCANC_AMCLKS(n)  (((n) & 3) << 3)  //\n//registers TSI_SCANC_AMPSC(n)  (((n) & 7) << 0)  //\n//registers TSI0_PEN   0x40045008 // Pin Enable Register\n//registers TSI0_WUCNTR   0x4004500C // Wake-Up Channel Counter Register\n//registers TSI0_CNTR1   0x40045100 // Counter Register\n//registers TSI0_CNTR3   0x40045104 // Counter Register\n//registers TSI0_CNTR5   0x40045108 // Counter Register\n//registers TSI0_CNTR7   0x4004510C // Counter Register\n//registers TSI0_CNTR9   0x40045110 // Counter Register\n//registers TSI0_CNTR11   0x40045114 // Counter Register\n//registers TSI0_CNTR13   0x40045118 // Counter Register\n//registers TSI0_CNTR15   0x4004511C // Counter Register\n//registers TSI0_THRESHOLD   0x40045120 // Low Power Channel Threshold Register\n//\n// Nested Vectored $interrupt Controller Table 3-4 & ARMv7 ref appendix B3.4 (page 750)\n\n//registers NVIC @at 0xE000_E000 {\n//  ISER [4 @offset  0x100 @inc 4] $u32 // $interrupt Set-enable Registers\n//  ICER [4 @offset  0x180 @inc 4] $u32 //Interrupt Clear-enable Registers\n//  IPR [128 @offset 0x400 @inc 1] $u8 // $interrupt priority\n//\n//  ICSR @offset 0xD04 $u32 { // $interrupt Control and State\n//    NMIPENDSET 2 PENDSVSET PENDSVCLR PENDSTSET PENDSTCLR 1 ISRPREEMPT\n//    ISRPENDING 1 VECTPENDING:9 RETTOBASE 2 VECTACTIVE:9\n//  }\n//\n//  VTOR @offset 0xD08 $u32 // Vector Table Offset\n//\n//  AIRCR @offset 0xD0C $u32 { // Application $interrupt and Reset Control\n//    VECTKEY:16 ENDIANNESS 4 PRIGROUP:3\n//    5 SYSRESETREQ VECTCLRACTIVE VECTRESET\n//  }\n//}\n\n//registers SCB_SCR    0xE000ED10 // System Control Register\n//registers SCB_CCR    0xE000ED14 // Configuration and Control\n//registers SCB_SHPR1   0xE000ED18 // System Handler Priority registers 1\n//registers SCB_SHPR2   0xE000ED1C // System Handler Priority registers 2\n//registers SCB_SHPR3   0xE000ED20 // System Handler Priority registers 3\n//registers SCB_SHCSR   0xE000ED24 // System Handler Control and State\n//registers SCB_CFSR   0xE000ED28 // Configurable Fault Status Register\n//registers SCB_HFSR   0xE000ED2C // HardFault Status\n//registers SCB_DFSR   0xE000ED30 // Debug Fault Status\n//registers SCB_MMFAR   0xE000ED34 // MemManage Fault Address\n\n//--- SYSTICK\n//registers SYST @at 0xE000_E000 {\n//  CSR @offset 0x10 $u32 { // SysTick Control and Status\n//    15\n//    COUNTFLAG\n//    13\n//    CLKSOURCE\n//    TICKINT\n//    ENABLE\n//  }\n//  RVR   @offset 0x14 $u32 // SysTick Reload Value Register\n//  CVR   @offset 0x18 $u32 // SysTick Current Value Register\n//  CALIB  @offset 0x1C @ro $u32 // SysTick Calibration Value\n//}\nregisters AIPS0 @at 0x_4000_0000 {\n  MPRA @offset 0x00 $u32\n\n  //--- AICS0_PACR (4.5.1 and 19.2 19.2.2)\n  // SPx: Determines whether the peripheral requires supervisor privilege level\n  // for accesses. When this field is set the master privilege level must indicate\n  // the supervisor access attribute and the MPR x [MPL n ] control field for the\n  // master must be set. If not access terminates with an error response and no\n  // peripheral access initiates.\n  // 0 This peripheral does not require supervisor privilege level for accesses. \n  // 1 This peripheral requires supervisor privilege level for accesses. \n  // WPx: Determines whether the peripheral allows write accessses. When this field\n  // is set and a write access is attempted access terminates with an error\n  // response and no peripheral access initiates\n  // 0 This peripheral allows write accesses. \n  // 1 This peripheral is write protected. \n  // TPx : Determines whether the peripheral allows accesses from an untrusted master.\n  // When this bit is set and an access is attempted by an untrusted master the\n  // access terminates with an error response and no peripheral access initiates.\n  // 0 Accesses from an untrusted master are allowed. \n  // 1 Accesses from an untrusted master are not allowed. \n\n  PACRA @offset 0x20\n  PACRB @offset 0x24\n  PACRC @offset 0x28\n  PACRD @offset 0x2C\n  PACRE @offset 0x40\n  PACRF @offset 0x44\n  PACRG @offset 0x48\n  PACRH @offset 0x4C\n  PACRI @offset 0x50\n  PACRJ @offset 0x54\n  PACRK @offset 0x58\n  PACRL @offset 0x5C\n  PACRM @offset 0x60\n  PACRN @offset 0x64\n  PACRO @offset 0x68\n  PACRP @offset 0x6C\n  $u32 {\n   1 SP0 WP0 TP0\n   1 SP1 WP1 TP1\n   1 SP2 WP2 TP2\n   1 SP3 WP3 TP3\n   1 SP4 WP4 TP4\n   1 SP5 WP5 TP5\n   1 SP6 WP6 TP6\n   1 SP7 WP7 TP7\n  }\n}\n//registers ARM_DEMCR   0xE000EDFC // Debug Exception and Monitor Control\n//registers ARM_DEMCR_TRCENA  (1 << 24)  // Enable debugging & monitoring blocks\n//registers ARM_DWT_CTRL   0xE0001000 // DWT control register\n//registers ARM_DWT_CTRL_CYCCNTENA  (1 << 0)  // Enable cycle count\n//registers ARM_DWT_CYCCNT   0xE0001004 // Cycle count register\n" ;

const cRegularFileWrapper gWrapperFile_71_targetTemplates (
  "registers-mk20dx256.omnibus-import",
  "omnibus-import",
  true, // Text file
  56988, // Text length
  gWrapperFileContent_71_targetTemplates
) ;

//--- File 'teensy-3-1/s-cortex-m4-header.s'

const char * gWrapperFileContent_74_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n\n	.syntax unified\n	.cpu cortex-m4\n	.thumb\n\n" ;

const cRegularFileWrapper gWrapperFile_74_targetTemplates (
  "s-cortex-m4-header.s",
  "s",
  true, // Text file
  164, // Text length
  gWrapperFileContent_74_targetTemplates
) ;

//--- File 'teensy-3-1/teensy-3-1-lcd.omnibus-import'

const char * gWrapperFileContent_72_targetTemplates = "\nctAssert target \"teensy-3-1/unprivileged\"\n\n//\n\n// http://esd.cs.ucr.edu/labs/interface/interface.html\n\nlet LCD_BUFFER_SIZE = 20\n\n//\n\ndriver lcd > digital {\n  let DB4 $DigitalPort\n  let DB5 $DigitalPort\n  let DB6 $DigitalPort\n  let DB7 $DigitalPort\n\n  let RS $DigitalPort\n  let ENABLE $DigitalPort\n\n  var buffer = [LCD_BUFFER_SIZE : $u8] (!repeated:0)\n  var sEntree = $Semaphore (!value:0)\n  var sSortie = $Semaphore (!value:LCD_BUFFER_SIZE)\n\n  //\n\n  func configurePorts startup @noUnusedWarning () {\n    digital.set (!mode:.output !toPort:self.DB4)\n    digital.set (!mode:.output !toPort:self.DB5)\n    digital.set (!mode:.output !toPort:self.DB6)\n    digital.set (!mode:.output !toPort:self.DB7)\n    digital.set (!mode:.output !toPort:self.RS)\n    digital.set (!mode:.output !toPort:self.ENABLE)\n  }\n\n  //\n\n  func driveHighE safe @noUnusedWarning () {\n    digital.write (!yes !toPort:self.ENABLE)\n  }\n\n  //\n\n  func driveLowE safe @noUnusedWarning () {\n    digital.write (!no !toPort:self.ENABLE)\n  }\n\n  //\n\n\n  func driveHighRS safe @noUnusedWarning () {\n   digital.write (!yes !toPort:self.RS)\n  }\n\n  //\n\n  func driveLowRS safe @noUnusedWarning () {\n    digital.write (!no !toPort:self.RS)\n  }\n\n  //\n\n  func setD4 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB4)\n  }\n\n  //\n\n  func setD5 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB5)\n  }\n\n  //\n\n  func setD6 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB6)\n  }\n\n  //\n\n  func setD7 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB7)\n  }\n\n  //\n  //   UTILITY ROUTINES\n  //\n\n  func programLcd4BitDataBusOutput safe @noUnusedWarning (\?inValue $u8) {\n    self.setD4 (!(inValue & 0x01)  0)\n    self.setD5 (!(inValue & 0x02)  0)\n    self.setD6 (!(inValue & 0x04)  0)\n    self.setD7 (!(inValue & 0x08)  0)\n  }\n\n  //\n\n  func writeFirstNibbleOf8bitCommand safe @noUnusedWarning (\?inValue $u8) {\n    self.driveLowRS ()\n    self.programLcd4BitDataBusOutput (!inValue)\n    self.driveHighE ()\n  }\n\n  //\n\n  func writeFirstNibbleOf8bitData safe @noUnusedWarning (\?inValue $u8) {\n    self.driveHighRS ()\n    self.programLcd4BitDataBusOutput (!inValue)\n    self.driveHighE ()\n  }\n\n   //\n\n  func writeSecondNibble safe @noUnusedWarning (\?inValue $u8) {\n    self.programLcd4BitDataBusOutput (!inValue)\n    self.driveHighE ()\n  }\n\n  //\n\n  func write4BitCommand startup @noUnusedWarning (\?inValue $u8) {\n    time.busyWaitingDuringMS (!1)\n    self.writeFirstNibbleOf8bitCommand (!inValue)\n    time.busyWaitingDuringMS (!1)\n    self.driveLowE ()\n  }\n\n  //\n\n  func write8bitCommand startup @noUnusedWarning (\?inCommand $u8) {\n    time.busyWaitingDuringMS (!1)\n    self.writeFirstNibbleOf8bitCommand (!inCommand >> 4)\n    time.busyWaitingDuringMS (!1)\n    self.driveLowE ()\n    time.busyWaitingDuringMS (!1)\n    self.writeSecondNibble (!inCommand)\n    time.busyWaitingDuringMS (!1)\n    self.driveLowE ()\n  }\n\n  //\n  //   LCD INIT\n  //\n\n  startup {\n    self.configurePorts ()\n  //--- tape 1 : attendre 15 ms\n    time.busyWaitingDuringMS (!15)\n  //--- tape 2 : crire la commande 0x30\n    self.write4BitCommand (!0x3)\n  //--- tape 3 : attendre 4,1 ms (en fait 5 ms)\n    time.busyWaitingDuringMS (!5)\n  //--- tape 4 : crire la commande 0x30 une 2e fois\n    self.write4BitCommand (!0x3)\n  //--- tape 5 : attendre 100 s\n    time.busyWaitingDuringMS (!1)\n  //--- tape 6 : crire la commande 0x30 une 3e fois\n    self.write4BitCommand (!0x3)\n  //--- tape 7 : crire la commande 0x20 pour passer en 4 bits\n    self.write4BitCommand (!0x2)\n  //--- tape 8 : crire la commande 'Set $interface Length' : 0 0 1 DL N F * *\n  //    DL : Data interface length : 0 (4 bits)\n  //    N : Number of Display lines : 1 (2 lignes)\n  //    F : Character Font : 0 (5x7)\n    self.write8bitCommand (!0x28)\n  //--- tape 9 : crire la commande 'Display Off'\n    self.write8bitCommand (!0x08)\n  //--- tape 10 : crire la commande 'Clear Display'\n    self.write8bitCommand (!0x01)\n  //--- tape 11 : crire la commande 'Set Cursor Move Direction' : 0 0 0 0 0 1 ID S\n  //    ID : Increment Cursor after Each Byte Written to Display : 1 (oui)\n  //    S : Shift Display When Byte Written : 0 (non)\n    self.write8bitCommand (!0x06)\n  //--- tape 12 : crire la commande 'Move Cursor / Shift Display' : 0 0 0 1 SC RL * *\n  //    SC : Display Shift On : 1 (oui)\n  //    RL : Direction of Shift : 1 (vers la droite)\n    self.write8bitCommand (!0x1C)\n  //--- tape 13 : crire la commande 'Return Cursor and LCD to Home Position'\n    self.write8bitCommand (!0x02)\n  //--- tape 14 : crire la commande 'Enable Display / Cursor' : 0 0 0 0 1 D C B\n  //    D : Turn Display On : 1 (oui)\n  //    C : Turn Cursor On : 0 (non)\n  //    B : Cursor Blink On : 0 (non)\n    self.write8bitCommand (!0x0C)\n  }\n\n  //\n  //   PRINT ROUTINES IN USER MODE\n  //\n\n  func write8bitCommand_inUserMode user @noUnusedWarning (\?inCommand $u8) {\n    time.wait (!during:1)\n    self.writeFirstNibbleOf8bitCommand (!inCommand >> 4)\n    time.wait (!during:1)\n    self.driveLowE ()\n    time.wait (!during:1)\n    self.writeSecondNibble (!inCommand)\n    time.wait (!during:1)\n    self.driveLowE ()\n  }\n\n  //\n\n  func writeData_inUserMode user @noUnusedWarning (\?inData $u8) {\n    time.wait (!during:1)\n    self.writeFirstNibbleOf8bitData (!inData >> 4)\n    time.wait (!during:1)\n    self.driveLowE ()\n    time.wait (!during:1)\n    self.writeSecondNibble (!inData)\n    time.wait (!during:1)\n    self.driveLowE ()\n  }\n\n  //\n\n  public func clearScreen user @noUnusedWarning () {\n    self.write8bitCommand_inUserMode (!0x01)\n  }\n\n  //\n\n  // Line 0 : 00 -> 19\n  // Line 1 : 64 -> 83\n  // Line 2 : 20 -> 39\n  // Line 3 : 84 -> 103\n\n  public func goto user @noUnusedWarning (\?line:inLine $u2 \?column:inColumn $u8) {\n    if inColumn < 20 {\n      if inLine == 0 {\n        self.write8bitCommand_inUserMode (!0x80 + 0 + inColumn)\n      }else if inLine == 1 {\n        self.write8bitCommand_inUserMode (!0x80 + 64 + inColumn)\n      }else if inLine == 2 {\n        self.write8bitCommand_inUserMode (!0x80 + 20 + inColumn)\n      }else{\n        self.write8bitCommand_inUserMode (!0x80 + 84 + inColumn)\n      }\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?spaces:inCount $u32) {\n    var count = inCount\n    while (count > 0) {\n      self.writeData_inUserMode (!0x20)\n      count -= 1\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?u32:inValue $u32) {\n    var divisor $u32 = 1_000_000_000\n    var value = inValue\n    var isPrinting = no\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value / divisor\n        let remainder = value - quotient * divisor\n        self.writeData_inUserMode (!convert (quotient) + 0x30)\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor / 10\n    }\n    if not isPrinting {\n      self.writeData_inUserMode (!0x30)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?u32:inValue $u32 \?width: inWidth $u32) {\n    var divisor $u32 = 1_000_000_000\n    var value = inValue\n    var isPrinting = no\n    var count $u32 = 0\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value / divisor\n        let remainder = value - quotient * divisor\n        self.writeData_inUserMode (!convert (quotient) + 0x30)\n        count += 1\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor / 10\n    }\n    if not isPrinting {\n      self.writeData_inUserMode (!0x30)\n      count += 1\n    }\n    for _ $u32 in count ..< inWidth {\n      self.writeData_inUserMode (!0x20)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?u64:inValue $u64) {\n    var divisor $u64 = 1_0000__00000__00000__00000\n    var value = inValue\n    var isPrinting = no\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value / divisor\n        let remainder = value - quotient * divisor\n        self.writeData_inUserMode (!convert (quotient) + 0x30)\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor / 10\n    }\n    if not isPrinting {\n      self.writeData_inUserMode (!0x30)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?string:inValue $literalString) {\n    for c in inValue {\n      self.writeData_inUserMode (!c)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex1:inValue $u32) {\n    let v = truncate $u8 (inValue & 0xF)\n    if v < 10 {\n      self.writeData_inUserMode (!v + 0x30)\n    }else{\n      self.writeData_inUserMode (!v + 0x41 - 10)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex2:inValue $u32) {\n    self.print (!hex1:inValue >> 4)\n    self.print (!hex1:inValue)\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex4:inValue $u32) {\n    self.print (!hex2:inValue >> 8)\n    self.print (!hex2:inValue)\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex8:inValue $u32) {\n    self.print (!hex4:inValue >> 16)\n    self.print (!hex4:inValue)\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex16:inValue $u64) {\n    self.print (!hex8:truncate (inValue >> 32))\n    self.print (!hex8:truncate (inValue))\n  }\n\n  //\n  //   PANIC\n  //\n\n  func writeDataInPanicMode panic @noUnusedWarning (\?inData $u8) {\n    time.panicOneMillisecondBusyWait ()\n    self.driveHighRS ()\n    self.programLcd4BitDataBusOutput (!inData >> 4)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n    time.panicOneMillisecondBusyWait ()\n    self.programLcd4BitDataBusOutput (!inData)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n  }\n\n  //\n\n  public func printUnsignedInPanicMode panic @noUnusedWarning (\?inValue $u32) {\n    var divisor $u32 = 1_000_000_000\n    var value = inValue\n    var isPrinting = no\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value !/ divisor\n        let remainder = value -% quotient *% divisor\n        self.writeDataInPanicMode (!truncate (quotient) +% 0x30)\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor !/ 10\n    }\n    if not isPrinting {\n      self.writeDataInPanicMode (!0x30)\n    }\n  }\n\n  //\n\n  public func printSignedInPanicMode panic @noUnusedWarning (\?inValue $i32) {\n    if inValue  0 {\n      self.printUnsignedInPanicMode (!truncate (inValue))\n    }else{\n      self.writeDataInPanicMode (!0x2D) // Signe -\n      self.printUnsignedInPanicMode (!truncate (-% inValue))\n    }\n  }\n\n  //\n\n  func write8bitCommandInPanicMode panic @noUnusedWarning (\?inCommand $u8) {\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowRS ()\n    self.programLcd4BitDataBusOutput (!inCommand >> 4)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n    time.panicOneMillisecondBusyWait ()\n    self.programLcd4BitDataBusOutput (!inCommand)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n  }\n\n  //\n\n  public func gotoInPanicMode panic @noUnusedWarning (\?line:inLine $u32 \?column:inColumn $u8) {\n    if inColumn < 20 {\n      if inLine == 0 {\n        self.write8bitCommandInPanicMode (!0x80 +% 0 +% inColumn)\n      }else if inLine == 1 {\n        self.write8bitCommandInPanicMode (!0x80 +% 64 +% inColumn)\n      }else if inLine == 2 {\n        self.write8bitCommandInPanicMode (!0x80 +% 20 +% inColumn)\n      }else if inLine == 3 {\n        self.write8bitCommandInPanicMode (!0x80 +% 84 +% inColumn)\n      }\n    }\n  }\n\n  //\n\n  public func clearScreenInPanicMode panic @noUnusedWarning () {\n    self.write8bitCommandInPanicMode (!0x01)\n    time.panicBusyWaitingDuringMS (!4)\n  }\n\n  //\n\n  public func printStringInPanicMode panic @noUnusedWarning (\?inString $literalString) {\n    for c in inString {\n      self.writeDataInPanicMode (!c)\n    }\n  }\n\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_72_targetTemplates (
  "teensy-3-1-lcd.omnibus-import",
  "omnibus-import",
  true, // Text file
  15303, // Text length
  gWrapperFileContent_72_targetTemplates
) ;

//--- File 'teensy-3-1/teensy-3-1-nvic-interrupts.omnibus-import'

const char * gWrapperFileContent_59_targetTemplates = "\nsection enable safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot) {\n  let idx $u32 = extend (inInterruptCode.u7 -% 16)\n  let bitIndex = idx & 0x1F\n  let registerIndex = idx >> 5\n  NVIC.ISER [registerIndex]! = 1 << bitIndex\n}\n\n//\n\nsection disable safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot) {\n  let idx $u32 = extend (inInterruptCode.u7 -% 16)\n  let bitIndex = idx & 0x1F\n  let registerIndex = idx >> 5\n  NVIC.ICER [registerIndex]! = 1 << bitIndex\n}\n\n//\n\n// 0 = highest priority\n// Cortex-M4: 0,16,32,48,64,80,96,112,128,144,160,176,192,208,224,240\nsection set safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot \?priority:inPriority $u8) {\n  NVIC.IPR [inInterruptCode.u7]! = inPriority\n}\n\n//\n\nsection getPriorityOf @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot) -> $u8 {\n  result = NVIC.IPR [inInterruptCode.u7]!\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_59_targetTemplates (
  "teensy-3-1-nvic-interrupts.omnibus-import",
  "omnibus-import",
  true, // Text file
  1340, // Text length
  gWrapperFileContent_59_targetTemplates
) ;

//--- File 'teensy-3-1/teensy-3-1-time.omnibus-import'

const char * gWrapperFileContent_65_targetTemplates = "ctAssert target \"teensy-3-1/unprivileged\"\n\n//\n\ndriver time ()\n\n//\n//   TIME\n//\n\ndriver time > root {\n  var mUptime $u32 = 0\n\n  //\n\n  startup { // Configure Systick interrupt every ms\n    SYST.RVR = 96000 - 1 // $interrupt every 96000 core clocks, i.e. every ms\n    SYST.CVR = 0\n    SYST.CSR = {SYST.CSR !CLKSOURCE:1 !ENABLE:1 !TICKINT:1}\n  }\n\n  //\n\n  public func oneMillisecondBusyWait startup @noUnusedWarning () {\n    while SYST.CSR.COUNTFLAG == 0 {}\n  }\n\n  //\n\n  public func panicOneMillisecondBusyWait panic @noUnusedWarning () {\n    while SYST.CSR.COUNTFLAG == 0 {}\n  }\n\n  //\n\n  public section now safe @noUnusedWarning () -> $u32 {\n    result = self.mUptime\n  }\n\n  //\n\n  public func busyWaitingDuringMS startup @noUnusedWarning @mutating (\?inDelay $u32) {\n    for _ $u32 in 0 ..< inDelay {\n      self.oneMillisecondBusyWait ()\n    }\n  }\n\n  //\n\n  public func panicBusyWaitingDuringMS panic @noUnusedWarning @mutating (\?inDelay $u32) {\n    for _ $u32 in 0 ..< inDelay {\n      self.panicOneMillisecondBusyWait ()\n    }\n  }\n\n  //\n\n  interrupt service systick {\n    let now = self.mUptime +% 1\n    self.mUptime = now\n    makeTasksReady (!fromCurrentDate:now)\n    notifyChangeForGuardedWaitUntil (!withCurrentDate:now)\n  }\n\n  //\n\n  public primitive wait safe @noUnusedWarning (\?until: inDate $u32) {\n    if inDate > self.mUptime {\n      block (!onDeadline:inDate)\n    }\n  }\n\n  //\n\n  public primitive wait @noUnusedWarning (\?during: inDelay $u32) {\n    if inDelay > 0 {\n      block (!onDeadline:self.mUptime +% inDelay)\n    }\n  }\n\n  //\n\n  public guard wait @noUnusedWarning (\?until:inDeadline $u32) {\n    accept = (inDeadline)  self.mUptime\n    if not accept {\n      handle (!guardedDeadline:inDeadline)\n    }\n  }\n\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_65_targetTemplates (
  "teensy-3-1-time.omnibus-import",
  "omnibus-import",
  true, // Text file
  2881, // Text length
  gWrapperFileContent_65_targetTemplates
) ;

//--- File 'teensy-3-1/teensy-3-1-xtr.omnibus-import'

const char * gWrapperFileContent_70_targetTemplates = "\nctAssert target \"teensy-3-1/unprivileged\"\n\n//\n//   SYNCHRONIZATION TOOLS ROUTINES\n//\n\nopaque $TaskList @instantiable {32}\n\n//--- Block running task\nextern func\nblock safe primitive (\?!inList:ioWaitingList $TaskList) : \"blockInList\"\n\nextern func\nblock safe primitive (\?onDeadline:inDeadline $u32) : \"blockOnDeadline\"\n\n//--- Make task Ready\nextern func\nmakeTaskReady safe service (\?!fromList:ioWaitingList $TaskList\n                            !found: outFound $bool) : \"makeTaskReady\"\n\nextern func\nmakeTasksReady safe service (\?fromCurrentDate:inCurrentDate $u32) : \"makeTasksReadyFromCurrentDate\"\n\n//\n//   GUARD\n//\n\nopaque $GuardList @instantiable {32}\n\nextern func\nhandle safe guard (\?!guard:ioGuard $GuardList) : \"handleGuardedCommand\"\n\nextern func\nhandle safe guard (\?guardedDeadline:inDeadlineMS $u32) : \"guard.handle.wait.until\"\n\nextern func\nnotifyChange safe service (\?!forGuard:ioGuard $GuardList) : \"notify.change.from.guard.list\"\n\nextern func\nnotifyChangeForGuardedWaitUntil safe service (\?withCurrentDate:inCurrentDate $u32)\n: \"notify.change.for.guarded.wait.until\"\n\n//\n//   ACTIVITY LED\n//\n\nrequired func activityLedOn safe section @exported ()\n\nrequired func activityLedOff safe section @exported ()\n\n//\n\n" ;

const cRegularFileWrapper gWrapperFile_70_targetTemplates (
  "teensy-3-1-xtr.omnibus-import",
  "omnibus-import",
  true, // Text file
  1764, // Text length
  gWrapperFileContent_70_targetTemplates
) ;

//--- File 'teensy-3-1/undefined-interrupt.s'

const char * gWrapperFileContent_67_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Undefined interrupt !ISR!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	!ISR! = -1\n\n" ;

const cRegularFileWrapper gWrapperFile_67_targetTemplates (
  "undefined-interrupt.s",
  "s",
  true, // Text file
  285, // Text length
  gWrapperFileContent_67_targetTemplates
) ;

//--- File 'teensy-3-1/xtr-interrupt-handler.s'

const char * gWrapperFileContent_60_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@   I N T E R R U P T   H A N D L E R                                                                                  *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global \"!ISR!\"\n  .type \"!ISR!\", %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global \"!HANDLER!\"\n  .type \"!HANDLER!\", %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n\"!ISR!\":\n	.fnstart\n@----------------------------------------- Save preserved registers\n	.save	{r4, r5, lr}\n  push  {r4, r5, lr}\n@----------------------------------------- Activity led On\n  bl    func.activityLedOn_28__29_   @ Defined in PLM source (can modify R0-R3 registers)\n@----------------------------------------- R4 <- running task context\n  ldr   r4, =gRunningTaskControlBlockPtr\n  ldr   r4, [r4]\n@----------------------------------------- Call $interrupt handler\n  bl    \"!HANDLER!\"\n@----------------------------------------- Perform context switch, if needed\n  b     handle.context.switch\n\n	.cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_60_targetTemplates (
  "xtr-interrupt-handler.s",
  "s",
  true, // Text file
  1572, // Text length
  gWrapperFileContent_60_targetTemplates
) ;

//--- File 'unprivileged/+config.omnibus-target'

const char * gWrapperFileContent_82_targetTemplates = "PYTHON_UTILITIES:\n   \"../../py-toolpath.txt\" -> \"sources/toolpath.py\"\n   \"../../py-makefile.txt\" -> \"sources/makefile.py\"\n   \"../../py-check-stacks.txt\" -> \"sources/check-stacks.py\"\n   \"../../py-omnibus.txt\" -> \"sources/omnibus.py\"\n   \"../../py-build-verbose.txt\" -> \"build-verbose.py\"\n   \"../../py-clean.txt\" -> \"clean.py\"\n   \"../../py-objdump.txt\" -> \"objdump.py\"\n   \"../../py-objsize.txt\" -> \"objsize.py\"\n   \"../py-run.txt\" -> \"run.py\"\n\nPYTHON_BUILD: \"../py-build.txt\"\n\nLINKER_SCRIPT: \"../ld-linker.txt\"\n\nPANIC_CODE_TYPE_NAME: $u32\nPANIC_LINE_TYPE_NAME: $u32\n\nPOINTER_BIT_COUNT: 32\n\nDYNAMIC_ARRAY: yes\n\nSYSTEM_STACK_SIZE: 1024\n\nNOP: \"call void asm sideeffect \\\"nop\\\", \\\"\\\"() nounwind\"\n\nBIT_BAND:0x4000_0000 0x4200_0000 0x4200_0000 32 4\n\nSERVICE_HANDLER: \"service-handler.s\"\nSERVICE_SYSTEM_STACK_SIZE: 12 // as_svc_handler saves 3 registers on system stack\nSERVICE_DISPATCHER_HEADER: \"service-dispatcher-header.s\"\nSERVICE_DISPATCHER_ENTRY: \"service-dispatcher-entry.s\"\nSERVICE_ENTRY_NO_RETURNED_VALUE: \"service-entry-no-return.s\"\nSERVICE_ENTRY_WITH_RETURNED_VALUE: \"service-entry-return-value.s\"\n\nSECTION_HANDLER: \"udfcoded-section-handler.s\"\nSECTION_SYSTEM_STACK_SIZE: 8 // saves 2 registers on system stack\nSECTION_DISPATCHER_HEADER: \"udfcoded-section-dispatcher-header.s\"\nSECTION_DISPATCHER_ENTRY: \"udfcoded-section-dispatcher-entry.s\"\nSECTION_ENTRY_FROM_UNKNOWN_MODE: \"udfcoded-section-invocation-from-unknown-mode.s\"\nSECTION_ENTRY_FROM_USER_MODE: \"udfcoded-section-invocation-from-user-mode.s\"\n\n//--- $interrupt handler\nINTERRUPT_HANDLER: \"../xtr-interrupt-handler.s\"\nINTERRUPT_USER_STACK_SIZE: 32 // Cortex M4 saves 8 regs in user stack on interrupt\nUNUSED_INTERRUPT: \"../undefined-interrupt.s\"\n\nCPP_FILES:\n  \"../c-cortex-m4-context.cpp\"\n  \"../../c-task-list-type-32-tasks.cpp\"\n  \"../../c-guard-types-32-tasks.cpp\"\n  \"../../c-task-control-block-type.cpp\"\n  \"../../c-guard-list-32-tasks.cpp\"\n  \"../../c-task-list-32-tasks.cpp\"\n  \"../../c-deadline-list-32-tasks.cpp\"\n  \"../../c-real-time-kernel-code.cpp\"\n  \"../../c-guard-code.cpp\"\n  \"../../c-real-time-kernel-utilities.cpp\"\n  \"../../memory-utilities.cpp\"\n  \"../../heap.cpp\"\n  \"../../dynamic-buffer.cpp\"\n\nS_FILES:\n  \"../s-cortex-m4-header.s\"\n  \"s-interrupt-vectors.s\"\n  \"s-reset-handler.s\"\n\nLL_FILES:\n  \"../ll-cortex-m4.ll\"\n  \"../../ll-clear-bss.ll\"\n  \"../../ll-copy-data-section.ll\"\n  \"../../ll-copy-byte-array.ll\"\n  \"../../ll-copy-word-array.ll\"\n  \"../../ll-configuration-on-boot.ll\"\n\nOMNIBUS_FILES:\n  \"../MK20D7-pm.svd.omnibus-import\"\n  \"../registers-mk20dx256-complement.omnibus-import\"\n  \"../../registers-cortex-m4.omnibus-import\"\n  \"../driver-root-teensy-3-1.omnibus-import\"\n  \"../teensy-3-1-nvic-interrupts.omnibus-import\"\n  \"../teensy-3-1-xtr.omnibus-import\"\n  \"../teensy-3-1-time.omnibus-import\"\n  \"../driver-digital-teensy-3-1.omnibus-import\"\n  \"../teensy-3-1-lcd.omnibus-import\"\n  \"../../semaphore.omnibus-import\"\n  \"../../heap.omnibus-import\"\n\nINTERRUPTS:\n  NMI -> 2\n  MemManage -> 4\n  BusFault -> 5\n  UsageFault -> 6\n  DebugMonitor -> 12\n  PendSV -> 14\n  systick -> 15\n  DMAChannel0TransferComplete -> 16\n  DMAChannel1TransferComplete -> 17\n  DMAChannel2TransferComplete -> 18\n  DMAChannel3TransferComplete -> 19\n  DMAChannel4TransferComplete -> 20\n  DMAChannel5TransferComplete -> 21\n  DMAChannel6TransferComplete -> 22\n  DMAChannel7TransferComplete -> 23\n  DMAChannel8TransferComplete -> 24\n  DMAChannel9TransferComplete -> 25\n  DMAChannel10TransferComplete -> 26\n  DMAChannel11TransferComplete -> 27\n  DMAChannel12TransferComplete -> 28\n  DMAChannel13TransferComplete -> 29\n  DMAChannel14TransferComplete -> 30\n  DMAChannel15TransferComplete -> 31\n  DMAError -> 32\n  flashMemoryCommandComplete -> 34\n  flashMemoryReadCollision -> 35\n  modeController -> 36\n  LLWU -> 37\n  WDOGEWM -> 38\n  I2C0 -> 40\n  I2C1 -> 41\n  SPI0 -> 42\n  SPI1 -> 43\n  CAN0MessageBuffer -> 45\n  CAN0BusOff -> 46\n  CAN0Error -> 47\n  CAN0TransmitWarning -> 48\n  CAN0ReceiveWarning -> 49\n  CAN0WakeUp -> 50\n  I2S0Transmit -> 51\n  I2S0Receive -> 52\n  UART0LON -> 60\n  UART0Status -> 61\n  UART0Error -> 62\n  UART1Status -> 63\n  UART1Error -> 64\n  UART2Status -> 65\n  UART2Error -> 66\n  ADC0 -> 73\n  ADC1 -> 74\n  CMP0 -> 75\n  CMP1 -> 76\n  CMP2 -> 77\n  FMT0 -> 78\n  FMT1 -> 79\n  FMT2 -> 80\n  CMT -> 81\n  RTCAlarm -> 82\n  RTCSecond -> 83\n  PITChannel0 -> 84\n  PITChannel1 -> 85\n  PITChannel2 -> 86\n  PITChannel3 -> 87\n  PDB -> 88\n  USBOTG -> 89\n  USBChargerDetect -> 90\n  DAC0 -> 97\n  TSI -> 99\n  MCG -> 100\n  lowPowerTimer -> 101\n  pinDetectPortA -> 103\n  pinDetectPortB -> 104\n  pinDetectPortC -> 105\n  pinDetectPortD -> 106\n  pinDetectPortE -> 107\n  softwareInterrupt -> 110\n" ;

const cRegularFileWrapper gWrapperFile_82_targetTemplates (
  "+config.omnibus-target",
  "omnibus-target",
  true, // Text file
  4612, // Text length
  gWrapperFileContent_82_targetTemplates
) ;

//--- File 'unprivileged/s-interrupt-vectors.s'

const char * gWrapperFileContent_79_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@   INTERRUPT VECTOR                                                                                                   *\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	.isr_vector,\"a\",%progbits\n\n  .word __system_stack_end\n@--- ARM Core System Handler Vectors\n  .word as_reset_handler @ 1\n  .word !ISR!NMI @ 2\n  .word as_section_handler @ 3\n  .word !ISR!MemManage @ 4\n  .word !ISR!BusFault @ 5\n  .word !ISR!UsageFault @ 6\n  .word -1 @ 7, reserved\n  .word -1 @ 8, reserved\n  .word -1 @ 9, reserved\n  .word -1 @ 10, reserved\n  .word as_svc_handler @ 11\n  .word !ISR!DebugMonitor @ 12\n  .word -1 @ 13, reserved\n  .word !ISR!PendSV @ 14\n  .word !ISR!systick @ 15\n@--- Non-Core Vectors\n  .word !ISR!DMAChannel0TransferComplete @ 16\n  .word !ISR!DMAChannel1TransferComplete @ 17\n  .word !ISR!DMAChannel2TransferComplete @ 18\n  .word !ISR!DMAChannel3TransferComplete @ 19\n  .word !ISR!DMAChannel4TransferComplete @ 20\n  .word !ISR!DMAChannel5TransferComplete @ 21\n  .word !ISR!DMAChannel6TransferComplete @ 22\n  .word !ISR!DMAChannel7TransferComplete @ 23\n  .word !ISR!DMAChannel8TransferComplete @ 24\n  .word !ISR!DMAChannel9TransferComplete @ 25\n  .word !ISR!DMAChannel10TransferComplete @ 26\n  .word !ISR!DMAChannel11TransferComplete @ 27\n  .word !ISR!DMAChannel12TransferComplete @ 28\n  .word !ISR!DMAChannel13TransferComplete @ 29\n  .word !ISR!DMAChannel14TransferComplete @ 30\n  .word !ISR!DMAChannel15TransferComplete @ 31\n  .word !ISR!DMAError @ 32\n  .word -1 @ 33\n  .word !ISR!flashMemoryCommandComplete @ 34\n  .word !ISR!flashMemoryReadCollision @ 35\n  .word !ISR!modeController @ 36\n  .word !ISR!LLWU @ 37\n  .word !ISR!WDOGEWM @ 38\n  .word -1 @ 39\n  .word !ISR!I2C0 @ 40\n  .word !ISR!I2C1 @ 41\n  .word !ISR!SPI0 @ 42\n  .word !ISR!SPI1 @ 43\n  .word -1 @ 44\n  .word !ISR!CAN0MessageBuffer @ 45\n  .word !ISR!CAN0BusOff @ 46\n  .word !ISR!CAN0Error @ 47\n  .word !ISR!CAN0TransmitWarning @ 48\n  .word !ISR!CAN0ReceiveWarning @ 49\n  .word !ISR!CAN0WakeUp @ 50\n  .word !ISR!I2S0Transmit @ 51\n  .word !ISR!I2S0Receive @ 52\n  .word -1 @ 53\n  .word -1 @ 54\n  .word -1 @ 55\n  .word -1 @ 56\n  .word -1 @ 57\n  .word -1 @ 58\n  .word -1 @ 59\n  .word !ISR!UART0LON @ 60\n  .word !ISR!UART0Status @ 61\n  .word !ISR!UART0Error @ 62\n  .word !ISR!UART1Status @ 63\n  .word !ISR!UART1Error @ 64\n  .word !ISR!UART2Status @ 65\n  .word !ISR!UART2Error @ 66\n  .word -1 @ 67\n  .word -1 @ 68\n  .word -1 @ 69\n  .word -1 @ 70\n  .word -1 @ 71\n  .word -1 @ 72\n  .word !ISR!ADC0 @ 73\n  .word !ISR!ADC1 @ 74\n  .word !ISR!CMP0 @ 75\n  .word !ISR!CMP1 @ 76\n  .word !ISR!CMP2 @ 77\n  .word !ISR!FMT0 @ 78\n  .word !ISR!FMT1 @ 79\n  .word !ISR!FMT2 @ 80\n  .word !ISR!CMT @ 81\n  .word !ISR!RTCAlarm @ 82\n  .word !ISR!RTCSecond @ 83\n  .word !ISR!PITChannel0 @ 84\n  .word !ISR!PITChannel1 @ 85\n  .word !ISR!PITChannel2 @ 86\n  .word !ISR!PITChannel3 @ 87\n  .word !ISR!PDB @ 88\n  .word !ISR!USBOTG @ 89\n  .word !ISR!USBChargerDetect @ 90\n  .word -1 @ 91\n  .word -1 @ 92\n  .word -1 @ 93\n  .word -1 @ 94\n  .word -1 @ 95\n  .word -1 @ 96\n  .word !ISR!DAC0 @ 97\n  .word -1 @ 98\n  .word !ISR!TSI @ 99\n  .word !ISR!MCG @ 100\n  .word !ISR!lowPowerTimer @ 101\n  .word -1 @ 102\n  .word !ISR!pinDetectPortA @ 103\n  .word !ISR!pinDetectPortB @ 104\n  .word !ISR!pinDetectPortC @ 105\n  .word !ISR!pinDetectPortD @ 106\n  .word !ISR!pinDetectPortE @ 107\n  .word -1 @ 108\n  .word -1 @ 109\n  .word !ISR!softwareInterrupt @ 110\n  .word -1 @ 111\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 112 to 119\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 120 to 127\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 128 to 135\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 136 to 143\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 144 to 151\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 152 to 159\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 160 to 167\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 168 to 175\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 176 to 183\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 184 to 191\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 192 to 199\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 200 to 207\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 208 to 215\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 216 to 223\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 224 to 231\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 232 to 239\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 240 to 247\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 248 to 255\n@--- Flash magic values\n  .word -1\n  .word -1\n  .word -1\n  .word -2\n\n" ;

const cRegularFileWrapper gWrapperFile_79_targetTemplates (
  "s-interrupt-vectors.s",
  "s",
  true, // Text file
  4591, // Text length
  gWrapperFileContent_79_targetTemplates
) ;

//--- File 'unprivileged/s-reset-handler.s'

const char * gWrapperFileContent_83_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 R E S E T    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                                *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n.lcomm backgroundTaskStack, 32\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.as_reset_handler\",\"ax\",%progbits\n\n  .global as_reset_handler\n  .type as_reset_handler, %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n@ See https://developer.arm.com/docs/dui0553/latest/2-the-cortex-m4-processor/21-programmers-model/213-core-registers\n\n	.section	\".text.as_reset_handler\",\"ax\",%progbits\n\n  .global as_reset_handler\n  .type as_reset_handler, %function\n\nas_reset_handler: @ Cortex M4 boots with interrupts enabled, in Thread mode (as IPSR is set to 0 at boot)\n@---------- Run boot, zero bss section, copy data section\n  bl  boot.routines\n@---------- Set background task context\n  ldr r0, =backgroundTaskStack\n  ldr r1, =backgroundTaskContext\n  str r0, [r1]\n@---------- Set PSP : this is stack for background task, it needs 32 bytes for stacking 8 registers\n  add r0, #32\n  msr psp, r0\n@---------- Set CONTROL register (see B1.4.4)\n@ bit 0 : 0 -> Thread mode has privileged access, 1 -> Thread mode has unprivileged access\n@ bit 1 : 0 -> Use SP_main as the current stack, 1 -> In Thread mode, use SP_process as the current stack\n@ bit 2 : 0 -> FP extension not active, 1 -> FP extension is active\n  movs r2, #3\n  msr  control, r2\n@---------- Software must use an ISB barrier instruction to ensure a write to the CONTROL register\n@ takes effect before the next instruction is executed.\n  isb\n@---------- Start real-time kernel (run startup.routines as service)\n  svc  #0\n@---------- Background task : infinite loop\nbackground.task:\n  wfi\n  b  background.task\n\n" ;

const cRegularFileWrapper gWrapperFile_83_targetTemplates (
  "s-reset-handler.s",
  "s",
  true, // Text file
  2335, // Text length
  gWrapperFileContent_83_targetTemplates
) ;

//--- File 'unprivileged/service-dispatcher-entry.s'

const char * gWrapperFileContent_87_targetTemplates = "  .word  \"!ENTRY!\" @ !IDX! + 1\n" ;

const cRegularFileWrapper gWrapperFile_87_targetTemplates (
  "service-dispatcher-entry.s",
  "s",
  true, // Text file
  31, // Text length
  gWrapperFileContent_87_targetTemplates
) ;

//--- File 'unprivileged/service-dispatcher-header.s'

const char * gWrapperFileContent_76_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S V C    D I S P A T C H E R    T A B L E                                                            *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .type startup.routines, %function\n\n  .align  2\n\n__svc_dispatcher_table:\n  .word  startup.routines @ 0\n" ;

const cRegularFileWrapper gWrapperFile_76_targetTemplates (
  "service-dispatcher-header.s",
  "s",
  true, // Text file
  710, // Text length
  gWrapperFileContent_76_targetTemplates
) ;

//--- File 'unprivileged/service-entry-no-return.s'

const char * gWrapperFileContent_81_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Service !ENTRY!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!ENTRY!\",\"ax\", %progbits\n	.globl	\"!ENTRY!\"\n	.align	2\n	.type	\"!ENTRY!\", %function\n	.code	16\n	.thumb_func\n\n\"!ENTRY!\":\n	.fnstart\n  svc #!IDX! + 1\n  bx  lr\n\n\".Lfunc_end_!ENTRY!\":\n  .size	\"!ENTRY!\", \".Lfunc_end_!ENTRY!\" - \"!ENTRY!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_81_targetTemplates (
  "service-entry-no-return.s",
  "s",
  true, // Text file
  529, // Text length
  gWrapperFileContent_81_targetTemplates
) ;

//--- File 'unprivileged/service-entry-return-value.s'

const char * gWrapperFileContent_86_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Service !ENTRY!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!ENTRY!\", \"ax\", %progbits\n	.globl	\"!ENTRY!\"\n	.align	2\n	.type	\"!ENTRY!\",%function\n	.code	16\n	.thumb_func\n\n\"!ENTRY!\":\n	.fnstart\n  svc #!IDX! + 1\n  b   xtr.user.result\n\n\".Lfunc_end_!ENTRY!\":\n  .size	\"!ENTRY!\", \".Lfunc_end_!ENTRY!\" - \"!ENTRY!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_86_targetTemplates (
  "service-entry-return-value.s",
  "s",
  true, // Text file
  542, // Text length
  gWrapperFileContent_86_targetTemplates
) ;

//--- File 'unprivileged/service-handler.s'

const char * gWrapperFileContent_85_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S V C    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                                    *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@          PSP+32 -> |                            |                                                                    *\n@                    |----------------------------| \\\n@          PSP+28 -> | xPSR                       |  |\n@                    |----------------------------|  |\n@          PSP+24 -> | PC (after SVC instruction) |  |\n@                    |----------------------------|  |\n@          PSP+20 -> | LR                         |  |\n@                    |----------------------------|  |\n@          PSP+16 -> | R12                        |  |  Saved by interrupt response\n@                    |----------------------------|  |\n@          PSP+12 -> | R3                         |  |\n@                    |----------------------------|  |\n@          PSP+8  -> | R2                         |  |\n@                    |----------------------------|  |\n@          PSP+4  -> | R1                         |  |\n@                    |----------------------------|  |\n@     /--- PSP ----> | R0                         |  |\n@     |              |----------------------------| /\n@     |                                                                                                                *\n@     |                                      *---------------------*\n@     |                                      | LR return code      | +36 [ 9]\n@     |                                      *---------------------*\n@     \\------------------------------------- | R13 (PSP)           | +32 [ 8]\n@                                            *---------------------*\n@                                            | R11                 | +28 [ 7]\n@                                            *---------------------*\n@                                            | R10                 | +24 [ 6]\n@                                            *---------------------*\n@                                            | R9                  | +20 [ 5]\n@                                            *---------------------*\n@                                            | R8                  | +16 [ 4]\n@                                            *---------------------*\n@                                            | R7                  | +12 [ 3]\n@                                            *---------------------*\n@                                            | R6                  | + 8 [ 2]\n@                                            *---------------------*\n@                                            | R5                  | + 4 [ 1]\n@  *--------------------------------*        *---------------------*\n@  | gRunningTaskControlBlockPtr    +------> | R4                  | + 0 [ 0]\n@  *--------------------------------*        *---------------------*\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global backgroundTaskContext\n  .lcomm backgroundTaskContext, 4\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.as_svc_handler\",\"ax\",%progbits\n\n  .global as_svc_handler\n  .type as_svc_handler, %function\n\nas_svc_handler:\n@----------------------------------------- Save preserved registers\n  push  {r4, r5, lr}\n@----------------------------------------- R5 <- thread SP\n  mrs   r5, psp\n@----------------------------------------- R4 <- Address of SVC instruction\n  ldr   r4, [r5, #24]    @ 24 : 6 stacked registers before saved PC\n@----------------------------------------- R12 <- bits 0-7 of SVC instruction\n  ldrb  r12, [r4, #-2]   @ R12 is service call index\n@----------------------------------------- R4 <- address of dispatcher table\n  ldr   r4, =__svc_dispatcher_table\n@----------------------------------------- R12 <- address of routine to call\n  ldr   r12, [r4, r12, lsl #2]   @ R12 = R4 + (R12 << 2)\n@----------------------------------------- R4 <- calling task context\n  ldr   r4, =gRunningTaskControlBlockPtr\n  ldr   r4, [r4]\n@----------------------------------------- Call service routine\n  blx   r12         @ R4:calling task context address, R5:thread PSP\n@--- Continues in sequence to handle.context.switch\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 H A N D L E    C O N T E X T    S W I T C H    ( D O U B L E    S T A C K    M O D E )               *\n@                                                                                                                      *\n@  On entry:                                                                                                           *\n@    - R4 contains the runnning task save context address,                                                             *\n@    - R5 can be freely used,                                                                                          *\n@    - R4, R5 and LR of running task have been pushed on handler task.                                                 *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\nhandle.context.switch:\n@----------------------------------------- Select task to run\n  bl    kernel_selectTaskToRun\n@----------------------------------------- R0 <- calling task context, R1 <- new task context\n  ldr   r1, =gRunningTaskControlBlockPtr\n  mov   r0, r4\n  ldr   r1, [r1]\n@----------------------------------------- Restore preserved registers\n  pop   {r4, r5, lr}\n@----------------------------------------- Task context did change \?\n  cmp   r0, r1  @ R0:old task context, R1:new task context\n  beq   __no_context_change\n@----------------------------------------- Save context of preempted task (if any)\n  cbz   r0, __perform_restore_context @ if old context is NULL, no context to save\n@--- Save registers r4 to r11, PSP, LR\n  mrs     r12, psp\n  stmia   r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}\n@----------------------------------------- Restore context of activated task (if any)\n__perform_restore_context:\n  cbz    r1, __no_context_to_restore\n  ldmia  r1, {r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}\n  msr    psp, r12\n  bx     lr\n@----------------------------------------- No context change\n__no_context_change:\n  cbz r0, __no_context_to_restore\n  bx  lr\n@----------------------------------------- No context to restore\n__no_context_to_restore:\n@--- Switch off activity led\n  bl func.activityLedOff_28__29_  @ Defined in PLM source\n@--- Restore PSP of background task\n  ldr  r0, =backgroundTaskContext\n  ldr  r0, [r0]\n  msr  psp, r0\n@--- Return from exception (thread mode, process stack, no floating point)\n  ldr  r1, =0xFFFFFFFD\n  bx   r1\n\n" ;

const cRegularFileWrapper gWrapperFile_85_targetTemplates (
  "service-handler.s",
  "s",
  true, // Text file
  7799, // Text length
  gWrapperFileContent_85_targetTemplates
) ;

//--- File 'unprivileged/udfcoded-section-dispatcher-entry.s'

const char * gWrapperFileContent_84_targetTemplates = "  .word  \"!IMPLEMENTATION_ROUTINE!\" @ !IDX!, user routine !USER_ROUTINE!\n" ;

const cRegularFileWrapper gWrapperFile_84_targetTemplates (
  "udfcoded-section-dispatcher-entry.s",
  "s",
  true, // Text file
  73, // Text length
  gWrapperFileContent_84_targetTemplates
) ;

//--- File 'unprivileged/udfcoded-section-dispatcher-header.s'

const char * gWrapperFileContent_75_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S E C T I O N   T A B L E                                                                            *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .align  2\n\n__section_dispatcher_table:\n" ;

const cRegularFileWrapper gWrapperFile_75_targetTemplates (
  "udfcoded-section-dispatcher-header.s",
  "s",
  true, // Text file
  647, // Text length
  gWrapperFileContent_75_targetTemplates
) ;

//--- File 'unprivileged/udfcoded-section-handler.s'

const char * gWrapperFileContent_80_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 U D F    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                                    *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                    |                            |                                                                    *\n@          PSP+32 -> |----------------------------| \\\n@                    | xPSR                       |  |\n@          PSP+28 -> |----------------------------|  |\n@                    | PC (UDF instruction)       |  |\n@          PSP+24 -> |----------------------------|  |\n@                    | LR                         |  |\n@          PSP+20 -> |----------------------------|  |\n@                    | R12                        |  |  Saved by interrupt response\n@          PSP+16 -> |----------------------------|  |\n@                    | R3                         |  |\n@          PSP+12 -> |----------------------------|  |\n@                    | R2                         |  |\n@          PSP+8  -> |----------------------------|  |\n@                    | R1                         |  |\n@          PSP+4  -> |----------------------------|  |\n@                    | R0                         |  |\n@          PSP    -> |----------------------------| /\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .section  \".text.as_section_handler\",\"ax\",%progbits\n\n  .global as_section_handler\n  .type as_section_handler, %function\n\nas_section_handler:\n@--------------------- Save preserved registers\n  push  {r5, lr}\n@--------------------- R5 <- thread SP\n  mrs   r5, psp           @ r5 <- thread SP\n@--------------------- LR <- Address of UDF instruction\n  ldr   lr, [r5, #24]     @ 24 : 6 stacked registers before saved PC\n@--------------------- Set return address to instruction following UDF\n  adds  lr, #2\n  str   lr, [r5, #24]\n@--------------------- R12 <- address of dispatcher\n  ldr   r12, =__section_dispatcher_table\n@--------------------- LR <- bits 0-7 of UDF instruction\n  ldrb  lr, [lr, #-2]            @ LR is service call index\n@--------------------- r12 <- address of routine to call\n  ldr   r12, [r12, lr, lsl #2]   @ R12 += LR << 2\n@--------------------- Call service routine\n  blx   r12                      @ R5: thread PSP\n@--------------------- Set return code (from R0 to R3) in stacked registers\n  stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\n@--------------------- Restore preserved registers, return from interrupt\n  pop   {r5, pc}\n\n" ;

const cRegularFileWrapper gWrapperFile_80_targetTemplates (
  "udfcoded-section-handler.s",
  "s",
  true, // Text file
  3206, // Text length
  gWrapperFileContent_80_targetTemplates
) ;

//--- File 'unprivileged/udfcoded-section-invocation-from-unknown-mode.s'

const char * gWrapperFileContent_78_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Section !USER_ROUTINE!, implemented by !IMPLEMENTATION_ROUTINE!\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .section  \".text.!USER_ROUTINE!\", \"ax\", %progbits\n\n  .global \"!USER_ROUTINE!\"\n  .type  \"!USER_ROUTINE!\", %function\n\n  .align  2\n  .thumb_func\n\n\"!USER_ROUTINE!\":\n  .fnstart\n  mrs  r12, IPSR @ r12 <- 00 in thread mode, nn, nn  0 in handler mode\n  ands r12, #255\n  bne  !IMPLEMENTATION_ROUTINE! @ in handler mode, call implementation routine directly\n  udf !IDX!\n  bx  lr\n\n\".Lfunc_end_!USER_ROUTINE!\":\n  .size  \"!USER_ROUTINE!\", \".Lfunc_end_!USER_ROUTINE!\" - \"!USER_ROUTINE!\"\n  .cantunwind\n  .fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_78_targetTemplates (
  "udfcoded-section-invocation-from-unknown-mode.s",
  "s",
  true, // Text file
  812, // Text length
  gWrapperFileContent_78_targetTemplates
) ;

//--- File 'unprivileged/udfcoded-section-invocation-from-user-mode.s'

const char * gWrapperFileContent_77_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Section !USER_ROUTINE!, implemented by !IMPLEMENTATION_ROUTINE!\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .section  \".text.!USER_ROUTINE!\", \"ax\", %progbits\n\n  .global \"!USER_ROUTINE!\"\n  .type  \"!USER_ROUTINE!\", %function\n\n  .align  2\n  .thumb_func\n\n\"!USER_ROUTINE!\":\n  .fnstart\n  udf !IDX!\n  bx  lr\n\n\".Lfunc_end_!USER_ROUTINE!\":\n  .size \"!USER_ROUTINE!\", \".Lfunc_end_!USER_ROUTINE!\" - \"!USER_ROUTINE!\"\n  .cantunwind\n  .fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_77_targetTemplates (
  "udfcoded-section-invocation-from-user-mode.s",
  "s",
  true, // Text file
  632, // Text length
  gWrapperFileContent_77_targetTemplates
) ;

//--- All files of 'unprivileged' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_3 [14] = {
  & gWrapperFile_82_targetTemplates,
  & gWrapperFile_79_targetTemplates,
  & gWrapperFile_83_targetTemplates,
  & gWrapperFile_87_targetTemplates,
  & gWrapperFile_76_targetTemplates,
  & gWrapperFile_81_targetTemplates,
  & gWrapperFile_86_targetTemplates,
  & gWrapperFile_85_targetTemplates,
  & gWrapperFile_84_targetTemplates,
  & gWrapperFile_75_targetTemplates,
  & gWrapperFile_80_targetTemplates,
  & gWrapperFile_78_targetTemplates,
  & gWrapperFile_77_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'unprivileged' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_3 [1] = {
  NULL
} ;

//--- Directory 'unprivileged'

const cDirectoryWrapper gWrapperDirectory_3_targetTemplates (
  "unprivileged",
  13,
  gWrapperAllFiles_targetTemplates_3,
  0,
  gWrapperAllDirectories_targetTemplates_3
) ;

//--- All files of 'teensy-3-1' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_2 [18] = {
  & gWrapperFile_73_targetTemplates,
  & gWrapperFile_61_targetTemplates,
  & gWrapperFile_62_targetTemplates,
  & gWrapperFile_63_targetTemplates,
  & gWrapperFile_64_targetTemplates,
  & gWrapperFile_68_targetTemplates,
  & gWrapperFile_66_targetTemplates,
  & gWrapperFile_58_targetTemplates,
  & gWrapperFile_69_targetTemplates,
  & gWrapperFile_71_targetTemplates,
  & gWrapperFile_74_targetTemplates,
  & gWrapperFile_72_targetTemplates,
  & gWrapperFile_59_targetTemplates,
  & gWrapperFile_65_targetTemplates,
  & gWrapperFile_70_targetTemplates,
  & gWrapperFile_67_targetTemplates,
  & gWrapperFile_60_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'teensy-3-1' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_2 [2] = {
  & gWrapperDirectory_3_targetTemplates,
  NULL
} ;

//--- Directory 'teensy-3-1'

const cDirectoryWrapper gWrapperDirectory_2_targetTemplates (
  "teensy-3-1",
  17,
  gWrapperAllFiles_targetTemplates_2,
  1,
  gWrapperAllDirectories_targetTemplates_2
) ;

//--- File 'teensy-3-6/MK66F18-pm.svd.omnibus-import'

const char * gWrapperFileContent_95_targetTemplates = "//------------------------------------------------------------------------------\n// MK66F18: MK66F18 Freescale Microcontroller\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: ADC [2]\n//        ADC0 at 0x4003b000\n//        ADC1 at 0x400bb000\n//------------------------------------------------------------------------------\n\nregisters ADC [2 @at 0x4003b000 0x400bb000]\n          ADC0 @at 0x4003b000\n          ADC1 @at 0x400bb000 {\n//---  Registers SC1(A,B): ADC Status and Control Registers 1\n  SC1 [2 @offset 0x0 @inc 0x4]\n  SC1A @offset 0x0\n  SC1B @offset 0x4 $u32 {\n    24\n    COCO // at 7: Conversion Complete Flag\n    AIEN // at 6: Interrupt Enable\n    DIFF // at 5: Differential Mode Enable\n    ADCH:5 // at 0: Input channel select\n  }\n\n//---  Register CFG1: ADC Configuration Register 1\n  CFG1 @offset 0x8 $u32 {\n    24\n    ADLPC // at 7: Low-Power Configuration\n    ADIV:2 // at 5: Clock Divide Select\n    ADLSMP // at 4: Sample Time Configuration\n    MODE:2 // at 2: Conversion mode selection\n    ADICLK:2 // at 0: Input Clock Select\n  }\n\n//---  Register CFG2: ADC Configuration Register 2\n  CFG2 @offset 0xc $u32 {\n    27\n    MUXSEL // at 4: ADC Mux Select\n    ADACKEN // at 3: Asynchronous Clock Output Enable\n    ADHSC // at 2: High-Speed Configuration\n    ADLSTS:2 // at 0: Long Sample Time Select\n  }\n\n//---  Registers R(A,B): ADC Data Result Register\n  R [2 @offset 0x10 @inc 0x4]\n  RA @offset 0x10 @ro\n  RB @offset 0x14 @ro $u32 {\n    16\n    D:16 // at 0: Data result\n  }\n\n//---  Registers CV(1,2): Compare Value Registers\n  CV [2 @offset 0x18 @inc 0x4]\n  CV1 @offset 0x18\n  CV2 @offset 0x1c $u32 {\n    16\n    CV:16 // at 0: Compare Value.\n  }\n\n//---  Register SC2: Status and Control Register 2\n  SC2 @offset 0x20 $u32 {\n    24\n    ADACT // at 7: Conversion Active\n    ADTRG // at 6: Conversion Trigger Select\n    ACFE // at 5: Compare Function Enable\n    ACFGT // at 4: Compare Function Greater Than Enable\n    ACREN // at 3: Compare Function Range Enable\n    DMAEN // at 2: DMA Enable\n    REFSEL:2 // at 0: Voltage Reference Selection\n  }\n\n//---  Register SC3: Status and Control Register 3\n  SC3 @offset 0x24 $u32 {\n    24\n    CAL // at 7: Calibration\n    CALF // at 6: Calibration Failed Flag\n    2\n    ADCO // at 3: Continuous Conversion Enable\n    AVGE // at 2: Hardware Average Enable\n    AVGS:2 // at 0: Hardware Average Select\n  }\n\n//---  Register OFS: ADC Offset Correction Register\n  OFS @offset 0x28 $u32 {\n    16\n    OFS:16 // at 0: Offset Error Correction Value\n  }\n\n//---  Register PG: ADC Plus-Side Gain Register\n  PG @offset 0x2c $u32 {\n    16\n    PG:16 // at 0: Plus-Side Gain\n  }\n\n//---  Register MG: ADC Minus-Side Gain Register\n  MG @offset 0x30 $u32 {\n    16\n    MG:16 // at 0: Minus-Side Gain\n  }\n\n//---  Register CLPD: ADC Plus-Side General Calibration Value Register\n  CLPD @offset 0x34 $u32 {\n    26\n    CLPD:6 // at 0: Calibration Value\n  }\n\n//---  Register CLPS: ADC Plus-Side General Calibration Value Register\n  CLPS @offset 0x38 $u32 {\n    26\n    CLPS:6 // at 0: Calibration Value\n  }\n\n//---  Register CLP4: ADC Plus-Side General Calibration Value Register\n  CLP4 @offset 0x3c $u32 {\n    22\n    CLP4:10 // at 0: Calibration Value\n  }\n\n//---  Register CLP3: ADC Plus-Side General Calibration Value Register\n  CLP3 @offset 0x40 $u32 {\n    23\n    CLP3:9 // at 0: Calibration Value\n  }\n\n//---  Register CLP2: ADC Plus-Side General Calibration Value Register\n  CLP2 @offset 0x44 $u32 {\n    24\n    CLP2:8 // at 0: Calibration Value\n  }\n\n//---  Register CLP1: ADC Plus-Side General Calibration Value Register\n  CLP1 @offset 0x48 $u32 {\n    25\n    CLP1:7 // at 0: Calibration Value\n  }\n\n//---  Register CLP0: ADC Plus-Side General Calibration Value Register\n  CLP0 @offset 0x4c $u32 {\n    26\n    CLP0:6 // at 0: Calibration Value\n  }\n\n//---  Register CLMD: ADC Minus-Side General Calibration Value Register\n  CLMD @offset 0x54 $u32 {\n    26\n    CLMD:6 // at 0: Calibration Value\n  }\n\n//---  Register CLMS: ADC Minus-Side General Calibration Value Register\n  CLMS @offset 0x58 $u32 {\n    26\n    CLMS:6 // at 0: Calibration Value\n  }\n\n//---  Register CLM4: ADC Minus-Side General Calibration Value Register\n  CLM4 @offset 0x5c $u32 {\n    22\n    CLM4:10 // at 0: Calibration Value\n  }\n\n//---  Register CLM3: ADC Minus-Side General Calibration Value Register\n  CLM3 @offset 0x60 $u32 {\n    23\n    CLM3:9 // at 0: Calibration Value\n  }\n\n//---  Register CLM2: ADC Minus-Side General Calibration Value Register\n  CLM2 @offset 0x64 $u32 {\n    24\n    CLM2:8 // at 0: Calibration Value\n  }\n\n//---  Register CLM1: ADC Minus-Side General Calibration Value Register\n  CLM1 @offset 0x68 $u32 {\n    25\n    CLM1:7 // at 0: Calibration Value\n  }\n\n//---  Register CLM0: ADC Minus-Side General Calibration Value Register\n  CLM0 @offset 0x6c $u32 {\n    26\n    CLM0:6 // at 0: Calibration Value\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: AIPS [2]\n//        AIPS0 at 0x40000000\n//        AIPS1 at 0x40080000\n//------------------------------------------------------------------------------\n\nregisters AIPS [2 @at 0x40000000 0x40080000]\n          AIPS0 @at 0x40000000\n          AIPS1 @at 0x40080000 {\n//---  Register MPRA: Master Privilege Register A\n  MPRA @offset 0x0 $u32 {\n    1\n    MTR0 // at 30: Master 0 Trusted For Read\n    MTW0 // at 29: Master 0 Trusted For Writes\n    MPL0 // at 28: Master 0 Privilege Level\n    1\n    MTR1 // at 26: Master 1 Trusted for Read\n    MTW1 // at 25: Master 1 Trusted for Writes\n    MPL1 // at 24: Master 1 Privilege Level\n    1\n    MTR2 // at 22: Master 2 Trusted For Read\n    MTW2 // at 21: Master 2 Trusted For Writes\n    MPL2 // at 20: Master 2 Privilege Level\n    1\n    MTR3 // at 18: Master 3 Trusted For Read\n    MTW3 // at 17: Master 3 Trusted For Writes\n    MPL3 // at 16: Master 3 Privilege Level\n    1\n    MTR4 // at 14: Master 4 Trusted For Read\n    MTW4 // at 13: Master 4 Trusted For Writes\n    MPL4 // at 12: Master 4 Privilege Level\n    1\n    MTR5 // at 10: Master 5 Trusted For Read\n    MTW5 // at 9: Master 5 Trusted For Writes\n    MPL5 // at 8: Master 5 Privilege Level\n    1\n    MTR6 // at 6: Master 6 Trusted for Read\n    MTW6 // at 5: Master 6 Trusted for Writes\n    MPL6 // at 4: Master 6 Privilege Level\n    4\n  }\n\n//---  Register PACRA: Peripheral Access Control Register\n  PACRA @offset 0x20 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRB: Peripheral Access Control Register\n  PACRB @offset 0x24 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRC: Peripheral Access Control Register\n  PACRC @offset 0x28 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRD: Peripheral Access Control Register\n  PACRD @offset 0x2c $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRE: Peripheral Access Control Register\n  PACRE @offset 0x40 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRF: Peripheral Access Control Register\n  PACRF @offset 0x44 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRG: Peripheral Access Control Register\n  PACRG @offset 0x48 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRH: Peripheral Access Control Register\n  PACRH @offset 0x4c $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRI: Peripheral Access Control Register\n  PACRI @offset 0x50 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRJ: Peripheral Access Control Register\n  PACRJ @offset 0x54 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRK: Peripheral Access Control Register\n  PACRK @offset 0x58 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRL: Peripheral Access Control Register\n  PACRL @offset 0x5c $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRM: Peripheral Access Control Register\n  PACRM @offset 0x60 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRN: Peripheral Access Control Register\n  PACRN @offset 0x64 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRO: Peripheral Access Control Register\n  PACRO @offset 0x68 $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n//---  Register PACRP: Peripheral Access Control Register\n  PACRP @offset 0x6c $u32 {\n    1\n    SP0 // at 30: Supervisor Protect\n    WP0 // at 29: Write Protect\n    TP0 // at 28: Trusted Protect\n    1\n    SP1 // at 26: Supervisor Protect\n    WP1 // at 25: Write Protect\n    TP1 // at 24: Trusted Protect\n    1\n    SP2 // at 22: Supervisor Protect\n    WP2 // at 21: Write Protect\n    TP2 // at 20: Trusted Protect\n    1\n    SP3 // at 18: Supervisor Protect\n    WP3 // at 17: Write Protect\n    TP3 // at 16: Trusted Protect\n    1\n    SP4 // at 14: Supervisor Protect\n    WP4 // at 13: Write Protect\n    TP4 // at 12: Trusted Protect\n    1\n    SP5 // at 10: Supervisor Protect\n    WP5 // at 9: Write Protect\n    TP5 // at 8: Trusted Protect\n    1\n    SP6 // at 6: Supervisor Protect\n    WP6 // at 5: Write Protect\n    TP6 // at 4: Trusted Protect\n    1\n    SP7 // at 2: Supervisor Protect\n    WP7 // at 1: Write Protect\n    TP7 // at 0: Trusted Protect\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral AXBS: Crossbar switch\n//------------------------------------------------------------------------------\n\nregisters AXBS @at 0x40004000 {\n//---  Registers PRS(0,1,2,3,4): Priority Registers Slave\n  PRS [5 @offset 0x0 @inc 0x100]\n  PRS0 @offset 0x0\n  PRS1 @offset 0x100\n  PRS2 @offset 0x200\n  PRS3 @offset 0x300\n  PRS4 @offset 0x400 $u32 {\n    5\n    M6:3 // at 24: Master 6 Priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M5:3 // at 20: Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M4:3 // at 16: Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M3:3 // at 12: Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M2:3 // at 8: Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M1:3 // at 4: Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.\n    1\n    M0:3 // at 0: Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.\n  }\n\n//---  Registers CRS(0,1,2,3,4): Control Register\n  CRS [5 @offset 0x10 @inc 0x100]\n  CRS0 @offset 0x10\n  CRS1 @offset 0x110\n  CRS2 @offset 0x210\n  CRS3 @offset 0x310\n  CRS4 @offset 0x410 $u32 {\n    RO // at 31: Read Only\n    HLP // at 30: Halt Low Priority\n    20\n    ARB:2 // at 8: Arbitration Mode\n    2\n    PCTL:2 // at 4: Parking Control\n    1\n    PARK:3 // at 0: Park\n  }\n\n//---  Registers MGPCR(0,1,2,3,4,5,6): Master General Purpose Control Register\n  MGPCR [7 @offset 0x800 @inc 0x100]\n  MGPCR0 @offset 0x800\n  MGPCR1 @offset 0x900\n  MGPCR2 @offset 0xa00\n  MGPCR3 @offset 0xb00\n  MGPCR4 @offset 0xc00\n  MGPCR5 @offset 0xd00\n  MGPCR6 @offset 0xe00 $u32 {\n    29\n    AULB:3 // at 0: Arbitrates On Undefined Length Bursts\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: CAN [2]\n//        CAN0 at 0x40024000\n//        CAN1 at 0x400a4000\n//------------------------------------------------------------------------------\n\nregisters CAN [2 @at 0x40024000 0x400a4000]\n          CAN0 @at 0x40024000\n          CAN1 @at 0x400a4000 {\n//---  Register MCR: Module Configuration Register\n  MCR @offset 0x0 $u32 {\n    MDIS // at 31: Module Disable\n    FRZ // at 30: Freeze Enable\n    RFEN // at 29: Rx FIFO Enable\n    HALT // at 28: Halt FlexCAN\n    NOTRDY // at 27: FlexCAN Not Ready\n    WAKMSK // at 26: Wake Up Interrupt Mask\n    SOFTRST // at 25: Soft Reset\n    FRZACK // at 24: Freeze Mode Acknowledge\n    SUPV // at 23: Supervisor Mode\n    SLFWAK // at 22: Self Wake Up\n    WRNEN // at 21: Warning Interrupt Enable\n    LPMACK // at 20: Low-Power Mode Acknowledge\n    WAKSRC // at 19: Wake Up Source\n    1\n    SRXDIS // at 17: Self Reception Disable\n    IRMQ // at 16: Individual Rx Masking And Queue Enable\n    2\n    LPRIOEN // at 13: Local Priority Enable\n    AEN // at 12: Abort Enable\n    2\n    IDAM:2 // at 8: ID Acceptance Mode\n    1\n    MAXMB:7 // at 0: Number Of The Last Message Buffer\n  }\n\n//---  Register CTRL1: Control 1 register\n  CTRL1 @offset 0x4 $u32 {\n    PRESDIV:8 // at 24: Prescaler Division Factor\n    RJW:2 // at 22: Resync Jump Width\n    PSEG1:3 // at 19: Phase Segment 1\n    PSEG2:3 // at 16: Phase Segment 2\n    BOFFMSK // at 15: Bus Off Mask\n    ERRMSK // at 14: Error Mask\n    CLKSRC // at 13: CAN Engine Clock Source\n    LPB // at 12: Loop Back Mode\n    TWRNMSK // at 11: Tx Warning Interrupt Mask\n    RWRNMSK // at 10: Rx Warning Interrupt Mask\n    2\n    SMP // at 7: CAN Bit Sampling\n    BOFFREC // at 6: Bus Off Recovery\n    TSYN // at 5: Timer Sync\n    LBUF // at 4: Lowest Buffer Transmitted First\n    LOM // at 3: Listen-Only Mode\n    PROPSEG:3 // at 0: Propagation Segment\n  }\n\n//---  Register TIMER: Free Running Timer\n  TIMER @offset 0x8 $u32 {\n    16\n    TIMER:16 // at 0: Timer Value\n  }\n\n//---  Register RXMGMASK: Rx Mailboxes Global Mask Register\n  RXMGMASK @offset 0x10 $u32 {\n    MG:32 // at 0: Rx Mailboxes Global Mask Bits\n  }\n\n//---  Register RX14MASK: Rx 14 Mask register\n  RX14MASK @offset 0x14 $u32 {\n    RX14M:32 // at 0: Rx Buffer 14 Mask Bits\n  }\n\n//---  Register RX15MASK: Rx 15 Mask register\n  RX15MASK @offset 0x18 $u32 {\n    RX15M:32 // at 0: Rx Buffer 15 Mask Bits\n  }\n\n//---  Register ECR: Error Counter\n  ECR @offset 0x1c $u32 {\n    16\n    RXERRCNT:8 // at 8: Receive Error Counter\n    TXERRCNT:8 // at 0: Transmit Error Counter\n  }\n\n//---  Register ESR1: Error and Status 1 register\n  ESR1 @offset 0x20 $u32 {\n    13\n    SYNCH // at 18: CAN Synchronization Status\n    TWRNINT // at 17: Tx Warning Interrupt Flag\n    RWRNINT // at 16: Rx Warning Interrupt Flag\n    BIT1ERR // at 15: Bit1 Error\n    BIT0ERR // at 14: Bit0 Error\n    ACKERR // at 13: Acknowledge Error\n    CRCERR // at 12: Cyclic Redundancy Check Error\n    FRMERR // at 11: Form Error\n    STFERR // at 10: Stuffing Error\n    TXWRN // at 9: TX Error Warning\n    RXWRN // at 8: Rx Error Warning\n    IDLE // at 7: This bit indicates when CAN bus is in IDLE state\n    TX // at 6: FlexCAN In Transmission\n    FLTCONF:2 // at 4: Fault Confinement State\n    RX // at 3: FlexCAN In Reception\n    BOFFINT // at 2: Bus Off Interrupt\n    ERRINT // at 1: Error Interrupt\n    WAKINT // at 0: Wake-Up Interrupt\n  }\n\n//---  Register IMASK1: Interrupt Masks 1 register\n  IMASK1 @offset 0x28 $u32 {\n    BUFLM:32 // at 0: Buffer MB i Mask\n  }\n\n//---  Register IFLAG1: Interrupt Flags 1 register\n  IFLAG1 @offset 0x30 $u32 {\n    BUF31TO8I:24 // at 8: Buffer MBi Interrupt\n    BUF7I // at 7: Buffer MB7 Interrupt Or \"Rx FIFO Overflow\"\n    BUF6I // at 6: Buffer MB6 Interrupt Or \"Rx FIFO Warning\"\n    BUF5I // at 5: Buffer MB5 Interrupt Or \"Frames available in Rx FIFO\"\n    BUF4TO1I:4 // at 1: Buffer MB i Interrupt Or \"reserved\"\n    BUF0I // at 0: Buffer MB0 Interrupt Or \"reserved\"\n  }\n\n//---  Register CTRL2: Control 2 register\n  CTRL2 @offset 0x34 $u32 {\n    3\n    WRMFRZ // at 28: Write-Access To Memory In Freeze Mode\n    RFFN:4 // at 24: Number Of Rx FIFO Filters\n    TASD:5 // at 19: Tx Arbitration Start Delay\n    MRP // at 18: Mailboxes Reception Priority\n    RRS // at 17: Remote Request Storing\n    EACEN // at 16: Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes\n    16\n  }\n\n//---  Register ESR2: Error and Status 2 register\n  ESR2 @offset 0x38 @ro $u32 {\n    9\n    LPTM:7 // at 16: Lowest Priority Tx Mailbox\n    1\n    VPS // at 14: Valid Priority Status\n    IMB // at 13: Inactive Mailbox\n    13\n  }\n\n//---  Register CRCR: CRC Register\n  CRCR @offset 0x44 @ro $u32 {\n    9\n    MBCRC:7 // at 16: CRC Mailbox\n    1\n    TXCRC:15 // at 0: CRC Transmitted\n  }\n\n//---  Register RXFGMASK: Rx FIFO Global Mask register\n  RXFGMASK @offset 0x48 $u32 {\n    FGM:32 // at 0: Rx FIFO Global Mask Bits\n  }\n\n//---  Register RXFIR: Rx FIFO Information Register\n  RXFIR @offset 0x4c @ro $u32 {\n    23\n    IDHIT:9 // at 0: Identifier Acceptance Filter Hit Indicator\n  }\n\n//---  Register CS0: Message Buffer 0 CS Register\n  CS0 @offset 0x80 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID0: Message Buffer 0 ID Register\n  ID0 @offset 0x84 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD00: Message Buffer 0 WORD0 Register\n  WORD00 @offset 0x88 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD10: Message Buffer 0 WORD1 Register\n  WORD10 @offset 0x8c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS1: Message Buffer 1 CS Register\n  CS1 @offset 0x90 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID1: Message Buffer 1 ID Register\n  ID1 @offset 0x94 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD01: Message Buffer 1 WORD0 Register\n  WORD01 @offset 0x98 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD11: Message Buffer 1 WORD1 Register\n  WORD11 @offset 0x9c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS2: Message Buffer 2 CS Register\n  CS2 @offset 0xa0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID2: Message Buffer 2 ID Register\n  ID2 @offset 0xa4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD02: Message Buffer 2 WORD0 Register\n  WORD02 @offset 0xa8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD12: Message Buffer 2 WORD1 Register\n  WORD12 @offset 0xac $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS3: Message Buffer 3 CS Register\n  CS3 @offset 0xb0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID3: Message Buffer 3 ID Register\n  ID3 @offset 0xb4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD03: Message Buffer 3 WORD0 Register\n  WORD03 @offset 0xb8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD13: Message Buffer 3 WORD1 Register\n  WORD13 @offset 0xbc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS4: Message Buffer 4 CS Register\n  CS4 @offset 0xc0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID4: Message Buffer 4 ID Register\n  ID4 @offset 0xc4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD04: Message Buffer 4 WORD0 Register\n  WORD04 @offset 0xc8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD14: Message Buffer 4 WORD1 Register\n  WORD14 @offset 0xcc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS5: Message Buffer 5 CS Register\n  CS5 @offset 0xd0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID5: Message Buffer 5 ID Register\n  ID5 @offset 0xd4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD05: Message Buffer 5 WORD0 Register\n  WORD05 @offset 0xd8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD15: Message Buffer 5 WORD1 Register\n  WORD15 @offset 0xdc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS6: Message Buffer 6 CS Register\n  CS6 @offset 0xe0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID6: Message Buffer 6 ID Register\n  ID6 @offset 0xe4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD06: Message Buffer 6 WORD0 Register\n  WORD06 @offset 0xe8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD16: Message Buffer 6 WORD1 Register\n  WORD16 @offset 0xec $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS7: Message Buffer 7 CS Register\n  CS7 @offset 0xf0 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID7: Message Buffer 7 ID Register\n  ID7 @offset 0xf4 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD07: Message Buffer 7 WORD0 Register\n  WORD07 @offset 0xf8 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD17: Message Buffer 7 WORD1 Register\n  WORD17 @offset 0xfc $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS8: Message Buffer 8 CS Register\n  CS8 @offset 0x100 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID8: Message Buffer 8 ID Register\n  ID8 @offset 0x104 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD08: Message Buffer 8 WORD0 Register\n  WORD08 @offset 0x108 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD18: Message Buffer 8 WORD1 Register\n  WORD18 @offset 0x10c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS9: Message Buffer 9 CS Register\n  CS9 @offset 0x110 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID9: Message Buffer 9 ID Register\n  ID9 @offset 0x114 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD09: Message Buffer 9 WORD0 Register\n  WORD09 @offset 0x118 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD19: Message Buffer 9 WORD1 Register\n  WORD19 @offset 0x11c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS10: Message Buffer 10 CS Register\n  CS10 @offset 0x120 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID10: Message Buffer 10 ID Register\n  ID10 @offset 0x124 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD010: Message Buffer 10 WORD0 Register\n  WORD010 @offset 0x128 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD110: Message Buffer 10 WORD1 Register\n  WORD110 @offset 0x12c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS11: Message Buffer 11 CS Register\n  CS11 @offset 0x130 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID11: Message Buffer 11 ID Register\n  ID11 @offset 0x134 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD011: Message Buffer 11 WORD0 Register\n  WORD011 @offset 0x138 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD111: Message Buffer 11 WORD1 Register\n  WORD111 @offset 0x13c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS12: Message Buffer 12 CS Register\n  CS12 @offset 0x140 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID12: Message Buffer 12 ID Register\n  ID12 @offset 0x144 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD012: Message Buffer 12 WORD0 Register\n  WORD012 @offset 0x148 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD112: Message Buffer 12 WORD1 Register\n  WORD112 @offset 0x14c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS13: Message Buffer 13 CS Register\n  CS13 @offset 0x150 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID13: Message Buffer 13 ID Register\n  ID13 @offset 0x154 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD013: Message Buffer 13 WORD0 Register\n  WORD013 @offset 0x158 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD113: Message Buffer 13 WORD1 Register\n  WORD113 @offset 0x15c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS14: Message Buffer 14 CS Register\n  CS14 @offset 0x160 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID14: Message Buffer 14 ID Register\n  ID14 @offset 0x164 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD014: Message Buffer 14 WORD0 Register\n  WORD014 @offset 0x168 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD114: Message Buffer 14 WORD1 Register\n  WORD114 @offset 0x16c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Register CS15: Message Buffer 15 CS Register\n  CS15 @offset 0x170 $u32 {\n    4\n    CODE:4 // at 24: Reserved\n    1\n    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.\n    IDE // at 21: ID Extended. One/zero for extended/standard format frame.\n    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.\n    DLC:4 // at 16: Length of the data to be stored/transmitted.\n    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.\n  }\n\n//---  Register ID15: Message Buffer 15 ID Register\n  ID15 @offset 0x174 $u32 {\n    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.\n    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.\n    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.\n  }\n\n//---  Register WORD015: Message Buffer 15 WORD0 Register\n  WORD015 @offset 0x178 $u32 {\n    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.\n    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.\n    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.\n    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.\n  }\n\n//---  Register WORD115: Message Buffer 15 WORD1 Register\n  WORD115 @offset 0x17c $u32 {\n    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.\n    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.\n    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.\n    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.\n  }\n\n//---  Registers RXIMR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Rx Individual Mask Registers\n  RXIMR [16 @offset 0x880 @inc 0x4]\n  RXIMR0 @offset 0x880\n  RXIMR1 @offset 0x884\n  RXIMR2 @offset 0x888\n  RXIMR3 @offset 0x88c\n  RXIMR4 @offset 0x890\n  RXIMR5 @offset 0x894\n  RXIMR6 @offset 0x898\n  RXIMR7 @offset 0x89c\n  RXIMR8 @offset 0x8a0\n  RXIMR9 @offset 0x8a4\n  RXIMR10 @offset 0x8a8\n  RXIMR11 @offset 0x8ac\n  RXIMR12 @offset 0x8b0\n  RXIMR13 @offset 0x8b4\n  RXIMR14 @offset 0x8b8\n  RXIMR15 @offset 0x8bc $u32 {\n    MI:32 // at 0: Individual Mask Bits\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral CAU: Memory Mapped Cryptographic Acceleration Unit (MMCAU)\n//------------------------------------------------------------------------------\n\nregisters CAU @at 0xe0081000 {\n//---  Register CAU_DIRECT0: Direct access register 0\n  CAU_DIRECT0 @offset 0x0 $u32 {\n    CAU_DIRECT0:32 // at 0: Direct register 0\n  }\n\n//---  Register CAU_DIRECT1: Direct access register 1\n  CAU_DIRECT1 @offset 0x4 $u32 {\n    CAU_DIRECT1:32 // at 0: Direct register 1\n  }\n\n//---  Register CAU_DIRECT2: Direct access register 2\n  CAU_DIRECT2 @offset 0x8 $u32 {\n    CAU_DIRECT2:32 // at 0: Direct register 2\n  }\n\n//---  Register CAU_DIRECT3: Direct access register 3\n  CAU_DIRECT3 @offset 0xc $u32 {\n    CAU_DIRECT3:32 // at 0: Direct register 3\n  }\n\n//---  Register CAU_DIRECT4: Direct access register 4\n  CAU_DIRECT4 @offset 0x10 $u32 {\n    CAU_DIRECT4:32 // at 0: Direct register 4\n  }\n\n//---  Register CAU_DIRECT5: Direct access register 5\n  CAU_DIRECT5 @offset 0x14 $u32 {\n    CAU_DIRECT5:32 // at 0: Direct register 5\n  }\n\n//---  Register CAU_DIRECT6: Direct access register 6\n  CAU_DIRECT6 @offset 0x18 $u32 {\n    CAU_DIRECT6:32 // at 0: Direct register 6\n  }\n\n//---  Register CAU_DIRECT7: Direct access register 7\n  CAU_DIRECT7 @offset 0x1c $u32 {\n    CAU_DIRECT7:32 // at 0: Direct register 7\n  }\n\n//---  Register CAU_DIRECT8: Direct access register 8\n  CAU_DIRECT8 @offset 0x20 $u32 {\n    CAU_DIRECT8:32 // at 0: Direct register 8\n  }\n\n//---  Register CAU_DIRECT9: Direct access register 9\n  CAU_DIRECT9 @offset 0x24 $u32 {\n    CAU_DIRECT9:32 // at 0: Direct register 9\n  }\n\n//---  Register CAU_DIRECT10: Direct access register 10\n  CAU_DIRECT10 @offset 0x28 $u32 {\n    CAU_DIRECT10:32 // at 0: Direct register 10\n  }\n\n//---  Register CAU_DIRECT11: Direct access register 11\n  CAU_DIRECT11 @offset 0x2c $u32 {\n    CAU_DIRECT11:32 // at 0: Direct register 11\n  }\n\n//---  Register CAU_DIRECT12: Direct access register 12\n  CAU_DIRECT12 @offset 0x30 $u32 {\n    CAU_DIRECT12:32 // at 0: Direct register 12\n  }\n\n//---  Register CAU_DIRECT13: Direct access register 13\n  CAU_DIRECT13 @offset 0x34 $u32 {\n    CAU_DIRECT13:32 // at 0: Direct register 13\n  }\n\n//---  Register CAU_DIRECT14: Direct access register 14\n  CAU_DIRECT14 @offset 0x38 $u32 {\n    CAU_DIRECT14:32 // at 0: Direct register 14\n  }\n\n//---  Register CAU_DIRECT15: Direct access register 15\n  CAU_DIRECT15 @offset 0x3c $u32 {\n    CAU_DIRECT15:32 // at 0: Direct register 15\n  }\n\n//---  Register CAU_LDR_CASR: Status register - Load Register command\n  CAU_LDR_CASR @offset 0x840 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_LDR_CAA: Accumulator register - Load Register command\n  CAU_LDR_CAA @offset 0x844 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_LDR_CA0: General Purpose Register 0 - Load Register command\n  CAU_LDR_CA0 @offset 0x848 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_LDR_CA1: General Purpose Register 1 - Load Register command\n  CAU_LDR_CA1 @offset 0x84c $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_LDR_CA2: General Purpose Register 2 - Load Register command\n  CAU_LDR_CA2 @offset 0x850 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_LDR_CA3: General Purpose Register 3 - Load Register command\n  CAU_LDR_CA3 @offset 0x854 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_LDR_CA4: General Purpose Register 4 - Load Register command\n  CAU_LDR_CA4 @offset 0x858 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_LDR_CA5: General Purpose Register 5 - Load Register command\n  CAU_LDR_CA5 @offset 0x85c $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_LDR_CA6: General Purpose Register 6 - Load Register command\n  CAU_LDR_CA6 @offset 0x860 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_LDR_CA7: General Purpose Register 7 - Load Register command\n  CAU_LDR_CA7 @offset 0x864 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_LDR_CA8: General Purpose Register 8 - Load Register command\n  CAU_LDR_CA8 @offset 0x868 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_STR_CASR: Status register - Store Register command\n  CAU_STR_CASR @offset 0x880 @ro $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_STR_CAA: Accumulator register - Store Register command\n  CAU_STR_CAA @offset 0x884 @ro $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_STR_CA0: General Purpose Register 0 - Store Register command\n  CAU_STR_CA0 @offset 0x888 @ro $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_STR_CA1: General Purpose Register 1 - Store Register command\n  CAU_STR_CA1 @offset 0x88c @ro $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_STR_CA2: General Purpose Register 2 - Store Register command\n  CAU_STR_CA2 @offset 0x890 @ro $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_STR_CA3: General Purpose Register 3 - Store Register command\n  CAU_STR_CA3 @offset 0x894 @ro $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_STR_CA4: General Purpose Register 4 - Store Register command\n  CAU_STR_CA4 @offset 0x898 @ro $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_STR_CA5: General Purpose Register 5 - Store Register command\n  CAU_STR_CA5 @offset 0x89c @ro $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_STR_CA6: General Purpose Register 6 - Store Register command\n  CAU_STR_CA6 @offset 0x8a0 @ro $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_STR_CA7: General Purpose Register 7 - Store Register command\n  CAU_STR_CA7 @offset 0x8a4 @ro $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_STR_CA8: General Purpose Register 8 - Store Register command\n  CAU_STR_CA8 @offset 0x8a8 @ro $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_ADR_CASR: Status register - Add Register command\n  CAU_ADR_CASR @offset 0x8c0 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_ADR_CAA: Accumulator register - Add to register command\n  CAU_ADR_CAA @offset 0x8c4 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_ADR_CA0: General Purpose Register 0 - Add to register command\n  CAU_ADR_CA0 @offset 0x8c8 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_ADR_CA1: General Purpose Register 1 - Add to register command\n  CAU_ADR_CA1 @offset 0x8cc $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_ADR_CA2: General Purpose Register 2 - Add to register command\n  CAU_ADR_CA2 @offset 0x8d0 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_ADR_CA3: General Purpose Register 3 - Add to register command\n  CAU_ADR_CA3 @offset 0x8d4 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_ADR_CA4: General Purpose Register 4 - Add to register command\n  CAU_ADR_CA4 @offset 0x8d8 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_ADR_CA5: General Purpose Register 5 - Add to register command\n  CAU_ADR_CA5 @offset 0x8dc $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_ADR_CA6: General Purpose Register 6 - Add to register command\n  CAU_ADR_CA6 @offset 0x8e0 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_ADR_CA7: General Purpose Register 7 - Add to register command\n  CAU_ADR_CA7 @offset 0x8e4 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_ADR_CA8: General Purpose Register 8 - Add to register command\n  CAU_ADR_CA8 @offset 0x8e8 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_RADR_CASR: Status register - Reverse and Add to Register command\n  CAU_RADR_CASR @offset 0x900 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command\n  CAU_RADR_CAA @offset 0x904 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command\n  CAU_RADR_CA0 @offset 0x908 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command\n  CAU_RADR_CA1 @offset 0x90c $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command\n  CAU_RADR_CA2 @offset 0x910 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command\n  CAU_RADR_CA3 @offset 0x914 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command\n  CAU_RADR_CA4 @offset 0x918 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command\n  CAU_RADR_CA5 @offset 0x91c $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command\n  CAU_RADR_CA6 @offset 0x920 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command\n  CAU_RADR_CA7 @offset 0x924 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command\n  CAU_RADR_CA8 @offset 0x928 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_XOR_CASR: Status register - Exclusive Or command\n  CAU_XOR_CASR @offset 0x980 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_XOR_CAA: Accumulator register - Exclusive Or command\n  CAU_XOR_CAA @offset 0x984 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command\n  CAU_XOR_CA0 @offset 0x988 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command\n  CAU_XOR_CA1 @offset 0x98c $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command\n  CAU_XOR_CA2 @offset 0x990 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command\n  CAU_XOR_CA3 @offset 0x994 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command\n  CAU_XOR_CA4 @offset 0x998 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command\n  CAU_XOR_CA5 @offset 0x99c $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command\n  CAU_XOR_CA6 @offset 0x9a0 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command\n  CAU_XOR_CA7 @offset 0x9a4 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command\n  CAU_XOR_CA8 @offset 0x9a8 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_ROTL_CASR: Status register - Rotate Left command\n  CAU_ROTL_CASR @offset 0x9c0 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_ROTL_CAA: Accumulator register - Rotate Left command\n  CAU_ROTL_CAA @offset 0x9c4 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command\n  CAU_ROTL_CA0 @offset 0x9c8 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command\n  CAU_ROTL_CA1 @offset 0x9cc $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command\n  CAU_ROTL_CA2 @offset 0x9d0 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command\n  CAU_ROTL_CA3 @offset 0x9d4 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command\n  CAU_ROTL_CA4 @offset 0x9d8 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command\n  CAU_ROTL_CA5 @offset 0x9dc $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command\n  CAU_ROTL_CA6 @offset 0x9e0 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command\n  CAU_ROTL_CA7 @offset 0x9e4 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command\n  CAU_ROTL_CA8 @offset 0x9e8 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_AESC_CASR: Status register - AES Column Operation command\n  CAU_AESC_CASR @offset 0xb00 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_AESC_CAA: Accumulator register - AES Column Operation command\n  CAU_AESC_CAA @offset 0xb04 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command\n  CAU_AESC_CA0 @offset 0xb08 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command\n  CAU_AESC_CA1 @offset 0xb0c $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command\n  CAU_AESC_CA2 @offset 0xb10 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command\n  CAU_AESC_CA3 @offset 0xb14 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command\n  CAU_AESC_CA4 @offset 0xb18 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command\n  CAU_AESC_CA5 @offset 0xb1c $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command\n  CAU_AESC_CA6 @offset 0xb20 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command\n  CAU_AESC_CA7 @offset 0xb24 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command\n  CAU_AESC_CA8 @offset 0xb28 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n//---  Register CAU_AESIC_CASR: Status register - AES Inverse Column Operation command\n  CAU_AESIC_CASR @offset 0xb40 $u32 {\n    VER:4 // at 28: CAU version\n    26\n    DPE // at 1: no description available\n    IC // at 0: no description available\n  }\n\n//---  Register CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command\n  CAU_AESIC_CAA @offset 0xb44 $u32 {\n    ACC:32 // at 0: ACC\n  }\n\n//---  Register CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command\n  CAU_AESIC_CA0 @offset 0xb48 $u32 {\n    CA0:32 // at 0: CA0\n  }\n\n//---  Register CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command\n  CAU_AESIC_CA1 @offset 0xb4c $u32 {\n    CA1:32 // at 0: CA1\n  }\n\n//---  Register CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command\n  CAU_AESIC_CA2 @offset 0xb50 $u32 {\n    CA2:32 // at 0: CA2\n  }\n\n//---  Register CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command\n  CAU_AESIC_CA3 @offset 0xb54 $u32 {\n    CA3:32 // at 0: CA3\n  }\n\n//---  Register CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command\n  CAU_AESIC_CA4 @offset 0xb58 $u32 {\n    CA4:32 // at 0: CA4\n  }\n\n//---  Register CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command\n  CAU_AESIC_CA5 @offset 0xb5c $u32 {\n    CA5:32 // at 0: CA5\n  }\n\n//---  Register CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command\n  CAU_AESIC_CA6 @offset 0xb60 $u32 {\n    CA6:32 // at 0: CA6\n  }\n\n//---  Register CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command\n  CAU_AESIC_CA7 @offset 0xb64 $u32 {\n    CA7:32 // at 0: CA7\n  }\n\n//---  Register CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command\n  CAU_AESIC_CA8 @offset 0xb68 $u32 {\n    CA8:32 // at 0: CA8\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: CMP [4]\n//        CMP0 at 0x40073000\n//        CMP1 at 0x40073008\n//        CMP2 at 0x40073010\n//        CMP3 at 0x40073018\n//------------------------------------------------------------------------------\n\nregisters CMP [4 @at 0x40073000 0x40073008 0x40073010 0x40073018]\n          CMP0 @at 0x40073000\n          CMP1 @at 0x40073008\n          CMP2 @at 0x40073010\n          CMP3 @at 0x40073018 {\n//---  Register CR0: CMP Control Register 0\n  CR0 @offset 0x0 $u8 {\n    1\n    FILTER_CNT:3 // at 4: Filter Sample Count\n    2\n    HYSTCTR:2 // at 0: Comparator hard block hysteresis control\n  }\n\n//---  Register CR1: CMP Control Register 1\n  CR1 @offset 0x1 $u8 {\n    SE // at 7: Sample Enable\n    WE // at 6: Windowing Enable\n    TRIGM // at 5: Trigger Mode Enable\n    PMODE // at 4: Power Mode Select\n    INV // at 3: Comparator INVERT\n    COS // at 2: Comparator Output Select\n    OPE // at 1: Comparator Output Pin Enable\n    EN // at 0: Comparator Module Enable\n  }\n\n//---  Register FPR: CMP Filter Period Register\n  FPR @offset 0x2 $u8 {\n    FILT_PER:8 // at 0: Filter Sample Period\n  }\n\n//---  Register SCR: CMP Status and Control Register\n  SCR @offset 0x3 $u8 {\n    1\n    DMAEN // at 6: DMA Enable Control\n    1\n    IER // at 4: Comparator Interrupt Enable Rising\n    IEF // at 3: Comparator Interrupt Enable Falling\n    CFR // at 2: Analog Comparator Flag Rising\n    CFF // at 1: Analog Comparator Flag Falling\n    COUT // at 0: Analog Comparator Output\n  }\n\n//---  Register DACCR: DAC Control Register\n  DACCR @offset 0x4 $u8 {\n    DACEN // at 7: DAC Enable\n    VRSEL // at 6: Supply Voltage Reference Source Select\n    VOSEL:6 // at 0: DAC Output Voltage Select\n  }\n\n//---  Register MUXCR: MUX Control Register\n  MUXCR @offset 0x5 $u8 {\n    PSTM // at 7: Pass Through Mode Enable\n    1\n    PSEL:3 // at 3: Plus Input Mux Control\n    MSEL:3 // at 0: Minus Input Mux Control\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral CMT: Carrier Modulator Transmitter\n//------------------------------------------------------------------------------\n\nregisters CMT @at 0x40062000 {\n//---  Register CGH1: CMT Carrier Generator High Data Register 1\n  CGH1 @offset 0x0 $u8 {\n    PH:8 // at 0: Primary Carrier High Time Data Value\n  }\n\n//---  Register CGL1: CMT Carrier Generator Low Data Register 1\n  CGL1 @offset 0x1 $u8 {\n    PL:8 // at 0: Primary Carrier Low Time Data Value\n  }\n\n//---  Register CGH2: CMT Carrier Generator High Data Register 2\n  CGH2 @offset 0x2 $u8 {\n    SH:8 // at 0: Secondary Carrier High Time Data Value\n  }\n\n//---  Register CGL2: CMT Carrier Generator Low Data Register 2\n  CGL2 @offset 0x3 $u8 {\n    SL:8 // at 0: Secondary Carrier Low Time Data Value\n  }\n\n//---  Register OC: CMT Output Control Register\n  OC @offset 0x4 $u8 {\n    IROL // at 7: IRO Latch Control\n    CMTPOL // at 6: CMT Output Polarity\n    IROPEN // at 5: IRO Pin Enable\n    5\n  }\n\n//---  Register MSC: CMT Modulator Status and Control Register\n  MSC @offset 0x5 $u8 {\n    EOCF // at 7: End Of Cycle Status Flag\n    CMTDIV:2 // at 5: CMT Clock Divide Prescaler\n    EXSPC // at 4: Extended Space Enable\n    BASE // at 3: Baseband Enable\n    FSK // at 2: FSK Mode Select\n    EOCIE // at 1: End of Cycle Interrupt Enable\n    MCGEN // at 0: Modulator and Carrier Generator Enable\n  }\n\n//---  Register CMD1: CMT Modulator Data Register Mark High\n  CMD1 @offset 0x6 $u8 {\n    MB:8 // at 0: MB[15:8]\n  }\n\n//---  Register CMD2: CMT Modulator Data Register Mark Low\n  CMD2 @offset 0x7 $u8 {\n    MB:8 // at 0: MB[7:0]\n  }\n\n//---  Register CMD3: CMT Modulator Data Register Space High\n  CMD3 @offset 0x8 $u8 {\n    SB:8 // at 0: SB[15:8]\n  }\n\n//---  Register CMD4: CMT Modulator Data Register Space Low\n  CMD4 @offset 0x9 $u8 {\n    SB:8 // at 0: SB[7:0]\n  }\n\n//---  Register PPS: CMT Primary Prescaler Register\n  PPS @offset 0xa $u8 {\n    4\n    PPSDIV:4 // at 0: Primary Prescaler Divider\n  }\n\n//---  Register DMA: CMT Direct Memory Access Register\n  DMA @offset 0xb $u8 {\n    7\n    DMA // at 0: DMA Enable\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral CRC: Cyclic Redundancy Check\n//------------------------------------------------------------------------------\n\nregisters CRC @at 0x40032000 {\n//---  Register DATA: CRC Data register\n  DATA @offset 0x0 $u32 {\n    HU:8 // at 24: CRC High Upper Byte\n    HL:8 // at 16: CRC High Lower Byte\n    LU:8 // at 8: CRC Low Upper Byte\n    LL:8 // at 0: CRC Low Lower Byte\n  }\n\n//---  Register DATAL: CRC_DATAL register.\n  DATAL @offset 0x0 $u16 {\n    DATAL:16 // at 0: DATAL stores the lower 16 bits of the 16/32 bit CRC\n  }\n\n//---  Register DATALL: CRC_DATALL register.\n  DATALL @offset 0x0 $u8 {\n    DATALL:8 // at 0: CRCLL stores the first 8 bits of the 32 bit DATA\n  }\n\n//---  Register DATALU: CRC_DATALU register.\n  DATALU @offset 0x1 $u8 {\n    DATALU:8 // at 0: DATALL stores the second 8 bits of the 32 bit CRC\n  }\n\n//---  Register DATAH: CRC_DATAH register.\n  DATAH @offset 0x2 $u16 {\n    DATAH:16 // at 0: DATAH stores the high 16 bits of the 16/32 bit CRC\n  }\n\n//---  Register DATAHL: CRC_DATAHL register.\n  DATAHL @offset 0x2 $u8 {\n    DATAHL:8 // at 0: DATAHL stores the third 8 bits of the 32 bit CRC\n  }\n\n//---  Register DATAHU: CRC_DATAHU register.\n  DATAHU @offset 0x3 $u8 {\n    DATAHU:8 // at 0: DATAHU stores the fourth 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLY: CRC Polynomial register\n  GPOLY @offset 0x4 $u32 {\n    HIGH:16 // at 16: High Polynominal Half-word\n    LOW:16 // at 0: Low Polynominal Half-word\n  }\n\n//---  Register GPOLYL: CRC_GPOLYL register.\n  GPOLYL @offset 0x4 $u16 {\n    GPOLYL:16 // at 0: POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value\n  }\n\n//---  Register GPOLYLL: CRC_GPOLYLL register.\n  GPOLYLL @offset 0x4 $u8 {\n    GPOLYLL:8 // at 0: POLYLL stores the first 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLYLU: CRC_GPOLYLU register.\n  GPOLYLU @offset 0x5 $u8 {\n    GPOLYLU:8 // at 0: POLYLL stores the second 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLYH: CRC_GPOLYH register.\n  GPOLYH @offset 0x6 $u16 {\n    GPOLYH:16 // at 0: POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value\n  }\n\n//---  Register GPOLYHL: CRC_GPOLYHL register.\n  GPOLYHL @offset 0x6 $u8 {\n    GPOLYHL:8 // at 0: POLYHL stores the third 8 bits of the 32 bit CRC\n  }\n\n//---  Register GPOLYHU: CRC_GPOLYHU register.\n  GPOLYHU @offset 0x7 $u8 {\n    GPOLYHU:8 // at 0: POLYHU stores the fourth 8 bits of the 32 bit CRC\n  }\n\n//---  Register CTRL: CRC Control register\n  CTRL @offset 0x8 $u32 {\n    TOT:2 // at 30: Type Of Transpose For Writes\n    TOTR:2 // at 28: Type Of Transpose For Read\n    1\n    FXOR // at 26: Complement Read Of CRC Data Register\n    WAS // at 25: Write CRC Data Register As Seed\n    TCRC // at 24: Width of CRC protocol.\n    24\n  }\n\n//---  Register CTRLHU: CRC_CTRLHU register.\n  CTRLHU @offset 0xb $u8 {\n    TOT:2 // at 6: no description available\n    TOTR:2 // at 4: no description available\n    1\n    FXOR // at 2: no description available\n    WAS // at 1: no description available\n    TCRC // at 0: no description available\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: DAC [2]\n//        DAC0 at 0x400cc000\n//        DAC1 at 0x400cd000\n//------------------------------------------------------------------------------\n\nregisters DAC [2 @at 0x400cc000 0x400cd000]\n          DAC0 @at 0x400cc000\n          DAC1 @at 0x400cd000 {\n//---  Registers DATL(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data Low Register\n  DATL [16 @offset 0x0 @inc 0x2]\n  DAT0L @offset 0x0\n  DAT1L @offset 0x2\n  DAT2L @offset 0x4\n  DAT3L @offset 0x6\n  DAT4L @offset 0x8\n  DAT5L @offset 0xa\n  DAT6L @offset 0xc\n  DAT7L @offset 0xe\n  DAT8L @offset 0x10\n  DAT9L @offset 0x12\n  DAT10L @offset 0x14\n  DAT11L @offset 0x16\n  DAT12L @offset 0x18\n  DAT13L @offset 0x1a\n  DAT14L @offset 0x1c\n  DAT15L @offset 0x1e $u8 {\n    DATA0:8 // at 0: DATA0\n  }\n\n//---  Registers DATH(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data High Register\n  DATH [16 @offset 0x1 @inc 0x2]\n  DAT0H @offset 0x1\n  DAT1H @offset 0x3\n  DAT2H @offset 0x5\n  DAT3H @offset 0x7\n  DAT4H @offset 0x9\n  DAT5H @offset 0xb\n  DAT6H @offset 0xd\n  DAT7H @offset 0xf\n  DAT8H @offset 0x11\n  DAT9H @offset 0x13\n  DAT10H @offset 0x15\n  DAT11H @offset 0x17\n  DAT12H @offset 0x19\n  DAT13H @offset 0x1b\n  DAT14H @offset 0x1d\n  DAT15H @offset 0x1f $u8 {\n    4\n    DATA1:4 // at 0: DATA1\n  }\n\n//---  Register SR: DAC Status Register\n  SR @offset 0x20 $u8 {\n    5\n    DACBFWMF // at 2: DAC Buffer Watermark Flag\n    DACBFRPTF // at 1: DAC Buffer Read Pointer Top Position Flag\n    DACBFRPBF // at 0: DAC Buffer Read Pointer Bottom Position Flag\n  }\n\n//---  Register C0: DAC Control Register\n  C0 @offset 0x21 $u8 {\n    DACEN // at 7: DAC Enable\n    DACRFS // at 6: DAC Reference Select\n    DACTRGSEL // at 5: DAC Trigger Select\n    DACSWTRG // at 4: DAC Software Trigger\n    LPEN // at 3: DAC Low Power Control\n    DACBWIEN // at 2: DAC Buffer Watermark Interrupt Enable\n    DACBTIEN // at 1: DAC Buffer Read Pointer Top Flag Interrupt Enable\n    DACBBIEN // at 0: DAC Buffer Read Pointer Bottom Flag Interrupt Enable\n  }\n\n//---  Register C1: DAC Control Register 1\n  C1 @offset 0x22 $u8 {\n    DMAEN // at 7: DMA Enable Select\n    2\n    DACBFWM:2 // at 3: DAC Buffer Watermark Select\n    DACBFMD:2 // at 1: DAC Buffer Work Mode Select\n    DACBFEN // at 0: DAC Buffer Enable\n  }\n\n//---  Register C2: DAC Control Register 2\n  C2 @offset 0x23 $u8 {\n    DACBFRP:4 // at 4: DAC Buffer Read Pointer\n    DACBFUP:4 // at 0: DAC Buffer Upper Limit\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral DMA: Enhanced direct memory access controller\n//------------------------------------------------------------------------------\n\nregisters DMA @at 0x40008000 {\n//---  Register CR: Control Register\n  CR @offset 0x0 $u32 {\n    14\n    CX // at 17: Cancel Transfer\n    ECX // at 16: Error Cancel Transfer\n    5\n    GRP1PRI // at 10: Channel Group 1 Priority\n    1\n    GRP0PRI // at 8: Channel Group 0 Priority\n    EMLM // at 7: Enable Minor Loop Mapping\n    CLM // at 6: Continuous Link Mode\n    HALT // at 5: Halt DMA Operations\n    HOE // at 4: Halt On Error\n    ERGA // at 3: Enable Round Robin Group Arbitration\n    ERCA // at 2: Enable Round Robin Channel Arbitration\n    EDBG // at 1: Enable Debug\n    1\n  }\n\n//---  Register ES: Error Status Register\n  ES @offset 0x4 @ro $u32 {\n    VLD // at 31: Logical OR of all ERR status bits\n    14\n    ECX // at 16: Transfer Canceled\n    GPE // at 15: Group Priority Error\n    CPE // at 14: Channel Priority Error\n    1\n    ERRCHN:5 // at 8: Error Channel Number or Canceled Channel Number\n    SAE // at 7: Source Address Error\n    SOE // at 6: Source Offset Error\n    DAE // at 5: Destination Address Error\n    DOE // at 4: Destination Offset Error\n    NCE // at 3: NBYTES/CITER Configuration Error\n    SGE // at 2: Scatter/Gather Configuration Error\n    SBE // at 1: Source Bus Error\n    DBE // at 0: Destination Bus Error\n  }\n\n//---  Register ERQ: Enable Request Register\n  ERQ @offset 0xc $u32 {\n    ERQ31 // at 31: Enable DMA Request 31\n    ERQ30 // at 30: Enable DMA Request 30\n    ERQ29 // at 29: Enable DMA Request 29\n    ERQ28 // at 28: Enable DMA Request 28\n    ERQ27 // at 27: Enable DMA Request 27\n    ERQ26 // at 26: Enable DMA Request 26\n    ERQ25 // at 25: Enable DMA Request 25\n    ERQ24 // at 24: Enable DMA Request 24\n    ERQ23 // at 23: Enable DMA Request 23\n    ERQ22 // at 22: Enable DMA Request 22\n    ERQ21 // at 21: Enable DMA Request 21\n    ERQ20 // at 20: Enable DMA Request 20\n    ERQ19 // at 19: Enable DMA Request 19\n    ERQ18 // at 18: Enable DMA Request 18\n    ERQ17 // at 17: Enable DMA Request 17\n    ERQ16 // at 16: Enable DMA Request 16\n    ERQ15 // at 15: Enable DMA Request 15\n    ERQ14 // at 14: Enable DMA Request 14\n    ERQ13 // at 13: Enable DMA Request 13\n    ERQ12 // at 12: Enable DMA Request 12\n    ERQ11 // at 11: Enable DMA Request 11\n    ERQ10 // at 10: Enable DMA Request 10\n    ERQ9 // at 9: Enable DMA Request 9\n    ERQ8 // at 8: Enable DMA Request 8\n    ERQ7 // at 7: Enable DMA Request 7\n    ERQ6 // at 6: Enable DMA Request 6\n    ERQ5 // at 5: Enable DMA Request 5\n    ERQ4 // at 4: Enable DMA Request 4\n    ERQ3 // at 3: Enable DMA Request 3\n    ERQ2 // at 2: Enable DMA Request 2\n    ERQ1 // at 1: Enable DMA Request 1\n    ERQ0 // at 0: Enable DMA Request 0\n  }\n\n//---  Register EEI: Enable Error Interrupt Register\n  EEI @offset 0x14 $u32 {\n    EEI31 // at 31: Enable Error Interrupt 31\n    EEI30 // at 30: Enable Error Interrupt 30\n    EEI29 // at 29: Enable Error Interrupt 29\n    EEI28 // at 28: Enable Error Interrupt 28\n    EEI27 // at 27: Enable Error Interrupt 27\n    EEI26 // at 26: Enable Error Interrupt 26\n    EEI25 // at 25: Enable Error Interrupt 25\n    EEI24 // at 24: Enable Error Interrupt 24\n    EEI23 // at 23: Enable Error Interrupt 23\n    EEI22 // at 22: Enable Error Interrupt 22\n    EEI21 // at 21: Enable Error Interrupt 21\n    EEI20 // at 20: Enable Error Interrupt 20\n    EEI19 // at 19: Enable Error Interrupt 19\n    EEI18 // at 18: Enable Error Interrupt 18\n    EEI17 // at 17: Enable Error Interrupt 17\n    EEI16 // at 16: Enable Error Interrupt 16\n    EEI15 // at 15: Enable Error Interrupt 15\n    EEI14 // at 14: Enable Error Interrupt 14\n    EEI13 // at 13: Enable Error Interrupt 13\n    EEI12 // at 12: Enable Error Interrupt 12\n    EEI11 // at 11: Enable Error Interrupt 11\n    EEI10 // at 10: Enable Error Interrupt 10\n    EEI9 // at 9: Enable Error Interrupt 9\n    EEI8 // at 8: Enable Error Interrupt 8\n    EEI7 // at 7: Enable Error Interrupt 7\n    EEI6 // at 6: Enable Error Interrupt 6\n    EEI5 // at 5: Enable Error Interrupt 5\n    EEI4 // at 4: Enable Error Interrupt 4\n    EEI3 // at 3: Enable Error Interrupt 3\n    EEI2 // at 2: Enable Error Interrupt 2\n    EEI1 // at 1: Enable Error Interrupt 1\n    EEI0 // at 0: Enable Error Interrupt 0\n  }\n\n//---  Register CEEI: Clear Enable Error Interrupt Register\n  CEEI @offset 0x18 $u8 {\n    NOP // at 7: No Op enable\n    CAEE // at 6: Clear All Enable Error Interrupts\n    1\n    CEEI:5 // at 0: Clear Enable Error Interrupt\n  }\n\n//---  Register SEEI: Set Enable Error Interrupt Register\n  SEEI @offset 0x19 $u8 {\n    NOP // at 7: No Op enable\n    SAEE // at 6: Sets All Enable Error Interrupts\n    1\n    SEEI:5 // at 0: Set Enable Error Interrupt\n  }\n\n//---  Register CERQ: Clear Enable Request Register\n  CERQ @offset 0x1a $u8 {\n    NOP // at 7: No Op enable\n    CAER // at 6: Clear All Enable Requests\n    1\n    CERQ:5 // at 0: Clear Enable Request\n  }\n\n//---  Register SERQ: Set Enable Request Register\n  SERQ @offset 0x1b $u8 {\n    NOP // at 7: No Op enable\n    SAER // at 6: Set All Enable Requests\n    1\n    SERQ:5 // at 0: Set Enable Request\n  }\n\n//---  Register CDNE: Clear DONE Status Bit Register\n  CDNE @offset 0x1c $u8 {\n    NOP // at 7: No Op enable\n    CADN // at 6: Clears All DONE Bits\n    1\n    CDNE:5 // at 0: Clear DONE Bit\n  }\n\n//---  Register SSRT: Set START Bit Register\n  SSRT @offset 0x1d $u8 {\n    NOP // at 7: No Op enable\n    SAST // at 6: Set All START Bits (activates all channels)\n    1\n    SSRT:5 // at 0: Set START Bit\n  }\n\n//---  Register CERR: Clear Error Register\n  CERR @offset 0x1e $u8 {\n    NOP // at 7: No Op enable\n    CAEI // at 6: Clear All Error Indicators\n    1\n    CERR:5 // at 0: Clear Error Indicator\n  }\n\n//---  Register CINT: Clear Interrupt Request Register\n  CINT @offset 0x1f $u8 {\n    NOP // at 7: No Op enable\n    CAIR // at 6: Clear All Interrupt Requests\n    1\n    CINT:5 // at 0: Clear Interrupt Request\n  }\n\n//---  Register INT: Interrupt Request Register\n  INT @offset 0x24 $u32 {\n    INT31 // at 31: Interrupt Request 31\n    INT30 // at 30: Interrupt Request 30\n    INT29 // at 29: Interrupt Request 29\n    INT28 // at 28: Interrupt Request 28\n    INT27 // at 27: Interrupt Request 27\n    INT26 // at 26: Interrupt Request 26\n    INT25 // at 25: Interrupt Request 25\n    INT24 // at 24: Interrupt Request 24\n    INT23 // at 23: Interrupt Request 23\n    INT22 // at 22: Interrupt Request 22\n    INT21 // at 21: Interrupt Request 21\n    INT20 // at 20: Interrupt Request 20\n    INT19 // at 19: Interrupt Request 19\n    INT18 // at 18: Interrupt Request 18\n    INT17 // at 17: Interrupt Request 17\n    INT16 // at 16: Interrupt Request 16\n    INT15 // at 15: Interrupt Request 15\n    INT14 // at 14: Interrupt Request 14\n    INT13 // at 13: Interrupt Request 13\n    INT12 // at 12: Interrupt Request 12\n    INT11 // at 11: Interrupt Request 11\n    INT10 // at 10: Interrupt Request 10\n    INT9 // at 9: Interrupt Request 9\n    INT8 // at 8: Interrupt Request 8\n    INT7 // at 7: Interrupt Request 7\n    INT6 // at 6: Interrupt Request 6\n    INT5 // at 5: Interrupt Request 5\n    INT4 // at 4: Interrupt Request 4\n    INT3 // at 3: Interrupt Request 3\n    INT2 // at 2: Interrupt Request 2\n    INT1 // at 1: Interrupt Request 1\n    INT0 // at 0: Interrupt Request 0\n  }\n\n//---  Register ERR: Error Register\n  ERR @offset 0x2c $u32 {\n    ERR31 // at 31: Error In Channel 31\n    ERR30 // at 30: Error In Channel 30\n    ERR29 // at 29: Error In Channel 29\n    ERR28 // at 28: Error In Channel 28\n    ERR27 // at 27: Error In Channel 27\n    ERR26 // at 26: Error In Channel 26\n    ERR25 // at 25: Error In Channel 25\n    ERR24 // at 24: Error In Channel 24\n    ERR23 // at 23: Error In Channel 23\n    ERR22 // at 22: Error In Channel 22\n    ERR21 // at 21: Error In Channel 21\n    ERR20 // at 20: Error In Channel 20\n    ERR19 // at 19: Error In Channel 19\n    ERR18 // at 18: Error In Channel 18\n    ERR17 // at 17: Error In Channel 17\n    ERR16 // at 16: Error In Channel 16\n    ERR15 // at 15: Error In Channel 15\n    ERR14 // at 14: Error In Channel 14\n    ERR13 // at 13: Error In Channel 13\n    ERR12 // at 12: Error In Channel 12\n    ERR11 // at 11: Error In Channel 11\n    ERR10 // at 10: Error In Channel 10\n    ERR9 // at 9: Error In Channel 9\n    ERR8 // at 8: Error In Channel 8\n    ERR7 // at 7: Error In Channel 7\n    ERR6 // at 6: Error In Channel 6\n    ERR5 // at 5: Error In Channel 5\n    ERR4 // at 4: Error In Channel 4\n    ERR3 // at 3: Error In Channel 3\n    ERR2 // at 2: Error In Channel 2\n    ERR1 // at 1: Error In Channel 1\n    ERR0 // at 0: Error In Channel 0\n  }\n\n//---  Register HRS: Hardware Request Status Register\n  HRS @offset 0x34 @ro $u32 {\n    HRS31 // at 31: Hardware Request Status Channel 31\n    HRS30 // at 30: Hardware Request Status Channel 30\n    HRS29 // at 29: Hardware Request Status Channel 29\n    HRS28 // at 28: Hardware Request Status Channel 28\n    HRS27 // at 27: Hardware Request Status Channel 27\n    HRS26 // at 26: Hardware Request Status Channel 26\n    HRS25 // at 25: Hardware Request Status Channel 25\n    HRS24 // at 24: Hardware Request Status Channel 24\n    HRS23 // at 23: Hardware Request Status Channel 23\n    HRS22 // at 22: Hardware Request Status Channel 22\n    HRS21 // at 21: Hardware Request Status Channel 21\n    HRS20 // at 20: Hardware Request Status Channel 20\n    HRS19 // at 19: Hardware Request Status Channel 19\n    HRS18 // at 18: Hardware Request Status Channel 18\n    HRS17 // at 17: Hardware Request Status Channel 17\n    HRS16 // at 16: Hardware Request Status Channel 16\n    HRS15 // at 15: Hardware Request Status Channel 15\n    HRS14 // at 14: Hardware Request Status Channel 14\n    HRS13 // at 13: Hardware Request Status Channel 13\n    HRS12 // at 12: Hardware Request Status Channel 12\n    HRS11 // at 11: Hardware Request Status Channel 11\n    HRS10 // at 10: Hardware Request Status Channel 10\n    HRS9 // at 9: Hardware Request Status Channel 9\n    HRS8 // at 8: Hardware Request Status Channel 8\n    HRS7 // at 7: Hardware Request Status Channel 7\n    HRS6 // at 6: Hardware Request Status Channel 6\n    HRS5 // at 5: Hardware Request Status Channel 5\n    HRS4 // at 4: Hardware Request Status Channel 4\n    HRS3 // at 3: Hardware Request Status Channel 3\n    HRS2 // at 2: Hardware Request Status Channel 2\n    HRS1 // at 1: Hardware Request Status Channel 1\n    HRS0 // at 0: Hardware Request Status Channel 0\n  }\n\n//---  Register EARS: Enable Asynchronous Request in Stop Register\n  EARS @offset 0x44 $u32 {\n    EDREQ_31 // at 31: Enable asynchronous DMA request in stop mode for channel 31\n    EDREQ_30 // at 30: Enable asynchronous DMA request in stop mode for channel 30\n    EDREQ_29 // at 29: Enable asynchronous DMA request in stop mode for channel 29\n    EDREQ_28 // at 28: Enable asynchronous DMA request in stop mode for channel 28\n    EDREQ_27 // at 27: Enable asynchronous DMA request in stop mode for channel 27\n    EDREQ_26 // at 26: Enable asynchronous DMA request in stop mode for channel 26\n    EDREQ_25 // at 25: Enable asynchronous DMA request in stop mode for channel 25\n    EDREQ_24 // at 24: Enable asynchronous DMA request in stop mode for channel 24\n    EDREQ_23 // at 23: Enable asynchronous DMA request in stop mode for channel 23\n    EDREQ_22 // at 22: Enable asynchronous DMA request in stop mode for channel 22\n    EDREQ_21 // at 21: Enable asynchronous DMA request in stop mode for channel 21\n    EDREQ_20 // at 20: Enable asynchronous DMA request in stop mode for channel 20\n    EDREQ_19 // at 19: Enable asynchronous DMA request in stop mode for channel 19\n    EDREQ_18 // at 18: Enable asynchronous DMA request in stop mode for channel 18\n    EDREQ_17 // at 17: Enable asynchronous DMA request in stop mode for channel 17\n    EDREQ_16 // at 16: Enable asynchronous DMA request in stop mode for channel 16\n    EDREQ_15 // at 15: Enable asynchronous DMA request in stop mode for channel 15\n    EDREQ_14 // at 14: Enable asynchronous DMA request in stop mode for channel 14\n    EDREQ_13 // at 13: Enable asynchronous DMA request in stop mode for channel 13\n    EDREQ_12 // at 12: Enable asynchronous DMA request in stop mode for channel 12\n    EDREQ_11 // at 11: Enable asynchronous DMA request in stop mode for channel 11\n    EDREQ_10 // at 10: Enable asynchronous DMA request in stop mode for channel 10\n    EDREQ_9 // at 9: Enable asynchronous DMA request in stop mode for channel 9\n    EDREQ_8 // at 8: Enable asynchronous DMA request in stop mode for channel 8\n    EDREQ_7 // at 7: Enable asynchronous DMA request in stop mode for channel 7\n    EDREQ_6 // at 6: Enable asynchronous DMA request in stop mode for channel 6\n    EDREQ_5 // at 5: Enable asynchronous DMA request in stop mode for channel 5\n    EDREQ_4 // at 4: Enable asynchronous DMA request in stop mode for channel 4\n    EDREQ_3 // at 3: Enable asynchronous DMA request in stop mode for channel 3.\n    EDREQ_2 // at 2: Enable asynchronous DMA request in stop mode for channel 2.\n    EDREQ_1 // at 1: Enable asynchronous DMA request in stop mode for channel 1.\n    EDREQ_0 // at 0: Enable asynchronous DMA request in stop mode for channel 0.\n  }\n\n//---  Registers DCHPRI(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12,19,18,17,16,23,22,21,20,27,26,25,24,31,30,29,28): Channel n Priority Register\n  DCHPRI [32 @offset 0x100 @inc 0x1]\n  DCHPRI3 @offset 0x100\n  DCHPRI2 @offset 0x101\n  DCHPRI1 @offset 0x102\n  DCHPRI0 @offset 0x103\n  DCHPRI7 @offset 0x104\n  DCHPRI6 @offset 0x105\n  DCHPRI5 @offset 0x106\n  DCHPRI4 @offset 0x107\n  DCHPRI11 @offset 0x108\n  DCHPRI10 @offset 0x109\n  DCHPRI9 @offset 0x10a\n  DCHPRI8 @offset 0x10b\n  DCHPRI15 @offset 0x10c\n  DCHPRI14 @offset 0x10d\n  DCHPRI13 @offset 0x10e\n  DCHPRI12 @offset 0x10f\n  DCHPRI19 @offset 0x110\n  DCHPRI18 @offset 0x111\n  DCHPRI17 @offset 0x112\n  DCHPRI16 @offset 0x113\n  DCHPRI23 @offset 0x114\n  DCHPRI22 @offset 0x115\n  DCHPRI21 @offset 0x116\n  DCHPRI20 @offset 0x117\n  DCHPRI27 @offset 0x118\n  DCHPRI26 @offset 0x119\n  DCHPRI25 @offset 0x11a\n  DCHPRI24 @offset 0x11b\n  DCHPRI31 @offset 0x11c\n  DCHPRI30 @offset 0x11d\n  DCHPRI29 @offset 0x11e\n  DCHPRI28 @offset 0x11f $u8 {\n    ECP // at 7: Enable Channel Preemption.\n    DPA // at 6: Disable Preempt Ability.\n    GRPPRI:2 // at 4: Channel n Current Group Priority\n    CHPRI:4 // at 0: Channel n Arbitration Priority\n  }\n\n//---  Registers TCD_SADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Source Address\n  TCD_SADDR [32 @offset 0x1000 @inc 0x20]\n  TCD0_SADDR @offset 0x1000\n  TCD1_SADDR @offset 0x1020\n  TCD2_SADDR @offset 0x1040\n  TCD3_SADDR @offset 0x1060\n  TCD4_SADDR @offset 0x1080\n  TCD5_SADDR @offset 0x10a0\n  TCD6_SADDR @offset 0x10c0\n  TCD7_SADDR @offset 0x10e0\n  TCD8_SADDR @offset 0x1100\n  TCD9_SADDR @offset 0x1120\n  TCD10_SADDR @offset 0x1140\n  TCD11_SADDR @offset 0x1160\n  TCD12_SADDR @offset 0x1180\n  TCD13_SADDR @offset 0x11a0\n  TCD14_SADDR @offset 0x11c0\n  TCD15_SADDR @offset 0x11e0\n  TCD16_SADDR @offset 0x1200\n  TCD17_SADDR @offset 0x1220\n  TCD18_SADDR @offset 0x1240\n  TCD19_SADDR @offset 0x1260\n  TCD20_SADDR @offset 0x1280\n  TCD21_SADDR @offset 0x12a0\n  TCD22_SADDR @offset 0x12c0\n  TCD23_SADDR @offset 0x12e0\n  TCD24_SADDR @offset 0x1300\n  TCD25_SADDR @offset 0x1320\n  TCD26_SADDR @offset 0x1340\n  TCD27_SADDR @offset 0x1360\n  TCD28_SADDR @offset 0x1380\n  TCD29_SADDR @offset 0x13a0\n  TCD30_SADDR @offset 0x13c0\n  TCD31_SADDR @offset 0x13e0 $u32 {\n    SADDR:32 // at 0: Source Address\n  }\n\n//---  Registers TCD_SOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Source Address Offset\n  TCD_SOFF [32 @offset 0x1004 @inc 0x20]\n  TCD0_SOFF @offset 0x1004\n  TCD1_SOFF @offset 0x1024\n  TCD2_SOFF @offset 0x1044\n  TCD3_SOFF @offset 0x1064\n  TCD4_SOFF @offset 0x1084\n  TCD5_SOFF @offset 0x10a4\n  TCD6_SOFF @offset 0x10c4\n  TCD7_SOFF @offset 0x10e4\n  TCD8_SOFF @offset 0x1104\n  TCD9_SOFF @offset 0x1124\n  TCD10_SOFF @offset 0x1144\n  TCD11_SOFF @offset 0x1164\n  TCD12_SOFF @offset 0x1184\n  TCD13_SOFF @offset 0x11a4\n  TCD14_SOFF @offset 0x11c4\n  TCD15_SOFF @offset 0x11e4\n  TCD16_SOFF @offset 0x1204\n  TCD17_SOFF @offset 0x1224\n  TCD18_SOFF @offset 0x1244\n  TCD19_SOFF @offset 0x1264\n  TCD20_SOFF @offset 0x1284\n  TCD21_SOFF @offset 0x12a4\n  TCD22_SOFF @offset 0x12c4\n  TCD23_SOFF @offset 0x12e4\n  TCD24_SOFF @offset 0x1304\n  TCD25_SOFF @offset 0x1324\n  TCD26_SOFF @offset 0x1344\n  TCD27_SOFF @offset 0x1364\n  TCD28_SOFF @offset 0x1384\n  TCD29_SOFF @offset 0x13a4\n  TCD30_SOFF @offset 0x13c4\n  TCD31_SOFF @offset 0x13e4 $u16 {\n    SOFF:16 // at 0: Source address signed offset\n  }\n\n//---  Registers TCD_ATTR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Transfer Attributes\n  TCD_ATTR [32 @offset 0x1006 @inc 0x20]\n  TCD0_ATTR @offset 0x1006\n  TCD1_ATTR @offset 0x1026\n  TCD2_ATTR @offset 0x1046\n  TCD3_ATTR @offset 0x1066\n  TCD4_ATTR @offset 0x1086\n  TCD5_ATTR @offset 0x10a6\n  TCD6_ATTR @offset 0x10c6\n  TCD7_ATTR @offset 0x10e6\n  TCD8_ATTR @offset 0x1106\n  TCD9_ATTR @offset 0x1126\n  TCD10_ATTR @offset 0x1146\n  TCD11_ATTR @offset 0x1166\n  TCD12_ATTR @offset 0x1186\n  TCD13_ATTR @offset 0x11a6\n  TCD14_ATTR @offset 0x11c6\n  TCD15_ATTR @offset 0x11e6\n  TCD16_ATTR @offset 0x1206\n  TCD17_ATTR @offset 0x1226\n  TCD18_ATTR @offset 0x1246\n  TCD19_ATTR @offset 0x1266\n  TCD20_ATTR @offset 0x1286\n  TCD21_ATTR @offset 0x12a6\n  TCD22_ATTR @offset 0x12c6\n  TCD23_ATTR @offset 0x12e6\n  TCD24_ATTR @offset 0x1306\n  TCD25_ATTR @offset 0x1326\n  TCD26_ATTR @offset 0x1346\n  TCD27_ATTR @offset 0x1366\n  TCD28_ATTR @offset 0x1386\n  TCD29_ATTR @offset 0x13a6\n  TCD30_ATTR @offset 0x13c6\n  TCD31_ATTR @offset 0x13e6 $u16 {\n    SMOD:5 // at 11: Source Address Modulo\n    SSIZE:3 // at 8: Source data transfer size\n    DMOD:5 // at 3: Destination Address Modulo\n    DSIZE:3 // at 0: Destination data transfer size\n  }\n\n//---  Registers TCD_NBYTES_MLNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Minor Byte Count (Minor Loop Mapping Disabled)\n  TCD_NBYTES_MLNO [32 @offset 0x1008 @inc 0x20]\n  TCD0_NBYTES_MLNO @offset 0x1008\n  TCD1_NBYTES_MLNO @offset 0x1028\n  TCD2_NBYTES_MLNO @offset 0x1048\n  TCD3_NBYTES_MLNO @offset 0x1068\n  TCD4_NBYTES_MLNO @offset 0x1088\n  TCD5_NBYTES_MLNO @offset 0x10a8\n  TCD6_NBYTES_MLNO @offset 0x10c8\n  TCD7_NBYTES_MLNO @offset 0x10e8\n  TCD8_NBYTES_MLNO @offset 0x1108\n  TCD9_NBYTES_MLNO @offset 0x1128\n  TCD10_NBYTES_MLNO @offset 0x1148\n  TCD11_NBYTES_MLNO @offset 0x1168\n  TCD12_NBYTES_MLNO @offset 0x1188\n  TCD13_NBYTES_MLNO @offset 0x11a8\n  TCD14_NBYTES_MLNO @offset 0x11c8\n  TCD15_NBYTES_MLNO @offset 0x11e8\n  TCD16_NBYTES_MLNO @offset 0x1208\n  TCD17_NBYTES_MLNO @offset 0x1228\n  TCD18_NBYTES_MLNO @offset 0x1248\n  TCD19_NBYTES_MLNO @offset 0x1268\n  TCD20_NBYTES_MLNO @offset 0x1288\n  TCD21_NBYTES_MLNO @offset 0x12a8\n  TCD22_NBYTES_MLNO @offset 0x12c8\n  TCD23_NBYTES_MLNO @offset 0x12e8\n  TCD24_NBYTES_MLNO @offset 0x1308\n  TCD25_NBYTES_MLNO @offset 0x1328\n  TCD26_NBYTES_MLNO @offset 0x1348\n  TCD27_NBYTES_MLNO @offset 0x1368\n  TCD28_NBYTES_MLNO @offset 0x1388\n  TCD29_NBYTES_MLNO @offset 0x13a8\n  TCD30_NBYTES_MLNO @offset 0x13c8\n  TCD31_NBYTES_MLNO @offset 0x13e8 $u32 {\n    NBYTES:32 // at 0: Minor Byte Transfer Count\n  }\n\n//---  Registers TCD_NBYTES_MLOFFNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)\n  TCD_NBYTES_MLOFFNO [32 @offset 0x1008 @inc 0x20]\n  TCD0_NBYTES_MLOFFNO @offset 0x1008\n  TCD1_NBYTES_MLOFFNO @offset 0x1028\n  TCD2_NBYTES_MLOFFNO @offset 0x1048\n  TCD3_NBYTES_MLOFFNO @offset 0x1068\n  TCD4_NBYTES_MLOFFNO @offset 0x1088\n  TCD5_NBYTES_MLOFFNO @offset 0x10a8\n  TCD6_NBYTES_MLOFFNO @offset 0x10c8\n  TCD7_NBYTES_MLOFFNO @offset 0x10e8\n  TCD8_NBYTES_MLOFFNO @offset 0x1108\n  TCD9_NBYTES_MLOFFNO @offset 0x1128\n  TCD10_NBYTES_MLOFFNO @offset 0x1148\n  TCD11_NBYTES_MLOFFNO @offset 0x1168\n  TCD12_NBYTES_MLOFFNO @offset 0x1188\n  TCD13_NBYTES_MLOFFNO @offset 0x11a8\n  TCD14_NBYTES_MLOFFNO @offset 0x11c8\n  TCD15_NBYTES_MLOFFNO @offset 0x11e8\n  TCD16_NBYTES_MLOFFNO @offset 0x1208\n  TCD17_NBYTES_MLOFFNO @offset 0x1228\n  TCD18_NBYTES_MLOFFNO @offset 0x1248\n  TCD19_NBYTES_MLOFFNO @offset 0x1268\n  TCD20_NBYTES_MLOFFNO @offset 0x1288\n  TCD21_NBYTES_MLOFFNO @offset 0x12a8\n  TCD22_NBYTES_MLOFFNO @offset 0x12c8\n  TCD23_NBYTES_MLOFFNO @offset 0x12e8\n  TCD24_NBYTES_MLOFFNO @offset 0x1308\n  TCD25_NBYTES_MLOFFNO @offset 0x1328\n  TCD26_NBYTES_MLOFFNO @offset 0x1348\n  TCD27_NBYTES_MLOFFNO @offset 0x1368\n  TCD28_NBYTES_MLOFFNO @offset 0x1388\n  TCD29_NBYTES_MLOFFNO @offset 0x13a8\n  TCD30_NBYTES_MLOFFNO @offset 0x13c8\n  TCD31_NBYTES_MLOFFNO @offset 0x13e8 $u32 {\n    SMLOE // at 31: Source Minor Loop Offset Enable\n    DMLOE // at 30: Destination Minor Loop Offset enable\n    NBYTES:30 // at 0: Minor Byte Transfer Count\n  }\n\n//---  Registers TCD_NBYTES_MLOFFYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)\n  TCD_NBYTES_MLOFFYES [32 @offset 0x1008 @inc 0x20]\n  TCD0_NBYTES_MLOFFYES @offset 0x1008\n  TCD1_NBYTES_MLOFFYES @offset 0x1028\n  TCD2_NBYTES_MLOFFYES @offset 0x1048\n  TCD3_NBYTES_MLOFFYES @offset 0x1068\n  TCD4_NBYTES_MLOFFYES @offset 0x1088\n  TCD5_NBYTES_MLOFFYES @offset 0x10a8\n  TCD6_NBYTES_MLOFFYES @offset 0x10c8\n  TCD7_NBYTES_MLOFFYES @offset 0x10e8\n  TCD8_NBYTES_MLOFFYES @offset 0x1108\n  TCD9_NBYTES_MLOFFYES @offset 0x1128\n  TCD10_NBYTES_MLOFFYES @offset 0x1148\n  TCD11_NBYTES_MLOFFYES @offset 0x1168\n  TCD12_NBYTES_MLOFFYES @offset 0x1188\n  TCD13_NBYTES_MLOFFYES @offset 0x11a8\n  TCD14_NBYTES_MLOFFYES @offset 0x11c8\n  TCD15_NBYTES_MLOFFYES @offset 0x11e8\n  TCD16_NBYTES_MLOFFYES @offset 0x1208\n  TCD17_NBYTES_MLOFFYES @offset 0x1228\n  TCD18_NBYTES_MLOFFYES @offset 0x1248\n  TCD19_NBYTES_MLOFFYES @offset 0x1268\n  TCD20_NBYTES_MLOFFYES @offset 0x1288\n  TCD21_NBYTES_MLOFFYES @offset 0x12a8\n  TCD22_NBYTES_MLOFFYES @offset 0x12c8\n  TCD23_NBYTES_MLOFFYES @offset 0x12e8\n  TCD24_NBYTES_MLOFFYES @offset 0x1308\n  TCD25_NBYTES_MLOFFYES @offset 0x1328\n  TCD26_NBYTES_MLOFFYES @offset 0x1348\n  TCD27_NBYTES_MLOFFYES @offset 0x1368\n  TCD28_NBYTES_MLOFFYES @offset 0x1388\n  TCD29_NBYTES_MLOFFYES @offset 0x13a8\n  TCD30_NBYTES_MLOFFYES @offset 0x13c8\n  TCD31_NBYTES_MLOFFYES @offset 0x13e8 $u32 {\n    SMLOE // at 31: Source Minor Loop Offset Enable\n    DMLOE // at 30: Destination Minor Loop Offset enable\n    MLOFF:20 // at 10: If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.\n    NBYTES:10 // at 0: Minor Byte Transfer Count\n  }\n\n//---  Registers TCD_SLAST(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Last Source Address Adjustment\n  TCD_SLAST [32 @offset 0x100c @inc 0x20]\n  TCD0_SLAST @offset 0x100c\n  TCD1_SLAST @offset 0x102c\n  TCD2_SLAST @offset 0x104c\n  TCD3_SLAST @offset 0x106c\n  TCD4_SLAST @offset 0x108c\n  TCD5_SLAST @offset 0x10ac\n  TCD6_SLAST @offset 0x10cc\n  TCD7_SLAST @offset 0x10ec\n  TCD8_SLAST @offset 0x110c\n  TCD9_SLAST @offset 0x112c\n  TCD10_SLAST @offset 0x114c\n  TCD11_SLAST @offset 0x116c\n  TCD12_SLAST @offset 0x118c\n  TCD13_SLAST @offset 0x11ac\n  TCD14_SLAST @offset 0x11cc\n  TCD15_SLAST @offset 0x11ec\n  TCD16_SLAST @offset 0x120c\n  TCD17_SLAST @offset 0x122c\n  TCD18_SLAST @offset 0x124c\n  TCD19_SLAST @offset 0x126c\n  TCD20_SLAST @offset 0x128c\n  TCD21_SLAST @offset 0x12ac\n  TCD22_SLAST @offset 0x12cc\n  TCD23_SLAST @offset 0x12ec\n  TCD24_SLAST @offset 0x130c\n  TCD25_SLAST @offset 0x132c\n  TCD26_SLAST @offset 0x134c\n  TCD27_SLAST @offset 0x136c\n  TCD28_SLAST @offset 0x138c\n  TCD29_SLAST @offset 0x13ac\n  TCD30_SLAST @offset 0x13cc\n  TCD31_SLAST @offset 0x13ec $u32 {\n    SLAST:32 // at 0: Last Source Address Adjustment\n  }\n\n//---  Registers TCD_DADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Destination Address\n  TCD_DADDR [32 @offset 0x1010 @inc 0x20]\n  TCD0_DADDR @offset 0x1010\n  TCD1_DADDR @offset 0x1030\n  TCD2_DADDR @offset 0x1050\n  TCD3_DADDR @offset 0x1070\n  TCD4_DADDR @offset 0x1090\n  TCD5_DADDR @offset 0x10b0\n  TCD6_DADDR @offset 0x10d0\n  TCD7_DADDR @offset 0x10f0\n  TCD8_DADDR @offset 0x1110\n  TCD9_DADDR @offset 0x1130\n  TCD10_DADDR @offset 0x1150\n  TCD11_DADDR @offset 0x1170\n  TCD12_DADDR @offset 0x1190\n  TCD13_DADDR @offset 0x11b0\n  TCD14_DADDR @offset 0x11d0\n  TCD15_DADDR @offset 0x11f0\n  TCD16_DADDR @offset 0x1210\n  TCD17_DADDR @offset 0x1230\n  TCD18_DADDR @offset 0x1250\n  TCD19_DADDR @offset 0x1270\n  TCD20_DADDR @offset 0x1290\n  TCD21_DADDR @offset 0x12b0\n  TCD22_DADDR @offset 0x12d0\n  TCD23_DADDR @offset 0x12f0\n  TCD24_DADDR @offset 0x1310\n  TCD25_DADDR @offset 0x1330\n  TCD26_DADDR @offset 0x1350\n  TCD27_DADDR @offset 0x1370\n  TCD28_DADDR @offset 0x1390\n  TCD29_DADDR @offset 0x13b0\n  TCD30_DADDR @offset 0x13d0\n  TCD31_DADDR @offset 0x13f0 $u32 {\n    DADDR:32 // at 0: Destination Address\n  }\n\n//---  Registers TCD_DOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Destination Address Offset\n  TCD_DOFF [32 @offset 0x1014 @inc 0x20]\n  TCD0_DOFF @offset 0x1014\n  TCD1_DOFF @offset 0x1034\n  TCD2_DOFF @offset 0x1054\n  TCD3_DOFF @offset 0x1074\n  TCD4_DOFF @offset 0x1094\n  TCD5_DOFF @offset 0x10b4\n  TCD6_DOFF @offset 0x10d4\n  TCD7_DOFF @offset 0x10f4\n  TCD8_DOFF @offset 0x1114\n  TCD9_DOFF @offset 0x1134\n  TCD10_DOFF @offset 0x1154\n  TCD11_DOFF @offset 0x1174\n  TCD12_DOFF @offset 0x1194\n  TCD13_DOFF @offset 0x11b4\n  TCD14_DOFF @offset 0x11d4\n  TCD15_DOFF @offset 0x11f4\n  TCD16_DOFF @offset 0x1214\n  TCD17_DOFF @offset 0x1234\n  TCD18_DOFF @offset 0x1254\n  TCD19_DOFF @offset 0x1274\n  TCD20_DOFF @offset 0x1294\n  TCD21_DOFF @offset 0x12b4\n  TCD22_DOFF @offset 0x12d4\n  TCD23_DOFF @offset 0x12f4\n  TCD24_DOFF @offset 0x1314\n  TCD25_DOFF @offset 0x1334\n  TCD26_DOFF @offset 0x1354\n  TCD27_DOFF @offset 0x1374\n  TCD28_DOFF @offset 0x1394\n  TCD29_DOFF @offset 0x13b4\n  TCD30_DOFF @offset 0x13d4\n  TCD31_DOFF @offset 0x13f4 $u16 {\n    DOFF:16 // at 0: Destination Address Signed Offset\n  }\n\n//---  Registers TCD_CITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)\n  TCD_CITER_ELINKNO [32 @offset 0x1016 @inc 0x20]\n  TCD0_CITER_ELINKNO @offset 0x1016\n  TCD1_CITER_ELINKNO @offset 0x1036\n  TCD2_CITER_ELINKNO @offset 0x1056\n  TCD3_CITER_ELINKNO @offset 0x1076\n  TCD4_CITER_ELINKNO @offset 0x1096\n  TCD5_CITER_ELINKNO @offset 0x10b6\n  TCD6_CITER_ELINKNO @offset 0x10d6\n  TCD7_CITER_ELINKNO @offset 0x10f6\n  TCD8_CITER_ELINKNO @offset 0x1116\n  TCD9_CITER_ELINKNO @offset 0x1136\n  TCD10_CITER_ELINKNO @offset 0x1156\n  TCD11_CITER_ELINKNO @offset 0x1176\n  TCD12_CITER_ELINKNO @offset 0x1196\n  TCD13_CITER_ELINKNO @offset 0x11b6\n  TCD14_CITER_ELINKNO @offset 0x11d6\n  TCD15_CITER_ELINKNO @offset 0x11f6\n  TCD16_CITER_ELINKNO @offset 0x1216\n  TCD17_CITER_ELINKNO @offset 0x1236\n  TCD18_CITER_ELINKNO @offset 0x1256\n  TCD19_CITER_ELINKNO @offset 0x1276\n  TCD20_CITER_ELINKNO @offset 0x1296\n  TCD21_CITER_ELINKNO @offset 0x12b6\n  TCD22_CITER_ELINKNO @offset 0x12d6\n  TCD23_CITER_ELINKNO @offset 0x12f6\n  TCD24_CITER_ELINKNO @offset 0x1316\n  TCD25_CITER_ELINKNO @offset 0x1336\n  TCD26_CITER_ELINKNO @offset 0x1356\n  TCD27_CITER_ELINKNO @offset 0x1376\n  TCD28_CITER_ELINKNO @offset 0x1396\n  TCD29_CITER_ELINKNO @offset 0x13b6\n  TCD30_CITER_ELINKNO @offset 0x13d6\n  TCD31_CITER_ELINKNO @offset 0x13f6 $u16 {\n    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete\n    CITER:15 // at 0: Current Major Iteration Count\n  }\n\n//---  Registers TCD_CITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)\n  TCD_CITER_ELINKYES [32 @offset 0x1016 @inc 0x20]\n  TCD0_CITER_ELINKYES @offset 0x1016\n  TCD1_CITER_ELINKYES @offset 0x1036\n  TCD2_CITER_ELINKYES @offset 0x1056\n  TCD3_CITER_ELINKYES @offset 0x1076\n  TCD4_CITER_ELINKYES @offset 0x1096\n  TCD5_CITER_ELINKYES @offset 0x10b6\n  TCD6_CITER_ELINKYES @offset 0x10d6\n  TCD7_CITER_ELINKYES @offset 0x10f6\n  TCD8_CITER_ELINKYES @offset 0x1116\n  TCD9_CITER_ELINKYES @offset 0x1136\n  TCD10_CITER_ELINKYES @offset 0x1156\n  TCD11_CITER_ELINKYES @offset 0x1176\n  TCD12_CITER_ELINKYES @offset 0x1196\n  TCD13_CITER_ELINKYES @offset 0x11b6\n  TCD14_CITER_ELINKYES @offset 0x11d6\n  TCD15_CITER_ELINKYES @offset 0x11f6\n  TCD16_CITER_ELINKYES @offset 0x1216\n  TCD17_CITER_ELINKYES @offset 0x1236\n  TCD18_CITER_ELINKYES @offset 0x1256\n  TCD19_CITER_ELINKYES @offset 0x1276\n  TCD20_CITER_ELINKYES @offset 0x1296\n  TCD21_CITER_ELINKYES @offset 0x12b6\n  TCD22_CITER_ELINKYES @offset 0x12d6\n  TCD23_CITER_ELINKYES @offset 0x12f6\n  TCD24_CITER_ELINKYES @offset 0x1316\n  TCD25_CITER_ELINKYES @offset 0x1336\n  TCD26_CITER_ELINKYES @offset 0x1356\n  TCD27_CITER_ELINKYES @offset 0x1376\n  TCD28_CITER_ELINKYES @offset 0x1396\n  TCD29_CITER_ELINKYES @offset 0x13b6\n  TCD30_CITER_ELINKYES @offset 0x13d6\n  TCD31_CITER_ELINKYES @offset 0x13f6 $u16 {\n    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete\n    1\n    LINKCH:5 // at 9: Minor Loop Link Channel Number\n    CITER:9 // at 0: Current Major Iteration Count\n  }\n\n//---  Registers TCD_DLASTSGA(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Last Destination Address Adjustment/Scatter Gather Address\n  TCD_DLASTSGA [32 @offset 0x1018 @inc 0x20]\n  TCD0_DLASTSGA @offset 0x1018\n  TCD1_DLASTSGA @offset 0x1038\n  TCD2_DLASTSGA @offset 0x1058\n  TCD3_DLASTSGA @offset 0x1078\n  TCD4_DLASTSGA @offset 0x1098\n  TCD5_DLASTSGA @offset 0x10b8\n  TCD6_DLASTSGA @offset 0x10d8\n  TCD7_DLASTSGA @offset 0x10f8\n  TCD8_DLASTSGA @offset 0x1118\n  TCD9_DLASTSGA @offset 0x1138\n  TCD10_DLASTSGA @offset 0x1158\n  TCD11_DLASTSGA @offset 0x1178\n  TCD12_DLASTSGA @offset 0x1198\n  TCD13_DLASTSGA @offset 0x11b8\n  TCD14_DLASTSGA @offset 0x11d8\n  TCD15_DLASTSGA @offset 0x11f8\n  TCD16_DLASTSGA @offset 0x1218\n  TCD17_DLASTSGA @offset 0x1238\n  TCD18_DLASTSGA @offset 0x1258\n  TCD19_DLASTSGA @offset 0x1278\n  TCD20_DLASTSGA @offset 0x1298\n  TCD21_DLASTSGA @offset 0x12b8\n  TCD22_DLASTSGA @offset 0x12d8\n  TCD23_DLASTSGA @offset 0x12f8\n  TCD24_DLASTSGA @offset 0x1318\n  TCD25_DLASTSGA @offset 0x1338\n  TCD26_DLASTSGA @offset 0x1358\n  TCD27_DLASTSGA @offset 0x1378\n  TCD28_DLASTSGA @offset 0x1398\n  TCD29_DLASTSGA @offset 0x13b8\n  TCD30_DLASTSGA @offset 0x13d8\n  TCD31_DLASTSGA @offset 0x13f8 $u32 {\n    DLASTSGA:32 // at 0: Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)\n  }\n\n//---  Registers TCD_CSR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Control and Status\n  TCD_CSR [32 @offset 0x101c @inc 0x20]\n  TCD0_CSR @offset 0x101c\n  TCD1_CSR @offset 0x103c\n  TCD2_CSR @offset 0x105c\n  TCD3_CSR @offset 0x107c\n  TCD4_CSR @offset 0x109c\n  TCD5_CSR @offset 0x10bc\n  TCD6_CSR @offset 0x10dc\n  TCD7_CSR @offset 0x10fc\n  TCD8_CSR @offset 0x111c\n  TCD9_CSR @offset 0x113c\n  TCD10_CSR @offset 0x115c\n  TCD11_CSR @offset 0x117c\n  TCD12_CSR @offset 0x119c\n  TCD13_CSR @offset 0x11bc\n  TCD14_CSR @offset 0x11dc\n  TCD15_CSR @offset 0x11fc\n  TCD16_CSR @offset 0x121c\n  TCD17_CSR @offset 0x123c\n  TCD18_CSR @offset 0x125c\n  TCD19_CSR @offset 0x127c\n  TCD20_CSR @offset 0x129c\n  TCD21_CSR @offset 0x12bc\n  TCD22_CSR @offset 0x12dc\n  TCD23_CSR @offset 0x12fc\n  TCD24_CSR @offset 0x131c\n  TCD25_CSR @offset 0x133c\n  TCD26_CSR @offset 0x135c\n  TCD27_CSR @offset 0x137c\n  TCD28_CSR @offset 0x139c\n  TCD29_CSR @offset 0x13bc\n  TCD30_CSR @offset 0x13dc\n  TCD31_CSR @offset 0x13fc $u16 {\n    BWC:2 // at 14: Bandwidth Control\n    1\n    MAJORLINKCH:5 // at 8: Major Loop Link Channel Number\n    DONE // at 7: Channel Done\n    ACTIVE // at 6: Channel Active\n    MAJORELINK // at 5: Enable channel-to-channel linking on major loop complete\n    ESG // at 4: Enable Scatter/Gather Processing\n    DREQ // at 3: Disable Request\n    INTHALF // at 2: Enable an interrupt when major counter is half complete.\n    INTMAJOR // at 1: Enable an interrupt when major iteration count completes.\n    START // at 0: Channel Start\n  }\n\n//---  Registers TCD_BITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)\n  TCD_BITER_ELINKNO [32 @offset 0x101e @inc 0x20]\n  TCD0_BITER_ELINKNO @offset 0x101e\n  TCD1_BITER_ELINKNO @offset 0x103e\n  TCD2_BITER_ELINKNO @offset 0x105e\n  TCD3_BITER_ELINKNO @offset 0x107e\n  TCD4_BITER_ELINKNO @offset 0x109e\n  TCD5_BITER_ELINKNO @offset 0x10be\n  TCD6_BITER_ELINKNO @offset 0x10de\n  TCD7_BITER_ELINKNO @offset 0x10fe\n  TCD8_BITER_ELINKNO @offset 0x111e\n  TCD9_BITER_ELINKNO @offset 0x113e\n  TCD10_BITER_ELINKNO @offset 0x115e\n  TCD11_BITER_ELINKNO @offset 0x117e\n  TCD12_BITER_ELINKNO @offset 0x119e\n  TCD13_BITER_ELINKNO @offset 0x11be\n  TCD14_BITER_ELINKNO @offset 0x11de\n  TCD15_BITER_ELINKNO @offset 0x11fe\n  TCD16_BITER_ELINKNO @offset 0x121e\n  TCD17_BITER_ELINKNO @offset 0x123e\n  TCD18_BITER_ELINKNO @offset 0x125e\n  TCD19_BITER_ELINKNO @offset 0x127e\n  TCD20_BITER_ELINKNO @offset 0x129e\n  TCD21_BITER_ELINKNO @offset 0x12be\n  TCD22_BITER_ELINKNO @offset 0x12de\n  TCD23_BITER_ELINKNO @offset 0x12fe\n  TCD24_BITER_ELINKNO @offset 0x131e\n  TCD25_BITER_ELINKNO @offset 0x133e\n  TCD26_BITER_ELINKNO @offset 0x135e\n  TCD27_BITER_ELINKNO @offset 0x137e\n  TCD28_BITER_ELINKNO @offset 0x139e\n  TCD29_BITER_ELINKNO @offset 0x13be\n  TCD30_BITER_ELINKNO @offset 0x13de\n  TCD31_BITER_ELINKNO @offset 0x13fe $u16 {\n    ELINK // at 15: Enables channel-to-channel linking on minor loop complete\n    BITER:15 // at 0: Starting Major Iteration Count\n  }\n\n//---  Registers TCD_BITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)\n  TCD_BITER_ELINKYES [32 @offset 0x101e @inc 0x20]\n  TCD0_BITER_ELINKYES @offset 0x101e\n  TCD1_BITER_ELINKYES @offset 0x103e\n  TCD2_BITER_ELINKYES @offset 0x105e\n  TCD3_BITER_ELINKYES @offset 0x107e\n  TCD4_BITER_ELINKYES @offset 0x109e\n  TCD5_BITER_ELINKYES @offset 0x10be\n  TCD6_BITER_ELINKYES @offset 0x10de\n  TCD7_BITER_ELINKYES @offset 0x10fe\n  TCD8_BITER_ELINKYES @offset 0x111e\n  TCD9_BITER_ELINKYES @offset 0x113e\n  TCD10_BITER_ELINKYES @offset 0x115e\n  TCD11_BITER_ELINKYES @offset 0x117e\n  TCD12_BITER_ELINKYES @offset 0x119e\n  TCD13_BITER_ELINKYES @offset 0x11be\n  TCD14_BITER_ELINKYES @offset 0x11de\n  TCD15_BITER_ELINKYES @offset 0x11fe\n  TCD16_BITER_ELINKYES @offset 0x121e\n  TCD17_BITER_ELINKYES @offset 0x123e\n  TCD18_BITER_ELINKYES @offset 0x125e\n  TCD19_BITER_ELINKYES @offset 0x127e\n  TCD20_BITER_ELINKYES @offset 0x129e\n  TCD21_BITER_ELINKYES @offset 0x12be\n  TCD22_BITER_ELINKYES @offset 0x12de\n  TCD23_BITER_ELINKYES @offset 0x12fe\n  TCD24_BITER_ELINKYES @offset 0x131e\n  TCD25_BITER_ELINKYES @offset 0x133e\n  TCD26_BITER_ELINKYES @offset 0x135e\n  TCD27_BITER_ELINKYES @offset 0x137e\n  TCD28_BITER_ELINKYES @offset 0x139e\n  TCD29_BITER_ELINKYES @offset 0x13be\n  TCD30_BITER_ELINKYES @offset 0x13de\n  TCD31_BITER_ELINKYES @offset 0x13fe $u16 {\n    ELINK // at 15: Enables channel-to-channel linking on minor loop complete\n    1\n    LINKCH:5 // at 9: Link Channel Number\n    BITER:9 // at 0: Starting major iteration count\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral DMAMUX: DMA channel multiplexor\n//------------------------------------------------------------------------------\n\nregisters DMAMUX @at 0x40021000 {\n//---  Registers CHCFG(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Channel Configuration register\n  CHCFG [32 @offset 0x0 @inc 0x1]\n  CHCFG0 @offset 0x0\n  CHCFG1 @offset 0x1\n  CHCFG2 @offset 0x2\n  CHCFG3 @offset 0x3\n  CHCFG4 @offset 0x4\n  CHCFG5 @offset 0x5\n  CHCFG6 @offset 0x6\n  CHCFG7 @offset 0x7\n  CHCFG8 @offset 0x8\n  CHCFG9 @offset 0x9\n  CHCFG10 @offset 0xa\n  CHCFG11 @offset 0xb\n  CHCFG12 @offset 0xc\n  CHCFG13 @offset 0xd\n  CHCFG14 @offset 0xe\n  CHCFG15 @offset 0xf\n  CHCFG16 @offset 0x10\n  CHCFG17 @offset 0x11\n  CHCFG18 @offset 0x12\n  CHCFG19 @offset 0x13\n  CHCFG20 @offset 0x14\n  CHCFG21 @offset 0x15\n  CHCFG22 @offset 0x16\n  CHCFG23 @offset 0x17\n  CHCFG24 @offset 0x18\n  CHCFG25 @offset 0x19\n  CHCFG26 @offset 0x1a\n  CHCFG27 @offset 0x1b\n  CHCFG28 @offset 0x1c\n  CHCFG29 @offset 0x1d\n  CHCFG30 @offset 0x1e\n  CHCFG31 @offset 0x1f $u8 {\n    ENBL // at 7: DMA Channel Enable\n    TRIG // at 6: DMA Channel Trigger Enable\n    SOURCE:6 // at 0: DMA Channel Source (Slot)\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral ENET: Ethernet MAC-NET Core\n//------------------------------------------------------------------------------\n\nregisters ENET @at 0x400c0000 {\n//---  Register EIR: Interrupt Event Register\n  EIR @offset 0x4 $u32 {\n    1\n    BABR // at 30: Babbling Receive Error\n    BABT // at 29: Babbling Transmit Error\n    GRA // at 28: Graceful Stop Complete\n    TXF // at 27: Transmit Frame Interrupt\n    TXB // at 26: Transmit Buffer Interrupt\n    RXF // at 25: Receive Frame Interrupt\n    RXB // at 24: Receive Buffer Interrupt\n    MII // at 23: MII Interrupt.\n    EBERR // at 22: Ethernet Bus Error\n    LC // at 21: Late Collision\n    RL // at 20: Collision Retry Limit\n    UN // at 19: Transmit FIFO Underrun\n    PLR // at 18: Payload Receive Error\n    WAKEUP // at 17: Node Wakeup Request Indication\n    TS_AVAIL // at 16: Transmit Timestamp Available\n    TS_TIMER // at 15: Timestamp Timer\n    15\n  }\n\n//---  Register EIMR: Interrupt Mask Register\n  EIMR @offset 0x8 $u32 {\n    1\n    BABR // at 30: BABR Interrupt Mask\n    BABT // at 29: BABT Interrupt Mask\n    GRA // at 28: GRA Interrupt Mask\n    TXF // at 27: TXF Interrupt Mask\n    TXB // at 26: TXB Interrupt Mask\n    RXF // at 25: RXF Interrupt Mask\n    RXB // at 24: RXB Interrupt Mask\n    MII // at 23: MII Interrupt Mask\n    EBERR // at 22: EBERR Interrupt Mask\n    LC // at 21: LC Interrupt Mask\n    RL // at 20: RL Interrupt Mask\n    UN // at 19: UN Interrupt Mask\n    PLR // at 18: PLR Interrupt Mask\n    WAKEUP // at 17: WAKEUP Interrupt Mask\n    TS_AVAIL // at 16: TS_AVAIL Interrupt Mask\n    TS_TIMER // at 15: TS_TIMER Interrupt Mask\n    15\n  }\n\n//---  Register RDAR: Receive Descriptor Active Register\n  RDAR @offset 0x10 $u32 {\n    7\n    RDAR // at 24: Receive Descriptor Active\n    24\n  }\n\n//---  Register TDAR: Transmit Descriptor Active Register\n  TDAR @offset 0x14 $u32 {\n    7\n    TDAR // at 24: Transmit Descriptor Active\n    24\n  }\n\n//---  Register ECR: Ethernet Control Register\n  ECR @offset 0x24 $u32 {\n    23\n    DBSWP // at 8: Descriptor Byte Swapping Enable\n    STOPEN // at 7: STOPEN Signal Control\n    DBGEN // at 6: Debug Enable\n    1\n    EN1588 // at 4: EN1588 Enable\n    SLEEP // at 3: Sleep Mode Enable\n    MAGICEN // at 2: Magic Packet Detection Enable\n    ETHEREN // at 1: Ethernet Enable\n    RESET // at 0: Ethernet MAC Reset\n  }\n\n//---  Register MMFR: MII Management Frame Register\n  MMFR @offset 0x40 $u32 {\n    ST:2 // at 30: Start Of Frame Delimiter\n    OP:2 // at 28: Operation Code\n    PA:5 // at 23: PHY Address\n    RA:5 // at 18: Register Address\n    TA:2 // at 16: Turn Around\n    DATA:16 // at 0: Management Frame Data\n  }\n\n//---  Register MSCR: MII Speed Control Register\n  MSCR @offset 0x44 $u32 {\n    21\n    HOLDTIME:3 // at 8: Hold time On MDIO Output\n    DIS_PRE // at 7: Disable Preamble\n    MII_SPEED:6 // at 1: MII Speed\n    1\n  }\n\n//---  Register MIBC: MIB Control Register\n  MIBC @offset 0x64 $u32 {\n    MIB_DIS // at 31: Disable MIB Logic\n    MIB_IDLE // at 30: MIB Idle\n    MIB_CLEAR // at 29: MIB Clear\n    29\n  }\n\n//---  Register RCR: Receive Control Register\n  RCR @offset 0x84 $u32 {\n    GRS // at 31: Graceful Receive Stopped\n    NLC // at 30: Payload Length Check Disable\n    MAX_FL:14 // at 16: Maximum Frame Length\n    CFEN // at 15: MAC Control Frame Enable\n    CRCFWD // at 14: Terminate/Forward Received CRC\n    PAUFWD // at 13: Terminate/Forward Pause Frames\n    PADEN // at 12: Enable Frame Padding Remove On Receive\n    2\n    RMII_10T // at 9: Enables 10-Mbps mode of the RMII .\n    RMII_MODE // at 8: RMII Mode Enable\n    2\n    FCE // at 5: Flow Control Enable\n    BC_REJ // at 4: Broadcast Frame Reject\n    PROM // at 3: Promiscuous Mode\n    MII_MODE // at 2: Media Independent Interface Mode\n    DRT // at 1: Disable Receive On Transmit\n    LOOP // at 0: Internal Loopback\n  }\n\n//---  Register TCR: Transmit Control Register\n  TCR @offset 0xc4 $u32 {\n    22\n    CRCFWD // at 9: Forward Frame From Application With CRC\n    ADDINS // at 8: Set MAC Address On Transmit\n    ADDSEL:3 // at 5: Source MAC Address Select On Transmit\n    RFC_PAUSE // at 4: Receive Frame Control Pause\n    TFC_PAUSE // at 3: Transmit Frame Control Pause\n    FDEN // at 2: Full-Duplex Enable\n    1\n    GTS // at 0: Graceful Transmit Stop\n  }\n\n//---  Register PALR: Physical Address Lower Register\n  PALR @offset 0xe4 $u32 {\n    PADDR1:32 // at 0: Pause Address\n  }\n\n//---  Register PAUR: Physical Address Upper Register\n  PAUR @offset 0xe8 $u32 {\n    PADDR2:16 // at 16: Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames\n    TYPE:16 // at 0: Type Field In PAUSE Frames\n  }\n\n//---  Register OPD: Opcode/Pause Duration Register\n  OPD @offset 0xec $u32 {\n    OPCODE:16 // at 16: Opcode Field In PAUSE Frames\n    PAUSE_DUR:16 // at 0: Pause Duration\n  }\n\n//---  Register IAUR: Descriptor Individual Upper Address Register\n  IAUR @offset 0x118 $u32 {\n    IADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address\n  }\n\n//---  Register IALR: Descriptor Individual Lower Address Register\n  IALR @offset 0x11c $u32 {\n    IADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address\n  }\n\n//---  Register GAUR: Descriptor Group Upper Address Register\n  GAUR @offset 0x120 $u32 {\n    GADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address\n  }\n\n//---  Register GALR: Descriptor Group Lower Address Register\n  GALR @offset 0x124 $u32 {\n    GADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address\n  }\n\n//---  Register TFWR: Transmit FIFO Watermark Register\n  TFWR @offset 0x144 $u32 {\n    23\n    STRFWD // at 8: Store And Forward Enable\n    2\n    TFWR:6 // at 0: Transmit FIFO Write\n  }\n\n//---  Register RDSR: Receive Descriptor Ring Start Register\n  RDSR @offset 0x180 $u32 {\n    R_DES_START:29 // at 3: Pointer to the beginning of the receive buffer descriptor queue.\n    3\n  }\n\n//---  Register TDSR: Transmit Buffer Descriptor Ring Start Register\n  TDSR @offset 0x184 $u32 {\n    X_DES_START:29 // at 3: Pointer to the beginning of the transmit buffer descriptor queue.\n    3\n  }\n\n//---  Register MRBR: Maximum Receive Buffer Size Register\n  MRBR @offset 0x188 $u32 {\n    21\n    R_BUF_SIZE:7 // at 4: Receive buffer size in bytes\n    4\n  }\n\n//---  Register RSFL: Receive FIFO Section Full Threshold\n  RSFL @offset 0x190 $u32 {\n    24\n    RX_SECTION_FULL:8 // at 0: Value Of Receive FIFO Section Full Threshold\n  }\n\n//---  Register RSEM: Receive FIFO Section Empty Threshold\n  RSEM @offset 0x194 $u32 {\n    11\n    STAT_SECTION_EMPTY:5 // at 16: RX Status FIFO Section Empty Threshold\n    8\n    RX_SECTION_EMPTY:8 // at 0: Value Of The Receive FIFO Section Empty Threshold\n  }\n\n//---  Register RAEM: Receive FIFO Almost Empty Threshold\n  RAEM @offset 0x198 $u32 {\n    24\n    RX_ALMOST_EMPTY:8 // at 0: Value Of The Receive FIFO Almost Empty Threshold\n  }\n\n//---  Register RAFL: Receive FIFO Almost Full Threshold\n  RAFL @offset 0x19c $u32 {\n    24\n    RX_ALMOST_FULL:8 // at 0: Value Of The Receive FIFO Almost Full Threshold\n  }\n\n//---  Register TSEM: Transmit FIFO Section Empty Threshold\n  TSEM @offset 0x1a0 $u32 {\n    24\n    TX_SECTION_EMPTY:8 // at 0: Value Of The Transmit FIFO Section Empty Threshold\n  }\n\n//---  Register TAEM: Transmit FIFO Almost Empty Threshold\n  TAEM @offset 0x1a4 $u32 {\n    24\n    TX_ALMOST_EMPTY:8 // at 0: Value of Transmit FIFO Almost Empty Threshold\n  }\n\n//---  Register TAFL: Transmit FIFO Almost Full Threshold\n  TAFL @offset 0x1a8 $u32 {\n    24\n    TX_ALMOST_FULL:8 // at 0: Value Of The Transmit FIFO Almost Full Threshold\n  }\n\n//---  Register TIPG: Transmit Inter-Packet Gap\n  TIPG @offset 0x1ac $u32 {\n    27\n    IPG:5 // at 0: Transmit Inter-Packet Gap\n  }\n\n//---  Register FTRL: Frame Truncation Length\n  FTRL @offset 0x1b0 $u32 {\n    18\n    TRUNC_FL:14 // at 0: Frame Truncation Length\n  }\n\n//---  Register TACC: Transmit Accelerator Function Configuration\n  TACC @offset 0x1c0 $u32 {\n    27\n    PROCHK // at 4: Enables insertion of protocol checksum.\n    IPCHK // at 3: Enables insertion of IP header checksum.\n    2\n    SHIFT16 // at 0: TX FIFO Shift-16\n  }\n\n//---  Register RACC: Receive Accelerator Function Configuration\n  RACC @offset 0x1c4 $u32 {\n    24\n    SHIFT16 // at 7: RX FIFO Shift-16\n    LINEDIS // at 6: Enable Discard Of Frames With MAC Layer Errors\n    3\n    PRODIS // at 2: Enable Discard Of Frames With Wrong Protocol Checksum\n    IPDIS // at 1: Enable Discard Of Frames With Wrong IPv4 Header Checksum\n    PADREM // at 0: Enable Padding Removal For Short IP Frames\n  }\n\n//---  Register RMON_T_DROP: Reserved Statistic Register\n  RMON_T_DROP @offset 0x200 @ro $u32\n//---  Register RMON_T_PACKETS: Tx Packet Count Statistic Register\n  RMON_T_PACKETS @offset 0x204 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Packet count\n  }\n\n//---  Register RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register\n  RMON_T_BC_PKT @offset 0x208 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Broadcast packets\n  }\n\n//---  Register RMON_T_MC_PKT: Tx Multicast Packets Statistic Register\n  RMON_T_MC_PKT @offset 0x20c @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Multicast packets\n  }\n\n//---  Register RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register\n  RMON_T_CRC_ALIGN @offset 0x210 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Packets with CRC/align error\n  }\n\n//---  Register RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register\n  RMON_T_UNDERSIZE @offset 0x214 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of transmit packets less than 64 bytes with good CRC\n  }\n\n//---  Register RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register\n  RMON_T_OVERSIZE @offset 0x218 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of transmit packets greater than MAX_FL bytes with good CRC\n  }\n\n//---  Register RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register\n  RMON_T_FRAG @offset 0x21c @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of packets less than 64 bytes with bad CRC\n  }\n\n//---  Register RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register\n  RMON_T_JAB @offset 0x220 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of transmit packets greater than MAX_FL bytes and bad CRC\n  }\n\n//---  Register RMON_T_COL: Tx Collision Count Statistic Register\n  RMON_T_COL @offset 0x224 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of transmit collisions\n  }\n\n//---  Register RMON_T_P64: Tx 64-Byte Packets Statistic Register\n  RMON_T_P64 @offset 0x228 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of 64-byte transmit packets\n  }\n\n//---  Register RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register\n  RMON_T_P65TO127 @offset 0x22c @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of 65- to 127-byte transmit packets\n  }\n\n//---  Register RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register\n  RMON_T_P128TO255 @offset 0x230 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of 128- to 255-byte transmit packets\n  }\n\n//---  Register RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register\n  RMON_T_P256TO511 @offset 0x234 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of 256- to 511-byte transmit packets\n  }\n\n//---  Register RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register\n  RMON_T_P512TO1023 @offset 0x238 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of 512- to 1023-byte transmit packets\n  }\n\n//---  Register RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register\n  RMON_T_P1024TO2047 @offset 0x23c @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of 1024- to 2047-byte transmit packets\n  }\n\n//---  Register RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register\n  RMON_T_P_GTE2048 @offset 0x240 @ro $u32 {\n    16\n    TXPKTS:16 // at 0: Number of transmit packets greater than 2048 bytes\n  }\n\n//---  Register RMON_T_OCTETS: Tx Octets Statistic Register\n  RMON_T_OCTETS @offset 0x244 @ro $u32 {\n    TXOCTS:32 // at 0: Number of transmit octets\n  }\n\n//---  Register IEEE_T_DROP: IEEE_T_DROP Reserved Statistic Register\n  IEEE_T_DROP @offset 0x248 @ro $u32\n//---  Register IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register\n  IEEE_T_FRAME_OK @offset 0x24c @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted OK\n  }\n\n//---  Register IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register\n  IEEE_T_1COL @offset 0x250 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with one collision\n  }\n\n//---  Register IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register\n  IEEE_T_MCOL @offset 0x254 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with multiple collisions\n  }\n\n//---  Register IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register\n  IEEE_T_DEF @offset 0x258 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with deferral delay\n  }\n\n//---  Register IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register\n  IEEE_T_LCOL @offset 0x25c @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with late collision\n  }\n\n//---  Register IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register\n  IEEE_T_EXCOL @offset 0x260 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with excessive collisions\n  }\n\n//---  Register IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register\n  IEEE_T_MACERR @offset 0x264 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with transmit FIFO underrun\n  }\n\n//---  Register IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register\n  IEEE_T_CSERR @offset 0x268 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with carrier sense error\n  }\n\n//---  Register IEEE_T_SQE: no description available\n  IEEE_T_SQE @offset 0x26c @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames transmitted with SQE error\n  }\n\n//---  Register IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register\n  IEEE_T_FDXFC @offset 0x270 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of flow-control pause frames transmitted\n  }\n\n//---  Register IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register\n  IEEE_T_OCTETS_OK @offset 0x274 @ro $u32 {\n    COUNT:32 // at 0: Octet count for frames transmitted without error Counts total octets (includes header and FCS fields).\n  }\n\n//---  Register RMON_R_PACKETS: Rx Packet Count Statistic Register\n  RMON_R_PACKETS @offset 0x284 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of packets received\n  }\n\n//---  Register RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register\n  RMON_R_BC_PKT @offset 0x288 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive broadcast packets\n  }\n\n//---  Register RMON_R_MC_PKT: Rx Multicast Packets Statistic Register\n  RMON_R_MC_PKT @offset 0x28c @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive multicast packets\n  }\n\n//---  Register RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register\n  RMON_R_CRC_ALIGN @offset 0x290 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive packets with CRC or align error\n  }\n\n//---  Register RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register\n  RMON_R_UNDERSIZE @offset 0x294 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive packets with less than 64 bytes and good CRC\n  }\n\n//---  Register RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register\n  RMON_R_OVERSIZE @offset 0x298 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive packets greater than MAX_FL and good CRC\n  }\n\n//---  Register RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register\n  RMON_R_FRAG @offset 0x29c @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive packets with less than 64 bytes and bad CRC\n  }\n\n//---  Register RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register\n  RMON_R_JAB @offset 0x2a0 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of receive packets greater than MAX_FL and bad CRC\n  }\n\n//---  Register RMON_R_RESVD_0: Reserved Statistic Register\n  RMON_R_RESVD_0 @offset 0x2a4 @ro $u32\n//---  Register RMON_R_P64: Rx 64-Byte Packets Statistic Register\n  RMON_R_P64 @offset 0x2a8 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of 64-byte receive packets\n  }\n\n//---  Register RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register\n  RMON_R_P65TO127 @offset 0x2ac @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of 65- to 127-byte recieve packets\n  }\n\n//---  Register RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register\n  RMON_R_P128TO255 @offset 0x2b0 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of 128- to 255-byte recieve packets\n  }\n\n//---  Register RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register\n  RMON_R_P256TO511 @offset 0x2b4 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of 256- to 511-byte recieve packets\n  }\n\n//---  Register RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register\n  RMON_R_P512TO1023 @offset 0x2b8 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of 512- to 1023-byte recieve packets\n  }\n\n//---  Register RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register\n  RMON_R_P1024TO2047 @offset 0x2bc @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of 1024- to 2047-byte recieve packets\n  }\n\n//---  Register RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register\n  RMON_R_P_GTE2048 @offset 0x2c0 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of greater-than-2048-byte recieve packets\n  }\n\n//---  Register RMON_R_OCTETS: Rx Octets Statistic Register\n  RMON_R_OCTETS @offset 0x2c4 @ro $u32 {\n    COUNT:32 // at 0: Number of receive octets\n  }\n\n//---  Register IEEE_R_DROP: Frames not Counted Correctly Statistic Register\n  IEEE_R_DROP @offset 0x2c8 @ro $u32 {\n    16\n    COUNT:16 // at 0: Frame count\n  }\n\n//---  Register IEEE_R_FRAME_OK: Frames Received OK Statistic Register\n  IEEE_R_FRAME_OK @offset 0x2cc @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames received OK\n  }\n\n//---  Register IEEE_R_CRC: Frames Received with CRC Error Statistic Register\n  IEEE_R_CRC @offset 0x2d0 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames received with CRC error\n  }\n\n//---  Register IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register\n  IEEE_R_ALIGN @offset 0x2d4 @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of frames received with alignment error\n  }\n\n//---  Register IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register\n  IEEE_R_MACERR @offset 0x2d8 @ro $u32 {\n    16\n    COUNT:16 // at 0: Receive FIFO overflow count\n  }\n\n//---  Register IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register\n  IEEE_R_FDXFC @offset 0x2dc @ro $u32 {\n    16\n    COUNT:16 // at 0: Number of flow-control pause frames received\n  }\n\n//---  Register IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register\n  IEEE_R_OCTETS_OK @offset 0x2e0 @ro $u32 {\n    COUNT:32 // at 0: Number of octets for frames received without error\n  }\n\n//---  Register ATCR: Adjustable Timer Control Register\n  ATCR @offset 0x400 $u32 {\n    18\n    SLAVE // at 13: Enable Timer Slave Mode\n    1\n    CAPTURE // at 11: Capture Timer Value\n    1\n    RESTART // at 9: Reset Timer\n    1\n    PINPER // at 7: Enables event signal output assertion on period event\n    2\n    PEREN // at 4: Enable Periodical Event\n    OFFRST // at 3: Reset Timer On Offset Event\n    OFFEN // at 2: Enable One-Shot Offset Event\n    1\n    EN // at 0: Enable Timer\n  }\n\n//---  Register ATVR: Timer Value Register\n  ATVR @offset 0x404 $u32 {\n    ATIME:32 // at 0: A write sets the timer\n  }\n\n//---  Register ATOFF: Timer Offset Register\n  ATOFF @offset 0x408 $u32 {\n    OFFSET:32 // at 0: Offset value for one-shot event generation\n  }\n\n//---  Register ATPER: Timer Period Register\n  ATPER @offset 0x40c $u32 {\n    PERIOD:32 // at 0: Value for generating periodic events\n  }\n\n//---  Register ATCOR: Timer Correction Register\n  ATCOR @offset 0x410 $u32 {\n    1\n    COR:31 // at 0: Correction Counter Wrap-Around Value\n  }\n\n//---  Register ATINC: Time-Stamping Clock Period Register\n  ATINC @offset 0x414 $u32 {\n    17\n    INC_CORR:7 // at 8: Correction Increment Value\n    1\n    INC:7 // at 0: Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds\n  }\n\n//---  Register ATSTMP: Timestamp of Last Transmitted Frame\n  ATSTMP @offset 0x418 @ro $u32 {\n    TIMESTAMP:32 // at 0: Timestamp of the last frame transmitted by the core that had TxBD[TS] set\n  }\n\n//---  Register TGSR: Timer Global Status Register\n  TGSR @offset 0x604 $u32 {\n    28\n    TF3 // at 3: Copy Of Timer Flag For Channel 3\n    TF2 // at 2: Copy Of Timer Flag For Channel 2\n    TF1 // at 1: Copy Of Timer Flag For Channel 1\n    TF0 // at 0: Copy Of Timer Flag For Channel 0\n  }\n\n//---  Registers TCSR(0,1,2,3): Timer Control Status Register\n  TCSR [4 @offset 0x608 @inc 0x8]\n  TCSR0 @offset 0x608\n  TCSR1 @offset 0x610\n  TCSR2 @offset 0x618\n  TCSR3 @offset 0x620 $u32 {\n    24\n    TF // at 7: Timer Flag\n    TIE // at 6: Timer Interrupt Enable\n    TMODE:4 // at 2: Timer Mode\n    1\n    TDRE // at 0: Timer DMA Request Enable\n  }\n\n//---  Registers TCCR(0,1,2,3): Timer Compare Capture Register\n  TCCR [4 @offset 0x60c @inc 0x8]\n  TCCR0 @offset 0x60c\n  TCCR1 @offset 0x614\n  TCCR2 @offset 0x61c\n  TCCR3 @offset 0x624 $u32 {\n    TCC:32 // at 0: Timer Capture Compare\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral EWM: External Watchdog Monitor\n//------------------------------------------------------------------------------\n\nregisters EWM @at 0x40061000 {\n//---  Register CTRL: Control Register\n  CTRL @offset 0x0 $u8 {\n    4\n    INTEN // at 3: Interrupt Enable.\n    INEN // at 2: Input Enable.\n    ASSIN // at 1: EWM_in's Assertion State Select.\n    EWMEN // at 0: EWM enable.\n  }\n\n//---  Register SERV: Service Register\n  SERV @offset 0x1 $u8 {\n    SERVICE:8 // at 0: The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C\n  }\n\n//---  Register CMPL: Compare Low Register\n  CMPL @offset 0x2 $u8 {\n    COMPAREL:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required\n  }\n\n//---  Register CMPH: Compare High Register\n  CMPH @offset 0x3 $u8 {\n    COMPAREH:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FB: FlexBus external bus interface\n//------------------------------------------------------------------------------\n\nregisters FB @at 0x4000c000 {\n//---  Registers CSAR(0,1,2,3,4,5): Chip Select Address Register\n  CSAR [6 @offset 0x0 @inc 0xc]\n  CSAR0 @offset 0x0\n  CSAR1 @offset 0xc\n  CSAR2 @offset 0x18\n  CSAR3 @offset 0x24\n  CSAR4 @offset 0x30\n  CSAR5 @offset 0x3c $u32 {\n    BA:16 // at 16: Base Address\n    16\n  }\n\n//---  Registers CSMR(0,1,2,3,4,5): Chip Select Mask Register\n  CSMR [6 @offset 0x4 @inc 0xc]\n  CSMR0 @offset 0x4\n  CSMR1 @offset 0x10\n  CSMR2 @offset 0x1c\n  CSMR3 @offset 0x28\n  CSMR4 @offset 0x34\n  CSMR5 @offset 0x40 $u32 {\n    BAM:16 // at 16: Base Address Mask\n    7\n    WP // at 8: Write Protect\n    7\n    V // at 0: Valid\n  }\n\n//---  Registers CSCR(0,1,2,3,4,5): Chip Select Control Register\n  CSCR [6 @offset 0x8 @inc 0xc]\n  CSCR0 @offset 0x8\n  CSCR1 @offset 0x14\n  CSCR2 @offset 0x20\n  CSCR3 @offset 0x2c\n  CSCR4 @offset 0x38\n  CSCR5 @offset 0x44 $u32 {\n    SWS:6 // at 26: Secondary Wait States\n    2\n    SWSEN // at 23: Secondary Wait State Enable\n    EXTS // at 22: Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.\n    ASET:2 // at 20: Address Setup\n    RDAH:2 // at 18: Read Address Hold or Deselect\n    WRAH:2 // at 16: Write Address Hold or Deselect\n    WS:6 // at 10: Wait States\n    BLS // at 9: Byte-Lane Shift\n    AA // at 8: Auto-Acknowledge Enable\n    PS:2 // at 6: Port Size\n    BEM // at 5: Byte-Enable Mode\n    BSTR // at 4: Burst-Read Enable\n    BSTW // at 3: Burst-Write Enable\n    3\n  }\n\n//---  Register CSPMCR: Chip Select port Multiplexing Control Register\n  CSPMCR @offset 0x60 $u32 {\n    GROUP1:4 // at 28: FlexBus Signal Group 1 Multiplex control\n    GROUP2:4 // at 24: FlexBus Signal Group 2 Multiplex control\n    GROUP3:4 // at 20: FlexBus Signal Group 3 Multiplex control\n    GROUP4:4 // at 16: FlexBus Signal Group 4 Multiplex control\n    GROUP5:4 // at 12: FlexBus Signal Group 5 Multiplex control\n    12\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FMC: Flash Memory Controller-greg\n//------------------------------------------------------------------------------\n\nregisters FMC @at 0x4001f000 {\n//---  Register PFAPR: Flash Access Protection Register\n  PFAPR @offset 0x0 $u32 {\n    8\n    M7PFD // at 23: Master 7 Prefetch Disable\n    M6PFD // at 22: Master 6 Prefetch Disable\n    M5PFD // at 21: Master 5 Prefetch Disable\n    M4PFD // at 20: Master 4 Prefetch Disable\n    M3PFD // at 19: Master 3 Prefetch Disable\n    M2PFD // at 18: Master 2 Prefetch Disable\n    M1PFD // at 17: Master 1 Prefetch Disable\n    M0PFD // at 16: Master 0 Prefetch Disable\n    M7AP:2 // at 14: Master 7 Access Protection\n    M6AP:2 // at 12: Master 6 Access Protection\n    M5AP:2 // at 10: Master 5 Access Protection\n    M4AP:2 // at 8: Master 4 Access Protection\n    M3AP:2 // at 6: Master 3 Access Protection\n    M2AP:2 // at 4: Master 2 Access Protection\n    M1AP:2 // at 2: Master 1 Access Protection\n    M0AP:2 // at 0: Master 0 Access Protection\n  }\n\n//---  Register PFB01CR: Flash Bank 0-1 Control Register\n  PFB01CR @offset 0x4 $u32 {\n    B0RWSC:4 // at 28: Bank 0 Read Wait State Control\n    CLCK_WAY:4 // at 24: Cache Lock Way x\n    CINV_WAY:4 // at 20: Cache Invalidate Way x\n    S_B_INV // at 19: Invalidate Prefetch Speculation Buffer\n    B0MW:2 // at 17: Bank 0 Memory Width\n    9\n    CRC:3 // at 5: Cache Replacement Control\n    B0DCE // at 4: Bank 0 Data Cache Enable\n    B0ICE // at 3: Bank 0 Instruction Cache Enable\n    B0DPE // at 2: Bank 0 Data Prefetch Enable\n    B0IPE // at 1: Bank 0 Instruction Prefetch Enable\n    RFU // at 0: Reserved for future use\n  }\n\n//---  Register PFB23CR: Flash Bank 2-3 Control Register\n  PFB23CR @offset 0x8 $u32 {\n    B1RWSC:4 // at 28: Bank 1 Read Wait State Control\n    9\n    B1MW:2 // at 17: Bank 1 Memory Width\n    12\n    B1DCE // at 4: Bank 1 Data Cache Enable\n    B1ICE // at 3: Bank 1 Instruction Cache Enable\n    B1DPE // at 2: Bank 1 Data Prefetch Enable\n    B1IPE // at 1: Bank 1 Instruction Prefetch Enable\n    RFU // at 0: Reserved for future use\n  }\n\n//---  Registers TAGVDW0S(0,1,2,3): Cache Tag Storage\n  TAGVDW0S [4 @offset 0x100 @inc 0x4]\n  TAGVDW0S0 @offset 0x100\n  TAGVDW0S1 @offset 0x104\n  TAGVDW0S2 @offset 0x108\n  TAGVDW0S3 @offset 0x10c $u32 {\n    10\n    tag:16 // at 6: 16-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers TAGVDW1S(0,1,2,3): Cache Tag Storage\n  TAGVDW1S [4 @offset 0x110 @inc 0x4]\n  TAGVDW1S0 @offset 0x110\n  TAGVDW1S1 @offset 0x114\n  TAGVDW1S2 @offset 0x118\n  TAGVDW1S3 @offset 0x11c $u32 {\n    10\n    tag:16 // at 6: 16-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers TAGVDW2S(0,1,2,3): Cache Tag Storage\n  TAGVDW2S [4 @offset 0x120 @inc 0x4]\n  TAGVDW2S0 @offset 0x120\n  TAGVDW2S1 @offset 0x124\n  TAGVDW2S2 @offset 0x128\n  TAGVDW2S3 @offset 0x12c $u32 {\n    10\n    tag:16 // at 6: 16-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers TAGVDW3S(0,1,2,3): Cache Tag Storage\n  TAGVDW3S [4 @offset 0x130 @inc 0x4]\n  TAGVDW3S0 @offset 0x130\n  TAGVDW3S1 @offset 0x134\n  TAGVDW3S2 @offset 0x138\n  TAGVDW3S3 @offset 0x13c $u32 {\n    10\n    tag:16 // at 6: 16-bit tag for cache entry\n    5\n    valid // at 0: 1-bit valid for cache entry\n  }\n\n//---  Registers DATAW0SUM(0,1,2,3): Cache Data Storage (uppermost word)\n  DATAW0SUM [4 @offset 0x200 @inc 0x10]\n  DATAW0S0UM @offset 0x200\n  DATAW0S1UM @offset 0x210\n  DATAW0S2UM @offset 0x220\n  DATAW0S3UM @offset 0x230 $u32 {\n    data:32 // at 0: Bits [127:96] of data entry\n  }\n\n//---  Registers DATAW0SMU(0,1,2,3): Cache Data Storage (mid-upper word)\n  DATAW0SMU [4 @offset 0x204 @inc 0x10]\n  DATAW0S0MU @offset 0x204\n  DATAW0S1MU @offset 0x214\n  DATAW0S2MU @offset 0x224\n  DATAW0S3MU @offset 0x234 $u32 {\n    data:32 // at 0: Bits [95:64] of data entry\n  }\n\n//---  Registers DATAW0SML(0,1,2,3): Cache Data Storage (mid-lower word)\n  DATAW0SML [4 @offset 0x208 @inc 0x10]\n  DATAW0S0ML @offset 0x208\n  DATAW0S1ML @offset 0x218\n  DATAW0S2ML @offset 0x228\n  DATAW0S3ML @offset 0x238 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW0SLM(0,1,2,3): Cache Data Storage (lowermost word)\n  DATAW0SLM [4 @offset 0x20c @inc 0x10]\n  DATAW0S0LM @offset 0x20c\n  DATAW0S1LM @offset 0x21c\n  DATAW0S2LM @offset 0x22c\n  DATAW0S3LM @offset 0x23c $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n//---  Registers DATAW1SUM(0,1,2,3): Cache Data Storage (uppermost word)\n  DATAW1SUM [4 @offset 0x240 @inc 0x10]\n  DATAW1S0UM @offset 0x240\n  DATAW1S1UM @offset 0x250\n  DATAW1S2UM @offset 0x260\n  DATAW1S3UM @offset 0x270 $u32 {\n    data:32 // at 0: Bits [127:96] of data entry\n  }\n\n//---  Registers DATAW1SMU(0,1,2,3): Cache Data Storage (mid-upper word)\n  DATAW1SMU [4 @offset 0x244 @inc 0x10]\n  DATAW1S0MU @offset 0x244\n  DATAW1S1MU @offset 0x254\n  DATAW1S2MU @offset 0x264\n  DATAW1S3MU @offset 0x274 $u32 {\n    data:32 // at 0: Bits [95:64] of data entry\n  }\n\n//---  Registers DATAW1SML(0,1,2,3): Cache Data Storage (mid-lower word)\n  DATAW1SML [4 @offset 0x248 @inc 0x10]\n  DATAW1S0ML @offset 0x248\n  DATAW1S1ML @offset 0x258\n  DATAW1S2ML @offset 0x268\n  DATAW1S3ML @offset 0x278 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW1SLM(0,1,2,3): Cache Data Storage (lowermost word)\n  DATAW1SLM [4 @offset 0x24c @inc 0x10]\n  DATAW1S0LM @offset 0x24c\n  DATAW1S1LM @offset 0x25c\n  DATAW1S2LM @offset 0x26c\n  DATAW1S3LM @offset 0x27c $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n//---  Registers DATAW2SUM(0,1,2,3): Cache Data Storage (uppermost word)\n  DATAW2SUM [4 @offset 0x280 @inc 0x10]\n  DATAW2S0UM @offset 0x280\n  DATAW2S1UM @offset 0x290\n  DATAW2S2UM @offset 0x2a0\n  DATAW2S3UM @offset 0x2b0 $u32 {\n    data:32 // at 0: Bits [127:96] of data entry\n  }\n\n//---  Registers DATAW2SMU(0,1,2,3): Cache Data Storage (mid-upper word)\n  DATAW2SMU [4 @offset 0x284 @inc 0x10]\n  DATAW2S0MU @offset 0x284\n  DATAW2S1MU @offset 0x294\n  DATAW2S2MU @offset 0x2a4\n  DATAW2S3MU @offset 0x2b4 $u32 {\n    data:32 // at 0: Bits [95:64] of data entry\n  }\n\n//---  Registers DATAW2SML(0,1,2,3): Cache Data Storage (mid-lower word)\n  DATAW2SML [4 @offset 0x288 @inc 0x10]\n  DATAW2S0ML @offset 0x288\n  DATAW2S1ML @offset 0x298\n  DATAW2S2ML @offset 0x2a8\n  DATAW2S3ML @offset 0x2b8 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW2SLM(0,1,2,3): Cache Data Storage (lowermost word)\n  DATAW2SLM [4 @offset 0x28c @inc 0x10]\n  DATAW2S0LM @offset 0x28c\n  DATAW2S1LM @offset 0x29c\n  DATAW2S2LM @offset 0x2ac\n  DATAW2S3LM @offset 0x2bc $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n//---  Registers DATAW3SUM(0,1,2,3): Cache Data Storage (uppermost word)\n  DATAW3SUM [4 @offset 0x2c0 @inc 0x10]\n  DATAW3S0UM @offset 0x2c0\n  DATAW3S1UM @offset 0x2d0\n  DATAW3S2UM @offset 0x2e0\n  DATAW3S3UM @offset 0x2f0 $u32 {\n    data:32 // at 0: Bits [127:96] of data entry\n  }\n\n//---  Registers DATAW3SMU(0,1,2,3): Cache Data Storage (mid-upper word)\n  DATAW3SMU [4 @offset 0x2c4 @inc 0x10]\n  DATAW3S0MU @offset 0x2c4\n  DATAW3S1MU @offset 0x2d4\n  DATAW3S2MU @offset 0x2e4\n  DATAW3S3MU @offset 0x2f4 $u32 {\n    data:32 // at 0: Bits [95:64] of data entry\n  }\n\n//---  Registers DATAW3SML(0,1,2,3): Cache Data Storage (mid-lower word)\n  DATAW3SML [4 @offset 0x2c8 @inc 0x10]\n  DATAW3S0ML @offset 0x2c8\n  DATAW3S1ML @offset 0x2d8\n  DATAW3S2ML @offset 0x2e8\n  DATAW3S3ML @offset 0x2f8 $u32 {\n    data:32 // at 0: Bits [63:32] of data entry\n  }\n\n//---  Registers DATAW3SLM(0,1,2,3): Cache Data Storage (lowermost word)\n  DATAW3SLM [4 @offset 0x2cc @inc 0x10]\n  DATAW3S0LM @offset 0x2cc\n  DATAW3S1LM @offset 0x2dc\n  DATAW3S2LM @offset 0x2ec\n  DATAW3S3LM @offset 0x2fc $u32 {\n    data:32 // at 0: Bits [31:0] of data entry\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FTFE: Flash Memory Interface\n//------------------------------------------------------------------------------\n\nregisters FTFE @at 0x40020000 {\n//---  Register FSTAT: Flash Status Register\n  FSTAT @offset 0x0 $u8 {\n    CCIF // at 7: Command Complete Interrupt Flag\n    RDCOLERR // at 6: FTFE Read Collision Error Flag\n    ACCERR // at 5: Flash Access Error Flag\n    FPVIOL // at 4: Flash Protection Violation Flag\n    3\n    MGSTAT0 // at 0: Memory Controller Command Completion Status Flag\n  }\n\n//---  Register FCNFG: Flash Configuration Register\n  FCNFG @offset 0x1 $u8 {\n    CCIE // at 7: Command Complete Interrupt Enable\n    RDCOLLIE // at 6: Read Collision Error Interrupt Enable\n    ERSAREQ // at 5: Erase All Request\n    ERSSUSP // at 4: Erase Suspend\n    SWAP // at 3: Swap\n    PFLSH // at 2: FTFE configuration\n    RAMRDY // at 1: RAM Ready\n    EEERDY // at 0: For devices with FlexNVM: This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access\n  }\n\n//---  Register FSEC: Flash Security Register\n  FSEC @offset 0x2 @ro $u8 {\n    KEYEN:2 // at 6: Backdoor Key Security Enable\n    MEEN:2 // at 4: Mass Erase Enable Bits\n    FSLACC:2 // at 2: Freescale Failure Analysis Access Code\n    SEC:2 // at 0: Flash Security\n  }\n\n//---  Register FOPT: Flash Option Register\n  FOPT @offset 0x3 @ro $u8 {\n    OPT:8 // at 0: Nonvolatile Option\n  }\n\n//---  Register FCCOB_0_3: Flash Common Command Object Registers (0 ... 3)\n  FCCOB_0_3 @offset 0x4 $u32\n//---  Register FCCOB_4_7: Flash Common Command Object Registers (4 ... 7)\n  FCCOB_4_7 @offset 0x8 $u32\n//---  Register FCCOB_8_11: Flash Common Command Object Registers (8 ... 11)\n  FCCOB_8_11 @offset 0xc $u32\n//---  Registers FPROT(3,2,1,0): Program Flash Protection Registers\n  FPROT [4 @offset 0x10 @inc 0x1]\n  FPROT3 @offset 0x10\n  FPROT2 @offset 0x11\n  FPROT1 @offset 0x12\n  FPROT0 @offset 0x13 $u8 {\n    PROT:8 // at 0: Program Flash Region Protect\n  }\n\n//---  Register FEPROT: EEPROM Protection Register\n  FEPROT @offset 0x16 $u8 {\n    EPROT:8 // at 0: EEPROM Region Protect\n  }\n\n//---  Register FDPROT: Data Flash Protection Register\n  FDPROT @offset 0x17 $u8 {\n    DPROT:8 // at 0: Data Flash Region Protect\n  }\n\n//---  Registers XACC(H3,H2,H1,H0,L3,L2,L1,L0): Execute-only Access Registers\n  XACC [8 @offset 0x18 @inc 0x1]\n  XACCH3 @offset 0x18\n  XACCH2 @offset 0x19\n  XACCH1 @offset 0x1a\n  XACCH0 @offset 0x1b\n  XACCL3 @offset 0x1c\n  XACCL2 @offset 0x1d\n  XACCL1 @offset 0x1e\n  XACCL0 @offset 0x1f @ro $u8 {\n    XA:8 // at 0: Execute-only access control\n  }\n\n//---  Registers SACC(H3,H2,H1,H0,L3,L2,L1,L0): Supervisor-only Access Registers\n  SACC [8 @offset 0x20 @inc 0x1]\n  SACCH3 @offset 0x20\n  SACCH2 @offset 0x21\n  SACCH1 @offset 0x22\n  SACCH0 @offset 0x23\n  SACCL3 @offset 0x24\n  SACCL2 @offset 0x25\n  SACCL1 @offset 0x26\n  SACCL0 @offset 0x27 @ro $u8 {\n    SA:8 // at 0: Supervisor-only access control\n  }\n\n//---  Register FACSS: Flash Access Segment Size Register\n  FACSS @offset 0x28 @ro $u8 {\n    SGSIZE:8 // at 0: Segment Size\n  }\n\n//---  Register FACSN: Flash Access Segment Number Register\n  FACSN @offset 0x2b @ro $u8 {\n    NUMSG:8 // at 0: Number of Segments Indicator\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral FTFE_FlashConfig: Flash configuration field\n//------------------------------------------------------------------------------\n\nregisters FTFE_FlashConfig @at 0x400 {\n//---  Register BACKKEY3: Backdoor Comparison Key 3.\n  BACKKEY3 @offset 0x0 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY2: Backdoor Comparison Key 2.\n  BACKKEY2 @offset 0x1 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY1: Backdoor Comparison Key 1.\n  BACKKEY1 @offset 0x2 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY0: Backdoor Comparison Key 0.\n  BACKKEY0 @offset 0x3 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY7: Backdoor Comparison Key 7.\n  BACKKEY7 @offset 0x4 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY6: Backdoor Comparison Key 6.\n  BACKKEY6 @offset 0x5 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY5: Backdoor Comparison Key 5.\n  BACKKEY5 @offset 0x6 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register BACKKEY4: Backdoor Comparison Key 4.\n  BACKKEY4 @offset 0x7 @ro $u8 {\n    KEY:8 // at 0: Backdoor Comparison Key.\n  }\n\n//---  Register FPROT3: Non-volatile P-Flash Protection 1 - Low Register\n  FPROT3 @offset 0x8 @ro $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FPROT2: Non-volatile P-Flash Protection 1 - High Register\n  FPROT2 @offset 0x9 @ro $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FPROT1: Non-volatile P-Flash Protection 0 - Low Register\n  FPROT1 @offset 0xa @ro $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FPROT0: Non-volatile P-Flash Protection 0 - High Register\n  FPROT0 @offset 0xb @ro $u8 {\n    PROT:8 // at 0: P-Flash Region Protect\n  }\n\n//---  Register FSEC: Non-volatile Flash Security Register\n  FSEC @offset 0xc @ro $u8 {\n    KEYEN:2 // at 6: Backdoor Key Security Enable\n    MEEN:2 // at 4: no description available\n    FSLACC:2 // at 2: Freescale Failure Analysis Access Code\n    SEC:2 // at 0: Flash Security\n  }\n\n//---  Register FOPT: Non-volatile Flash Option Register\n  FOPT @offset 0xd @ro $u8 {\n    5\n    NMI_DIS // at 2: no description available\n    EZPORT_DIS // at 1: no description available\n    LPBOOT // at 0: no description available\n  }\n\n//---  Register FEPROT: Non-volatile EERAM Protection Register\n  FEPROT @offset 0xe @ro $u8 {\n    EPROT:8 // at 0: no description available\n  }\n\n//---  Register FDPROT: Non-volatile D-Flash Protection Register\n  FDPROT @offset 0xf @ro $u8 {\n    DPROT:8 // at 0: D-Flash Region Protect\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: FTM [4]\n//        FTM0 at 0x40038000\n//        FTM1 at 0x40039000\n//        FTM2 at 0x4003a000\n//        FTM3 at 0x400b9000\n//------------------------------------------------------------------------------\n\nregisters FTM [4 @at 0x40038000 0x40039000 0x4003a000 0x400b9000]\n          FTM0 @at 0x40038000\n          FTM1 @at 0x40039000\n          FTM2 @at 0x4003a000\n          FTM3 @at 0x400b9000 {\n//---  Register SC: Status And Control\n  SC @offset 0x0 $u32 {\n    24\n    TOF // at 7: Timer Overflow Flag\n    TOIE // at 6: Timer Overflow Interrupt Enable\n    CPWMS // at 5: Center-Aligned PWM Select\n    CLKS:2 // at 3: Clock Source Selection\n    PS:3 // at 0: Prescale Factor Selection\n  }\n\n//---  Register CNT: Counter\n  CNT @offset 0x4 $u32 {\n    16\n    COUNT:16 // at 0: Counter Value\n  }\n\n//---  Register MOD: Modulo\n  MOD @offset 0x8 $u32 {\n    16\n    MOD:16 // at 0: Modulo Value\n  }\n\n//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status And Control\n  CSC [8 @offset 0xc @inc 0x8]\n  C0SC @offset 0xc\n  C1SC @offset 0x14\n  C2SC @offset 0x1c\n  C3SC @offset 0x24\n  C4SC @offset 0x2c\n  C5SC @offset 0x34\n  C6SC @offset 0x3c\n  C7SC @offset 0x44 $u32 {\n    24\n    CHF // at 7: Channel Flag\n    CHIE // at 6: Channel Interrupt Enable\n    MSB // at 5: Channel Mode Select\n    MSA // at 4: Channel Mode Select\n    ELSB // at 3: Edge or Level Select\n    ELSA // at 2: Edge or Level Select\n    1\n    DMA // at 0: DMA Enable\n  }\n\n//---  Registers CV(0,1,2,3,4,5,6,7): Channel (n) Value\n  CV [8 @offset 0x10 @inc 0x8]\n  C0V @offset 0x10\n  C1V @offset 0x18\n  C2V @offset 0x20\n  C3V @offset 0x28\n  C4V @offset 0x30\n  C5V @offset 0x38\n  C6V @offset 0x40\n  C7V @offset 0x48 $u32 {\n    16\n    VAL:16 // at 0: Channel Value\n  }\n\n//---  Register CNTIN: Counter Initial Value\n  CNTIN @offset 0x4c $u32 {\n    16\n    INIT:16 // at 0: Initial Value Of The FTM Counter\n  }\n\n//---  Register STATUS: Capture And Compare Status\n  STATUS @offset 0x50 $u32 {\n    24\n    CH7F // at 7: Channel 7 Flag\n    CH6F // at 6: Channel 6 Flag\n    CH5F // at 5: Channel 5 Flag\n    CH4F // at 4: Channel 4 Flag\n    CH3F // at 3: Channel 3 Flag\n    CH2F // at 2: Channel 2 Flag\n    CH1F // at 1: Channel 1 Flag\n    CH0F // at 0: Channel 0 Flag\n  }\n\n//---  Register MODE: Features Mode Selection\n  MODE @offset 0x54 $u32 {\n    24\n    FAULTIE // at 7: Fault Interrupt Enable\n    FAULTM:2 // at 5: Fault Control Mode\n    CAPTEST // at 4: Capture Test Mode Enable\n    PWMSYNC // at 3: PWM Synchronization Mode\n    WPDIS // at 2: Write Protection Disable\n    INIT // at 1: Initialize The Channels Output\n    FTMEN // at 0: FTM Enable\n  }\n\n//---  Register SYNC: Synchronization\n  SYNC @offset 0x58 $u32 {\n    24\n    SWSYNC // at 7: PWM Synchronization Software Trigger\n    TRIG2 // at 6: PWM Synchronization Hardware Trigger 2\n    TRIG1 // at 5: PWM Synchronization Hardware Trigger 1\n    TRIG0 // at 4: PWM Synchronization Hardware Trigger 0\n    SYNCHOM // at 3: Output Mask Synchronization\n    REINIT // at 2: FTM Counter Reinitialization By Synchronization (FTM counter synchronization)\n    CNTMAX // at 1: Maximum Loading Point Enable\n    CNTMIN // at 0: Minimum Loading Point Enable\n  }\n\n//---  Register OUTINIT: Initial State For Channels Output\n  OUTINIT @offset 0x5c $u32 {\n    24\n    CH7OI // at 7: Channel 7 Output Initialization Value\n    CH6OI // at 6: Channel 6 Output Initialization Value\n    CH5OI // at 5: Channel 5 Output Initialization Value\n    CH4OI // at 4: Channel 4 Output Initialization Value\n    CH3OI // at 3: Channel 3 Output Initialization Value\n    CH2OI // at 2: Channel 2 Output Initialization Value\n    CH1OI // at 1: Channel 1 Output Initialization Value\n    CH0OI // at 0: Channel 0 Output Initialization Value\n  }\n\n//---  Register OUTMASK: Output Mask\n  OUTMASK @offset 0x60 $u32 {\n    24\n    CH7OM // at 7: Channel 7 Output Mask\n    CH6OM // at 6: Channel 6 Output Mask\n    CH5OM // at 5: Channel 5 Output Mask\n    CH4OM // at 4: Channel 4 Output Mask\n    CH3OM // at 3: Channel 3 Output Mask\n    CH2OM // at 2: Channel 2 Output Mask\n    CH1OM // at 1: Channel 1 Output Mask\n    CH0OM // at 0: Channel 0 Output Mask\n  }\n\n//---  Register COMBINE: Function For Linked Channels\n  COMBINE @offset 0x64 $u32 {\n    1\n    FAULTEN3 // at 30: Fault Control Enable For n = 6\n    SYNCEN3 // at 29: Synchronization Enable For n = 6\n    DTEN3 // at 28: Deadtime Enable For n = 6\n    DECAP3 // at 27: Dual Edge Capture Mode Captures For n = 6\n    DECAPEN3 // at 26: Dual Edge Capture Mode Enable For n = 6\n    COMP3 // at 25: Complement Of Channel (n) for n = 6\n    COMBINE3 // at 24: Combine Channels For n = 6\n    1\n    FAULTEN2 // at 22: Fault Control Enable For n = 4\n    SYNCEN2 // at 21: Synchronization Enable For n = 4\n    DTEN2 // at 20: Deadtime Enable For n = 4\n    DECAP2 // at 19: Dual Edge Capture Mode Captures For n = 4\n    DECAPEN2 // at 18: Dual Edge Capture Mode Enable For n = 4\n    COMP2 // at 17: Complement Of Channel (n) For n = 4\n    COMBINE2 // at 16: Combine Channels For n = 4\n    1\n    FAULTEN1 // at 14: Fault Control Enable For n = 2\n    SYNCEN1 // at 13: Synchronization Enable For n = 2\n    DTEN1 // at 12: Deadtime Enable For n = 2\n    DECAP1 // at 11: Dual Edge Capture Mode Captures For n = 2\n    DECAPEN1 // at 10: Dual Edge Capture Mode Enable For n = 2\n    COMP1 // at 9: Complement Of Channel (n) For n = 2\n    COMBINE1 // at 8: Combine Channels For n = 2\n    1\n    FAULTEN0 // at 6: Fault Control Enable For n = 0\n    SYNCEN0 // at 5: Synchronization Enable For n = 0\n    DTEN0 // at 4: Deadtime Enable For n = 0\n    DECAP0 // at 3: Dual Edge Capture Mode Captures For n = 0\n    DECAPEN0 // at 2: Dual Edge Capture Mode Enable For n = 0\n    COMP0 // at 1: Complement Of Channel (n) For n = 0\n    COMBINE0 // at 0: Combine Channels For n = 0\n  }\n\n//---  Register DEADTIME: Deadtime Insertion Control\n  DEADTIME @offset 0x68 $u32 {\n    24\n    DTPS:2 // at 6: Deadtime Prescaler Value\n    DTVAL:6 // at 0: Deadtime Value\n  }\n\n//---  Register EXTTRIG: FTM External Trigger\n  EXTTRIG @offset 0x6c $u32 {\n    24\n    TRIGF // at 7: Channel Trigger Flag\n    INITTRIGEN // at 6: Initialization Trigger Enable\n    CH1TRIG // at 5: Channel 1 Trigger Enable\n    CH0TRIG // at 4: Channel 0 Trigger Enable\n    CH5TRIG // at 3: Channel 5 Trigger Enable\n    CH4TRIG // at 2: Channel 4 Trigger Enable\n    CH3TRIG // at 1: Channel 3 Trigger Enable\n    CH2TRIG // at 0: Channel 2 Trigger Enable\n  }\n\n//---  Register POL: Channels Polarity\n  POL @offset 0x70 $u32 {\n    24\n    POL7 // at 7: Channel 7 Polarity\n    POL6 // at 6: Channel 6 Polarity\n    POL5 // at 5: Channel 5 Polarity\n    POL4 // at 4: Channel 4 Polarity\n    POL3 // at 3: Channel 3 Polarity\n    POL2 // at 2: Channel 2 Polarity\n    POL1 // at 1: Channel 1 Polarity\n    POL0 // at 0: Channel 0 Polarity\n  }\n\n//---  Register FMS: Fault Mode Status\n  FMS @offset 0x74 $u32 {\n    24\n    FAULTF // at 7: Fault Detection Flag\n    WPEN // at 6: Write Protection Enable\n    FAULTIN // at 5: Fault Inputs\n    1\n    FAULTF3 // at 3: Fault Detection Flag 3\n    FAULTF2 // at 2: Fault Detection Flag 2\n    FAULTF1 // at 1: Fault Detection Flag 1\n    FAULTF0 // at 0: Fault Detection Flag 0\n  }\n\n//---  Register FILTER: Input Capture Filter Control\n  FILTER @offset 0x78 $u32 {\n    16\n    CH3FVAL:4 // at 12: Channel 3 Input Filter\n    CH2FVAL:4 // at 8: Channel 2 Input Filter\n    CH1FVAL:4 // at 4: Channel 1 Input Filter\n    CH0FVAL:4 // at 0: Channel 0 Input Filter\n  }\n\n//---  Register FLTCTRL: Fault Control\n  FLTCTRL @offset 0x7c $u32 {\n    20\n    FFVAL:4 // at 8: Fault Input Filter\n    FFLTR3EN // at 7: Fault Input 3 Filter Enable\n    FFLTR2EN // at 6: Fault Input 2 Filter Enable\n    FFLTR1EN // at 5: Fault Input 1 Filter Enable\n    FFLTR0EN // at 4: Fault Input 0 Filter Enable\n    FAULT3EN // at 3: Fault Input 3 Enable\n    FAULT2EN // at 2: Fault Input 2 Enable\n    FAULT1EN // at 1: Fault Input 1 Enable\n    FAULT0EN // at 0: Fault Input 0 Enable\n  }\n\n//---  Register QDCTRL: Quadrature Decoder Control And Status\n  QDCTRL @offset 0x80 $u32 {\n    24\n    PHAFLTREN // at 7: Phase A Input Filter Enable\n    PHBFLTREN // at 6: Phase B Input Filter Enable\n    PHAPOL // at 5: Phase A Input Polarity\n    PHBPOL // at 4: Phase B Input Polarity\n    QUADMODE // at 3: Quadrature Decoder Mode\n    QUADIR // at 2: FTM Counter Direction In Quadrature Decoder Mode\n    TOFDIR // at 1: Timer Overflow Direction In Quadrature Decoder Mode\n    QUADEN // at 0: Quadrature Decoder Mode Enable\n  }\n\n//---  Register CONF: Configuration\n  CONF @offset 0x84 $u32 {\n    21\n    GTBEOUT // at 10: Global Time Base Output\n    GTBEEN // at 9: Global Time Base Enable\n    1\n    BDMMODE:2 // at 6: BDM Mode\n    1\n    NUMTOF:5 // at 0: TOF Frequency\n  }\n\n//---  Register FLTPOL: FTM Fault Input Polarity\n  FLTPOL @offset 0x88 $u32 {\n    28\n    FLT3POL // at 3: Fault Input 3 Polarity\n    FLT2POL // at 2: Fault Input 2 Polarity\n    FLT1POL // at 1: Fault Input 1 Polarity\n    FLT0POL // at 0: Fault Input 0 Polarity\n  }\n\n//---  Register SYNCONF: Synchronization Configuration\n  SYNCONF @offset 0x8c $u32 {\n    11\n    HWSOC // at 20: Software output control synchronization is activated by a hardware trigger.\n    HWINVC // at 19: Inverting control synchronization is activated by a hardware trigger.\n    HWOM // at 18: Output mask synchronization is activated by a hardware trigger.\n    HWWRBUF // at 17: MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.\n    HWRSTCNT // at 16: FTM counter synchronization is activated by a hardware trigger.\n    3\n    SWSOC // at 12: Software output control synchronization is activated by the software trigger.\n    SWINVC // at 11: Inverting control synchronization is activated by the software trigger.\n    SWOM // at 10: Output mask synchronization is activated by the software trigger.\n    SWWRBUF // at 9: MOD, CNTIN, and CV registers synchronization is activated by the software trigger.\n    SWRSTCNT // at 8: FTM counter synchronization is activated by the software trigger.\n    SYNCMODE // at 7: Synchronization Mode\n    1\n    SWOC // at 5: SWOCTRL Register Synchronization\n    INVC // at 4: INVCTRL Register Synchronization\n    1\n    CNTINC // at 2: CNTIN Register Synchronization\n    1\n    HWTRIGMODE // at 0: Hardware Trigger Mode\n  }\n\n//---  Register INVCTRL: FTM Inverting Control\n  INVCTRL @offset 0x90 $u32 {\n    28\n    INV3EN // at 3: Pair Channels 3 Inverting Enable\n    INV2EN // at 2: Pair Channels 2 Inverting Enable\n    INV1EN // at 1: Pair Channels 1 Inverting Enable\n    INV0EN // at 0: Pair Channels 0 Inverting Enable\n  }\n\n//---  Register SWOCTRL: FTM Software Output Control\n  SWOCTRL @offset 0x94 $u32 {\n    16\n    CH7OCV // at 15: Channel 7 Software Output Control Value\n    CH6OCV // at 14: Channel 6 Software Output Control Value\n    CH5OCV // at 13: Channel 5 Software Output Control Value\n    CH4OCV // at 12: Channel 4 Software Output Control Value\n    CH3OCV // at 11: Channel 3 Software Output Control Value\n    CH2OCV // at 10: Channel 2 Software Output Control Value\n    CH1OCV // at 9: Channel 1 Software Output Control Value\n    CH0OCV // at 8: Channel 0 Software Output Control Value\n    CH7OC // at 7: Channel 7 Software Output Control Enable\n    CH6OC // at 6: Channel 6 Software Output Control Enable\n    CH5OC // at 5: Channel 5 Software Output Control Enable\n    CH4OC // at 4: Channel 4 Software Output Control Enable\n    CH3OC // at 3: Channel 3 Software Output Control Enable\n    CH2OC // at 2: Channel 2 Software Output Control Enable\n    CH1OC // at 1: Channel 1 Software Output Control Enable\n    CH0OC // at 0: Channel 0 Software Output Control Enable\n  }\n\n//---  Register PWMLOAD: FTM PWM Load\n  PWMLOAD @offset 0x98 $u32 {\n    22\n    LDOK // at 9: Load Enable\n    1\n    CH7SEL // at 7: Channel 7 Select\n    CH6SEL // at 6: Channel 6 Select\n    CH5SEL // at 5: Channel 5 Select\n    CH4SEL // at 4: Channel 4 Select\n    CH3SEL // at 3: Channel 3 Select\n    CH2SEL // at 2: Channel 2 Select\n    CH1SEL // at 1: Channel 1 Select\n    CH0SEL // at 0: Channel 0 Select\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: GPIO [5]\n//        GPIOA at 0x400ff000\n//        GPIOB at 0x400ff040\n//        GPIOC at 0x400ff080\n//        GPIOD at 0x400ff0c0\n//        GPIOE at 0x400ff100\n//------------------------------------------------------------------------------\n\nregisters GPIO [5 @at 0x400ff000 0x400ff040 0x400ff080 0x400ff0c0 0x400ff100]\n          GPIOA @at 0x400ff000\n          GPIOB @at 0x400ff040\n          GPIOC @at 0x400ff080\n          GPIOD @at 0x400ff0c0\n          GPIOE @at 0x400ff100 {\n//---  Register PDOR: Port Data Output Register\n  PDOR @offset 0x0 $u32 {\n    PDO:32 // at 0: Port Data Output\n  }\n\n//---  Register PSOR: Port Set Output Register\n  PSOR @offset 0x4 $u32 {\n    PTSO:32 // at 0: Port Set Output\n  }\n\n//---  Register PCOR: Port Clear Output Register\n  PCOR @offset 0x8 $u32 {\n    PTCO:32 // at 0: Port Clear Output\n  }\n\n//---  Register PTOR: Port Toggle Output Register\n  PTOR @offset 0xc $u32 {\n    PTTO:32 // at 0: Port Toggle Output\n  }\n\n//---  Register PDIR: Port Data Input Register\n  PDIR @offset 0x10 @ro $u32 {\n    PDI:32 // at 0: Port Data Input\n  }\n\n//---  Register PDDR: Port Data Direction Register\n  PDDR @offset 0x14 $u32 {\n    PDD:32 // at 0: Port Data Direction\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: I2C [4]\n//        I2C0 at 0x40066000\n//        I2C1 at 0x40067000\n//        I2C2 at 0x400e6000\n//        I2C3 at 0x400e7000\n//------------------------------------------------------------------------------\n\nregisters I2C [4 @at 0x40066000 0x40067000 0x400e6000 0x400e7000]\n          I2C0 @at 0x40066000\n          I2C1 @at 0x40067000\n          I2C2 @at 0x400e6000\n          I2C3 @at 0x400e7000 {\n//---  Register A1: I2C Address Register 1\n  A1 @offset 0x0 $u8 {\n    AD:7 // at 1: Address\n    1\n  }\n\n//---  Register F: I2C Frequency Divider register\n  F @offset 0x1 $u8 {\n    MULT:2 // at 6: Multiplier Factor\n    ICR:6 // at 0: ClockRate\n  }\n\n//---  Register C1: I2C Control Register 1\n  C1 @offset 0x2 $u8 {\n    IICEN // at 7: I2C Enable\n    IICIE // at 6: I2C Interrupt Enable\n    MST // at 5: Master Mode Select\n    TX // at 4: Transmit Mode Select\n    TXAK // at 3: Transmit Acknowledge Enable\n    RSTA // at 2: Repeat START\n    WUEN // at 1: Wakeup Enable\n    DMAEN // at 0: DMA Enable\n  }\n\n//---  Register S: I2C Status register\n  S @offset 0x3 $u8 {\n    TCF // at 7: Transfer Complete Flag\n    IAAS // at 6: Addressed As A Slave\n    BUSY // at 5: Bus Busy\n    ARBL // at 4: Arbitration Lost\n    RAM // at 3: Range Address Match\n    SRW // at 2: Slave Read/Write\n    IICIF // at 1: Interrupt Flag\n    RXAK // at 0: Receive Acknowledge\n  }\n\n//---  Register D: I2C Data I/O register\n  D @offset 0x4 $u8 {\n    DATA:8 // at 0: Data\n  }\n\n//---  Register C2: I2C Control Register 2\n  C2 @offset 0x5 $u8 {\n    GCAEN // at 7: General Call Address Enable\n    ADEXT // at 6: Address Extension\n    HDRS // at 5: High Drive Select\n    SBRC // at 4: Slave Baud Rate Control\n    RMEN // at 3: Range Address Matching Enable\n    AD:3 // at 0: Slave Address\n  }\n\n//---  Register FLT: I2C Programmable Input Glitch Filter Register\n  FLT @offset 0x6 $u8 {\n    SHEN // at 7: Stop Hold Enable\n    STOPF // at 6: I2C Bus Stop Detect Flag\n    SSIE // at 5: I2C Bus Stop or Start Interrupt Enable\n    STARTF // at 4: I2C Bus Start Detect Flag\n    FLT:4 // at 0: I2C Programmable Filter Factor\n  }\n\n//---  Register RA: I2C Range Address register\n  RA @offset 0x7 $u8 {\n    RAD:7 // at 1: Range Slave Address\n    1\n  }\n\n//---  Register SMB: I2C SMBus Control and Status register\n  SMB @offset 0x8 $u8 {\n    FACK // at 7: Fast NACK/ACK Enable\n    ALERTEN // at 6: SMBus Alert Response Address Enable\n    SIICAEN // at 5: Second I2C Address Enable\n    TCKSEL // at 4: Timeout Counter Clock Select\n    SLTF // at 3: SCL Low Timeout Flag\n    SHTF1 // at 2: SCL High Timeout Flag 1\n    SHTF2 // at 1: SCL High Timeout Flag 2\n    SHTF2IE // at 0: SHTF2 Interrupt Enable\n  }\n\n//---  Register A2: I2C Address Register 2\n  A2 @offset 0x9 $u8 {\n    SAD:7 // at 1: SMBus Address\n    1\n  }\n\n//---  Register SLTH: I2C SCL Low Timeout Register High\n  SLTH @offset 0xa $u8 {\n    SSLT:8 // at 0: SSLT[15:8]\n  }\n\n//---  Register SLTL: I2C SCL Low Timeout Register Low\n  SLTL @offset 0xb $u8 {\n    SSLT:8 // at 0: SSLT[7:0]\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral I2S0: Inter-IC Sound / Synchronous Audio Interface\n//------------------------------------------------------------------------------\n\nregisters I2S0 @at 0x4002f000 {\n//---  Register TCSR: SAI Transmit Control Register\n  TCSR @offset 0x0 $u32 {\n    TE // at 31: Transmitter Enable\n    STOPE // at 30: Stop Enable\n    DBGE // at 29: Debug Enable\n    BCE // at 28: Bit Clock Enable\n    2\n    FR // at 25: FIFO Reset\n    SR // at 24: Software Reset\n    3\n    WSF // at 20: Word Start Flag\n    SEF // at 19: Sync Error Flag\n    FEF // at 18: FIFO Error Flag\n    FWF // at 17: FIFO Warning Flag\n    FRF // at 16: FIFO Request Flag\n    3\n    WSIE // at 12: Word Start Interrupt Enable\n    SEIE // at 11: Sync Error Interrupt Enable\n    FEIE // at 10: FIFO Error Interrupt Enable\n    FWIE // at 9: FIFO Warning Interrupt Enable\n    FRIE // at 8: FIFO Request Interrupt Enable\n    6\n    FWDE // at 1: FIFO Warning DMA Enable\n    FRDE // at 0: FIFO Request DMA Enable\n  }\n\n//---  Register TCR1: SAI Transmit Configuration 1 Register\n  TCR1 @offset 0x4 $u32 {\n    29\n    TFW:3 // at 0: Transmit FIFO Watermark\n  }\n\n//---  Register TCR2: SAI Transmit Configuration 2 Register\n  TCR2 @offset 0x8 $u32 {\n    SYNC:2 // at 30: Synchronous Mode\n    BCS // at 29: Bit Clock Swap\n    BCI // at 28: Bit Clock Input\n    MSEL:2 // at 26: MCLK Select\n    BCP // at 25: Bit Clock Polarity\n    BCD // at 24: Bit Clock Direction\n    16\n    DIV:8 // at 0: Bit Clock Divide\n  }\n\n//---  Register TCR3: SAI Transmit Configuration 3 Register\n  TCR3 @offset 0xc $u32 {\n    6\n    CFR:2 // at 24: Channel FIFO Reset\n    6\n    TCE:2 // at 16: Transmit Channel Enable\n    11\n    WDFL:5 // at 0: Word Flag Configuration\n  }\n\n//---  Register TCR4: SAI Transmit Configuration 4 Register\n  TCR4 @offset 0x10 $u32 {\n    3\n    FCONT // at 28: FIFO Continue on Error\n    FCOMB:2 // at 26: FIFO Combine Mode\n    FPACK:2 // at 24: FIFO Packing Mode\n    3\n    FRSZ:5 // at 16: Frame size\n    3\n    SYWD:5 // at 8: Sync Width\n    3\n    MF // at 4: MSB First\n    FSE // at 3: Frame Sync Early\n    ONDEM // at 2: On Demand Mode\n    FSP // at 1: Frame Sync Polarity\n    FSD // at 0: Frame Sync Direction\n  }\n\n//---  Register TCR5: SAI Transmit Configuration 5 Register\n  TCR5 @offset 0x14 $u32 {\n    3\n    WNW:5 // at 24: Word N Width\n    3\n    W0W:5 // at 16: Word 0 Width\n    3\n    FBT:5 // at 8: First Bit Shifted\n    8\n  }\n\n//---  Registers TDR(0,1): SAI Transmit Data Register\n  TDR [2 @offset 0x20 @inc 0x4]\n  TDR0 @offset 0x20\n  TDR1 @offset 0x24 $u32 {\n    TDR:32 // at 0: Transmit Data Register\n  }\n\n//---  Registers TFR(0,1): SAI Transmit FIFO Register\n  TFR [2 @offset 0x40 @inc 0x4]\n  TFR0 @offset 0x40\n  TFR1 @offset 0x44 @ro $u32 {\n    WCP // at 31: Write Channel Pointer\n    11\n    WFP:4 // at 16: Write FIFO Pointer\n    12\n    RFP:4 // at 0: Read FIFO Pointer\n  }\n\n//---  Register TMR: SAI Transmit Mask Register\n  TMR @offset 0x60 $u32 {\n    TWM:32 // at 0: Transmit Word Mask\n  }\n\n//---  Register RCSR: SAI Receive Control Register\n  RCSR @offset 0x80 $u32 {\n    RE // at 31: Receiver Enable\n    STOPE // at 30: Stop Enable\n    DBGE // at 29: Debug Enable\n    BCE // at 28: Bit Clock Enable\n    2\n    FR // at 25: FIFO Reset\n    SR // at 24: Software Reset\n    3\n    WSF // at 20: Word Start Flag\n    SEF // at 19: Sync Error Flag\n    FEF // at 18: FIFO Error Flag\n    FWF // at 17: FIFO Warning Flag\n    FRF // at 16: FIFO Request Flag\n    3\n    WSIE // at 12: Word Start Interrupt Enable\n    SEIE // at 11: Sync Error Interrupt Enable\n    FEIE // at 10: FIFO Error Interrupt Enable\n    FWIE // at 9: FIFO Warning Interrupt Enable\n    FRIE // at 8: FIFO Request Interrupt Enable\n    6\n    FWDE // at 1: FIFO Warning DMA Enable\n    FRDE // at 0: FIFO Request DMA Enable\n  }\n\n//---  Register RCR1: SAI Receive Configuration 1 Register\n  RCR1 @offset 0x84 $u32 {\n    29\n    RFW:3 // at 0: Receive FIFO Watermark\n  }\n\n//---  Register RCR2: SAI Receive Configuration 2 Register\n  RCR2 @offset 0x88 $u32 {\n    SYNC:2 // at 30: Synchronous Mode\n    BCS // at 29: Bit Clock Swap\n    BCI // at 28: Bit Clock Input\n    MSEL:2 // at 26: MCLK Select\n    BCP // at 25: Bit Clock Polarity\n    BCD // at 24: Bit Clock Direction\n    16\n    DIV:8 // at 0: Bit Clock Divide\n  }\n\n//---  Register RCR3: SAI Receive Configuration 3 Register\n  RCR3 @offset 0x8c $u32 {\n    6\n    CFR:2 // at 24: Channel FIFO Reset\n    6\n    RCE:2 // at 16: Receive Channel Enable\n    11\n    WDFL:5 // at 0: Word Flag Configuration\n  }\n\n//---  Register RCR4: SAI Receive Configuration 4 Register\n  RCR4 @offset 0x90 $u32 {\n    3\n    FCONT // at 28: FIFO Continue on Error\n    FCOMB:2 // at 26: FIFO Combine Mode\n    FPACK:2 // at 24: FIFO Packing Mode\n    3\n    FRSZ:5 // at 16: Frame Size\n    3\n    SYWD:5 // at 8: Sync Width\n    3\n    MF // at 4: MSB First\n    FSE // at 3: Frame Sync Early\n    ONDEM // at 2: On Demand Mode\n    FSP // at 1: Frame Sync Polarity\n    FSD // at 0: Frame Sync Direction\n  }\n\n//---  Register RCR5: SAI Receive Configuration 5 Register\n  RCR5 @offset 0x94 $u32 {\n    3\n    WNW:5 // at 24: Word N Width\n    3\n    W0W:5 // at 16: Word 0 Width\n    3\n    FBT:5 // at 8: First Bit Shifted\n    8\n  }\n\n//---  Registers RDR(0,1): SAI Receive Data Register\n  RDR [2 @offset 0xa0 @inc 0x4]\n  RDR0 @offset 0xa0\n  RDR1 @offset 0xa4 @ro $u32 {\n    RDR:32 // at 0: Receive Data Register\n  }\n\n//---  Registers RFR(0,1): SAI Receive FIFO Register\n  RFR [2 @offset 0xc0 @inc 0x4]\n  RFR0 @offset 0xc0\n  RFR1 @offset 0xc4 @ro $u32 {\n    12\n    WFP:4 // at 16: Write FIFO Pointer\n    RCP // at 15: Receive Channel Pointer\n    11\n    RFP:4 // at 0: Read FIFO Pointer\n  }\n\n//---  Register RMR: SAI Receive Mask Register\n  RMR @offset 0xe0 $u32 {\n    RWM:32 // at 0: Receive Word Mask\n  }\n\n//---  Register MCR: SAI MCLK Control Register\n  MCR @offset 0x100 $u32 {\n    DUF // at 31: Divider Update Flag\n    MOE // at 30: MCLK Output Enable\n    4\n    MICS:2 // at 24: MCLK Input Clock Select\n    24\n  }\n\n//---  Register MDR: SAI MCLK Divide Register\n  MDR @offset 0x104 $u32 {\n    12\n    FRACT:8 // at 12: MCLK Fraction\n    DIVIDE:12 // at 0: MCLK Divide\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral LLWU: Low leakage wakeup unit\n//------------------------------------------------------------------------------\n\nregisters LLWU @at 0x4007c000 {\n//---  Register PE1: LLWU Pin Enable 1 register\n  PE1 @offset 0x0 $u8 {\n    WUPE3:2 // at 6: Wakeup Pin Enable For LLWU_P3\n    WUPE2:2 // at 4: Wakeup Pin Enable For LLWU_P2\n    WUPE1:2 // at 2: Wakeup Pin Enable For LLWU_P1\n    WUPE0:2 // at 0: Wakeup Pin Enable For LLWU_P0\n  }\n\n//---  Register PE2: LLWU Pin Enable 2 register\n  PE2 @offset 0x1 $u8 {\n    WUPE7:2 // at 6: Wakeup Pin Enable For LLWU_P7\n    WUPE6:2 // at 4: Wakeup Pin Enable For LLWU_P6\n    WUPE5:2 // at 2: Wakeup Pin Enable For LLWU_P5\n    WUPE4:2 // at 0: Wakeup Pin Enable For LLWU_P4\n  }\n\n//---  Register PE3: LLWU Pin Enable 3 register\n  PE3 @offset 0x2 $u8 {\n    WUPE11:2 // at 6: Wakeup Pin Enable For LLWU_P11\n    WUPE10:2 // at 4: Wakeup Pin Enable For LLWU_P10\n    WUPE9:2 // at 2: Wakeup Pin Enable For LLWU_P9\n    WUPE8:2 // at 0: Wakeup Pin Enable For LLWU_P8\n  }\n\n//---  Register PE4: LLWU Pin Enable 4 register\n  PE4 @offset 0x3 $u8 {\n    WUPE15:2 // at 6: Wakeup Pin Enable For LLWU_P15\n    WUPE14:2 // at 4: Wakeup Pin Enable For LLWU_P14\n    WUPE13:2 // at 2: Wakeup Pin Enable For LLWU_P13\n    WUPE12:2 // at 0: Wakeup Pin Enable For LLWU_P12\n  }\n\n//---  Register PE5: LLWU Pin Enable 5 register\n  PE5 @offset 0x4 $u8 {\n    WUPE19:2 // at 6: Wakeup Pin Enable For LLWU_P19\n    WUPE18:2 // at 4: Wakeup Pin Enable For LLWU_P18\n    WUPE17:2 // at 2: Wakeup Pin Enable For LLWU_P17\n    WUPE16:2 // at 0: Wakeup Pin Enable For LLWU_P16\n  }\n\n//---  Register PE6: LLWU Pin Enable 6 register\n  PE6 @offset 0x5 $u8 {\n    WUPE23:2 // at 6: Wakeup Pin Enable For LLWU_P23\n    WUPE22:2 // at 4: Wakeup Pin Enable For LLWU_P22\n    WUPE21:2 // at 2: Wakeup Pin Enable For LLWU_P21\n    WUPE20:2 // at 0: Wakeup Pin Enable For LLWU_P20\n  }\n\n//---  Register PE7: LLWU Pin Enable 7 register\n  PE7 @offset 0x6 $u8 {\n    WUPE27:2 // at 6: Wakeup Pin Enable For LLWU_P27\n    WUPE26:2 // at 4: Wakeup Pin Enable For LLWU_P26\n    WUPE25:2 // at 2: Wakeup Pin Enable For LLWU_P25\n    WUPE24:2 // at 0: Wakeup Pin Enable For LLWU_P24\n  }\n\n//---  Register PE8: LLWU Pin Enable 8 register\n  PE8 @offset 0x7 $u8 {\n    WUPE31:2 // at 6: Wakeup Pin Enable For LLWU_P31\n    WUPE30:2 // at 4: Wakeup Pin Enable For LLWU_P30\n    WUPE29:2 // at 2: Wakeup Pin Enable For LLWU_P29\n    WUPE28:2 // at 0: Wakeup Pin Enable For LLWU_P28\n  }\n\n//---  Register ME: LLWU Module Enable register\n  ME @offset 0x8 $u8 {\n    WUME7 // at 7: Wakeup Module Enable For Module 7\n    WUME6 // at 6: Wakeup Module Enable For Module 6\n    WUME5 // at 5: Wakeup Module Enable For Module 5\n    WUME4 // at 4: Wakeup Module Enable For Module 4\n    WUME3 // at 3: Wakeup Module Enable For Module 3\n    WUME2 // at 2: Wakeup Module Enable For Module 2\n    WUME1 // at 1: Wakeup Module Enable for Module 1\n    WUME0 // at 0: Wakeup Module Enable For Module 0\n  }\n\n//---  Register PF1: LLWU Pin Flag 1 register\n  PF1 @offset 0x9 $u8 {\n    WUF7 // at 7: Wakeup Flag For LLWU_P7\n    WUF6 // at 6: Wakeup Flag For LLWU_P6\n    WUF5 // at 5: Wakeup Flag For LLWU_P5\n    WUF4 // at 4: Wakeup Flag For LLWU_P4\n    WUF3 // at 3: Wakeup Flag For LLWU_P3\n    WUF2 // at 2: Wakeup Flag For LLWU_P2\n    WUF1 // at 1: Wakeup Flag For LLWU_P1\n    WUF0 // at 0: Wakeup Flag For LLWU_P0\n  }\n\n//---  Register PF2: LLWU Pin Flag 2 register\n  PF2 @offset 0xa $u8 {\n    WUF15 // at 7: Wakeup Flag For LLWU_P15\n    WUF14 // at 6: Wakeup Flag For LLWU_P14\n    WUF13 // at 5: Wakeup Flag For LLWU_P13\n    WUF12 // at 4: Wakeup Flag For LLWU_P12\n    WUF11 // at 3: Wakeup Flag For LLWU_P11\n    WUF10 // at 2: Wakeup Flag For LLWU_P10\n    WUF9 // at 1: Wakeup Flag For LLWU_P9\n    WUF8 // at 0: Wakeup Flag For LLWU_P8\n  }\n\n//---  Register PF3: LLWU Pin Flag 3 register\n  PF3 @offset 0xb $u8 {\n    WUF23 // at 7: Wakeup Flag For LLWU_P23\n    WUF22 // at 6: Wakeup Flag For LLWU_P22\n    WUF21 // at 5: Wakeup Flag For LLWU_P21\n    WUF20 // at 4: Wakeup Flag For LLWU_P20\n    WUF19 // at 3: Wakeup Flag For LLWU_P19\n    WUF18 // at 2: Wakeup Flag For LLWU_P18\n    WUF17 // at 1: Wakeup Flag For LLWU_P17\n    WUF16 // at 0: Wakeup Flag For LLWU_P16\n  }\n\n//---  Register PF4: LLWU Pin Flag 4 register\n  PF4 @offset 0xc $u8 {\n    WUF31 // at 7: Wakeup Flag For LLWU_P31\n    WUF30 // at 6: Wakeup Flag For LLWU_P30\n    WUF29 // at 5: Wakeup Flag For LLWU_P29\n    WUF28 // at 4: Wakeup Flag For LLWU_P28\n    WUF27 // at 3: Wakeup Flag For LLWU_P27\n    WUF26 // at 2: Wakeup Flag For LLWU_P26\n    WUF25 // at 1: Wakeup Flag For LLWU_P25\n    WUF24 // at 0: Wakeup Flag For LLWU_P24\n  }\n\n//---  Register MF5: LLWU Module Flag 5 register\n  MF5 @offset 0xd @ro $u8 {\n    MWUF7 // at 7: Wakeup flag For module 7\n    MWUF6 // at 6: Wakeup flag For module 6\n    MWUF5 // at 5: Wakeup flag For module 5\n    MWUF4 // at 4: Wakeup flag For module 4\n    MWUF3 // at 3: Wakeup flag For module 3\n    MWUF2 // at 2: Wakeup flag For module 2\n    MWUF1 // at 1: Wakeup flag For module 1\n    MWUF0 // at 0: Wakeup flag For module 0\n  }\n\n//---  Register FILT1: LLWU Pin Filter 1 register\n  FILT1 @offset 0xe $u8 {\n    FILTF // at 7: Filter Detect Flag\n    FILTE:2 // at 5: Digital Filter On External Pin\n    FILTSEL:5 // at 0: Filter Pin Select\n  }\n\n//---  Register FILT2: LLWU Pin Filter 2 register\n  FILT2 @offset 0xf $u8 {\n    FILTF // at 7: Filter Detect Flag\n    FILTE:2 // at 5: Digital Filter On External Pin\n    FILTSEL:5 // at 0: Filter Pin Select\n  }\n\n//---  Register FILT3: LLWU Pin Filter 3 register\n  FILT3 @offset 0x10 $u8 {\n    FILTF // at 7: Filter Detect Flag\n    FILTE:2 // at 5: Digital Filter On External Pin\n    FILTSEL:5 // at 0: Filter Pin Select\n  }\n\n//---  Register FILT4: LLWU Pin Filter 4 register\n  FILT4 @offset 0x11 $u8 {\n    FILTF // at 7: Filter Detect Flag\n    FILTE:2 // at 5: Digital Filter On External Pin\n    FILTSEL:5 // at 0: Filter Pin Select\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral LMEM: Local Memory Controller\n//------------------------------------------------------------------------------\n\nregisters LMEM @at 0xe0082000 {\n//---  Register PCCCR: Cache control register\n  PCCCR @offset 0x0 $u32 {\n    GO // at 31: Initiate Cache Command\n    3\n    PUSHW1 // at 27: Push Way 1\n    INVW1 // at 26: Invalidate Way 1\n    PUSHW0 // at 25: Push Way 0\n    INVW0 // at 24: Invalidate Way 0\n    20\n    PCCR3 // at 3: Forces no allocation on cache misses (must also have PCCR2 asserted)\n    PCCR2 // at 2: Forces all cacheable spaces to write through\n    ENWRBUF // at 1: Enable Write Buffer\n    ENCACHE // at 0: Cache enable\n  }\n\n//---  Register PCCLCR: Cache line control register\n  PCCLCR @offset 0x4 $u32 {\n    4\n    LACC // at 27: Line access type\n    LADSEL // at 26: Line Address Select\n    LCMD:2 // at 24: Line Command\n    1\n    LCWAY // at 22: Line Command Way\n    LCIMB // at 21: Line Command Initial Modified Bit\n    LCIVB // at 20: Line Command Initial Valid Bit\n    3\n    TDSEL // at 16: Tag/Data Select\n    1\n    WSEL // at 14: Way select\n    2\n    CACHEADDR:10 // at 2: Cache address\n    1\n    LGO // at 0: Initiate Cache Line Command\n  }\n\n//---  Register PCCSAR: Cache search address register\n  PCCSAR @offset 0x8 $u32 {\n    PHYADDR:30 // at 2: Physical Address\n    1\n    LGO // at 0: Initiate Cache Line Command\n  }\n\n//---  Register PCCCVR: Cache read/write value register\n  PCCCVR @offset 0xc $u32 {\n    DATA:32 // at 0: Cache read/write Data\n  }\n\n//---  Register PCCRMR: Cache regions mode register\n  PCCRMR @offset 0x20 $u32 {\n    R0:2 // at 30: Region 0 mode\n    R1:2 // at 28: Region 1 mode\n    R2:2 // at 26: Region 2 mode\n    R3:2 // at 24: Region 3 mode\n    R4:2 // at 22: Region 4 mode\n    R5:2 // at 20: Region 5 mode\n    R6:2 // at 18: Region 6 mode\n    R7:2 // at 16: Region 7 mode\n    R8:2 // at 14: Region 8 mode\n    R9:2 // at 12: Region 9 mode\n    R10:2 // at 10: Region 10 mode\n    R11:2 // at 8: Region 11 mode\n    R12:2 // at 6: Region 12 mode\n    R13:2 // at 4: Region 13 mode\n    R14:2 // at 2: Region 14 mode\n    R15:2 // at 0: Region 15 mode\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral LPTMR0: Low Power Timer\n//------------------------------------------------------------------------------\n\nregisters LPTMR0 @at 0x40040000 {\n//---  Register CSR: Low Power Timer Control Status Register\n  CSR @offset 0x0 $u32 {\n    24\n    TCF // at 7: Timer Compare Flag\n    TIE // at 6: Timer Interrupt Enable\n    TPS:2 // at 4: Timer Pin Select\n    TPP // at 3: Timer Pin Polarity\n    TFC // at 2: Timer Free-Running Counter\n    TMS // at 1: Timer Mode Select\n    TEN // at 0: Timer Enable\n  }\n\n//---  Register PSR: Low Power Timer Prescale Register\n  PSR @offset 0x4 $u32 {\n    25\n    PRESCALE:4 // at 3: Prescale Value\n    PBYP // at 2: Prescaler Bypass\n    PCS:2 // at 0: Prescaler Clock Select\n  }\n\n//---  Register CMR: Low Power Timer Compare Register\n  CMR @offset 0x8 $u32 {\n    16\n    COMPARE:16 // at 0: Compare Value\n  }\n\n//---  Register CNR: Low Power Timer Counter Register\n  CNR @offset 0xc $u32 {\n    16\n    COUNTER:16 // at 0: Counter Value\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral LPUART0: Universal Asynchronous Receiver/Transmitter\n//------------------------------------------------------------------------------\n\nregisters LPUART0 @at 0x400c4000 {\n//---  Register BAUD: LPUART Baud Rate Register\n  BAUD @offset 0x0 $u32 {\n    MAEN1 // at 31: Match Address Mode Enable 1\n    MAEN2 // at 30: Match Address Mode Enable 2\n    M10 // at 29: 10-bit Mode select\n    OSR:5 // at 24: Over Sampling Ratio\n    TDMAE // at 23: Transmitter DMA Enable\n    1\n    RDMAE // at 21: Receiver Full DMA Enable\n    1\n    MATCFG:2 // at 18: Match Configuration\n    BOTHEDGE // at 17: Both Edge Sampling\n    RESYNCDIS // at 16: Resynchronization Disable\n    LBKDIE // at 15: LIN Break Detect Interrupt Enable\n    RXEDGIE // at 14: RX Input Active Edge Interrupt Enable\n    SBNS // at 13: Stop Bit Number Select\n    SBR:13 // at 0: Baud Rate Modulo Divisor.\n  }\n\n//---  Register STAT: LPUART Status Register\n  STAT @offset 0x4 $u32 {\n    LBKDIF // at 31: LIN Break Detect Interrupt Flag\n    RXEDGIF // at 30: LPUART_RX Pin Active Edge Interrupt Flag\n    MSBF // at 29: MSB First\n    RXINV // at 28: Receive Data Inversion\n    RWUID // at 27: Receive Wake Up Idle Detect\n    BRK13 // at 26: Break Character Generation Length\n    LBKDE // at 25: LIN Break Detection Enable\n    RAF // at 24: Receiver Active Flag\n    TDRE // at 23: Transmit Data Register Empty Flag\n    TC // at 22: Transmission Complete Flag\n    RDRF // at 21: Receive Data Register Full Flag\n    IDLE // at 20: Idle Line Flag\n    OR // at 19: Receiver Overrun Flag\n    NF // at 18: Noise Flag\n    FE // at 17: Framing Error Flag\n    PF // at 16: Parity Error Flag\n    MA1F // at 15: Match 1 Flag\n    MA2F // at 14: Match 2 Flag\n    14\n  }\n\n//---  Register CTRL: LPUART Control Register\n  CTRL @offset 0x8 $u32 {\n    R8T9 // at 31: Receive Bit 8 / Transmit Bit 9\n    R9T8 // at 30: Receive Bit 9 / Transmit Bit 8\n    TXDIR // at 29: LPUART_TX Pin Direction in Single-Wire Mode\n    TXINV // at 28: Transmit Data Inversion\n    ORIE // at 27: Overrun Interrupt Enable\n    NEIE // at 26: Noise Error Interrupt Enable\n    FEIE // at 25: Framing Error Interrupt Enable\n    PEIE // at 24: Parity Error Interrupt Enable\n    TIE // at 23: Transmit Interrupt Enable\n    TCIE // at 22: Transmission Complete Interrupt Enable for\n    RIE // at 21: Receiver Interrupt Enable\n    ILIE // at 20: Idle Line Interrupt Enable\n    TE // at 19: Transmitter Enable\n    RE // at 18: Receiver Enable\n    RWU // at 17: Receiver Wakeup Control\n    SBK // at 16: Send Break\n    MA1IE // at 15: Match 1 Interrupt Enable\n    MA2IE // at 14: Match 2 Interrupt Enable\n    3\n    IDLECFG:3 // at 8: Idle Configuration\n    LOOPS // at 7: Loop Mode Select\n    DOZEEN // at 6: Doze Enable\n    RSRC // at 5: Receiver Source Select\n    M // at 4: 9-Bit or 8-Bit Mode Select\n    WAKE // at 3: Receiver Wakeup Method Select\n    ILT // at 2: Idle Line Type Select\n    PE // at 1: Parity Enable\n    PT // at 0: Parity Type\n  }\n\n//---  Register DATA: LPUART Data Register\n  DATA @offset 0xc $u32 {\n    16\n    NOISY // at 15: The current received dataword contained in DATA[R9:R0] was received with noise.\n    PARITYE // at 14: The current received dataword contained in DATA[R9:R0] was received with a parity error.\n    FRETSC // at 13: Frame Error / Transmit Special Character\n    RXEMPT // at 12: Receive Buffer Empty\n    IDLINE // at 11: Idle Line\n    1\n    R9T9 // at 9: Read receive data buffer 9 or write transmit data buffer 9.\n    R8T8 // at 8: Read receive data buffer 8 or write transmit data buffer 8.\n    R7T7 // at 7: Read receive data buffer 7 or write transmit data buffer 7.\n    R6T6 // at 6: Read receive data buffer 6 or write transmit data buffer 6.\n    R5T5 // at 5: Read receive data buffer 5 or write transmit data buffer 5.\n    R4T4 // at 4: Read receive data buffer 4 or write transmit data buffer 4.\n    R3T3 // at 3: Read receive data buffer 3 or write transmit data buffer 3.\n    R2T2 // at 2: Read receive data buffer 2 or write transmit data buffer 2.\n    R1T1 // at 1: Read receive data buffer 1 or write transmit data buffer 1.\n    R0T0 // at 0: Read receive data buffer 0 or write transmit data buffer 0.\n  }\n\n//---  Register MATCH: LPUART Match Address Register\n  MATCH @offset 0x10 $u32 {\n    6\n    MA2:10 // at 16: Match Address 2\n    6\n    MA1:10 // at 0: Match Address 1\n  }\n\n//---  Register MODIR: LPUART Modem IrDA Register\n  MODIR @offset 0x14 $u32 {\n    13\n    IREN // at 18: Infrared enable\n    TNP:2 // at 16: Transmitter narrow pulse\n    10\n    TXCTSSRC // at 5: Transmit CTS Source\n    TXCTSC // at 4: Transmit CTS Configuration\n    RXRTSE // at 3: Receiver request-to-send enable\n    TXRTSPOL // at 2: Transmitter request-to-send polarity\n    TXRTSE // at 1: Transmitter request-to-send enable\n    TXCTSE // at 0: Transmitter clear-to-send enable\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral MCG: Multipurpose Clock Generator module\n//------------------------------------------------------------------------------\n\nregisters MCG @at 0x40064000 {\n//---  Register C1: MCG Control 1 Register\n  C1 @offset 0x0 $u8 {\n    CLKS:2 // at 6: Clock Source Select\n    FRDIV:3 // at 3: FLL External Reference Divider\n    IREFS // at 2: Internal Reference Select\n    IRCLKEN // at 1: Internal Reference Clock Enable\n    IREFSTEN // at 0: Internal Reference Stop Enable\n  }\n\n//---  Register C2: MCG Control 2 Register\n  C2 @offset 0x1 $u8 {\n    LOCRE0 // at 7: Loss of Clock Reset Enable\n    FCFTRIM // at 6: Fast Internal Reference Clock Fine Trim\n    RANGE:2 // at 4: Frequency Range Select\n    HGO // at 3: High Gain Oscillator Select\n    EREFS // at 2: External Reference Select\n    LP // at 1: Low Power Select\n    IRCS // at 0: Internal Reference Clock Select\n  }\n\n//---  Register C3: MCG Control 3 Register\n  C3 @offset 0x2 $u8 {\n    SCTRIM:8 // at 0: Slow Internal Reference Clock Trim Setting\n  }\n\n//---  Register C4: MCG Control 4 Register\n  C4 @offset 0x3 $u8 {\n    DMX32 // at 7: DCO Maximum Frequency with 32.768 kHz Reference\n    DRST_DRS:2 // at 5: DCO Range Select\n    FCTRIM:4 // at 1: Fast Internal Reference Clock Trim Setting\n    SCFTRIM // at 0: Slow Internal Reference Clock Fine Trim\n  }\n\n//---  Register C5: MCG Control 5 Register\n  C5 @offset 0x4 $u8 {\n    1\n    PLLCLKEN // at 6: PLL Clock Enable\n    PLLSTEN // at 5: PLL Stop Enable\n    2\n    PRDIV:3 // at 0: PLL External Reference Divider\n  }\n\n//---  Register C6: MCG Control 6 Register\n  C6 @offset 0x5 $u8 {\n    LOLIE0 // at 7: Loss of Lock Interrrupt Enable\n    PLLS // at 6: PLL Select\n    CME0 // at 5: Clock Monitor Enable\n    VDIV:5 // at 0: VCO Divider\n  }\n\n//---  Register S: MCG Status Register\n  S @offset 0x6 $u8 {\n    LOLS0 // at 7: Loss of Lock Status\n    LOCK0 // at 6: Lock Status\n    PLLST // at 5: PLL Select Status\n    IREFST // at 4: Internal Reference Status\n    CLKST:2 // at 2: Clock Mode Status\n    OSCINIT0 // at 1: OSC Initialization\n    IRCST // at 0: Internal Reference Clock Status\n  }\n\n//---  Register SC: MCG Status and Control Register\n  SC @offset 0x8 $u8 {\n    ATME // at 7: Automatic Trim Machine Enable\n    ATMS // at 6: Automatic Trim Machine Select\n    ATMF // at 5: Automatic Trim Machine Fail Flag\n    FLTPRSRV // at 4: FLL Filter Preserve Enable\n    FCRDIV:3 // at 1: Fast Clock Internal Reference Divider\n    LOCS0 // at 0: OSC0 Loss of Clock Status\n  }\n\n//---  Register ATCVH: MCG Auto Trim Compare Value High Register\n  ATCVH @offset 0xa $u8 {\n    ATCVH:8 // at 0: ATM Compare Value High\n  }\n\n//---  Register ATCVL: MCG Auto Trim Compare Value Low Register\n  ATCVL @offset 0xb $u8 {\n    ATCVL:8 // at 0: ATM Compare Value Low\n  }\n\n//---  Register C7: MCG Control 7 Register\n  C7 @offset 0xc $u8 {\n    6\n    OSCSEL:2 // at 0: MCG OSC Clock Select\n  }\n\n//---  Register C8: MCG Control 8 Register\n  C8 @offset 0xd $u8 {\n    LOCRE1 // at 7: Loss of Clock Reset Enable\n    LOLRE // at 6: PLL Loss of Lock Reset Enable\n    CME1 // at 5: Clock Monitor Enable1\n    4\n    LOCS1 // at 0: RTC Loss of Clock Status\n  }\n\n//---  Register C9: MCG Control 9 Register\n  C9 @offset 0xe $u8 {\n    2\n    PLL_CME // at 5: MCG External PLL Clock Monitor Enable\n    PLL_LOCRE // at 4: MCG External PLL Loss of Clock Reset Enable\n    3\n    EXT_PLL_LOCS // at 0: External PLL Loss of Clock Status\n  }\n\n//---  Register C11: MCG Control 11 Register\n  C11 @offset 0x10 $u8 {\n    3\n    PLLCS // at 4: PLL Clock Select\n    4\n  }\n\n//---  Register S2: MCG Status 2 Register\n  S2 @offset 0x12 @ro $u8 {\n    3\n    PLLCST // at 4: PLL Clock Select Status\n    4\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral MCM: Core Platform Miscellaneous Control Module\n//------------------------------------------------------------------------------\n\nregisters MCM @at 0xe0080000 {\n//---  Register PLASC: Crossbar Switch (AXBS) Slave Configuration\n  PLASC @offset 0x8 @ro $u16 {\n    8\n    ASC:8 // at 0: Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.\n  }\n\n//---  Register PLAMC: Crossbar Switch (AXBS) Master Configuration\n  PLAMC @offset 0xa @ro $u16 {\n    8\n    AMC:8 // at 0: Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.\n  }\n\n//---  Register CR: Control Register\n  CR @offset 0xc $u32 {\n    1\n    SRAMLWP // at 30: SRAM_L Write Protect\n    SRAMLAP:2 // at 28: SRAM_L arbitration priority\n    1\n    SRAMUWP // at 26: SRAM_U write protect\n    SRAMUAP:2 // at 24: SRAM_U arbitration priority\n    24\n  }\n\n//---  Register ISCR: Interrupt Status Register\n  ISCR @offset 0x10 $u32 {\n    FIDCE // at 31: FPU input denormal interrupt enable\n    2\n    FIXCE // at 28: FPU inexact interrupt enable\n    FUFCE // at 27: FPU underflow interrupt enable\n    FOFCE // at 26: FPU overflow interrupt enable\n    FDZCE // at 25: FPU divide-by-zero interrupt enable\n    FIOCE // at 24: FPU invalid operation interrupt enable\n    8\n    FIDC // at 15: FPU input denormal interrupt status\n    2\n    FIXC // at 12: FPU inexact interrupt status\n    FUFC // at 11: FPU underflow interrupt status\n    FOFC // at 10: FPU overflow interrupt status\n    FDZC // at 9: FPU divide-by-zero interrupt status\n    FIOC // at 8: FPU invalid operation interrupt status\n    4\n    DHREQ // at 3: Debug Halt Request Indicator\n    NMI // at 2: Non-maskable Interrupt Pending\n    IRQ // at 1: Normal Interrupt Pending\n    1\n  }\n\n//---  Register ETBCC: ETB Counter Control register\n  ETBCC @offset 0x14 $u32 {\n    26\n    ITDIS // at 5: ITM-To-TPIU Disable\n    ETDIS // at 4: ETM-To-TPIU Disable\n    RLRQ // at 3: Reload Request\n    RSPT:2 // at 1: Response Type\n    CNTEN // at 0: Counter Enable\n  }\n\n//---  Register ETBRL: ETB Reload register\n  ETBRL @offset 0x18 $u32 {\n    21\n    RELOAD:11 // at 0: Byte Count Reload Value\n  }\n\n//---  Register ETBCNT: ETB Counter Value register\n  ETBCNT @offset 0x1c @ro $u32 {\n    21\n    COUNTER:11 // at 0: Byte Count Counter Value\n  }\n\n//---  Register FADR: Fault address register\n  FADR @offset 0x20 @ro $u32 {\n    ADDRESS:32 // at 0: Fault address\n  }\n\n//---  Register FATR: Fault attributes register\n  FATR @offset 0x24 @ro $u32 {\n    BEOVR // at 31: Bus error overrun\n    19\n    BEMN:4 // at 8: Bus error master number\n    BEWT // at 7: Bus error write\n    1\n    BESZ:2 // at 4: Bus error size\n    2\n    BEMD // at 1: Bus error privilege level\n    BEDA // at 0: Bus error access type\n  }\n\n//---  Register FDR: Fault data register\n  FDR @offset 0x28 @ro $u32 {\n    DATA:32 // at 0: Fault data\n  }\n\n//---  Register PID: Process ID register\n  PID @offset 0x30 $u32 {\n    24\n    PID:8 // at 0: M0_PID And M1_PID For MPU\n  }\n\n//---  Register CPO: Compute Operation Control Register\n  CPO @offset 0x40 $u32 {\n    29\n    CPOWOI // at 2: Compute Operation wakeup on interrupt\n    CPOACK // at 1: Compute Operation acknowledge\n    CPOREQ // at 0: Compute Operation request\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral MPU: Memory protection unit\n//------------------------------------------------------------------------------\n\nregisters MPU @at 0x4000d000 {\n//---  Register CESR: Control/Error Status Register\n  CESR @offset 0x0 $u32 {\n    SPERR:5 // at 27: Slave Port n Error\n    7\n    HRL:4 // at 16: Hardware Revision Level\n    NSP:4 // at 12: Number Of Slave Ports\n    NRGD:4 // at 8: Number Of Region Descriptors\n    7\n    VLD // at 0: Valid\n  }\n\n//---  Registers EAR(0,1,2,3,4): Error Address Register, slave port n\n  EAR [5 @offset 0x10 @inc 0x8]\n  EAR0 @offset 0x10\n  EAR1 @offset 0x18\n  EAR2 @offset 0x20\n  EAR3 @offset 0x28\n  EAR4 @offset 0x30 @ro $u32 {\n    EADDR:32 // at 0: Error Address\n  }\n\n//---  Registers EDR(0,1,2,3,4): Error Detail Register, slave port n\n  EDR [5 @offset 0x14 @inc 0x8]\n  EDR0 @offset 0x14\n  EDR1 @offset 0x1c\n  EDR2 @offset 0x24\n  EDR3 @offset 0x2c\n  EDR4 @offset 0x34 @ro $u32 {\n    EACD:16 // at 16: Error Access Control Detail\n    EPID:8 // at 8: Error Process Identification\n    EMN:4 // at 4: Error Master Number\n    EATTR:3 // at 1: Error Attributes\n    ERW // at 0: Error Read/Write\n  }\n\n//---  Registers RGD_WORD0(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 0\n  RGD_WORD0 [12 @offset 0x400 @inc 0x10]\n  RGD0_WORD0 @offset 0x400\n  RGD1_WORD0 @offset 0x410\n  RGD2_WORD0 @offset 0x420\n  RGD3_WORD0 @offset 0x430\n  RGD4_WORD0 @offset 0x440\n  RGD5_WORD0 @offset 0x450\n  RGD6_WORD0 @offset 0x460\n  RGD7_WORD0 @offset 0x470\n  RGD8_WORD0 @offset 0x480\n  RGD9_WORD0 @offset 0x490\n  RGD10_WORD0 @offset 0x4a0\n  RGD11_WORD0 @offset 0x4b0 $u32 {\n    SRTADDR:27 // at 5: Start Address\n    5\n  }\n\n//---  Registers RGD_WORD1(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 1\n  RGD_WORD1 [12 @offset 0x404 @inc 0x10]\n  RGD0_WORD1 @offset 0x404\n  RGD1_WORD1 @offset 0x414\n  RGD2_WORD1 @offset 0x424\n  RGD3_WORD1 @offset 0x434\n  RGD4_WORD1 @offset 0x444\n  RGD5_WORD1 @offset 0x454\n  RGD6_WORD1 @offset 0x464\n  RGD7_WORD1 @offset 0x474\n  RGD8_WORD1 @offset 0x484\n  RGD9_WORD1 @offset 0x494\n  RGD10_WORD1 @offset 0x4a4\n  RGD11_WORD1 @offset 0x4b4 $u32 {\n    ENDADDR:27 // at 5: End Address\n    5\n  }\n\n//---  Registers RGD_WORD2(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 2\n  RGD_WORD2 [12 @offset 0x408 @inc 0x10]\n  RGD0_WORD2 @offset 0x408\n  RGD1_WORD2 @offset 0x418\n  RGD2_WORD2 @offset 0x428\n  RGD3_WORD2 @offset 0x438\n  RGD4_WORD2 @offset 0x448\n  RGD5_WORD2 @offset 0x458\n  RGD6_WORD2 @offset 0x468\n  RGD7_WORD2 @offset 0x478\n  RGD8_WORD2 @offset 0x488\n  RGD9_WORD2 @offset 0x498\n  RGD10_WORD2 @offset 0x4a8\n  RGD11_WORD2 @offset 0x4b8 $u32 {\n    M7RE // at 31: Bus Master 7 Read Enable\n    M7WE // at 30: Bus Master 7 Write Enable\n    M6RE // at 29: Bus Master 6 Read Enable\n    M6WE // at 28: Bus Master 6 Write Enable\n    M5RE // at 27: Bus Master 5 Read Enable\n    M5WE // at 26: Bus Master 5 Write Enable\n    M4RE // at 25: Bus Master 4 Read Enable\n    M4WE // at 24: Bus Master 4 Write Enable\n    M3PE // at 23: Bus Master 3 Process Identifier Enable\n    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control\n    M3UM:3 // at 18: Bus Master 3 User Mode Access Control\n    M2PE // at 17: Bus Master 2 Process Identifier Enable\n    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control\n    M2UM:3 // at 12: Bus Master 2 User Mode Access control\n    M1PE // at 11: Bus Master 1 Process Identifier enable\n    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control\n    M1UM:3 // at 6: Bus Master 1 User Mode Access Control\n    M0PE // at 5: Bus Master 0 Process Identifier enable\n    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control\n    M0UM:3 // at 0: Bus Master 0 User Mode Access Control\n  }\n\n//---  Registers RGD_WORD3(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 3\n  RGD_WORD3 [12 @offset 0x40c @inc 0x10]\n  RGD0_WORD3 @offset 0x40c\n  RGD1_WORD3 @offset 0x41c\n  RGD2_WORD3 @offset 0x42c\n  RGD3_WORD3 @offset 0x43c\n  RGD4_WORD3 @offset 0x44c\n  RGD5_WORD3 @offset 0x45c\n  RGD6_WORD3 @offset 0x46c\n  RGD7_WORD3 @offset 0x47c\n  RGD8_WORD3 @offset 0x48c\n  RGD9_WORD3 @offset 0x49c\n  RGD10_WORD3 @offset 0x4ac\n  RGD11_WORD3 @offset 0x4bc $u32 {\n    PID:8 // at 24: Process Identifier\n    PIDMASK:8 // at 16: Process Identifier Mask\n    15\n    VLD // at 0: Valid\n  }\n\n//---  Registers RGDAAC(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor Alternate Access Control n\n  RGDAAC [12 @offset 0x800 @inc 0x4]\n  RGDAAC0 @offset 0x800\n  RGDAAC1 @offset 0x804\n  RGDAAC2 @offset 0x808\n  RGDAAC3 @offset 0x80c\n  RGDAAC4 @offset 0x810\n  RGDAAC5 @offset 0x814\n  RGDAAC6 @offset 0x818\n  RGDAAC7 @offset 0x81c\n  RGDAAC8 @offset 0x820\n  RGDAAC9 @offset 0x824\n  RGDAAC10 @offset 0x828\n  RGDAAC11 @offset 0x82c $u32 {\n    M7RE // at 31: Bus Master 7 Read Enable\n    M7WE // at 30: Bus Master 7 Write Enable\n    M6RE // at 29: Bus Master 6 Read Enable\n    M6WE // at 28: Bus Master 6 Write Enable\n    M5RE // at 27: Bus Master 5 Read Enable\n    M5WE // at 26: Bus Master 5 Write Enable\n    M4RE // at 25: Bus Master 4 Read Enable\n    M4WE // at 24: Bus Master 4 Write Enable\n    M3PE // at 23: Bus Master 3 Process Identifier Enable\n    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control\n    M3UM:3 // at 18: Bus Master 3 User Mode Access Control\n    M2PE // at 17: Bus Master 2 Process Identifier Enable\n    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control\n    M2UM:3 // at 12: Bus Master 2 User Mode Access Control\n    M1PE // at 11: Bus Master 1 Process Identifier Enable\n    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control\n    M1UM:3 // at 6: Bus Master 1 User Mode Access Control\n    M0PE // at 5: Bus Master 0 Process Identifier Enable\n    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control\n    M0UM:3 // at 0: Bus Master 0 User Mode Access Control\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral OSC: Oscillator\n//------------------------------------------------------------------------------\n\nregisters OSC @at 0x40065000 {\n//---  Register CR: OSC Control Register\n  CR @offset 0x0 $u8 {\n    ERCLKEN // at 7: External Reference Enable\n    1\n    EREFSTEN // at 5: External Reference Stop Enable\n    1\n    SC2P // at 3: Oscillator 2 pF Capacitor Load Configure\n    SC4P // at 2: Oscillator 4 pF Capacitor Load Configure\n    SC8P // at 1: Oscillator 8 pF Capacitor Load Configure\n    SC16P // at 0: Oscillator 16 pF Capacitor Load Configure\n  }\n\n//---  Register DIV: OSC_DIV\n  DIV @offset 0x2 $u8 {\n    ERPS:2 // at 6: ERCLK prescaler\n    6\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral PDB0: Programmable Delay Block\n//------------------------------------------------------------------------------\n\nregisters PDB0 @at 0x40036000 {\n//---  Register SC: Status and Control register\n  SC @offset 0x0 $u32 {\n    12\n    LDMOD:2 // at 18: Load Mode Select\n    PDBEIE // at 17: PDB Sequence Error Interrupt Enable\n    SWTRIG // at 16: Software Trigger\n    DMAEN // at 15: DMA Enable\n    PRESCALER:3 // at 12: Prescaler Divider Select\n    TRGSEL:4 // at 8: Trigger Input Source Select\n    PDBEN // at 7: PDB Enable\n    PDBIF // at 6: PDB Interrupt Flag\n    PDBIE // at 5: PDB Interrupt Enable\n    1\n    MULT:2 // at 2: Multiplication Factor Select for Prescaler\n    CONT // at 1: Continuous Mode Enable\n    LDOK // at 0: Load OK\n  }\n\n//---  Register MOD: Modulus register\n  MOD @offset 0x4 $u32 {\n    16\n    MOD:16 // at 0: PDB Modulus\n  }\n\n//---  Register CNT: Counter register\n  CNT @offset 0x8 @ro $u32 {\n    16\n    CNT:16 // at 0: PDB Counter\n  }\n\n//---  Register IDLY: Interrupt Delay register\n  IDLY @offset 0xc $u32 {\n    16\n    IDLY:16 // at 0: PDB Interrupt Delay\n  }\n\n//---  Registers CHC1(0,1): Channel n Control register 1\n  CHC1 [2 @offset 0x10 @inc 0x28]\n  CH0C1 @offset 0x10\n  CH1C1 @offset 0x38 $u32 {\n    8\n    BB:8 // at 16: PDB Channel Pre-Trigger Back-to-Back Operation Enable\n    TOS:8 // at 8: PDB Channel Pre-Trigger Output Select\n    EN:8 // at 0: PDB Channel Pre-Trigger Enable\n  }\n\n//---  Registers CHS(0,1): Channel n Status register\n  CHS [2 @offset 0x14 @inc 0x28]\n  CH0S @offset 0x14\n  CH1S @offset 0x3c $u32 {\n    8\n    CF:8 // at 16: PDB Channel Flags\n    8\n    ERR:8 // at 0: PDB Channel Sequence Error Flags\n  }\n\n//---  Registers CHDLY0(0,1): Channel n Delay 0 register\n  CHDLY0 [2 @offset 0x18 @inc 0x28]\n  CH0DLY0 @offset 0x18\n  CH1DLY0 @offset 0x40 $u32 {\n    16\n    DLY:16 // at 0: PDB Channel Delay\n  }\n\n//---  Registers CHDLY1(0,1): Channel n Delay 1 register\n  CHDLY1 [2 @offset 0x1c @inc 0x28]\n  CH0DLY1 @offset 0x1c\n  CH1DLY1 @offset 0x44 $u32 {\n    16\n    DLY:16 // at 0: PDB Channel Delay\n  }\n\n//---  Registers DACINTC(0,1): DAC Interval Trigger n Control register\n  DACINTC [2 @offset 0x150 @inc 0x8]\n  DACINTC0 @offset 0x150\n  DACINTC1 @offset 0x158 $u32 {\n    30\n    EXT // at 1: DAC External Trigger Input Enable\n    TOE // at 0: DAC Interval Trigger Enable\n  }\n\n//---  Registers DACINT(0,1): DAC Interval n register\n  DACINT [2 @offset 0x154 @inc 0x8]\n  DACINT0 @offset 0x154\n  DACINT1 @offset 0x15c $u32 {\n    16\n    INT:16 // at 0: DAC Interval\n  }\n\n//---  Register POEN: Pulse-Out n Enable register\n  POEN @offset 0x190 $u32 {\n    24\n    POEN:8 // at 0: PDB Pulse-Out Enable\n  }\n\n//---  Registers PODLY(0,1,2,3): Pulse-Out n Delay register\n  PODLY [4 @offset 0x194 @inc 0x4]\n  PO0DLY @offset 0x194\n  PO1DLY @offset 0x198\n  PO2DLY @offset 0x19c\n  PO3DLY @offset 0x1a0 $u32 {\n    DLY1:16 // at 16: PDB Pulse-Out Delay 1\n    DLY2:16 // at 0: PDB Pulse-Out Delay 2\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral PIT: Periodic Interrupt Timer\n//------------------------------------------------------------------------------\n\nregisters PIT @at 0x40037000 {\n//---  Register MCR: PIT Module Control Register\n  MCR @offset 0x0 $u32 {\n    30\n    MDIS // at 1: Module Disable - (PIT section)\n    FRZ // at 0: Freeze\n  }\n\n//---  Register LTMR64H: PIT Upper Lifetime Timer Register\n  LTMR64H @offset 0xe0 @ro $u32 {\n    LTH:32 // at 0: Life Timer value\n  }\n\n//---  Register LTMR64L: PIT Lower Lifetime Timer Register\n  LTMR64L @offset 0xe4 @ro $u32 {\n    LTL:32 // at 0: Life Timer value\n  }\n\n//---  Registers LDVAL(0,1,2,3): Timer Load Value Register\n  LDVAL [4 @offset 0x100 @inc 0x10]\n  LDVAL0 @offset 0x100\n  LDVAL1 @offset 0x110\n  LDVAL2 @offset 0x120\n  LDVAL3 @offset 0x130 $u32 {\n    TSV:32 // at 0: Timer Start Value\n  }\n\n//---  Registers CVAL(0,1,2,3): Current Timer Value Register\n  CVAL [4 @offset 0x104 @inc 0x10]\n  CVAL0 @offset 0x104\n  CVAL1 @offset 0x114\n  CVAL2 @offset 0x124\n  CVAL3 @offset 0x134 @ro $u32 {\n    TVL:32 // at 0: Current Timer Value\n  }\n\n//---  Registers TCTRL(0,1,2,3): Timer Control Register\n  TCTRL [4 @offset 0x108 @inc 0x10]\n  TCTRL0 @offset 0x108\n  TCTRL1 @offset 0x118\n  TCTRL2 @offset 0x128\n  TCTRL3 @offset 0x138 $u32 {\n    29\n    CHN // at 2: Chain Mode\n    TIE // at 1: Timer Interrupt Enable\n    TEN // at 0: Timer Enable\n  }\n\n//---  Registers TFLG(0,1,2,3): Timer Flag Register\n  TFLG [4 @offset 0x10c @inc 0x10]\n  TFLG0 @offset 0x10c\n  TFLG1 @offset 0x11c\n  TFLG2 @offset 0x12c\n  TFLG3 @offset 0x13c $u32 {\n    31\n    TIF // at 0: Timer Interrupt Flag\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral PMC: Power Management Controller\n//------------------------------------------------------------------------------\n\nregisters PMC @at 0x4007d000 {\n//---  Register LVDSC1: Low Voltage Detect Status And Control 1 register\n  LVDSC1 @offset 0x0 $u8 {\n    LVDF // at 7: Low-Voltage Detect Flag\n    LVDACK // at 6: Low-Voltage Detect Acknowledge\n    LVDIE // at 5: Low-Voltage Detect Interrupt Enable\n    LVDRE // at 4: Low-Voltage Detect Reset Enable\n    2\n    LVDV:2 // at 0: Low-Voltage Detect Voltage Select\n  }\n\n//---  Register LVDSC2: Low Voltage Detect Status And Control 2 register\n  LVDSC2 @offset 0x1 $u8 {\n    LVWF // at 7: Low-Voltage Warning Flag\n    LVWACK // at 6: Low-Voltage Warning Acknowledge\n    LVWIE // at 5: Low-Voltage Warning Interrupt Enable\n    3\n    LVWV:2 // at 0: Low-Voltage Warning Voltage Select\n  }\n\n//---  Register REGSC: Regulator Status And Control register\n  REGSC @offset 0x2 $u8 {\n    3\n    BGEN // at 4: Bandgap Enable In VLPx Operation\n    ACKISO // at 3: Acknowledge Isolation\n    REGONS // at 2: Regulator In Run Regulation Status\n    1\n    BGBE // at 0: Bandgap Buffer Enable\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: PORT [5]\n//        PORTA at 0x40049000\n//        PORTB at 0x4004a000\n//        PORTC at 0x4004b000\n//        PORTD at 0x4004c000\n//        PORTE at 0x4004d000\n//------------------------------------------------------------------------------\n\nregisters PORT [5 @at 0x40049000 0x4004a000 0x4004b000 0x4004c000 0x4004d000]\n          PORTA @at 0x40049000\n          PORTB @at 0x4004a000\n          PORTC @at 0x4004b000\n          PORTD @at 0x4004c000\n          PORTE @at 0x4004d000 {\n//---  Registers PCR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Pin Control Register n\n  PCR [32 @offset 0x0 @inc 0x4]\n  PCR0 @offset 0x0\n  PCR1 @offset 0x4\n  PCR2 @offset 0x8\n  PCR3 @offset 0xc\n  PCR4 @offset 0x10\n  PCR5 @offset 0x14\n  PCR6 @offset 0x18\n  PCR7 @offset 0x1c\n  PCR8 @offset 0x20\n  PCR9 @offset 0x24\n  PCR10 @offset 0x28\n  PCR11 @offset 0x2c\n  PCR12 @offset 0x30\n  PCR13 @offset 0x34\n  PCR14 @offset 0x38\n  PCR15 @offset 0x3c\n  PCR16 @offset 0x40\n  PCR17 @offset 0x44\n  PCR18 @offset 0x48\n  PCR19 @offset 0x4c\n  PCR20 @offset 0x50\n  PCR21 @offset 0x54\n  PCR22 @offset 0x58\n  PCR23 @offset 0x5c\n  PCR24 @offset 0x60\n  PCR25 @offset 0x64\n  PCR26 @offset 0x68\n  PCR27 @offset 0x6c\n  PCR28 @offset 0x70\n  PCR29 @offset 0x74\n  PCR30 @offset 0x78\n  PCR31 @offset 0x7c $u32 {\n    7\n    ISF // at 24: Interrupt Status Flag\n    4\n    IRQC:4 // at 16: Interrupt Configuration\n    LK // at 15: Lock Register\n    4\n    MUX:3 // at 8: Pin Mux Control\n    1\n    DSE // at 6: Drive Strength Enable\n    ODE // at 5: Open Drain Enable\n    PFE // at 4: Passive Filter Enable\n    1\n    SRE // at 2: Slew Rate Enable\n    PE // at 1: Pull Enable\n    PS // at 0: Pull Select\n  }\n\n//---  Register GPCLR: Global Pin Control Low Register\n  GPCLR @offset 0x80 $u32 {\n    GPWE:16 // at 16: Global Pin Write Enable\n    GPWD:16 // at 0: Global Pin Write Data\n  }\n\n//---  Register GPCHR: Global Pin Control High Register\n  GPCHR @offset 0x84 $u32 {\n    GPWE:16 // at 16: Global Pin Write Enable\n    GPWD:16 // at 0: Global Pin Write Data\n  }\n\n//---  Register ISFR: Interrupt Status Flag Register\n  ISFR @offset 0xa0 $u32 {\n    ISF:32 // at 0: Interrupt Status Flag\n  }\n\n//---  Register DFER: Digital Filter Enable Register\n  DFER @offset 0xc0 $u32 {\n    DFE:32 // at 0: Digital Filter Enable\n  }\n\n//---  Register DFCR: Digital Filter Clock Register\n  DFCR @offset 0xc4 $u32 {\n    31\n    CS // at 0: Clock Source\n  }\n\n//---  Register DFWR: Digital Filter Width Register\n  DFWR @offset 0xc8 $u32 {\n    27\n    FILT:5 // at 0: Filter Length\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RCM: Reset Control Module\n//------------------------------------------------------------------------------\n\nregisters RCM @at 0x4007f000 {\n//---  Register SRS0: System Reset Status Register 0\n  SRS0 @offset 0x0 @ro $u8 {\n    POR // at 7: Power-On Reset\n    PIN // at 6: External Reset Pin\n    WDOG // at 5: Watchdog\n    1\n    LOL // at 3: Loss-of-Lock Reset\n    LOC // at 2: Loss-of-Clock Reset\n    LVD // at 1: Low-Voltage Detect Reset\n    WAKEUP // at 0: Low Leakage Wakeup Reset\n  }\n\n//---  Register SRS1: System Reset Status Register 1\n  SRS1 @offset 0x1 @ro $u8 {\n    2\n    SACKERR // at 5: Stop Mode Acknowledge Error Reset\n    EZPT // at 4: EzPort Reset\n    MDM_AP // at 3: MDM-AP System Reset Request\n    SW // at 2: Software\n    LOCKUP // at 1: Core Lockup\n    JTAG // at 0: JTAG Generated Reset\n  }\n\n//---  Register RPFC: Reset Pin Filter Control register\n  RPFC @offset 0x4 $u8 {\n    5\n    RSTFLTSS // at 2: Reset Pin Filter Select in Stop Mode\n    RSTFLTSRW:2 // at 0: Reset Pin Filter Select in Run and Wait Modes\n  }\n\n//---  Register RPFW: Reset Pin Filter Width register\n  RPFW @offset 0x5 $u8 {\n    3\n    RSTFLTSEL:5 // at 0: Reset Pin Filter Bus Clock Select\n  }\n\n//---  Register MR: Mode Register\n  MR @offset 0x7 @ro $u8 {\n    6\n    EZP_MS // at 1: EZP_MS_B pin state\n    1\n  }\n\n//---  Register SSRS0: Sticky System Reset Status Register 0\n  SSRS0 @offset 0x8 $u8 {\n    SPOR // at 7: Sticky Power-On Reset\n    SPIN // at 6: Sticky External Reset Pin\n    SWDOG // at 5: Sticky Watchdog\n    1\n    SLOL // at 3: Sticky Loss-of-Lock Reset\n    SLOC // at 2: Sticky Loss-of-Clock Reset\n    SLVD // at 1: Sticky Low-Voltage Detect Reset\n    SWAKEUP // at 0: Sticky Low Leakage Wakeup Reset\n  }\n\n//---  Register SSRS1: Sticky System Reset Status Register 1\n  SSRS1 @offset 0x9 $u8 {\n    2\n    SSACKERR // at 5: Sticky Stop Mode Acknowledge Error Reset\n    SEZPT // at 4: Sticky EzPort Reset\n    SMDM_AP // at 3: Sticky MDM-AP System Reset Request\n    SSW // at 2: Sticky Software\n    SLOCKUP // at 1: Sticky Core Lockup\n    SJTAG // at 0: Sticky JTAG Generated Reset\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RFSYS: System register file\n//------------------------------------------------------------------------------\n\nregisters RFSYS @at 0x40041000 {\n//---  Registers REG(0,1,2,3,4,5,6,7): Register file register\n  REG [8 @offset 0x0 @inc 0x4]\n  REG0 @offset 0x0\n  REG1 @offset 0x4\n  REG2 @offset 0x8\n  REG3 @offset 0xc\n  REG4 @offset 0x10\n  REG5 @offset 0x14\n  REG6 @offset 0x18\n  REG7 @offset 0x1c $u32 {\n    HH:8 // at 24: High higher byte\n    HL:8 // at 16: High lower byte\n    LH:8 // at 8: Low higher byte\n    LL:8 // at 0: Low lower byte\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RFVBAT: VBAT register file\n//------------------------------------------------------------------------------\n\nregisters RFVBAT @at 0x4003e000 {\n//---  Registers REG(0,1,2,3,4,5,6,7): VBAT register file register\n  REG [8 @offset 0x0 @inc 0x4]\n  REG0 @offset 0x0\n  REG1 @offset 0x4\n  REG2 @offset 0x8\n  REG3 @offset 0xc\n  REG4 @offset 0x10\n  REG5 @offset 0x14\n  REG6 @offset 0x18\n  REG7 @offset 0x1c $u32 {\n    HH:8 // at 24: High higher byte\n    HL:8 // at 16: High lower byte\n    LH:8 // at 8: Low higher byte\n    LL:8 // at 0: Low lower byte\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RNG: Random Number Generator Accelerator\n//------------------------------------------------------------------------------\n\nregisters RNG @at 0x400a0000 {\n//---  Register CR: RNGA Control Register\n  CR @offset 0x0 $u32 {\n    27\n    SLP // at 4: Sleep\n    CLRI // at 3: Clear Interrupt\n    INTM // at 2: Interrupt Mask\n    HA // at 1: High Assurance\n    GO // at 0: Go\n  }\n\n//---  Register SR: RNGA Status Register\n  SR @offset 0x4 @ro $u32 {\n    8\n    OREG_SIZE:8 // at 16: Output Register Size\n    OREG_LVL:8 // at 8: Output Register Level\n    3\n    SLP // at 4: Sleep\n    ERRI // at 3: Error Interrupt\n    ORU // at 2: Output Register Underflow\n    LRS // at 1: Last Read Status\n    SECV // at 0: Security Violation\n  }\n\n//---  Register ER: RNGA Entropy Register\n  ER @offset 0x8 $u32 {\n    EXT_ENT:32 // at 0: External Entropy\n  }\n\n//---  Register OR: RNGA Output Register\n  OR @offset 0xc @ro $u32 {\n    RANDOUT:32 // at 0: Random Output\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral RTC: Secure Real Time Clock\n//------------------------------------------------------------------------------\n\nregisters RTC @at 0x4003d000 {\n//---  Register TSR: RTC Time Seconds Register\n  TSR @offset 0x0 $u32 {\n    TSR:32 // at 0: Time Seconds Register\n  }\n\n//---  Register TPR: RTC Time Prescaler Register\n  TPR @offset 0x4 $u32 {\n    16\n    TPR:16 // at 0: Time Prescaler Register\n  }\n\n//---  Register TAR: RTC Time Alarm Register\n  TAR @offset 0x8 $u32 {\n    TAR:32 // at 0: Time Alarm Register\n  }\n\n//---  Register TCR: RTC Time Compensation Register\n  TCR @offset 0xc $u32 {\n    CIC:8 // at 24: Compensation Interval Counter\n    TCV:8 // at 16: Time Compensation Value\n    CIR:8 // at 8: Compensation Interval Register\n    TCR:8 // at 0: Time Compensation Register\n  }\n\n//---  Register CR: RTC Control Register\n  CR @offset 0x10 $u32 {\n    18\n    SC2P // at 13: Oscillator 2pF Load Configure\n    SC4P // at 12: Oscillator 4pF Load Configure\n    SC8P // at 11: Oscillator 8pF Load Configure\n    SC16P // at 10: Oscillator 16pF Load Configure\n    CLKO // at 9: Clock Output\n    OSCE // at 8: Oscillator Enable\n    3\n    WPS // at 4: Wakeup Pin Select\n    UM // at 3: Update Mode\n    SUP // at 2: Supervisor Access\n    WPE // at 1: Wakeup Pin Enable\n    SWR // at 0: Software Reset\n  }\n\n//---  Register SR: RTC Status Register\n  SR @offset 0x14 $u32 {\n    27\n    TCE // at 4: Time Counter Enable\n    MOF // at 3: Monotonic Overflow Flag\n    TAF // at 2: Time Alarm Flag\n    TOF // at 1: Time Overflow Flag\n    TIF // at 0: Time Invalid Flag\n  }\n\n//---  Register LR: RTC Lock Register\n  LR @offset 0x18 $u32 {\n    20\n    MCHL // at 11: Monotonic Counter High Lock\n    MCLL // at 10: Monotonic Counter Low Lock\n    MEL // at 9: Monotonic Enable Lock\n    TTSL // at 8: Tamper Time Seconds Lock\n    1\n    LRL // at 6: Lock Register Lock\n    SRL // at 5: Status Register Lock\n    CRL // at 4: Control Register Lock\n    TCL // at 3: Time Compensation Lock\n    3\n  }\n\n//---  Register IER: RTC Interrupt Enable Register\n  IER @offset 0x1c $u32 {\n    24\n    WPON // at 7: Wakeup Pin On\n    2\n    TSIE // at 4: Time Seconds Interrupt Enable\n    MOIE // at 3: Monotonic Overflow Interrupt Enable\n    TAIE // at 2: Time Alarm Interrupt Enable\n    TOIE // at 1: Time Overflow Interrupt Enable\n    TIIE // at 0: Time Invalid Interrupt Enable\n  }\n\n//---  Register TTSR: RTC Tamper Time Seconds Register\n  TTSR @offset 0x20 @ro $u32 {\n    TTS:32 // at 0: Tamper Time Seconds\n  }\n\n//---  Register MER: RTC Monotonic Enable Register\n  MER @offset 0x24 $u32 {\n    27\n    MCE // at 4: Monotonic Counter Enable\n    4\n  }\n\n//---  Register MCLR: RTC Monotonic Counter Low Register\n  MCLR @offset 0x28 $u32 {\n    MCL:32 // at 0: Monotonic Counter Low\n  }\n\n//---  Register MCHR: RTC Monotonic Counter High Register\n  MCHR @offset 0x2c $u32 {\n    MCH:32 // at 0: Monotonic Counter High\n  }\n\n//---  Register WAR: RTC Write Access Register\n  WAR @offset 0x800 $u32 {\n    20\n    MCHW // at 11: Monotonic Counter High Write\n    MCLW // at 10: Monotonic Counter Low Write\n    MERW // at 9: Monotonic Enable Register Write\n    TTSW // at 8: Tamper Time Seconds Write\n    IERW // at 7: Interrupt Enable Register Write\n    LRW // at 6: Lock Register Write\n    SRW // at 5: Status Register Write\n    CRW // at 4: Control Register Write\n    TCRW // at 3: Time Compensation Register Write\n    TARW // at 2: Time Alarm Register Write\n    TPRW // at 1: Time Prescaler Register Write\n    TSRW // at 0: Time Seconds Register Write\n  }\n\n//---  Register RAR: RTC Read Access Register\n  RAR @offset 0x804 $u32 {\n    20\n    MCHR // at 11: Monotonic Counter High Read\n    MCLR // at 10: Monotonic Counter Low Read\n    MERR // at 9: Monotonic Enable Register Read\n    TTSR // at 8: Tamper Time Seconds Read\n    IERR // at 7: Interrupt Enable Register Read\n    LRR // at 6: Lock Register Read\n    SRR // at 5: Status Register Read\n    CRR // at 4: Control Register Read\n    TCRR // at 3: Time Compensation Register Read\n    TARR // at 2: Time Alarm Register Read\n    TPRR // at 1: Time Prescaler Register Read\n    TSRR // at 0: Time Seconds Register Read\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SDHC: Secured Digital Host Controller\n//------------------------------------------------------------------------------\n\nregisters SDHC @at 0x400b1000 {\n//---  Register DSADDR: DMA System Address register\n  DSADDR @offset 0x0 $u32 {\n    DSADDR:30 // at 2: DMA System Address\n    2\n  }\n\n//---  Register BLKATTR: Block Attributes register\n  BLKATTR @offset 0x4 $u32 {\n    BLKCNT:16 // at 16: Blocks Count For Current Transfer\n    3\n    BLKSIZE:13 // at 0: Transfer Block Size\n  }\n\n//---  Register CMDARG: Command Argument register\n  CMDARG @offset 0x8 $u32 {\n    CMDARG:32 // at 0: Command Argument\n  }\n\n//---  Register XFERTYP: Transfer Type register\n  XFERTYP @offset 0xc $u32 {\n    2\n    CMDINX:6 // at 24: Command Index\n    CMDTYP:2 // at 22: Command Type\n    DPSEL // at 21: Data Present Select\n    CICEN // at 20: Command Index Check Enable\n    CCCEN // at 19: Command CRC Check Enable\n    1\n    RSPTYP:2 // at 16: Response Type Select\n    10\n    MSBSEL // at 5: Multi/Single Block Select\n    DTDSEL // at 4: Data Transfer Direction Select\n    1\n    AC12EN // at 2: Auto CMD12 Enable\n    BCEN // at 1: Block Count Enable\n    DMAEN // at 0: DMA Enable\n  }\n\n//---  Register CMDRSP0: Command Response 0\n  CMDRSP0 @offset 0x10 @ro $u32 {\n    CMDRSP0:32 // at 0: Command Response 0\n  }\n\n//---  Register CMDRSP1: Command Response 1\n  CMDRSP1 @offset 0x14 @ro $u32 {\n    CMDRSP1:32 // at 0: Command Response 1\n  }\n\n//---  Register CMDRSP2: Command Response 2\n  CMDRSP2 @offset 0x18 @ro $u32 {\n    CMDRSP2:32 // at 0: Command Response 2\n  }\n\n//---  Register CMDRSP3: Command Response 3\n  CMDRSP3 @offset 0x1c @ro $u32 {\n    CMDRSP3:32 // at 0: Command Response 3\n  }\n\n//---  Register DATPORT: Buffer Data Port register\n  DATPORT @offset 0x20 $u32 {\n    DATCONT:32 // at 0: Data Content\n  }\n\n//---  Register PRSSTAT: Present State register\n  PRSSTAT @offset 0x24 @ro $u32 {\n    DLSL:8 // at 24: DAT Line Signal Level\n    CLSL // at 23: CMD Line Signal Level\n    6\n    CINS // at 16: Card Inserted\n    4\n    BREN // at 11: Buffer Read Enable\n    BWEN // at 10: Buffer Write Enable\n    RTA // at 9: Read Transfer Active\n    WTA // at 8: Write Transfer Active\n    SDOFF // at 7: SD Clock Gated Off Internally\n    PEROFF // at 6: SDHC clock Gated Off Internally\n    HCKOFF // at 5: System Clock Gated Off Internally\n    IPGOFF // at 4: Bus Clock Gated Off Internally\n    SDSTB // at 3: SD Clock Stable\n    DLA // at 2: Data Line Active\n    CDIHB // at 1: Command Inhibit (DAT)\n    CIHB // at 0: Command Inhibit (CMD)\n  }\n\n//---  Register PROCTL: Protocol Control register\n  PROCTL @offset 0x28 $u32 {\n    5\n    WECRM // at 26: Wakeup Event Enable On SD Card Removal\n    WECINS // at 25: Wakeup Event Enable On SD Card Insertion\n    WECINT // at 24: Wakeup Event Enable On Card Interrupt\n    4\n    IABG // at 19: Interrupt At Block Gap\n    RWCTL // at 18: Read Wait Control\n    CREQ // at 17: Continue Request\n    SABGREQ // at 16: Stop At Block Gap Request\n    6\n    DMAS:2 // at 8: DMA Select\n    CDSS // at 7: Card Detect Signal Selection\n    CDTL // at 6: Card Detect Test Level\n    EMODE:2 // at 4: Endian Mode\n    D3CD // at 3: DAT3 As Card Detection Pin\n    DTW:2 // at 1: Data Transfer Width\n    LCTL // at 0: LED Control\n  }\n\n//---  Register SYSCTL: System Control register\n  SYSCTL @offset 0x2c $u32 {\n    4\n    INITA // at 27: Initialization Active\n    RSTD // at 26: Software Reset For DAT Line\n    RSTC // at 25: Software Reset For CMD Line\n    RSTA // at 24: Software Reset For ALL\n    4\n    DTOCV:4 // at 16: Data Timeout Counter Value\n    SDCLKFS:8 // at 8: SDCLK Frequency Select\n    DVS:4 // at 4: Divisor\n    SDCLKEN // at 3: SD Clock Enable\n    PEREN // at 2: Peripheral Clock Enable\n    HCKEN // at 1: System Clock Enable\n    IPGEN // at 0: IPG Clock Enable\n  }\n\n//---  Register IRQSTAT: Interrupt Status register\n  IRQSTAT @offset 0x30 $u32 {\n    3\n    DMAE // at 28: DMA Error\n    3\n    AC12E // at 24: Auto CMD12 Error\n    1\n    DEBE // at 22: Data End Bit Error\n    DCE // at 21: Data CRC Error\n    DTOE // at 20: Data Timeout Error\n    CIE // at 19: Command Index Error\n    CEBE // at 18: Command End Bit Error\n    CCE // at 17: Command CRC Error\n    CTOE // at 16: Command Timeout Error\n    7\n    CINT // at 8: Card Interrupt\n    CRM // at 7: Card Removal\n    CINS // at 6: Card Insertion\n    BRR // at 5: Buffer Read Ready\n    BWR // at 4: Buffer Write Ready\n    DINT // at 3: DMA Interrupt\n    BGE // at 2: Block Gap Event\n    TC // at 1: Transfer Complete\n    CC // at 0: Command Complete\n  }\n\n//---  Register IRQSTATEN: Interrupt Status Enable register\n  IRQSTATEN @offset 0x34 $u32 {\n    3\n    DMAESEN // at 28: DMA Error Status Enable\n    3\n    AC12ESEN // at 24: Auto CMD12 Error Status Enable\n    1\n    DEBESEN // at 22: Data End Bit Error Status Enable\n    DCESEN // at 21: Data CRC Error Status Enable\n    DTOESEN // at 20: Data Timeout Error Status Enable\n    CIESEN // at 19: Command Index Error Status Enable\n    CEBESEN // at 18: Command End Bit Error Status Enable\n    CCESEN // at 17: Command CRC Error Status Enable\n    CTOESEN // at 16: Command Timeout Error Status Enable\n    7\n    CINTSEN // at 8: Card Interrupt Status Enable\n    CRMSEN // at 7: Card Removal Status Enable\n    CINSEN // at 6: Card Insertion Status Enable\n    BRRSEN // at 5: Buffer Read Ready Status Enable\n    BWRSEN // at 4: Buffer Write Ready Status Enable\n    DINTSEN // at 3: DMA Interrupt Status Enable\n    BGESEN // at 2: Block Gap Event Status Enable\n    TCSEN // at 1: Transfer Complete Status Enable\n    CCSEN // at 0: Command Complete Status Enable\n  }\n\n//---  Register IRQSIGEN: Interrupt Signal Enable register\n  IRQSIGEN @offset 0x38 $u32 {\n    3\n    DMAEIEN // at 28: DMA Error Interrupt Enable\n    3\n    AC12EIEN // at 24: Auto CMD12 Error Interrupt Enable\n    1\n    DEBEIEN // at 22: Data End Bit Error Interrupt Enable\n    DCEIEN // at 21: Data CRC Error Interrupt Enable\n    DTOEIEN // at 20: Data Timeout Error Interrupt Enable\n    CIEIEN // at 19: Command Index Error Interrupt Enable\n    CEBEIEN // at 18: Command End Bit Error Interrupt Enable\n    CCEIEN // at 17: Command CRC Error Interrupt Enable\n    CTOEIEN // at 16: Command Timeout Error Interrupt Enable\n    7\n    CINTIEN // at 8: Card Interrupt Enable\n    CRMIEN // at 7: Card Removal Interrupt Enable\n    CINSIEN // at 6: Card Insertion Interrupt Enable\n    BRRIEN // at 5: Buffer Read Ready Interrupt Enable\n    BWRIEN // at 4: Buffer Write Ready Interrupt Enable\n    DINTIEN // at 3: DMA Interrupt Enable\n    BGEIEN // at 2: Block Gap Event Interrupt Enable\n    TCIEN // at 1: Transfer Complete Interrupt Enable\n    CCIEN // at 0: Command Complete Interrupt Enable\n  }\n\n//---  Register AC12ERR: Auto CMD12 Error Status Register\n  AC12ERR @offset 0x3c @ro $u32 {\n    24\n    CNIBAC12E // at 7: Command Not Issued By Auto CMD12 Error\n    2\n    AC12IE // at 4: Auto CMD12 Index Error\n    AC12CE // at 3: Auto CMD12 CRC Error\n    AC12EBE // at 2: Auto CMD12 End Bit Error\n    AC12TOE // at 1: Auto CMD12 Timeout Error\n    AC12NE // at 0: Auto CMD12 Not Executed\n  }\n\n//---  Register HTCAPBLT: Host Controller Capabilities\n  HTCAPBLT @offset 0x40 @ro $u32 {\n    7\n    VS33 // at 24: Voltage Support 3.3 V\n    SRS // at 23: Suspend/Resume Support\n    DMAS // at 22: DMA Support\n    HSS // at 21: High Speed Support\n    ADMAS // at 20: ADMA Support\n    1\n    MBL:3 // at 16: Max Block Length\n    16\n  }\n\n//---  Register WML: Watermark Level Register\n  WML @offset 0x44 $u32 {\n    8\n    WRWML:8 // at 16: Write Watermark Level\n    8\n    RDWML:8 // at 0: Read Watermark Level\n  }\n\n//---  Register FEVT: Force Event register\n  FEVT @offset 0x50 $u32 {\n    CINT // at 31: Force Event Card Interrupt\n    2\n    DMAE // at 28: Force Event DMA Error\n    3\n    AC12E // at 24: Force Event Auto Command 12 Error\n    1\n    DEBE // at 22: Force Event Data End Bit Error\n    DCE // at 21: Force Event Data CRC Error\n    DTOE // at 20: Force Event Data Time Out Error\n    CIE // at 19: Force Event Command Index Error\n    CEBE // at 18: Force Event Command End Bit Error\n    CCE // at 17: Force Event Command CRC Error\n    CTOE // at 16: Force Event Command Time Out Error\n    8\n    CNIBAC12E // at 7: Force Event Command Not Executed By Auto Command 12 Error\n    2\n    AC12IE // at 4: Force Event Auto Command 12 Index Error\n    AC12EBE // at 3: Force Event Auto Command 12 End Bit Error\n    AC12CE // at 2: Force Event Auto Command 12 CRC Error\n    AC12TOE // at 1: Force Event Auto Command 12 Time Out Error\n    AC12NE // at 0: Force Event Auto Command 12 Not Executed\n  }\n\n//---  Register ADMAES: ADMA Error Status register\n  ADMAES @offset 0x54 @ro $u32 {\n    28\n    ADMADCE // at 3: ADMA Descriptor Error\n    ADMALME // at 2: ADMA Length Mismatch Error\n    ADMAES:2 // at 0: ADMA Error State (When ADMA Error Is Occurred.)\n  }\n\n//---  Register ADSADDR: ADMA System Addressregister\n  ADSADDR @offset 0x58 $u32 {\n    ADSADDR:30 // at 2: ADMA System Address\n    2\n  }\n\n//---  Register VENDOR: Vendor Specific register\n  VENDOR @offset 0xc0 $u32 {\n    8\n    INTSTVAL:8 // at 16: Internal State Value\n    14\n    EXBLKNU // at 1: Exact Block Number Block Read Enable For SDIO CMD53\n    1\n  }\n\n//---  Register MMCBOOT: MMC Boot register\n  MMCBOOT @offset 0xc4 $u32 {\n    BOOTBLKCNT:16 // at 16: Defines the stop at block gap value of automatic mode\n    8\n    AUTOSABGEN // at 7: When boot, enable auto stop at block gap function\n    BOOTEN // at 6: Boot Mode Enable\n    BOOTMODE // at 5: Boot Mode Select\n    BOOTACK // at 4: Boot Ack Mode Select\n    DTOCVACK:4 // at 0: Boot ACK Time Out Counter Value\n  }\n\n//---  Register HOSTVER: Host Controller Version\n  HOSTVER @offset 0xfc @ro $u32 {\n    16\n    VVN:8 // at 8: Vendor Version Number\n    SVN:8 // at 0: Specification Version Number\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SDRAM: Synchronous DRAM Controller\n//------------------------------------------------------------------------------\n\nregisters SDRAM @at 0x4000f000 {\n//---  Register CTRL: Control Register\n  CTRL @offset 0x42 $u16 {\n    4\n    IS // at 11: Initiate self-refresh command.\n    RTIM:2 // at 9: Refresh timing\n    RC:9 // at 0: Refresh count\n  }\n\n//---  Registers AC(0,1): Address and Control Register\n  AC [2 @offset 0x48 @inc 0x8]\n  AC0 @offset 0x48\n  AC1 @offset 0x50 $u32 {\n    BA:14 // at 18: Base address register.\n    2\n    RE // at 15: Refresh enable\n    1\n    CASL:2 // at 12: CAS Latency\n    1\n    CBM:3 // at 8: Command bit location\n    1\n    IMRS // at 6: Initiate mode register set (mrs) command.\n    PS:2 // at 4: Port size.\n    IP // at 3: Initiate precharge all (pall) command.\n    3\n  }\n\n//---  Registers CM(0,1): Control Mask\n  CM [2 @offset 0x4c @inc 0x8]\n  CM0 @offset 0x4c\n  CM1 @offset 0x54 $u32 {\n    BAM:14 // at 18: Base address mask.\n    9\n    WP // at 8: Write protect.\n    7\n    V // at 0: Valid.\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SIM: System Integration Module\n//------------------------------------------------------------------------------\n\nregisters SIM @at 0x40047000 {\n//---  Register SOPT1: System Options Register 1\n  SOPT1 @offset 0x0 $u32 {\n    USBREGEN // at 31: USB voltage regulator enable\n    USBSSTBY // at 30: USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.\n    USBVSTBY // at 29: USB voltage regulator in standby mode during VLPR and VLPW modes\n    9\n    OSC32KSEL:2 // at 18: 32K oscillator clock select\n    2\n    RAMSIZE:4 // at 12: RAM size\n    12\n  }\n\n//---  Register SOPT1CFG: SOPT1 Configuration Register\n  SOPT1CFG @offset 0x4 $u32 {\n    5\n    USSWE // at 26: USB voltage regulator stop standby write enable\n    UVSWE // at 25: USB voltage regulator VLP standby write enable\n    URWE // at 24: USB voltage regulator enable write enable\n    24\n  }\n\n//---  Register USBPHYCTL: USB PHY Control Register\n  USBPHYCTL @offset 0x8 $u32 {\n    8\n    USBDISILIM // at 23: USB Disable Inrush Current Limit\n    USB3VOUTTRG:3 // at 20: USB 3.3V Output Target\n    10\n    USBVREGPD // at 9: Enables the pulldown on the output of the USB Regulator.\n    USBVREGSEL // at 8: Selects the default input voltage source to the USB Regulator in case both VREG_IN0 and VREG_IN1 are powered\n    8\n  }\n\n//---  Register SOPT2: System Options Register 2\n  SOPT2 @offset 0x1004 $u32 {\n    2\n    SDHCSRC:2 // at 28: SDHC clock source select\n    LPUARTSRC:2 // at 26: LPUART clock source select\n    TPMSRC:2 // at 24: TPM clock source select\n    2\n    TIMESRC:2 // at 20: IEEE 1588 timestamp clock source select\n    RMIISRC // at 19: RMII clock source select\n    USBSRC // at 18: USB clock source select\n    PLLFLLSEL:2 // at 16: PLL/FLL clock select\n    3\n    TRACECLKSEL // at 12: Debug trace clock select\n    2\n    FBSL:2 // at 8: FlexBus security level\n    CLKOUTSEL:3 // at 5: CLKOUT select\n    RTCCLKOUTSEL // at 4: RTC clock out select\n    2\n    USBREGEN // at 1: USB PHY PLL Regulator Enable\n    USBSLSRC // at 0: USB Slow Clock Source\n  }\n\n//---  Register SOPT4: System Options Register 4\n  SOPT4 @offset 0x100c $u32 {\n    FTM3TRG1SRC // at 31: FlexTimer 3 Hardware Trigger 1 Source Select\n    FTM3TRG0SRC // at 30: FlexTimer 3 Hardware Trigger 0 Source Select\n    FTM0TRG1SRC // at 29: FlexTimer 0 Hardware Trigger 1 Source Select\n    FTM0TRG0SRC // at 28: FlexTimer 0 Hardware Trigger 0 Source Select\n    FTM3CLKSEL // at 27: FlexTimer 3 External Clock Pin Select\n    FTM2CLKSEL // at 26: FlexTimer 2 External Clock Pin Select\n    FTM1CLKSEL // at 25: FTM1 External Clock Pin Select\n    FTM0CLKSEL // at 24: FlexTimer 0 External Clock Pin Select\n    1\n    FTM2CH1SRC // at 22: FTM2 channel 1 input capture source select\n    FTM2CH0SRC:2 // at 20: FTM2 channel 0 input capture source select\n    FTM1CH0SRC:2 // at 18: FTM1 channel 0 input capture source select\n    5\n    FTM3FLT0 // at 12: FTM3 Fault 0 Select\n    3\n    FTM2FLT0 // at 8: FTM2 Fault 0 Select\n    3\n    FTM1FLT0 // at 4: FTM1 Fault 0 Select\n    FTM0FLT3 // at 3: FTM0 Fault 3 Select\n    FTM0FLT2 // at 2: FTM0 Fault 2 Select\n    FTM0FLT1 // at 1: FTM0 Fault 1 Select\n    FTM0FLT0 // at 0: FTM0 Fault 0 Select\n  }\n\n//---  Register SOPT5: System Options Register 5\n  SOPT5 @offset 0x1010 $u32 {\n    12\n    LPUART0RXSRC:2 // at 18: LPUART0 receive data source select\n    LPUART0TXSRC:2 // at 16: LPUART0 transmit data source select\n    8\n    UART1RXSRC:2 // at 6: UART 1 receive data source select\n    UART1TXSRC:2 // at 4: UART 1 transmit data source select\n    UART0RXSRC:2 // at 2: UART 0 receive data source select\n    UART0TXSRC:2 // at 0: UART 0 transmit data source select\n  }\n\n//---  Register SOPT7: System Options Register 7\n  SOPT7 @offset 0x1018 $u32 {\n    16\n    ADC1ALTTRGEN // at 15: ADC1 alternate trigger enable\n    2\n    ADC1PRETRGSEL // at 12: ADC1 pre-trigger select\n    ADC1TRGSEL:4 // at 8: ADC1 trigger select\n    ADC0ALTTRGEN // at 7: ADC0 alternate trigger enable\n    2\n    ADC0PRETRGSEL // at 4: ADC0 pretrigger select\n    ADC0TRGSEL:4 // at 0: ADC0 trigger select\n  }\n\n//---  Register SOPT8: System Options Register 8\n  SOPT8 @offset 0x101c $u32 {\n    FTM3OCH7SRC // at 31: FTM3 channel 7 output source\n    FTM3OCH6SRC // at 30: FTM3 channel 6 output source\n    FTM3OCH5SRC // at 29: FTM3 channel 5 output source\n    FTM3OCH4SRC // at 28: FTM3 channel 4 output source\n    FTM3OCH3SRC // at 27: FTM3 channel 3 output source\n    FTM3OCH2SRC // at 26: FTM3 channel 2 output source\n    FTM3OCH1SRC // at 25: FTM3 channel 1 output source\n    FTM3OCH0SRC // at 24: FTM3 channel 0 output source\n    FTM0OCH7SRC // at 23: FTM0 channel 7 output source\n    FTM0OCH6SRC // at 22: FTM0 channel 6 output source\n    FTM0OCH5SRC // at 21: FTM0 channel 5 output source\n    FTM0OCH4SRC // at 20: FTM0 channel 4 output source\n    FTM0OCH3SRC // at 19: FTM0 channel 3 output source\n    FTM0OCH2SRC // at 18: FTM0 channel 2 output source\n    FTM0OCH1SRC // at 17: FTM0 channel 1 output source\n    FTM0OCH0SRC // at 16: FTM0 channel 0 output source\n    12\n    FTM3SYNCBIT // at 3: FTM3 Hardware Trigger 0 Software Synchronization\n    FTM2SYNCBIT // at 2: FTM2 Hardware Trigger 0 Software Synchronization\n    FTM1SYNCBIT // at 1: FTM1 Hardware Trigger 0 Software Synchronization\n    FTM0SYNCBIT // at 0: FTM0 Hardware Trigger 0 Software Synchronization\n  }\n\n//---  Register SOPT9: System Options Register 9\n  SOPT9 @offset 0x1020 $u32 {\n    5\n    TPM2CLKSEL // at 26: TPM2 External Clock Pin Select\n    TPM1CLKSEL // at 25: TPM1 External Clock Pin Select\n    3\n    TPM2CH0SRC:2 // at 20: TPM2 channel 0 input capture source select\n    TPM1CH0SRC:2 // at 18: TPM1 channel 0 input capture source select\n    18\n  }\n\n//---  Register SDID: System Device Identification Register\n  SDID @offset 0x1024 @ro $u32 {\n    FAMILYID:4 // at 28: Kinetis Family ID\n    SUBFAMID:4 // at 24: Kinetis Sub-Family ID\n    SERIESID:4 // at 20: Kinetis Series ID\n    4\n    REVID:4 // at 12: Device revision number\n    DIEID:5 // at 7: Device Die ID\n    FAMID:3 // at 4: Kinetis family identification\n    PINID:4 // at 0: Pincount identification\n  }\n\n//---  Register SCGC1: System Clock Gating Control Register 1\n  SCGC1 @offset 0x1028 $u32 {\n    21\n    UART4 // at 10: UART4 Clock Gate Control\n    2\n    I2C3 // at 7: I2C3 Clock Gate Control\n    I2C2 // at 6: I2C2 Clock Gate Control\n    6\n  }\n\n//---  Register SCGC2: System Clock Gating Control Register 2\n  SCGC2 @offset 0x102c $u32 {\n    18\n    DAC1 // at 13: DAC1 Clock Gate Control\n    DAC0 // at 12: DAC0 Clock Gate Control\n    1\n    TPM2 // at 10: TPM2 Clock Gate Control\n    TPM1 // at 9: TPM1 Clock Gate Control\n    4\n    LPUART0 // at 4: LPUART0 Clock Gate Control\n    3\n    ENET // at 0: ENET Clock Gate Control\n  }\n\n//---  Register SCGC3: System Clock Gating Control Register 3\n  SCGC3 @offset 0x1030 $u32 {\n    4\n    ADC1 // at 27: ADC1 Clock Gate Control\n    1\n    FTM3 // at 25: FTM3 Clock Gate Control\n    FTM2 // at 24: FTM2 Clock Gate Control\n    6\n    SDHC // at 17: SDHC Clock Gate Control\n    4\n    SPI2 // at 12: SPI2 Clock Gate Control\n    7\n    FLEXCAN1 // at 4: FlexCAN1 Clock Gate Control\n    USBHSDCD // at 3: USBHS DCD Clock Gate Control\n    USBHSPHY // at 2: USBHS PHY Clock Gate Control\n    USBHS // at 1: USBHS Clock Gate Control\n    RNGA // at 0: RNGA Clock Gate Control\n  }\n\n//---  Register SCGC4: System Clock Gating Control Register 4\n  SCGC4 @offset 0x1034 $u32 {\n    11\n    VREF // at 20: VREF Clock Gate Control\n    CMP // at 19: Comparator Clock Gate Control\n    USBOTG // at 18: USB Clock Gate Control\n    4\n    UART3 // at 13: UART3 Clock Gate Control\n    UART2 // at 12: UART2 Clock Gate Control\n    UART1 // at 11: UART1 Clock Gate Control\n    UART0 // at 10: UART0 Clock Gate Control\n    2\n    I2C1 // at 7: I2C1 Clock Gate Control\n    I2C0 // at 6: I2C0 Clock Gate Control\n    3\n    CMT // at 2: CMT Clock Gate Control\n    EWM // at 1: EWM Clock Gate Control\n    1\n  }\n\n//---  Register SCGC5: System Clock Gating Control Register 5\n  SCGC5 @offset 0x1038 $u32 {\n    18\n    PORTE // at 13: Port E Clock Gate Control\n    PORTD // at 12: Port D Clock Gate Control\n    PORTC // at 11: Port C Clock Gate Control\n    PORTB // at 10: Port B Clock Gate Control\n    PORTA // at 9: Port A Clock Gate Control\n    3\n    TSI // at 5: TSI Clock Gate Control\n    4\n    LPTMR // at 0: Low Power Timer Access Control\n  }\n\n//---  Register SCGC6: System Clock Gating Control Register 6\n  SCGC6 @offset 0x103c $u32 {\n    DAC0 // at 31: DAC0 Clock Gate Control\n    1\n    RTC // at 29: RTC Access Control\n    1\n    ADC0 // at 27: ADC0 Clock Gate Control\n    FTM2 // at 26: FTM2 Clock Gate Control\n    FTM1 // at 25: FTM1 Clock Gate Control\n    FTM0 // at 24: FTM0 Clock Gate Control\n    PIT // at 23: PIT Clock Gate Control\n    PDB // at 22: PDB Clock Gate Control\n    USBDCD // at 21: USB DCD Clock Gate Control\n    2\n    CRC // at 18: CRC Clock Gate Control\n    2\n    I2S // at 15: I2S Clock Gate Control\n    1\n    SPI1 // at 13: SPI1 Clock Gate Control\n    SPI0 // at 12: SPI0 Clock Gate Control\n    2\n    RNGA // at 9: RNGA Clock Gate Control\n    4\n    FLEXCAN0 // at 4: FlexCAN0 Clock Gate Control\n    2\n    DMAMUX // at 1: DMA Mux Clock Gate Control\n    FTF // at 0: Flash Memory Clock Gate Control\n  }\n\n//---  Register SCGC7: System Clock Gating Control Register 7\n  SCGC7 @offset 0x1040 $u32 {\n    28\n    SDRAMC // at 3: SDRAMC Clock Gate Control\n    MPU // at 2: MPU Clock Gate Control\n    DMA // at 1: DMA Clock Gate Control\n    FLEXBUS // at 0: FlexBus Clock Gate Control\n  }\n\n//---  Register CLKDIV1: System Clock Divider Register 1\n  CLKDIV1 @offset 0x1044 $u32 {\n    OUTDIV1:4 // at 28: Clock 1 output divider value\n    OUTDIV2:4 // at 24: Clock 2 output divider value\n    OUTDIV3:4 // at 20: Clock 3 output divider value\n    OUTDIV4:4 // at 16: Clock 4 output divider value\n    16\n  }\n\n//---  Register CLKDIV2: System Clock Divider Register 2\n  CLKDIV2 @offset 0x1048 $u32 {\n    28\n    USBDIV:3 // at 1: USB clock divider divisor\n    USBFRAC // at 0: USB clock divider fraction\n  }\n\n//---  Register FCFG1: Flash Configuration Register 1\n  FCFG1 @offset 0x104c $u32 {\n    NVMSIZE:4 // at 28: FlexNVM size\n    PFSIZE:4 // at 24: Program flash size\n    4\n    EESIZE:4 // at 16: EEPROM size\n    4\n    DEPART:4 // at 8: FlexNVM partition\n    6\n    FLASHDOZE // at 1: Flash Doze\n    FLASHDIS // at 0: Flash Disable\n  }\n\n//---  Register FCFG2: Flash Configuration Register 2\n  FCFG2 @offset 0x1050 @ro $u32 {\n    SWAPPFLSH // at 31: Swap program flash\n    MAXADDR0:7 // at 24: Max address block 0\n    PFLSH // at 23: Program flash only\n    MAXADDR1:7 // at 16: Max address block 1\n    16\n  }\n\n//---  Register UIDH: Unique Identification Register High\n  UIDH @offset 0x1054 @ro $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register UIDMH: Unique Identification Register Mid-High\n  UIDMH @offset 0x1058 @ro $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register UIDML: Unique Identification Register Mid Low\n  UIDML @offset 0x105c @ro $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register UIDL: Unique Identification Register Low\n  UIDL @offset 0x1060 @ro $u32 {\n    UID:32 // at 0: Unique Identification\n  }\n\n//---  Register CLKDIV3: System Clock Divider Register 3\n  CLKDIV3 @offset 0x1064 $u32 {\n    28\n    PLLFLLDIV:3 // at 1: PLLFLL clock divider divisor\n    PLLFLLFRAC // at 0: PLLFLL clock divider fraction\n  }\n\n//---  Register CLKDIV4: System Clock Divider Register 4\n  CLKDIV4 @offset 0x1068 $u32 {\n    28\n    TRACEDIV:3 // at 1: Trace clock divider divisor\n    TRACEFRAC // at 0: Trace clock divider fraction\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral SMC: System Mode Controller\n//------------------------------------------------------------------------------\n\nregisters SMC @at 0x4007e000 {\n//---  Register PMPROT: Power Mode Protection register\n  PMPROT @offset 0x0 $u8 {\n    AHSRUN // at 7: Allow High Speed Run mode\n    1\n    AVLP // at 5: Allow Very-Low-Power Modes\n    1\n    ALLS // at 3: Allow Low-Leakage Stop Mode\n    1\n    AVLLS // at 1: Allow Very-Low-Leakage Stop Mode\n    1\n  }\n\n//---  Register PMCTRL: Power Mode Control register\n  PMCTRL @offset 0x1 $u8 {\n    1\n    RUNM:2 // at 5: Run Mode Control\n    1\n    STOPA // at 3: Stop Aborted\n    STOPM:3 // at 0: Stop Mode Control\n  }\n\n//---  Register STOPCTRL: Stop Control Register\n  STOPCTRL @offset 0x2 $u8 {\n    PSTOPO:2 // at 6: Partial Stop Option\n    PORPO // at 5: POR Power Option\n    RAM2PO // at 4: RAM2 Power Option\n    1\n    LLSM:3 // at 0: LLS or VLLS Mode Control\n  }\n\n//---  Register PMSTAT: Power Mode Status register\n  PMSTAT @offset 0x3 @ro $u8 {\n    PMSTAT:8 // at 0: Power Mode Status\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: SPI [3]\n//        SPI0 at 0x4002c000\n//        SPI1 at 0x4002d000\n//        SPI2 at 0x400ac000\n//------------------------------------------------------------------------------\n\nregisters SPI [3 @at 0x4002c000 0x4002d000 0x400ac000]\n          SPI0 @at 0x4002c000\n          SPI1 @at 0x4002d000\n          SPI2 @at 0x400ac000 {\n//---  Register MCR: Module Configuration Register\n  MCR @offset 0x0 $u32 {\n    MSTR // at 31: Master/Slave Mode Select\n    CONT_SCKE // at 30: Continuous SCK Enable\n    DCONF:2 // at 28: SPI Configuration.\n    FRZ // at 27: Freeze\n    MTFE // at 26: Modified Transfer Format Enable\n    PCSSE // at 25: Peripheral Chip Select Strobe Enable\n    ROOE // at 24: Receive FIFO Overflow Overwrite Enable\n    2\n    PCSIS:6 // at 16: Peripheral Chip Select x Inactive State\n    DOZE // at 15: Doze Enable\n    MDIS // at 14: Module Disable\n    DIS_TXF // at 13: Disable Transmit FIFO\n    DIS_RXF // at 12: Disable Receive FIFO\n    CLR_TXF // at 11: Clear TX FIFO\n    CLR_RXF // at 10: CLR_RXF\n    SMPL_PT:2 // at 8: Sample Point\n    7\n    HALT // at 0: Halt\n  }\n\n//---  Register TCR: Transfer Count Register\n  TCR @offset 0x8 $u32 {\n    SPI_TCNT:16 // at 16: SPI Transfer Counter\n    16\n  }\n\n//---  Registers CTAR(0,1): Clock and Transfer Attributes Register (In Master Mode)\n  CTAR [2 @offset 0xc @inc 0x4]\n  CTAR0 @offset 0xc\n  CTAR1 @offset 0x10 $u32 {\n    DBR // at 31: Double Baud Rate\n    FMSZ:4 // at 27: Frame Size\n    CPOL // at 26: Clock Polarity\n    CPHA // at 25: Clock Phase\n    LSBFE // at 24: LSB First\n    PCSSCK:2 // at 22: PCS to SCK Delay Prescaler\n    PASC:2 // at 20: After SCK Delay Prescaler\n    PDT:2 // at 18: Delay after Transfer Prescaler\n    PBR:2 // at 16: Baud Rate Prescaler\n    CSSCK:4 // at 12: PCS to SCK Delay Scaler\n    ASC:4 // at 8: After SCK Delay Scaler\n    DT:4 // at 4: Delay After Transfer Scaler\n    BR:4 // at 0: Baud Rate Scaler\n  }\n\n//---  Register CTAR_SLAVE: Clock and Transfer Attributes Register (In Slave Mode)\n  CTAR_SLAVE @offset 0xc $u32 {\n    1\n    FMSZ:4 // at 27: Frame Size\n    CPOL // at 26: Clock Polarity\n    CPHA // at 25: Clock Phase\n    25\n  }\n\n//---  Register SR: Status Register\n  SR @offset 0x2c $u32 {\n    TCF // at 31: Transfer Complete Flag\n    TXRXS // at 30: TX and RX Status\n    1\n    EOQF // at 28: End of Queue Flag\n    TFUF // at 27: Transmit FIFO Underflow Flag\n    1\n    TFFF // at 25: Transmit FIFO Fill Flag\n    5\n    RFOF // at 19: Receive FIFO Overflow Flag\n    1\n    RFDF // at 17: Receive FIFO Drain Flag\n    1\n    TXCTR:4 // at 12: TX FIFO Counter\n    TXNXTPTR:4 // at 8: Transmit Next Pointer\n    RXCTR:4 // at 4: RX FIFO Counter\n    POPNXTPTR:4 // at 0: Pop Next Pointer\n  }\n\n//---  Register RSER: DMA/Interrupt Request Select and Enable Register\n  RSER @offset 0x30 $u32 {\n    TCF_RE // at 31: Transmission Complete Request Enable\n    2\n    EOQF_RE // at 28: Finished Request Enable\n    TFUF_RE // at 27: Transmit FIFO Underflow Request Enable\n    1\n    TFFF_RE // at 25: Transmit FIFO Fill Request Enable\n    TFFF_DIRS // at 24: Transmit FIFO Fill DMA or Interrupt Request Select\n    4\n    RFOF_RE // at 19: Receive FIFO Overflow Request Enable\n    1\n    RFDF_RE // at 17: Receive FIFO Drain Request Enable\n    RFDF_DIRS // at 16: Receive FIFO Drain DMA or Interrupt Request Select\n    16\n  }\n\n//---  Register PUSHR: PUSH TX FIFO Register In Master Mode\n  PUSHR @offset 0x34 $u32 {\n    CONT // at 31: Continuous Peripheral Chip Select Enable\n    CTAS:3 // at 28: Clock and Transfer Attributes Select\n    EOQ // at 27: End Of Queue\n    CTCNT // at 26: Clear Transfer Counter\n    4\n    PCS:6 // at 16: Select which PCS signals are to be asserted for the transfer\n    TXDATA:16 // at 0: Transmit Data\n  }\n\n//---  Register PUSHR_SLAVE: PUSH TX FIFO Register In Slave Mode\n  PUSHR_SLAVE @offset 0x34 $u32 {\n    TXDATA:32 // at 0: Transmit Data\n  }\n\n//---  Register POPR: POP RX FIFO Register\n  POPR @offset 0x38 @ro $u32 {\n    RXDATA:32 // at 0: Received Data\n  }\n\n//---  Registers TXFR(0,1,2,3): Transmit FIFO Registers\n  TXFR [4 @offset 0x3c @inc 0x4]\n  TXFR0 @offset 0x3c @ro\n  TXFR1 @offset 0x40 @ro\n  TXFR2 @offset 0x44 @ro\n  TXFR3 @offset 0x48 @ro $u32 {\n    TXCMD_TXDATA:16 // at 16: Transmit Command or Transmit Data\n    TXDATA:16 // at 0: Transmit Data\n  }\n\n//---  Registers RXFR(0,1,2,3): Receive FIFO Registers\n  RXFR [4 @offset 0x7c @inc 0x4]\n  RXFR0 @offset 0x7c @ro\n  RXFR1 @offset 0x80 @ro\n  RXFR2 @offset 0x84 @ro\n  RXFR3 @offset 0x88 @ro $u32 {\n    RXDATA:32 // at 0: Receive Data\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: TPM [2]\n//        TPM1 at 0x400c9000\n//        TPM2 at 0x400ca000\n//------------------------------------------------------------------------------\n\nregisters TPM [2 @at 0x400c9000 0x400ca000]\n          TPM1 @at 0x400c9000\n          TPM2 @at 0x400ca000 {\n//---  Register SC: Status and Control\n  SC @offset 0x0 $u32 {\n    23\n    DMA // at 8: DMA Enable\n    TOF // at 7: Timer Overflow Flag\n    TOIE // at 6: Timer Overflow Interrupt Enable\n    CPWMS // at 5: Center-Aligned PWM Select\n    CMOD:2 // at 3: Clock Mode Selection\n    PS:3 // at 0: Prescale Factor Selection\n  }\n\n//---  Register CNT: Counter\n  CNT @offset 0x4 $u32 {\n    16\n    COUNT:16 // at 0: Counter value\n  }\n\n//---  Register MOD: Modulo\n  MOD @offset 0x8 $u32 {\n    16\n    MOD:16 // at 0: Modulo value\n  }\n\n//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status and Control\n  CSC [8 @offset 0xc @inc 0x8]\n  C0SC @offset 0xc\n  C1SC @offset 0x14\n  C2SC @offset 0x1c\n  C3SC @offset 0x24\n  C4SC @offset 0x2c\n  C5SC @offset 0x34\n  C6SC @offset 0x3c\n  C7SC @offset 0x44 $u32 {\n    24\n    CHF // at 7: Channel Flag\n    CHIE // at 6: Channel Interrupt Enable\n    MSB // at 5: Channel Mode Select\n    MSA // at 4: Channel Mode Select\n    ELSB // at 3: Edge or Level Select\n    ELSA // at 2: Edge or Level Select\n    1\n    DMA // at 0: DMA Enable\n  }\n\n//---  Registers CV(0,1): Channel (n) Value\n  CV [2 @offset 0x10 @inc 0x8]\n  C0V @offset 0x10\n  C1V @offset 0x18 $u32 {\n    16\n    VAL:16 // at 0: Channel Value\n  }\n\n//---  Register STATUS: Capture and Compare Status\n  STATUS @offset 0x50 $u32 {\n    23\n    TOF // at 8: Timer Overflow Flag\n    6\n    CH1F // at 1: Channel 1 Flag\n    CH0F // at 0: Channel 0 Flag\n  }\n\n//---  Register COMBINE: Combine Channel Register\n  COMBINE @offset 0x64 $u32 {\n    30\n    COMSWAP0 // at 1: Combine Channel 0 and 1 Swap\n    COMBINE0 // at 0: Combine Channels 0 and 1\n  }\n\n//---  Register POL: Channel Polarity\n  POL @offset 0x70 $u32 {\n    30\n    POL1 // at 1: Channel 1 Polarity\n    POL0 // at 0: Channel 0 Polarity\n  }\n\n//---  Register FILTER: Filter Control\n  FILTER @offset 0x78 $u32 {\n    24\n    CH1FVAL:4 // at 4: Channel 1 Filter Value\n    CH0FVAL:4 // at 0: Channel 0 Filter Value\n  }\n\n//---  Register QDCTRL: Quadrature Decoder Control and Status\n  QDCTRL @offset 0x80 $u32 {\n    28\n    QUADMODE // at 3: Quadrature Decoder Mode\n    QUADIR // at 2: Counter Direction in Quadrature Decode Mode\n    TOFDIR // at 1: Indicates if the TOF bit was set on the top or the bottom of counting.\n    QUADEN // at 0: Enables the quadrature decoder mode\n  }\n\n//---  Register CONF: Configuration\n  CONF @offset 0x84 $u32 {\n    4\n    TRGSEL:4 // at 24: Trigger Select\n    TRGSRC // at 23: Trigger Source\n    TRGPOL // at 22: Trigger Polarity\n    2\n    CPOT // at 19: Counter Pause On Trigger\n    CROT // at 18: Counter Reload On Trigger\n    CSOO // at 17: Counter Stop On Overflow\n    CSOT // at 16: Counter Start on Trigger\n    6\n    GTBEEN // at 9: Global time base enable\n    GTBSYNC // at 8: Global Time Base Synchronization\n    DBGMODE:2 // at 6: Debug Mode\n    DOZEEN // at 5: Doze Enable\n    5\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral TSI0: Touch sense input\n//------------------------------------------------------------------------------\n\nregisters TSI0 @at 0x40045000 {\n//---  Register GENCS: TSI General Control and Status Register\n  GENCS @offset 0x0 $u32 {\n    OUTRGF // at 31: Out of Range Flag.\n    2\n    ESOR // at 28: End-of-scan or Out-of-Range Interrupt Selection\n    MODE:4 // at 24: TSI analog modes setup and status bits.\n    REFCHRG:3 // at 21: REFCHRG\n    DVOLT:2 // at 19: DVOLT\n    EXTCHRG:3 // at 16: EXTCHRG\n    PS:3 // at 13: PS\n    NSCN:5 // at 8: NSCN\n    TSIEN // at 7: Touch Sensing Input Module Enable\n    TSIIEN // at 6: Touch Sensing Input Interrupt Enable\n    STPE // at 5: TSI STOP Enable\n    STM // at 4: Scan Trigger Mode\n    SCNIP // at 3: Scan In Progress Status\n    EOSF // at 2: End of Scan Flag\n    CURSW // at 1: CURSW\n    EOSDMEO // at 0: End-of-Scan DMA Transfer Request Enable Only\n  }\n\n//---  Register DATA: TSI DATA Register\n  DATA @offset 0x4 $u32 {\n    TSICH:4 // at 28: TSICH\n    4\n    DMAEN // at 23: DMA Transfer Enabled\n    SWTS // at 22: Software Trigger Start\n    6\n    TSICNT:16 // at 0: TSI Conversion Counter Value\n  }\n\n//---  Register TSHD: TSI Threshold Register\n  TSHD @offset 0x8 $u32 {\n    THRESH:16 // at 16: TSI Wakeup Channel High-threshold\n    THRESL:16 // at 0: TSI Wakeup Channel Low-threshold\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// PERIPHERAL GROUP: UART [5]\n//        UART0 at 0x4006a000\n//        UART1 at 0x4006b000\n//        UART2 at 0x4006c000\n//        UART3 at 0x4006d000\n//        UART4 at 0x400ea000\n//------------------------------------------------------------------------------\n\nregisters UART [5 @at 0x4006a000 0x4006b000 0x4006c000 0x4006d000 0x400ea000]\n          UART0 @at 0x4006a000\n          UART1 @at 0x4006b000\n          UART2 @at 0x4006c000\n          UART3 @at 0x4006d000\n          UART4 @at 0x400ea000 {\n//---  Register BDH: UART Baud Rate Registers: High\n  BDH @offset 0x0 $u8 {\n    LBKDIE // at 7: LIN Break Detect Interrupt Enable\n    RXEDGIE // at 6: RxD Input Active Edge Interrupt Enable\n    SBNS // at 5: Stop Bit Number Select\n    SBR:5 // at 0: UART Baud Rate Bits\n  }\n\n//---  Register BDL: UART Baud Rate Registers: Low\n  BDL @offset 0x1 $u8 {\n    SBR:8 // at 0: UART Baud Rate Bits\n  }\n\n//---  Register C1: UART Control Register 1\n  C1 @offset 0x2 $u8 {\n    LOOPS // at 7: Loop Mode Select\n    UARTSWAI // at 6: UART Stops in Wait Mode\n    RSRC // at 5: Receiver Source Select\n    M // at 4: 9-bit or 8-bit Mode Select\n    WAKE // at 3: Receiver Wakeup Method Select\n    ILT // at 2: Idle Line Type Select\n    PE // at 1: Parity Enable\n    PT // at 0: Parity Type\n  }\n\n//---  Register C2: UART Control Register 2\n  C2 @offset 0x3 $u8 {\n    TIE // at 7: Transmitter Interrupt or DMA Transfer Enable.\n    TCIE // at 6: Transmission Complete Interrupt Enable\n    RIE // at 5: Receiver Full Interrupt or DMA Transfer Enable\n    ILIE // at 4: Idle Line Interrupt Enable\n    TE // at 3: Transmitter Enable\n    RE // at 2: Receiver Enable\n    RWU // at 1: Receiver Wakeup Control\n    SBK // at 0: Send Break\n  }\n\n//---  Register S1: UART Status Register 1\n  S1 @offset 0x4 @ro $u8 {\n    TDRE // at 7: Transmit Data Register Empty Flag\n    TC // at 6: Transmit Complete Flag\n    RDRF // at 5: Receive Data Register Full Flag\n    IDLE // at 4: Idle Line Flag\n    OR // at 3: Receiver Overrun Flag\n    NF // at 2: Noise Flag\n    FE // at 1: Framing Error Flag\n    PF // at 0: Parity Error Flag\n  }\n\n//---  Register S2: UART Status Register 2\n  S2 @offset 0x5 $u8 {\n    LBKDIF // at 7: LIN Break Detect Interrupt Flag\n    RXEDGIF // at 6: RxD Pin Active Edge Interrupt Flag\n    MSBF // at 5: Most Significant Bit First\n    RXINV // at 4: Receive Data Inversion\n    RWUID // at 3: Receive Wakeup Idle Detect\n    BRK13 // at 2: Break Transmit Character Length\n    LBKDE // at 1: LIN Break Detection Enable\n    RAF // at 0: Receiver Active Flag\n  }\n\n//---  Register C3: UART Control Register 3\n  C3 @offset 0x6 $u8 {\n    R8 // at 7: Received Bit 8\n    T8 // at 6: Transmit Bit 8\n    TXDIR // at 5: Transmitter Pin Data Direction in Single-Wire mode\n    TXINV // at 4: Transmit Data Inversion.\n    ORIE // at 3: Overrun Error Interrupt Enable\n    NEIE // at 2: Noise Error Interrupt Enable\n    FEIE // at 1: Framing Error Interrupt Enable\n    PEIE // at 0: Parity Error Interrupt Enable\n  }\n\n//---  Register D: UART Data Register\n  D @offset 0x7 $u8 {\n    RT:8 // at 0: Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register\n  }\n\n//---  Register MA1: UART Match Address Registers 1\n  MA1 @offset 0x8 $u8 {\n    MA:8 // at 0: Match Address\n  }\n\n//---  Register MA2: UART Match Address Registers 2\n  MA2 @offset 0x9 $u8 {\n    MA:8 // at 0: Match Address\n  }\n\n//---  Register C4: UART Control Register 4\n  C4 @offset 0xa $u8 {\n    MAEN1 // at 7: Match Address Mode Enable 1\n    MAEN2 // at 6: Match Address Mode Enable 2\n    M10 // at 5: 10-bit Mode select\n    BRFA:5 // at 0: Baud Rate Fine Adjust\n  }\n\n//---  Register C5: UART Control Register 5\n  C5 @offset 0xb $u8 {\n    TDMAS // at 7: Transmitter DMA Select\n    1\n    RDMAS // at 5: Receiver Full DMA Select\n    5\n  }\n\n//---  Register ED: UART Extended Data Register\n  ED @offset 0xc @ro $u8 {\n    NOISY // at 7: The current received dataword contained in D and C3[R8] was received with noise.\n    PARITYE // at 6: The current received dataword contained in D and C3[R8] was received with a parity error.\n    6\n  }\n\n//---  Register MODEM: UART Modem Register\n  MODEM @offset 0xd $u8 {\n    4\n    RXRTSE // at 3: Receiver request-to-send enable\n    TXRTSPOL // at 2: Transmitter request-to-send polarity\n    TXRTSE // at 1: Transmitter request-to-send enable\n    TXCTSE // at 0: Transmitter clear-to-send enable\n  }\n\n//---  Register IR: UART Infrared Register\n  IR @offset 0xe $u8 {\n    5\n    IREN // at 2: Infrared enable\n    TNP:2 // at 0: Transmitter narrow pulse\n  }\n\n//---  Register PFIFO: UART FIFO Parameters\n  PFIFO @offset 0x10 $u8 {\n    TXFE // at 7: Transmit FIFO Enable\n    TXFIFOSIZE:3 // at 4: Transmit FIFO. Buffer Depth\n    RXFE // at 3: Receive FIFO Enable\n    RXFIFOSIZE:3 // at 0: Receive FIFO. Buffer Depth\n  }\n\n//---  Register CFIFO: UART FIFO Control Register\n  CFIFO @offset 0x11 $u8 {\n    TXFLUSH // at 7: Transmit FIFO/Buffer Flush\n    RXFLUSH // at 6: Receive FIFO/Buffer Flush\n    3\n    RXOFE // at 2: Receive FIFO Overflow Interrupt Enable\n    TXOFE // at 1: Transmit FIFO Overflow Interrupt Enable\n    RXUFE // at 0: Receive FIFO Underflow Interrupt Enable\n  }\n\n//---  Register SFIFO: UART FIFO Status Register\n  SFIFO @offset 0x12 $u8 {\n    TXEMPT // at 7: Transmit Buffer/FIFO Empty\n    RXEMPT // at 6: Receive Buffer/FIFO Empty\n    3\n    RXOF // at 2: Receiver Buffer Overflow Flag\n    TXOF // at 1: Transmitter Buffer Overflow Flag\n    RXUF // at 0: Receiver Buffer Underflow Flag\n  }\n\n//---  Register TWFIFO: UART FIFO Transmit Watermark\n  TWFIFO @offset 0x13 $u8 {\n    TXWATER:8 // at 0: Transmit Watermark\n  }\n\n//---  Register TCFIFO: UART FIFO Transmit Count\n  TCFIFO @offset 0x14 @ro $u8 {\n    TXCOUNT:8 // at 0: Transmit Counter\n  }\n\n//---  Register RWFIFO: UART FIFO Receive Watermark\n  RWFIFO @offset 0x15 $u8 {\n    RXWATER:8 // at 0: Receive Watermark\n  }\n\n//---  Register RCFIFO: UART FIFO Receive Count\n  RCFIFO @offset 0x16 @ro $u8 {\n    RXCOUNT:8 // at 0: Receive Counter\n  }\n\n//---  Register C7816: UART 7816 Control Register\n  C7816 @offset 0x18 $u8 {\n    3\n    ONACK // at 4: Generate NACK on Overflow\n    ANACK // at 3: Generate NACK on Error\n    INIT // at 2: Detect Initial Character\n    TTYPE // at 1: Transfer Type\n    ISO_7816E // at 0: ISO-7816 Functionality Enabled\n  }\n\n//---  Register IE7816: UART 7816 Interrupt Enable Register\n  IE7816 @offset 0x19 $u8 {\n    WTE // at 7: Wait Timer Interrupt Enable\n    CWTE // at 6: Character Wait Timer Interrupt Enable\n    BWTE // at 5: Block Wait Timer Interrupt Enable\n    INITDE // at 4: Initial Character Detected Interrupt Enable\n    ADTE // at 3: ATR Duration Timer Interrupt Enable\n    GTVE // at 2: Guard Timer Violated Interrupt Enable\n    TXTE // at 1: Transmit Threshold Exceeded Interrupt Enable\n    RXTE // at 0: Receive Threshold Exceeded Interrupt Enable\n  }\n\n//---  Register IS7816: UART 7816 Interrupt Status Register\n  IS7816 @offset 0x1a $u8 {\n    WT // at 7: Wait Timer Interrupt\n    CWT // at 6: Character Wait Timer Interrupt\n    BWT // at 5: Block Wait Timer Interrupt\n    INITD // at 4: Initial Character Detected Interrupt\n    ADT // at 3: ATR Duration Time Interrupt\n    GTV // at 2: Guard Timer Violated Interrupt\n    TXT // at 1: Transmit Threshold Exceeded Interrupt\n    RXT // at 0: Receive Threshold Exceeded Interrupt\n  }\n\n//---  Register WP7816: UART 7816 Wait Parameter Register\n  WP7816 @offset 0x1b $u8 {\n    WTX:8 // at 0: Wait Time Multiplier (C7816[TTYPE] = 1)\n  }\n\n//---  Register WN7816: UART 7816 Wait N Register\n  WN7816 @offset 0x1c $u8 {\n    GTN:8 // at 0: Guard Band N\n  }\n\n//---  Register WF7816: UART 7816 Wait FD Register\n  WF7816 @offset 0x1d $u8 {\n    GTFD:8 // at 0: FD Multiplier\n  }\n\n//---  Register ET7816: UART 7816 Error Threshold Register\n  ET7816 @offset 0x1e $u8 {\n    TXTHRESHOLD:4 // at 4: Transmit NACK Threshold\n    RXTHRESHOLD:4 // at 0: Receive NACK Threshold\n  }\n\n//---  Register TL7816: UART 7816 Transmit Length Register\n  TL7816 @offset 0x1f $u8 {\n    TLEN:8 // at 0: Transmit Length\n  }\n\n//---  Register AP7816A_T0: UART 7816 ATR Duration Timer Register A\n  AP7816A_T0 @offset 0x3a $u8 {\n    ADTI_H:8 // at 0: ATR Duration Time Integer High (C7816[TTYPE] = 0)\n  }\n\n//---  Register AP7816B_T0: UART 7816 ATR Duration Timer Register B\n  AP7816B_T0 @offset 0x3b $u8 {\n    ADTI_L:8 // at 0: ATR Duration Time Integer Low (C7816[TTYPE] = 0)\n  }\n\n//---  Register WP7816A_T0: UART 7816 Wait Parameter Register A\n  WP7816A_T0 @offset 0x3c $u8 {\n    WI_H:8 // at 0: Wait Time Integer High (C7816[TTYPE] = 0)\n  }\n\n//---  Register WP7816A_T1: UART 7816 Wait Parameter Register A\n  WP7816A_T1 @offset 0x3c $u8 {\n    BWI_H:8 // at 0: Block Wait Time Integer High (C7816[TTYPE] = 1)\n  }\n\n//---  Register WP7816B_T0: UART 7816 Wait Parameter Register B\n  WP7816B_T0 @offset 0x3d $u8 {\n    WI_L:8 // at 0: Wait Time Integer Low (C7816[TTYPE] = 0)\n  }\n\n//---  Register WP7816B_T1: UART 7816 Wait Parameter Register B\n  WP7816B_T1 @offset 0x3d $u8 {\n    BWI_L:8 // at 0: Block Wait Time Integer Low (C7816[TTYPE] = 1)\n  }\n\n//---  Register WGP7816_T1: UART 7816 Wait and Guard Parameter Register\n  WGP7816_T1 @offset 0x3e $u8 {\n    CWI1:4 // at 4: Character Wait Time Integer 1 (C7816[TTYPE] = 1)\n    BGI:4 // at 0: Block Guard Time Integer (C7816[TTYPE] = 1)\n  }\n\n//---  Register WP7816C_T1: UART 7816 Wait Parameter Register C\n  WP7816C_T1 @offset 0x3f $u8 {\n    3\n    CWI2:5 // at 0: Character Wait Time Integer 2 (C7816[TTYPE] = 1)\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USB0: Universal Serial Bus, OTG Capable Controller\n//------------------------------------------------------------------------------\n\nregisters USB0 @at 0x40072000 {\n//---  Register PERID: Peripheral ID register\n  PERID @offset 0x0 @ro $u8 {\n    2\n    ID:6 // at 0: Peripheral Identification\n  }\n\n//---  Register IDCOMP: Peripheral ID Complement register\n  IDCOMP @offset 0x4 @ro $u8 {\n    2\n    NID:6 // at 0: Ones' complement of PERID[ID]. bits.\n  }\n\n//---  Register REV: Peripheral Revision register\n  REV @offset 0x8 @ro $u8 {\n    REV:8 // at 0: Revision\n  }\n\n//---  Register ADDINFO: Peripheral Additional Info register\n  ADDINFO @offset 0xc @ro $u8 {\n    7\n    IEHOST // at 0: This bit is set if host mode is enabled.\n  }\n\n//---  Register OTGISTAT: OTG Interrupt Status register\n  OTGISTAT @offset 0x10 $u8 {\n    IDCHG // at 7: This bit is set when a change in the ID Signal from the USB connector is sensed.\n    ONEMSEC // at 6: This bit is set when the 1 millisecond timer expires\n    LINE_STATE_CHG // at 5: This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits) are stable without change for 1 millisecond, and the value of the line state is different from the last time when the line state was stable\n    1\n    SESSVLDCHG // at 3: This bit is set when a change in VBUS is detected indicating a session valid or a session no longer valid\n    B_SESS_CHG // at 2: This bit is set when a change in VBUS is detected on a B device.\n    1\n    AVBUSCHG // at 0: This bit is set when a change in VBUS is detected on an A device.\n  }\n\n//---  Register OTGICR: OTG Interrupt Control register\n  OTGICR @offset 0x14 $u8 {\n    IDEN // at 7: ID Interrupt Enable\n    ONEMSECEN // at 6: One Millisecond Interrupt Enable\n    LINESTATEEN // at 5: Line State Change Interrupt Enable\n    1\n    SESSVLDEN // at 3: Session Valid Interrupt Enable\n    BSESSEN // at 2: B Session END Interrupt Enable\n    1\n    AVBUSEN // at 0: A VBUS Valid Interrupt Enable\n  }\n\n//---  Register OTGSTAT: OTG Status register\n  OTGSTAT @offset 0x18 $u8 {\n    ID // at 7: Indicates the current state of the ID pin on the USB connector\n    ONEMSECEN // at 6: This bit is reserved for the 1ms count, but it is not useful to software.\n    LINESTATESTABLE // at 5: Indicates that the internal signals that control the LINE_STATE_CHG field of OTGISTAT are stable for at least 1 ms\n    1\n    SESS_VLD // at 3: Session Valid\n    BSESSEND // at 2: B Session End\n    1\n    AVBUSVLD // at 0: A VBUS Valid\n  }\n\n//---  Register OTGCTL: OTG Control register\n  OTGCTL @offset 0x1c $u8 {\n    DPHIGH // at 7: D+ Data Line pullup resistor enable\n    1\n    DPLOW // at 5: D+ Data Line pull-down resistor enable\n    DMLOW // at 4: D- Data Line pull-down resistor enable\n    1\n    OTGEN // at 2: On-The-Go pullup/pulldown resistor enable\n    2\n  }\n\n//---  Register ISTAT: Interrupt Status register\n  ISTAT @offset 0x80 $u8 {\n    STALL // at 7: Stall Interrupt\n    ATTACH // at 6: Attach Interrupt\n    RESUME // at 5: This bit is set when a K-state is observed on the DP/DM signals for 2\n    SLEEP // at 4: This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms\n    TOKDNE // at 3: This bit is set when the current token being processed has completed\n    SOFTOK // at 2: This bit is set when the USB Module receives a Start Of Frame (SOF) token\n    ERROR // at 1: This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur\n    USBRST // at 0: This bit is set when the USB Module has decoded a valid USB reset\n  }\n\n//---  Register INTEN: Interrupt Enable register\n  INTEN @offset 0x84 $u8 {\n    STALLEN // at 7: STALL Interrupt Enable\n    ATTACHEN // at 6: ATTACH Interrupt Enable\n    RESUMEEN // at 5: RESUME Interrupt Enable\n    SLEEPEN // at 4: SLEEP Interrupt Enable\n    TOKDNEEN // at 3: TOKDNE Interrupt Enable\n    SOFTOKEN // at 2: SOFTOK Interrupt Enable\n    ERROREN // at 1: ERROR Interrupt Enable\n    USBRSTEN // at 0: USBRST Interrupt Enable\n  }\n\n//---  Register ERRSTAT: Error Interrupt Status register\n  ERRSTAT @offset 0x88 $u8 {\n    BTSERR // at 7: This bit is set when a bit stuff error is detected\n    1\n    DMAERR // at 5: This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data\n    BTOERR // at 4: This bit is set when a bus turnaround timeout error occurs\n    DFN8 // at 3: This bit is set if the data field received was not 8 bits in length\n    CRC16 // at 2: This bit is set when a data packet is rejected due to a CRC16 error.\n    CRC5EOF // at 1: This error interrupt has two functions\n    PIDERR // at 0: This bit is set when the PID check field fails.\n  }\n\n//---  Register ERREN: Error Interrupt Enable register\n  ERREN @offset 0x8c $u8 {\n    BTSERREN // at 7: BTSERR Interrupt Enable\n    1\n    DMAERREN // at 5: DMAERR Interrupt Enable\n    BTOERREN // at 4: BTOERR Interrupt Enable\n    DFN8EN // at 3: DFN8 Interrupt Enable\n    CRC16EN // at 2: CRC16 Interrupt Enable\n    CRC5EOFEN // at 1: CRC5/EOF Interrupt Enable\n    PIDERREN // at 0: PIDERR Interrupt Enable\n  }\n\n//---  Register STAT: Status register\n  STAT @offset 0x90 @ro $u8 {\n    ENDP:4 // at 4: This four-bit field encodes the endpoint address that received or transmitted the previous token\n    TX // at 3: Transmit Indicator\n    ODD // at 2: This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.\n    2\n  }\n\n//---  Register CTL: Control register\n  CTL @offset 0x94 $u8 {\n    JSTATE // at 7: Live USB differential receiver JSTATE signal\n    SE0 // at 6: Live USB Single Ended Zero signal\n    TXSUSPENDTOKENBUSY // at 5: In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token\n    RESET // at 4: Setting this bit enables the USB Module to generate USB reset signaling\n    HOSTMODEEN // at 3: When set to 1, this bit enables the USB Module to operate in Host mode\n    RESUME // at 2: When set to 1 this bit enables the USB Module to execute resume signaling\n    ODDRST // at 1: Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank\n    USBENSOFEN // at 0: USB Enable\n  }\n\n//---  Register ADDR: Address register\n  ADDR @offset 0x98 $u8 {\n    LSEN // at 7: Low Speed Enable bit\n    ADDR:7 // at 0: USB Address\n  }\n\n//---  Register BDTPAGE1: BDT Page register 1\n  BDTPAGE1 @offset 0x9c $u8 {\n    BDTBA:7 // at 1: Provides address bits 15 through 9 of the BDT base address.\n    1\n  }\n\n//---  Register FRMNUML: Frame Number register Low\n  FRMNUML @offset 0xa0 $u8 {\n    FRM:8 // at 0: This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory\n  }\n\n//---  Register FRMNUMH: Frame Number register High\n  FRMNUMH @offset 0xa4 $u8 {\n    5\n    FRM:3 // at 0: This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory\n  }\n\n//---  Register TOKEN: Token register\n  TOKEN @offset 0xa8 $u8 {\n    TOKENPID:4 // at 4: Contains the token type executed by the USB module.\n    TOKENENDPT:4 // at 0: Holds the Endpoint address for the token command\n  }\n\n//---  Register SOFTHLD: SOF Threshold register\n  SOFTHLD @offset 0xac $u8 {\n    CNT:8 // at 0: Represents the SOF count threshold in byte times.\n  }\n\n//---  Register BDTPAGE2: BDT Page Register 2\n  BDTPAGE2 @offset 0xb0 $u8 {\n    BDTBA:8 // at 0: Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory\n  }\n\n//---  Register BDTPAGE3: BDT Page Register 3\n  BDTPAGE3 @offset 0xb4 $u8 {\n    BDTBA:8 // at 0: Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory\n  }\n\n//---  Registers ENDPT(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Endpoint Control register\n  ENDPT [16 @offset 0xc0 @inc 0x4]\n  ENDPT0 @offset 0xc0\n  ENDPT1 @offset 0xc4\n  ENDPT2 @offset 0xc8\n  ENDPT3 @offset 0xcc\n  ENDPT4 @offset 0xd0\n  ENDPT5 @offset 0xd4\n  ENDPT6 @offset 0xd8\n  ENDPT7 @offset 0xdc\n  ENDPT8 @offset 0xe0\n  ENDPT9 @offset 0xe4\n  ENDPT10 @offset 0xe8\n  ENDPT11 @offset 0xec\n  ENDPT12 @offset 0xf0\n  ENDPT13 @offset 0xf4\n  ENDPT14 @offset 0xf8\n  ENDPT15 @offset 0xfc $u8 {\n    HOSTWOHUB // at 7: Host without a hub This is a Host mode only field and is present in the control register for endpoint 0 (ENDPT0) only\n    RETRYDIS // at 6: This is a Host mode only bit and is present in the control register for endpoint 0 (ENDPT0) only\n    1\n    EPCTLDIS // at 4: This bit, when set, disables control (SETUP) transfers\n    EPRXEN // at 3: This bit, when set, enables the endpoint for RX transfers. See\n    EPTXEN // at 2: This bit, when set, enables the endpoint for TX transfers. See\n    EPSTALL // at 1: When set this bit indicates that the endpoint is called\n    EPHSHK // at 0: When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint\n  }\n\n//---  Register USBCTRL: USB Control register\n  USBCTRL @offset 0x100 $u8 {\n    SUSP // at 7: Places the USB transceiver into the suspend state.\n    PDE // at 6: Enables the weak pulldowns on the USB transceiver.\n    6\n  }\n\n//---  Register OBSERVE: USB OTG Observe register\n  OBSERVE @offset 0x104 @ro $u8 {\n    DPPU // at 7: Provides observability of the D+ Pullup enable at the USB transceiver.\n    DPPD // at 6: Provides observability of the D+ Pulldown enable at the USB transceiver.\n    1\n    DMPD // at 4: Provides observability of the D- Pulldown enable at the USB transceiver.\n    4\n  }\n\n//---  Register CONTROL: USB OTG Control register\n  CONTROL @offset 0x108 $u8 {\n    3\n    DPPULLUPNONOTG // at 4: Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG device mode.\n    4\n  }\n\n//---  Register USBTRC0: USB Transceiver Control register 0\n  USBTRC0 @offset 0x10c $u8 {\n    USBRESET // at 7: USB Reset\n    1\n    USBRESMEN // at 5: Asynchronous Resume Interrupt Enable\n    2\n    USB_CLK_RECOVERY_INT // at 2: Combined USB Clock Recovery interrupt status\n    SYNC_DET // at 1: Synchronous USB Interrupt Detect\n    USB_RESUME_INT // at 0: USB Asynchronous Interrupt\n  }\n\n//---  Register USBFRMADJUST: Frame Adjust Register\n  USBFRMADJUST @offset 0x114 $u8 {\n    ADJ:8 // at 0: Frame Adjustment\n  }\n\n//---  Register CLK_RECOVER_CTRL: USB Clock recovery control\n  CLK_RECOVER_CTRL @offset 0x140 $u8 {\n    CLOCK_RECOVER_EN // at 7: Crystal-less USB enable\n    RESET_RESUME_ROUGH_EN // at 6: Reset/resume to rough phase enable\n    RESTART_IFRTRIM_EN // at 5: Restart from IFR trim value\n    5\n  }\n\n//---  Register CLK_RECOVER_IRC_EN: IRC48M oscillator enable register\n  CLK_RECOVER_IRC_EN @offset 0x144 $u8 {\n    6\n    IRC_EN // at 1: IRC48M enable\n    REG_EN // at 0: IRC48M regulator enable\n  }\n\n//---  Register CLK_RECOVER_INT_EN: Clock recovery combined interrupt enable\n  CLK_RECOVER_INT_EN @offset 0x154 $u8 {\n    3\n    OVF_ERROR_EN // at 4: Determines whether OVF_ERROR condition signal is used in generation of USB_CLK_RECOVERY_INT.\n    4\n  }\n\n//---  Register CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status\n  CLK_RECOVER_INT_STATUS @offset 0x15c $u8 {\n    3\n    OVF_ERROR // at 4: Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M module\n    4\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USBDCD: USB Device Charger Detection module\n//------------------------------------------------------------------------------\n\nregisters USBDCD @at 0x40035000 {\n//---  Register CONTROL: Control register\n  CONTROL @offset 0x0 $u32 {\n    6\n    SR // at 25: Software Reset\n    START // at 24: Start Change Detection Sequence\n    6\n    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.\n    IE // at 16: Interrupt Enable\n    7\n    IF // at 8: Interrupt Flag\n    7\n    IACK // at 0: Interrupt Acknowledge\n  }\n\n//---  Register CLOCK: Clock register\n  CLOCK @offset 0x4 $u32 {\n    20\n    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary\n    1\n    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed\n  }\n\n//---  Register STATUS: Status register\n  STATUS @offset 0x8 @ro $u32 {\n    9\n    ACTIVE // at 22: Active Status Indicator\n    TO // at 21: Timeout Flag\n    ERR // at 20: Error Flag\n    SEQ_STAT:2 // at 18: Charger Detection Sequence Status\n    SEQ_RES:2 // at 16: Charger Detection Sequence Results\n    16\n  }\n\n//---  Register SIGNAL_OVERRIDE: Signal Override Register\n  SIGNAL_OVERRIDE @offset 0xc $u32 {\n    30\n    PS:2 // at 0: Phase Selection\n  }\n\n//---  Register TIMER0: TIMER0 register\n  TIMER0 @offset 0x10 $u32 {\n    6\n    TSEQ_INIT:10 // at 16: Sequence Initiation Time\n    4\n    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)\n  }\n\n//---  Register TIMER1: TIMER1 register\n  TIMER1 @offset 0x14 $u32 {\n    6\n    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal\n    6\n    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled\n  }\n\n//---  Register TIMER2_BC11: TIMER2_BC11 register\n  TIMER2_BC11 @offset 0x18 $u32 {\n    6\n    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup\n    12\n    CHECK_DM:4 // at 0: Time Before Check of D- Line\n  }\n\n//---  Register TIMER2_BC12: TIMER2_BC12 register\n  TIMER2_BC12 @offset 0x18 $u32 {\n    6\n    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection\n    6\n    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USBHS: USB HS/FS/LS OTG Controller\n//------------------------------------------------------------------------------\n\nregisters USBHS @at 0x400a1000 {\n//---  Register ID: Identification Register\n  ID @offset 0x0 @ro $u32 {\n    VERSIONID:3 // at 29: Version ID\n    VERSION:4 // at 25: Version\n    REVISION:4 // at 21: Revision\n    TAG:5 // at 16: Tag\n    2\n    NID:6 // at 8: Ones complement version of ID.\n    2\n    ID:6 // at 0: Configuration number\n  }\n\n//---  Register HWGENERAL: General Hardware Parameters Register\n  HWGENERAL @offset 0x4 @ro $u32 {\n    21\n    SM:2 // at 9: Serial mode\n    PHYM:3 // at 6: PHY Mode\n    PHYW:2 // at 4: PHY Width\n    4\n  }\n\n//---  Register HWHOST: Host Hardware Parameters Register\n  HWHOST @offset 0x8 @ro $u32 {\n    TTPER:8 // at 24: Transaction translator periodic contexts.\n    TTASY:8 // at 16: Transaction translator contexts.\n    12\n    NPORT:3 // at 1: Number of Ports\n    HC // at 0: Host Capable\n  }\n\n//---  Register HWDEVICE: Device Hardware Parameters Register\n  HWDEVICE @offset 0xc @ro $u32 {\n    26\n    DEVEP:5 // at 1: Device endpoints.\n    DC // at 0: Device Capable\n  }\n\n//---  Register HWTXBUF: Transmit Buffer Hardware Parameters Register\n  HWTXBUF @offset 0x10 @ro $u32 {\n    TXLC // at 31: Transmit local Context Registers\n    7\n    TXCHANADD:8 // at 16: Transmit Channel Address\n    TXADD:8 // at 8: Transmit Address.\n    TXBURST:8 // at 0: Transmit Burst.\n  }\n\n//---  Register HWRXBUF: Receive Buffer Hardware Parameters Register\n  HWRXBUF @offset 0x14 @ro $u32 {\n    16\n    RXADD:8 // at 8: Receive Address.\n    RXBURST:8 // at 0: Receive Burst.\n  }\n\n//---  Registers GPTIMERLD(0,1): General Purpose Timer n Load Register\n  GPTIMERLD [2 @offset 0x80 @inc 0x8]\n  GPTIMER0LD @offset 0x80\n  GPTIMER1LD @offset 0x88 $u32 {\n    8\n    GPTLD:24 // at 0: Specifies the value to be loaded into the countdown timer on a reset\n  }\n\n//---  Registers GPTIMERCTL(0,1): General Purpose Timer n Control Register\n  GPTIMERCTL [2 @offset 0x84 @inc 0x8]\n  GPTIMER0CTL @offset 0x84\n  GPTIMER1CTL @offset 0x8c $u32 {\n    RUN // at 31: Timer Run\n    RST // at 30: Timer Reset\n    5\n    MODE // at 24: Timer Mode\n    GPTCNT:24 // at 0: Timer Count\n  }\n\n//---  Register USB_SBUSCFG: System Bus Interface Configuration Register\n  USB_SBUSCFG @offset 0x90 $u32 {\n    29\n    BURSTMODE:3 // at 0: Burst mode\n  }\n\n//---  Register HCIVERSION: Host Controller Interface Version and Capability Registers Length Register\n  HCIVERSION @offset 0x100 @ro $u32 {\n    HCIVERSION:16 // at 16: EHCI revision number\n    8\n    CAPLENGTH:8 // at 0: Capability registers length\n  }\n\n//---  Register HCSPARAMS: Host Controller Structural Parameters Register\n  HCSPARAMS @offset 0x104 @ro $u32 {\n    4\n    N_TT:4 // at 24: Number of Transaction Translators.\n    N_PTT:4 // at 20: Ports per Transaction Translator\n    3\n    PI // at 16: Port Indicators\n    N_CC:4 // at 12: Number of Companion Controllers\n    N_PCC:4 // at 8: Number Ports per CC\n    3\n    PPC // at 4: Power Port Control\n    N_PORTS:4 // at 0: Number of Ports\n  }\n\n//---  Register HCCPARAMS: Host Controller Capability Parameters Register\n  HCCPARAMS @offset 0x108 @ro $u32 {\n    16\n    EECP:8 // at 8: EHCI Extended Capabilities Pointer\n    IST:4 // at 4: Isochronous Scheduling Threshold\n    1\n    ASP // at 2: Asynchronous Schedule Park capability\n    PFL // at 1: Programmable Frame List flag\n    ADC // at 0: 64-bit addressing capability.\n  }\n\n//---  Register DCIVERSION: Device Controller Interface Version\n  DCIVERSION @offset 0x122 @ro $u16 {\n    DCIVERSION:16 // at 0: Device interface revision number.\n  }\n\n//---  Register DCCPARAMS: Device Controller Capability Parameters\n  DCCPARAMS @offset 0x124 @ro $u32 {\n    23\n    HC // at 8: Host Capable\n    DC // at 7: Device Capable\n    2\n    DEN:5 // at 0: Device Endpoint Number\n  }\n\n//---  Register USBCMD: USB Command Register\n  USBCMD @offset 0x140 $u32 {\n    8\n    ITC:8 // at 16: Interrupt Threshold Control\n    FS2 // at 15: Frame list Size 2\n    ATDTW // at 14: Add dTD TripWire\n    SUTW // at 13: Setup TripWire\n    1\n    ASPE // at 11: Asynchronous Schedule Park mode Enable\n    1\n    ASP:2 // at 8: Asynchronous Schedule Park mode count\n    1\n    IAA // at 6: Interrupt on Async Advance doorbell\n    ASE // at 5: Asynchronous Schedule Enable\n    PSE // at 4: Periodic Schedule Enable\n    FS:2 // at 2: Frame list Size\n    RST // at 1: Controller Reset\n    RS // at 0: Run/Stop\n  }\n\n//---  Register USBSTS: USB Status Register\n  USBSTS @offset 0x144 $u32 {\n    6\n    TI1 // at 25: General purpose Timer 1 Interrupt\n    TI0 // at 24: General purpose Timer 0 Interrupt\n    4\n    UPI // at 19: USB host Periodic Interrupt\n    UAI // at 18: USB host Asynchronous Interrupt\n    1\n    NAKI // at 16: NAK Interrupt\n    AS // at 15: Asynchronous schedule Status\n    PS // at 14: Periodic schedule Status\n    RCL // at 13: Reclamation\n    HCH // at 12: Host Controller Halted\n    3\n    SLI // at 8: Device-controller suspend\n    SRI // at 7: SOF Received\n    URI // at 6: USB Reset received\n    AAI // at 5: Interrupt on Async Advance\n    SEI // at 4: System Error\n    FRI // at 3: Frame-list Rollover\n    PCI // at 2: Port Change detect\n    UEI // at 1: USB Error Interrupt\n    UI // at 0: USB Interrupt (USBINT)\n  }\n\n//---  Register USBINTR: USB Interrupt Enable Register\n  USBINTR @offset 0x148 $u32 {\n    6\n    TIE1 // at 25: General purpose Timer 1 Interrupt Enable\n    TIE0 // at 24: General purpose Timer 0 Interrupt Enable\n    4\n    UPIE // at 19: USB host Periodic Interrupt Enable\n    UAIE // at 18: USB host Asynchronous Interrupt Enable\n    1\n    NAKE // at 16: NAK Interrupt Enable\n    7\n    SLE // at 8: Sleep (DC suspend) Enable\n    SRE // at 7: SOF-Received Enable\n    URE // at 6: USB-Reset Enable\n    AAE // at 5: Interrupt on Async advance Enable\n    SEE // at 4: System Error Enable\n    FRE // at 3: Frame list Rollover Enable\n    PCE // at 2: Port Change detect Enable\n    UEE // at 1: USB Error interrupt Enable\n    UE // at 0: USB interrupt Enable\n  }\n\n//---  Register FRINDEX: Frame Index Register\n  FRINDEX @offset 0x14c $u32 {\n    Reerved:18 // at 14: Reserved\n    FRINDEX:14 // at 0: Frame Index\n  }\n\n//---  Register DEVICEADDR: Device Address Register\n  DEVICEADDR @offset 0x154 $u32 {\n    USBADR:7 // at 25: Device Address\n    USBADRA // at 24: Device Address Advance\n    24\n  }\n\n//---  Register PERIODICLISTBASE: Periodic Frame List Base Address Register\n  PERIODICLISTBASE @offset 0x154 $u32 {\n    PERBASE:20 // at 12: Base address\n    12\n  }\n\n//---  Register ASYNCLISTADDR: Current Asynchronous List Address Register\n  ASYNCLISTADDR @offset 0x158 $u32 {\n    ASYBASE:27 // at 5: Link pointer low (LPL)\n    5\n  }\n\n//---  Register EPLISTADDR: Endpoint List Address Register\n  EPLISTADDR @offset 0x158 $u32 {\n    EPBASE:21 // at 11: Endpoint list address\n    11\n  }\n\n//---  Register TTCTRL: Host TT Asynchronous Buffer Control\n  TTCTRL @offset 0x15c @ro $u32 {\n    Reerved // at 31: Reserved\n    TTHA:7 // at 24: TT Hub Address\n    24\n  }\n\n//---  Register BURSTSIZE: Master Interface Data Burst Size Register\n  BURSTSIZE @offset 0x160 $u32 {\n    16\n    TXPBURST:8 // at 8: Programable TX Burst length\n    RXPBURST:8 // at 0: Programable RX Burst length\n  }\n\n//---  Register TXFILLTUNING: Transmit FIFO Tuning Control Register\n  TXFILLTUNING @offset 0x164 $u32 {\n    10\n    TXFIFOTHRES:6 // at 16: FIFO burst Threshold\n    3\n    TXSCHHEALTH:5 // at 8: Scheduler Health counter\n    1\n    TXSCHOH:7 // at 0: Scheduler Overhead\n  }\n\n//---  Register ENDPTNAK: Endpoint NAK Register\n  ENDPTNAK @offset 0x178 $u32 {\n    12\n    EPTN:4 // at 16: TX Endpoint NAK\n    12\n    EPRN:4 // at 0: RX Endpoint NAK\n  }\n\n//---  Register ENDPTNAKEN: Endpoint NAK Enable Register\n  ENDPTNAKEN @offset 0x17c $u32 {\n    12\n    EPTNE:4 // at 16: TX Endpoint NAK\n    12\n    EPRNE:4 // at 0: RX Endpoint NAK\n  }\n\n//---  Register CONFIGFLAG: Configure Flag Register\n  CONFIGFLAG @offset 0x180 @ro $u32\n//---  Register PORTSC1: Port Status and Control Registers\n  PORTSC1 @offset 0x184 $u32 {\n    PTS:2 // at 30: Port Transceiver Select [1:0]\n    2\n    PSPD:2 // at 26: Port Speed\n    PTS2 // at 25: Port Transceiver Select [2]\n    PFSC // at 24: Port force Full-Speed Connect\n    PHCD // at 23: PHY low power suspend\n    WKOC // at 22: Wake on Over-Current enable\n    WKDS // at 21: Wake on Disconnect enable\n    WKCN // at 20: Wake on Connect enable\n    PTC:4 // at 16: Port Test Control\n    PIC:2 // at 14: Port Indicator Control\n    PO // at 13: Port Owner\n    PP // at 12: Port Power\n    LS:2 // at 10: Line Status\n    HSP // at 9: High Speed Port.\n    PR // at 8: Port Reset\n    SUSP // at 7: Suspend\n    FPR // at 6: Force Port Resume\n    OCC // at 5: Over-Current Change\n    OCA // at 4: Over-current active\n    PEC // at 3: Port Enable/disable Change\n    PE // at 2: Port Enabled/disabled\n    CSC // at 1: Connect Change Status\n    CCS // at 0: Current Connect Status\n  }\n\n//---  Register OTGSC: On-the-Go Status and Control Register\n  OTGSC @offset 0x1a4 $u32 {\n    1\n    DPIE // at 30: Data Pulse Interrupt Enable\n    MSE // at 29: 1 Milli-Second timer interrupt Enable\n    BSEIE // at 28: B Session End Interrupt Enable\n    BSVIE // at 27: B Session Valid Interrupt Enable\n    ASVIE // at 26: A Session Valid Interrupt Enable\n    AVVIE // at 25: A VBUS Valid Interrupt Enable\n    IDIE // at 24: USB ID Interrupt Enable\n    1\n    DPIS // at 22: Data Pulse interrupt Status\n    MSS // at 21: 1 Milli-Second timer interrupt Status\n    BSEIS // at 20: B Session End Interrupt Status\n    BSVIS // at 19: B Session Valid Interrupt Status\n    ASVIS // at 18: A Session Valid Interrupt Status\n    AVVIS // at 17: A VBUS Valid Interrupt Status\n    IDIS // at 16: USB ID Interrupt Status\n    1\n    DPS // at 14: Data bus Pulsing Status\n    MST // at 13: 1 Milli-Second timer Toggle\n    BSE // at 12: B Session End\n    BSV // at 11: B Session Valid\n    ASV // at 10: A Session Valid\n    AVV // at 9: A VBus Valid\n    ID // at 8: USB ID\n    HABA // at 7: Hardware Assist B-Disconnect to A-connect\n    1\n    IDPU // at 5: ID Pull-Up\n    DP // at 4: Data Pulsing\n    OT // at 3: OTG Termination\n    HAAR // at 2: Hardware Assist Auto-Reset\n    VC // at 1: VBUS Charge\n    VD // at 0: VBUS Discharge\n  }\n\n//---  Register USBMODE: USB Mode Register\n  USBMODE @offset 0x1a8 $u32 {\n    17\n    TXHSD:3 // at 12: Tx to Tx HS Delay\n    7\n    SDIS // at 4: Stream DISable\n    SLOM // at 3: Setup Lock-Out Mode\n    ES // at 2: Endian Select\n    CM:2 // at 0: Controller Mode\n  }\n\n//---  Register EPSETUPSR: Endpoint Setup Status Register\n  EPSETUPSR @offset 0x1ac $u32 {\n    28\n    EPSETUPSTAT:4 // at 0: Setup Endpoint Status\n  }\n\n//---  Register EPPRIME: Endpoint Initialization Register\n  EPPRIME @offset 0x1b0 $u32 {\n    12\n    PETB:4 // at 16: Prime Endpoint tTansmit Buffer\n    12\n    PERB:4 // at 0: Prime Endpoint Receive Buffer\n  }\n\n//---  Register EPFLUSH: Endpoint Flush Register\n  EPFLUSH @offset 0x1b4 $u32 {\n    12\n    FETB:4 // at 16: Flush Endpoint Transmit Buffer\n    12\n    FERB:4 // at 0: Flush Endpoint Receive Buffer\n  }\n\n//---  Register EPSR: Endpoint Status Register\n  EPSR @offset 0x1b8 @ro $u32 {\n    12\n    ETBR:4 // at 16: Endpoint Transmit Buffer Ready\n    12\n    ERBR:4 // at 0: Endpoint Receive Buffer Ready\n  }\n\n//---  Register EPCOMPLETE: Endpoint Complete Register\n  EPCOMPLETE @offset 0x1bc $u32 {\n    12\n    ETCE:4 // at 16: Endpoint Transmit Complete Event\n    12\n    ERCE:4 // at 0: Endpoint Receive Complete Event\n  }\n\n//---  Register EPCR0: Endpoint Control Register 0\n  EPCR0 @offset 0x1c0 $u32 {\n    8\n    TXE // at 23: TX Endpoint Enable\n    3\n    TXT:2 // at 18: TX Endpoint Type\n    1\n    TXS // at 16: TX Endpoint Stall\n    8\n    RXE // at 7: RX endpoint Enable\n    3\n    RXT:2 // at 2: RX endpoint Type\n    1\n    RXS // at 0: RX endpoint Stall\n  }\n\n//---  Registers EPCR(1,2,3,4,5,6,7): Endpoint Control Register n\n  EPCR [7 @offset 0x1c4 @inc 0x4]\n  EPCR1 @offset 0x1c4\n  EPCR2 @offset 0x1c8\n  EPCR3 @offset 0x1cc\n  EPCR4 @offset 0x1d0\n  EPCR5 @offset 0x1d4\n  EPCR6 @offset 0x1d8\n  EPCR7 @offset 0x1dc $u32 {\n    8\n    TXE // at 23: TX endpoint Enable\n    TXR // at 22: TX data toggle Reset\n    TXI // at 21: TX data toggle Inhibit\n    1\n    TXT:2 // at 18: TX endpoint Type\n    TXD // at 17: TX endpoint Data source\n    TXS // at 16: TX endpoint Stall\n    8\n    RXE // at 7: RX endpoint Enable\n    RXR // at 6: RX data toggle Reset\n    RXI // at 5: RX data toggle Inhibit\n    1\n    RXT:2 // at 2: RX endpoint Type\n    RXD // at 1: RX endpoint Data sink\n    RXS // at 0: RX endpoint Stall\n  }\n\n//---  Register USBGENCTRL: USB General Control Register\n  USBGENCTRL @offset 0x200 $u32 {\n    26\n    WU_INT_CLR // at 5: Wakeup Interrupt Clear\n    4\n    WU_IE // at 0: Wakeup Interrupt Enable\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USBHSDCD: USB Device Charger Detection module\n//------------------------------------------------------------------------------\n\nregisters USBHSDCD @at 0x400a3000 {\n//---  Register CONTROL: Control register\n  CONTROL @offset 0x0 $u32 {\n    6\n    SR // at 25: Software Reset\n    START // at 24: Start Change Detection Sequence\n    6\n    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.\n    IE // at 16: Interrupt Enable\n    7\n    IF // at 8: Interrupt Flag\n    7\n    IACK // at 0: Interrupt Acknowledge\n  }\n\n//---  Register CLOCK: Clock register\n  CLOCK @offset 0x4 $u32 {\n    20\n    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary\n    1\n    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed\n  }\n\n//---  Register STATUS: Status register\n  STATUS @offset 0x8 @ro $u32 {\n    9\n    ACTIVE // at 22: Active Status Indicator\n    TO // at 21: Timeout Flag\n    ERR // at 20: Error Flag\n    SEQ_STAT:2 // at 18: Charger Detection Sequence Status\n    SEQ_RES:2 // at 16: Charger Detection Sequence Results\n    16\n  }\n\n//---  Register SIGNAL_OVERRIDE: Signal Override Register\n  SIGNAL_OVERRIDE @offset 0xc $u32 {\n    30\n    PS:2 // at 0: Phase Selection\n  }\n\n//---  Register TIMER0: TIMER0 register\n  TIMER0 @offset 0x10 $u32 {\n    6\n    TSEQ_INIT:10 // at 16: Sequence Initiation Time\n    4\n    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)\n  }\n\n//---  Register TIMER1: TIMER1 register\n  TIMER1 @offset 0x14 $u32 {\n    6\n    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal\n    6\n    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled\n  }\n\n//---  Register TIMER2_BC11: TIMER2_BC11 register\n  TIMER2_BC11 @offset 0x18 $u32 {\n    6\n    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup\n    12\n    CHECK_DM:4 // at 0: Time Before Check of D- Line\n  }\n\n//---  Register TIMER2_BC12: TIMER2_BC12 register\n  TIMER2_BC12 @offset 0x18 $u32 {\n    6\n    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection\n    6\n    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral USBPHY: USBPHY Register Reference Index\n//------------------------------------------------------------------------------\n\nregisters USBPHY @at 0x400a2000 {\n//---  Register PWD: USB PHY Power-Down Register\n  PWD @offset 0x0 $u32 {\n    11\n    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    4\n    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    10\n  }\n\n//---  Register PWD_SET: USB PHY Power-Down Register\n  PWD_SET @offset 0x4 $u32 {\n    11\n    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    4\n    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    10\n  }\n\n//---  Register PWD_CLR: USB PHY Power-Down Register\n  PWD_CLR @offset 0x8 $u32 {\n    11\n    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    4\n    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    10\n  }\n\n//---  Register PWD_TOG: USB PHY Power-Down Register\n  PWD_TOG @offset 0xc $u32 {\n    11\n    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    4\n    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled\n    10\n  }\n\n//---  Register TX: USB PHY Transmitter Control Register\n  TX @offset 0x10 $u32 {\n    3\n    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit\n    6\n    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin\n    4\n    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin\n    4\n    D_CAL:4 // at 0: Decode to trim the nominal 17\n  }\n\n//---  Register TX_SET: USB PHY Transmitter Control Register\n  TX_SET @offset 0x14 $u32 {\n    3\n    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit\n    6\n    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin\n    4\n    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin\n    4\n    D_CAL:4 // at 0: Decode to trim the nominal 17\n  }\n\n//---  Register TX_CLR: USB PHY Transmitter Control Register\n  TX_CLR @offset 0x18 $u32 {\n    3\n    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit\n    6\n    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin\n    4\n    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin\n    4\n    D_CAL:4 // at 0: Decode to trim the nominal 17\n  }\n\n//---  Register TX_TOG: USB PHY Transmitter Control Register\n  TX_TOG @offset 0x1c $u32 {\n    3\n    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit\n    6\n    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin\n    4\n    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin\n    4\n    D_CAL:4 // at 0: Decode to trim the nominal 17\n  }\n\n//---  Register RX: USB PHY Receiver Control Register\n  RX @offset 0x20 $u32 {\n    9\n    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver\n    15\n    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.\n    1\n    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector\n  }\n\n//---  Register RX_SET: USB PHY Receiver Control Register\n  RX_SET @offset 0x24 $u32 {\n    9\n    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver\n    15\n    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.\n    1\n    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector\n  }\n\n//---  Register RX_CLR: USB PHY Receiver Control Register\n  RX_CLR @offset 0x28 $u32 {\n    9\n    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver\n    15\n    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.\n    1\n    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector\n  }\n\n//---  Register RX_TOG: USB PHY Receiver Control Register\n  RX_TOG @offset 0x2c $u32 {\n    9\n    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver\n    15\n    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.\n    1\n    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector\n  }\n\n//---  Register CTRL: USB PHY General Control Register\n  CTRL @offset 0x30 $u32 {\n    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers\n    CLKGATE // at 30: Gate UTMI Clocks\n    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state\n    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing\n    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle\n    2\n    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.\n    3\n    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended\n    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended\n    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)\n    2\n    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY\n    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY\n    1\n    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected\n    7\n    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection\n    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode\n    1\n    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector\n    1\n  }\n\n//---  Register CTRL_SET: USB PHY General Control Register\n  CTRL_SET @offset 0x34 $u32 {\n    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers\n    CLKGATE // at 30: Gate UTMI Clocks\n    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state\n    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing\n    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle\n    2\n    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.\n    3\n    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended\n    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended\n    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)\n    2\n    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY\n    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY\n    1\n    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected\n    7\n    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection\n    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode\n    1\n    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector\n    1\n  }\n\n//---  Register CTRL_CLR: USB PHY General Control Register\n  CTRL_CLR @offset 0x38 $u32 {\n    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers\n    CLKGATE // at 30: Gate UTMI Clocks\n    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state\n    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing\n    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle\n    2\n    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.\n    3\n    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended\n    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended\n    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)\n    2\n    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY\n    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY\n    1\n    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected\n    7\n    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection\n    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode\n    1\n    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector\n    1\n  }\n\n//---  Register CTRL_TOG: USB PHY General Control Register\n  CTRL_TOG @offset 0x3c $u32 {\n    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers\n    CLKGATE // at 30: Gate UTMI Clocks\n    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state\n    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing\n    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle\n    2\n    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.\n    3\n    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended\n    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended\n    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)\n    2\n    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY\n    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY\n    1\n    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected\n    7\n    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection\n    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode\n    1\n    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector\n    1\n  }\n\n//---  Register STATUS: USB PHY Status Register\n  STATUS @offset 0x40 $u32 {\n    21\n    RESUME_STATUS // at 10: Indicates that the host is sending a wake-up after Suspend and has triggered an interrupt.\n    1\n    OTGID_STATUS // at 8: Indicates the results of USB_ID pin on the USB cable plugged into the local Micro- or Mini-AB receptacle\n    1\n    DEVPLUGIN_STATUS // at 6: Status indicator for non-standard resistive plugged-in detection\n    2\n    HOSTDISCONDETECT_STATUS // at 3: Indicates at the local host (downstream) port that the remote device has disconnected while in High-Speed mode\n    3\n  }\n\n//---  Register DEBUG: USB PHY Debug Register\n  DEBUG @offset 0x50 $u32 {\n    1\n    CLKGATE // at 30: Gate Test Clocks\n    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.\n    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.\n    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.\n    3\n    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.\n    3\n    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.\n    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive\n    2\n    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode\n    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line\n    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.\n    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value\n  }\n\n//---  Register DEBUG_SET: USB PHY Debug Register\n  DEBUG_SET @offset 0x54 $u32 {\n    1\n    CLKGATE // at 30: Gate Test Clocks\n    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.\n    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.\n    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.\n    3\n    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.\n    3\n    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.\n    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive\n    2\n    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode\n    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line\n    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.\n    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value\n  }\n\n//---  Register DEBUG_CLR: USB PHY Debug Register\n  DEBUG_CLR @offset 0x58 $u32 {\n    1\n    CLKGATE // at 30: Gate Test Clocks\n    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.\n    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.\n    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.\n    3\n    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.\n    3\n    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.\n    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive\n    2\n    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode\n    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line\n    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.\n    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value\n  }\n\n//---  Register DEBUG_TOG: USB PHY Debug Register\n  DEBUG_TOG @offset 0x5c $u32 {\n    1\n    CLKGATE // at 30: Gate Test Clocks\n    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.\n    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.\n    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.\n    3\n    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.\n    3\n    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.\n    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive\n    2\n    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode\n    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line\n    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.\n    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value\n  }\n\n//---  Register DEBUG0_STATUS: UTMI Debug Status Register 0\n  DEBUG0_STATUS @offset 0x60 @ro $u32 {\n    SQUELCH_COUNT:6 // at 26: Running count of the squelch reset instead of normal end for HS RX.\n    UTMI_RXERROR_FAIL_COUNT:10 // at 16: Running count of the UTMI_RXERROR.\n    LOOP_BACK_FAIL_COUNT:16 // at 0: Running count of the failed pseudo-random generator loopback\n  }\n\n//---  Register DEBUG1: UTMI Debug Status Register 1\n  DEBUG1 @offset 0x70 $u32 {\n    17\n    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:\n    13\n  }\n\n//---  Register DEBUG1_SET: UTMI Debug Status Register 1\n  DEBUG1_SET @offset 0x74 $u32 {\n    17\n    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:\n    13\n  }\n\n//---  Register DEBUG1_CLR: UTMI Debug Status Register 1\n  DEBUG1_CLR @offset 0x78 $u32 {\n    17\n    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:\n    13\n  }\n\n//---  Register DEBUG1_TOG: UTMI Debug Status Register 1\n  DEBUG1_TOG @offset 0x7c $u32 {\n    17\n    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:\n    13\n  }\n\n//---  Register VERSION: UTMI RTL Version\n  VERSION @offset 0x80 @ro $u32 {\n    MAJOR:8 // at 24: Fixed read-only value reflecting the MAJOR field of the RTL version.\n    MINOR:8 // at 16: Fixed read-only value reflecting the MINOR field of the RTL version.\n    STEP:16 // at 0: Fixed read-only value reflecting the stepping of the RTL version.\n  }\n\n//---  Register PLL_SIC: USB PHY PLL Control/Status Register\n  PLL_SIC @offset 0xa0 $u32 {\n    PLL_LOCK // at 31: USB PLL lock status indicator\n    14\n    PLL_BYPASS // at 16: Bypass the USB PLL.\n    2\n    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.\n    PLL_POWER // at 12: Power up the USB PLL.\n    PLL_HOLD_RING_OFF // at 11: Analog debug bit\n    4\n    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.\n    4\n    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider\n  }\n\n//---  Register PLL_SIC_SET: USB PHY PLL Control/Status Register\n  PLL_SIC_SET @offset 0xa4 $u32 {\n    PLL_LOCK // at 31: USB PLL lock status indicator\n    14\n    PLL_BYPASS // at 16: Bypass the USB PLL.\n    2\n    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.\n    PLL_POWER // at 12: Power up the USB PLL.\n    PLL_HOLD_RING_OFF // at 11: Analog debug bit\n    4\n    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.\n    4\n    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider\n  }\n\n//---  Register PLL_SIC_CLR: USB PHY PLL Control/Status Register\n  PLL_SIC_CLR @offset 0xa8 $u32 {\n    PLL_LOCK // at 31: USB PLL lock status indicator\n    14\n    PLL_BYPASS // at 16: Bypass the USB PLL.\n    2\n    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.\n    PLL_POWER // at 12: Power up the USB PLL.\n    PLL_HOLD_RING_OFF // at 11: Analog debug bit\n    4\n    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.\n    4\n    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider\n  }\n\n//---  Register PLL_SIC_TOG: USB PHY PLL Control/Status Register\n  PLL_SIC_TOG @offset 0xac $u32 {\n    PLL_LOCK // at 31: USB PLL lock status indicator\n    14\n    PLL_BYPASS // at 16: Bypass the USB PLL.\n    2\n    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.\n    PLL_POWER // at 12: Power up the USB PLL.\n    PLL_HOLD_RING_OFF // at 11: Analog debug bit\n    4\n    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.\n    4\n    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider\n  }\n\n//---  Register USB1_VBUS_DETECT: USB PHY VBUS Detect Control Register\n  USB1_VBUS_DETECT @offset 0xc0 $u32 {\n    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection\n    4\n    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor\n    5\n    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator\n    1\n    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID\n    7\n    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller\n    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid\n    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid\n    SESSEND_OVERRIDE // at 4: Override value for SESSEND\n    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable\n    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator\n  }\n\n//---  Register USB1_VBUS_DETECT_SET: USB PHY VBUS Detect Control Register\n  USB1_VBUS_DETECT_SET @offset 0xc4 $u32 {\n    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection\n    4\n    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor\n    5\n    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator\n    1\n    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID\n    7\n    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller\n    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid\n    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid\n    SESSEND_OVERRIDE // at 4: Override value for SESSEND\n    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable\n    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator\n  }\n\n//---  Register USB1_VBUS_DETECT_CLR: USB PHY VBUS Detect Control Register\n  USB1_VBUS_DETECT_CLR @offset 0xc8 $u32 {\n    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection\n    4\n    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor\n    5\n    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator\n    1\n    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID\n    7\n    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller\n    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid\n    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid\n    SESSEND_OVERRIDE // at 4: Override value for SESSEND\n    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable\n    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator\n  }\n\n//---  Register USB1_VBUS_DETECT_TOG: USB PHY VBUS Detect Control Register\n  USB1_VBUS_DETECT_TOG @offset 0xcc $u32 {\n    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection\n    4\n    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor\n    5\n    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator\n    1\n    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID\n    7\n    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller\n    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller\n    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid\n    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid\n    SESSEND_OVERRIDE // at 4: Override value for SESSEND\n    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable\n    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator\n  }\n\n//---  Register USB1_VBUS_DET_STAT: USB PHY VBUS Detector Status Register\n  USB1_VBUS_DET_STAT @offset 0xd0 @ro $u32 {\n    27\n    VBUS_VALID_3V // at 4: VBUS_VALID_3V detector status\n    VBUS_VALID // at 3: VBUS voltage status\n    AVALID // at 2: A-Device Session Valid status\n    BVALID // at 1: B-Device Session Valid status\n    SESSEND // at 0: Session End indicator\n  }\n\n//---  Register USB1_CHRG_DET_STAT: USB PHY Charger Detect Status Register\n  USB1_CHRG_DET_STAT @offset 0xf0 @ro $u32 {\n    27\n    SECDET_DCP // at 4: Battery Charging Secondary Detection phase output\n    DP_STATE // at 3: Single ended receiver output for the USB_DP pin, from charger detection circuits.\n    DM_STATE // at 2: Single ended receiver output for the USB_DM pin, from charger detection circuits.\n    CHRG_DETECTED // at 1: Battery Charging Primary Detection phase output\n    PLUG_CONTACT // at 0: Battery Charging Data Contact Detection phase output\n  }\n\n//---  Register ANACTRL: USB PHY Analog Control Register\n  ANACTRL @offset 0x100 $u32 {\n    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.\n    15\n    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers\n    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins\n    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency\n    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK\n    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used\n    TESTCLK_SEL // at 0: Test clock selection to analog test\n  }\n\n//---  Register ANACTRL_SET: USB PHY Analog Control Register\n  ANACTRL_SET @offset 0x104 $u32 {\n    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.\n    15\n    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers\n    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins\n    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency\n    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK\n    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used\n    TESTCLK_SEL // at 0: Test clock selection to analog test\n  }\n\n//---  Register ANACTRL_CLR: USB PHY Analog Control Register\n  ANACTRL_CLR @offset 0x108 $u32 {\n    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.\n    15\n    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers\n    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins\n    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency\n    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK\n    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used\n    TESTCLK_SEL // at 0: Test clock selection to analog test\n  }\n\n//---  Register ANACTRL_TOG: USB PHY Analog Control Register\n  ANACTRL_TOG @offset 0x10c $u32 {\n    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.\n    15\n    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers\n    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1\n    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins\n    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency\n    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK\n    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used\n    TESTCLK_SEL // at 0: Test clock selection to analog test\n  }\n\n//---  Register USB1_LOOPBACK: USB PHY Loopback Control/Status Register\n  USB1_LOOPBACK @offset 0x110 $u32 {\n    8\n    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode\n    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed\n    6\n    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test\n    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results\n    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.\n    TSTI_TX_EN // at 5: Enable TX for USB loopback test.\n    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS\n    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing\n    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test\n    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test\n    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.\n  }\n\n//---  Register USB1_LOOPBACK_SET: USB PHY Loopback Control/Status Register\n  USB1_LOOPBACK_SET @offset 0x114 $u32 {\n    8\n    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode\n    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed\n    6\n    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test\n    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results\n    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.\n    TSTI_TX_EN // at 5: Enable TX for USB loopback test.\n    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS\n    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing\n    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test\n    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test\n    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.\n  }\n\n//---  Register USB1_LOOPBACK_CLR: USB PHY Loopback Control/Status Register\n  USB1_LOOPBACK_CLR @offset 0x118 $u32 {\n    8\n    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode\n    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed\n    6\n    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test\n    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results\n    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.\n    TSTI_TX_EN // at 5: Enable TX for USB loopback test.\n    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS\n    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing\n    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test\n    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test\n    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.\n  }\n\n//---  Register USB1_LOOPBACK_TOG: USB PHY Loopback Control/Status Register\n  USB1_LOOPBACK_TOG @offset 0x11c $u32 {\n    8\n    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode\n    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed\n    6\n    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test\n    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results\n    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.\n    TSTI_TX_EN // at 5: Enable TX for USB loopback test.\n    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS\n    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing\n    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test\n    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test\n    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.\n  }\n\n//---  Register USB1_LOOPBACK_HSFSCNT: USB PHY Loopback Packet Number Select Register\n  USB1_LOOPBACK_HSFSCNT @offset 0x120 $u32 {\n    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n  }\n\n//---  Register USB1_LOOPBACK_HSFSCNT_SET: USB PHY Loopback Packet Number Select Register\n  USB1_LOOPBACK_HSFSCNT_SET @offset 0x124 $u32 {\n    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n  }\n\n//---  Register USB1_LOOPBACK_HSFSCNT_CLR: USB PHY Loopback Packet Number Select Register\n  USB1_LOOPBACK_HSFSCNT_CLR @offset 0x128 $u32 {\n    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n  }\n\n//---  Register USB1_LOOPBACK_HSFSCNT_TOG: USB PHY Loopback Packet Number Select Register\n  USB1_LOOPBACK_HSFSCNT_TOG @offset 0x12c $u32 {\n    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.\n  }\n\n//---  Register TRIM_OVERRIDE_EN: USB PHY Trim Override Enable Register\n  TRIM_OVERRIDE_EN @offset 0x130 $u32 {\n    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.\n    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.\n    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.\n    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.\n    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.\n    11\n    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.\n    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.\n    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.\n    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used\n    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.\n  }\n\n//---  Register TRIM_OVERRIDE_EN_SET: USB PHY Trim Override Enable Register\n  TRIM_OVERRIDE_EN_SET @offset 0x134 $u32 {\n    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.\n    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.\n    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.\n    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.\n    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.\n    11\n    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.\n    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.\n    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.\n    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used\n    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.\n  }\n\n//---  Register TRIM_OVERRIDE_EN_CLR: USB PHY Trim Override Enable Register\n  TRIM_OVERRIDE_EN_CLR @offset 0x138 $u32 {\n    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.\n    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.\n    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.\n    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.\n    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.\n    11\n    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.\n    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.\n    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.\n    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used\n    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.\n  }\n\n//---  Register TRIM_OVERRIDE_EN_TOG: USB PHY Trim Override Enable Register\n  TRIM_OVERRIDE_EN_TOG @offset 0x13c $u32 {\n    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.\n    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.\n    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.\n    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.\n    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.\n    11\n    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.\n    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.\n    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.\n    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used\n    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral VREF: Voltage Reference\n//------------------------------------------------------------------------------\n\nregisters VREF @at 0x40074000 {\n//---  Register TRM: VREF Trim Register\n  TRM @offset 0x0 $u8 {\n    1\n    CHOPEN // at 6: Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.\n    TRIM:6 // at 0: Trim bits\n  }\n\n//---  Register SC: VREF Status and Control Register\n  SC @offset 0x1 $u8 {\n    VREFEN // at 7: Internal Voltage Reference enable\n    REGEN // at 6: Regulator enable\n    ICOMPEN // at 5: Second order curvature compensation enable\n    2\n    VREFST // at 2: Internal Voltage Reference stable\n    MODE_LV:2 // at 0: Buffer Mode selection\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Peripheral WDOG: Generation 2008 Watchdog Timer\n//------------------------------------------------------------------------------\n\nregisters WDOG @at 0x40052000 {\n//---  Register STCTRLH: Watchdog Status and Control Register High\n  STCTRLH @offset 0x0 $u16 {\n    1\n    DISTESTWDOG // at 14: Allows the WDOG's functional test mode to be disabled permanently\n    BYTESEL:2 // at 12: This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.\n    TESTSEL // at 11: Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.\n    TESTWDOG // at 10: Puts the watchdog in the functional test mode\n    2\n    WAITEN // at 7: Enables or disables WDOG in Wait mode.\n    STOPEN // at 6: Enables or disables WDOG in Stop mode.\n    DBGEN // at 5: Enables or disables WDOG in Debug mode.\n    ALLOWUPDATE // at 4: Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence\n    WINEN // at 3: Enables Windowing mode.\n    IRQRSTEN // at 2: Used to enable the debug breadcrumbs feature\n    CLKSRC // at 1: Selects clock source for the WDOG timer and other internal timing operations.\n    WDOGEN // at 0: Enables or disables the WDOG's operation\n  }\n\n//---  Register STCTRLL: Watchdog Status and Control Register Low\n  STCTRLL @offset 0x2 $u16 {\n    INTFLG // at 15: Interrupt flag\n    15\n  }\n\n//---  Register TOVALH: Watchdog Time-out Value Register High\n  TOVALH @offset 0x4 $u16 {\n    TOVALHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer\n  }\n\n//---  Register TOVALL: Watchdog Time-out Value Register Low\n  TOVALL @offset 0x6 $u16 {\n    TOVALLOW:16 // at 0: Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer\n  }\n\n//---  Register WINH: Watchdog Window Register High\n  WINH @offset 0x8 $u16 {\n    WINHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog\n  }\n\n//---  Register WINL: Watchdog Window Register Low\n  WINL @offset 0xa $u16 {\n    WINLOW:16 // at 0: Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog\n  }\n\n//---  Register REFRESH: Watchdog Refresh register\n  REFRESH @offset 0xc $u16 {\n    WDOGREFRESH:16 // at 0: Watchdog refresh register\n  }\n\n//---  Register UNLOCK: Watchdog Unlock register\n  UNLOCK @offset 0xe $u16 {\n    WDOGUNLOCK:16 // at 0: Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again\n  }\n\n//---  Register TMROUTH: Watchdog Timer Output Register High\n  TMROUTH @offset 0x10 $u16 {\n    TIMEROUTHIGH:16 // at 0: Shows the value of the upper 16 bits of the watchdog timer.\n  }\n\n//---  Register TMROUTL: Watchdog Timer Output Register Low\n  TMROUTL @offset 0x12 $u16 {\n    TIMEROUTLOW:16 // at 0: Shows the value of the lower 16 bits of the watchdog timer.\n  }\n\n//---  Register RSTCNT: Watchdog Reset Count register\n  RSTCNT @offset 0x14 $u16 {\n    RSTCNT:16 // at 0: Counts the number of times the watchdog resets the system\n  }\n\n//---  Register PRESC: Watchdog Prescaler register\n  PRESC @offset 0x16 $u16 {\n    5\n    PRESCVAL:3 // at 8: 3-bit prescaler for the watchdog clock source\n    8\n  }\n\n}\n\n" ;

const cRegularFileWrapper gWrapperFile_95_targetTemplates (
  "MK66F18-pm.svd.omnibus-import",
  "omnibus-import",
  true, // Text file
  349252, // Text length
  gWrapperFileContent_95_targetTemplates
) ;

//--- File 'teensy-3-6/c-cortex-m4-context.cpp'

const char * gWrapperFileContent_98_targetTemplates = "//\n//   T A S K    R O U T I N E    T Y P E\n//\n\ntypedef void (* RoutineTaskType) (void) ;\n\n//\n//    CORTEX-M4 EXCEPTION FRAME (WITHOUT FLOATING-POINT STORAGE)\n//\n//\n//         PSP+32 -> |                            |\n//                   |----------------------------| \\\n//         PSP+28 -> | xPSR                       |  |\n//                   |----------------------------|  |\n//         PSP+24 -> | PC (after SVC instruction) |  |\n//                   |----------------------------|  |\n//         PSP+20 -> | LR                         |  |\n//                   |----------------------------|  |\n//         PSP+16 -> | R12                        |  |  Saved by interrupt response\n//                   |----------------------------|  |\n//         PSP+12 -> | R3                         |  |\n//                   |----------------------------|  |\n//         PSP+8  -> | R2                         |  |\n//                   |----------------------------|  |\n//         PSP+4  -> | R1                         |  |\n//                   |----------------------------|  |\n//   /---- PSP ----> | R0                         |  |\n//   |               |----------------------------| /\n//   |\n//   |                                        *---------------------*\n//   |                                        | LR return code      | +36 [ 9]\n//   |                                        *---------------------*\n//   \\----------------------------------------| R13 (PSP)           | +32 [ 8]\n//                                            *---------------------*\n//                                            | R11                 | +28 [ 7]\n//                                            *---------------------*\n//                                            | R10                 | +24 [ 6]\n//                                            *---------------------*\n//                                            | R9                  | +20 [ 5]\n//                                            *---------------------*\n//                                            | R8                  | +16 [ 4]\n//                                            *---------------------*\n//                                            | R7                  | +12 [ 3]\n//                                            *---------------------*\n//                                            | R6                  | + 8 [ 2]\n//                                            *---------------------*\n//                                            | R5                  | + 4 [ 1]\n//  *--------------------------------*        *---------------------*\n//  | gRunningTaskContextSaveAddress +------> | R4                  | + 0 [ 0]\n//  *--------------------------------*        *---------------------*\n//\n//\n//    CORTEX-M4 EXCEPTION FRAME (WITH FLOATING-POINT STORAGE)\n//\n//\n//         PSP+104-> |                            |\n//                   |----------------------------| \\\n//         PSP+100-> | <<unused>>                 |  |\n//                   |----------------------------|  |\n//         PSP+96 -> | FPSCR                      |  |\n//                   |----------------------------|  |\n//         PSP+92 -> | S15                        |  |\n//                   |----------------------------|  |\n//         PSP+88 -> | S14                        |  |\n//                   |----------------------------|  |\n//         PSP+84 -> | S13                        |  |\n//                   |----------------------------|  |\n//         PSP+80 -> | S12                        |  |\n//                   |----------------------------|  |\n//         PSP+76 -> | S11                        |  |\n//                   |----------------------------|  |\n//         PSP+72 -> | S10                        |  |\n//                   |----------------------------|  |\n//         PSP+68 -> | S9                         |  |\n//                   |----------------------------|  |\n//         PSP+64 -> | S8                         |  |\n//                   |----------------------------|  |\n//         PSP+60 -> | S7                         |  |\n//                   |----------------------------|  |\n//         PSP+56 -> | S6                         |  |\n//                   |----------------------------|  |\n//         PSP+52 -> | S5                         |  |\n//                   |----------------------------|  |\n//         PSP+48 -> | S4                         |  |\n//                   |----------------------------|  |\n//         PSP+44 -> | S3                         |  |\n//                   |----------------------------|  |\n//         PSP+40 -> | S2                         |  |\n//                   |----------------------------|  |\n//         PSP+36 -> | S1                         |  |\n//                   |----------------------------|  |\n//         PSP+32 -> | S0                         |  |\n//                   |----------------------------|  |\n//         PSP+28 -> | xPSR                       |  |\n//                   |----------------------------|  |\n//         PSP+24 -> | PC (after SVC instruction) |  |\n//                   |----------------------------|  |\n//         PSP+20 -> | LR                         |  |\n//                   |----------------------------|  |\n//         PSP+16 -> | R12                        |  |  Saved by interrupt response\n//                   |----------------------------|  |\n//         PSP+12 -> | R3                         |  |\n//                   |----------------------------|  |\n//         PSP+8  -> | R2                         |  |\n//                   |----------------------------|  |\n//         PSP+4  -> | R1                         |  |\n//                   |----------------------------|  |\n//   /---- PSP ----> | R0                         |  |\n//   |               |----------------------------| /\n//   |\n//   |                                        *---------------------*\n//   |                                        | LR return code      | +36 [ 9]\n//   |                                        *---------------------*\n//   \\----------------------------------------| R13 (PSP)           | +32 [ 8]\n//                                            *---------------------*\n//                                            | R11                 | +28 [ 7]\n//                                            *---------------------*\n//                                            | R10                 | +24 [ 6]\n//                                            *---------------------*\n//                                            | R9                  | +20 [ 5]\n//                                            *---------------------*\n//                                            | R8                  | +16 [ 4]\n//                                            *---------------------*\n//                                            | R7                  | +12 [ 3]\n//                                            *---------------------*\n//                                            | R6                  | + 8 [ 2]\n//                                            *---------------------*\n//                                            | R5                  | + 4 [ 1]\n//  *--------------------------------*        *---------------------*\n//  | gRunningTaskContextSaveAddress +------> | R4                  | + 0 [ 0]\n//  *--------------------------------*        *---------------------*\n//\n//\n\ntypedef struct {\n  unsigned mR0 ;\n  unsigned mR1 ;\n  unsigned mR2 ;\n  unsigned mR3 ;\n  unsigned mR12 ;\n  unsigned mLR ;\n  unsigned mPC ;\n  unsigned mXPSR ;\n} ExceptionFrame_without_floatingPointStorage ;\n\n//\n\ntypedef struct {\n  ExceptionFrame_without_floatingPointStorage mFrame ;\n  unsigned mS [16] ;\n  unsigned mFPSCR ;\n  unsigned mUnused ;\n} ExceptionFrame_with_floatingPointStorage ;\n\n//\n\ntypedef struct {\n  unsigned mR4 ;\n  unsigned mR5 ;\n  unsigned mR6 ;\n  unsigned mR7 ;\n  unsigned mR8 ;\n  unsigned mR9 ;\n  unsigned mR10 ;\n  unsigned mR11 ;\n  ExceptionFrame_without_floatingPointStorage * mPSP ;\n  unsigned mLR_RETURN_CODE ;\n} TaskContext ;\n\n//\n\nstatic inline void kernel_set_task_context (TaskContext & ioTaskContext,\n                                            const unsigned inStackBufferAddress,\n                                            const unsigned inStackBufferSize,\n                                            RoutineTaskType inTaskRoutine,\n                                            const bool inHasFloatingPointContext) __attribute__ ((always_inline)) ;\n\nstatic inline void kernel_set_task_context (TaskContext & ioTaskContext,\n                                            const unsigned inStackBufferAddress,\n                                            const unsigned inStackBufferSize,\n                                            RoutineTaskType inTaskRoutine,\n                                            const bool inHasFloatingPointContext) {\n//--- Initialize LR\n  ioTaskContext.mLR_RETURN_CODE = inHasFloatingPointContext \? 0xFFFFFFED : 0xFFFFFFFD ; // Thread mode, process stack\n//--- Stack Pointer initial value\n  unsigned initialTopOfStack = inStackBufferAddress + inStackBufferSize ;\n  initialTopOfStack -= inHasFloatingPointContext\n    \? sizeof (ExceptionFrame_with_floatingPointStorage)\n    : sizeof (ExceptionFrame_without_floatingPointStorage)\n  ;\n//--- Initialize SP\n  auto * ptr = (ExceptionFrame_without_floatingPointStorage *) initialTopOfStack ;\n  ioTaskContext.mPSP = ptr ;\n//--- Initialize PC\n  ptr->mPC = (unsigned) inTaskRoutine ;\n//--- Initialize CPSR\n  ptr->mXPSR = 1 << 24 ; // Thumb bit\n}\n" ;

const cRegularFileWrapper gWrapperFile_98_targetTemplates (
  "c-cortex-m4-context.cpp",
  "cpp",
  true, // Text file
  10704, // Text length
  gWrapperFileContent_98_targetTemplates
) ;

//--- File 'teensy-3-6/driver-digital-teensy-3-6.omnibus-import'

const char * gWrapperFileContent_96_targetTemplates = "\nctAssert target \"teensy-3-6/xtr32\", \"teensy-3-6/xtr64\"\n\n//\n\nregisters @user PORTA (PCR, GPCLR, GPCHR)\nregisters @user PORTB (PCR, GPCLR, GPCHR)\nregisters @user PORTC (PCR, GPCLR, GPCHR)\nregisters @user PORTD (PCR, GPCLR, GPCHR)\n\nregisters @user GPIOA (PDOR, PSOR, PCOR, PTOR, PDDR)\nregisters @user GPIOB (PDOR, PSOR, PCOR, PTOR, PDDR)\nregisters @user GPIOC (PDOR, PSOR, PCOR, PTOR, PDDR)\nregisters @user GPIOD (PDOR, PSOR, PCOR, PTOR, PDDR)\n\n//\n\nenum $DigitalPort {\n//--- Common with Teensy 3.1 / 3.2\n  case D0  // PTB16\n  case D1  // PTB17\n  case D2  // PTD0\n  case D3  // PTA12\n  case D4  // PTA13\n  case D5  // PTD7\n  case D6  // PTD4\n  case D7  // PTD2\n  case D8  // PTD3\n  case D9  // PTC3\n  case D10 // PTC4\n  case D11 // PTC6\n  case D12 // PTC7\n  case D13 // PTC5\n  case D14 // PTD1\n  case D15 // PTC0\n  case D16 // PTB0\n  case D17 // PTB1\n  case D18 // PTB3\n  case D19 // PTB2\n  case D20 // PTD5\n  case D21 // PTD6\n  case D22 // PTC1\n  case D23 // PTC2\n//--- Only on Teensy 3.6\n  case D24 // PTE26\n  case D25 // PTA5\n  case D26 // PTA14\n  case D27 // PTA15\n  case D28 // PTA16\n  case D29 // PTB18\n  case D30 // PTB19\n  case D31 // PTB10\n  case D32 // PTB11\n  case D33 // PTE24\n  case D34 // PTE25\n  case D35 // PTC8\n  case D36 // PTC9\n  case D37 // PTC10\n  case D38 // PTC11\n  case D39 // PTA17\n  case D40 // PTA28\n  case D41 // PTA29\n  case D42 // PTA26\n  case D43 // PTB20\n  case D44 // PTB22\n  case D45 // PTB23\n  case D46 // PTB21\n  case D47 // PTD8\n  case D48 // PTD9\n  case D49 // PTB4\n  case D50 // PTB5\n  case D51 // PTD14\n  case D52 // PTD13\n  case D53 // PTD12\n  case D54 // PTD15\n  case D55 // PTD11\n  case D56 // PTE10\n  case D57 // PTE11\n}\n\n//\n\nenum $DigitalMode {\n  case output\n  case outputOpenCollector\n  case input\n  case inputPullUp\n}\n\n//\n\ndriver digital ()\n\n//\n\ndriver digital > root {\n\n  //\n  // By default, the 32 PORTA:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_9000 --> 0x4004_907C\n  // This corresponds to AIPS slot 73 (4.5.1)\n  // By default, the 32 PORTB:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_A000 --> 0x4004_A07C\n  // This corresponds to AIPS slot 74 (4.5.1)\n  // By default, the 32 PORTC:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_B000 --> 0x4004_B07C\n  // This corresponds to AIPS slot 75 (4.5.1)\n  // By default, the 32 PORTD:PCR registers are not accessible in user mode\n  // Their adresses : 0x4004_C000 --> 0x4004_C07C\n  // This corresponds to AIPS slot 76 (4.5.1)\n  //\n\n  boot { // See 19.2.2 page 351\n  // Slot 73 is accessible in user mode by resetting bits 27:24 of AIPS0.PACRJ\n  // Slot 74 is accessible in user mode by resetting bits 23:20 of AIPS0.PACRJ\n  // Slot 75 is accessible in user mode by resetting bits 19:16 of AIPS0.PACRJ\n  // Slot 76 is accessible in user mode by resetting bits 15:12 of AIPS0.PACRJ\n  // Simplification: all bits of AIPS0.PACRJ are reseted\n    AIPS0.PACRJ = 0\n  }\n\n  //\n\n  public func set safe @noUnusedWarning (\?mode:mode $DigitalMode\n                                          \?toPort:port $DigitalPort) {\n  //--- Set config and dir to apply\n   var config $u32\n    var dir $u1\n    switch mode {\n    case output :\n      config = {PORTC.PCR !MUX:1}\n      dir = 1\n    case outputOpenCollector :\n      config = {PORTC.PCR !MUX:1 !ODE:1}\n      dir = 1\n    case input :\n      config = {PORTC.PCR !MUX:1}\n      dir = 0\n    case inputPullUp :\n      config = {PORTC.PCR !MUX:1 !PE:1 !PS:1}\n      dir = 0\n    }\n  //---Apply\n    switch port {\n    case D0 : // PTB16\n      PORTB.PCR [16] = config\n      GPIOB.PDDR @bit 16 = dir\n    case D1 : // PTB17\n      PORTB.PCR [17] = config\n      GPIOB.PDDR @bit 17 = dir\n    case D2 : // PTD0\n      PORTD.PCR [0] = config\n      GPIOD.PDDR @bit 0 = dir\n    case D3 : // PTA12\n      PORTA.PCR [12] = config\n      GPIOA.PDDR @bit 12 = dir\n    case D4 : // PTA13\n      PORTA.PCR [13] = config\n      GPIOA.PDDR @bit 13 = dir\n    case D5 : // PTD7\n      PORTD.PCR [7] = config\n      GPIOD.PDDR @bit 7 = dir\n    case D6 : // PTD4\n      PORTD.PCR [4] = config\n      GPIOD.PDDR @bit 4 = dir\n    case D7 : // PTD2\n      PORTD.PCR [2] = config\n      GPIOD.PDDR @bit 2 = dir\n    case D8 : // PTD3\n      PORTD.PCR [3] = config\n      GPIOD.PDDR @bit 3 = dir\n    case D9  : // PTC3\n      PORTC.PCR [3] = config\n      GPIOC.PDDR @bit 3 = dir\n    case D10 : // PTC4\n      PORTC.PCR [4] = config\n      GPIOC.PDDR @bit 4 = dir\n    case D11 : // PTC6\n      PORTC.PCR [6] = config\n      GPIOC.PDDR @bit 6 = dir\n    case D12 : // PTC7\n      PORTC.PCR [7] = config\n      GPIOC.PDDR @bit 7 = dir\n    case D13 : // PTC5\n      PORTC.PCR [5] = config\n      GPIOC.PDDR @bit 5 = dir\n    case D14 : // PTD1\n      PORTD.PCR [1] = config\n      GPIOD.PDDR @bit 1 = dir\n    case D15 : // PTC0\n      PORTC.PCR [0] = config\n      GPIOC.PDDR @bit 0 = dir\n    case D16 : // PTB0\n      PORTB.PCR [0] = config\n      GPIOB.PDDR @bit 0 = dir\n    case D17 : // PTB1\n      PORTB.PCR [1] = config\n      GPIOB.PDDR @bit 1 = dir\n    case D18 : // PTB3\n      PORTB.PCR [3] = config\n      GPIOB.PDDR @bit 3 = dir\n    case D19 : // PTB2\n      PORTB.PCR [2] = config\n      GPIOB.PDDR @bit 2 = dir\n    case D20 : // PTD5\n      PORTD.PCR [5] = config\n      GPIOD.PDDR @bit 5 = dir\n    case D21 : // PTD6\n      PORTD.PCR [6] = config\n      GPIOD.PDDR @bit 6 = dir\n    case D22 : // PTC1\n      PORTC.PCR [1] = config\n      GPIOC.PDDR @bit 1 = dir\n    case D23 : // PTC2\n      PORTC.PCR [2] = config\n      GPIOC.PDDR @bit 2 = dir\n    case D24 : // PTE26\n      PORTE.PCR [26] = config\n      GPIOE.PDDR @bit 26 = dir\n    case D25 : // PTA5\n      PORTA.PCR [5] = config\n      GPIOA.PDDR @bit 5 = dir\n    case D26 : // PTA14\n      PORTA.PCR [14] = config\n      GPIOA.PDDR @bit 14 = dir\n    case D27 : // PTA15\n      PORTA.PCR [15] = config\n      GPIOA.PDDR @bit 15 = dir\n    case D28 : // PTA16\n      PORTA.PCR [16] = config\n      GPIOA.PDDR @bit 16 = dir\n    case D29 : // PTB18\n      PORTB.PCR [18] = config\n      GPIOB.PDDR @bit 18 = dir\n    case D30 : // PTB19\n      PORTB.PCR [19] = config\n      GPIOB.PDDR @bit 19 = dir\n    case D31 : // PTB10\n      PORTB.PCR [10] = config\n      GPIOB.PDDR @bit 10 = dir\n    case D32 : // PTB11\n      PORTB.PCR [11] = config\n      GPIOB.PDDR @bit 11 = dir\n    case D33 : // PTE24\n      PORTE.PCR [24] = config\n      GPIOE.PDDR @bit 24 = dir\n    case D34 : // PTE25\n      PORTE.PCR [25] = config\n      GPIOE.PDDR @bit 25 = dir\n    case D35 : // PTC8\n      PORTC.PCR [8] = config\n      GPIOC.PDDR @bit 8 = dir\n    case D36 : // PTC9\n      PORTC.PCR [9] = config\n      GPIOC.PDDR @bit 9 = dir\n    case D37 : // PTC10\n      PORTC.PCR [10] = config\n      GPIOC.PDDR @bit 10 = dir\n    case D38 : // PTC11\n      PORTC.PCR [11] = config\n      GPIOC.PDDR @bit 11 = dir\n   case D39 : // PTA17\n      PORTA.PCR [17] = config\n      GPIOA.PDDR @bit 17 = dir\n    case D40 : // PTA28\n      PORTA.PCR [28] = config\n      GPIOA.PDDR @bit 28 = dir\n    case D41 : // PTA29\n      PORTA.PCR [29] = config\n      GPIOA.PDDR @bit 29 = dir\n    case D42 : // PTA26\n      PORTA.PCR [26] = config\n      GPIOA.PDDR @bit 26 = dir\n    case D43 : // PTB20\n      PORTB.PCR [20] = config\n      GPIOB.PDDR @bit 20 = dir\n    case D44 : // PTB22\n      PORTB.PCR [22] = config\n      GPIOB.PDDR @bit 22 = dir\n    case D45 : // PTB23\n      PORTB.PCR [23] = config\n      GPIOB.PDDR @bit 23 = dir\n    case D46 : // PTB21\n      PORTB.PCR [21] = config\n      GPIOB.PDDR @bit 21 = dir\n    case D47 : // PTD8\n      PORTD.PCR [8] = config\n      GPIOD.PDDR @bit 8 = dir\n    case D48 : // PTD9\n      PORTD.PCR [9] = config\n      GPIOD.PDDR @bit 9 = dir\n    case D49 : // PTB4\n      PORTB.PCR [4] = config\n      GPIOB.PDDR @bit 4 = dir\n    case D50 : // PTB5\n      PORTB.PCR [5] = config\n      GPIOB.PDDR @bit 5 = dir\n    case D51 : // PTD14\n      PORTD.PCR [14] = config\n      GPIOD.PDDR @bit 14 = dir\n    case D52 : // PTD13\n      PORTD.PCR [13] = config\n      GPIOD.PDDR @bit 13 = dir\n    case D53 : // PTD12\n      PORTD.PCR [12] = config\n      GPIOD.PDDR @bit 12 = dir\n    case D54 : // PTD15\n      PORTD.PCR [15] = config\n      GPIOD.PDDR @bit 15 = dir\n   case D55 : // PTD11\n      PORTD.PCR [11] = config\n      GPIOD.PDDR @bit 11 = dir\n    case D56 : // PTE10\n      PORTE.PCR [10] = config\n      GPIOE.PDDR @bit 10 = dir\n    case D57 : // PTE11\n      PORTE.PCR [11] = config\n      GPIOE.PDDR @bit 11 = dir\n    }\n  }\n\n  //\n\n  public func write safe @noUnusedWarning (\?value $bool\n                                            \?toPort:port $DigitalPort) {\n    switch port {\n    case D0 : // PTB16\n      if value {\n        GPIOB.PSOR = 1 << 16\n      }else{\n        GPIOB.PCOR = 1 << 16\n      }\n    case D1 : // PTB17\n      if value {\n        GPIOB.PSOR = 1 << 17\n      }else{\n        GPIOB.PCOR = 1 << 17\n      }\n    case D2 : // PTD0\n      if value {\n        GPIOD.PSOR = 1 << 0\n      }else{\n        GPIOD.PCOR = 1 << 0\n      }\n    case D3 : // PTA12\n      if value {\n        GPIOA.PSOR = 1 << 12\n      }else{\n        GPIOA.PCOR = 1 << 12\n      }\n    case D4 : // PTA13\n      if value {\n        GPIOA.PSOR = 1 << 13\n      }else{\n        GPIOA.PCOR = 1 << 13\n      }\n    case D5 : // PTD7\n      if value {\n        GPIOD.PSOR = 1 << 7\n      }else{\n        GPIOD.PCOR = 1 << 7\n      }\n    case D6 : // PTD4\n      if value {\n        GPIOD.PSOR = 1 << 4\n      }else{\n        GPIOD.PCOR = 1 << 4\n      }\n    case D7 : // PTD2\n      if value {\n        GPIOD.PSOR = 1 << 2\n      }else{\n        GPIOD.PCOR = 1 << 2\n      }\n    case D8 : // PTD3\n      if value {\n        GPIOD.PSOR = 1 << 3\n      }else{\n        GPIOD.PCOR = 1 << 3\n      }\n    case D9  : // PTC3\n      if value {\n        GPIOC.PSOR = 1 << 3\n      }else{\n        GPIOC.PCOR = 1 << 3\n      }\n    case D10 : // PTC4\n      if value {\n        GPIOC.PSOR = 1 << 4\n      }else{\n        GPIOC.PCOR = 1 << 4\n      }\n    case D11 : // PTC6\n      if value {\n        GPIOC.PSOR = 1 << 6\n      }else{\n        GPIOC.PCOR = 1 << 6\n      }\n    case D12 : // PTC7\n      if value {\n        GPIOC.PSOR = 1 << 7\n      }else{\n        GPIOC.PCOR = 1 << 7\n      }\n    case D13 : // PTC5\n      if value {\n        GPIOC.PSOR = 1 << 5\n      }else{\n        GPIOC.PCOR = 1 << 5\n      }\n    case D14 : // PTD1\n      if value {\n        GPIOD.PSOR = 1 << 1\n      }else{\n        GPIOD.PCOR = 1 << 1\n      }\n    case D15 : // PTC0\n      if value {\n        GPIOC.PSOR = 1 << 0\n      }else{\n        GPIOC.PCOR = 1 << 0\n      }\n    case D16 : // PTB0\n      if value {\n        GPIOB.PSOR = 1 << 0\n      }else{\n        GPIOB.PCOR = 1 << 0\n      }\n    case D17 : // PTB1\n      if value {\n        GPIOB.PSOR = 1 << 1\n      }else{\n        GPIOB.PCOR = 1 << 1\n      }\n    case D18 : // PTB3\n      if value {\n        GPIOB.PSOR = 1 << 3\n      }else{\n        GPIOB.PCOR = 1 << 3\n      }\n    case D19 : // PTB2\n      if value {\n        GPIOB.PSOR = 1 << 2\n      }else{\n        GPIOB.PCOR = 1 << 2\n      }\n    case D20 : // PTD5\n      if value {\n        GPIOD.PSOR = 1 << 5\n      }else{\n        GPIOD.PCOR = 1 << 5\n      }\n    case D21 : // PTD6\n      if value {\n        GPIOD.PSOR = 1 << 6\n      }else{\n        GPIOD.PCOR = 1 << 6\n      }\n    case D22 : // PTC1\n      if value {\n        GPIOC.PSOR = 1 << 1\n      }else{\n        GPIOC.PCOR = 1 << 1\n      }\n    case D23 : // PTC2\n      if value {\n        GPIOC.PSOR = 1 << 2\n      }else{\n        GPIOC.PCOR = 1 << 2\n      }\n    case D24 : // PTE26\n      if value {\n        GPIOE.PSOR = 1 << 26\n      }else{\n        GPIOE.PCOR = 1 << 26\n      }\n    case D25 : // PTA5\n      if value {\n        GPIOA.PSOR = 1 << 5\n      }else{\n        GPIOA.PCOR = 1 << 5\n      }\n    case D26 : // PTA14\n      if value {\n        GPIOA.PSOR = 1 << 14\n      }else{\n        GPIOA.PCOR = 1 << 14\n      }\n    case D27 : // PTA15\n      if value {\n        GPIOA.PSOR = 1 << 15\n      }else{\n        GPIOA.PCOR = 1 << 15\n      }\n    case D28 : // PTA16\n      if value {\n        GPIOA.PSOR = 1 << 16\n      }else{\n        GPIOA.PCOR = 1 << 16\n      }\n    case D29 : // PTB18\n      if value {\n        GPIOB.PSOR = 1 << 18\n      }else{\n        GPIOB.PCOR = 1 << 18\n      }\n    case D30 : // PTB19\n      if value {\n        GPIOB.PSOR = 1 << 19\n      }else{\n        GPIOB.PCOR = 1 << 19\n      }\n    case D31 : // PTB10\n      if value {\n        GPIOB.PSOR = 1 << 10\n      }else{\n        GPIOB.PCOR = 1 << 10\n      }\n    case D32 : // PTB11\n      if value {\n        GPIOB.PSOR = 1 << 11\n      }else{\n        GPIOB.PCOR = 1 << 11\n      }\n    case D33 : // PTE24\n      if value {\n        GPIOE.PSOR = 1 << 24\n      }else{\n        GPIOE.PCOR = 1 << 24\n      }\n    case D34 : // PTE25\n      if value {\n        GPIOE.PSOR = 1 << 25\n      }else{\n        GPIOE.PCOR = 1 << 25\n      }\n    case D35 : // PTC8\n      if value {\n        GPIOC.PSOR = 1 << 8\n      }else{\n        GPIOC.PCOR = 1 << 8\n      }\n    case D36 : // PTC9\n      if value {\n        GPIOC.PSOR = 1 << 9\n      }else{\n        GPIOC.PCOR = 1 << 9\n      }\n    case D37 : // PTC10\n      if value {\n        GPIOC.PSOR = 1 << 10\n      }else{\n        GPIOC.PCOR = 1 << 10\n      }\n    case D38 : // PTC11\n      if value {\n        GPIOC.PSOR = 1 << 11\n      }else{\n        GPIOC.PCOR = 1 << 11\n      }\n    case D39 : // PTA17\n      if value {\n        GPIOA.PSOR = 1 << 17\n      }else{\n        GPIOA.PCOR = 1 << 17\n      }\n    case D40 : // PTA28\n      if value {\n        GPIOA.PSOR = 1 << 28\n      }else{\n        GPIOA.PCOR = 1 << 28\n      }\n    case D41 : // PTA29\n      if value {\n        GPIOA.PSOR = 1 << 29\n      }else{\n        GPIOA.PCOR = 1 << 29\n      }\n    case D42 : // PTA26\n      if value {\n        GPIOA.PSOR = 1 << 26\n      }else{\n        GPIOA.PCOR = 1 << 26\n      }\n    case D43 : // PTB20\n      if value {\n        GPIOB.PSOR = 1 << 20\n      }else{\n        GPIOB.PCOR = 1 << 20\n      }\n    case D44 : // PTB22\n      if value {\n        GPIOB.PSOR = 1 << 22\n      }else{\n        GPIOB.PCOR = 1 << 22\n      }\n    case D45 : // PTB23\n      if value {\n        GPIOB.PSOR = 1 << 23\n      }else{\n        GPIOB.PCOR = 1 << 23\n      }\n    case D46 : // PTB21\n      if value {\n        GPIOB.PSOR = 1 << 21\n      }else{\n        GPIOB.PCOR = 1 << 21\n      }\n    case D47 : // PTD8\n      if value {\n        GPIOD.PSOR = 1 << 8\n      }else{\n        GPIOD.PCOR = 1 << 8\n      }\n    case D48 : // PTD9\n      if value {\n        GPIOD.PSOR = 1 << 9\n      }else{\n        GPIOD.PCOR = 1 << 9\n      }\n    case D49 : // PTB4\n      if value {\n        GPIOB.PSOR = 1 << 4\n      }else{\n        GPIOB.PCOR = 1 << 4\n      }\n    case D50 : // PTB5\n      if value {\n        GPIOB.PSOR = 1 << 5\n      }else{\n        GPIOB.PCOR = 1 << 5\n      }\n    case D51 : // PTD14\n      if value {\n        GPIOD.PSOR = 1 << 14\n      }else{\n        GPIOD.PCOR = 1 << 14\n      }\n    case D52 : // PTD13\n      if value {\n        GPIOD.PSOR = 1 << 13\n      }else{\n        GPIOD.PCOR = 1 << 13\n      }\n    case D53 : // PTD12\n      if value {\n        GPIOD.PSOR = 1 << 12\n      }else{\n        GPIOD.PCOR = 1 << 12\n      }\n    case D54 : // PTD15\n      if value {\n        GPIOD.PSOR = 1 << 15\n      }else{\n        GPIOD.PCOR = 1 << 15\n      }\n    case D55 : // PTD11\n      if value {\n        GPIOD.PSOR = 1 << 11\n      }else{\n        GPIOD.PCOR = 1 << 11\n      }\n    case D56 : // PTE10\n      if value {\n        GPIOE.PSOR = 1 << 10\n      }else{\n        GPIOE.PCOR = 1 << 10\n      }\n    case D57 : // PTE11\n      if value {\n        GPIOE.PSOR = 1 << 11\n      }else{\n        GPIOE.PCOR = 1 << 11\n      }\n    }\n  }\n\n  //\n\n  public func read safe @noUnusedWarning (\?port:port $DigitalPort) -> $bool {\n    switch port {\n    case D0 : // PTB16\n      result = (GPIOB.PDIR & (1 << 16))  0\n    case D1 : // PTB17\n      result = (GPIOB.PDIR & (1 << 17))  0\n    case D2 : // PTD0\n      result = (GPIOD.PDIR & (1 << 0))  0\n    case D3 : // PTA12\n      result = (GPIOA.PDIR & (1 << 12))  0\n    case D4 : // PTA13\n      result = (GPIOA.PDIR & (1 << 13))  0\n    case D5 : // PTD7\n      result = (GPIOD.PDIR & (1 << 7))  0\n    case D6 : // PTD4\n      result = (GPIOD.PDIR & (1 << 4))  0\n    case D7 : // PTD2\n      result = (GPIOD.PDIR & (1 << 2))  0\n    case D8 : // PTD3\n      result = (GPIOD.PDIR & (1 << 3))  0\n    case D9  : // PTC3\n      result = (GPIOC.PDIR & (1 << 3))  0\n    case D10 : // PTC4\n      result = (GPIOC.PDIR & (1 << 4))  0\n    case D11 : // PTC6\n      result = (GPIOC.PDIR & (1 << 6))  0\n    case D12 : // PTC7\n      result = (GPIOC.PDIR & (1 << 7))  0\n    case D13 : // PTC5\n      result = (GPIOC.PDIR & (1 << 5))  0\n    case D14 : // PTD1\n      result = (GPIOD.PDIR & (1 << 1))  0\n    case D15 : // PTC0\n      result = (GPIOC.PDIR & (1 << 0))  0\n    case D16 : // PTB0\n      result = (GPIOB.PDIR & (1 << 0))  0\n    case D17 : // PTB1\n      result = (GPIOB.PDIR & (1 << 1))  0\n    case D18 : // PTB3\n      result = (GPIOB.PDIR & (1 << 3))  0\n    case D19 : // PTB2\n      result = (GPIOB.PDIR & (1 << 2))  0\n    case D20 : // PTD5\n      result = (GPIOD.PDIR & (1 << 5))  0\n    case D21 : // PTD6\n      result = (GPIOD.PDIR & (1 << 6))  0\n    case D22 : // PTC1\n      result = (GPIOC.PDIR & (1 << 1))  0\n    case D23 : // PTC2\n      result = (GPIOC.PDIR & (1 << 2))  0\n    case D24 : // PTE26\n      result = (GPIOE.PDIR & (1 << 26))  0\n    case D25 : // PTA5\n      result = (GPIOA.PDIR & (1 << 5))  0\n    case D26 : // PTA14\n      result = (GPIOA.PDIR & (1 << 14))  0\n    case D27 : // PTA15\n      result = (GPIOA.PDIR & (1 << 15))  0\n    case D28 : // PTA16\n      result = (GPIOA.PDIR & (1 << 16))  0\n    case D29 : // PTB18\n      result = (GPIOB.PDIR & (1 << 18))  0\n    case D30 : // PTB19\n      result = (GPIOB.PDIR & (1 << 19))  0\n    case D31 : // PTB10\n      result = (GPIOB.PDIR & (1 << 10))  0\n    case D32 : // PTB11\n      result = (GPIOB.PDIR & (1 << 11))  0\n    case D33 : // PTE24\n      result = (GPIOE.PDIR & (1 << 24))  0\n    case D34 : // PTE25\n      result = (GPIOE.PDIR & (1 << 25))  0\n    case D35 : // PTC8\n      result = (GPIOC.PDIR & (1 << 8))  0\n    case D36 : // PTC9\n      result = (GPIOC.PDIR & (1 << 9))  0\n    case D37 : // PTC10\n      result = (GPIOC.PDIR & (1 << 10))  0\n    case D38 : // PTC11\n      result = (GPIOC.PDIR & (1 << 11))  0\n    case D39 : // PTA17\n      result = (GPIOA.PDIR & (1 << 17))  0\n    case D40 : // PTA28\n      result = (GPIOA.PDIR & (1 << 28))  0\n    case D41 : // PTA29\n      result = (GPIOA.PDIR & (1 << 29))  0\n    case D42 : // PTA26\n      result = (GPIOA.PDIR & (1 << 26))  0\n    case D43 : // PTB20\n      result = (GPIOB.PDIR & (1 << 20))  0\n    case D44 : // PTB22\n      result = (GPIOB.PDIR & (1 << 22))  0\n    case D45 : // PTB23\n      result = (GPIOB.PDIR & (1 << 23))  0\n    case D46 : // PTB21\n      result = (GPIOB.PDIR & (1 << 21))  0\n    case D47 : // PTD8\n      result = (GPIOD.PDIR & (1 << 8))  0\n    case D48 : // PTD9\n      result = (GPIOD.PDIR & (1 << 9))  0\n    case D49 : // PTB4\n      result = (GPIOB.PDIR & (1 << 4))  0\n    case D50 : // PTB5\n      result = (GPIOB.PDIR & (1 << 5))  0\n    case D51 : // PTD14\n      result = (GPIOD.PDIR & (1 << 14))  0\n    case D52 : // PTD13\n      result = (GPIOD.PDIR & (1 << 13))  0\n    case D53 : // PTD12\n      result = (GPIOD.PDIR & (1 << 12))  0\n    case D54 : // PTD15\n      result = (GPIOD.PDIR & (1 << 15))  0\n    case D55 : // PTD11\n      result = (GPIOD.PDIR & (1 << 11))  0\n    case D56 : // PTE10\n      result = (GPIOE.PDIR & (1 << 10))  0\n    case D57 : // PTE11\n      result = (GPIOE.PDIR & (1 << 11))  0\n    }\n  }\n\n  //\n\n  public func toggle safe @noUnusedWarning (\?port:port $DigitalPort) {\n    switch port {\n    case D0 : // PTB16\n      GPIOB.PTOR = 1 << 16\n    case D1 : // PTB17\n      GPIOB.PTOR = 1 << 17\n    case D2 : // PTD0\n      GPIOD.PTOR = 1 << 0\n    case D3 : // PTA12\n      GPIOA.PTOR = 1 << 12\n    case D4 : // PTA13\n      GPIOA.PTOR = 1 << 13\n    case D5 : // PTD7\n      GPIOD.PTOR = 1 << 7\n    case D6 : // PTD4\n      GPIOD.PTOR = 1 << 4\n    case D7 : // PTD2\n      GPIOD.PTOR = 1 << 2\n    case D8 : // PTD3\n      GPIOD.PTOR = 1 << 3\n    case D9  : // PTC3\n      GPIOC.PTOR = 1 << 3\n    case D10 : // PTC4\n      GPIOC.PTOR = 1 << 4\n    case D11 : // PTC6\n      GPIOC.PTOR = 1 << 6\n    case D12 : // PTC7\n      GPIOC.PTOR = 1 << 7\n    case D13 : // PTC5\n      GPIOC.PTOR = 1 << 5\n    case D14 : // PTD1\n      GPIOD.PTOR = 1 << 1\n    case D15 : // PTC0\n      GPIOC.PTOR = 1 << 0\n    case D16 : // PTB0\n      GPIOB.PTOR = 1 << 0\n    case D17 : // PTB1\n      GPIOB.PTOR = 1 << 1\n    case D18 : // PTB3\n      GPIOB.PTOR = 1 << 3\n    case D19 : // PTB2\n      GPIOB.PTOR = 1 << 2\n    case D20 : // PTD5\n      GPIOD.PTOR = 1 << 5\n    case D21 : // PTD6\n      GPIOD.PTOR = 1 << 6\n    case D22 : // PTC1\n      GPIOC.PTOR = 1 << 1\n    case D23 : // PTC2\n      GPIOC.PTOR = 1 << 2\n    case D24 : // PTE26\n      GPIOE.PTOR = 1 << 26\n    case D25 : // PTA5\n      GPIOA.PTOR = 1 << 5\n    case D26 : // PTA14\n      GPIOA.PTOR = 1 << 14\n    case D27 : // PTA15\n      GPIOA.PTOR = 1 << 15\n    case D28 : // PTA16\n      GPIOA.PTOR = 1 << 16\n    case D29 : // PTB18\n      GPIOB.PTOR = 1 << 18\n    case D30 : // PTB19\n      GPIOB.PTOR = 1 << 19\n    case D31 : // PTB10\n      GPIOB.PTOR = 1 << 10\n    case D32 : // PTB11\n      GPIOB.PTOR = 1 << 11\n    case D33 : // PTE24\n      GPIOE.PTOR = 1 << 24\n    case D34 : // PTE25\n      GPIOE.PTOR = 1 << 25\n    case D35 : // PTC8\n      GPIOC.PTOR = 1 << 8\n    case D36 : // PTC9\n      GPIOC.PTOR = 1 << 9\n    case D37 : // PTC10\n      GPIOC.PTOR = 1 << 10\n    case D38 : // PTC11\n      GPIOC.PTOR = 1 << 11\n    case D39 : // PTA17\n      GPIOA.PTOR = 1 << 17\n    case D40 : // PTA28\n      GPIOA.PTOR = 1 << 28\n    case D41 : // PTA29\n      GPIOA.PTOR = 1 << 29\n    case D42 : // PTA26\n      GPIOA.PTOR = 1 << 26\n    case D43 : // PTB20\n      GPIOB.PTOR = 1 << 20\n    case D44 : // PTB22\n      GPIOB.PTOR = 1 << 22\n    case D45 : // PTB23\n      GPIOB.PTOR = 1 << 23\n    case D46 : // PTB21\n      GPIOB.PTOR = 1 << 21\n    case D47 : // PTD8\n      GPIOD.PTOR = 1 << 8\n    case D48 : // PTD9\n      GPIOD.PTOR = 1 << 9\n    case D49 : // PTB4\n      GPIOB.PTOR = 1 << 4\n    case D50 : // PTB5\n      GPIOB.PTOR = 1 << 5\n    case D51 : // PTD14\n      GPIOD.PTOR = 1 << 14\n    case D52 : // PTD13\n      GPIOD.PTOR = 1 << 13\n    case D53 : // PTD12\n      GPIOD.PTOR = 1 << 12\n    case D54 : // PTD15\n      GPIOD.PTOR = 1 << 15\n    case D55 : // PTD11\n      GPIOD.PTOR = 1 << 11\n    case D56 : // PTE10\n      GPIOE.PTOR = 1 << 10\n    case D57 : // PTE11\n      GPIOE.PTOR = 1 << 11\n    }\n  }\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_96_targetTemplates (
  "driver-digital-teensy-3-6.omnibus-import",
  "omnibus-import",
  true, // Text file
  24013, // Text length
  gWrapperFileContent_96_targetTemplates
) ;

//--- File 'teensy-3-6/driver-root-teensy-3-6.omnibus-import'

const char * gWrapperFileContent_105_targetTemplates = "\nctAssert target \"teensy-3-6/xtr32\", \"teensy-3-6/xtr64\"\n\n//\n// CLOCK SETTINGS\n//\n// The MCGCLOCKOUT frequency is given by (the 16 MHz quartz frequency is divided by 2 for the PPL)\n//  MCGCLOCKOUT = 16 MHz / 2 * (MCG:C6:VDIV + 16) / (MCG:C5:PRDIV + 1)\n//\n//\n// CPU CLOCK\n//\n//  The CPU Clock is given by: MCGCLOCKOUT / (SIM:CLKDIV1:OUTDIV1 + 1)\n//\n//  Here, F_CPU_MHZ is a given constant, so we only check that settings are correct by asserting:\n//     F_CPU_MHZ * (MCG:C5:PRDIV + 1) * (SIM:CLKDIV1:OUTDIV1 + 1) = (16 MHz / 2) * (MCG:C6:VDIV + 16)\n//\n//\n// BUS (peripheral) CLOCK\n//\n//  The peripheral Clock is given by: MCGCLOCKOUT / (SIM:CLKDIV1:OUTDIV2 + 1)\n//\n//  Here, SIM:CLKDIV1:OUTDIV2 is a given constant, so we compute BUS_MHZ by:\n//     BUS_MHZ = (16 MHz / 2) * (MCG:C6:VDIV + 16) / (MCG:C5:PRDIV + 1) / (SIM:CLKDIV1:OUTDIV2 + 1)\n//\n//\n// Flexbus CLOCK\n//\n//  The Flexbus Clock is given by: MCGCLOCKOUT / (SIM:CLKDIV1:OUTDIV3 + 1)\n//\n//  Here, SIM:CLKDIV1:OUTDIV3 is a given constant, so we compute FLEXBUS_MHZ by:\n//     FLEXBUS_MHZ = (16 MHz / 2) * (MCG:C6:VDIV + 16) /(MCG:C5:PRDIV + 1) / (SIM:CLKDIV1:OUTDIV3 + 1)\n//\n//\n// Flash CLOCK\n//\n//  The FLASH Clock is given by: MCGCLOCKOUT / (SIM:CLKDIV1:OUTDIV3 + 1)\n//\n//  Here, SIM:CLKDIV1:OUTDIV4 is a given constant, so we compute Flash Clock in kHz (result may not be integer):\n//     FLASH_KHZ = (16000 kHz / 2) * (MCG:C6:VDIV + 16) / (MCG:C5:PRDIV + 1) / (SIM:CLKDIV1:OUTDIV4 + 1)\n//\n//\n// MICRO CONTROLLER REQUIREMENTS\n//\n// The clock dividers are programmed via the SIM modules CLKDIV registers. Each divider is programmable from a\n// divide-by-1 through divide-by-16 setting. The following requirements must be met when configuring the clocks\n// for this device:\n// 1. The core and system clock frequencies must be 180 MHz or slower in HSRUN, 120 MHz or slower in RUN. \n//\n// 2. The bus clock frequency must be programmed to 60 MHz or less in HSRUN or RUN, and an integer divide of the\n//      core clock. The core clock to bus clock ratio is limited to a max value of 8. \n//\n// 3. The flash clock frequency must be programmed to 28 MHz or less, less than or equal to the bus clock, and an\n//      integer divide of the core clock. The core clock to flash clock ratio is limited to a max value of 8. \n//\n// 4. The FlexBus clock frequency must be programmed to be less than or equal to the bus clock frequency. The\n//      FlexBus also has pad interface restrictions that limits the maximum frequency. For this device the FlexBus\n//      maximum frequency is 60 MHz. The core clock to FlexBus clock ratio is limited to a max value of 8. \n//\n// 5. Since SDRAMC and FlexBus both use CLKOUT, the same restrictions apply to the SDRAM controller as stated\n//      for the FlexBus clock. \n//\n//\n// SETTING SUMMARY\n//\n// F_CPU   MCG_C5   MCG_C6   SIM_CLKDIV1   SIM_CLKDIV1   SIM_CLKDIV1   SIM_CLKDIV1   BUS_MHZ   FLEXBUS    FLASH\n// _MHZ    _PRDIV    _VDIV      _OUTDIV1      _OUTDIV2      _OUTDIV3      _OUTDIV4                _MHZ     _KHZ\n//  240         0       14             0             3             0             7       60        240   30 000\n//  216         0       11             0             1             0             7       54        216   27 000\n//  192         0        8             0             1             0             6       28        192   27 428\n//  180         1       29             0             1             0             6       60        180   25 714\n//  168         0        5             0             2             0             5       56        168   28 000\n//  144         0        2             0             1             0             4       28        144   28 800\n//  120         1       14             0             1             0             4       60        120   24 000\n//   96         1        8             0             1             0             2       24         96   24 000\n//   72         1        2             0             0             0             2       36         72   24 000\n//   48         1        8             1             1             1             3       48         48   24 000\n//   24         1        8             3             3             3             3       24         24   24 000\n//\n// PRDIV SETTINGS\n//\n\nlet MCG_C5_PRDIV =\n  if F_CPU_MHZ == 240 {\n    0\n  }else if F_CPU_MHZ == 216 {\n    0\n  }else if F_CPU_MHZ == 192 {\n    0\n  }else if F_CPU_MHZ == 180 {\n    1\n  }else if F_CPU_MHZ == 168 {\n    0\n  }else if F_CPU_MHZ == 144 {\n    0\n  }else if F_CPU_MHZ == 120 {\n    1\n  }else if F_CPU_MHZ == 96 {\n    1\n  }else if F_CPU_MHZ == 72 {\n    1\n  }else if F_CPU_MHZ == 48 {\n    1\n  }else if F_CPU_MHZ == 24 {\n    1\n  }else{\n    0 // Any value, an error is raised in \"check\" instruction below\n  }\n\n//\n// MCG:C6:VDIV SETTINGS\n//\n\nlet MCG_C6_VDIV =\n  if F_CPU_MHZ == 240 {\n    14\n  }else if F_CPU_MHZ == 216 {\n    11\n  }else if F_CPU_MHZ == 192 {\n    8\n  }else if F_CPU_MHZ == 180 {\n    29\n  }else if F_CPU_MHZ == 168 {\n    5\n  }else if F_CPU_MHZ == 144 {\n    2\n  }else if F_CPU_MHZ == 120 {\n    14\n  }else if F_CPU_MHZ == 96 {\n    8\n  }else if F_CPU_MHZ == 72 {\n    2\n  }else if F_CPU_MHZ == 48 {\n    8\n  }else if F_CPU_MHZ == 24 {\n    8\n  }else{\n    0 // Any value, an error is raised in \"check\" instruction below\n  }\n\n//\n// SIM:CLKDIV1:OUTDIV1 SETTINGS\n//\n\nlet SIM_CLKDIV1_OUTDIV1 =\n  if F_CPU_MHZ == 48 {\n    1\n  }else if F_CPU_MHZ == 24 {\n    3\n  }else{\n    0 // 0 for all other settings\n  }\n\n//\n// SIM:CLKDIV1:OUTDIV2 SETTINGS (divisor for bus)\n//\n\nlet SIM_CLKDIV1_OUTDIV2 =\n  if F_CPU_MHZ == 240 {\n    3\n  }else if F_CPU_MHZ == 216 {\n    3\n  }else if F_CPU_MHZ == 192 {\n    3\n  }else if F_CPU_MHZ == 180 {\n    2\n  }else if F_CPU_MHZ == 168 {\n    2\n  }else if F_CPU_MHZ == 144 {\n    2\n  }else if F_CPU_MHZ == 120 {\n    1\n  }else if F_CPU_MHZ == 96 {\n    1\n  }else if F_CPU_MHZ == 72 {\n    1\n  }else if F_CPU_MHZ == 48 {\n    1\n  }else if F_CPU_MHZ == 24 {\n    3\n  }else{\n    0 // Any value, an error is raised in \"check\" instruction below\n  }\n\n//\n// BUS_MHZ\n//\n\nlet BUS_MHZ = (16 / 2) * (MCG_C6_VDIV + 16) /(MCG_C5_PRDIV + 1) / (SIM_CLKDIV1_OUTDIV2 + 1)\n\n//\n// SIM:CLKDIV1:OUTDIV3 SETTINGS (divisor for Flexbus)\n//\n\nlet SIM_CLKDIV1_OUTDIV3 =\n  if F_CPU_MHZ == 48 {\n    1\n  }else if F_CPU_MHZ == 24 {\n    3\n  }else{\n    0 // Zero for any other CPU frequency\n  }\n\n//\n// FLEXBUS_MHZ\n//\n\nlet FLEXBUS_MHZ = (16 / 2) * (MCG_C6_VDIV + 16) /(MCG_C5_PRDIV + 1) / (SIM_CLKDIV1_OUTDIV3 + 1)\n\n//\n// SIM:CLKDIV1:OUTDIV4 SETTINGS (divisor for Flash)\n//\n\nlet SIM_CLKDIV1_OUTDIV4 =\n  if F_CPU_MHZ == 240 {\n    7\n  }else if F_CPU_MHZ == 216 {\n    7\n  }else if F_CPU_MHZ == 192 {\n    6\n  }else if F_CPU_MHZ == 180 {\n    6\n  }else if F_CPU_MHZ == 168 {\n    5\n  }else if F_CPU_MHZ == 144 {\n    4\n  }else if F_CPU_MHZ == 120 {\n    4\n  }else if F_CPU_MHZ == 96 {\n    3\n  }else if F_CPU_MHZ == 72 {\n    2\n  }else if F_CPU_MHZ == 48 {\n    3\n  }else if F_CPU_MHZ == 24 {\n    3\n  }else{\n    0 // Any value, an error is raised in \"check\" instruction below\n  }\n\n//\n// FLASH CLOCK (in kHz)\n//\n\nlet FLASH_KHZ = (16_000 / 2) * (MCG_C6_VDIV + 16) / (MCG_C5_PRDIV + 1) / (SIM_CLKDIV1_OUTDIV4 + 1)\n\n//\n// USB CLOCK\n//\n// The USB module SHOULD be driven by a 48 MHz clock.\n//\n// For all CPU frequencies (but 216 MHz and 180 MHz), this clock is derived from MCGPLLCLK; the MCGPLLCLK is\n// identical to MCGCLOCKOUT (as SIM_CLKDIV2_PLL_FLL_SEL=1). So:\n//   USB_CLOCK = MCGCLOCKOUT * (SIM_CLKDIV2_USBFRAC + 1) / (SIM_CLKDIV2_USBDIV + 1)\n// We check :\n//   48 MHz == 16 MHz / 2 * (MCG:C6:VDIV + 16) / (MCG:C5:PRDIV + 1) * (SIM_CLKDIV2_USBFRAC + 1) / (SIM_CLKDIV2_USBDIV + 1)\n// So:\n//   6 * (MCG:C5:PRDIV + 1) * (SIM_CLKDIV2_USBDIV + 1) == (MCG:C6:VDIV + 16) * (SIM_CLKDIV2_USBFRAC + 1)\n//\n// For 216 MHz and 180 MHz CPU frequencies, we use directly the built-in 48 MHz clock: SIM_CLKDIV2_PLL_FLL_SEL=3, with\n// di divisor (SIM_CLKDIV2_USBFRAC=0 and SIM_CLKDIV2_USBDIV=0).\n//\n// USB SETTING SUMMARY (for all CPU frequencies, but 216 MHz and 180 MHz)\n//\n// F_CPU   SIM_CLKDIV2   SIM_CLKDIV2   SIM_SOPT2_\n// _MHZ        _USBDIV      _USBFRAC    PLLFLLSEL\n//  240              4             0            1\n//  216              0             0            3\n//  192              3             0            1\n//  180              0             0            3\n//  168              6             1            1\n//  144              2             0            1\n//  120              4             1            1\n//   96              1             0            1\n//   72              2             1            1\n//   48              1             0            1\n//   24              1             0            1\n//\n// SIM:SOPT2:PLLFLLSEL SETTINGS\n//\n\nlet SIM_SOPT2_PLLFLLSEL =\n  if (F_CPU_MHZ == 216) || (F_CPU_MHZ == 180) {\n    3\n  }else{\n    1\n  }\n\n//\n// SIM:CLKDIV2:USBFRAC SETTINGS\n//\n\nlet SIM_CLKDIV2_USBFRAC =\n  if (F_CPU_MHZ == 168) || (F_CPU_MHZ == 120) || (F_CPU_MHZ == 72) {\n    1\n  }else{\n    0\n  }\n\n//\n// SIM:CLKDIV2:USBDIV SETTINGS\n//\n\nlet SIM_CLKDIV2_USBDIV =\n  if F_CPU_MHZ == 240 {\n    4\n  }else if F_CPU_MHZ == 216 {\n    0\n  }else if F_CPU_MHZ == 192 {\n    3\n  }else if F_CPU_MHZ == 180 {\n    0\n  }else if F_CPU_MHZ == 168 {\n    6\n  }else if F_CPU_MHZ == 144 {\n    2\n  }else if F_CPU_MHZ == 120 {\n    4\n  }else if F_CPU_MHZ == 96 {\n    1\n  }else if F_CPU_MHZ == 72 {\n    2\n  }else if F_CPU_MHZ == 48 {\n    1\n  }else if F_CPU_MHZ == 24 {\n    1\n  }else{\n    0 // Any value, an error is raised in \"check\" instruction below\n  }\n\n//\n//  DRIVER ROOT\n//\n\ndriver root {\n  boot {\n  //--------------------------------------------------- Static checks\n    ctAssert \"F_CPU_MHZ valid values: 240, 216, 192, 180, 168, 144, 120, 96, 72, 48 or 24\"\n     (   (F_CPU_MHZ == 240) || (F_CPU_MHZ == 216) || (F_CPU_MHZ == 192) || (F_CPU_MHZ == 180) || (F_CPU_MHZ == 168)\n      || (F_CPU_MHZ == 144) || (F_CPU_MHZ == 120) || (F_CPU_MHZ ==  96) || (F_CPU_MHZ ==  72) || (F_CPU_MHZ ==  48)\n      || (F_CPU_MHZ == 24))\n  //--- Check CPU clock setting is correct\n    ctAssert \"CPU clock setting\" (F_CPU_MHZ * (MCG_C5_PRDIV + 1) * (SIM_CLKDIV1_OUTDIV1 + 1) == (16 / 2) * (MCG_C6_VDIV + 16))\n  //--- (2) The bus clock frequency must be programmed to 60 MHz or less in HSRUN or RUN ...\n    ctAssert \"BUS_MHZ  60\" (BUS_MHZ  60)\n  //---  ... an integer divide of the core clock. ...\n    ctAssert \"bus clock frequency must be an integer divide of the core clock\" (F_CPU_MHZ == (F_CPU_MHZ / BUS_MHZ) * BUS_MHZ)\n  //--- ... The core clock to bus clock ratio is limited to a max value of 8.\n    ctAssert \"core clock to bus clock ratio is limited to a max value of 8\" (F_CPU_MHZ / BUS_MHZ  8)\n  //--- (3) The flash clock frequency must be programmed to 28 MHz or less [No! overclocking --> 30 MHz] ...\n    ctAssert \"flash clock frequency must be programmed to 30 MHz or less\" (FLASH_KHZ  30_000)\n  //--- ... less than or equal to the bus clock, ...\n    ctAssert \"flash clock frequency must be less than or equal to the bus clock\" (FLASH_KHZ  (BUS_MHZ * 1000))\n  //    ... and an integer divide of the core clock. ...\n    ctAssert \"flash clock frequency must be an integer divide of the core clock\" (\n      (SIM_CLKDIV1_OUTDIV4 + 1) == ((SIM_CLKDIV1_OUTDIV4 + 1) / (SIM_CLKDIV1_OUTDIV1 + 1)) * (SIM_CLKDIV1_OUTDIV1 + 1)\n    )\n  //    ... The core clock to flash clock ratio is limited to a max value of 8.\n    ctAssert \"core clock to flash clock ratio is limited to a max value of 8\" (F_CPU_MHZ * 1000 / FLASH_KHZ  8)\n  //--- (4) The FlexBus clock frequency must be programmed to be less than or equal to the bus clock frequency. ...\n//    check \"flexBus clock frequency must be less than or equal to the bus clock\" (FLEXBUS_MHZ  BUS_MHZ)\n  //--- ... For this device the FlexBus maximum frequency is 60 MHz. ...\n//    check \"flexBus maximum frequency is 60 MHz\" (FLEXBUS_MHZ  60)\n  //--- ... The core clock to FlexBus clock ratio is limited to a max value of 8\n    ctAssert \"core clock to FlexBus clock ratio is limited to a max value of 8\" (F_CPU_MHZ / FLEXBUS_MHZ  8)\n  //--- USB Clock\n    ctAssert \"USB Clock is 48 MHz\" (\n     (F_CPU_MHZ == 180) || (F_CPU_MHZ == 216) || // 180 MHz and 216 MHz use directly IRC48MHZ clock\n     (6 * (MCG_C5_PRDIV + 1) * (SIM_CLKDIV2_USBDIV + 1) == (MCG_C6_VDIV + 16) * (SIM_CLKDIV2_USBFRAC + 1))\n    )\n    ctAssert \"USB Clock is 48 MHz (for 180 MHz CPU clock)\" (\n     (F_CPU_MHZ  180) || // 180 MHz uses directly IRC48 clock\n     ((SIM_CLKDIV2_USBDIV == 0) && (SIM_CLKDIV2_USBFRAC == 0))\n    )\n    ctAssert \"USB Clock is 48 MHz (for 216 MHz CPU clock)\" (\n     (F_CPU_MHZ  216) || // 216 MHz uses directly IRC48 clock\n     ((SIM_CLKDIV2_USBDIV == 0) && (SIM_CLKDIV2_USBFRAC == 0))\n    )\n  //--------------------------------------------------- Disable watchdog timer\n  //--- These two instructions are required for unlocking watchdog timer\n    WDOG.UNLOCK = WDOG_UNLOCK_SEQ1\n    WDOG.UNLOCK = WDOG_UNLOCK_SEQ2\n  //--- Disable watchdog timer\n    WDOG.STCTRLH = 0\n    nop ()\n    nop ()\n  //--------------------------------------------------- Enable clocks to always-used peripherals\n    SIM.SCGC3 = {SIM.SCGC3 !ADC1:1 !FTM2:1 !FTM3:1}\n    SIM.SCGC5 = {SIM.SCGC5 !PORTA:1 !PORTB:1 !PORTC:1 !PORTD:1 !PORTE:1}   // clocks active to all GPIO\n    SIM.SCGC6 = {SIM.SCGC6 !RTC:1 !FTM0:1 !FTM1:1 !ADC0:1 !FTF:1}\n  //  SCB.CPACR = 0x00F0_0000; // Enable floating point unit\n    LMEM.PCCCR = {LMEM.PCCCR !GO:1 !INVW1:1 !INVW0:1 !ENWRBUF:1 !ENCACHE:1} // 0x8500_0003\n  //--- If the RTC oscillator isn't enabled, get it started early\n    if RTC.CR.OSCE == 0 {\n      RTC.SR = 0\n      RTC.CR = {RTC.CR !SC16P:1 !SC4P:1 !OSCE:1}\n    }\n  //--- Release I/O pins hold, if we woke up from VLLS mode\n    if PMC.REGSC.ACKISO  0 {\n      PMC.REGSC |= {PMC.REGSC !ACKISO:1}\n    }\n  //--- Since this is a write once register, make it visible to all F_CPU's\n  //    so we can into other sleep modes in the future at any speed\n    SMC.PMPROT = {SMC.PMPROT !AHSRUN:1 !AVLP:1 !ALLS:1 !AVLLS:1}\n\n    SCB.VTOR = 0  // use vector table in flash\n  //---------2- Initialisation de la PLL\n  // start in FEI mode\n  //--- Enable capacitors for crystal\n    OSC.CR = {OSC.CR !SC8P:1 !SC2P:1 !ERCLKEN:1}\n  //--- Enable osc, 8-32 MHz range, low power mode\n    MCG.C2 = {MCG.C2 !RANGE:2 !EREFS:1}\n  //--- Switch to crystal as clock source, FLL input = 16 MHz / 512\n    MCG.C1 = {MCG.C1 !CLKS:2 !FRDIV:4}\n  //--- Wait for crystal oscillator to begin\n    while MCG.S.OSCINIT0 == 0 {}\n  //--- Wait for FLL to use oscillator\n    while MCG.S.IREFST  0 {}\n  //--- Wait for MCGOUT to use oscillator\n    while MCG.S.CLKST  {MCG.S !CLKST:2} {}\n  //--- Now we're in FBE mode\n  //--- If we need faster than crystal, turn on the PLL\n    if @static F_CPU_MHZ > 120 {\n      SMC.PMCTRL = {SMC.PMCTRL !RUNM:3} // enter HSRUN mode\n      let HSRUN $u8 = 0x80\n      while SMC.PMSTAT  HSRUN {}\n    }\n  //--- Configure CPU clock\n    MCG.C5 = {MCG.C5 !PRDIV:MCG_C5_PRDIV}\n    MCG.C6 = {MCG.C6 !PLLS:1 !VDIV:MCG_C6_VDIV}\n  //--- Wait for PLL to start using xtal as its input\n    while MCG.S.PLLST == 0 {}\n  //--- Wait for PLL to lock\n    while MCG.S.LOCK0 == 0 {}\n  //------------------------------------ Now we're in PBE mode : now program the clock dividers\n    SIM.CLKDIV1 = {SIM.CLKDIV1\n      !OUTDIV1:SIM_CLKDIV1_OUTDIV1 // Divisor for Core clock\n      !OUTDIV2:SIM_CLKDIV1_OUTDIV2 // Divisor for Bus clock\n      !OUTDIV3:SIM_CLKDIV1_OUTDIV3 // Divisor for Flexbus clock\n      !OUTDIV4:SIM_CLKDIV1_OUTDIV4 // Divisor for Fash clock\n    }\n    SIM.CLKDIV2 = {SIM.CLKDIV2 !USBDIV:SIM_CLKDIV2_USBDIV !USBFRAC:SIM_CLKDIV2_USBFRAC}\n  //--- Switch to PLL as clock source\n    MCG.C1 = {MCG.C1 !CLKS:0 !FRDIV:4}\n  //--- Wait for PLL clock to be used\n    while MCG.S.CLKST  {MCG.S !CLKST:3} {}\n  //--- USB clock\n    SIM.SOPT2 = {SIM.SOPT2\n      !USBSRC:1\n      !PLLFLLSEL:SIM_SOPT2_PLLFLLSEL\n      !TRACECLKSEL:1\n    }\n  }\n\n}\n\n//\n\ndriver root ()\n\n//\n\n" ;

const cRegularFileWrapper gWrapperFile_105_targetTemplates (
  "driver-root-teensy-3-6.omnibus-import",
  "omnibus-import",
  true, // Text file
  21290, // Text length
  gWrapperFileContent_105_targetTemplates
) ;

//--- File 'teensy-3-6/ld-linker.txt'

const char * gWrapperFileContent_107_targetTemplates = "/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                   Memory                                   */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nMEMORY {\n  flash (rx) : ORIGIN = 0, LENGTH = 1024k \n  sram (rwx) : ORIGIN = 0x1FFF0000, LENGTH = 256k \n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                ISR Vectors                                 */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .vectors : {\n    __vectors_start = . ;\n    KEEP (*(.isr_vector)) ;\n    __vectors_end = . ;\n  } > flash\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                    Code                                    */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .text : {\n    FILL(0xff)\n    __code_start = . ;\n  /*--- Code */\n    . = ALIGN(4);\n    *(.text*) ;\n    *(.text) ;\n    *(text) ;\n    *(.gnu.linkonce.t.*) ;\n  /*---- ROM data ----*/\n    . = ALIGN(4);\n    *(.rodata*);\n    . = ALIGN(4);\n    *(.gnu.linkonce.r.*);\n    . = ALIGN(4);\n    *(.glue_7t);\n    . = ALIGN(4);\n    *(.glue_7);\n    . = ALIGN(4);\n    __code_end = . ;\n  } > flash\n\n  /DISCARD/ : {\n    *(rel.ARM.*);\n    *(.ARM.*);\n    *(.gnu.linkonce.armexidx.*);\n  }\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                          Data (initialized data)                           */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .data : AT (__code_end) {\n    FILL (0xFF)\n    . = ALIGN (4) ;\n    __data_start = . ;\n    * (.data*) ;\n    . = ALIGN (4) ;\n    __data_end = . ;\n  } > sram\n}\n\n\n/*----------------------------------------------------------------------------*/\n\n__data_load_start = LOADADDR (.data) ;\n__data_load_end   = LOADADDR (.data) + SIZEOF (.data) ;\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                          BSS (uninitialized data)                          */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .bss : {\n    . = ALIGN(4);\n    __bss_start = . ;\n    * (.bss*) ;\n    * (COMMON) ;\n    . = ALIGN(4);\n    __bss_end = . ;\n  } > sram\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                System stack                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .system_stack :{\n    . = ALIGN (4) ;\n    __system_stack_start = . ;\n    . += !SYSTEMSTACKSIZE! ;\n    . = ALIGN (4) ;\n    __system_stack_end = . ;\n  } > sram\n}\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                                    Heap                                    */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\nSECTIONS {\n  .heap : {\n    . = ALIGN (4) ;\n    __heap_start = . ;\n  } > sram\n}\n\n/*----------------------------------------------------------------------------*/\n\n__heap_end = ORIGIN(sram) + LENGTH(sram) ;\n\n/*----------------------------------------------------------------------------*/\n" ;

const cRegularFileWrapper gWrapperFile_107_targetTemplates (
  "ld-linker.txt",
  "txt",
  true, // Text file
  4504, // Text length
  gWrapperFileContent_107_targetTemplates
) ;

//--- File 'teensy-3-6/ll-cortex-m4.ll'

const char * gWrapperFileContent_112_targetTemplates = ";--- For LLVM < 9.0.0\n;target datalayout = \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\"\n\n;--- For LLVM >= 9.0.0\ntarget datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\n\n;---\ntarget triple = \"thumbv7em-none--eabi\"\n" ;

const cRegularFileWrapper gWrapperFile_112_targetTemplates (
  "ll-cortex-m4.ll",
  "ll",
  true, // Text file
  236, // Text length
  gWrapperFileContent_112_targetTemplates
) ;

//--- File 'teensy-3-6/py-build.txt'

const char * gWrapperFileContent_111_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nimport sys, os\n\n#----------------------------------------------------------------------------------------------------------------------*\n\nsys.path.append (os.path.dirname (os.path.abspath (sys.argv [0])) + \"/sources\")\nimport omnibus\nimport toolpath\n\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef archiveBaseURL ():\n  return \"http://www.pcmolinaro.name/omnibus-tools/\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM optimizer invocation                                                                                          *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef llvmOptimizerCompiler ():\n  return [toolpath.toolDir () + \"/bin/opt\", \"-Oz\", \"-S\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLC Compiler invocation                                                                                            *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLCcompiler ():\n  return [toolpath.toolDir () + \"/bin/llc\", \"-function-sections\", \"-data-sections\", \"-O2\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM Linker invocation                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLVMLinkercompiler ():\n  return [toolpath.toolDir () + \"/bin/llvm-link\", \"-S\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   CLANG Compiler invocation                                                                                          *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef CLANGcompiler ():\n  result = [toolpath.toolDir () + \"/bin/clang\"]\n  result.append (\"--target=armv7-none--eabi\")\n  result.append (\"-mcpu=cortex-m4\")\n  result.append (\"-Oz\")\n  result.append (\"-fomit-frame-pointer\")\n  result.append (\"-fshort-enums\")\n  result.append (\"-Wall\")\n  result.append (\"-fno-rtti\")\n  result.append (\"-fno-exceptions\")\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   AS assembler invocation                                                                                            *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef asAssembler ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-as\", \"-mthumb\", \"-mcpu=cortex-m4\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Display object size invocation                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef displayObjectSize ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-size\", \"-t\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Object Dump invocation                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef dumpObjectCode ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-objdump\", \"-Sdh\", \"-Mforce-thumb\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker invocation                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linker ():\n  result = [toolpath.toolDir () + \"/bin/arm-eabi-ld\"]\n  result.append (\"-nostartfiles\")\n  result.append (\"--fatal-warnings\")\n  result.append (\"--warn-common\")\n  result.append (\"--no-undefined\")\n  result.append (\"--cref\")\n  result.append (\"-static\")\n  result.append (\"--gc-sections\")\n  result.append (\"--sort-common=descending\")\n  result.append (\"--sort-section=alignment\")\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker scripts                                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerScripts ():\n  result = [\"linker\"] # Linker script is linker.ld\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Linker libraries                                                                                                   *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef linkerLibraries ():\n  result = [\"libgcc-armv7e-m.a\"]\n  return result\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   objcopy invocation                                                                                                 *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef objcopy ():\n  return [toolpath.toolDir () + \"/bin/arm-eabi-objcopy\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   C Source files                                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef CsourceList ():\n  return [\"src.cpp\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   LLVM Source files                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef LLVMsourceList ():\n  return [\"src.ll\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Assembler Source files                                                                                             *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef assemblerSourceList ():\n  return [\"src.s\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Product directory                                                                                                  *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef productDir ():\n  return \"product\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#                         Object files directories                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef objectDir ():\n  return \"objects\"\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   Run executable                                                                                                      *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef runExecutableOnTarget ():\n  return [toolpath.toolDir () + \"/bin/teensy_loader_cli\", \"-w\", \"-v\", \"-mmcu=mk20dx256\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   ARM stack computations utility                                                                                     *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef arm_stack_computations ():\n  return [toolpath.toolDir () + \"/bin/arm-stack-computations\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   check stack utility                                                                                                *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ndef check_stack_utility ():\n  return [\"sources/check-stacks.py\"]\n\n#----------------------------------------------------------------------------------------------------------------------*\n#                                                                                                                      *\n#   MAIN                                                                                                               *\n#                                                                                                                      *\n#----------------------------------------------------------------------------------------------------------------------*\n\ncurrentFile = os.path.abspath (sys.argv [0])\nomnibus.runMakefile (toolpath.toolDir (), archiveBaseURL (), LLVMsourceList (), assemblerSourceList (), objectDir (), \\\n                 LLCcompiler (), llvmOptimizerCompiler (), \\\n                 asAssembler (), productDir (), \\\n                 linker (), linkerScripts (), linkerLibraries (), \\\n                 objcopy (), dumpObjectCode (), displayObjectSize (), runExecutableOnTarget (), \\\n                 CLANGcompiler (), CsourceList (), LLVMLinkercompiler (), \\\n                 currentFile, arm_stack_computations (), check_stack_utility ())\n\n#----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_111_targetTemplates (
  "py-build.txt",
  "txt",
  true, // Text file
  15537, // Text length
  gWrapperFileContent_111_targetTemplates
) ;

//--- File 'teensy-3-6/py-run.txt'

const char * gWrapperFileContent_90_targetTemplates = "#! /usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\n#------------------------------------------------------------------------------*\n# https://docs.python.org/2/library/subprocess.html#module-subprocess\n\nimport subprocess\nimport sys\nimport os\n\n#------------------------------------------------------------------------------*\n\n#--- Get script absolute path\nscriptDir = os.path.dirname (os.path.abspath (sys.argv [0]))\nos.chdir (scriptDir)\n#---\nreturncode = subprocess.call ([\"python\", \"build.py\", \"run\"])\nif returncode != 0 :\n    sys.exit (returncode)\n\n#------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_90_targetTemplates (
  "py-run.txt",
  "txt",
  true, // Text file
  630, // Text length
  gWrapperFileContent_90_targetTemplates
) ;

//--- File 'teensy-3-6/registers-mk66fx1m0-complements.omnibus-import'

const char * gWrapperFileContent_114_targetTemplates = "ctAssert target \"teensy-3-6/xtr32\", \"teensy-3-6/xtr64\"\n\n//\n\nlet WDOG_UNLOCK_SEQ1 $u16 = 0xC520\nlet WDOG_UNLOCK_SEQ2 $u16 = 0xD928\n\n//\n\nlet DMAMUX_SOURCE_TSI      $u6 = 1\nlet DMAMUX_SOURCE_UART0_RX $u6 = 2\nlet DMAMUX_SOURCE_UART0_TX $u6 = 3\nlet DMAMUX_SOURCE_UART1_RX $u6 = 4\nlet DMAMUX_SOURCE_UART1_TX $u6 = 5\nlet DMAMUX_SOURCE_UART2_RX $u6 = 6\nlet DMAMUX_SOURCE_UART2_TX $u6 = 7\nlet DMAMUX_SOURCE_UART3_RX $u6 = 8\nlet DMAMUX_SOURCE_UART3_TX $u6 = 9\nlet DMAMUX_SOURCE_UART4_RXTX $u6 = 10\nlet DMAMUX_SOURCE_I2S0_RX $u6 = 12\nlet DMAMUX_SOURCE_I2S0_TX $u6 = 13\nlet DMAMUX_SOURCE_SPI0_RX $u6 = 14\nlet DMAMUX_SOURCE_SPI0_TX $u6 = 15\nlet DMAMUX_SOURCE_SPI1_RX $u6 = 16\nlet DMAMUX_SOURCE_SPI1_TX $u6 = 17\nlet DMAMUX_SOURCE_I2C0 $u6 = 18\nlet DMAMUX_SOURCE_I2C3 $u6 = 18\nlet DMAMUX_SOURCE_I2C1 $u6 = 19\nlet DMAMUX_SOURCE_I2C2 $u6 = 19\nlet DMAMUX_SOURCE_FTM0_CH0 $u6 = 20\nlet DMAMUX_SOURCE_FTM0_CH1 $u6 = 21\nlet DMAMUX_SOURCE_FTM0_CH2 $u6 = 22\nlet DMAMUX_SOURCE_FTM0_CH3 $u6 = 23\nlet DMAMUX_SOURCE_FTM0_CH4 $u6 = 24\nlet DMAMUX_SOURCE_FTM0_CH5 $u6 = 25\nlet DMAMUX_SOURCE_FTM0_CH6 $u6 = 26\nlet DMAMUX_SOURCE_FTM0_CH7 $u6 = 27\nlet DMAMUX_SOURCE_FTM1_CH0 $u6 = 28\nlet DMAMUX_SOURCE_TPM1_CH0 $u6 = 28\nlet DMAMUX_SOURCE_FTM1_CH1 $u6 = 29\nlet DMAMUX_SOURCE_TPM1_CH1 $u6 = 29\nlet DMAMUX_SOURCE_FTM2_CH0 $u6 = 30\nlet DMAMUX_SOURCE_TPM2_CH0 $u6 = 30\nlet DMAMUX_SOURCE_FTM2_CH1 $u6 = 31\nlet DMAMUX_SOURCE_TPM2_CH1 $u6 = 31\nlet DMAMUX_SOURCE_FTM3_CH0 $u6 = 32\nlet DMAMUX_SOURCE_FTM3_CH1 $u6 = 33\nlet DMAMUX_SOURCE_FTM3_CH2 $u6 = 34\nlet DMAMUX_SOURCE_FTM3_CH3 $u6 = 35\nlet DMAMUX_SOURCE_FTM3_CH4 $u6 = 36\nlet DMAMUX_SOURCE_FTM3_CH5 $u6 = 37\nlet DMAMUX_SOURCE_FTM3_CH6 $u6 = 38\nlet DMAMUX_SOURCE_SPI2_RX $u6 = 38\nlet DMAMUX_SOURCE_FTM3_CH7 $u6 = 39\nlet DMAMUX_SOURCE_SPI2_TX $u6 = 39\nlet DMAMUX_SOURCE_ADC0 $u6 = 40\nlet DMAMUX_SOURCE_ADC1 $u6 = 41\nlet DMAMUX_SOURCE_CMP0 $u6 = 42\nlet DMAMUX_SOURCE_CMP1 $u6 = 43\nlet DMAMUX_SOURCE_CMP2 $u6 = 44\nlet DMAMUX_SOURCE_CMP3 $u6 = 44\nlet DMAMUX_SOURCE_DAC0 $u6 = 45\nlet DMAMUX_SOURCE_DAC1 $u6 = 46\nlet DMAMUX_SOURCE_CMT $u6 = 47\nlet DMAMUX_SOURCE_PDB $u6 = 48\nlet DMAMUX_SOURCE_PORTA $u6 = 49\nlet DMAMUX_SOURCE_PORTB $u6 = 50\nlet DMAMUX_SOURCE_PORTC $u6 = 51\nlet DMAMUX_SOURCE_PORTD $u6 = 52\nlet DMAMUX_SOURCE_PORTE $u6 = 53\nlet DMAMUX_SOURCE_IEEE1588_T0 $u6 = 54\nlet DMAMUX_SOURCE_IEEE1588_T1 $u6 = 55\nlet DMAMUX_SOURCE_FTM1_OV $u6 = 55\nlet DMAMUX_SOURCE_IEEE1588_T2 $u6 = 56\nlet DMAMUX_SOURCE_FTM2_OV $u6 = 56\nlet DMAMUX_SOURCE_IEEE1588_T3 $u6 = 57\nlet DMAMUX_SOURCE_LPUART0_RX $u6 = 58\nlet DMAMUX_SOURCE_LPUART0_TX $u6 = 59\nlet DMAMUX_SOURCE_ALWAYS0 $u6 = 60\nlet DMAMUX_SOURCE_ALWAYS1 $u6 = 61\nlet DMAMUX_SOURCE_ALWAYS2 $u6 = 62\nlet DMAMUX_SOURCE_ALWAYS3 $u6 = 63\n\n//\n\nlet DMA_TCD_ATTR_SIZE_8BIT         $u3 = 0\nlet DMA_TCD_ATTR_SIZE_16BIT        $u3 = 1\nlet DMA_TCD_ATTR_SIZE_32BIT        $u3 = 2\nlet DMA_TCD_ATTR_SIZE_16BYTE_BURST $u3 = 4\nlet DMA_TCD_ATTR_SIZE_32BYTE_BURST $u3 = 5\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_114_targetTemplates (
  "registers-mk66fx1m0-complements.omnibus-import",
  "omnibus-import",
  true, // Text file
  3221, // Text length
  gWrapperFileContent_114_targetTemplates
) ;

//--- File 'teensy-3-6/s-cortex-m4-header.s'

const char * gWrapperFileContent_117_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n\n	.syntax unified\n	.cpu cortex-m4\n	.thumb\n\n" ;

const cRegularFileWrapper gWrapperFile_117_targetTemplates (
  "s-cortex-m4-header.s",
  "s",
  true, // Text file
  164, // Text length
  gWrapperFileContent_117_targetTemplates
) ;

//--- File 'teensy-3-6/s-current-stack-pointer.s'

const char * gWrapperFileContent_116_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Current Stack Pointer\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.current.stack.pointer\", \"ax\", %progbits\n\n  .global \"!FUNC!current.stack.pointer\"\n  .type \"!FUNC!current.stack.pointer\", %function\n\n\"!FUNC!current.stack.pointer\":\n  mov r0, sp\n  bx lr\n\n@----------------------------------------------------------------------------------------------------------------------*\n" ;

const cRegularFileWrapper gWrapperFile_116_targetTemplates (
  "s-current-stack-pointer.s",
  "s",
  true, // Text file
  590, // Text length
  gWrapperFileContent_116_targetTemplates
) ;

//--- File 'teensy-3-6/s-interrupt-handler.s'

const char * gWrapperFileContent_115_targetTemplates = "\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 I N T E R R U P T    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                        *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global \"!ISR!\"\n  .type \"!ISR!\", %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .global \"!HANDLER!\"\n  .type \"!HANDLER!\", %function\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n\"!ISR!\":\n	.fnstart\n@----------------------------------------- Save preserved registers\n	.save	{r4, lr}\n  push  {r4, lr}\n@----------------------------------------- Activity led On\n  bl    func.activityLedOn_28__29_   @ Defined in PLM source (can modify R0-R3 registers)\n@----------------------------------------- R4 <- running task context\n  ldr   r4, =gRunningTaskControlBlockPtr\n  ldr   r4, [r4]\n@----------------------------------------- Call Interrupt handler\n  bl    \"!HANDLER!\"\n@----------------------------------------- Perform the context switch, if needed\n  b     handle.context.switch\n\n	.cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_115_targetTemplates (
  "s-interrupt-handler.s",
  "s",
  true, // Text file
  1568, // Text length
  gWrapperFileContent_115_targetTemplates
) ;

//--- File 'teensy-3-6/s-interrupt-vectors.s'

const char * gWrapperFileContent_93_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@   INTERRUPT VECTOR                                                                                                   *\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	.isr_vector, \"a\", %progbits\n\n  .word __system_stack_end\n@--- ARM Core System Handler Vectors\n  .word as_reset_handler @ 1\n  .word !ISR!NMI @ 2\n  .word as_section_handler @ 3\n  .word !ISR!MemManage @ 4\n  .word !ISR!BusFault @ 5\n  .word !ISR!UsageFault @ 6\n  .word -1 @ 7, reserved\n  .word -1 @ 8, reserved\n  .word -1 @ 9, reserved\n  .word -1 @ 10, reserved\n  .word as_svc_handler @ 11\n  .word !ISR!DebugMonitor @ 12\n  .word -1 @ 13, reserved\n  .word !ISR!PendSV @ 14\n  .word !ISR!systick @ 15\n@--- Non-Core Vectors\n  .word !ISR!DMAChannel0TransferComplete @ 16\n  .word !ISR!DMAChannel1TransferComplete @ 17\n  .word !ISR!DMAChannel2TransferComplete @ 18\n  .word !ISR!DMAChannel3TransferComplete @ 19\n  .word !ISR!DMAChannel4TransferComplete @ 20\n  .word !ISR!DMAChannel5TransferComplete @ 21\n  .word !ISR!DMAChannel6TransferComplete @ 22\n  .word !ISR!DMAChannel7TransferComplete @ 23\n  .word !ISR!DMAChannel8TransferComplete @ 24\n  .word !ISR!DMAChannel9TransferComplete @ 25\n  .word !ISR!DMAChannel10TransferComplete @ 26\n  .word !ISR!DMAChannel11TransferComplete @ 27\n  .word !ISR!DMAChannel12TransferComplete @ 28\n  .word !ISR!DMAChannel13TransferComplete @ 29\n  .word !ISR!DMAChannel14TransferComplete @ 30\n  .word !ISR!DMAChannel15TransferComplete @ 31\n  .word !ISR!DMAError @ 32\n  .word !ISR!MCM @ 33\n  .word !ISR!FlashMemoryCommandComplete @ 34\n  .word !ISR!FlashMemoryReadCollision @ 35\n  .word !ISR!LowVoltage @ 36\n  .word !ISR!LowLeakageWakeup @ 37\n  .word !ISR!WDOG_EWM @ 38\n  .word !ISR!RandomNumberGenerator @ 39\n  .word !ISR!I2C0 @ 40\n  .word !ISR!I2C1 @ 41\n  .word !ISR!SPI0 @ 42\n  .word !ISR!SPI1 @ 43\n  .word !ISR!I2S0Transmit @ 44\n  .word !ISR!I2S0Receive @ 45\n  .word -1 @ 64\n  .word !ISR!UART0Status @ 47\n  .word !ISR!UART0Error @ 48\n  .word !ISR!UART1Status @ 49\n  .word !ISR!UART1Error @ 50\n  .word !ISR!UART2Status @ 51\n  .word !ISR!UART2Error @ 52\n  .word !ISR!UART3Status @ 53\n  .word !ISR!UART3Error @ 54\n  .word !ISR!ADC0 @ 55\n  .word !ISR!CMP0 @ 56\n  .word !ISR!CMP1 @ 57\n  .word !ISR!FTM0 @ 58\n  .word !ISR!FTM1 @ 59\n  .word !ISR!FTM2 @ 60\n  .word !ISR!CMT @ 61\n  .word !ISR!RTCAlarm @ 62\n  .word !ISR!RTCSecond @ 63\n  .word !ISR!PITChannel0 @ 64\n  .word !ISR!PITChannel1 @ 65\n  .word !ISR!PITChannel2 @ 66\n  .word !ISR!PITChannel3 @ 67\n  .word !ISR!PDB @ 68\n  .word !ISR!USBFS_OTG @ 69\n  .word !ISR!USBFSChargerDetect @ 70\n  .word -1 @ 71\n  .word !ISR!DAC0 @ 72\n  .word !ISR!MCG @ 73\n  .word !ISR!lowPowerTimer @ 74\n  .word !ISR!pinDetectPortA @ 75\n  .word !ISR!pinDetectPortB @ 76\n  .word !ISR!pinDetectPortC @ 77\n  .word !ISR!pinDetectPortD @ 78\n  .word !ISR!pinDetectPortE @ 79\n  .word !ISR!softwareInterrupt @ 80\n  .word !ISR!SPI2 @ 81\n  .word !ISR!UART4Status @ 82\n  .word !ISR!UART4Error @ 83\n  .word -1 @ 84\n  .word -1 @ 85\n  .word !ISR!CMP2 @ 86\n  .word !ISR!FTM3 @ 87\n  .word !ISR!DAC1 @ 88\n  .word !ISR!ADC1 @ 89\n  .word !ISR!I2C2 @ 90\n  .word !ISR!CAN0MessageBuffer @ 91\n  .word !ISR!CAN0BusOff @ 92\n  .word !ISR!CAN0Error @ 93\n  .word !ISR!CAN0TransmitWarning @ 94\n  .word !ISR!CAN0ReceiveWarning @ 95\n  .word !ISR!CAN0WakeUp @ 96\n  .word !ISR!SDHC @ 97\n  .word !ISR!EthernetTimer @ 98\n  .word !ISR!EthernetTransmit @ 99\n  .word !ISR!EthernetReceive @ 100\n  .word !ISR!EthernetError @ 101\n  .word !ISR!LPUART0Status @ 102\n  .word !ISR!TSI0 @ 103\n  .word !ISR!TPM1 @ 104\n  .word !ISR!TPM2 @ 105\n  .word !ISR!USB_HS_DCD_PHY @ 106\n  .word !ISR!I2C3 @ 107\n  .word !ISR!CMP3 @ 108\n  .word !ISR!USB_HS_OTG @ 109\n  .word !ISR!CAN1MessageBuffer @ 110\n  .word !ISR!CAN1BusOff @ 111\n  .word !ISR!CAN1Error @ 112\n  .word !ISR!CAN1TransmitWarning @ 113\n  .word !ISR!CAN1ReceiveWarning @ 114\n  .word !ISR!CAN0WakeUp @ 115\n\n  .word                 -1, -1, -1, -1 @ 116 to 119\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 120 to 127\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 128 to 135\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 136 to 143\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 144 to 151\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 152 to 159\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 160 to 167\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 168 to 175\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 176 to 183\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 184 to 191\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 192 to 199\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 200 to 207\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 208 to 215\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 216 to 223\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 224 to 231\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 232 to 239\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 240 to 247\n  .word -1, -1, -1, -1, -1, -1, -1, -1 @ 248 to 255\n@--- Flash magic values\n  .word -1\n  .word -1\n  .word -1\n  .word -2\n\n" ;

const cRegularFileWrapper gWrapperFile_93_targetTemplates (
  "s-interrupt-vectors.s",
  "s",
  true, // Text file
  5029, // Text length
  gWrapperFileContent_93_targetTemplates
) ;

//--- File 'teensy-3-6/s-reset-handler.s'

const char * gWrapperFileContent_102_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 R E S E T    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                                *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n@--- This is stack for background task\n   BACKGROUND.STACK.SIZE = 32\n\n	.section	.bss.background.task.stack, \"aw\", %nobits\n  .align	  3   @ Stack should be aligned on a 8-byte boundary\n\nbackground.task.stack:\n  .space	BACKGROUND.STACK.SIZE\n\n@----------------------------------------------------------------------------------------------------------------------*\n@ See https://developer.arm.com/docs/dui0553/latest/2-the-cortex-m4-processor/21-programmers-model/213-core-registers\n\n	.section	\".text.as_reset_handler\",\"ax\",%progbits\n\n  .global as_reset_handler\n  .type as_reset_handler, %function\n\nas_reset_handler: @ Cortex M4 boots with interrupts enabled, in Thread mode (as PRIMASK is set to 0 at boot)\n@---------------------------------- Run boot, zero bss section, copy data section\n  bl  boot.routines\n@---------------------------------- Enable FPU\n@ The FPU is disabled from reset. You must enable it before you can use any floating-point instructions.\n@--- CPACR is located at address 0xE000ED88\n@  ldr r0, =0xE000ED88\n@--- Read CPACR\n@  ldr r1, [r0]\n@--- Set bits 20-23 to enable CP10 and CP11 coprocessors\n@  orr r1, r1, #(0xF << 20)\n@--- Write back the modified value to the CPACR\n@  str r1, [r0] @ wait for store to complete\n@  dsb\n@--- Reset pipeline now the FPU is enabled\n@  isb\n@---------------------------------- Set PSP : this is stack for background task, it needs 32 bytes for stacking 8 registers\n  ldr   r0,  =background.task.stack + BACKGROUND.STACK.SIZE\n  msr   psp, r0\n@---------------------------------- Set CONTROL register (see B1.4.4)\n@ bit 0 : 0 -> Thread mode has privileged access, 1 -> Thread mode has unprivileged access\n@ bit 1 : 0 -> Use SP_main as the current stack, 1 -> In Thread mode, use SP_process as the current stack\n@ bit 2 : 0 -> FP extension not active, 1 -> FP extension is active\n  movs r2, #3\n  msr  control, r2\n@--- Software must use an ISB barrier instruction to ensure a write to the CONTROL register\n@ takes effect before the next instruction is executed.\n  isb\n@---------------------------------- Start real-time kernel (run service configuration.on.init)\n  svc  #0\n@---------------------------------- Background task : infinite loop\nbackground.task:\n  wfi\n  b  background.task\n\n" ;

const cRegularFileWrapper gWrapperFile_102_targetTemplates (
  "s-reset-handler.s",
  "s",
  true, // Text file
  2839, // Text length
  gWrapperFileContent_102_targetTemplates
) ;

//--- File 'teensy-3-6/s-unused-interrupt.s'

const char * gWrapperFileContent_94_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Undefined interrupt !ISR!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	!ISR! = -1\n\n" ;

const cRegularFileWrapper gWrapperFile_94_targetTemplates (
  "s-unused-interrupt.s",
  "s",
  true, // Text file
  285, // Text length
  gWrapperFileContent_94_targetTemplates
) ;

//--- File 'teensy-3-6/service-dispatcher-entry.s'

const char * gWrapperFileContent_109_targetTemplates = "  .word  \"!ENTRY!\" @ !IDX! + 1\n" ;

const cRegularFileWrapper gWrapperFile_109_targetTemplates (
  "service-dispatcher-entry.s",
  "s",
  true, // Text file
  31, // Text length
  gWrapperFileContent_109_targetTemplates
) ;

//--- File 'teensy-3-6/service-dispatcher-header.s'

const char * gWrapperFileContent_89_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S V C    D I S P A T C H E R    T A B L E                                                            *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .type startup.routines, %function\n\n  .align  2\n\n__svc_dispatcher_table:\n  .word  startup.routines @ 0\n" ;

const cRegularFileWrapper gWrapperFile_89_targetTemplates (
  "service-dispatcher-header.s",
  "s",
  true, // Text file
  710, // Text length
  gWrapperFileContent_89_targetTemplates
) ;

//--- File 'teensy-3-6/service-entry-no-return.s'

const char * gWrapperFileContent_99_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Service !ENTRY!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!ENTRY!\", \"ax\", %progbits\n	.globl	\"!ENTRY!\"\n	.align	2\n	.type	\"!ENTRY!\", %function\n	.code	16\n	.thumb_func\n\n\"!ENTRY!\":\n	.fnstart\n  svc #!IDX! + 1\n  bx  lr\n\n\".Lfunc_end_!ENTRY!\":\n  .size	\"!ENTRY!\", \".Lfunc_end_!ENTRY!\" - \"!ENTRY!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_99_targetTemplates (
  "service-entry-no-return.s",
  "s",
  true, // Text file
  530, // Text length
  gWrapperFileContent_99_targetTemplates
) ;

//--- File 'teensy-3-6/service-entry-return-value.s'

const char * gWrapperFileContent_108_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Service !ENTRY!\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.!ENTRY!\", \"ax\", %progbits\n	.globl	\"!ENTRY!\"\n	.align	2\n	.type	\"!ENTRY!\", %function\n	.thumb_func\n\n\"!ENTRY!\":\n	.fnstart\n  svc #!IDX! + 1\n  b   xtr.user.result\n\n\".Lfunc_end_!ENTRY!\":\n  .size	\"!ENTRY!\", \".Lfunc_end_!ENTRY!\" - \"!ENTRY!\"\n  .cantunwind\n	.fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_108_targetTemplates (
  "service-entry-return-value.s",
  "s",
  true, // Text file
  533, // Text length
  gWrapperFileContent_108_targetTemplates
) ;

//--- File 'teensy-3-6/service-handler.s'

const char * gWrapperFileContent_104_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S V C    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                                    *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@          PSP+32 -> |                            |                                                                    *\n@                    |----------------------------| \\\n@          PSP+28 -> | xPSR                       |  |\n@                    |----------------------------|  |\n@          PSP+24 -> | PC (after SVC instruction) |  |\n@                    |----------------------------|  |\n@          PSP+20 -> | LR                         |  |\n@                    |----------------------------|  |\n@          PSP+16 -> | R12                        |  |  Saved by interrupt response\n@                    |----------------------------|  |\n@          PSP+12 -> | R3                         |  |\n@                    |----------------------------|  |\n@          PSP+8  -> | R2                         |  |\n@                    |----------------------------|  |\n@          PSP+4  -> | R1                         |  |\n@                    |----------------------------|  |\n@     /--- PSP ----> | R0                         |  |\n@     |              |----------------------------| /\n@     |                                                                                                                *\n@     |                                      *---------------------*\n@     |                                      | LR return code      | +36 [ 9]\n@     |                                      *---------------------*\n@     \\------------------------------------- | R13 (PSP)           | +32 [ 8]\n@                                            *---------------------*\n@                                            | R11                 | +28 [ 7]\n@                                            *---------------------*\n@                                            | R10                 | +24 [ 6]\n@                                            *---------------------*\n@                                            | R9                  | +20 [ 5]\n@                                            *---------------------*\n@                                            | R8                  | +16 [ 4]\n@                                            *---------------------*\n@                                            | R7                  | +12 [ 3]\n@                                            *---------------------*\n@                                            | R6                  | + 8 [ 2]\n@                                            *---------------------*\n@                                            | R5                  | + 4 [ 1]\n@  *--------------------------------*        *---------------------*\n@  | gRunningTaskControlBlockPtr    +------> | R4                  | + 0 [ 0]\n@  *--------------------------------*        *---------------------*\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	.bss.background.task.context.ptr, \"aw\", %nobits\n  .align	  2\n\nbackground.task.context.ptr:\n  .space	4\n\n@----------------------------------------------------------------------------------------------------------------------*\n\n	.section	\".text.as_svc_handler\",\"ax\",%progbits\n\n  .global as_svc_handler\n  .type as_svc_handler, %function\n\nas_svc_handler:\n@----------------------------------------- Save preserved registers\n  push  {r4, lr}\n@----------------------------------------- R4 <- thread SP\n  mrs   r4, psp\n@----------------------------------------- Restore R0, R1, R2 and R3 from saved stack\n  ldmia r4!, {r0, r1, r2, r3}       @ R4 incremented by 16\n@----------------------------------------- R4 <- Address of SVC instruction\n  ldr   r4, [r4, #8]    @ 16 + 8 = 24 : 6 stacked registers before saved PC\n@----------------------------------------- R12 <- bits 0-7 of SVC instruction\n  ldrb  r12, [r4, #-2]   @ R12 is service call index\n@----------------------------------------- R4 <- address of dispatcher table\n  ldr   r4, =__svc_dispatcher_table\n@----------------------------------------- R12 <- address of routine to call\n  ldr   r12, [r4, r12, lsl #2]   @ R12 = R4 + (R12 << 2)\n@----------------------------------------- R4 <- calling task context\n  ldr   r4, =gRunningTaskControlBlockPtr\n  ldr   r4, [r4]\n@----------------------------------------- Call service routine\n  blx   r12         @ R4:calling task context address, R5:thread PSP\n@--- Continues in sequence to handle.context.switch\n\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 H A N D L E    C O N T E X T    S W I T C H    ( D O U B L E    S T A C K    M O D E )               *\n@                                                                                                                      *\n@  On entry:                                                                                                           *\n@    - R4 contains the runnning task save context address,                                                             *\n@    - R4 and LR of running task have been pushed on handler task.                                                     *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\nhandle.context.switch:\n@----------------------------------------- Select task to run\n  bl    kernel_selectTaskToRun\n@----------------------------------------- R0 <- calling task context, R1 <- new task context\n  ldr   r1, =gRunningTaskControlBlockPtr\n  mov   r0, r4\n  ldr   r1, [r1]\n@----------------------------------------- Restore preserved registers\n  pop   {r4, lr}\n@----------------------------------------- Task context did change \?\n  cmp   r0, r1  @ R0:old task context, R1:new task context\n  beq   no.context.change\n@----------------------------------------- Save context of preempted task (if any)\n  mrs   r12, psp\n  cbz   r0, store.backround.task.context @ if old context is NULL, save background task context\n@--- Save registers r4 to r11, PSP, LR\n  stmia r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}\n  b     perform.restore.context\nstore.backround.task.context:\n  ldr   r0, =background.task.context.ptr\n  str   r12, [r0]\n@----------------------------------------- Restore context of activated task (if any)\nperform.restore.context:\n  cbz   r1, run.background.task\n  ldmia r1, {r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}\n  msr   psp, r12\n  bx    lr\n@----------------------------------------- No context change\nno.context.change:\n  cbz   r0, run.background.task\n  bx    lr\n@----------------------------------------- Run background task\nrun.background.task:\n@--- Switch off activity led\n  bl   func.activityLedOff_28__29_  @ Defined in PLM source\n@--- Restore PSP of background task\n  ldr  r0, =background.task.context.ptr\n  ldr  r0, [r0]\n  msr  psp, r0\n@--- Return from exception (thread mode, process stack, no floating point)\n  ldr  r1, =0xFFFFFFFD\n  bx   r1\n\n" ;

const cRegularFileWrapper gWrapperFile_104_targetTemplates (
  "service-handler.s",
  "s",
  true, // Text file
  7987, // Text length
  gWrapperFileContent_104_targetTemplates
) ;

//--- File 'teensy-3-6/teensy-3-6-lcd.omnibus-import'

const char * gWrapperFileContent_110_targetTemplates = "\nctAssert target \"teensy-3-6/xtr32\", \"teensy-3-6/xtr64\"\n\n//\n\n// http://esd.cs.ucr.edu/labs/interface/interface.html\n\nlet LCD_BUFFER_SIZE = 20\n\n//\n\ndriver lcd > digital {\n  let DB4 $DigitalPort\n  let DB5 $DigitalPort\n  let DB6 $DigitalPort\n  let DB7 $DigitalPort\n\n  let RS $DigitalPort\n  let ENABLE $DigitalPort\n\n  var buffer = [LCD_BUFFER_SIZE : $u8] (!repeated:0)\n  var sEntree = $Semaphore (!value:0)\n  var sSortie = $Semaphore (!value:LCD_BUFFER_SIZE)\n\n  //\n\n  func configurePorts startup @noUnusedWarning () {\n    digital.set (!mode:.output !toPort:self.DB4)\n    digital.set (!mode:.output !toPort:self.DB5)\n    digital.set (!mode:.output !toPort:self.DB6)\n    digital.set (!mode:.output !toPort:self.DB7)\n    digital.set (!mode:.output !toPort:self.RS)\n    digital.set (!mode:.output !toPort:self.ENABLE)\n  }\n\n  //\n\n  func driveHighE safe @noUnusedWarning () {\n    digital.write (!yes !toPort:self.ENABLE)\n  }\n\n  //\n\n  func driveLowE safe @noUnusedWarning () {\n    digital.write (!no !toPort:self.ENABLE)\n  }\n\n  //\n\n\n  func driveHighRS safe @noUnusedWarning () {\n   digital.write (!yes !toPort:self.RS)\n  }\n\n  //\n\n  func driveLowRS safe @noUnusedWarning () {\n    digital.write (!no !toPort:self.RS)\n  }\n\n  //\n\n  func setD4 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB4)\n  }\n\n  //\n\n  func setD5 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB5)\n  }\n\n  //\n\n  func setD6 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB6)\n  }\n\n  //\n\n  func setD7 safe @noUnusedWarning (\?inValue $bool) {\n    digital.write (!inValue !toPort:self.DB7)\n  }\n\n  //\n  //   UTILITY ROUTINES\n  //\n\n  func programLcd4BitDataBusOutput safe @noUnusedWarning (\?inValue $u8) {\n    self.setD4 (!(inValue & 0x01)  0)\n    self.setD5 (!(inValue & 0x02)  0)\n    self.setD6 (!(inValue & 0x04)  0)\n    self.setD7 (!(inValue & 0x08)  0)\n  }\n\n  //\n\n  func writeFirstNibbleOf8bitCommand safe @noUnusedWarning (\?inValue $u8) {\n    self.driveLowRS ()\n    self.programLcd4BitDataBusOutput (!inValue)\n    self.driveHighE ()\n  }\n\n  //\n\n  func writeFirstNibbleOf8bitData safe @noUnusedWarning (\?inValue $u8) {\n    self.driveHighRS ()\n    self.programLcd4BitDataBusOutput (!inValue)\n    self.driveHighE ()\n  }\n\n   //\n\n  func writeSecondNibble safe @noUnusedWarning (\?inValue $u8) {\n    self.programLcd4BitDataBusOutput (!inValue)\n    self.driveHighE ()\n  }\n\n  //\n\n  func write4BitCommand startup @noUnusedWarning (\?inValue $u8) {\n    time.busyWaitingDuringMS (!1)\n    self.writeFirstNibbleOf8bitCommand (!inValue)\n    time.busyWaitingDuringMS (!1)\n    self.driveLowE ()\n  }\n\n  //\n\n  func write8bitCommand startup @noUnusedWarning (\?inCommand $u8) {\n    time.busyWaitingDuringMS (!1)\n    self.writeFirstNibbleOf8bitCommand (!inCommand >> 4)\n    time.busyWaitingDuringMS (!1)\n    self.driveLowE ()\n    time.busyWaitingDuringMS (!1)\n    self.writeSecondNibble (!inCommand)\n    time.busyWaitingDuringMS (!1)\n    self.driveLowE ()\n  }\n\n  //\n  //   LCD INIT\n  //\n\n  startup {\n    self.configurePorts ()\n  //--- tape 1 : attendre 15 ms\n    time.busyWaitingDuringMS (!15)\n  //--- tape 2 : crire la commande 0x30\n    self.write4BitCommand (!0x3)\n  //--- tape 3 : attendre 4,1 ms (en fait 5 ms)\n    time.busyWaitingDuringMS (!5)\n  //--- tape 4 : crire la commande 0x30 une 2e fois\n    self.write4BitCommand (!0x3)\n  //--- tape 5 : attendre 100 s\n    time.busyWaitingDuringMS (!1)\n  //--- tape 6 : crire la commande 0x30 une 3e fois\n    self.write4BitCommand (!0x3)\n  //--- tape 7 : crire la commande 0x20 pour passer en 4 bits\n    self.write4BitCommand (!0x2)\n  //--- tape 8 : crire la commande 'Set $interface Length' : 0 0 1 DL N F * *\n  //    DL : Data interface length : 0 (4 bits)\n  //    N : Number of Display lines : 1 (2 lignes)\n  //    F : Character Font : 0 (5x7)\n    self.write8bitCommand (!0x28)\n  //--- tape 9 : crire la commande 'Display Off'\n    self.write8bitCommand (!0x08)\n  //--- tape 10 : crire la commande 'Clear Display'\n    self.write8bitCommand (!0x01)\n  //--- tape 11 : crire la commande 'Set Cursor Move Direction' : 0 0 0 0 0 1 ID S\n  //    ID : Increment Cursor after Each Byte Written to Display : 1 (oui)\n  //    S : Shift Display When Byte Written : 0 (non)\n    self.write8bitCommand (!0x06)\n  //--- tape 12 : crire la commande 'Move Cursor / Shift Display' : 0 0 0 1 SC RL * *\n  //    SC : Display Shift On : 1 (oui)\n  //    RL : Direction of Shift : 1 (vers la droite)\n    self.write8bitCommand (!0x1C)\n  //--- tape 13 : crire la commande 'Return Cursor and LCD to Home Position'\n    self.write8bitCommand (!0x02)\n  //--- tape 14 : crire la commande 'Enable Display / Cursor' : 0 0 0 0 1 D C B\n  //    D : Turn Display On : 1 (oui)\n  //    C : Turn Cursor On : 0 (non)\n  //    B : Cursor Blink On : 0 (non)\n    self.write8bitCommand (!0x0C)\n  }\n\n  //\n  //   PRINT ROUTINES IN USER MODE\n  //\n\n  func write8bitCommand_inUserMode user @noUnusedWarning (\?inCommand $u8) {\n    time.wait (!during:1)\n    self.writeFirstNibbleOf8bitCommand (!inCommand >> 4)\n    time.wait (!during:1)\n    self.driveLowE ()\n    time.wait (!during:1)\n    self.writeSecondNibble (!inCommand)\n    time.wait (!during:1)\n    self.driveLowE ()\n  }\n\n  //\n\n  func writeData_inUserMode user @noUnusedWarning (\?inData $u8) {\n    time.wait (!during:1)\n    self.writeFirstNibbleOf8bitData (!inData >> 4)\n    time.wait (!during:1)\n    self.driveLowE ()\n    time.wait (!during:1)\n    self.writeSecondNibble (!inData)\n    time.wait (!during:1)\n    self.driveLowE ()\n  }\n\n  //\n\n  public func clearScreen user @noUnusedWarning () {\n    self.write8bitCommand_inUserMode (!0x01)\n  }\n\n  //\n\n  // Line 0 : 00 -> 19\n  // Line 1 : 64 -> 83\n  // Line 2 : 20 -> 39\n  // Line 3 : 84 -> 103\n\n  public func goto user @noUnusedWarning (\?line:inLine $u2 \?column:inColumn $u8) {\n    if inColumn < 20 {\n      if inLine == 0 {\n        self.write8bitCommand_inUserMode (!0x80 + 0 + inColumn)\n      }else if inLine == 1 {\n        self.write8bitCommand_inUserMode (!0x80 + 64 + inColumn)\n      }else if inLine == 2 {\n        self.write8bitCommand_inUserMode (!0x80 + 20 + inColumn)\n      }else{\n        self.write8bitCommand_inUserMode (!0x80 + 84 + inColumn)\n      }\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?spaces:inCount $u32) {\n    var count = inCount\n    while (count > 0) {\n      self.writeData_inUserMode (!0x20)\n      count -= 1\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?u32:inValue $u32) {\n    var divisor $u32 = 1_000_000_000\n    var value = inValue\n    var isPrinting = no\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value / divisor\n        let remainder = value - quotient * divisor\n        self.writeData_inUserMode (!convert (quotient) + 0x30)\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor / 10\n    }\n    if not isPrinting {\n      self.writeData_inUserMode (!0x30)\n    }\n  }\n\n  public func print user @noUnusedWarning (\?u32:inValue $u32 \?width: inWidth $u32) {\n    var divisor $u32 = 1_000_000_000\n    var value = inValue\n    var isPrinting = no\n    var count $u32 = 0\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value / divisor\n        let remainder = value - quotient * divisor\n        self.writeData_inUserMode (!convert (quotient) + 0x30)\n        count += 1\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor / 10\n    }\n    if not isPrinting {\n      self.writeData_inUserMode (!0x30)\n      count += 1\n    }\n    for _ $u32 in count ..< inWidth {\n      self.writeData_inUserMode (!0x20)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?u64:inValue $u64) {\n    var divisor $u64 = 1_0000__00000__00000__00000\n    var value = inValue\n    var isPrinting = no\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value / divisor\n        let remainder = value - quotient * divisor\n        self.writeData_inUserMode (!convert (quotient) + 0x30)\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor / 10\n    }\n    if not isPrinting {\n      self.writeData_inUserMode (!0x30)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?string:inValue $literalString) {\n    for c in inValue {\n      self.writeData_inUserMode (!c)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex1:inValue $u32) {\n    let v = truncate $u8 (inValue & 0xF)\n    if v < 10 {\n      self.writeData_inUserMode (!v + 0x30)\n    }else{\n      self.writeData_inUserMode (!v + 0x41 - 10)\n    }\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex2:inValue $u32) {\n    self.print (!hex1:inValue >> 4)\n    self.print (!hex1:inValue)\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex4:inValue $u32) {\n    self.print (!hex2:inValue >> 8)\n    self.print (!hex2:inValue)\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex8:inValue $u32) {\n    self.print (!hex4:inValue >> 16)\n    self.print (!hex4:inValue)\n  }\n\n  //\n\n  public func print user @noUnusedWarning (\?hex16:inValue $u64) {\n    self.print (!hex8:truncate (inValue >> 32))\n    self.print (!hex8:truncate (inValue))\n  }\n\n  //\n  //   PANIC\n  //\n\n  func writeDataInPanicMode panic @noUnusedWarning (\?inData $u8) {\n    time.panicOneMillisecondBusyWait ()\n    self.driveHighRS ()\n    self.programLcd4BitDataBusOutput (!inData >> 4)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n    time.panicOneMillisecondBusyWait ()\n    self.programLcd4BitDataBusOutput (!inData)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n  }\n\n  //\n\n  public func printUnsignedInPanicMode panic @noUnusedWarning (\?inValue $u32) {\n    time.panicOneMillisecondBusyWait ()\n    var divisor $u32 = 1_000_000_000\n    var value = inValue\n    var isPrinting = no\n    while divisor > 0 {\n      if isPrinting || (value  divisor) {\n        let quotient = value !/ divisor\n        let remainder = value -% quotient *% divisor\n        self.writeDataInPanicMode (!truncate (quotient) +% 0x30)\n        value = remainder\n        isPrinting = yes\n      }\n      divisor = divisor !/ 10\n    }\n    if not isPrinting {\n      self.writeDataInPanicMode (!0x30)\n    }\n  }\n\n  //\n\n  public func printSignedInPanicMode panic @noUnusedWarning (\?inValue $i32) {\n    time.panicOneMillisecondBusyWait ()\n    if inValue  0 {\n      self.printUnsignedInPanicMode (!truncate (inValue))\n    }else{\n      self.writeDataInPanicMode (!0x2D) // Signe -\n      self.printUnsignedInPanicMode (!truncate (-% inValue))\n    }\n  }\n\n  //\n\n  func write8bitCommandInPanicMode panic @noUnusedWarning (\?inCommand $u8) {\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowRS ()\n    self.programLcd4BitDataBusOutput (!inCommand >> 4)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n    time.panicOneMillisecondBusyWait ()\n    self.programLcd4BitDataBusOutput (!inCommand)\n    self.driveHighE ()\n    time.panicOneMillisecondBusyWait ()\n    self.driveLowE ()\n  }\n\n  //\n\n  public func gotoInPanicMode panic @noUnusedWarning (\?line:inLine $u32 \?column:inColumn $u8) {\n   time.panicOneMillisecondBusyWait ()\n   if inColumn < 20 {\n      if inLine == 0 {\n        self.write8bitCommandInPanicMode (!0x80 +% 0 +% inColumn)\n      }else if inLine == 1 {\n        self.write8bitCommandInPanicMode (!0x80 +% 64 +% inColumn)\n      }else if inLine == 2 {\n        self.write8bitCommandInPanicMode (!0x80 +% 20 +% inColumn)\n      }else if inLine == 3 {\n        self.write8bitCommandInPanicMode (!0x80 +% 84 +% inColumn)\n      }\n    }\n  }\n\n  //\n\n  public func clearScreenInPanicMode panic @noUnusedWarning () {\n    time.panicOneMillisecondBusyWait ()\n    self.write8bitCommandInPanicMode (!0x01)\n    time.panicBusyWaitingDuringMS (!4)\n  }\n\n  //\n\n  public func printStringInPanicMode panic @noUnusedWarning (\?inString $literalString) {\n    time.panicOneMillisecondBusyWait ()\n    for c in inString {\n      self.writeDataInPanicMode (!c)\n    }\n  }\n\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_110_targetTemplates (
  "teensy-3-6-lcd.omnibus-import",
  "omnibus-import",
  true, // Text file
  17072, // Text length
  gWrapperFileContent_110_targetTemplates
) ;

//--- File 'teensy-3-6/teensy-3-6-nvic-interrupts.omnibus-import'

const char * gWrapperFileContent_101_targetTemplates = "\nctAssert target \"teensy-3-6/xtr32\", \"teensy-3-6/xtr64\"\n\n//\n\nsection enable safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot) {\n  let idx $u32 = extend (inInterruptCode.u7 -% 16)\n  let bitIndex = idx & 0x1F\n  let registerIndex = idx >> 5\n  NVIC.ISER [registerIndex]! = 1 << bitIndex\n}\n\n//\n\nsection disable safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot) {\n  let idx $u32 = extend (inInterruptCode.u7 -% 16)\n  let bitIndex = idx & 0x1F\n  let registerIndex = idx >> 5\n  NVIC.ICER [registerIndex]! = 1 << bitIndex\n}\n\n//\n\n// 0 = highest priority\n// Cortex-M4: 0,16,32,48,64,80,96,112,128,144,160,176,192,208,224,240\nsection set safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot \?priority:inPriority $u8) {\n  NVIC.IPR [inInterruptCode.u7]! = inPriority\n}\n\n//\n\nsection getPriorityOf safe @noUnusedWarning (\?interrupt: inInterruptCode $ISRSlot) -> $u8 {\n  result = NVIC.IPR [inInterruptCode.u7]!\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_101_targetTemplates (
  "teensy-3-6-nvic-interrupts.omnibus-import",
  "omnibus-import",
  true, // Text file
  1523, // Text length
  gWrapperFileContent_101_targetTemplates
) ;

//--- File 'teensy-3-6/teensy-3-6-time.omnibus-import'

const char * gWrapperFileContent_106_targetTemplates = "\nctAssert target \"teensy-3-6/xtr32\", \"teensy-3-6/xtr64\"\n\n//\n\ndriver time ()\n\n//\n//   TIME (for Cortex M4)\n//\n\ndriver time > root {\n  var mUptime $u32 = 0\n\n  //\n\n  startup { // Configure Systick interrupt every ms\n    SYST.RVR = F_CPU_MHZ * 1000 - 1 // $interrupt every ms\n    SYST.CVR = 0\n    SYST.CSR = {SYST.CSR !CLKSOURCE:1 !ENABLE:1 !TICKINT:1}\n  }\n\n  //\n  //   Functions callable in startup mode\n  //\n\n  public func oneMillisecondBusyWait startup @noUnusedWarning () {\n    while SYST.CSR.COUNTFLAG == 0 {}\n  }\n\n  //\n\n  public func busyWaitingDuringMS startup @noUnusedWarning (\?inDelay $u32) {\n    for _ $u32 in 0 ..< inDelay {\n      self.oneMillisecondBusyWait ()\n    }\n  }\n\n  //\n  //   Functions callable in panic mode\n  //\n\n  public func panicOneMillisecondBusyWait panic @noUnusedWarning () {\n    while SYST.CSR.COUNTFLAG == 0 {}\n  }\n\n  //\n\n  public func panicBusyWaitingDuringMS panic @noUnusedWarning (\?inDelay $u32) {\n    for _ $u32 in 0 ..< inDelay {\n      self.panicOneMillisecondBusyWait ()\n    }\n  }\n\n  //\n  //   systick interrupt service routine\n  //\n\n  interrupt service systick {\n //   noteCurrentTaskFreeStackSize ()\n    let now = self.mUptime +% 1\n    self.mUptime = now\n    makeTasksReady (!fromCurrentDate:now)\n    notifyChangeForGuardedWaitUntil (!withCurrentDate:now)\n  }\n\n  //\n  //   Primitives callable in user mode\n  //\n\n  public primitive wait @noUnusedWarning (\?until: inDate $u32) {\n    if inDate > self.mUptime {\n      block (!onDeadline:inDate)\n    }\n  }\n\n  //\n\n  public primitive wait @noUnusedWarning (\?during: inDelay $u32) {\n    if inDelay > 0 {\n      block (!onDeadline:self.mUptime +% inDelay)\n    }\n  }\n\n  //\n\n  public guard wait @noUnusedWarning (\?until:inDeadline $u32) {\n//    noteCurrentTaskFreeStackSize ()\n    accept = inDeadline  self.mUptime\n    if not accept {\n      handle (!guardedDeadline:inDeadline)\n    }\n  }\n\n  //\n  //   Primitives callable in user mode\n  //\n\n  public section now safe @noUnusedWarning () -> $u32 {\n    result = self.mUptime\n  }\n\n  //\n\n}\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_106_targetTemplates (
  "teensy-3-6-time.omnibus-import",
  "omnibus-import",
  true, // Text file
  4349, // Text length
  gWrapperFileContent_106_targetTemplates
) ;

//--- File 'teensy-3-6/teensy-3-6-xtr32.omnibus-import'

const char * gWrapperFileContent_113_targetTemplates = "\nctAssert target \"teensy-3-6/xtr32\"\n\n//\n//   UTILITY ROUTINES\n//\n\nextern func currentStackPointer user () -> $u32 : \"current.stack.pointer\"\n\nextern func freeStackSize user () -> $u32 : \"freeStackSize\"\n\nextern func noteFreeStackSize user () : \"noteFreeStackSize\"\n\nextern func noteCurrentTaskFreeStackSize service () : \"noteCurrentTaskFreeStackSize\"\n\nextern func taskCount user () -> $u32 : \"taskCount\"\n\nenum $GuardState {\n  case evaluatingOrOutside\n  case didChange\n  case waitingForChange\n}\n\nextern func taskGuardState safe user (\?taskIndex: inIndex $u32) -> $GuardState : \"taskGuardState\"\n\nextern func taskAllocatedStackSize safe user (\?taskIndex: inIndex $u32) -> $u32 : \"taskAllocatedStackSize\"\n\nextern func taskFreeStackSize safe user (\?taskIndex: inIndex $u32) -> $u32 : \"taskFreeStackSize\"\n\nextern func taskName safe user (\?taskIndex: inIndex $u32) -> $literalString : \"taskName\"\n\n//\n//   SYNCHRONIZATION TOOLS ROUTINES\n//\n\nopaque $TaskList @instantiable {32}\n\n//--- Block running task\nextern func\nblock safe primitive (\?!inList:ioWaitingList $TaskList) : \"blockInList\"\n\nextern func\nblock safe primitive (\?onDeadline:inDeadline $u32) : \"blockOnDeadline\"\n\n//--- Make task Ready\nextern func\nmakeTaskReady safe service (\?!fromList:ioWaitingList $TaskList\n                            !found: outFound $bool) : \"makeTaskReady\"\n\nextern func\nmakeTasksReady safe service (\?fromCurrentDate:inCurrentDate $u32) : \"makeTasksReadyFromCurrentDate\"\n\n//\n//   GUARD\n//\n\nopaque $GuardList @instantiable {32}\n\nextern func\nhandle safe guard (\?!guard:ioGuard $GuardList) : \"handleGuardedCommand\"\n\nextern func\nhandle safe guard (\?guardedDeadline:inDeadlineMS $u32) : \"guard.handle.wait.until\"\n\nextern func\nnotifyChange safe service (\?!forGuard:ioGuard $GuardList) : \"notify.change.from.guard.list\"\n\nextern func\nnotifyChangeForGuardedWaitUntil safe service (\?withCurrentDate:inCurrentDate $u32)\n: \"notify.change.for.guarded.wait.until\"\n\n//\n//   ACTIVITY LED\n//\n\nrequired func activityLedOn safe section @exported ()\n\nrequired func activityLedOff safe section @exported ()\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_113_targetTemplates (
  "teensy-3-6-xtr32.omnibus-import",
  "omnibus-import",
  true, // Text file
  3122, // Text length
  gWrapperFileContent_113_targetTemplates
) ;

//--- File 'teensy-3-6/teensy-3-6-xtr64.omnibus-import'

const char * gWrapperFileContent_100_targetTemplates = "\nctAssert target \"teensy-3-6/xtr64\"\n\n//\n//   UTILITY ROUTINES\n//\n\nextern func currentStackPointer safe user () -> $u32 : \"current.stack.pointer\"\n\nextern func freeStackSize safe user () -> $u32 : \"freeStackSize\"\n\nextern func noteFreeStackSize safe user () : \"noteFreeStackSize\"\n\nextern func noteCurrentTaskFreeStackSize safe service () : \"noteCurrentTaskFreeStackSize\"\n\nextern func taskCount safe user () -> $u32 : \"taskCount\"\n\nenum $GuardState {\n  case evaluatingOrOutside\n  case didChange\n  case waitingForChange\n}\n\nextern func taskGuardState safe user (\?taskIndex: inIndex $u32) -> $GuardState : \"taskGuardState\"\n\nextern func taskAllocatedStackSize safe user (\?taskIndex: inIndex $u32) -> $u32 : \"taskAllocatedStackSize\"\n\nextern func taskFreeStackSize safe user (\?taskIndex: inIndex $u32) -> $u32 : \"taskFreeStackSize\"\n\nextern func taskName safe user (\?taskIndex: inIndex $u32) -> $literalString : \"taskName\"\n\n//\n//   SYNCHRONIZATION TOOLS ROUTINES\n//\n\nopaque $TaskList @instantiable {64}\n\n//--- Block running task\nextern func\nblock safe primitive (\?!inList:ioWaitingList $TaskList) : \"blockInList\"\n\nextern func\nblock safe primitive (\?onDeadline:inDeadline $u32) : \"blockOnDeadline\"\n\n//--- Make task Ready\nextern func\nmakeTaskReady safe service (\?!fromList:ioWaitingList $TaskList\n                            !found: outFound $bool) : \"makeTaskReady\"\n\nextern func\nmakeTasksReady safe service (\?fromCurrentDate:inCurrentDate $u32) : \"makeTasksReadyFromCurrentDate\"\n\n//\n//   GUARD\n//\n\nopaque $GuardList @instantiable {64}\n\nextern func\nhandle safe guard (\?!guard:ioGuard $GuardList) : \"handleGuardedCommand\"\n\nextern func\nhandle safe guard (\?guardedDeadline:inDeadlineMS $u32) : \"guard.handle.wait.until\"\n\nextern func\nnotifyChange safe service (\?!forGuard:ioGuard $GuardList) : \"notify.change.from.guard.list\"\n\nextern func\nnotifyChangeForGuardedWaitUntil safe service (\?withCurrentDate:inCurrentDate $u32)\n: \"notify.change.for.guarded.wait.until\"\n\n//\n//   ACTIVITY LED\n//\n\nrequired func activityLedOn safe section @exported ()\n\nrequired func activityLedOff safe section @exported ()\n\n//\n" ;

const cRegularFileWrapper gWrapperFile_100_targetTemplates (
  "teensy-3-6-xtr64.omnibus-import",
  "omnibus-import",
  true, // Text file
  3147, // Text length
  gWrapperFileContent_100_targetTemplates
) ;

//--- File 'teensy-3-6/udfcoded-section-dispatcher-entry.s'

const char * gWrapperFileContent_103_targetTemplates = "  .word  \"!IMPLEMENTATION_ROUTINE!\" @ !IDX!, user routine !USER_ROUTINE!\n" ;

const cRegularFileWrapper gWrapperFile_103_targetTemplates (
  "udfcoded-section-dispatcher-entry.s",
  "s",
  true, // Text file
  73, // Text length
  gWrapperFileContent_103_targetTemplates
) ;

//--- File 'teensy-3-6/udfcoded-section-dispatcher-header.s'

const char * gWrapperFileContent_88_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 S E C T I O N   T A B L E                                                                            *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .align  2\n\n__section_dispatcher_table:\n" ;

const cRegularFileWrapper gWrapperFile_88_targetTemplates (
  "udfcoded-section-dispatcher-header.s",
  "s",
  true, // Text file
  647, // Text length
  gWrapperFileContent_88_targetTemplates
) ;

//--- File 'teensy-3-6/udfcoded-section-handler.s'

const char * gWrapperFileContent_97_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                 U D F    H A N D L E R    ( D O U B L E    S T A C K    M O D E )                                    *\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n@                                                                                                                      *\n@                    |                            |                                                                    *\n@          PSP+32 -> |----------------------------| \\\n@                    | xPSR                       |  |\n@          PSP+28 -> |----------------------------|  |\n@                    | PC (UDF instruction)       |  |\n@          PSP+24 -> |----------------------------|  |\n@                    | LR                         |  |\n@          PSP+20 -> |----------------------------|  |\n@                    | R12                        |  |  Saved by interrupt response\n@          PSP+16 -> |----------------------------|  |\n@                    | R3                         |  |\n@          PSP+12 -> |----------------------------|  |\n@                    | R2                         |  |\n@          PSP+8  -> |----------------------------|  |\n@                    | R1                         |  |\n@          PSP+4  -> |----------------------------|  |\n@                    | R0                         |  |\n@          PSP    -> |----------------------------| /\n@                                                                                                                      *\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .section  \".text.as_section_handler\",\"ax\",%progbits\n\n  .global as_section_handler\n  .type as_section_handler, %function\n\nas_section_handler:\n@--------------------- Save preserved registers\n  push  {r5, lr}\n@--------------------- R5 <- thread SP\n  mrs   r5, psp\n@----------------------------------------- Restore R0, R1, R2 and R3 from saved stack\n  ldmia r5!, {r0, r1, r2, r3}       @ R5 incremented by 16\n@--------------------- LR <- Address of UDF instruction\n  ldr   lr, [r5, #8]     @ 16 + 8 = 24 : 6 stacked registers before saved PC\n@--------------------- Set return address to instruction following UDF\n  adds  lr, #2\n  str   lr, [r5, #8]\n@--------------------- R12 <- address of dispatcher\n  ldr   r12, =__section_dispatcher_table\n  subs  r5, #16   @ Prepare R5 for storing R0 to R3 in stacked registers\n@--------------------- LR <- bits 0-7 of UDF instruction\n  ldrb  lr, [lr, #-2]            @ LR is service call index\n@--------------------- r12 <- address of routine to call\n  ldr   r12, [r12, lr, lsl #2]   @ R12 += LR << 2\n@--------------------- Call service routine\n  blx   r12                      @ R5: thread PSP\n@--------------------- Set return code (from R0 to R3) in stacked registers\n  stmia r5!, {r0, r1, r2, r3}    @ R5 is thread SP\n@--------------------- Restore preserved registers, return from interrupt\n  pop   {r5, pc}\n\n" ;

const cRegularFileWrapper gWrapperFile_97_targetTemplates (
  "udfcoded-section-handler.s",
  "s",
  true, // Text file
  3403, // Text length
  gWrapperFileContent_97_targetTemplates
) ;

//--- File 'teensy-3-6/udfcoded-section-invocation-from-unknown-mode.s'

const char * gWrapperFileContent_92_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Section !USER_ROUTINE!, implemented by !IMPLEMENTATION_ROUTINE!\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .section  \".text.!USER_ROUTINE!\", \"ax\", %progbits\n\n  .global \"!USER_ROUTINE!\"\n  .type  \"!USER_ROUTINE!\", %function\n\n  .align  2\n  .thumb_func\n\n\"!USER_ROUTINE!\":\n  .fnstart\n  mrs  r12, IPSR @ r12 <- 00 in thread mode, nn, nn  0 in handler mode\n  ands r12, #255\n  bne  \"!IMPLEMENTATION_ROUTINE!\" @ in handler mode, call implementation routine directly\n  udf  !IDX!\n  bx   lr\n\n\".Lfunc_end_!USER_ROUTINE!\":\n  .size  \"!USER_ROUTINE!\", \".Lfunc_end_!USER_ROUTINE!\" - \"!USER_ROUTINE!\"\n  .cantunwind\n  .fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_92_targetTemplates (
  "udfcoded-section-invocation-from-unknown-mode.s",
  "s",
  true, // Text file
  816, // Text length
  gWrapperFileContent_92_targetTemplates
) ;

//--- File 'teensy-3-6/udfcoded-section-invocation-from-user-mode.s'

const char * gWrapperFileContent_91_targetTemplates = "@----------------------------------------------------------------------------------------------------------------------*\n@  Section !USER_ROUTINE!, implemented by !IMPLEMENTATION_ROUTINE!\n@----------------------------------------------------------------------------------------------------------------------*\n\n  .section  \".text.!USER_ROUTINE!\", \"ax\", %progbits\n\n  .global \"!USER_ROUTINE!\"\n  .type  \"!USER_ROUTINE!\", %function\n\n  .align  2\n  .thumb_func\n\n\"!USER_ROUTINE!\":\n  .fnstart\n  udf !IDX!\n  bx  lr\n\n\".Lfunc_end_!USER_ROUTINE!\":\n  .size \"!USER_ROUTINE!\", \".Lfunc_end_!USER_ROUTINE!\" - \"!USER_ROUTINE!\"\n  .cantunwind\n  .fnend\n\n" ;

const cRegularFileWrapper gWrapperFile_91_targetTemplates (
  "udfcoded-section-invocation-from-user-mode.s",
  "s",
  true, // Text file
  632, // Text length
  gWrapperFileContent_91_targetTemplates
) ;

//--- File 'xtr32/+config.omnibus-target'

const char * gWrapperFileContent_118_targetTemplates = "PYTHON_UTILITIES:\n   \"../../py-toolpath.txt\" -> \"sources/toolpath.py\"\n   \"../../py-makefile.txt\" -> \"sources/makefile.py\"\n   \"../../py-check-stacks.txt\" -> \"sources/check-stacks.py\"\n   \"../../py-omnibus.txt\" -> \"sources/omnibus.py\"\n   \"../../py-build-verbose.txt\" -> \"build-verbose.py\"\n   \"../../py-clean.txt\" -> \"clean.py\"\n   \"../../py-objdump.txt\" -> \"objdump.py\"\n   \"../../py-objsize.txt\" -> \"objsize.py\"\n   \"../py-run.txt\" -> \"run.py\"\n\nPYTHON_BUILD: \"../py-build.txt\"\n\nLINKER_SCRIPT: \"../ld-linker.txt\"\n\nPANIC_CODE_TYPE_NAME: $u32\nPANIC_LINE_TYPE_NAME: $u32\n\nPOINTER_BIT_COUNT: 32\n\nDYNAMIC_ARRAY: yes\n\nSYSTEM_STACK_SIZE: 1024\n\nNOP: \"call void asm sideeffect \\\"nop\\\", \\\"\\\"() nounwind\"\n\nBIT_BAND:0x4000_0000 0x4200_0000 0x4200_0000 32 4\n\nSERVICE_HANDLER: \"../service-handler.s\"\nSERVICE_SYSTEM_STACK_SIZE: 12 // as_svc_handler saves 3 registers on system stack\nSERVICE_DISPATCHER_HEADER: \"../service-dispatcher-header.s\"\nSERVICE_DISPATCHER_ENTRY: \"../service-dispatcher-entry.s\"\nSERVICE_ENTRY_NO_RETURNED_VALUE: \"../service-entry-no-return.s\"\nSERVICE_ENTRY_WITH_RETURNED_VALUE: \"../service-entry-return-value.s\"\n\nSECTION_HANDLER: \"../udfcoded-section-handler.s\"\nSECTION_SYSTEM_STACK_SIZE: 8 // saves 2 registers on system stack\nSECTION_DISPATCHER_HEADER: \"../udfcoded-section-dispatcher-header.s\"\nSECTION_DISPATCHER_ENTRY: \"../udfcoded-section-dispatcher-entry.s\"\nSECTION_ENTRY_FROM_UNKNOWN_MODE: \"../udfcoded-section-invocation-from-unknown-mode.s\"\nSECTION_ENTRY_FROM_USER_MODE: \"../udfcoded-section-invocation-from-user-mode.s\"\n\nINTERRUPT_HANDLER: \"../s-interrupt-handler.s\"\nINTERRUPT_USER_STACK_SIZE: 32 // Cortex M4 saves 8 regs in user stack on interrupt\nUNUSED_INTERRUPT: \"../s-unused-interrupt.s\"\n\nCPP_FILES:\n  \"../c-cortex-m4-context.cpp\"\n  \"../../c-task-list-type-32-tasks.cpp\"\n  \"../../c-guard-types-32-tasks.cpp\"\n  \"../../c-task-control-block-type.cpp\"\n  \"../../c-task-list-32-tasks.cpp\"\n  \"../../c-guard-list-32-tasks.cpp\"\n  \"../../c-deadline-list-32-tasks.cpp\"\n  \"../../c-real-time-kernel-code.cpp\"\n  \"../../c-guard-code.cpp\"\n  \"../../c-real-time-kernel-utilities.cpp\"\n  \"../../memory-utilities.cpp\"\n  \"../../heap.cpp\"\n  \"../../dynamic-buffer.cpp\"\n\nS_FILES:\n  \"../s-cortex-m4-header.s\"\n  \"../s-interrupt-vectors.s\"\n  \"../s-reset-handler.s\"\n  \"../s-current-stack-pointer.s\"\n\nLL_FILES:\n  \"../ll-cortex-m4.ll\"\n  \"../../ll-clear-bss.ll\"\n  \"../../ll-copy-data-section.ll\"\n  \"../../ll-copy-byte-array.ll\"\n  \"../../ll-copy-word-array.ll\"\n  \"../../ll-configuration-on-boot.ll\"\n\nOMNIBUS_FILES:\n  \"../MK66F18-pm.svd.omnibus-import\"\n  \"../registers-mk66fx1m0-complements.omnibus-import\"\n  \"../../registers-cortex-m4.omnibus-import\"\n  \"../teensy-3-6-nvic-interrupts.omnibus-import\"\n  \"../driver-root-teensy-3-6.omnibus-import\"\n  \"../teensy-3-6-time.omnibus-import\"\n  \"../teensy-3-6-xtr32.omnibus-import\"\n  \"../driver-digital-teensy-3-6.omnibus-import\"\n  \"../teensy-3-6-lcd.omnibus-import\"\n  \"../../semaphore.omnibus-import\"\n  \"../../heap.omnibus-import\"\n\nINTERRUPTS:\n  NMI -> 2\n  MemManage -> 4\n  BusFault -> 5\n  UsageFault -> 6\n  DebugMonitor -> 12\n  PendSV -> 14\n  systick -> 15\n  DMAChannel0TransferComplete -> 16\n  DMAChannel1TransferComplete -> 17\n  DMAChannel2TransferComplete -> 18\n  DMAChannel3TransferComplete -> 19\n  DMAChannel4TransferComplete -> 20\n  DMAChannel5TransferComplete -> 21\n  DMAChannel6TransferComplete -> 22\n  DMAChannel7TransferComplete -> 23\n  DMAChannel8TransferComplete -> 24\n  DMAChannel9TransferComplete -> 25\n  DMAChannel10TransferComplete -> 26\n  DMAChannel11TransferComplete -> 27\n  DMAChannel12TransferComplete -> 28\n  DMAChannel13TransferComplete -> 29\n  DMAChannel14TransferComplete -> 30\n  DMAChannel15TransferComplete -> 31\n  DMAError -> 32\n  MCM -> 33\n  FlashMemoryCommandComplete -> 34\n  FlashMemoryReadCollision -> 35\n  LowVoltage -> 36\n  LowLeakageWakeup -> 37\n  WDOG_EWM -> 38\n  RandomNumberGenerator -> 39\n  I2C0 -> 40\n  I2C1 -> 41\n  SPI0 -> 42\n  SPI1 -> 43\n  I2S0Transmit -> 44\n  I2S0Receive -> 45\n  UART0Status -> 47\n  UART0Error -> 48\n  UART1Status -> 49\n  UART1Error -> 50\n  UART2Status -> 51\n  UART2Error -> 52\n  UART3Status -> 53\n  UART3Error -> 54\n  ADC0 -> 55\n  CMP0 -> 56\n  CMP1 -> 57\n  FTM0 -> 58\n  FTM1 -> 59\n  FTM2 -> 60\n  CMT -> 61\n  RTCAlarm -> 62\n  RTCSecond -> 63\n  PITChannel0 -> 64\n  PITChannel1 -> 65\n  PITChannel2 -> 66\n  PITChannel3 -> 67\n  PDB -> 68\n  USBFS_OTG -> 69\n  USBFSChargerDetect -> 70\n  DAC0 -> 72\n  MCG -> 73\n  lowPowerTimer -> 74\n  pinDetectPortA -> 75\n  pinDetectPortB -> 76\n  pinDetectPortC -> 77\n  pinDetectPortD -> 78\n  pinDetectPortE -> 79\n  softwareInterrupt -> 80\n  SPI2 -> 81\n  UART4Status -> 82\n  UART4Error -> 83\n  CMP2 -> 86\n  FTM3 -> 87\n  DAC1 -> 88\n  ADC1 -> 89\n  I2C2 -> 90\n  CAN0MessageBuffer -> 91\n  CAN0BusOff -> 92\n  CAN0Error -> 93\n  CAN0TransmitWarning -> 94\n  CAN0ReceiveWarning -> 95\n  CAN0WakeUp -> 96\n  SDHC -> 97\n  EthernetTimer -> 98\n  EthernetTransmit -> 99\n  EthernetReceive -> 100\n  EthernetError -> 101\n  LPUART0Status -> 102\n  TSI0 -> 103\n  TPM1 -> 104\n  TPM2 -> 105\n  USB_HS_DCD_PHY -> 106\n  I2C3 -> 107\n  CMP3 -> 108\n  USB_HS_OTG -> 109\n  CAN1MessageBuffer -> 110\n  CAN1BusOff -> 111\n  CAN1Error -> 112\n  CAN1TransmitWarning -> 113\n  CAN1ReceiveWarning -> 114\n  CAN1WakeUp -> 115\n" ;

const cRegularFileWrapper gWrapperFile_118_targetTemplates (
  "+config.omnibus-target",
  "omnibus-target",
  true, // Text file
  5194, // Text length
  gWrapperFileContent_118_targetTemplates
) ;

//--- All files of 'xtr32' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_5 [2] = {
  & gWrapperFile_118_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'xtr32' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_5 [1] = {
  NULL
} ;

//--- Directory 'xtr32'

const cDirectoryWrapper gWrapperDirectory_5_targetTemplates (
  "xtr32",
  1,
  gWrapperAllFiles_targetTemplates_5,
  0,
  gWrapperAllDirectories_targetTemplates_5
) ;

//--- File 'xtr64/+config.omnibus-target'

const char * gWrapperFileContent_119_targetTemplates = "PYTHON_UTILITIES:\n   \"../../py-toolpath.txt\" -> \"sources/toolpath.py\"\n   \"../../py-makefile.txt\" -> \"sources/makefile.py\"\n   \"../../py-check-stacks.txt\" -> \"sources/check-stacks.py\"\n   \"../../py-omnibus.txt\" -> \"sources/omnibus.py\"\n   \"../../py-build-verbose.txt\" -> \"build-verbose.py\"\n   \"../../py-clean.txt\" -> \"clean.py\"\n   \"../../py-objdump.txt\" -> \"objdump.py\"\n   \"../../py-objsize.txt\" -> \"objsize.py\"\n   \"../py-run.txt\" -> \"run.py\"\n\nPYTHON_BUILD: \"../py-build.txt\"\n\nLINKER_SCRIPT: \"../ld-linker.txt\"\n\nPANIC_CODE_TYPE_NAME: $u32\nPANIC_LINE_TYPE_NAME: $u32\n\nPOINTER_BIT_COUNT: 32\n\nDYNAMIC_ARRAY: yes\n\nSYSTEM_STACK_SIZE: 1024\n\nNOP: \"call void asm sideeffect \\\"nop\\\", \\\"\\\"() nounwind\"\n\nBIT_BAND:0x4000_0000 0x4200_0000 0x4200_0000 32 4\n\nSERVICE_HANDLER: \"../service-handler.s\"\nSERVICE_SYSTEM_STACK_SIZE: 12 // as_svc_handler saves 3 registers on system stack\nSERVICE_DISPATCHER_HEADER: \"../service-dispatcher-header.s\"\nSERVICE_DISPATCHER_ENTRY: \"../service-dispatcher-entry.s\"\nSERVICE_ENTRY_NO_RETURNED_VALUE: \"../service-entry-no-return.s\"\nSERVICE_ENTRY_WITH_RETURNED_VALUE: \"../service-entry-return-value.s\"\n\nSECTION_HANDLER: \"../udfcoded-section-handler.s\"\nSECTION_SYSTEM_STACK_SIZE: 8 // saves 2 registers on system stack\nSECTION_DISPATCHER_HEADER: \"../udfcoded-section-dispatcher-header.s\"\nSECTION_DISPATCHER_ENTRY: \"../udfcoded-section-dispatcher-entry.s\"\nSECTION_ENTRY_FROM_UNKNOWN_MODE: \"../udfcoded-section-invocation-from-unknown-mode.s\"\nSECTION_ENTRY_FROM_USER_MODE: \"../udfcoded-section-invocation-from-user-mode.s\"\n\nINTERRUPT_HANDLER: \"../s-interrupt-handler.s\"\nINTERRUPT_USER_STACK_SIZE: 32 // Cortex M4 saves 8 regs in user stack on interrupt\nUNUSED_INTERRUPT: \"../s-unused-interrupt.s\"\n\nCPP_FILES:\n  \"../c-cortex-m4-context.cpp\"\n  \"../../c-task-list-type-64-tasks.cpp\"\n  \"../../c-guard-types-64-tasks.cpp\"\n  \"../../c-task-control-block-type.cpp\"\n  \"../../c-task-list-64-tasks.cpp\"\n  \"../../c-guard-list-64-tasks.cpp\"\n  \"../../c-deadline-list-64-tasks.cpp\"\n  \"../../c-real-time-kernel-code.cpp\"\n  \"../../c-guard-code.cpp\"\n  \"../../c-real-time-kernel-utilities.cpp\"\n  \"../../memory-utilities.cpp\"\n  \"../../heap.cpp\"\n  \"../../dynamic-buffer.cpp\"\n\nS_FILES:\n  \"../s-cortex-m4-header.s\"\n  \"../s-interrupt-vectors.s\"\n  \"../s-reset-handler.s\"\n  \"../s-current-stack-pointer.s\"\n\nLL_FILES:\n  \"../ll-cortex-m4.ll\"\n  \"../../ll-clear-bss.ll\"\n  \"../../ll-copy-data-section.ll\"\n  \"../../ll-copy-byte-array.ll\"\n  \"../../ll-copy-word-array.ll\"\n  \"../../ll-configuration-on-boot.ll\"\n\nOMNIBUS_FILES:\n  \"../MK66F18-pm.svd.omnibus-import\"\n  \"../registers-mk66fx1m0-complements.omnibus-import\"\n  \"../../registers-cortex-m4.omnibus-import\"\n  \"../teensy-3-6-nvic-interrupts.omnibus-import\"\n  \"../driver-root-teensy-3-6.omnibus-import\"\n  \"../teensy-3-6-time.omnibus-import\"\n  \"../teensy-3-6-xtr64.omnibus-import\"\n  \"../driver-digital-teensy-3-6.omnibus-import\"\n  \"../teensy-3-6-lcd.omnibus-import\"\n  \"../../semaphore.omnibus-import\"\n  \"../../heap.omnibus-import\"\n\nINTERRUPTS:\n  NMI -> 2\n  MemManage -> 4\n  BusFault -> 5\n  UsageFault -> 6\n  DebugMonitor -> 12\n  PendSV -> 14\n  systick -> 15\n  DMAChannel0TransferComplete -> 16\n  DMAChannel1TransferComplete -> 17\n  DMAChannel2TransferComplete -> 18\n  DMAChannel3TransferComplete -> 19\n  DMAChannel4TransferComplete -> 20\n  DMAChannel5TransferComplete -> 21\n  DMAChannel6TransferComplete -> 22\n  DMAChannel7TransferComplete -> 23\n  DMAChannel8TransferComplete -> 24\n  DMAChannel9TransferComplete -> 25\n  DMAChannel10TransferComplete -> 26\n  DMAChannel11TransferComplete -> 27\n  DMAChannel12TransferComplete -> 28\n  DMAChannel13TransferComplete -> 29\n  DMAChannel14TransferComplete -> 30\n  DMAChannel15TransferComplete -> 31\n  DMAError -> 32\n  MCM -> 33\n  FlashMemoryCommandComplete -> 34\n  FlashMemoryReadCollision -> 35\n  LowVoltage -> 36\n  LowLeakageWakeup -> 37\n  WDOG_EWM -> 38\n  RandomNumberGenerator -> 39\n  I2C0 -> 40\n  I2C1 -> 41\n  SPI0 -> 42\n  SPI1 -> 43\n  I2S0Transmit -> 44\n  I2S0Receive -> 45\n  UART0Status -> 47\n  UART0Error -> 48\n  UART1Status -> 49\n  UART1Error -> 50\n  UART2Status -> 51\n  UART2Error -> 52\n  UART3Status -> 53\n  UART3Error -> 54\n  ADC0 -> 55\n  CMP0 -> 56\n  CMP1 -> 57\n  FTM0 -> 58\n  FTM1 -> 59\n  FTM2 -> 60\n  CMT -> 61\n  RTCAlarm -> 62\n  RTCSecond -> 63\n  PITChannel0 -> 64\n  PITChannel1 -> 65\n  PITChannel2 -> 66\n  PITChannel3 -> 67\n  PDB -> 68\n  USBFS_OTG -> 69\n  USBFSChargerDetect -> 70\n  DAC0 -> 72\n  MCG -> 73\n  lowPowerTimer -> 74\n  pinDetectPortA -> 75\n  pinDetectPortB -> 76\n  pinDetectPortC -> 77\n  pinDetectPortD -> 78\n  pinDetectPortE -> 79\n  softwareInterrupt -> 80\n  SPI2 -> 81\n  UART4Status -> 82\n  UART4Error -> 83\n  CMP2 -> 86\n  FTM3 -> 87\n  DAC1 -> 88\n  ADC1 -> 89\n  I2C2 -> 90\n  CAN0MessageBuffer -> 91\n  CAN0BusOff -> 92\n  CAN0Error -> 93\n  CAN0TransmitWarning -> 94\n  CAN0ReceiveWarning -> 95\n  CAN0WakeUp -> 96\n  SDHC -> 97\n  EthernetTimer -> 98\n  EthernetTransmit -> 99\n  EthernetReceive -> 100\n  EthernetError -> 101\n  LPUART0Status -> 102\n  TSI0 -> 103\n  TPM1 -> 104\n  TPM2 -> 105\n  USB_HS_DCD_PHY -> 106\n  I2C3 -> 107\n  CMP3 -> 108\n  USB_HS_OTG -> 109\n  CAN1MessageBuffer -> 110\n  CAN1BusOff -> 111\n  CAN1Error -> 112\n  CAN1TransmitWarning -> 113\n  CAN1ReceiveWarning -> 114\n  CAN1WakeUp -> 115\n" ;

const cRegularFileWrapper gWrapperFile_119_targetTemplates (
  "+config.omnibus-target",
  "omnibus-target",
  true, // Text file
  5194, // Text length
  gWrapperFileContent_119_targetTemplates
) ;

//--- All files of 'xtr64' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_6 [2] = {
  & gWrapperFile_119_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'xtr64' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_6 [1] = {
  NULL
} ;

//--- Directory 'xtr64'

const cDirectoryWrapper gWrapperDirectory_6_targetTemplates (
  "xtr64",
  1,
  gWrapperAllFiles_targetTemplates_6,
  0,
  gWrapperAllDirectories_targetTemplates_6
) ;

//--- All files of 'teensy-3-6' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_4 [31] = {
  & gWrapperFile_95_targetTemplates,
  & gWrapperFile_98_targetTemplates,
  & gWrapperFile_96_targetTemplates,
  & gWrapperFile_105_targetTemplates,
  & gWrapperFile_107_targetTemplates,
  & gWrapperFile_112_targetTemplates,
  & gWrapperFile_111_targetTemplates,
  & gWrapperFile_90_targetTemplates,
  & gWrapperFile_114_targetTemplates,
  & gWrapperFile_117_targetTemplates,
  & gWrapperFile_116_targetTemplates,
  & gWrapperFile_115_targetTemplates,
  & gWrapperFile_93_targetTemplates,
  & gWrapperFile_102_targetTemplates,
  & gWrapperFile_94_targetTemplates,
  & gWrapperFile_109_targetTemplates,
  & gWrapperFile_89_targetTemplates,
  & gWrapperFile_99_targetTemplates,
  & gWrapperFile_108_targetTemplates,
  & gWrapperFile_104_targetTemplates,
  & gWrapperFile_110_targetTemplates,
  & gWrapperFile_101_targetTemplates,
  & gWrapperFile_106_targetTemplates,
  & gWrapperFile_113_targetTemplates,
  & gWrapperFile_100_targetTemplates,
  & gWrapperFile_103_targetTemplates,
  & gWrapperFile_88_targetTemplates,
  & gWrapperFile_97_targetTemplates,
  & gWrapperFile_92_targetTemplates,
  & gWrapperFile_91_targetTemplates,
  NULL
} ;

//--- All sub-directories of 'teensy-3-6' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_4 [3] = {
  & gWrapperDirectory_5_targetTemplates,
  & gWrapperDirectory_6_targetTemplates,
  NULL
} ;

//--- Directory 'teensy-3-6'

const cDirectoryWrapper gWrapperDirectory_4_targetTemplates (
  "teensy-3-6",
  30,
  gWrapperAllFiles_targetTemplates_4,
  2,
  gWrapperAllDirectories_targetTemplates_4
) ;

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_targetTemplates_0 [35] = {
  & gWrapperFile_4_targetTemplates,
  & gWrapperFile_5_targetTemplates,
  & gWrapperFile_3_targetTemplates,
  & gWrapperFile_10_targetTemplates,
  & gWrapperFile_11_targetTemplates,
  & gWrapperFile_24_targetTemplates,
  & gWrapperFile_31_targetTemplates,
  & gWrapperFile_9_targetTemplates,
  & gWrapperFile_20_targetTemplates,
  & gWrapperFile_21_targetTemplates,
  & gWrapperFile_16_targetTemplates,
  & gWrapperFile_17_targetTemplates,
  & gWrapperFile_8_targetTemplates,
  & gWrapperFile_7_targetTemplates,
  & gWrapperFile_26_targetTemplates,
  & gWrapperFile_6_targetTemplates,
  & gWrapperFile_15_targetTemplates,
  & gWrapperFile_2_targetTemplates,
  & gWrapperFile_25_targetTemplates,
  & gWrapperFile_23_targetTemplates,
  & gWrapperFile_0_targetTemplates,
  & gWrapperFile_1_targetTemplates,
  & gWrapperFile_13_targetTemplates,
  & gWrapperFile_32_targetTemplates,
  & gWrapperFile_33_targetTemplates,
  & gWrapperFile_18_targetTemplates,
  & gWrapperFile_28_targetTemplates,
  & gWrapperFile_22_targetTemplates,
  & gWrapperFile_30_targetTemplates,
  & gWrapperFile_29_targetTemplates,
  & gWrapperFile_19_targetTemplates,
  & gWrapperFile_27_targetTemplates,
  & gWrapperFile_14_targetTemplates,
  & gWrapperFile_12_targetTemplates,
  NULL
} ;

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_targetTemplates_0 [4] = {
  & gWrapperDirectory_1_targetTemplates,
  & gWrapperDirectory_2_targetTemplates,
  & gWrapperDirectory_4_targetTemplates,
  NULL
} ;

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_targetTemplates (
  "",
  34,
  gWrapperAllFiles_targetTemplates_0,
  3,
  gWrapperAllDirectories_targetTemplates_0
) ;


