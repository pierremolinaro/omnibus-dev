target "teensy-3-6/xtr32"
let F_CPU_MHZ = 240

import "carte-tp-teensy-3-6.plm-import"

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

driver myDriver > digital {

  //····················································································································
  //--- Two external clocks are available for the Flexi timers : FTM_CLKIN0 and FTM_CKLIN1
  //  Input ports for FTM_CLKIN0
  //    PTA18 ALT 4: not available, used by 16 MHz quartz
  //    PTB16 ALT 4: pin #0
  //    PTC12 ALT 4: not available on Teensy
  //  Input ports for FTM_CLKIN1
  //    PTA19 ALT 4: not available, used by 16 MHz quartz
  //    PTB17 ALT 4: pin #1
  //    PTC13 ALT 4: not available on Teensy
  //  For selecting external clock for FTM: CLKS field of FTM0:SC set to 3.
  //  The FTMiCLKSEL fields of the SIM:SOPT4 register select FTM_CLKIN0 or FTM_CKLIN1 :
  //    0 for FTM_CLKIN0
  //    1 for FTM_CLKIN0
  //····················································································································

  startup {
    digital.set (!mode:.OUTPUT !toPort:LED_L0)
    digital.set (!mode:.OUTPUT !toPort:LED_L1)
  //--- Enable clock
    #SIM:SCGC6 |= {#SIM:SCGC6 !FTM0:1 !FTM1:1}
    #SIM:SOPT4 = 0 // |= {#SIM:SOPT4 !FTM1CLKSEL:1}
  //-- Configure PTB16 as FTM_CLKIN0 (with pullup)
//    #PORTB:PCR[16] = {#PORTB:PCR !MUX:4 !PE:1 !PS:1}
    #PORTB:PCR[17] = {#PORTB:PCR !MUX:4 !PE:1 !PS:1}
  //--- Set counter min value
//    #FTM[1]:CONF = {#FTM:CONF !NUMTOF:31}
    #FTM[0]:MODE = 0x05
    #FTM[0]:SC = 0
    #FTM[0]:CNTIN = {#FTM:CNTIN !INIT:0}
    #FTM[0]:CNT = {#FTM:CNT !COUNT:0}
    #FTM[0]:MOD = {#FTM:MOD !MOD:1}
    #FTM[0]:C0SC = 0x14
    #PORTB:PCR[16] = {#PORTB:PCR !MUX:4 !PE:1 !PS:1}
    #FTM[0]:C0V = 0
    #FTM[0]:SC = 0x58

//    #FTM[0]:CNTIN = {#FTM:CNTIN !INIT:0}
    #FTM[1]:CNTIN = {#FTM:CNTIN !INIT:0}
  //--- Set counter current value
//    #FTM[0]:CNT = {#FTM:CNT !COUNT:0}
    #FTM[1]:CNT = {#FTM:CNT !COUNT:0}
  //--- Set counter max value
//    #FTM[0]:MOD = {#FTM:MOD !MOD:1}
    #FTM[1]:MOD = {#FTM:MOD !MOD:0xFFFF}

//    #FTM[0]:CONF = {#FTM:CONF !BDMMODE:3}
//    #FTM[1]:CONF = {#FTM:CONF !BDMMODE:3}
//    #FTM[0]:MODE = {#FTM:MODE !FTMEN:1}
//    #FTM[1]:MODE = {#FTM:MODE !FTMEN:1}
  //--- Set prescaler (0 -> divide by 1) and clock source (3 --> external source)
//    #FTM[0]:C0V = 0  //compare value = 0
//    #FTM[0]:SC = {#FTM:SC !CLKS:3 !PS:0}
    #FTM[1]:SC = {#FTM:SC !CLKS:1 !PS:6}
  //--- Enable NVIC interrupt
    enable (!interrupt:.FTM0)
  //--- Enable FTM interrupt
//    #FTM[0]:SC |= {#FTM:SC !TOIE:1}
  //--- Enable NVIC interrupt
    enable (!interrupt:.FTM1)
  //--- Enable FTM interrupt
    #FTM[1]:SC |= {#FTM:SC !TOIE:1}
  }

  //····················································································································

   section readCounter0 () -> $uint32 {
    result = #FTM[0]:CNT
  }
  //····················································································································

   section readCounter1 () -> $uint32 {
    result = #FTM[1]:CNT
  }

  //····················································································································

  interrupt section FTM0 {
  //--- Set by hardware when the FTM counter passes the value in the MOD register.
  //    The TOF bit is cleared by reading the SC register while TOF is set and then writing a 0 to TOF bit
    #FTM[0]:SC = #FTM[0]:SC & ~ {#FTM:SC !TOF:1}
    digital.toggle (!port:LED_L0)
  }
  //····················································································································

  interrupt section FTM1 {
  //--- Set by hardware when the FTM counter passes the value in the MOD register.
  //    The TOF bit is cleared by reading the SC register while TOF is set and then writing a 0 to TOF bit
    #FTM[1]:SC = #FTM[1]:SC & ~ {#FTM:SC !TOF:1}
    digital.toggle (!port:LED_L1)
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

driver myDriver ()

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

task T1 @stacksize 512 @activate {
  var échéance $uint32 = 0
  var counter0 $uint32 = 0
  var counter1 $uint32 = 0

  on @setup first {
    digital.set (!mode:.OUTPUT !toPort:LED_L3)
    lcd.print (!string:"FTM0:")
    lcd.goto (!line:1 !column:0)
    lcd.print (!string:"FTM1:")
  }

  on time.wait (!until:self.échéance) {
    self.échéance +%= 1_000
    digital.toggle (!port:LED_L3)
    let counter0 = myDriver.readCounter0 ()
    if self.counter0 ≠ counter0 {
      self.counter0 = counter0
      lcd.goto (!line:0 !column:6)
      lcd.print (!u32:counter0)
    }
    let counter1 = myDriver.readCounter1 ()
    if self.counter1 ≠ counter1 {
      self.counter1 = counter1
      lcd.goto (!line:1 !column:6)
      lcd.print (!u32:counter1)
    }
  }

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
