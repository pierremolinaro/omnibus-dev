target "teensy-3-6/unprivileged"
let F_CPU_MHZ = 180

driver lcd (!DB4:.D16 !DB5:.D15 !DB6:.D14 !DB7:.D19 !RS:.D18 !ENABLE:.D17)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Display clock settings                                                               
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let myBUS_MHZ @display = BUS_MHZ
let myFLEXBUS_MHZ @display = FLEXBUS_MHZ
let myFLASH_KHZ @display = FLASH_KHZ

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   ACTIVITY LED                                                               
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func section activityLedOn @safe @exported () {
  digital.write (!yes !toPort:.D13)
}

func section activityLedOff @safe @exported () {
  digital.write (!no !toPort:.D13)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// USB DEVICE DRIVER
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let NUM_ENDPOINTS = 4
let LED_L1 = $digitalPort.D4
let LED_L2 = $digitalPort.D5
let LED_L3 = $digitalPort.D6
let LED_L4 = $digitalPort.D7

//······················································································································

struct $bdt_t @copyable {
 var desc $uint32 = 0
 var addr $uint32 = 0
}


let BDT_OWN   = 0x80
let BDT_DATA1 = 0x40
let BDT_DATA0 = 0x00
let BDT_DTS   = 0x08
let BDT_STALL = 0x04
//let BDT_PID(n) (((n) >> 2) & 15)

let EP0_SIZE = 64

func BDT_DESC (?count $uint32 ?data $uint1) -> $uint32 {
  result = BDT_OWN | BDT_DTS | (count << 16) | if data ≠ 0 {BDT_DATA1} else {BDT_DATA0}
}

let TX   = 1
let RX   = 0
let ODD  = 1
let EVEN = 0
let DATA0 = 0
let DATA1 = 1

func index (? endpoint $uint32 ?tx $uint32 ?odd $uint32) -> $uint32 {
  result = (endpoint << 2) | (tx << 1) | odd
}

let TRACE_SIZE = 10

//······················································································································

driver usb_device > digital {
// Descriptor table should be aligned on a 512 byte-boudary
  var descriptorTable @align 512 = $bdt_t [(NUM_ENDPOINTS+1)*4] (!repeated:$bdt_t ())

  var ep0_rx0_buf @align 4 = $uint8 [EP0_SIZE] (!repeated:0)
  var ep0_rx1_buf @align 4 = $uint8 [EP0_SIZE] (!repeated:0)
  var ep0_tx_bdt_bank $uint32 = 0

  var état = $uint4 [TRACE_SIZE] (!repeated:0)
  var indexÉtat $uint32 = 0
  
  public system section lireÉtat (?index $uint32) -> $uint32 {
    result = extend (self.état [index])
  }
  
  public system section lireAddresseUSB () -> $uint32 {
    let r = addressof (self.descriptorTable)
    result = extend (r [8 ... 15])
  }
  
  //····················································································································

  init {
    digital.set (!mode:.OUTPUT !toPort:LED_L1)
    digital.set (!mode:.OUTPUT !toPort:LED_L2)
    digital.set (!mode:.OUTPUT !toPort:LED_L3)
    digital.set (!mode:.OUTPUT !toPort:LED_L4)
  // This basically follows the flowchart in the Kinetis Quick Reference User Guide, Rev. 3, 05/2014, page 134
  //-- Assume 48 MHz clock already running
    SIM:SCGC4 |= {SIM:SCGC4 !USBOTG:1} // SIM - enable clock
//    SIM:SCGC7 |= {SIM:SCGC7 !MPU:1} //--- Useful ?
//    SIM:SCGC6 |= {SIM:SCGC6 !USBDCD:1} //--- Useful ?
//    SIM:SCGC3 |= {SIM:SCGC3 !USBHSDCD:1 !USBHSPHY:1 !USBHS:1} //--- Useful ?
    MPU:RGDAAC [0] |= {MPU:RGDAAC !M4RE:1 !M4WE:1}
  //--- If using IRC48M, turn on the USB clock recovery hardware
    if @static (F_CPU_MHZ == 180) or (F_CPU_MHZ == 216) {
      USB0:CLK_RECOVER_IRC_EN = {USB0:CLK_RECOVER_IRC_EN !IRC_EN:1 !REG_EN:1}
      USB0:CLK_RECOVER_CTRL = {USB0:CLK_RECOVER_CTRL !CLOCK_RECOVER_EN:1 !RESTART_IFRTRIM_EN:1}
    }
  //--- Reset USB module (SB0:USBTRC0:USBRESET is always read as 0. Wait 2 USB clock cycles after setting this bit)
    USB0:USBTRC0 |= {USB0:USBTRC0 !USBRESET:1} // Page 1516
    while USB0:USBTRC0:USBRESET ≠ 0 {} // wait for reset to end
  //-- Set descriptor table base address
    let descriptorTableBaseAddress = addressof (self.descriptorTable)
    USB0:BDTPAGE1 = descriptorTableBaseAddress [08...15]
    USB0:BDTPAGE2 = descriptorTableBaseAddress [16...23]
    USB0:BDTPAGE3 = descriptorTableBaseAddress [24...31]
  //--- Enable weak pull-downs (???)
 //   SIM:USBPHYCTL = {SIM:USBPHYCTL !USB3VOUTTRG:6 !USBVREGPD:1 !USBVREGSEL:1}
  //--- Clear all ISR flags
    USB0:ISTAT = 0xFF
    USB0:ERRSTAT = 0xFF
    USB0:OTGISTAT = 0xFF
    USB0:INTEN = {USB0:INTEN !USBRSTEN:1} | 0x40
  //-- Enable USB
    USB0:CTL = {USB0:CTL !USBENOFEN:1}
    USB0:USBCTRL = 0
  //-- Enable reset interrupt
    USB0:INTEN = {USB0:INTEN !USBRSTEN:1}
  //-- Enable interrupt in NVIC
    enable (!interrupt: .USBFS_OTG)
  //--- Enable d+ pullup
    // USB0:OTGCTL = {USB0:OTGCTL !DPHIGH:1} // Page 1500
    USB0:CONTROL = {USB0:CONTROL !DPPULLNONOTG:1} // Page 1515
  }

  //····················································································································
  
  interrupt section USBFS_OTG {
    let status = USB0:ISTAT

    if (status & {USB0:ISTAT !USBRST:1}) ≠ 0 { // RESET: configure Endpoint 0
      self.état [self.indexÉtat] = 1
      self.indexÉtat = (self.indexÉtat + 1) % TRACE_SIZE
      USB0:CTL |= {USB0:CTL !ODDRST:1}
      self.ep0_tx_bdt_bank = 0
   //--- Set up buffers to receive Setup and OUT packets
      self.descriptorTable [index(!0 !RX !EVEN)].desc = BDT_DESC (!EP0_SIZE  !0)
      self.descriptorTable [index(!0 !RX !EVEN)].addr = addressof (self.ep0_rx0_buf)
      self.descriptorTable [index(!0 !RX !ODD) ].desc = BDT_DESC (!EP0_SIZE !0)
      self.descriptorTable [index(!0 !RX !ODD) ].addr = addressof (self.ep0_rx1_buf)
      self.descriptorTable [index(!0 !TX !EVEN)].desc = 0
      self.descriptorTable [index(!0 !TX !ODD) ].desc = 0
    //--- Activate endpoint 0
      USB0:ENDPT [0] = {USB0:ENDPT !EPRXEN:1 !EPTXEN:1 !EPHSHK:1}
    //--- Clear all ending interrupts
      USB0:ERRSTAT = 0xFF
      USB0:ISTAT = 0xFF
    //--- Set the address to zero during enumeration
      USB0:ADDR = 0
    //--- Enable other interrupts
      USB0:ERREN = 0xFF
      USB0:INTEN = {USB0:INTEN !STALLEN:1 !SLEEPEN:1 !TOKDNEEN:1 !SOFTOKEN:1 !ERROREN:1 !USBRSTEN:1}
    //--- is this necessary?
   //   USB0:CTL = {USB0:CTL !USBENOFEN:1} // Page 1507
    //  USB0:ISTAT = {USB0:ISTAT !USBRST:1} // Ack
    }else{
      if (status & {USB0:ISTAT !SOFTOK:1}) ≠ 0 {
        self.état [self.indexÉtat] = 2
        self.indexÉtat = (self.indexÉtat + 1) % TRACE_SIZE
        USB0:ISTAT = {USB0:ISTAT !SOFTOK:1} // Ack
      }
  
      if (status & {USB0:ISTAT !TOKDNE:1}) ≠ 0 { // Page 1502
        digital.write (!yes !toPort:LED_L2)
        self.état [self.indexÉtat] = 3
        self.indexÉtat = (self.indexÉtat + 1) % TRACE_SIZE
        let transactionStatus = USB0:STAT
        let endPoint $uint4 = transactionStatus [4...7]
  //      let TX_transitionStatus = transactionStatus [3...3].bool ()
  //      let ODD_transitionStatus = transactionStatus [2...2].bool ()
        if endPoint == 0 {
        }else{
        
        }
        USB0:ISTAT = {USB0:ISTAT !TOKDNE:1} // Ack
      }
  
      
      if (status & {USB0:ISTAT !STALL:1}) ≠ 0 {
        self.état [self.indexÉtat] = 4
        self.indexÉtat = (self.indexÉtat + 1) % TRACE_SIZE
        USB0:ISTAT = {USB0:ISTAT !STALL:1} // Ack
      }
  
      if (status & {USB0:ISTAT !ERROR:1}) ≠ 0 {
        self.état [self.indexÉtat] = 5
        self.indexÉtat = (self.indexÉtat + 1) % TRACE_SIZE
        let err = USB0:ERRSTAT
        USB0:ERRSTAT = err
        USB0:ISTAT = {USB0:ISTAT !ERROR:1} // Ack
      }
  
      if (status & {USB0:ISTAT !SLEEP:1}) ≠ 0 {
        self.état [self.indexÉtat] = 6
        self.indexÉtat = (self.indexÉtat + 1) % TRACE_SIZE
        USB0:ISTAT = {USB0:ISTAT !SLEEP:1} // Ack
    }
    }
  }
  
  //····················································································································
  
  interrupt section USB_HS_OTG {
    digital.write (!yes !toPort:LED_L4)
  }
  
  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

driver usb_device ()

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// TASK
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let LED_L0 = $digitalPort.D3

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

task T @priority 0 @stacksize 512 {
  var tick $uint32 = 0
  var état $uint32 = 0
  
  //····················································································································

  setup 1 {
    digital.set (!mode:.OUTPUT !toPort:.D13) // Led Teensy
    digital.set (!mode:.OUTPUT !toPort:LED_L0)
  }
  
  //····················································································································

  on time.wait (!untilDeadline:self.tick) {
    digital.toggle (!port:LED_L0)
    self.tick +%= 500
    lcd.goto (!line:0 !column:0)
    for i $uint32 in 0 ..< TRACE_SIZE {
      let e = usb_device.lireÉtat (!i)
      lcd.print (!hex2:e)
    }
    lcd.goto (!line:1 !column:0)
    lcd.print (!hex8:usb_device.lireAddresseUSB ())
    
  } 

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
