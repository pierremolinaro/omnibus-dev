//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  This eDMA demo shows how using DMA for outputing periodic signal
//  The output port is D13 (LED_BUILTIN), i.e. PTC5
//  Port D3 is toggled at PIT0 frequency
//  Port D4 is toggled at the end of PATTERN_LENGTH (major loop count) transfers
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// This code works on Teensy 3.6
// It has not been tested on Teensy 3.5
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// IT DOES NOT WORK ON TEENSY 3.1, THE MICRO-CONTROLLER IS BUGGY
//    The symptom is D4 blinks at 150 kHz, independantly from PATTERN_FREQUENCY 
//    See Mask Set Errata for Mask 1N36B: https://www.nxp.com/docs/en/errata/KINETIS_K_1N36B.pdf
//    Erratum ID e4588: Instead of sending a single DMA request every time the PIT expires, the first
//    time the PIT triggers a DMA transfer the “always enabled” source will not negate its request.
//    This results in the DMA request remaining asserted continuously after the first trigger.
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

target "teensy-3-6/privileged"
let F_CPU_MHZ = 180

module lcd (!DB4:.D16 !DB5:.D15 !DB6:.D14 !DB7:.D19 !RS:.D18 !ENABLE:.D17)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   ACTIVITY LED                                                                                                       
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func safe activityLedOn @exported () {
  digitalWrite (!port:.D13 !yes)
}

func safe activityLedOff @exported () {
  digitalWrite (!port:.D13 !no)
}

let LED_L0 = $digitalPort.D3
let LED_L4 = $digitalPort.D7
let LED_L3 = $digitalPort.D6
let LED_L2 = $digitalPort.D5

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

init 1000 {
  pinMode (!port:.D13 !mode:.OUTPUT) // Led Teensy
  pinMode (!port:LED_L0 !mode:.OUTPUT)
  pinMode (!port:LED_L3 !mode:.OUTPUT)
  pinMode (!port:LED_L2 !mode:.OUTPUT)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let PATTERN_FREQUENCY = 5 // In Hertz
// So LED_L3 frequency is PATTERN_FREQUENCY / 2
// So D4 frequency is PATTERN_FREQUENCY / 2 / PATTERN_LENGTH

staticArray kPATTERN {let x $bool }

extend staticArray kPATTERN ( // Morse code example: output "S S S ..."
  yes; no; yes; no; yes; // 3 dots : letter S
  no; no; no; no; no; no; no // Medium gap betwween words
)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————
// eDMA module cannot access GPIO from aliased bit-band regions.
// eDMA module can access:
//    - GPIOx_PDOR (but it changes all bits of the given GPIO x)
//    - GPIOx_PSOR (it sets selected bits of the given GPIO x, but cannot reset them)
//    - GPIOx_PCOR (it resets selected bits of the given GPIO x, but cannot set them)
//    - GPIOx_PTOR (it toggles selected bits of the given GPIO x)
// So we use GPIOx_PTOR

// The output port is D7: PTD2
// For toggling D7, without any change on other GPIOC bits: "GPIOD_PTOR = (1 << 2)"
// "GPIOD_PTOR = 0 ;" is a nop
// So we need to transform the kPATTERN boolean array to the gOutputPattern uint32_t array, that will
// contains (1 << 2) for toggling PTD2 port, and 0 for not changing it: the values
// are not the kPATTERN values, but the toggles we need to output the given pattern.
// Building the gOutputPattern array is done at the beginning of the setup function.

let PATTERN_LENGTH = kPATTERN.count

type $patternArray : $uint32 [PATTERN_LENGTH]

var gOutputPattern = $patternArray (!repeated:0)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

isr safe PITChannel0 {
//--- Acquitter l'interruption
  PIT_TFLG [0] = {PIT_TFLG !TIF:1}
//--- Toggle LED_L3
  toggle (!port:LED_L3)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

isr safe DMAChannel_0_16_TransferComplete {
//--- Acquitter l'interruption
  DMA_CINT = 0
//--- Toggle LED_L2
  toggle (!port:LED_L2)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

system section initializeDMA () {
//--- Transform pattern for encoding level changes
  var current = no ;
  var index $uint32 = 0
  for élément in kPATTERN {
    let b = élément.x
    gOutputPattern [index] = if current ≠ b { 0 } else { 1 << 2 }
    index += 1
    current = b
  }
//--- Set up LED_BUILTIN digital output at LOW level
  pinMode (!port:LED_L4 !mode:.OUTPUT)
  digitalWrite (!port:LED_L4 !no)

//--- Power on DMA_MUX, PIT, DMA
  SIM_SCGC6 |= {SIM_SCGC6 !DMAMUX:1 !PIT:1}
  SIM_SCGC7 |= {SIM_SCGC7 !DMA:1}

//--- Unmask PIT0 interrupt
  enable (!interrupt:.PITChannel0)

//--- Unmask DMAChannel_0_16_TransferComplete interrupt
  enable (!interrupt:.DMAChannel_0_16_TransferComplete)

//--- Enable PIT module
  PIT_MCR = 0

//--- Disable PIT0
  PIT_TCTRL [0] = 0

//--- PIT0 clock frequency is F_BUS (in Hertz): PIT_LDVAL0 sets the request period of DMA 0
  PIT_LDVAL [0] = ((F_BUS_MHZ * 1_000_000) / PATTERN_FREQUENCY) - 1

//--- Clear PIT 0 interrupt flag
  PIT_TFLG [0] = 1

//--- Disable DMA Channel 0: it is required for configuring it
  DMAMUX_CHCFG [0] = 0

//--- Initial source address: the gOutputPattern array address
  DMA_TCD_SADDR [0] = addressof (gOutputPattern)

//--- After every request, source address is incremented by 4
  DMA_TCD_SOFF [0] = 4

//--- At the end of a major loop, source address is decremented to gOutputPattern array address
  DMA_TCD_SLAST [0] = - 4 * PATTERN_LENGTH // - transfert_size * major_loop_count

//--- Destination address: the address of the GPIOC_PTOR control register
  DMA_TCD_DADDR [0] = addressof (GPIOD_PTOR)

//--- After every request, destination address is not modified
  DMA_TCD_DOFF [0] = 0

//--- At the end of a major loop, destination address is not modified
  DMA_TCD_DLASTSGA [0] = 0

//--- Set major loop count
  DMA_TCD_CITER_ELINKNO [0] = PATTERN_LENGTH
  DMA_TCD_BITER_ELINKNO [0] = PATTERN_LENGTH

//--- Source and destination are 32-bit
  DMA_TCD_ATTR [0] = {DMA_TCD_ATTR
    !SSIZE: DMA_TCD_ATTR_SIZE_32BIT // Transfer source size is 32-bit
    !DSIZE: DMA_TCD_ATTR_SIZE_32BIT // Transfer destination size is 32-bit
  }
 
//--- Number of bytes to transfer per request: 4
  DMA_TCD_NBYTES_MLNO [0] = 4

//--- Set repetition and DMA interrupt
// if DREQ bit is set, the DMA performs PATTERN_LENGTH transfers and stops)
// Otherwise, the DMA performs PATTERN_LENGTH transfers repetitively
  DMA_TCD_CSR [0] = {DMA_TCD_CSR
    !INTMAJOR:1 // Generate an interrupt at the end of major loop count transfert (for toggling D4)
   // | DMA_TCD_CSR_DREQ // For setting DREQ bit
  }

//--- Configure DMA Channel
  DMAMUX_CHCFG [0] = {DMAMUX_CHCFG
    !ENABLE:1 // DMA Channel 0 is enabled
    !TRIG:1   // DMA Channel 0 is triggered by PIT 0
    !SOURCE:DMAMUX_SOURCE_ALWAYS0 // Trigger is always active
  }

//--- Start DMA Channel 0
  DMA_SERQ = 0

//--- Enable PIT 0 : it starts counting, enable interrupt
  PIT_TCTRL [0] = {PIT_TCTRL !TEN:1 !TIE:1}
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

task Tâche priority 1 stackSize 512 {
  var compteur $uint32 = 0
 
  setup 1 {
    initializeDMA ()
  }
  
  on time.waitUntilMS (!deadline:self.compteur) {
    digitalWrite (!port:LED_L0 !yes)
    self.compteur +%= 500
    time.waitUntilMS (!deadline: self.compteur)
    digitalWrite (!port:LED_L0 !no)
    self.compteur +%= 500
    lcd.goto (!line:0 !column:0)
    lcd.print (!unsigned:gOutputPattern.count)
    lcd.print (!string:" ")
    let cc = $isrSlot.PITChannel0.uint7 ()
    lcd.print (!unsigned:extend (cc))
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
