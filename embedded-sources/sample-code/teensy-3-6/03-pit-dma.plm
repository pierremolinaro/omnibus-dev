//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  This eDMA demo shows how using DMA for outputing periodic signal
//  The output port is D13 (LED_BUILTIN), i.e. PTC5
//  Port D3 is toggled at PIT0 frequency
//  Port D4 is toggled at the end of PATTERN_LENGTH (major loop count) transfers
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// This code works on Teensy 3.6
// It has not been tested on Teensy 3.5
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// IT DOES NOT WORK ON TEENSY 3.1, THE MICRO-CONTROLLER IS BUGGY
//    The symptom is D4 blinks at 150 kHz, independantly from PATTERN_FREQUENCY 
//    See Mask Set Errata for Mask 1N36B: https://www.nxp.com/docs/en/errata/KINETIS_K_1N36B.pdf
//    Erratum ID e4588: Instead of sending a single DMA request every time the PIT expires, the first
//    time the PIT triggers a DMA transfer the “always enabled” source will not negate its request.
//    This results in the DMA request remaining asserted continuously after the first trigger.
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

target "teensy-3-6/privileged"
let F_CPU_MHZ = 180

module lcd (!DB4:.D16 !DB5:.D15 !DB6:.D14 !DB7:.D19 !RS:.D18 !ENABLE:.D17)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   ACTIVITY LED                                                                                                       
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func safe activityLedOn @exported () {
  digitalWrite (!port:.D13 !yes)
}

func safe activityLedOff @exported () {
  digitalWrite (!port:.D13 !no)
}

let LED_L0 = $digitalPort.D3
let LED_L4 = $digitalPort.D7

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

init 1000 {
  pinMode (!port:.D13 !mode:.OUTPUT) // Led Teensy
  pinMode (!port:LED_L0 !mode:.OUTPUT)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let PATTERN_FREQUENCY = 5 // In Hertz
// So D3 frequency is PATTERN_FREQUENCY / 2
// So D4 frequency is PATTERN_FREQUENCY / 2 / PATTERN_LENGTH

staticArray kPATTERN {let x $bool }
extend staticArray kPATTERN ( // Morse code example: output "S S S ..."
  yes; no; yes; no; yes; // 3 dots : letter S
  no; no; no; no; no; no; no // Medium gap betwween words
)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————
// eDMA module cannot access GPIO from aliased bit-band regions.
// eDMA module can access:
//    - GPIOx_PDOR (but it changes all bits of the given GPIO x)
//    - GPIOx_PSOR (it sets selected bits of the given GPIO x, but cannot reset them)
//    - GPIOx_PCOR (it resets selected bits of the given GPIO x, but cannot set them)
//    - GPIOx_PTOR (it toggles selected bits of the given GPIO x)
// So we use GPIOx_PTOR

// The output port is D7: PTD2
// For toggling D7, without any change on other GPIOC bits: "GPIOD_PTOR = (1 << 2)"
// "GPIOD_PTOR = 0 ;" is a nop
// So we need to transform the kPATTERN boolean array to the gOutputPattern uint32_t array, that will
// contains (1 << 2) for toggling PTD2 port, and 0 for not changing it: the values
// are not the kPATTERN values, but the toggles we need to output the given pattern.
// Building the gOutputPattern array is done at the beginning of the setup function.

let PATTERN_LENGTH = kPATTERN.count

type $patternArray : $uint32 [PATTERN_LENGTH]

var gOutputPattern = $patternArray ()

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

task Tâche priority 1 stackSize 512 {
  var compteur $uint32 = 0
  
  setup 1 {
  //--- Transform pattern for encoding level changes
    var current = no ;
    var index $uint32 = 0
    for élément in kPATTERN {
      let b = élément.x
      gOutputPattern [index] = if current ≠ b { 0 } else { 1 << 2 }
      index += 1
      current = b
    }
  //--- Set up LED_BUILTIN digital output at LOW level
    pinMode (!port:LED_L4 !mode:.OUTPUT)
    digitalWrite (!port:LED_L4 !no)
  
  //--- Power on DMA_MUX, PIT, DMA
    SIM_SCGC6 |= {SIM_SCGC6 !DMAMUX:1 !PIT:1}
    SIM_SCGC7 |= {SIM_SCGC7 !DMA:1}
  
  //--- Enable PIT module
    PIT_MCR = 0
  
  //--- Disable PIT0
    PIT_TCTRL [0] = 0
  
  //--- PIT0 clock frequency is F_BUS (in Hertz): PIT_LDVAL0 sets the request period of DMA 0
    PIT_LDVAL [0] = ((F_BUS_MHZ * 1_000_000) / PATTERN_FREQUENCY) - 1
  
  //--- Clear PIT 0 interrupt flag
    PIT_TFLG [0] = 1
  
  //--- Disable DMA Channel 0: it is required for configuring it
    DMAMUX_CHCFG [0] = 0
  
  //--- Initial source address: the gOutputPattern array address
    DMA_TCD_SADDR [0] = addressof (gOutputPattern)
  
  //--- After every request, source address is incremented by 4
    DMA_TCD_SOFF [0] = 4
  
  //--- At the end of a major loop, source address is decremented to gOutputPattern array address
    DMA_TCD_SLAST [0] = - 4 * PATTERN_LENGTH // - transfert_size * major_loop_count
  
  //--- Destination address: the address of the GPIOC_PTOR control register
    DMA_TCD_DADDR [0] = addressof (GPIOD_PTOR)
  
  //--- After every request, destination address is not modified
    DMA_TCD_DOFF [0] = 0
  
  //--- At the end of a major loop, destination address is not modified
    DMA_TCD_DLASTSGA [0] = 0
  
  //--- Set major loop count
    DMA_TCD_CITER_ELINKNO [0] = PATTERN_LENGTH
    DMA_TCD_BITER_ELINKNO [0] = PATTERN_LENGTH
  
  //--- Source and destination are 32-bit
    DMA_TCD_ATTR [0] = {DMA_TCD_ATTR
      !SSIZE: DMA_TCD_ATTR_SIZE_32BIT // Transfer source size is 32-bit
      !DSIZE: DMA_TCD_ATTR_SIZE_32BIT // Transfer destination size is 32-bit
    }
   
  //--- Number of bytes to transfer per request: 4
    DMA_TCD_NBYTES_MLNO [0] = 4
  
  //--- Set repetition and DMA interrupt
  // if DREQ bit is set, the DMA performs PATTERN_LENGTH transfers and stops)
  // Otherwise, the DMA performs PATTERN_LENGTH transfers repetitively
    DMA_TCD_CSR [0] = {DMA_TCD_CSR
      !INTMAJOR:1 // Generate an interrupt at the end of major loop count transfert (for toggling D4)
     // | DMA_TCD_CSR_DREQ // For setting DREQ bit
    }

  //--- Configure DMA Channel
    DMAMUX_CHCFG [0] = {DMAMUX_CHCFG
      !ENABLE:1 // DMA Channel 0 is enabled
      !TRIG:1   // DMA Channel 0 is triggered by PIT 0
      !SOURCE:DMAMUX_SOURCE_ALWAYS0 // Trigger is always active
    }

  //--- Start DMA Channel 0
    DMA_SERQ = 0
  
  //--- Enable PIT 0 : it starts counting
    PIT_TCTRL [0] = {PIT_TCTRL !TEN:1}
  }
  
  while time.waitUntilMS (!deadline:self.compteur) {
    digitalWrite (!port:LED_L0 !yes)
    self.compteur +%= 500
    time.waitUntilMS (!deadline: self.compteur)
    digitalWrite (!port:LED_L0 !no)
    self.compteur +%= 500
    lcd.goto (!line:0 !column:0)
    lcd.printUnsigned (!gOutputPattern.count)
    lcd.printString (!" ")
    lcd.printUnsigned (!$patternArray.count)
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
