//——————————————————————————————————————————————————————————————————————————————
//   SYNCHRONIZATION TOOLS ROUTINES
//——————————————————————————————————————————————————————————————————————————————

type $taskList : ((32)) @instantiable

//--- Block running task
extern func primitive block (?!inList:ioWaitingList $taskList) : "blockInList"

extern func primitive block (?onDeadline:inDeadline $uint32) : "blockOnDeadline"

extern func primitive block (?!inList:ioWaitingList $taskList
                           ?onDeadline:inDeadline $uint32) : "blockInListAndOnDeadline"

//--- Make task Ready
extern func service
makeTaskReady (?!fromList:ioWaitingList $taskList
               !found: outFound $bool) : "makeTaskReady"

extern func service makeTasksReady (?fromCurrentDate:inCurrentDate $uint32) : "makeTasksReadyFromCurrentDate"

//——————————————————————————————————————————————————————————————————————————————
//   GUARD
//——————————————————————————————————————————————————————————————————————————————

type $guardList : ((32)) @instantiable

extern func guard handle (?!guard:ioGuard $guardList) : "handleGuardedCommand"

extern func guard handle (?guardedDeadline:inDeadlineMS $uint32) : "handleGuardedWaitUntil"

extern func service notifyChange (?!forGuard:ioGuard $guardList) : "guardDidChange"

extern func service notifyChangeForGuardedWaitUntil (?withCurrentDate:inCurrentDate $uint32) : "tickHandlerForGuardedWaitUntil"

//——————————————————————————————————————————————————————————————————————————————

let TIMER_PRESCALER = 6
let TICKS_PER_MILLISECONDS = 10000

//——————————————————————————————————————————————————————————————————————————————

init 100 {
//--- Program pin P1.23 as an output (STAT led)
  IO1DIR |= 1 << 23
  IO1CLR  = 1 << 23 // Led On
//-------------------------------- Timer 1
//--- 1. Set Prescaler
  TIMER1_PR = TIMER_PRESCALER - 1
//--- 2. Set Match Register 0
//    We want an interrupt every millisecond
  TIMER1_MR0 = TICKS_PER_MILLISECONDS - 1
//--- 2. Set Count control Register
//    Bits 1-0: 00 (timer mode)
//    Bits 3-2: XX (any value, because timer mode)
  TIMER1_CCR = 0
//--- 3. Match Control Register
//    Bit 0: 1 (interrupt on MR0 match)
//    Bit 1: 1 (reset on MR0 match)
//    Bit 2: 0 (do not stop on MR0 match)
//    Bit 5-3: 000 (MR1 not used)
//    Bit 8-6: 000 (MR2 not used)
//    Bit 11-9: 000 (MR3 not used)
  TIMER1_MCR = 3
//--- 4. Use vector 9 for TIMER1 interrupt
//  sys_installInterruptServiceRoutine (MODE_ TIMER1InterruptServiceRoutine, 5) ;
//  VICVectAddr9 = (uint32_t) TIMER1InterruptServiceRoutine ;
//  VICVectCntl9 = 0x20 | 5 ; // Timer interrupt number is #5
//--- 5. Use IRQ for tracking MR0 matches
//  TIMER1 gets interruption #5 (mask: 0x20)
//  VICIntEnClr   = 1 << 5 ; // Timer1 interrupt generates IRQ
//  VICIntEnable |= 1 << 5 ; // Enable Timer1 interrupt
//--- 6. Start Counter 0 (Timer Control Register)
// Bit 0 : 1 (Enables counting)
// Bit 1 : 0 (No reset)
  TIMER1_TCR = 1
}

module time ()

//——————————————————————————————————————————————————————————————————————————————

module time {

  //············································································

  var mUptimeMS $uint32 = 0

  //············································································

  public func safe kernelMillis @noUnusedWarning () -> $uint32 {
    result = self.mUptimeMS
  }

  //············································································

  public system section millis @noUnusedWarning () -> $uint32 {
    result = self.mUptimeMS
  }

  //············································································

  isr service TIMER1 {
    TIMER1_IR = 1 // Clears MR0 interrupt
    let now = self.mUptimeMS +% 1
    self.mUptimeMS = now
    makeTasksReady (!fromCurrentDate:now)
    notifyChangeForGuardedWaitUntil (!withCurrentDate:now)
  }

  //············································································

  public system primitive waitUntilMS @noUnusedWarning (?deadline: inDate $uint32) {
    if inDate > self.kernelMillis () {
      block (!onDeadline:inDate)
    }
  }

  //············································································

  public func user waitDuringMS @noUnusedWarning @mutating @userAccess (?delay: inDelay $uint32) {
    self.waitUntilMS (!deadline:self.millis () + inDelay)
  }

  //············································································

  public guard waitUntilMS @noUnusedWarning (?deadline:inDeadline $uint32) {
    accept = inDeadline <= self.kernelMillis ()
    if not accept {
      handle (!guardedDeadline:inDeadline)
    }
  }

  //············································································

}

//——————————————————————————————————————————————————————————————————————————————
