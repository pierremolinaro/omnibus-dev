//——————————————————————————————————————————————————————————————————————————————
//   SYNCHRONIZATION TOOLS ROUTINES
//——————————————————————————————————————————————————————————————————————————————

newtype $taskList : [[32]] @instantiable

//--- Block running task
extern func primitive block (?!inList:ioWaitingList $taskList) : "blockInList"

extern func primitive block (?onDeadline:inDeadline $uint32) : "blockOnDeadline"

extern func primitive
block (?!inList:ioWaitingList $taskList
       ?onDeadline:inDeadline $uint32
       ?!result: ioResult $bool) : "block.in.list.and.on.deadline"

//--- Make task Ready
extern func service
makeTaskReady (?!fromList:ioWaitingList $taskList
               !found: outFound $bool) : "makeTaskReady"

extern func service makeTasksReady (?fromCurrentDate:inCurrentDate $uint32) : "makeTasksReadyFromCurrentDate"

//——————————————————————————————————————————————————————————————————————————————
//   GUARD
//——————————————————————————————————————————————————————————————————————————————

newtype $guardList : [[32]] @instantiable

extern func guard handle (?!guard:ioGuard $guardList) : "handleGuardedCommand"

extern func guard handle (?guardedDeadline:inDeadlineMS $uint32) : "handleGuardedWaitUntil"

extern func service notifyChange (?!forGuard:ioGuard $guardList) : "notify.change.from.guard.list"

extern func service notifyChangeForGuardedWaitUntil (?withCurrentDate:inCurrentDate $uint32) : "notify.change.for.guarded.wait.until"

//——————————————————————————————————————————————————————————————————————————————

let TIMER_PRESCALER = 6
let TICKS_PER_MILLISECONDS = 10000

//——————————————————————————————————————————————————————————————————————————————

driver time ()

//——————————————————————————————————————————————————————————————————————————————

driver time {

  //············································································

  init {
  //--- Program pin P1.23 as an output (STAT led)
    IO1DIR |= 1 << 23
    IO1CLR  = 1 << 23 // Led On
  //-------------------------------- Timer 1
  //--- 1. Set Prescaler
    TIMER1_PR = TIMER_PRESCALER - 1
  //--- 2. Set Match Register 0
  //    We want an interrupt every millisecond
    TIMER1_MR0 = TICKS_PER_MILLISECONDS - 1
  //--- 2. Set Count control Register
  //    Bits 1-0: 00 (timer mode)
  //    Bits 3-2: XX (any value, because timer mode)
    TIMER1_CCR = 0
  //--- 3. Match Control Register
  //    Bit 0: 1 (interrupt on MR0 match)
  //    Bit 1: 1 (reset on MR0 match)
  //    Bit 2: 0 (do not stop on MR0 match)
  //    Bit 5-3: 000 (MR1 not used)
  //    Bit 8-6: 000 (MR2 not used)
  //    Bit 11-9: 000 (MR3 not used)
    TIMER1_MCR = 3
  //--- 4. Use vector 9 for TIMER1 interrupt
  //  sys_installInterruptServiceRoutine (MODE_ TIMER1InterruptServiceRoutine, 5) ;
  //  VICVectAddr9 = (uint32_t) TIMER1InterruptServiceRoutine ;
  //  VICVectCntl9 = 0x20 | 5 ; // Timer interrupt number is #5
  //--- 5. Use IRQ for tracking MR0 matches
  //  TIMER1 gets interruption #5 (mask: 0x20)
  //  VICIntEnClr   = 1 << 5 ; // Timer1 interrupt generates IRQ
  //  VICIntEnable |= 1 << 5 ; // Enable Timer1 interrupt
  //--- 6. Start Counter 0 (Timer Control Register)
  // Bit 0 : 1 (Enables counting)
  // Bit 1 : 0 (No reset)
    TIMER1_TCR = 1
  }

  //············································································

  var mUptime $uint32 = 0

  //············································································

  public system safe now @noUnusedWarning () -> $uint32 {
    result = self.mUptime
  }

  //············································································

  isr service TIMER1 {
    TIMER1_IR = 1 // Clears MR0 interrupt
    let now = self.mUptime +% 1
    self.mUptime = now
    makeTasksReady (!fromCurrentDate:now)
    notifyChangeForGuardedWaitUntil (!withCurrentDate:now)
  }

  //············································································

  public system primitive wait @noUnusedWarning (?untilDeadline: inDate $uint32) {
    if inDate > self.now () {
      block (!onDeadline:inDate)
    }
  }

  //············································································

  public func user wait @noUnusedWarning @mutating @userAccess (?duringDelay: inDelay $uint32) {
    self.wait (!untilDeadline:self.now () + inDelay)
  }

  //············································································

  public guard wait @noUnusedWarning (?untilDeadline:inDeadline $uint32) {
    accept = inDeadline ≤ self.now ()
    if not accept {
      handle (!guardedDeadline:inDeadline)
    }
  }

  //············································································

}

//——————————————————————————————————————————————————————————————————————————————
