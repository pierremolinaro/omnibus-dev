//------------------------------------------------------------------------------
// MK66F18: MK66F18 Freescale Microcontroller
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©ADC [2]
//        ADC0 at 0x4003b000
//        ADC1 at 0x400bb000
//------------------------------------------------------------------------------

registers ©ADC [2 @at 0x4003b000 0x400bb000]
          ©ADC0 @at 0x4003b000
          ©ADC1 @at 0x400bb000 {
//---  Registers SC1(A,B): ADC Status and Control Registers 1
  SC1 [2 @offset 0x0 @inc 0x4]
  SC1A @offset 0x0
  SC1B @offset 0x4 $u32 {
    24
    COCO // at 7: Conversion Complete Flag
    AIEN // at 6: Interrupt Enable
    DIFF // at 5: Differential Mode Enable
    ADCH:5 // at 0: Input channel select
  }

//---  Register CFG1: ADC Configuration Register 1
  CFG1 @offset 0x8 $u32 {
    24
    ADLPC // at 7: Low-Power Configuration
    ADIV:2 // at 5: Clock Divide Select
    ADLSMP // at 4: Sample Time Configuration
    MODE:2 // at 2: Conversion mode selection
    ADICLK:2 // at 0: Input Clock Select
  }

//---  Register CFG2: ADC Configuration Register 2
  CFG2 @offset 0xc $u32 {
    27
    MUXSEL // at 4: ADC Mux Select
    ADACKEN // at 3: Asynchronous Clock Output Enable
    ADHSC // at 2: High-Speed Configuration
    ADLSTS:2 // at 0: Long Sample Time Select
  }

//---  Registers R(A,B): ADC Data Result Register
  R [2 @offset 0x10 @inc 0x4]
  RA @offset 0x10 @ro
  RB @offset 0x14 @ro $u32 {
    16
    D:16 // at 0: Data result
  }

//---  Registers CV(1,2): Compare Value Registers
  CV [2 @offset 0x18 @inc 0x4]
  CV1 @offset 0x18
  CV2 @offset 0x1c $u32 {
    16
    CV:16 // at 0: Compare Value.
  }

//---  Register SC2: Status and Control Register 2
  SC2 @offset 0x20 $u32 {
    24
    ADACT // at 7: Conversion Active
    ADTRG // at 6: Conversion Trigger Select
    ACFE // at 5: Compare Function Enable
    ACFGT // at 4: Compare Function Greater Than Enable
    ACREN // at 3: Compare Function Range Enable
    DMAEN // at 2: DMA Enable
    REFSEL:2 // at 0: Voltage Reference Selection
  }

//---  Register SC3: Status and Control Register 3
  SC3 @offset 0x24 $u32 {
    24
    CAL // at 7: Calibration
    CALF // at 6: Calibration Failed Flag
    2
    ADCO // at 3: Continuous Conversion Enable
    AVGE // at 2: Hardware Average Enable
    AVGS:2 // at 0: Hardware Average Select
  }

//---  Register OFS: ADC Offset Correction Register
  OFS @offset 0x28 $u32 {
    16
    OFS:16 // at 0: Offset Error Correction Value
  }

//---  Register PG: ADC Plus-Side Gain Register
  PG @offset 0x2c $u32 {
    16
    PG:16 // at 0: Plus-Side Gain
  }

//---  Register MG: ADC Minus-Side Gain Register
  MG @offset 0x30 $u32 {
    16
    MG:16 // at 0: Minus-Side Gain
  }

//---  Register CLPD: ADC Plus-Side General Calibration Value Register
  CLPD @offset 0x34 $u32 {
    26
    CLPD:6 // at 0: Calibration Value
  }

//---  Register CLPS: ADC Plus-Side General Calibration Value Register
  CLPS @offset 0x38 $u32 {
    26
    CLPS:6 // at 0: Calibration Value
  }

//---  Register CLP4: ADC Plus-Side General Calibration Value Register
  CLP4 @offset 0x3c $u32 {
    22
    CLP4:10 // at 0: Calibration Value
  }

//---  Register CLP3: ADC Plus-Side General Calibration Value Register
  CLP3 @offset 0x40 $u32 {
    23
    CLP3:9 // at 0: Calibration Value
  }

//---  Register CLP2: ADC Plus-Side General Calibration Value Register
  CLP2 @offset 0x44 $u32 {
    24
    CLP2:8 // at 0: Calibration Value
  }

//---  Register CLP1: ADC Plus-Side General Calibration Value Register
  CLP1 @offset 0x48 $u32 {
    25
    CLP1:7 // at 0: Calibration Value
  }

//---  Register CLP0: ADC Plus-Side General Calibration Value Register
  CLP0 @offset 0x4c $u32 {
    26
    CLP0:6 // at 0: Calibration Value
  }

//---  Register CLMD: ADC Minus-Side General Calibration Value Register
  CLMD @offset 0x54 $u32 {
    26
    CLMD:6 // at 0: Calibration Value
  }

//---  Register CLMS: ADC Minus-Side General Calibration Value Register
  CLMS @offset 0x58 $u32 {
    26
    CLMS:6 // at 0: Calibration Value
  }

//---  Register CLM4: ADC Minus-Side General Calibration Value Register
  CLM4 @offset 0x5c $u32 {
    22
    CLM4:10 // at 0: Calibration Value
  }

//---  Register CLM3: ADC Minus-Side General Calibration Value Register
  CLM3 @offset 0x60 $u32 {
    23
    CLM3:9 // at 0: Calibration Value
  }

//---  Register CLM2: ADC Minus-Side General Calibration Value Register
  CLM2 @offset 0x64 $u32 {
    24
    CLM2:8 // at 0: Calibration Value
  }

//---  Register CLM1: ADC Minus-Side General Calibration Value Register
  CLM1 @offset 0x68 $u32 {
    25
    CLM1:7 // at 0: Calibration Value
  }

//---  Register CLM0: ADC Minus-Side General Calibration Value Register
  CLM0 @offset 0x6c $u32 {
    26
    CLM0:6 // at 0: Calibration Value
  }

}

//--- Enumerated values for register SC1%s, field ADCH
  let ADC0_SC1_ADCH_When_00000 $u5 = 0 // When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
  let ADC0_SC1_ADCH_When_00001 $u5 = 1 // When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
  let ADC0_SC1_ADCH_When_00010 $u5 = 2 // When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
  let ADC0_SC1_ADCH_When_00011 $u5 = 3 // When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
  let ADC0_SC1_ADCH_When_00100 $u5 = 4 // When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_00101 $u5 = 5 // When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_00110 $u5 = 6 // When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_00111 $u5 = 7 // When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01000 $u5 = 8 // When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01001 $u5 = 9 // When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01010 $u5 = 10 // When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01011 $u5 = 11 // When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01100 $u5 = 12 // When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01101 $u5 = 13 // When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01110 $u5 = 14 // When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_01111 $u5 = 15 // When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10000 $u5 = 16 // When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10001 $u5 = 17 // When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10010 $u5 = 18 // When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10011 $u5 = 19 // When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10100 $u5 = 20 // When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10101 $u5 = 21 // When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10110 $u5 = 22 // When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_10111 $u5 = 23 // When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
  let ADC0_SC1_ADCH_When_11010 $u5 = 26 // When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
  let ADC0_SC1_ADCH_When_11011 $u5 = 27 // When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap (differential) is selected as input.
  let ADC0_SC1_ADCH_When_11101 $u5 = 29 // When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2[REFSEL].
  let ADC0_SC1_ADCH_When_11110 $u5 = 30 // When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2[REFSEL].
  let ADC0_SC1_ADCH_Module_11111 $u5 = 31 // Module is disabled.

//--- Enumerated values for register SC1%s, field DIFF
  let ADC0_SC1_DIFF_Single_ended_0 $bool = no // Single-ended conversions and input channels are selected.
  let ADC0_SC1_DIFF_Differential_1 $bool = yes // Differential conversions and input channels are selected.

//--- Enumerated values for register SC1%s, field AIEN
  let ADC0_SC1_AIEN_Conversion_0 $bool = no // Conversion complete interrupt is disabled.
  let ADC0_SC1_AIEN_Conversion_1 $bool = yes // Conversion complete interrupt is enabled.

//--- Enumerated values for register SC1%s, field COCO
  let ADC0_SC1_COCO_Conversion_0 $bool = no // Conversion is not completed.
  let ADC0_SC1_COCO_Conversion_1 $bool = yes // Conversion is completed.

//--- Enumerated values for register CFG1, field ADICLK
  let ADC0_CFG1_ADICLK_Bus_00 $u2 = 0 // Bus clock
  let ADC0_CFG1_ADICLK_Bus_01 $u2 = 1 // Bus clock divided by 2(BUSCLK/2)
  let ADC0_CFG1_ADICLK_Alternate_10 $u2 = 2 // Alternate clock (ALTCLK)
  let ADC0_CFG1_ADICLK_Asynchronous_11 $u2 = 3 // Asynchronous clock (ADACK)

//--- Enumerated values for register CFG1, field MODE
  let ADC0_CFG1_MODE_When_00 $u2 = 0 // When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is differential 9-bit conversion with 2's complement output.
  let ADC0_CFG1_MODE_When_01 $u2 = 1 // When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is differential 13-bit conversion with 2's complement output.
  let ADC0_CFG1_MODE_When_10 $u2 = 2 // When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is differential 11-bit conversion with 2's complement output
  let ADC0_CFG1_MODE_When_11 $u2 = 3 // When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is differential 16-bit conversion with 2's complement output

//--- Enumerated values for register CFG1, field ADLSMP
  let ADC0_CFG1_ADLSMP_Short_0 $bool = no // Short sample time.
  let ADC0_CFG1_ADLSMP_Long_1 $bool = yes // Long sample time.

//--- Enumerated values for register CFG1, field ADIV
  let ADC0_CFG1_ADIV_The_00 $u2 = 0 // The divide ratio is 1 and the clock rate is input clock.
  let ADC0_CFG1_ADIV_The_01 $u2 = 1 // The divide ratio is 2 and the clock rate is (input clock)/2.
  let ADC0_CFG1_ADIV_The_10 $u2 = 2 // The divide ratio is 4 and the clock rate is (input clock)/4.
  let ADC0_CFG1_ADIV_The_11 $u2 = 3 // The divide ratio is 8 and the clock rate is (input clock)/8.

//--- Enumerated values for register CFG1, field ADLPC
  let ADC0_CFG1_ADLPC_Normal_0 $bool = no // Normal power configuration.
  let ADC0_CFG1_ADLPC_Low_power_1 $bool = yes // Low-power configuration. The power is reduced at the expense of maximum clock speed.

//--- Enumerated values for register CFG2, field ADLSTS
  let ADC0_CFG2_ADLSTS_Default_00 $u2 = 0 // Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles total.
  let ADC0_CFG2_ADLSTS_12_01 $u2 = 1 // 12 extra ADCK cycles; 16 ADCK cycles total sample time.
  let ADC0_CFG2_ADLSTS_6_10 $u2 = 2 // 6 extra ADCK cycles; 10 ADCK cycles total sample time.
  let ADC0_CFG2_ADLSTS_2_11 $u2 = 3 // 2 extra ADCK cycles; 6 ADCK cycles total sample time.

//--- Enumerated values for register CFG2, field ADHSC
  let ADC0_CFG2_ADHSC_Normal_0 $bool = no // Normal conversion sequence selected.
  let ADC0_CFG2_ADHSC_High_speed_1 $bool = yes // High-speed conversion sequence selected with 2 additional ADCK cycles to total conversion time.

//--- Enumerated values for register CFG2, field ADACKEN
  let ADC0_CFG2_ADACKEN_Asynchronous_0 $bool = no // Asynchronous clock output disabled; Asynchronous clock is enabled only if selected by ADICLK and a conversion is active.
  let ADC0_CFG2_ADACKEN_Asynchronous_1 $bool = yes // Asynchronous clock and clock output is enabled regardless of the state of the ADC.

//--- Enumerated values for register CFG2, field MUXSEL
  let ADC0_CFG2_MUXSEL_ADxxa_0 $bool = no // ADxxa channels are selected.
  let ADC0_CFG2_MUXSEL_ADxxb_1 $bool = yes // ADxxb channels are selected.

//--- Enumerated values for register SC2, field REFSEL
  let ADC0_SC2_REFSEL_Default_00 $u2 = 0 // Default voltage reference pin pair, that is, external pins VREFH and VREFL
  let ADC0_SC2_REFSEL_Alternate_01 $u2 = 1 // Alternate reference pair, that is, VALTH and VALTL . This pair may be additional external pins or internal sources depending on the MCU configuration. See the chip configuration information for details specific to this MCU

//--- Enumerated values for register SC2, field DMAEN
  let ADC0_SC2_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let ADC0_SC2_DMAEN_DMA_1 $bool = yes // DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event noted when any of the SC1n[COCO] flags is asserted.

//--- Enumerated values for register SC2, field ACREN
  let ADC0_SC2_ACREN_Range_0 $bool = no // Range function disabled. Only CV1 is compared.
  let ADC0_SC2_ACREN_Range_1 $bool = yes // Range function enabled. Both CV1 and CV2 are compared.

//--- Enumerated values for register SC2, field ACFGT
  let ADC0_SC2_ACFGT_Configures_0 $bool = no // Configures less than threshold, outside range not inclusive and inside range not inclusive; functionality based on the values placed in CV1 and CV2.
  let ADC0_SC2_ACFGT_Configures_1 $bool = yes // Configures greater than or equal to threshold, outside and inside ranges inclusive; functionality based on the values placed in CV1 and CV2.

//--- Enumerated values for register SC2, field ACFE
  let ADC0_SC2_ACFE_Compare_0 $bool = no // Compare function disabled.
  let ADC0_SC2_ACFE_Compare_1 $bool = yes // Compare function enabled.

//--- Enumerated values for register SC2, field ADTRG
  let ADC0_SC2_ADTRG_Software_0 $bool = no // Software trigger selected.
  let ADC0_SC2_ADTRG_Hardware_1 $bool = yes // Hardware trigger selected.

//--- Enumerated values for register SC2, field ADACT
  let ADC0_SC2_ADACT_Conversion_0 $bool = no // Conversion not in progress.
  let ADC0_SC2_ADACT_Conversion_1 $bool = yes // Conversion in progress.

//--- Enumerated values for register SC3, field AVGS
  let ADC0_SC3_AVGS_4_00 $u2 = 0 // 4 samples averaged.
  let ADC0_SC3_AVGS_8_01 $u2 = 1 // 8 samples averaged.
  let ADC0_SC3_AVGS_16_10 $u2 = 2 // 16 samples averaged.
  let ADC0_SC3_AVGS_32_11 $u2 = 3 // 32 samples averaged.

//--- Enumerated values for register SC3, field AVGE
  let ADC0_SC3_AVGE_Hardware_0 $bool = no // Hardware average function disabled.
  let ADC0_SC3_AVGE_Hardware_1 $bool = yes // Hardware average function enabled.

//--- Enumerated values for register SC3, field ADCO
  let ADC0_SC3_ADCO_One_0 $bool = no // One conversion or one set of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
  let ADC0_SC3_ADCO_Continuous_1 $bool = yes // Continuous conversions or sets of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.

//--- Enumerated values for register SC3, field CALF
  let ADC0_SC3_CALF_Calibration_0 $bool = no // Calibration completed normally.
  let ADC0_SC3_CALF_Calibration_1 $bool = yes // Calibration failed. ADC accuracy specifications are not guaranteed.

//--- Enumerated values for register SC1%s, field ADCH
  let ADC1_SC1_ADCH_When_00000 $u5 = 0 // When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
  let ADC1_SC1_ADCH_When_00001 $u5 = 1 // When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
  let ADC1_SC1_ADCH_When_00010 $u5 = 2 // When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
  let ADC1_SC1_ADCH_When_00011 $u5 = 3 // When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
  let ADC1_SC1_ADCH_When_00100 $u5 = 4 // When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_00101 $u5 = 5 // When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_00110 $u5 = 6 // When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_00111 $u5 = 7 // When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01000 $u5 = 8 // When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01001 $u5 = 9 // When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01010 $u5 = 10 // When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01011 $u5 = 11 // When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01100 $u5 = 12 // When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01101 $u5 = 13 // When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01110 $u5 = 14 // When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_01111 $u5 = 15 // When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10000 $u5 = 16 // When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10001 $u5 = 17 // When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10010 $u5 = 18 // When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10011 $u5 = 19 // When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10100 $u5 = 20 // When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10101 $u5 = 21 // When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10110 $u5 = 22 // When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_10111 $u5 = 23 // When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
  let ADC1_SC1_ADCH_When_11010 $u5 = 26 // When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
  let ADC1_SC1_ADCH_When_11011 $u5 = 27 // When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap (differential) is selected as input.
  let ADC1_SC1_ADCH_When_11101 $u5 = 29 // When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2[REFSEL].
  let ADC1_SC1_ADCH_When_11110 $u5 = 30 // When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2[REFSEL].
  let ADC1_SC1_ADCH_Module_11111 $u5 = 31 // Module is disabled.

//--- Enumerated values for register SC1%s, field DIFF
  let ADC1_SC1_DIFF_Single_ended_0 $bool = no // Single-ended conversions and input channels are selected.
  let ADC1_SC1_DIFF_Differential_1 $bool = yes // Differential conversions and input channels are selected.

//--- Enumerated values for register SC1%s, field AIEN
  let ADC1_SC1_AIEN_Conversion_0 $bool = no // Conversion complete interrupt is disabled.
  let ADC1_SC1_AIEN_Conversion_1 $bool = yes // Conversion complete interrupt is enabled.

//--- Enumerated values for register SC1%s, field COCO
  let ADC1_SC1_COCO_Conversion_0 $bool = no // Conversion is not completed.
  let ADC1_SC1_COCO_Conversion_1 $bool = yes // Conversion is completed.

//--- Enumerated values for register CFG1, field ADICLK
  let ADC1_CFG1_ADICLK_Bus_00 $u2 = 0 // Bus clock
  let ADC1_CFG1_ADICLK_Bus_01 $u2 = 1 // Bus clock divided by 2(BUSCLK/2)
  let ADC1_CFG1_ADICLK_Alternate_10 $u2 = 2 // Alternate clock (ALTCLK)
  let ADC1_CFG1_ADICLK_Asynchronous_11 $u2 = 3 // Asynchronous clock (ADACK)

//--- Enumerated values for register CFG1, field MODE
  let ADC1_CFG1_MODE_When_00 $u2 = 0 // When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is differential 9-bit conversion with 2's complement output.
  let ADC1_CFG1_MODE_When_01 $u2 = 1 // When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is differential 13-bit conversion with 2's complement output.
  let ADC1_CFG1_MODE_When_10 $u2 = 2 // When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is differential 11-bit conversion with 2's complement output
  let ADC1_CFG1_MODE_When_11 $u2 = 3 // When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is differential 16-bit conversion with 2's complement output

//--- Enumerated values for register CFG1, field ADLSMP
  let ADC1_CFG1_ADLSMP_Short_0 $bool = no // Short sample time.
  let ADC1_CFG1_ADLSMP_Long_1 $bool = yes // Long sample time.

//--- Enumerated values for register CFG1, field ADIV
  let ADC1_CFG1_ADIV_The_00 $u2 = 0 // The divide ratio is 1 and the clock rate is input clock.
  let ADC1_CFG1_ADIV_The_01 $u2 = 1 // The divide ratio is 2 and the clock rate is (input clock)/2.
  let ADC1_CFG1_ADIV_The_10 $u2 = 2 // The divide ratio is 4 and the clock rate is (input clock)/4.
  let ADC1_CFG1_ADIV_The_11 $u2 = 3 // The divide ratio is 8 and the clock rate is (input clock)/8.

//--- Enumerated values for register CFG1, field ADLPC
  let ADC1_CFG1_ADLPC_Normal_0 $bool = no // Normal power configuration.
  let ADC1_CFG1_ADLPC_Low_power_1 $bool = yes // Low-power configuration. The power is reduced at the expense of maximum clock speed.

//--- Enumerated values for register CFG2, field ADLSTS
  let ADC1_CFG2_ADLSTS_Default_00 $u2 = 0 // Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles total.
  let ADC1_CFG2_ADLSTS_12_01 $u2 = 1 // 12 extra ADCK cycles; 16 ADCK cycles total sample time.
  let ADC1_CFG2_ADLSTS_6_10 $u2 = 2 // 6 extra ADCK cycles; 10 ADCK cycles total sample time.
  let ADC1_CFG2_ADLSTS_2_11 $u2 = 3 // 2 extra ADCK cycles; 6 ADCK cycles total sample time.

//--- Enumerated values for register CFG2, field ADHSC
  let ADC1_CFG2_ADHSC_Normal_0 $bool = no // Normal conversion sequence selected.
  let ADC1_CFG2_ADHSC_High_speed_1 $bool = yes // High-speed conversion sequence selected with 2 additional ADCK cycles to total conversion time.

//--- Enumerated values for register CFG2, field ADACKEN
  let ADC1_CFG2_ADACKEN_Asynchronous_0 $bool = no // Asynchronous clock output disabled; Asynchronous clock is enabled only if selected by ADICLK and a conversion is active.
  let ADC1_CFG2_ADACKEN_Asynchronous_1 $bool = yes // Asynchronous clock and clock output is enabled regardless of the state of the ADC.

//--- Enumerated values for register CFG2, field MUXSEL
  let ADC1_CFG2_MUXSEL_ADxxa_0 $bool = no // ADxxa channels are selected.
  let ADC1_CFG2_MUXSEL_ADxxb_1 $bool = yes // ADxxb channels are selected.

//--- Enumerated values for register SC2, field REFSEL
  let ADC1_SC2_REFSEL_Default_00 $u2 = 0 // Default voltage reference pin pair, that is, external pins VREFH and VREFL
  let ADC1_SC2_REFSEL_Alternate_01 $u2 = 1 // Alternate reference pair, that is, VALTH and VALTL . This pair may be additional external pins or internal sources depending on the MCU configuration. See the chip configuration information for details specific to this MCU

//--- Enumerated values for register SC2, field DMAEN
  let ADC1_SC2_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let ADC1_SC2_DMAEN_DMA_1 $bool = yes // DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event noted when any of the SC1n[COCO] flags is asserted.

//--- Enumerated values for register SC2, field ACREN
  let ADC1_SC2_ACREN_Range_0 $bool = no // Range function disabled. Only CV1 is compared.
  let ADC1_SC2_ACREN_Range_1 $bool = yes // Range function enabled. Both CV1 and CV2 are compared.

//--- Enumerated values for register SC2, field ACFGT
  let ADC1_SC2_ACFGT_Configures_0 $bool = no // Configures less than threshold, outside range not inclusive and inside range not inclusive; functionality based on the values placed in CV1 and CV2.
  let ADC1_SC2_ACFGT_Configures_1 $bool = yes // Configures greater than or equal to threshold, outside and inside ranges inclusive; functionality based on the values placed in CV1 and CV2.

//--- Enumerated values for register SC2, field ACFE
  let ADC1_SC2_ACFE_Compare_0 $bool = no // Compare function disabled.
  let ADC1_SC2_ACFE_Compare_1 $bool = yes // Compare function enabled.

//--- Enumerated values for register SC2, field ADTRG
  let ADC1_SC2_ADTRG_Software_0 $bool = no // Software trigger selected.
  let ADC1_SC2_ADTRG_Hardware_1 $bool = yes // Hardware trigger selected.

//--- Enumerated values for register SC2, field ADACT
  let ADC1_SC2_ADACT_Conversion_0 $bool = no // Conversion not in progress.
  let ADC1_SC2_ADACT_Conversion_1 $bool = yes // Conversion in progress.

//--- Enumerated values for register SC3, field AVGS
  let ADC1_SC3_AVGS_4_00 $u2 = 0 // 4 samples averaged.
  let ADC1_SC3_AVGS_8_01 $u2 = 1 // 8 samples averaged.
  let ADC1_SC3_AVGS_16_10 $u2 = 2 // 16 samples averaged.
  let ADC1_SC3_AVGS_32_11 $u2 = 3 // 32 samples averaged.

//--- Enumerated values for register SC3, field AVGE
  let ADC1_SC3_AVGE_Hardware_0 $bool = no // Hardware average function disabled.
  let ADC1_SC3_AVGE_Hardware_1 $bool = yes // Hardware average function enabled.

//--- Enumerated values for register SC3, field ADCO
  let ADC1_SC3_ADCO_One_0 $bool = no // One conversion or one set of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
  let ADC1_SC3_ADCO_Continuous_1 $bool = yes // Continuous conversions or sets of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.

//--- Enumerated values for register SC3, field CALF
  let ADC1_SC3_CALF_Calibration_0 $bool = no // Calibration completed normally.
  let ADC1_SC3_CALF_Calibration_1 $bool = yes // Calibration failed. ADC accuracy specifications are not guaranteed.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©AIPS [2]
//        AIPS0 at 0x40000000
//        AIPS1 at 0x40080000
//------------------------------------------------------------------------------

registers ©AIPS [2 @at 0x40000000 0x40080000]
          ©AIPS0 @at 0x40000000
          ©AIPS1 @at 0x40080000 {
//---  Register MPRA: Master Privilege Register A
  MPRA @offset 0x0 $u32 {
    1
    MTR0 // at 30: Master 0 Trusted For Read
    MTW0 // at 29: Master 0 Trusted For Writes
    MPL0 // at 28: Master 0 Privilege Level
    1
    MTR1 // at 26: Master 1 Trusted for Read
    MTW1 // at 25: Master 1 Trusted for Writes
    MPL1 // at 24: Master 1 Privilege Level
    1
    MTR2 // at 22: Master 2 Trusted For Read
    MTW2 // at 21: Master 2 Trusted For Writes
    MPL2 // at 20: Master 2 Privilege Level
    1
    MTR3 // at 18: Master 3 Trusted For Read
    MTW3 // at 17: Master 3 Trusted For Writes
    MPL3 // at 16: Master 3 Privilege Level
    1
    MTR4 // at 14: Master 4 Trusted For Read
    MTW4 // at 13: Master 4 Trusted For Writes
    MPL4 // at 12: Master 4 Privilege Level
    1
    MTR5 // at 10: Master 5 Trusted For Read
    MTW5 // at 9: Master 5 Trusted For Writes
    MPL5 // at 8: Master 5 Privilege Level
    1
    MTR6 // at 6: Master 6 Trusted for Read
    MTW6 // at 5: Master 6 Trusted for Writes
    MPL6 // at 4: Master 6 Privilege Level
    4
  }

//---  Register PACRA: Peripheral Access Control Register
  PACRA @offset 0x20 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRB: Peripheral Access Control Register
  PACRB @offset 0x24 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRC: Peripheral Access Control Register
  PACRC @offset 0x28 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRD: Peripheral Access Control Register
  PACRD @offset 0x2c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRE: Peripheral Access Control Register
  PACRE @offset 0x40 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRF: Peripheral Access Control Register
  PACRF @offset 0x44 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRG: Peripheral Access Control Register
  PACRG @offset 0x48 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRH: Peripheral Access Control Register
  PACRH @offset 0x4c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRI: Peripheral Access Control Register
  PACRI @offset 0x50 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRJ: Peripheral Access Control Register
  PACRJ @offset 0x54 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRK: Peripheral Access Control Register
  PACRK @offset 0x58 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRL: Peripheral Access Control Register
  PACRL @offset 0x5c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRM: Peripheral Access Control Register
  PACRM @offset 0x60 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRN: Peripheral Access Control Register
  PACRN @offset 0x64 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRO: Peripheral Access Control Register
  PACRO @offset 0x68 $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

//---  Register PACRP: Peripheral Access Control Register
  PACRP @offset 0x6c $u32 {
    1
    SP0 // at 30: Supervisor Protect
    WP0 // at 29: Write Protect
    TP0 // at 28: Trusted Protect
    1
    SP1 // at 26: Supervisor Protect
    WP1 // at 25: Write Protect
    TP1 // at 24: Trusted Protect
    1
    SP2 // at 22: Supervisor Protect
    WP2 // at 21: Write Protect
    TP2 // at 20: Trusted Protect
    1
    SP3 // at 18: Supervisor Protect
    WP3 // at 17: Write Protect
    TP3 // at 16: Trusted Protect
    1
    SP4 // at 14: Supervisor Protect
    WP4 // at 13: Write Protect
    TP4 // at 12: Trusted Protect
    1
    SP5 // at 10: Supervisor Protect
    WP5 // at 9: Write Protect
    TP5 // at 8: Trusted Protect
    1
    SP6 // at 6: Supervisor Protect
    WP6 // at 5: Write Protect
    TP6 // at 4: Trusted Protect
    1
    SP7 // at 2: Supervisor Protect
    WP7 // at 1: Write Protect
    TP7 // at 0: Trusted Protect
  }

}

//--- Enumerated values for register MPRA, field MPL6
  let AIPS0_MPRA_MPL6_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL6_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW6
  let AIPS0_MPRA_MTW6_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW6_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR6
  let AIPS0_MPRA_MTR6_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR6_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL5
  let AIPS0_MPRA_MPL5_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL5_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW5
  let AIPS0_MPRA_MTW5_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW5_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR5
  let AIPS0_MPRA_MTR5_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR5_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL4
  let AIPS0_MPRA_MPL4_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL4_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW4
  let AIPS0_MPRA_MTW4_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW4_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR4
  let AIPS0_MPRA_MTR4_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR4_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL3
  let AIPS0_MPRA_MPL3_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL3_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW3
  let AIPS0_MPRA_MTW3_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW3_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR3
  let AIPS0_MPRA_MTR3_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR3_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL2
  let AIPS0_MPRA_MPL2_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL2_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW2
  let AIPS0_MPRA_MTW2_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW2_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR2
  let AIPS0_MPRA_MTR2_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR2_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL1
  let AIPS0_MPRA_MPL1_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL1_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW1
  let AIPS0_MPRA_MTW1_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW1_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR1
  let AIPS0_MPRA_MTR1_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR1_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL0
  let AIPS0_MPRA_MPL0_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS0_MPRA_MPL0_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW0
  let AIPS0_MPRA_MTW0_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS0_MPRA_MTW0_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR0
  let AIPS0_MPRA_MTR0_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS0_MPRA_MTR0_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register PACRA, field TP7
  let AIPS0_PACRA_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP7
  let AIPS0_PACRA_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP7
  let AIPS0_PACRA_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP6
  let AIPS0_PACRA_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP6
  let AIPS0_PACRA_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP6
  let AIPS0_PACRA_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP5
  let AIPS0_PACRA_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP5
  let AIPS0_PACRA_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP5
  let AIPS0_PACRA_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP4
  let AIPS0_PACRA_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP4
  let AIPS0_PACRA_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP4
  let AIPS0_PACRA_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP3
  let AIPS0_PACRA_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP3
  let AIPS0_PACRA_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP3
  let AIPS0_PACRA_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP2
  let AIPS0_PACRA_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP2
  let AIPS0_PACRA_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP2
  let AIPS0_PACRA_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP1
  let AIPS0_PACRA_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP1
  let AIPS0_PACRA_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP1
  let AIPS0_PACRA_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP0
  let AIPS0_PACRA_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRA_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP0
  let AIPS0_PACRA_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRA_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP0
  let AIPS0_PACRA_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRA_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP7
  let AIPS0_PACRB_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP7
  let AIPS0_PACRB_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP7
  let AIPS0_PACRB_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP6
  let AIPS0_PACRB_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP6
  let AIPS0_PACRB_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP6
  let AIPS0_PACRB_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP5
  let AIPS0_PACRB_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP5
  let AIPS0_PACRB_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP5
  let AIPS0_PACRB_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP4
  let AIPS0_PACRB_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP4
  let AIPS0_PACRB_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP4
  let AIPS0_PACRB_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP3
  let AIPS0_PACRB_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP3
  let AIPS0_PACRB_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP3
  let AIPS0_PACRB_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP2
  let AIPS0_PACRB_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP2
  let AIPS0_PACRB_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP2
  let AIPS0_PACRB_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP1
  let AIPS0_PACRB_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP1
  let AIPS0_PACRB_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP1
  let AIPS0_PACRB_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP0
  let AIPS0_PACRB_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRB_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP0
  let AIPS0_PACRB_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRB_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP0
  let AIPS0_PACRB_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRB_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP7
  let AIPS0_PACRC_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP7
  let AIPS0_PACRC_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP7
  let AIPS0_PACRC_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP6
  let AIPS0_PACRC_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP6
  let AIPS0_PACRC_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP6
  let AIPS0_PACRC_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP5
  let AIPS0_PACRC_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP5
  let AIPS0_PACRC_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP5
  let AIPS0_PACRC_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP4
  let AIPS0_PACRC_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP4
  let AIPS0_PACRC_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP4
  let AIPS0_PACRC_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP3
  let AIPS0_PACRC_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP3
  let AIPS0_PACRC_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP3
  let AIPS0_PACRC_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP2
  let AIPS0_PACRC_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP2
  let AIPS0_PACRC_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP2
  let AIPS0_PACRC_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP1
  let AIPS0_PACRC_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP1
  let AIPS0_PACRC_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP1
  let AIPS0_PACRC_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP0
  let AIPS0_PACRC_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRC_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP0
  let AIPS0_PACRC_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRC_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP0
  let AIPS0_PACRC_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRC_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP7
  let AIPS0_PACRD_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP7
  let AIPS0_PACRD_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP7
  let AIPS0_PACRD_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP6
  let AIPS0_PACRD_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP6
  let AIPS0_PACRD_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP6
  let AIPS0_PACRD_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP5
  let AIPS0_PACRD_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP5
  let AIPS0_PACRD_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP5
  let AIPS0_PACRD_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP4
  let AIPS0_PACRD_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP4
  let AIPS0_PACRD_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP4
  let AIPS0_PACRD_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP3
  let AIPS0_PACRD_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP3
  let AIPS0_PACRD_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP3
  let AIPS0_PACRD_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP2
  let AIPS0_PACRD_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP2
  let AIPS0_PACRD_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP2
  let AIPS0_PACRD_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP1
  let AIPS0_PACRD_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP1
  let AIPS0_PACRD_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP1
  let AIPS0_PACRD_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP0
  let AIPS0_PACRD_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRD_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP0
  let AIPS0_PACRD_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRD_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP0
  let AIPS0_PACRD_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRD_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP7
  let AIPS0_PACRE_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP7
  let AIPS0_PACRE_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP7
  let AIPS0_PACRE_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP6
  let AIPS0_PACRE_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP6
  let AIPS0_PACRE_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP6
  let AIPS0_PACRE_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP5
  let AIPS0_PACRE_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP5
  let AIPS0_PACRE_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP5
  let AIPS0_PACRE_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP4
  let AIPS0_PACRE_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP4
  let AIPS0_PACRE_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP4
  let AIPS0_PACRE_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP3
  let AIPS0_PACRE_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP3
  let AIPS0_PACRE_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP3
  let AIPS0_PACRE_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP2
  let AIPS0_PACRE_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP2
  let AIPS0_PACRE_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP2
  let AIPS0_PACRE_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP1
  let AIPS0_PACRE_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP1
  let AIPS0_PACRE_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP1
  let AIPS0_PACRE_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP0
  let AIPS0_PACRE_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRE_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP0
  let AIPS0_PACRE_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRE_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP0
  let AIPS0_PACRE_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRE_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP7
  let AIPS0_PACRF_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP7
  let AIPS0_PACRF_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP7
  let AIPS0_PACRF_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP6
  let AIPS0_PACRF_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP6
  let AIPS0_PACRF_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP6
  let AIPS0_PACRF_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP5
  let AIPS0_PACRF_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP5
  let AIPS0_PACRF_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP5
  let AIPS0_PACRF_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP4
  let AIPS0_PACRF_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP4
  let AIPS0_PACRF_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP4
  let AIPS0_PACRF_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP3
  let AIPS0_PACRF_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP3
  let AIPS0_PACRF_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP3
  let AIPS0_PACRF_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP2
  let AIPS0_PACRF_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP2
  let AIPS0_PACRF_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP2
  let AIPS0_PACRF_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP1
  let AIPS0_PACRF_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP1
  let AIPS0_PACRF_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP1
  let AIPS0_PACRF_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP0
  let AIPS0_PACRF_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRF_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP0
  let AIPS0_PACRF_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRF_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP0
  let AIPS0_PACRF_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRF_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP7
  let AIPS0_PACRG_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP7
  let AIPS0_PACRG_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP7
  let AIPS0_PACRG_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP6
  let AIPS0_PACRG_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP6
  let AIPS0_PACRG_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP6
  let AIPS0_PACRG_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP5
  let AIPS0_PACRG_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP5
  let AIPS0_PACRG_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP5
  let AIPS0_PACRG_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP4
  let AIPS0_PACRG_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP4
  let AIPS0_PACRG_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP4
  let AIPS0_PACRG_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP3
  let AIPS0_PACRG_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP3
  let AIPS0_PACRG_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP3
  let AIPS0_PACRG_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP2
  let AIPS0_PACRG_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP2
  let AIPS0_PACRG_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP2
  let AIPS0_PACRG_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP1
  let AIPS0_PACRG_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP1
  let AIPS0_PACRG_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP1
  let AIPS0_PACRG_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP0
  let AIPS0_PACRG_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRG_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP0
  let AIPS0_PACRG_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRG_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP0
  let AIPS0_PACRG_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRG_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP7
  let AIPS0_PACRH_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP7
  let AIPS0_PACRH_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP7
  let AIPS0_PACRH_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP6
  let AIPS0_PACRH_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP6
  let AIPS0_PACRH_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP6
  let AIPS0_PACRH_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP5
  let AIPS0_PACRH_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP5
  let AIPS0_PACRH_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP5
  let AIPS0_PACRH_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP4
  let AIPS0_PACRH_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP4
  let AIPS0_PACRH_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP4
  let AIPS0_PACRH_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP3
  let AIPS0_PACRH_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP3
  let AIPS0_PACRH_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP3
  let AIPS0_PACRH_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP2
  let AIPS0_PACRH_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP2
  let AIPS0_PACRH_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP2
  let AIPS0_PACRH_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP1
  let AIPS0_PACRH_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP1
  let AIPS0_PACRH_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP1
  let AIPS0_PACRH_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP0
  let AIPS0_PACRH_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRH_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP0
  let AIPS0_PACRH_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRH_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP0
  let AIPS0_PACRH_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRH_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP7
  let AIPS0_PACRI_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP7
  let AIPS0_PACRI_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP7
  let AIPS0_PACRI_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP6
  let AIPS0_PACRI_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP6
  let AIPS0_PACRI_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP6
  let AIPS0_PACRI_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP5
  let AIPS0_PACRI_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP5
  let AIPS0_PACRI_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP5
  let AIPS0_PACRI_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP4
  let AIPS0_PACRI_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP4
  let AIPS0_PACRI_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP4
  let AIPS0_PACRI_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP3
  let AIPS0_PACRI_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP3
  let AIPS0_PACRI_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP3
  let AIPS0_PACRI_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP2
  let AIPS0_PACRI_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP2
  let AIPS0_PACRI_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP2
  let AIPS0_PACRI_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP1
  let AIPS0_PACRI_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP1
  let AIPS0_PACRI_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP1
  let AIPS0_PACRI_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP0
  let AIPS0_PACRI_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRI_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP0
  let AIPS0_PACRI_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRI_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP0
  let AIPS0_PACRI_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRI_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP7
  let AIPS0_PACRJ_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP7
  let AIPS0_PACRJ_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP7
  let AIPS0_PACRJ_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP6
  let AIPS0_PACRJ_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP6
  let AIPS0_PACRJ_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP6
  let AIPS0_PACRJ_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP5
  let AIPS0_PACRJ_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP5
  let AIPS0_PACRJ_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP5
  let AIPS0_PACRJ_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP4
  let AIPS0_PACRJ_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP4
  let AIPS0_PACRJ_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP4
  let AIPS0_PACRJ_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP3
  let AIPS0_PACRJ_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP3
  let AIPS0_PACRJ_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP3
  let AIPS0_PACRJ_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP2
  let AIPS0_PACRJ_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP2
  let AIPS0_PACRJ_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP2
  let AIPS0_PACRJ_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP1
  let AIPS0_PACRJ_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP1
  let AIPS0_PACRJ_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP1
  let AIPS0_PACRJ_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP0
  let AIPS0_PACRJ_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRJ_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP0
  let AIPS0_PACRJ_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRJ_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP0
  let AIPS0_PACRJ_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRJ_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP7
  let AIPS0_PACRK_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP7
  let AIPS0_PACRK_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP7
  let AIPS0_PACRK_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP6
  let AIPS0_PACRK_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP6
  let AIPS0_PACRK_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP6
  let AIPS0_PACRK_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP5
  let AIPS0_PACRK_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP5
  let AIPS0_PACRK_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP5
  let AIPS0_PACRK_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP4
  let AIPS0_PACRK_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP4
  let AIPS0_PACRK_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP4
  let AIPS0_PACRK_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP3
  let AIPS0_PACRK_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP3
  let AIPS0_PACRK_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP3
  let AIPS0_PACRK_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP2
  let AIPS0_PACRK_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP2
  let AIPS0_PACRK_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP2
  let AIPS0_PACRK_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP1
  let AIPS0_PACRK_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP1
  let AIPS0_PACRK_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP1
  let AIPS0_PACRK_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP0
  let AIPS0_PACRK_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRK_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP0
  let AIPS0_PACRK_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRK_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP0
  let AIPS0_PACRK_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRK_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP7
  let AIPS0_PACRL_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP7
  let AIPS0_PACRL_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP7
  let AIPS0_PACRL_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP6
  let AIPS0_PACRL_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP6
  let AIPS0_PACRL_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP6
  let AIPS0_PACRL_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP5
  let AIPS0_PACRL_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP5
  let AIPS0_PACRL_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP5
  let AIPS0_PACRL_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP4
  let AIPS0_PACRL_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP4
  let AIPS0_PACRL_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP4
  let AIPS0_PACRL_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP3
  let AIPS0_PACRL_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP3
  let AIPS0_PACRL_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP3
  let AIPS0_PACRL_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP2
  let AIPS0_PACRL_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP2
  let AIPS0_PACRL_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP2
  let AIPS0_PACRL_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP1
  let AIPS0_PACRL_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP1
  let AIPS0_PACRL_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP1
  let AIPS0_PACRL_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP0
  let AIPS0_PACRL_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRL_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP0
  let AIPS0_PACRL_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRL_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP0
  let AIPS0_PACRL_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRL_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP7
  let AIPS0_PACRM_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP7
  let AIPS0_PACRM_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP7
  let AIPS0_PACRM_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP6
  let AIPS0_PACRM_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP6
  let AIPS0_PACRM_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP6
  let AIPS0_PACRM_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP5
  let AIPS0_PACRM_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP5
  let AIPS0_PACRM_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP5
  let AIPS0_PACRM_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP4
  let AIPS0_PACRM_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP4
  let AIPS0_PACRM_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP4
  let AIPS0_PACRM_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP3
  let AIPS0_PACRM_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP3
  let AIPS0_PACRM_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP3
  let AIPS0_PACRM_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP2
  let AIPS0_PACRM_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP2
  let AIPS0_PACRM_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP2
  let AIPS0_PACRM_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP1
  let AIPS0_PACRM_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP1
  let AIPS0_PACRM_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP1
  let AIPS0_PACRM_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP0
  let AIPS0_PACRM_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRM_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP0
  let AIPS0_PACRM_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRM_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP0
  let AIPS0_PACRM_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRM_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP7
  let AIPS0_PACRN_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP7
  let AIPS0_PACRN_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP7
  let AIPS0_PACRN_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP6
  let AIPS0_PACRN_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP6
  let AIPS0_PACRN_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP6
  let AIPS0_PACRN_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP5
  let AIPS0_PACRN_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP5
  let AIPS0_PACRN_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP5
  let AIPS0_PACRN_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP4
  let AIPS0_PACRN_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP4
  let AIPS0_PACRN_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP4
  let AIPS0_PACRN_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP3
  let AIPS0_PACRN_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP3
  let AIPS0_PACRN_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP3
  let AIPS0_PACRN_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP2
  let AIPS0_PACRN_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP2
  let AIPS0_PACRN_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP2
  let AIPS0_PACRN_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP1
  let AIPS0_PACRN_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP1
  let AIPS0_PACRN_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP1
  let AIPS0_PACRN_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP0
  let AIPS0_PACRN_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRN_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP0
  let AIPS0_PACRN_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRN_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP0
  let AIPS0_PACRN_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRN_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP7
  let AIPS0_PACRO_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP7
  let AIPS0_PACRO_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP7
  let AIPS0_PACRO_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP6
  let AIPS0_PACRO_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP6
  let AIPS0_PACRO_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP6
  let AIPS0_PACRO_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP5
  let AIPS0_PACRO_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP5
  let AIPS0_PACRO_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP5
  let AIPS0_PACRO_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP4
  let AIPS0_PACRO_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP4
  let AIPS0_PACRO_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP4
  let AIPS0_PACRO_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP3
  let AIPS0_PACRO_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP3
  let AIPS0_PACRO_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP3
  let AIPS0_PACRO_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP2
  let AIPS0_PACRO_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP2
  let AIPS0_PACRO_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP2
  let AIPS0_PACRO_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP1
  let AIPS0_PACRO_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP1
  let AIPS0_PACRO_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP1
  let AIPS0_PACRO_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP0
  let AIPS0_PACRO_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRO_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP0
  let AIPS0_PACRO_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRO_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP0
  let AIPS0_PACRO_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRO_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP7
  let AIPS0_PACRP_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP7
  let AIPS0_PACRP_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP7
  let AIPS0_PACRP_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP6
  let AIPS0_PACRP_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP6
  let AIPS0_PACRP_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP6
  let AIPS0_PACRP_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP5
  let AIPS0_PACRP_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP5
  let AIPS0_PACRP_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP5
  let AIPS0_PACRP_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP4
  let AIPS0_PACRP_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP4
  let AIPS0_PACRP_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP4
  let AIPS0_PACRP_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP3
  let AIPS0_PACRP_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP3
  let AIPS0_PACRP_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP3
  let AIPS0_PACRP_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP2
  let AIPS0_PACRP_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP2
  let AIPS0_PACRP_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP2
  let AIPS0_PACRP_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP1
  let AIPS0_PACRP_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP1
  let AIPS0_PACRP_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP1
  let AIPS0_PACRP_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP0
  let AIPS0_PACRP_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS0_PACRP_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP0
  let AIPS0_PACRP_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS0_PACRP_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP0
  let AIPS0_PACRP_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS0_PACRP_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register MPRA, field MPL6
  let AIPS1_MPRA_MPL6_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL6_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW6
  let AIPS1_MPRA_MTW6_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW6_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR6
  let AIPS1_MPRA_MTR6_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR6_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL5
  let AIPS1_MPRA_MPL5_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL5_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW5
  let AIPS1_MPRA_MTW5_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW5_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR5
  let AIPS1_MPRA_MTR5_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR5_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL4
  let AIPS1_MPRA_MPL4_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL4_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW4
  let AIPS1_MPRA_MTW4_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW4_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR4
  let AIPS1_MPRA_MTR4_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR4_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL3
  let AIPS1_MPRA_MPL3_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL3_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW3
  let AIPS1_MPRA_MTW3_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW3_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR3
  let AIPS1_MPRA_MTR3_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR3_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL2
  let AIPS1_MPRA_MPL2_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL2_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW2
  let AIPS1_MPRA_MTW2_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW2_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR2
  let AIPS1_MPRA_MTR2_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR2_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL1
  let AIPS1_MPRA_MPL1_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL1_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW1
  let AIPS1_MPRA_MTW1_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW1_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR1
  let AIPS1_MPRA_MTR1_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR1_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register MPRA, field MPL0
  let AIPS1_MPRA_MPL0_Accesses_0 $bool = no // Accesses from this master are forced to user-mode.
  let AIPS1_MPRA_MPL0_Accesses_1 $bool = yes // Accesses from this master are not forced to user-mode.

//--- Enumerated values for register MPRA, field MTW0
  let AIPS1_MPRA_MTW0_This_0 $bool = no // This master is not trusted for write accesses.
  let AIPS1_MPRA_MTW0_This_1 $bool = yes // This master is trusted for write accesses.

//--- Enumerated values for register MPRA, field MTR0
  let AIPS1_MPRA_MTR0_This_0 $bool = no // This master is not trusted for read accesses.
  let AIPS1_MPRA_MTR0_This_1 $bool = yes // This master is trusted for read accesses.

//--- Enumerated values for register PACRA, field TP7
  let AIPS1_PACRA_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP7
  let AIPS1_PACRA_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP7
  let AIPS1_PACRA_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP6
  let AIPS1_PACRA_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP6
  let AIPS1_PACRA_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP6
  let AIPS1_PACRA_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP5
  let AIPS1_PACRA_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP5
  let AIPS1_PACRA_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP5
  let AIPS1_PACRA_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP4
  let AIPS1_PACRA_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP4
  let AIPS1_PACRA_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP4
  let AIPS1_PACRA_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP3
  let AIPS1_PACRA_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP3
  let AIPS1_PACRA_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP3
  let AIPS1_PACRA_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP2
  let AIPS1_PACRA_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP2
  let AIPS1_PACRA_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP2
  let AIPS1_PACRA_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP1
  let AIPS1_PACRA_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP1
  let AIPS1_PACRA_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP1
  let AIPS1_PACRA_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRA, field TP0
  let AIPS1_PACRA_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRA_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRA, field WP0
  let AIPS1_PACRA_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRA_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRA, field SP0
  let AIPS1_PACRA_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRA_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP7
  let AIPS1_PACRB_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP7
  let AIPS1_PACRB_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP7
  let AIPS1_PACRB_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP6
  let AIPS1_PACRB_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP6
  let AIPS1_PACRB_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP6
  let AIPS1_PACRB_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP5
  let AIPS1_PACRB_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP5
  let AIPS1_PACRB_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP5
  let AIPS1_PACRB_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP4
  let AIPS1_PACRB_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP4
  let AIPS1_PACRB_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP4
  let AIPS1_PACRB_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP3
  let AIPS1_PACRB_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP3
  let AIPS1_PACRB_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP3
  let AIPS1_PACRB_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP2
  let AIPS1_PACRB_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP2
  let AIPS1_PACRB_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP2
  let AIPS1_PACRB_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP1
  let AIPS1_PACRB_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP1
  let AIPS1_PACRB_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP1
  let AIPS1_PACRB_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRB, field TP0
  let AIPS1_PACRB_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRB_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRB, field WP0
  let AIPS1_PACRB_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRB_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRB, field SP0
  let AIPS1_PACRB_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRB_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP7
  let AIPS1_PACRC_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP7
  let AIPS1_PACRC_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP7
  let AIPS1_PACRC_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP6
  let AIPS1_PACRC_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP6
  let AIPS1_PACRC_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP6
  let AIPS1_PACRC_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP5
  let AIPS1_PACRC_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP5
  let AIPS1_PACRC_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP5
  let AIPS1_PACRC_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP4
  let AIPS1_PACRC_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP4
  let AIPS1_PACRC_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP4
  let AIPS1_PACRC_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP3
  let AIPS1_PACRC_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP3
  let AIPS1_PACRC_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP3
  let AIPS1_PACRC_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP2
  let AIPS1_PACRC_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP2
  let AIPS1_PACRC_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP2
  let AIPS1_PACRC_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP1
  let AIPS1_PACRC_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP1
  let AIPS1_PACRC_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP1
  let AIPS1_PACRC_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRC, field TP0
  let AIPS1_PACRC_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRC_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRC, field WP0
  let AIPS1_PACRC_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRC_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRC, field SP0
  let AIPS1_PACRC_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRC_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP7
  let AIPS1_PACRD_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP7
  let AIPS1_PACRD_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP7
  let AIPS1_PACRD_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP6
  let AIPS1_PACRD_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP6
  let AIPS1_PACRD_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP6
  let AIPS1_PACRD_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP5
  let AIPS1_PACRD_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP5
  let AIPS1_PACRD_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP5
  let AIPS1_PACRD_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP4
  let AIPS1_PACRD_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP4
  let AIPS1_PACRD_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP4
  let AIPS1_PACRD_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP3
  let AIPS1_PACRD_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP3
  let AIPS1_PACRD_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP3
  let AIPS1_PACRD_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP2
  let AIPS1_PACRD_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP2
  let AIPS1_PACRD_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP2
  let AIPS1_PACRD_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP1
  let AIPS1_PACRD_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP1
  let AIPS1_PACRD_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP1
  let AIPS1_PACRD_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRD, field TP0
  let AIPS1_PACRD_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRD_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRD, field WP0
  let AIPS1_PACRD_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRD_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRD, field SP0
  let AIPS1_PACRD_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRD_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP7
  let AIPS1_PACRE_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP7
  let AIPS1_PACRE_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP7
  let AIPS1_PACRE_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP6
  let AIPS1_PACRE_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP6
  let AIPS1_PACRE_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP6
  let AIPS1_PACRE_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP5
  let AIPS1_PACRE_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP5
  let AIPS1_PACRE_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP5
  let AIPS1_PACRE_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP4
  let AIPS1_PACRE_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP4
  let AIPS1_PACRE_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP4
  let AIPS1_PACRE_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP3
  let AIPS1_PACRE_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP3
  let AIPS1_PACRE_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP3
  let AIPS1_PACRE_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP2
  let AIPS1_PACRE_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP2
  let AIPS1_PACRE_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP2
  let AIPS1_PACRE_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP1
  let AIPS1_PACRE_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP1
  let AIPS1_PACRE_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP1
  let AIPS1_PACRE_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRE, field TP0
  let AIPS1_PACRE_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRE_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRE, field WP0
  let AIPS1_PACRE_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRE_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRE, field SP0
  let AIPS1_PACRE_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRE_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP7
  let AIPS1_PACRF_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP7
  let AIPS1_PACRF_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP7
  let AIPS1_PACRF_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP6
  let AIPS1_PACRF_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP6
  let AIPS1_PACRF_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP6
  let AIPS1_PACRF_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP5
  let AIPS1_PACRF_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP5
  let AIPS1_PACRF_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP5
  let AIPS1_PACRF_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP4
  let AIPS1_PACRF_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP4
  let AIPS1_PACRF_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP4
  let AIPS1_PACRF_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP3
  let AIPS1_PACRF_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP3
  let AIPS1_PACRF_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP3
  let AIPS1_PACRF_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP2
  let AIPS1_PACRF_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP2
  let AIPS1_PACRF_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP2
  let AIPS1_PACRF_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP1
  let AIPS1_PACRF_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP1
  let AIPS1_PACRF_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP1
  let AIPS1_PACRF_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRF, field TP0
  let AIPS1_PACRF_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRF_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRF, field WP0
  let AIPS1_PACRF_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRF_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRF, field SP0
  let AIPS1_PACRF_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRF_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP7
  let AIPS1_PACRG_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP7
  let AIPS1_PACRG_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP7
  let AIPS1_PACRG_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP6
  let AIPS1_PACRG_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP6
  let AIPS1_PACRG_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP6
  let AIPS1_PACRG_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP5
  let AIPS1_PACRG_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP5
  let AIPS1_PACRG_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP5
  let AIPS1_PACRG_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP4
  let AIPS1_PACRG_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP4
  let AIPS1_PACRG_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP4
  let AIPS1_PACRG_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP3
  let AIPS1_PACRG_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP3
  let AIPS1_PACRG_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP3
  let AIPS1_PACRG_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP2
  let AIPS1_PACRG_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP2
  let AIPS1_PACRG_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP2
  let AIPS1_PACRG_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP1
  let AIPS1_PACRG_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP1
  let AIPS1_PACRG_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP1
  let AIPS1_PACRG_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRG, field TP0
  let AIPS1_PACRG_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRG_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRG, field WP0
  let AIPS1_PACRG_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRG_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRG, field SP0
  let AIPS1_PACRG_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRG_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP7
  let AIPS1_PACRH_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP7
  let AIPS1_PACRH_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP7
  let AIPS1_PACRH_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP6
  let AIPS1_PACRH_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP6
  let AIPS1_PACRH_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP6
  let AIPS1_PACRH_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP5
  let AIPS1_PACRH_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP5
  let AIPS1_PACRH_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP5
  let AIPS1_PACRH_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP4
  let AIPS1_PACRH_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP4
  let AIPS1_PACRH_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP4
  let AIPS1_PACRH_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP3
  let AIPS1_PACRH_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP3
  let AIPS1_PACRH_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP3
  let AIPS1_PACRH_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP2
  let AIPS1_PACRH_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP2
  let AIPS1_PACRH_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP2
  let AIPS1_PACRH_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP1
  let AIPS1_PACRH_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP1
  let AIPS1_PACRH_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP1
  let AIPS1_PACRH_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRH, field TP0
  let AIPS1_PACRH_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRH_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRH, field WP0
  let AIPS1_PACRH_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRH_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRH, field SP0
  let AIPS1_PACRH_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRH_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP7
  let AIPS1_PACRI_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP7
  let AIPS1_PACRI_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP7
  let AIPS1_PACRI_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP6
  let AIPS1_PACRI_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP6
  let AIPS1_PACRI_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP6
  let AIPS1_PACRI_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP5
  let AIPS1_PACRI_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP5
  let AIPS1_PACRI_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP5
  let AIPS1_PACRI_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP4
  let AIPS1_PACRI_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP4
  let AIPS1_PACRI_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP4
  let AIPS1_PACRI_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP3
  let AIPS1_PACRI_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP3
  let AIPS1_PACRI_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP3
  let AIPS1_PACRI_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP2
  let AIPS1_PACRI_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP2
  let AIPS1_PACRI_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP2
  let AIPS1_PACRI_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP1
  let AIPS1_PACRI_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP1
  let AIPS1_PACRI_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP1
  let AIPS1_PACRI_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRI, field TP0
  let AIPS1_PACRI_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRI_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRI, field WP0
  let AIPS1_PACRI_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRI_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRI, field SP0
  let AIPS1_PACRI_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRI_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP7
  let AIPS1_PACRJ_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP7
  let AIPS1_PACRJ_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP7
  let AIPS1_PACRJ_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP6
  let AIPS1_PACRJ_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP6
  let AIPS1_PACRJ_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP6
  let AIPS1_PACRJ_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP5
  let AIPS1_PACRJ_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP5
  let AIPS1_PACRJ_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP5
  let AIPS1_PACRJ_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP4
  let AIPS1_PACRJ_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP4
  let AIPS1_PACRJ_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP4
  let AIPS1_PACRJ_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP3
  let AIPS1_PACRJ_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP3
  let AIPS1_PACRJ_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP3
  let AIPS1_PACRJ_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP2
  let AIPS1_PACRJ_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP2
  let AIPS1_PACRJ_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP2
  let AIPS1_PACRJ_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP1
  let AIPS1_PACRJ_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP1
  let AIPS1_PACRJ_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP1
  let AIPS1_PACRJ_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRJ, field TP0
  let AIPS1_PACRJ_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRJ_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRJ, field WP0
  let AIPS1_PACRJ_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRJ_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRJ, field SP0
  let AIPS1_PACRJ_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRJ_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP7
  let AIPS1_PACRK_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP7
  let AIPS1_PACRK_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP7
  let AIPS1_PACRK_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP6
  let AIPS1_PACRK_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP6
  let AIPS1_PACRK_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP6
  let AIPS1_PACRK_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP5
  let AIPS1_PACRK_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP5
  let AIPS1_PACRK_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP5
  let AIPS1_PACRK_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP4
  let AIPS1_PACRK_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP4
  let AIPS1_PACRK_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP4
  let AIPS1_PACRK_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP3
  let AIPS1_PACRK_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP3
  let AIPS1_PACRK_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP3
  let AIPS1_PACRK_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP2
  let AIPS1_PACRK_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP2
  let AIPS1_PACRK_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP2
  let AIPS1_PACRK_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP1
  let AIPS1_PACRK_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP1
  let AIPS1_PACRK_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP1
  let AIPS1_PACRK_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRK, field TP0
  let AIPS1_PACRK_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRK_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRK, field WP0
  let AIPS1_PACRK_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRK_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRK, field SP0
  let AIPS1_PACRK_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRK_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP7
  let AIPS1_PACRL_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP7
  let AIPS1_PACRL_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP7
  let AIPS1_PACRL_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP6
  let AIPS1_PACRL_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP6
  let AIPS1_PACRL_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP6
  let AIPS1_PACRL_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP5
  let AIPS1_PACRL_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP5
  let AIPS1_PACRL_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP5
  let AIPS1_PACRL_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP4
  let AIPS1_PACRL_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP4
  let AIPS1_PACRL_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP4
  let AIPS1_PACRL_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP3
  let AIPS1_PACRL_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP3
  let AIPS1_PACRL_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP3
  let AIPS1_PACRL_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP2
  let AIPS1_PACRL_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP2
  let AIPS1_PACRL_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP2
  let AIPS1_PACRL_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP1
  let AIPS1_PACRL_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP1
  let AIPS1_PACRL_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP1
  let AIPS1_PACRL_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRL, field TP0
  let AIPS1_PACRL_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRL_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRL, field WP0
  let AIPS1_PACRL_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRL_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRL, field SP0
  let AIPS1_PACRL_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRL_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP7
  let AIPS1_PACRM_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP7
  let AIPS1_PACRM_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP7
  let AIPS1_PACRM_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP6
  let AIPS1_PACRM_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP6
  let AIPS1_PACRM_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP6
  let AIPS1_PACRM_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP5
  let AIPS1_PACRM_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP5
  let AIPS1_PACRM_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP5
  let AIPS1_PACRM_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP4
  let AIPS1_PACRM_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP4
  let AIPS1_PACRM_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP4
  let AIPS1_PACRM_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP3
  let AIPS1_PACRM_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP3
  let AIPS1_PACRM_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP3
  let AIPS1_PACRM_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP2
  let AIPS1_PACRM_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP2
  let AIPS1_PACRM_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP2
  let AIPS1_PACRM_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP1
  let AIPS1_PACRM_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP1
  let AIPS1_PACRM_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP1
  let AIPS1_PACRM_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRM, field TP0
  let AIPS1_PACRM_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRM_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRM, field WP0
  let AIPS1_PACRM_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRM_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRM, field SP0
  let AIPS1_PACRM_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRM_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP7
  let AIPS1_PACRN_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP7
  let AIPS1_PACRN_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP7
  let AIPS1_PACRN_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP6
  let AIPS1_PACRN_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP6
  let AIPS1_PACRN_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP6
  let AIPS1_PACRN_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP5
  let AIPS1_PACRN_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP5
  let AIPS1_PACRN_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP5
  let AIPS1_PACRN_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP4
  let AIPS1_PACRN_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP4
  let AIPS1_PACRN_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP4
  let AIPS1_PACRN_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP3
  let AIPS1_PACRN_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP3
  let AIPS1_PACRN_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP3
  let AIPS1_PACRN_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP2
  let AIPS1_PACRN_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP2
  let AIPS1_PACRN_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP2
  let AIPS1_PACRN_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP1
  let AIPS1_PACRN_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP1
  let AIPS1_PACRN_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP1
  let AIPS1_PACRN_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRN, field TP0
  let AIPS1_PACRN_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRN_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRN, field WP0
  let AIPS1_PACRN_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRN_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRN, field SP0
  let AIPS1_PACRN_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRN_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP7
  let AIPS1_PACRO_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP7
  let AIPS1_PACRO_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP7
  let AIPS1_PACRO_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP6
  let AIPS1_PACRO_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP6
  let AIPS1_PACRO_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP6
  let AIPS1_PACRO_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP5
  let AIPS1_PACRO_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP5
  let AIPS1_PACRO_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP5
  let AIPS1_PACRO_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP4
  let AIPS1_PACRO_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP4
  let AIPS1_PACRO_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP4
  let AIPS1_PACRO_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP3
  let AIPS1_PACRO_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP3
  let AIPS1_PACRO_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP3
  let AIPS1_PACRO_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP2
  let AIPS1_PACRO_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP2
  let AIPS1_PACRO_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP2
  let AIPS1_PACRO_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP1
  let AIPS1_PACRO_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP1
  let AIPS1_PACRO_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP1
  let AIPS1_PACRO_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRO, field TP0
  let AIPS1_PACRO_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRO_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRO, field WP0
  let AIPS1_PACRO_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRO_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRO, field SP0
  let AIPS1_PACRO_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRO_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP7
  let AIPS1_PACRP_TP7_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP7_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP7
  let AIPS1_PACRP_WP7_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP7_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP7
  let AIPS1_PACRP_SP7_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP7_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP6
  let AIPS1_PACRP_TP6_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP6_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP6
  let AIPS1_PACRP_WP6_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP6_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP6
  let AIPS1_PACRP_SP6_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP6_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP5
  let AIPS1_PACRP_TP5_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP5_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP5
  let AIPS1_PACRP_WP5_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP5_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP5
  let AIPS1_PACRP_SP5_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP5_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP4
  let AIPS1_PACRP_TP4_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP4_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP4
  let AIPS1_PACRP_WP4_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP4_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP4
  let AIPS1_PACRP_SP4_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP4_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP3
  let AIPS1_PACRP_TP3_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP3_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP3
  let AIPS1_PACRP_WP3_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP3_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP3
  let AIPS1_PACRP_SP3_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP3_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP2
  let AIPS1_PACRP_TP2_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP2_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP2
  let AIPS1_PACRP_WP2_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP2_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP2
  let AIPS1_PACRP_SP2_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP2_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP1
  let AIPS1_PACRP_TP1_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP1_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP1
  let AIPS1_PACRP_WP1_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP1_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP1
  let AIPS1_PACRP_SP1_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP1_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//--- Enumerated values for register PACRP, field TP0
  let AIPS1_PACRP_TP0_Accesses_0 $bool = no // Accesses from an untrusted master are allowed.
  let AIPS1_PACRP_TP0_Accesses_1 $bool = yes // Accesses from an untrusted master are not allowed.

//--- Enumerated values for register PACRP, field WP0
  let AIPS1_PACRP_WP0_This_0 $bool = no // This peripheral allows write accesses.
  let AIPS1_PACRP_WP0_This_1 $bool = yes // This peripheral is write protected.

//--- Enumerated values for register PACRP, field SP0
  let AIPS1_PACRP_SP0_This_0 $bool = no // This peripheral does not require supervisor privilege level for accesses.
  let AIPS1_PACRP_SP0_This_1 $bool = yes // This peripheral requires supervisor privilege level for accesses.

//------------------------------------------------------------------------------
// Peripheral AXBS: Crossbar switch
//------------------------------------------------------------------------------

registers ©AXBS @at 0x40004000 {
//---  Registers PRS(0,1,2,3,4): Priority Registers Slave
  PRS [5 @offset 0x0 @inc 0x100]
  PRS0 @offset 0x0
  PRS1 @offset 0x100
  PRS2 @offset 0x200
  PRS3 @offset 0x300
  PRS4 @offset 0x400 $u32 {
    5
    M6:3 // at 24: Master 6 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M5:3 // at 20: Master 5 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M4:3 // at 16: Master 4 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M3:3 // at 12: Master 3 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M2:3 // at 8: Master 2 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M1:3 // at 4: Master 1 Priority. Sets the arbitration priority for this port on the associated slave port.
    1
    M0:3 // at 0: Master 0 Priority. Sets the arbitration priority for this port on the associated slave port.
  }

//---  Registers CRS(0,1,2,3,4): Control Register
  CRS [5 @offset 0x10 @inc 0x100]
  CRS0 @offset 0x10
  CRS1 @offset 0x110
  CRS2 @offset 0x210
  CRS3 @offset 0x310
  CRS4 @offset 0x410 $u32 {
    RO // at 31: Read Only
    HLP // at 30: Halt Low Priority
    20
    ARB:2 // at 8: Arbitration Mode
    2
    PCTL:2 // at 4: Parking Control
    1
    PARK:3 // at 0: Park
  }

//---  Registers MGPCR(0,1,2,3,4,5,6): Master General Purpose Control Register
  MGPCR [7 @offset 0x800 @inc 0x100]
  MGPCR0 @offset 0x800
  MGPCR1 @offset 0x900
  MGPCR2 @offset 0xa00
  MGPCR3 @offset 0xb00
  MGPCR4 @offset 0xc00
  MGPCR5 @offset 0xd00
  MGPCR6 @offset 0xe00 $u32 {
    29
    AULB:3 // at 0: Arbitrates On Undefined Length Bursts
  }

}

//--- Enumerated values for register PRS%s, field M0
  let AXBS_PRS_M0_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M0_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M0_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M0_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M0_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M0_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M0_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M0_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register PRS%s, field M1
  let AXBS_PRS_M1_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M1_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M1_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M1_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M1_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M1_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M1_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M1_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register PRS%s, field M2
  let AXBS_PRS_M2_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M2_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M2_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M2_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M2_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M2_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M2_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M2_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register PRS%s, field M3
  let AXBS_PRS_M3_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M3_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M3_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M3_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M3_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M3_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M3_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M3_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register PRS%s, field M4
  let AXBS_PRS_M4_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M4_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M4_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M4_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M4_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M4_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M4_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M4_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register PRS%s, field M5
  let AXBS_PRS_M5_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M5_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M5_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M5_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M5_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M5_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M5_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M5_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register PRS%s, field M6
  let AXBS_PRS_M6_This_000 $u3 = 0 // This master has level 1, or highest, priority when accessing the slave port.
  let AXBS_PRS_M6_This_001 $u3 = 1 // This master has level 2 priority when accessing the slave port.
  let AXBS_PRS_M6_This_010 $u3 = 2 // This master has level 3 priority when accessing the slave port.
  let AXBS_PRS_M6_This_011 $u3 = 3 // This master has level 4 priority when accessing the slave port.
  let AXBS_PRS_M6_This_100 $u3 = 4 // This master has level 5 priority when accessing the slave port.
  let AXBS_PRS_M6_This_101 $u3 = 5 // This master has level 6 priority when accessing the slave port.
  let AXBS_PRS_M6_This_110 $u3 = 6 // This master has level 7 priority when accessing the slave port.
  let AXBS_PRS_M6_This_111 $u3 = 7 // This master has level 8, or lowest, priority when accessing the slave port.

//--- Enumerated values for register CRS%s, field PARK
  let AXBS_CRS_PARK_Park_000 $u3 = 0 // Park on master port M0
  let AXBS_CRS_PARK_Park_001 $u3 = 1 // Park on master port M1
  let AXBS_CRS_PARK_Park_010 $u3 = 2 // Park on master port M2
  let AXBS_CRS_PARK_Park_011 $u3 = 3 // Park on master port M3
  let AXBS_CRS_PARK_Park_100 $u3 = 4 // Park on master port M4
  let AXBS_CRS_PARK_Park_101 $u3 = 5 // Park on master port M5
  let AXBS_CRS_PARK_Park_110 $u3 = 6 // Park on master port M6
  let AXBS_CRS_PARK_Park_111 $u3 = 7 // Park on master port M7

//--- Enumerated values for register CRS%s, field PCTL
  let AXBS_CRS_PCTL_When_00 $u2 = 0 // When no master makes a request, the arbiter parks the slave port on the master port defined by the PARK field
  let AXBS_CRS_PCTL_When_01 $u2 = 1 // When no master makes a request, the arbiter parks the slave port on the last master to be in control of the slave port
  let AXBS_CRS_PCTL_When_10 $u2 = 2 // When no master makes a request, the slave port is not parked on a master and the arbiter drives all outputs to a constant safe state

//--- Enumerated values for register CRS%s, field ARB
  let AXBS_CRS_ARB_Fixed_00 $u2 = 0 // Fixed priority
  let AXBS_CRS_ARB_Round_robin__01 $u2 = 1 // Round-robin, or rotating, priority

//--- Enumerated values for register CRS%s, field HLP
  let AXBS_CRS_HLP_The_0 $bool = no // The low power mode request has the highest priority for arbitration on this slave port
  let AXBS_CRS_HLP_The_1 $bool = yes // The low power mode request has the lowest initial priority for arbitration on this slave port

//--- Enumerated values for register CRS%s, field RO
  let AXBS_CRS_RO_The_0 $bool = no // The slave port's registers are writeable
  let AXBS_CRS_RO_The_1 $bool = yes // The slave port's registers are read-only and cannot be written. Attempted writes have no effect on the registers and result in a bus error response.

//--- Enumerated values for register MGPCR%s, field AULB
  let AXBS_MGPCR_AULB_No_000 $u3 = 0 // No arbitration is allowed during an undefined length burst
  let AXBS_MGPCR_AULB_Arbitration_001 $u3 = 1 // Arbitration is allowed at any time during an undefined length burst
  let AXBS_MGPCR_AULB_Arbitration_010 $u3 = 2 // Arbitration is allowed after four beats of an undefined length burst
  let AXBS_MGPCR_AULB_Arbitration_011 $u3 = 3 // Arbitration is allowed after eight beats of an undefined length burst
  let AXBS_MGPCR_AULB_Arbitration_100 $u3 = 4 // Arbitration is allowed after 16 beats of an undefined length burst

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©CAN [2]
//        CAN0 at 0x40024000
//        CAN1 at 0x400a4000
//------------------------------------------------------------------------------

registers ©CAN [2 @at 0x40024000 0x400a4000]
          ©CAN0 @at 0x40024000
          ©CAN1 @at 0x400a4000 {
//---  Register MCR: Module Configuration Register
  MCR @offset 0x0 $u32 {
    MDIS // at 31: Module Disable
    FRZ // at 30: Freeze Enable
    RFEN // at 29: Rx FIFO Enable
    HALT // at 28: Halt FlexCAN
    NOTRDY // at 27: FlexCAN Not Ready
    WAKMSK // at 26: Wake Up Interrupt Mask
    SOFTRST // at 25: Soft Reset
    FRZACK // at 24: Freeze Mode Acknowledge
    SUPV // at 23: Supervisor Mode
    SLFWAK // at 22: Self Wake Up
    WRNEN // at 21: Warning Interrupt Enable
    LPMACK // at 20: Low-Power Mode Acknowledge
    WAKSRC // at 19: Wake Up Source
    1
    SRXDIS // at 17: Self Reception Disable
    IRMQ // at 16: Individual Rx Masking And Queue Enable
    2
    LPRIOEN // at 13: Local Priority Enable
    AEN // at 12: Abort Enable
    2
    IDAM:2 // at 8: ID Acceptance Mode
    1
    MAXMB:7 // at 0: Number Of The Last Message Buffer
  }

//---  Register CTRL1: Control 1 register
  CTRL1 @offset 0x4 $u32 {
    PRESDIV:8 // at 24: Prescaler Division Factor
    RJW:2 // at 22: Resync Jump Width
    PSEG1:3 // at 19: Phase Segment 1
    PSEG2:3 // at 16: Phase Segment 2
    BOFFMSK // at 15: Bus Off Mask
    ERRMSK // at 14: Error Mask
    CLKSRC // at 13: CAN Engine Clock Source
    LPB // at 12: Loop Back Mode
    TWRNMSK // at 11: Tx Warning Interrupt Mask
    RWRNMSK // at 10: Rx Warning Interrupt Mask
    2
    SMP // at 7: CAN Bit Sampling
    BOFFREC // at 6: Bus Off Recovery
    TSYN // at 5: Timer Sync
    LBUF // at 4: Lowest Buffer Transmitted First
    LOM // at 3: Listen-Only Mode
    PROPSEG:3 // at 0: Propagation Segment
  }

//---  Register TIMER: Free Running Timer
  TIMER @offset 0x8 $u32 {
    16
    TIMER:16 // at 0: Timer Value
  }

//---  Register RXMGMASK: Rx Mailboxes Global Mask Register
  RXMGMASK @offset 0x10 $u32 {
    MG:32 // at 0: Rx Mailboxes Global Mask Bits
  }

//---  Register RX14MASK: Rx 14 Mask register
  RX14MASK @offset 0x14 $u32 {
    RX14M:32 // at 0: Rx Buffer 14 Mask Bits
  }

//---  Register RX15MASK: Rx 15 Mask register
  RX15MASK @offset 0x18 $u32 {
    RX15M:32 // at 0: Rx Buffer 15 Mask Bits
  }

//---  Register ECR: Error Counter
  ECR @offset 0x1c $u32 {
    16
    RXERRCNT:8 // at 8: Receive Error Counter
    TXERRCNT:8 // at 0: Transmit Error Counter
  }

//---  Register ESR1: Error and Status 1 register
  ESR1 @offset 0x20 $u32 {
    13
    SYNCH // at 18: CAN Synchronization Status
    TWRNINT // at 17: Tx Warning Interrupt Flag
    RWRNINT // at 16: Rx Warning Interrupt Flag
    BIT1ERR // at 15: Bit1 Error
    BIT0ERR // at 14: Bit0 Error
    ACKERR // at 13: Acknowledge Error
    CRCERR // at 12: Cyclic Redundancy Check Error
    FRMERR // at 11: Form Error
    STFERR // at 10: Stuffing Error
    TXWRN // at 9: TX Error Warning
    RXWRN // at 8: Rx Error Warning
    IDLE // at 7: This bit indicates when CAN bus is in IDLE state
    TX // at 6: FlexCAN In Transmission
    FLTCONF:2 // at 4: Fault Confinement State
    RX // at 3: FlexCAN In Reception
    BOFFINT // at 2: Bus Off Interrupt
    ERRINT // at 1: Error Interrupt
    WAKINT // at 0: Wake-Up Interrupt
  }

//---  Register IMASK1: Interrupt Masks 1 register
  IMASK1 @offset 0x28 $u32 {
    BUFLM:32 // at 0: Buffer MB i Mask
  }

//---  Register IFLAG1: Interrupt Flags 1 register
  IFLAG1 @offset 0x30 $u32 {
    BUF31TO8I:24 // at 8: Buffer MBi Interrupt
    BUF7I // at 7: Buffer MB7 Interrupt Or "Rx FIFO Overflow"
    BUF6I // at 6: Buffer MB6 Interrupt Or "Rx FIFO Warning"
    BUF5I // at 5: Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
    BUF4TO1I:4 // at 1: Buffer MB i Interrupt Or "reserved"
    BUF0I // at 0: Buffer MB0 Interrupt Or "reserved"
  }

//---  Register CTRL2: Control 2 register
  CTRL2 @offset 0x34 $u32 {
    3
    WRMFRZ // at 28: Write-Access To Memory In Freeze Mode
    RFFN:4 // at 24: Number Of Rx FIFO Filters
    TASD:5 // at 19: Tx Arbitration Start Delay
    MRP // at 18: Mailboxes Reception Priority
    RRS // at 17: Remote Request Storing
    EACEN // at 16: Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
    16
  }

//---  Register ESR2: Error and Status 2 register
  ESR2 @offset 0x38 @ro $u32 {
    9
    LPTM:7 // at 16: Lowest Priority Tx Mailbox
    1
    VPS // at 14: Valid Priority Status
    IMB // at 13: Inactive Mailbox
    13
  }

//---  Register CRCR: CRC Register
  CRCR @offset 0x44 @ro $u32 {
    9
    MBCRC:7 // at 16: CRC Mailbox
    1
    TXCRC:15 // at 0: CRC Transmitted
  }

//---  Register RXFGMASK: Rx FIFO Global Mask register
  RXFGMASK @offset 0x48 $u32 {
    FGM:32 // at 0: Rx FIFO Global Mask Bits
  }

//---  Register RXFIR: Rx FIFO Information Register
  RXFIR @offset 0x4c @ro $u32 {
    23
    IDHIT:9 // at 0: Identifier Acceptance Filter Hit Indicator
  }

//---  Register CS0: Message Buffer 0 CS Register
  CS0 @offset 0x80 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID0: Message Buffer 0 ID Register
  ID0 @offset 0x84 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD00: Message Buffer 0 WORD0 Register
  WORD00 @offset 0x88 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD10: Message Buffer 0 WORD1 Register
  WORD10 @offset 0x8c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS1: Message Buffer 1 CS Register
  CS1 @offset 0x90 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID1: Message Buffer 1 ID Register
  ID1 @offset 0x94 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD01: Message Buffer 1 WORD0 Register
  WORD01 @offset 0x98 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD11: Message Buffer 1 WORD1 Register
  WORD11 @offset 0x9c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS2: Message Buffer 2 CS Register
  CS2 @offset 0xa0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID2: Message Buffer 2 ID Register
  ID2 @offset 0xa4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD02: Message Buffer 2 WORD0 Register
  WORD02 @offset 0xa8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD12: Message Buffer 2 WORD1 Register
  WORD12 @offset 0xac $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS3: Message Buffer 3 CS Register
  CS3 @offset 0xb0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID3: Message Buffer 3 ID Register
  ID3 @offset 0xb4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD03: Message Buffer 3 WORD0 Register
  WORD03 @offset 0xb8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD13: Message Buffer 3 WORD1 Register
  WORD13 @offset 0xbc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS4: Message Buffer 4 CS Register
  CS4 @offset 0xc0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID4: Message Buffer 4 ID Register
  ID4 @offset 0xc4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD04: Message Buffer 4 WORD0 Register
  WORD04 @offset 0xc8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD14: Message Buffer 4 WORD1 Register
  WORD14 @offset 0xcc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS5: Message Buffer 5 CS Register
  CS5 @offset 0xd0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID5: Message Buffer 5 ID Register
  ID5 @offset 0xd4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD05: Message Buffer 5 WORD0 Register
  WORD05 @offset 0xd8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD15: Message Buffer 5 WORD1 Register
  WORD15 @offset 0xdc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS6: Message Buffer 6 CS Register
  CS6 @offset 0xe0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID6: Message Buffer 6 ID Register
  ID6 @offset 0xe4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD06: Message Buffer 6 WORD0 Register
  WORD06 @offset 0xe8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD16: Message Buffer 6 WORD1 Register
  WORD16 @offset 0xec $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS7: Message Buffer 7 CS Register
  CS7 @offset 0xf0 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID7: Message Buffer 7 ID Register
  ID7 @offset 0xf4 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD07: Message Buffer 7 WORD0 Register
  WORD07 @offset 0xf8 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD17: Message Buffer 7 WORD1 Register
  WORD17 @offset 0xfc $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS8: Message Buffer 8 CS Register
  CS8 @offset 0x100 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID8: Message Buffer 8 ID Register
  ID8 @offset 0x104 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD08: Message Buffer 8 WORD0 Register
  WORD08 @offset 0x108 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD18: Message Buffer 8 WORD1 Register
  WORD18 @offset 0x10c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS9: Message Buffer 9 CS Register
  CS9 @offset 0x110 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID9: Message Buffer 9 ID Register
  ID9 @offset 0x114 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD09: Message Buffer 9 WORD0 Register
  WORD09 @offset 0x118 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD19: Message Buffer 9 WORD1 Register
  WORD19 @offset 0x11c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS10: Message Buffer 10 CS Register
  CS10 @offset 0x120 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID10: Message Buffer 10 ID Register
  ID10 @offset 0x124 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD010: Message Buffer 10 WORD0 Register
  WORD010 @offset 0x128 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD110: Message Buffer 10 WORD1 Register
  WORD110 @offset 0x12c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS11: Message Buffer 11 CS Register
  CS11 @offset 0x130 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID11: Message Buffer 11 ID Register
  ID11 @offset 0x134 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD011: Message Buffer 11 WORD0 Register
  WORD011 @offset 0x138 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD111: Message Buffer 11 WORD1 Register
  WORD111 @offset 0x13c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS12: Message Buffer 12 CS Register
  CS12 @offset 0x140 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID12: Message Buffer 12 ID Register
  ID12 @offset 0x144 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD012: Message Buffer 12 WORD0 Register
  WORD012 @offset 0x148 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD112: Message Buffer 12 WORD1 Register
  WORD112 @offset 0x14c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS13: Message Buffer 13 CS Register
  CS13 @offset 0x150 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID13: Message Buffer 13 ID Register
  ID13 @offset 0x154 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD013: Message Buffer 13 WORD0 Register
  WORD013 @offset 0x158 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD113: Message Buffer 13 WORD1 Register
  WORD113 @offset 0x15c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS14: Message Buffer 14 CS Register
  CS14 @offset 0x160 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID14: Message Buffer 14 ID Register
  ID14 @offset 0x164 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD014: Message Buffer 14 WORD0 Register
  WORD014 @offset 0x168 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD114: Message Buffer 14 WORD1 Register
  WORD114 @offset 0x16c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Register CS15: Message Buffer 15 CS Register
  CS15 @offset 0x170 $u32 {
    4
    CODE:4 // at 24: Reserved
    1
    SRR // at 22: Substitute Remote Request. Contains a fixed recessive bit.
    IDE // at 21: ID Extended. One/zero for extended/standard format frame.
    RTR // at 20: Remote Transmission Request. One/zero for remote/data frame.
    DLC:4 // at 16: Length of the data to be stored/transmitted.
    TIME_STAMP:16 // at 0: Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
  }

//---  Register ID15: Message Buffer 15 ID Register
  ID15 @offset 0x174 $u32 {
    PRIO:3 // at 29: Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    STD:11 // at 18: Contains standard/extended (HIGH word) identifier of message buffer.
    EXT:18 // at 0: Contains extended (LOW word) identifier of message buffer.
  }

//---  Register WORD015: Message Buffer 15 WORD0 Register
  WORD015 @offset 0x178 $u32 {
    DATA_BYTE_0:8 // at 24: Data byte 0 of Rx/Tx frame.
    DATA_BYTE_1:8 // at 16: Data byte 1 of Rx/Tx frame.
    DATA_BYTE_2:8 // at 8: Data byte 2 of Rx/Tx frame.
    DATA_BYTE_3:8 // at 0: Data byte 3 of Rx/Tx frame.
  }

//---  Register WORD115: Message Buffer 15 WORD1 Register
  WORD115 @offset 0x17c $u32 {
    DATA_BYTE_4:8 // at 24: Data byte 4 of Rx/Tx frame.
    DATA_BYTE_5:8 // at 16: Data byte 5 of Rx/Tx frame.
    DATA_BYTE_6:8 // at 8: Data byte 6 of Rx/Tx frame.
    DATA_BYTE_7:8 // at 0: Data byte 7 of Rx/Tx frame.
  }

//---  Registers RXIMR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Rx Individual Mask Registers
  RXIMR [16 @offset 0x880 @inc 0x4]
  RXIMR0 @offset 0x880
  RXIMR1 @offset 0x884
  RXIMR2 @offset 0x888
  RXIMR3 @offset 0x88c
  RXIMR4 @offset 0x890
  RXIMR5 @offset 0x894
  RXIMR6 @offset 0x898
  RXIMR7 @offset 0x89c
  RXIMR8 @offset 0x8a0
  RXIMR9 @offset 0x8a4
  RXIMR10 @offset 0x8a8
  RXIMR11 @offset 0x8ac
  RXIMR12 @offset 0x8b0
  RXIMR13 @offset 0x8b4
  RXIMR14 @offset 0x8b8
  RXIMR15 @offset 0x8bc $u32 {
    MI:32 // at 0: Individual Mask Bits
  }

}

//--- Enumerated values for register MCR, field IDAM
  let CAN0_MCR_IDAM_Format_00 $u2 = 0 // Format A: One full ID (standard and extended) per ID Filter Table element.
  let CAN0_MCR_IDAM_Format_01 $u2 = 1 // Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
  let CAN0_MCR_IDAM_Format_10 $u2 = 2 // Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
  let CAN0_MCR_IDAM_Format_11 $u2 = 3 // Format D: All frames rejected.

//--- Enumerated values for register MCR, field AEN
  let CAN0_MCR_AEN_Abort_0 $bool = no // Abort disabled.
  let CAN0_MCR_AEN_Abort_1 $bool = yes // Abort enabled.

//--- Enumerated values for register MCR, field LPRIOEN
  let CAN0_MCR_LPRIOEN_Local_0 $bool = no // Local Priority disabled.
  let CAN0_MCR_LPRIOEN_Local_1 $bool = yes // Local Priority enabled.

//--- Enumerated values for register MCR, field IRMQ
  let CAN0_MCR_IRMQ_Individual_0 $bool = no // Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
  let CAN0_MCR_IRMQ_Individual_1 $bool = yes // Individual Rx masking and queue feature are enabled.

//--- Enumerated values for register MCR, field SRXDIS
  let CAN0_MCR_SRXDIS_Self_0 $bool = no // Self reception enabled.
  let CAN0_MCR_SRXDIS_Self_1 $bool = yes // Self reception disabled.

//--- Enumerated values for register MCR, field WAKSRC
  let CAN0_MCR_WAKSRC_FlexCAN_0 $bool = no // FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
  let CAN0_MCR_WAKSRC_FlexCAN_1 $bool = yes // FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.

//--- Enumerated values for register MCR, field LPMACK
  let CAN0_MCR_LPMACK_FlexCAN_0 $bool = no // FlexCAN is not in a low-power mode.
  let CAN0_MCR_LPMACK_FlexCAN_1 $bool = yes // FlexCAN is in a low-power mode.

//--- Enumerated values for register MCR, field WRNEN
  let CAN0_MCR_WRNEN_TWRNINT_0 $bool = no // TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
  let CAN0_MCR_WRNEN_TWRNINT_1 $bool = yes // TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.

//--- Enumerated values for register MCR, field SLFWAK
  let CAN0_MCR_SLFWAK_FlexCAN_0 $bool = no // FlexCAN Self Wake Up feature is disabled.
  let CAN0_MCR_SLFWAK_FlexCAN_1 $bool = yes // FlexCAN Self Wake Up feature is enabled.

//--- Enumerated values for register MCR, field SUPV
  let CAN0_MCR_SUPV_FlexCAN_0 $bool = no // FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses .
  let CAN0_MCR_SUPV_FlexCAN_1 $bool = yes // FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location .

//--- Enumerated values for register MCR, field FRZACK
  let CAN0_MCR_FRZACK_FlexCAN_0 $bool = no // FlexCAN not in Freeze mode, prescaler running.
  let CAN0_MCR_FRZACK_FlexCAN_1 $bool = yes // FlexCAN in Freeze mode, prescaler stopped.

//--- Enumerated values for register MCR, field SOFTRST
  let CAN0_MCR_SOFTRST_No_0 $bool = no // No reset request.
  let CAN0_MCR_SOFTRST_Resets_1 $bool = yes // Resets the registers affected by soft reset.

//--- Enumerated values for register MCR, field WAKMSK
  let CAN0_MCR_WAKMSK_Wake_0 $bool = no // Wake Up Interrupt is disabled.
  let CAN0_MCR_WAKMSK_Wake_1 $bool = yes // Wake Up Interrupt is enabled.

//--- Enumerated values for register MCR, field NOTRDY
  let CAN0_MCR_NOTRDY_FlexCAN_0 $bool = no // FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
  let CAN0_MCR_NOTRDY_FlexCAN_1 $bool = yes // FlexCAN module is either in Disable mode , Stop mode or Freeze mode.

//--- Enumerated values for register MCR, field HALT
  let CAN0_MCR_HALT_No_0 $bool = no // No Freeze mode request.
  let CAN0_MCR_HALT_Enters_1 $bool = yes // Enters Freeze mode if the FRZ bit is asserted.

//--- Enumerated values for register MCR, field RFEN
  let CAN0_MCR_RFEN_Rx_0 $bool = no // Rx FIFO not enabled.
  let CAN0_MCR_RFEN_Rx_1 $bool = yes // Rx FIFO enabled.

//--- Enumerated values for register MCR, field FRZ
  let CAN0_MCR_FRZ_Not_0 $bool = no // Not enabled to enter Freeze mode.
  let CAN0_MCR_FRZ_Enabled_1 $bool = yes // Enabled to enter Freeze mode.

//--- Enumerated values for register MCR, field MDIS
  let CAN0_MCR_MDIS_Enable_0 $bool = no // Enable the FlexCAN module.
  let CAN0_MCR_MDIS_Disable_1 $bool = yes // Disable the FlexCAN module.

//--- Enumerated values for register CTRL1, field LOM
  let CAN0_CTRL1_LOM_Listen_Only_0 $bool = no // Listen-Only mode is deactivated.
  let CAN0_CTRL1_LOM_FlexCAN_1 $bool = yes // FlexCAN module operates in Listen-Only mode.

//--- Enumerated values for register CTRL1, field LBUF
  let CAN0_CTRL1_LBUF_Buffer_0 $bool = no // Buffer with highest priority is transmitted first.
  let CAN0_CTRL1_LBUF_Lowest_1 $bool = yes // Lowest number buffer is transmitted first.

//--- Enumerated values for register CTRL1, field TSYN
  let CAN0_CTRL1_TSYN_Timer_0 $bool = no // Timer Sync feature disabled
  let CAN0_CTRL1_TSYN_Timer_1 $bool = yes // Timer Sync feature enabled

//--- Enumerated values for register CTRL1, field BOFFREC
  let CAN0_CTRL1_BOFFREC_Automatic_0 $bool = no // Automatic recovering from Bus Off state enabled, according to CAN Spec 2.0 part B.
  let CAN0_CTRL1_BOFFREC_Automatic_1 $bool = yes // Automatic recovering from Bus Off state disabled.

//--- Enumerated values for register CTRL1, field SMP
  let CAN0_CTRL1_SMP_Just_0 $bool = no // Just one sample is used to determine the bit value.
  let CAN0_CTRL1_SMP_Three_1 $bool = yes // Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.

//--- Enumerated values for register CTRL1, field RWRNMSK
  let CAN0_CTRL1_RWRNMSK_Rx_0 $bool = no // Rx Warning Interrupt disabled.
  let CAN0_CTRL1_RWRNMSK_Rx_1 $bool = yes // Rx Warning Interrupt enabled.

//--- Enumerated values for register CTRL1, field TWRNMSK
  let CAN0_CTRL1_TWRNMSK_Tx_0 $bool = no // Tx Warning Interrupt disabled.
  let CAN0_CTRL1_TWRNMSK_Tx_1 $bool = yes // Tx Warning Interrupt enabled.

//--- Enumerated values for register CTRL1, field LPB
  let CAN0_CTRL1_LPB_Loop_0 $bool = no // Loop Back disabled.
  let CAN0_CTRL1_LPB_Loop_1 $bool = yes // Loop Back enabled.

//--- Enumerated values for register CTRL1, field CLKSRC
  let CAN0_CTRL1_CLKSRC_The_0 $bool = no // The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
  let CAN0_CTRL1_CLKSRC_The_1 $bool = yes // The CAN engine clock source is the peripheral clock.

//--- Enumerated values for register CTRL1, field ERRMSK
  let CAN0_CTRL1_ERRMSK_Error_0 $bool = no // Error interrupt disabled.
  let CAN0_CTRL1_ERRMSK_Error_1 $bool = yes // Error interrupt enabled.

//--- Enumerated values for register CTRL1, field BOFFMSK
  let CAN0_CTRL1_BOFFMSK_Bus_0 $bool = no // Bus Off interrupt disabled.
  let CAN0_CTRL1_BOFFMSK_Bus_1 $bool = yes // Bus Off interrupt enabled.

//--- Enumerated values for register RXMGMASK, field MG
  let CAN0_RXMGMASK_MG_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN0_RXMGMASK_MG_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register RX14MASK, field RX14M
  let CAN0_RX14MASK_RX14M_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN0_RX14MASK_RX14M_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register RX15MASK, field RX15M
  let CAN0_RX15MASK_RX15M_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN0_RX15MASK_RX15M_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register ESR1, field WAKINT
  let CAN0_ESR1_WAKINT_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_WAKINT_Indicates_1 $bool = yes // Indicates a recessive to dominant transition was received on the CAN bus.

//--- Enumerated values for register ESR1, field ERRINT
  let CAN0_ESR1_ERRINT_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_ERRINT_Indicates_1 $bool = yes // Indicates setting of any Error Bit in the Error and Status Register.

//--- Enumerated values for register ESR1, field BOFFINT
  let CAN0_ESR1_BOFFINT_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_BOFFINT_FlexCAN_1 $bool = yes // FlexCAN module entered Bus Off state.

//--- Enumerated values for register ESR1, field RX
  let CAN0_ESR1_RX_FlexCAN_0 $bool = no // FlexCAN is not receiving a message.
  let CAN0_ESR1_RX_FlexCAN_1 $bool = yes // FlexCAN is receiving a message.

//--- Enumerated values for register ESR1, field FLTCONF
  let CAN0_ESR1_FLTCONF_Error_00 $u2 = 0 // Error Active
  let CAN0_ESR1_FLTCONF_Error_01 $u2 = 1 // Error Passive
  let CAN0_ESR1_FLTCONF_Bus_1x $u2 = 2 // Bus Off

//--- Enumerated values for register ESR1, field TX
  let CAN0_ESR1_TX_FlexCAN_0 $bool = no // FlexCAN is not transmitting a message.
  let CAN0_ESR1_TX_FlexCAN_1 $bool = yes // FlexCAN is transmitting a message.

//--- Enumerated values for register ESR1, field IDLE
  let CAN0_ESR1_IDLE_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_IDLE_CAN_1 $bool = yes // CAN bus is now IDLE.

//--- Enumerated values for register ESR1, field RXWRN
  let CAN0_ESR1_RXWRN_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_RXWRN_RXERRCNT_1 $bool = yes // RXERRCNT is greater than or equal to 96.

//--- Enumerated values for register ESR1, field TXWRN
  let CAN0_ESR1_TXWRN_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_TXWRN_TXERRCNT_1 $bool = yes // TXERRCNT is greater than or equal to 96.

//--- Enumerated values for register ESR1, field STFERR
  let CAN0_ESR1_STFERR_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_STFERR_A_1 $bool = yes // A Stuffing Error occurred since last read of this register.

//--- Enumerated values for register ESR1, field FRMERR
  let CAN0_ESR1_FRMERR_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_FRMERR_A_1 $bool = yes // A Form Error occurred since last read of this register.

//--- Enumerated values for register ESR1, field CRCERR
  let CAN0_ESR1_CRCERR_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_CRCERR_A_1 $bool = yes // A CRC error occurred since last read of this register.

//--- Enumerated values for register ESR1, field ACKERR
  let CAN0_ESR1_ACKERR_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_ACKERR_An_1 $bool = yes // An ACK error occurred since last read of this register.

//--- Enumerated values for register ESR1, field BIT0ERR
  let CAN0_ESR1_BIT0ERR_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_BIT0ERR_At_1 $bool = yes // At least one bit sent as dominant is received as recessive.

//--- Enumerated values for register ESR1, field BIT1ERR
  let CAN0_ESR1_BIT1ERR_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_BIT1ERR_At_1 $bool = yes // At least one bit sent as recessive is received as dominant.

//--- Enumerated values for register ESR1, field RWRNINT
  let CAN0_ESR1_RWRNINT_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_RWRNINT_The_1 $bool = yes // The Rx error counter transitioned from less than 96 to greater than or equal to 96.

//--- Enumerated values for register ESR1, field TWRNINT
  let CAN0_ESR1_TWRNINT_No_0 $bool = no // No such occurrence.
  let CAN0_ESR1_TWRNINT_The_1 $bool = yes // The Tx error counter transitioned from less than 96 to greater than or equal to 96.

//--- Enumerated values for register ESR1, field SYNCH
  let CAN0_ESR1_SYNCH_FlexCAN_0 $bool = no // FlexCAN is not synchronized to the CAN bus.
  let CAN0_ESR1_SYNCH_FlexCAN_1 $bool = yes // FlexCAN is synchronized to the CAN bus.

//--- Enumerated values for register IMASK1, field BUFLM
  let CAN0_IMASK1_BUFLM_The_0 $u32 = 0 // The corresponding buffer Interrupt is disabled.
  let CAN0_IMASK1_BUFLM_The_1 $u32 = 1 // The corresponding buffer Interrupt is enabled.

//--- Enumerated values for register IFLAG1, field BUF0I
  let CAN0_IFLAG1_BUF0I_The_0 $bool = no // The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
  let CAN0_IFLAG1_BUF0I_The_1 $bool = yes // The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.

//--- Enumerated values for register IFLAG1, field BUF4TO1I
  let CAN0_IFLAG1_BUF4TO1I_The_0 $u4 = 0 // The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
  let CAN0_IFLAG1_BUF4TO1I_The_1 $u4 = 1 // The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.

//--- Enumerated values for register IFLAG1, field BUF5I
  let CAN0_IFLAG1_BUF5I_No_0 $bool = no // No occurrence of MB5 completing transmission/reception when MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
  let CAN0_IFLAG1_BUF5I_MB5_1 $bool = yes // MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s) available in the Rx FIFO when MCR[RFEN]=1

//--- Enumerated values for register IFLAG1, field BUF6I
  let CAN0_IFLAG1_BUF6I_No_0 $bool = no // No occurrence of MB6 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
  let CAN0_IFLAG1_BUF6I_MB6_1 $bool = yes // MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO almost full when MCR[RFEN]=1

//--- Enumerated values for register IFLAG1, field BUF7I
  let CAN0_IFLAG1_BUF7I_No_0 $bool = no // No occurrence of MB7 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
  let CAN0_IFLAG1_BUF7I_MB7_1 $bool = yes // MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO overflow when MCR[RFEN]=1

//--- Enumerated values for register IFLAG1, field BUF31TO8I
  let CAN0_IFLAG1_BUF31TO8I_The_0 $u24 = 0 // The corresponding buffer has no occurrence of successfully completed transmission or reception.
  let CAN0_IFLAG1_BUF31TO8I_The_1 $u24 = 1 // The corresponding buffer has successfully completed transmission or reception.

//--- Enumerated values for register CTRL2, field EACEN
  let CAN0_CTRL2_EACEN_Rx_0 $bool = no // Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
  let CAN0_CTRL2_EACEN_Enables_1 $bool = yes // Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.

//--- Enumerated values for register CTRL2, field RRS
  let CAN0_CTRL2_RRS_Remote_0 $bool = no // Remote Response Frame is generated.
  let CAN0_CTRL2_RRS_Remote_1 $bool = yes // Remote Request Frame is stored.

//--- Enumerated values for register CTRL2, field MRP
  let CAN0_CTRL2_MRP_Matching_0 $bool = no // Matching starts from Rx FIFO and continues on Mailboxes.
  let CAN0_CTRL2_MRP_Matching_1 $bool = yes // Matching starts from Mailboxes and continues on Rx FIFO.

//--- Enumerated values for register CTRL2, field WRMFRZ
  let CAN0_CTRL2_WRMFRZ_Maintain_0 $bool = no // Maintain the write access restrictions.
  let CAN0_CTRL2_WRMFRZ_Enable_1 $bool = yes // Enable unrestricted write access to FlexCAN memory.

//--- Enumerated values for register ESR2, field IMB
  let CAN0_ESR2_IMB_If_0 $bool = no // If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
  let CAN0_ESR2_IMB_If_1 $bool = yes // If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.

//--- Enumerated values for register ESR2, field VPS
  let CAN0_ESR2_VPS_Contents_0 $bool = no // Contents of IMB and LPTM are invalid.
  let CAN0_ESR2_VPS_Contents_1 $bool = yes // Contents of IMB and LPTM are valid.

//--- Enumerated values for register RXFGMASK, field FGM
  let CAN0_RXFGMASK_FGM_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN0_RXFGMASK_FGM_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register RXIMR%s, field MI
  let CAN0_RXIMR_MI_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN0_RXIMR_MI_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register MCR, field IDAM
  let CAN1_MCR_IDAM_Format_00 $u2 = 0 // Format A: One full ID (standard and extended) per ID Filter Table element.
  let CAN1_MCR_IDAM_Format_01 $u2 = 1 // Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
  let CAN1_MCR_IDAM_Format_10 $u2 = 2 // Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
  let CAN1_MCR_IDAM_Format_11 $u2 = 3 // Format D: All frames rejected.

//--- Enumerated values for register MCR, field AEN
  let CAN1_MCR_AEN_Abort_0 $bool = no // Abort disabled.
  let CAN1_MCR_AEN_Abort_1 $bool = yes // Abort enabled.

//--- Enumerated values for register MCR, field LPRIOEN
  let CAN1_MCR_LPRIOEN_Local_0 $bool = no // Local Priority disabled.
  let CAN1_MCR_LPRIOEN_Local_1 $bool = yes // Local Priority enabled.

//--- Enumerated values for register MCR, field IRMQ
  let CAN1_MCR_IRMQ_Individual_0 $bool = no // Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
  let CAN1_MCR_IRMQ_Individual_1 $bool = yes // Individual Rx masking and queue feature are enabled.

//--- Enumerated values for register MCR, field SRXDIS
  let CAN1_MCR_SRXDIS_Self_0 $bool = no // Self reception enabled.
  let CAN1_MCR_SRXDIS_Self_1 $bool = yes // Self reception disabled.

//--- Enumerated values for register MCR, field WAKSRC
  let CAN1_MCR_WAKSRC_FlexCAN_0 $bool = no // FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
  let CAN1_MCR_WAKSRC_FlexCAN_1 $bool = yes // FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.

//--- Enumerated values for register MCR, field LPMACK
  let CAN1_MCR_LPMACK_FlexCAN_0 $bool = no // FlexCAN is not in a low-power mode.
  let CAN1_MCR_LPMACK_FlexCAN_1 $bool = yes // FlexCAN is in a low-power mode.

//--- Enumerated values for register MCR, field WRNEN
  let CAN1_MCR_WRNEN_TWRNINT_0 $bool = no // TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
  let CAN1_MCR_WRNEN_TWRNINT_1 $bool = yes // TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.

//--- Enumerated values for register MCR, field SLFWAK
  let CAN1_MCR_SLFWAK_FlexCAN_0 $bool = no // FlexCAN Self Wake Up feature is disabled.
  let CAN1_MCR_SLFWAK_FlexCAN_1 $bool = yes // FlexCAN Self Wake Up feature is enabled.

//--- Enumerated values for register MCR, field SUPV
  let CAN1_MCR_SUPV_FlexCAN_0 $bool = no // FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses .
  let CAN1_MCR_SUPV_FlexCAN_1 $bool = yes // FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location .

//--- Enumerated values for register MCR, field FRZACK
  let CAN1_MCR_FRZACK_FlexCAN_0 $bool = no // FlexCAN not in Freeze mode, prescaler running.
  let CAN1_MCR_FRZACK_FlexCAN_1 $bool = yes // FlexCAN in Freeze mode, prescaler stopped.

//--- Enumerated values for register MCR, field SOFTRST
  let CAN1_MCR_SOFTRST_No_0 $bool = no // No reset request.
  let CAN1_MCR_SOFTRST_Resets_1 $bool = yes // Resets the registers affected by soft reset.

//--- Enumerated values for register MCR, field WAKMSK
  let CAN1_MCR_WAKMSK_Wake_0 $bool = no // Wake Up Interrupt is disabled.
  let CAN1_MCR_WAKMSK_Wake_1 $bool = yes // Wake Up Interrupt is enabled.

//--- Enumerated values for register MCR, field NOTRDY
  let CAN1_MCR_NOTRDY_FlexCAN_0 $bool = no // FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
  let CAN1_MCR_NOTRDY_FlexCAN_1 $bool = yes // FlexCAN module is either in Disable mode , Stop mode or Freeze mode.

//--- Enumerated values for register MCR, field HALT
  let CAN1_MCR_HALT_No_0 $bool = no // No Freeze mode request.
  let CAN1_MCR_HALT_Enters_1 $bool = yes // Enters Freeze mode if the FRZ bit is asserted.

//--- Enumerated values for register MCR, field RFEN
  let CAN1_MCR_RFEN_Rx_0 $bool = no // Rx FIFO not enabled.
  let CAN1_MCR_RFEN_Rx_1 $bool = yes // Rx FIFO enabled.

//--- Enumerated values for register MCR, field FRZ
  let CAN1_MCR_FRZ_Not_0 $bool = no // Not enabled to enter Freeze mode.
  let CAN1_MCR_FRZ_Enabled_1 $bool = yes // Enabled to enter Freeze mode.

//--- Enumerated values for register MCR, field MDIS
  let CAN1_MCR_MDIS_Enable_0 $bool = no // Enable the FlexCAN module.
  let CAN1_MCR_MDIS_Disable_1 $bool = yes // Disable the FlexCAN module.

//--- Enumerated values for register CTRL1, field LOM
  let CAN1_CTRL1_LOM_Listen_Only_0 $bool = no // Listen-Only mode is deactivated.
  let CAN1_CTRL1_LOM_FlexCAN_1 $bool = yes // FlexCAN module operates in Listen-Only mode.

//--- Enumerated values for register CTRL1, field LBUF
  let CAN1_CTRL1_LBUF_Buffer_0 $bool = no // Buffer with highest priority is transmitted first.
  let CAN1_CTRL1_LBUF_Lowest_1 $bool = yes // Lowest number buffer is transmitted first.

//--- Enumerated values for register CTRL1, field TSYN
  let CAN1_CTRL1_TSYN_Timer_0 $bool = no // Timer Sync feature disabled
  let CAN1_CTRL1_TSYN_Timer_1 $bool = yes // Timer Sync feature enabled

//--- Enumerated values for register CTRL1, field BOFFREC
  let CAN1_CTRL1_BOFFREC_Automatic_0 $bool = no // Automatic recovering from Bus Off state enabled, according to CAN Spec 2.0 part B.
  let CAN1_CTRL1_BOFFREC_Automatic_1 $bool = yes // Automatic recovering from Bus Off state disabled.

//--- Enumerated values for register CTRL1, field SMP
  let CAN1_CTRL1_SMP_Just_0 $bool = no // Just one sample is used to determine the bit value.
  let CAN1_CTRL1_SMP_Three_1 $bool = yes // Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.

//--- Enumerated values for register CTRL1, field RWRNMSK
  let CAN1_CTRL1_RWRNMSK_Rx_0 $bool = no // Rx Warning Interrupt disabled.
  let CAN1_CTRL1_RWRNMSK_Rx_1 $bool = yes // Rx Warning Interrupt enabled.

//--- Enumerated values for register CTRL1, field TWRNMSK
  let CAN1_CTRL1_TWRNMSK_Tx_0 $bool = no // Tx Warning Interrupt disabled.
  let CAN1_CTRL1_TWRNMSK_Tx_1 $bool = yes // Tx Warning Interrupt enabled.

//--- Enumerated values for register CTRL1, field LPB
  let CAN1_CTRL1_LPB_Loop_0 $bool = no // Loop Back disabled.
  let CAN1_CTRL1_LPB_Loop_1 $bool = yes // Loop Back enabled.

//--- Enumerated values for register CTRL1, field CLKSRC
  let CAN1_CTRL1_CLKSRC_The_0 $bool = no // The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
  let CAN1_CTRL1_CLKSRC_The_1 $bool = yes // The CAN engine clock source is the peripheral clock.

//--- Enumerated values for register CTRL1, field ERRMSK
  let CAN1_CTRL1_ERRMSK_Error_0 $bool = no // Error interrupt disabled.
  let CAN1_CTRL1_ERRMSK_Error_1 $bool = yes // Error interrupt enabled.

//--- Enumerated values for register CTRL1, field BOFFMSK
  let CAN1_CTRL1_BOFFMSK_Bus_0 $bool = no // Bus Off interrupt disabled.
  let CAN1_CTRL1_BOFFMSK_Bus_1 $bool = yes // Bus Off interrupt enabled.

//--- Enumerated values for register RXMGMASK, field MG
  let CAN1_RXMGMASK_MG_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN1_RXMGMASK_MG_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register RX14MASK, field RX14M
  let CAN1_RX14MASK_RX14M_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN1_RX14MASK_RX14M_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register RX15MASK, field RX15M
  let CAN1_RX15MASK_RX15M_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN1_RX15MASK_RX15M_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register ESR1, field WAKINT
  let CAN1_ESR1_WAKINT_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_WAKINT_Indicates_1 $bool = yes // Indicates a recessive to dominant transition was received on the CAN bus.

//--- Enumerated values for register ESR1, field ERRINT
  let CAN1_ESR1_ERRINT_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_ERRINT_Indicates_1 $bool = yes // Indicates setting of any Error Bit in the Error and Status Register.

//--- Enumerated values for register ESR1, field BOFFINT
  let CAN1_ESR1_BOFFINT_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_BOFFINT_FlexCAN_1 $bool = yes // FlexCAN module entered Bus Off state.

//--- Enumerated values for register ESR1, field RX
  let CAN1_ESR1_RX_FlexCAN_0 $bool = no // FlexCAN is not receiving a message.
  let CAN1_ESR1_RX_FlexCAN_1 $bool = yes // FlexCAN is receiving a message.

//--- Enumerated values for register ESR1, field FLTCONF
  let CAN1_ESR1_FLTCONF_Error_00 $u2 = 0 // Error Active
  let CAN1_ESR1_FLTCONF_Error_01 $u2 = 1 // Error Passive
  let CAN1_ESR1_FLTCONF_Bus_1x $u2 = 2 // Bus Off

//--- Enumerated values for register ESR1, field TX
  let CAN1_ESR1_TX_FlexCAN_0 $bool = no // FlexCAN is not transmitting a message.
  let CAN1_ESR1_TX_FlexCAN_1 $bool = yes // FlexCAN is transmitting a message.

//--- Enumerated values for register ESR1, field IDLE
  let CAN1_ESR1_IDLE_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_IDLE_CAN_1 $bool = yes // CAN bus is now IDLE.

//--- Enumerated values for register ESR1, field RXWRN
  let CAN1_ESR1_RXWRN_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_RXWRN_RXERRCNT_1 $bool = yes // RXERRCNT is greater than or equal to 96.

//--- Enumerated values for register ESR1, field TXWRN
  let CAN1_ESR1_TXWRN_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_TXWRN_TXERRCNT_1 $bool = yes // TXERRCNT is greater than or equal to 96.

//--- Enumerated values for register ESR1, field STFERR
  let CAN1_ESR1_STFERR_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_STFERR_A_1 $bool = yes // A Stuffing Error occurred since last read of this register.

//--- Enumerated values for register ESR1, field FRMERR
  let CAN1_ESR1_FRMERR_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_FRMERR_A_1 $bool = yes // A Form Error occurred since last read of this register.

//--- Enumerated values for register ESR1, field CRCERR
  let CAN1_ESR1_CRCERR_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_CRCERR_A_1 $bool = yes // A CRC error occurred since last read of this register.

//--- Enumerated values for register ESR1, field ACKERR
  let CAN1_ESR1_ACKERR_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_ACKERR_An_1 $bool = yes // An ACK error occurred since last read of this register.

//--- Enumerated values for register ESR1, field BIT0ERR
  let CAN1_ESR1_BIT0ERR_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_BIT0ERR_At_1 $bool = yes // At least one bit sent as dominant is received as recessive.

//--- Enumerated values for register ESR1, field BIT1ERR
  let CAN1_ESR1_BIT1ERR_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_BIT1ERR_At_1 $bool = yes // At least one bit sent as recessive is received as dominant.

//--- Enumerated values for register ESR1, field RWRNINT
  let CAN1_ESR1_RWRNINT_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_RWRNINT_The_1 $bool = yes // The Rx error counter transitioned from less than 96 to greater than or equal to 96.

//--- Enumerated values for register ESR1, field TWRNINT
  let CAN1_ESR1_TWRNINT_No_0 $bool = no // No such occurrence.
  let CAN1_ESR1_TWRNINT_The_1 $bool = yes // The Tx error counter transitioned from less than 96 to greater than or equal to 96.

//--- Enumerated values for register ESR1, field SYNCH
  let CAN1_ESR1_SYNCH_FlexCAN_0 $bool = no // FlexCAN is not synchronized to the CAN bus.
  let CAN1_ESR1_SYNCH_FlexCAN_1 $bool = yes // FlexCAN is synchronized to the CAN bus.

//--- Enumerated values for register IMASK1, field BUFLM
  let CAN1_IMASK1_BUFLM_The_0 $u32 = 0 // The corresponding buffer Interrupt is disabled.
  let CAN1_IMASK1_BUFLM_The_1 $u32 = 1 // The corresponding buffer Interrupt is enabled.

//--- Enumerated values for register IFLAG1, field BUF0I
  let CAN1_IFLAG1_BUF0I_The_0 $bool = no // The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
  let CAN1_IFLAG1_BUF0I_The_1 $bool = yes // The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.

//--- Enumerated values for register IFLAG1, field BUF4TO1I
  let CAN1_IFLAG1_BUF4TO1I_The_0 $u4 = 0 // The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
  let CAN1_IFLAG1_BUF4TO1I_The_1 $u4 = 1 // The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.

//--- Enumerated values for register IFLAG1, field BUF5I
  let CAN1_IFLAG1_BUF5I_No_0 $bool = no // No occurrence of MB5 completing transmission/reception when MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
  let CAN1_IFLAG1_BUF5I_MB5_1 $bool = yes // MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s) available in the Rx FIFO when MCR[RFEN]=1

//--- Enumerated values for register IFLAG1, field BUF6I
  let CAN1_IFLAG1_BUF6I_No_0 $bool = no // No occurrence of MB6 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
  let CAN1_IFLAG1_BUF6I_MB6_1 $bool = yes // MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO almost full when MCR[RFEN]=1

//--- Enumerated values for register IFLAG1, field BUF7I
  let CAN1_IFLAG1_BUF7I_No_0 $bool = no // No occurrence of MB7 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
  let CAN1_IFLAG1_BUF7I_MB7_1 $bool = yes // MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO overflow when MCR[RFEN]=1

//--- Enumerated values for register IFLAG1, field BUF31TO8I
  let CAN1_IFLAG1_BUF31TO8I_The_0 $u24 = 0 // The corresponding buffer has no occurrence of successfully completed transmission or reception.
  let CAN1_IFLAG1_BUF31TO8I_The_1 $u24 = 1 // The corresponding buffer has successfully completed transmission or reception.

//--- Enumerated values for register CTRL2, field EACEN
  let CAN1_CTRL2_EACEN_Rx_0 $bool = no // Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
  let CAN1_CTRL2_EACEN_Enables_1 $bool = yes // Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.

//--- Enumerated values for register CTRL2, field RRS
  let CAN1_CTRL2_RRS_Remote_0 $bool = no // Remote Response Frame is generated.
  let CAN1_CTRL2_RRS_Remote_1 $bool = yes // Remote Request Frame is stored.

//--- Enumerated values for register CTRL2, field MRP
  let CAN1_CTRL2_MRP_Matching_0 $bool = no // Matching starts from Rx FIFO and continues on Mailboxes.
  let CAN1_CTRL2_MRP_Matching_1 $bool = yes // Matching starts from Mailboxes and continues on Rx FIFO.

//--- Enumerated values for register CTRL2, field WRMFRZ
  let CAN1_CTRL2_WRMFRZ_Maintain_0 $bool = no // Maintain the write access restrictions.
  let CAN1_CTRL2_WRMFRZ_Enable_1 $bool = yes // Enable unrestricted write access to FlexCAN memory.

//--- Enumerated values for register ESR2, field IMB
  let CAN1_ESR2_IMB_If_0 $bool = no // If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
  let CAN1_ESR2_IMB_If_1 $bool = yes // If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.

//--- Enumerated values for register ESR2, field VPS
  let CAN1_ESR2_VPS_Contents_0 $bool = no // Contents of IMB and LPTM are invalid.
  let CAN1_ESR2_VPS_Contents_1 $bool = yes // Contents of IMB and LPTM are valid.

//--- Enumerated values for register RXFGMASK, field FGM
  let CAN1_RXFGMASK_FGM_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN1_RXFGMASK_FGM_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//--- Enumerated values for register RXIMR%s, field MI
  let CAN1_RXIMR_MI_The_0 $u32 = 0 // The corresponding bit in the filter is "don't care."
  let CAN1_RXIMR_MI_The_1 $u32 = 1 // The corresponding bit in the filter is checked.

//------------------------------------------------------------------------------
// Peripheral CAU: Memory Mapped Cryptographic Acceleration Unit (MMCAU)
//------------------------------------------------------------------------------

registers ©CAU @at 0xe0081000 {
//---  Register CAU_DIRECT0: Direct access register 0
  CAU_DIRECT0 @offset 0x0 $u32 {
    CAU_DIRECT0:32 // at 0: Direct register 0
  }

//---  Register CAU_DIRECT1: Direct access register 1
  CAU_DIRECT1 @offset 0x4 $u32 {
    CAU_DIRECT1:32 // at 0: Direct register 1
  }

//---  Register CAU_DIRECT2: Direct access register 2
  CAU_DIRECT2 @offset 0x8 $u32 {
    CAU_DIRECT2:32 // at 0: Direct register 2
  }

//---  Register CAU_DIRECT3: Direct access register 3
  CAU_DIRECT3 @offset 0xc $u32 {
    CAU_DIRECT3:32 // at 0: Direct register 3
  }

//---  Register CAU_DIRECT4: Direct access register 4
  CAU_DIRECT4 @offset 0x10 $u32 {
    CAU_DIRECT4:32 // at 0: Direct register 4
  }

//---  Register CAU_DIRECT5: Direct access register 5
  CAU_DIRECT5 @offset 0x14 $u32 {
    CAU_DIRECT5:32 // at 0: Direct register 5
  }

//---  Register CAU_DIRECT6: Direct access register 6
  CAU_DIRECT6 @offset 0x18 $u32 {
    CAU_DIRECT6:32 // at 0: Direct register 6
  }

//---  Register CAU_DIRECT7: Direct access register 7
  CAU_DIRECT7 @offset 0x1c $u32 {
    CAU_DIRECT7:32 // at 0: Direct register 7
  }

//---  Register CAU_DIRECT8: Direct access register 8
  CAU_DIRECT8 @offset 0x20 $u32 {
    CAU_DIRECT8:32 // at 0: Direct register 8
  }

//---  Register CAU_DIRECT9: Direct access register 9
  CAU_DIRECT9 @offset 0x24 $u32 {
    CAU_DIRECT9:32 // at 0: Direct register 9
  }

//---  Register CAU_DIRECT10: Direct access register 10
  CAU_DIRECT10 @offset 0x28 $u32 {
    CAU_DIRECT10:32 // at 0: Direct register 10
  }

//---  Register CAU_DIRECT11: Direct access register 11
  CAU_DIRECT11 @offset 0x2c $u32 {
    CAU_DIRECT11:32 // at 0: Direct register 11
  }

//---  Register CAU_DIRECT12: Direct access register 12
  CAU_DIRECT12 @offset 0x30 $u32 {
    CAU_DIRECT12:32 // at 0: Direct register 12
  }

//---  Register CAU_DIRECT13: Direct access register 13
  CAU_DIRECT13 @offset 0x34 $u32 {
    CAU_DIRECT13:32 // at 0: Direct register 13
  }

//---  Register CAU_DIRECT14: Direct access register 14
  CAU_DIRECT14 @offset 0x38 $u32 {
    CAU_DIRECT14:32 // at 0: Direct register 14
  }

//---  Register CAU_DIRECT15: Direct access register 15
  CAU_DIRECT15 @offset 0x3c $u32 {
    CAU_DIRECT15:32 // at 0: Direct register 15
  }

//---  Register CAU_LDR_CASR: Status register - Load Register command
  CAU_LDR_CASR @offset 0x840 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_LDR_CAA: Accumulator register - Load Register command
  CAU_LDR_CAA @offset 0x844 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_LDR_CA0: General Purpose Register 0 - Load Register command
  CAU_LDR_CA0 @offset 0x848 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_LDR_CA1: General Purpose Register 1 - Load Register command
  CAU_LDR_CA1 @offset 0x84c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_LDR_CA2: General Purpose Register 2 - Load Register command
  CAU_LDR_CA2 @offset 0x850 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_LDR_CA3: General Purpose Register 3 - Load Register command
  CAU_LDR_CA3 @offset 0x854 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_LDR_CA4: General Purpose Register 4 - Load Register command
  CAU_LDR_CA4 @offset 0x858 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_LDR_CA5: General Purpose Register 5 - Load Register command
  CAU_LDR_CA5 @offset 0x85c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_LDR_CA6: General Purpose Register 6 - Load Register command
  CAU_LDR_CA6 @offset 0x860 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_LDR_CA7: General Purpose Register 7 - Load Register command
  CAU_LDR_CA7 @offset 0x864 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_LDR_CA8: General Purpose Register 8 - Load Register command
  CAU_LDR_CA8 @offset 0x868 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_STR_CASR: Status register - Store Register command
  CAU_STR_CASR @offset 0x880 @ro $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_STR_CAA: Accumulator register - Store Register command
  CAU_STR_CAA @offset 0x884 @ro $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_STR_CA0: General Purpose Register 0 - Store Register command
  CAU_STR_CA0 @offset 0x888 @ro $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_STR_CA1: General Purpose Register 1 - Store Register command
  CAU_STR_CA1 @offset 0x88c @ro $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_STR_CA2: General Purpose Register 2 - Store Register command
  CAU_STR_CA2 @offset 0x890 @ro $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_STR_CA3: General Purpose Register 3 - Store Register command
  CAU_STR_CA3 @offset 0x894 @ro $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_STR_CA4: General Purpose Register 4 - Store Register command
  CAU_STR_CA4 @offset 0x898 @ro $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_STR_CA5: General Purpose Register 5 - Store Register command
  CAU_STR_CA5 @offset 0x89c @ro $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_STR_CA6: General Purpose Register 6 - Store Register command
  CAU_STR_CA6 @offset 0x8a0 @ro $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_STR_CA7: General Purpose Register 7 - Store Register command
  CAU_STR_CA7 @offset 0x8a4 @ro $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_STR_CA8: General Purpose Register 8 - Store Register command
  CAU_STR_CA8 @offset 0x8a8 @ro $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_ADR_CASR: Status register - Add Register command
  CAU_ADR_CASR @offset 0x8c0 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_ADR_CAA: Accumulator register - Add to register command
  CAU_ADR_CAA @offset 0x8c4 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_ADR_CA0: General Purpose Register 0 - Add to register command
  CAU_ADR_CA0 @offset 0x8c8 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_ADR_CA1: General Purpose Register 1 - Add to register command
  CAU_ADR_CA1 @offset 0x8cc $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_ADR_CA2: General Purpose Register 2 - Add to register command
  CAU_ADR_CA2 @offset 0x8d0 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_ADR_CA3: General Purpose Register 3 - Add to register command
  CAU_ADR_CA3 @offset 0x8d4 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_ADR_CA4: General Purpose Register 4 - Add to register command
  CAU_ADR_CA4 @offset 0x8d8 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_ADR_CA5: General Purpose Register 5 - Add to register command
  CAU_ADR_CA5 @offset 0x8dc $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_ADR_CA6: General Purpose Register 6 - Add to register command
  CAU_ADR_CA6 @offset 0x8e0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_ADR_CA7: General Purpose Register 7 - Add to register command
  CAU_ADR_CA7 @offset 0x8e4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_ADR_CA8: General Purpose Register 8 - Add to register command
  CAU_ADR_CA8 @offset 0x8e8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_RADR_CASR: Status register - Reverse and Add to Register command
  CAU_RADR_CASR @offset 0x900 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
  CAU_RADR_CAA @offset 0x904 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
  CAU_RADR_CA0 @offset 0x908 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
  CAU_RADR_CA1 @offset 0x90c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
  CAU_RADR_CA2 @offset 0x910 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
  CAU_RADR_CA3 @offset 0x914 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
  CAU_RADR_CA4 @offset 0x918 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
  CAU_RADR_CA5 @offset 0x91c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
  CAU_RADR_CA6 @offset 0x920 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
  CAU_RADR_CA7 @offset 0x924 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
  CAU_RADR_CA8 @offset 0x928 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_XOR_CASR: Status register - Exclusive Or command
  CAU_XOR_CASR @offset 0x980 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_XOR_CAA: Accumulator register - Exclusive Or command
  CAU_XOR_CAA @offset 0x984 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
  CAU_XOR_CA0 @offset 0x988 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
  CAU_XOR_CA1 @offset 0x98c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
  CAU_XOR_CA2 @offset 0x990 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
  CAU_XOR_CA3 @offset 0x994 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
  CAU_XOR_CA4 @offset 0x998 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
  CAU_XOR_CA5 @offset 0x99c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
  CAU_XOR_CA6 @offset 0x9a0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
  CAU_XOR_CA7 @offset 0x9a4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
  CAU_XOR_CA8 @offset 0x9a8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_ROTL_CASR: Status register - Rotate Left command
  CAU_ROTL_CASR @offset 0x9c0 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_ROTL_CAA: Accumulator register - Rotate Left command
  CAU_ROTL_CAA @offset 0x9c4 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
  CAU_ROTL_CA0 @offset 0x9c8 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
  CAU_ROTL_CA1 @offset 0x9cc $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
  CAU_ROTL_CA2 @offset 0x9d0 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
  CAU_ROTL_CA3 @offset 0x9d4 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
  CAU_ROTL_CA4 @offset 0x9d8 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
  CAU_ROTL_CA5 @offset 0x9dc $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
  CAU_ROTL_CA6 @offset 0x9e0 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
  CAU_ROTL_CA7 @offset 0x9e4 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
  CAU_ROTL_CA8 @offset 0x9e8 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_AESC_CASR: Status register - AES Column Operation command
  CAU_AESC_CASR @offset 0xb00 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_AESC_CAA: Accumulator register - AES Column Operation command
  CAU_AESC_CAA @offset 0xb04 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
  CAU_AESC_CA0 @offset 0xb08 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
  CAU_AESC_CA1 @offset 0xb0c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
  CAU_AESC_CA2 @offset 0xb10 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
  CAU_AESC_CA3 @offset 0xb14 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
  CAU_AESC_CA4 @offset 0xb18 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
  CAU_AESC_CA5 @offset 0xb1c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
  CAU_AESC_CA6 @offset 0xb20 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
  CAU_AESC_CA7 @offset 0xb24 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
  CAU_AESC_CA8 @offset 0xb28 $u32 {
    CA8:32 // at 0: CA8
  }

//---  Register CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
  CAU_AESIC_CASR @offset 0xb40 $u32 {
    VER:4 // at 28: CAU version
    26
    DPE // at 1: no description available
    IC // at 0: no description available
  }

//---  Register CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
  CAU_AESIC_CAA @offset 0xb44 $u32 {
    ACC:32 // at 0: ACC
  }

//---  Register CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
  CAU_AESIC_CA0 @offset 0xb48 $u32 {
    CA0:32 // at 0: CA0
  }

//---  Register CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
  CAU_AESIC_CA1 @offset 0xb4c $u32 {
    CA1:32 // at 0: CA1
  }

//---  Register CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
  CAU_AESIC_CA2 @offset 0xb50 $u32 {
    CA2:32 // at 0: CA2
  }

//---  Register CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
  CAU_AESIC_CA3 @offset 0xb54 $u32 {
    CA3:32 // at 0: CA3
  }

//---  Register CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
  CAU_AESIC_CA4 @offset 0xb58 $u32 {
    CA4:32 // at 0: CA4
  }

//---  Register CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
  CAU_AESIC_CA5 @offset 0xb5c $u32 {
    CA5:32 // at 0: CA5
  }

//---  Register CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
  CAU_AESIC_CA6 @offset 0xb60 $u32 {
    CA6:32 // at 0: CA6
  }

//---  Register CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
  CAU_AESIC_CA7 @offset 0xb64 $u32 {
    CA7:32 // at 0: CA7
  }

//---  Register CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
  CAU_AESIC_CA8 @offset 0xb68 $u32 {
    CA8:32 // at 0: CA8
  }

}

//--- Enumerated values for register CAU_LDR_CASR, field IC
  let CAU_CAU_LDR_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_LDR_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_LDR_CASR, field DPE
  let CAU_CAU_LDR_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_LDR_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_LDR_CASR, field VER
  let CAU_CAU_LDR_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_LDR_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_STR_CASR, field IC
  let CAU_CAU_STR_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_STR_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_STR_CASR, field DPE
  let CAU_CAU_STR_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_STR_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_STR_CASR, field VER
  let CAU_CAU_STR_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_STR_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_ADR_CASR, field IC
  let CAU_CAU_ADR_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_ADR_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_ADR_CASR, field DPE
  let CAU_CAU_ADR_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_ADR_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_ADR_CASR, field VER
  let CAU_CAU_ADR_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_ADR_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_RADR_CASR, field IC
  let CAU_CAU_RADR_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_RADR_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_RADR_CASR, field DPE
  let CAU_CAU_RADR_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_RADR_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_RADR_CASR, field VER
  let CAU_CAU_RADR_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_RADR_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_XOR_CASR, field IC
  let CAU_CAU_XOR_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_XOR_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_XOR_CASR, field DPE
  let CAU_CAU_XOR_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_XOR_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_XOR_CASR, field VER
  let CAU_CAU_XOR_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_XOR_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_ROTL_CASR, field IC
  let CAU_CAU_ROTL_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_ROTL_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_ROTL_CASR, field DPE
  let CAU_CAU_ROTL_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_ROTL_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_ROTL_CASR, field VER
  let CAU_CAU_ROTL_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_ROTL_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_AESC_CASR, field IC
  let CAU_CAU_AESC_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_AESC_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_AESC_CASR, field DPE
  let CAU_CAU_AESC_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_AESC_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_AESC_CASR, field VER
  let CAU_CAU_AESC_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_AESC_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//--- Enumerated values for register CAU_AESIC_CASR, field IC
  let CAU_CAU_AESIC_CASR_IC_No_0 $bool = no // No illegal commands issued
  let CAU_CAU_AESIC_CASR_IC_Illegal_1 $bool = yes // Illegal command issued

//--- Enumerated values for register CAU_AESIC_CASR, field DPE
  let CAU_CAU_AESIC_CASR_DPE_No_0 $bool = no // No error detected
  let CAU_CAU_AESIC_CASR_DPE_DES_1 $bool = yes // DES key parity error detected

//--- Enumerated values for register CAU_AESIC_CASR, field VER
  let CAU_CAU_AESIC_CASR_VER_Initial_0001 $u4 = 1 // Initial CAU version
  let CAU_CAU_AESIC_CASR_VER_Second_0010 $u4 = 2 // Second version, added support for SHA-256 algorithm.(This is the value on this device)

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©CMP [4]
//        CMP0 at 0x40073000
//        CMP1 at 0x40073008
//        CMP2 at 0x40073010
//        CMP3 at 0x40073018
//------------------------------------------------------------------------------

registers ©CMP [4 @at 0x40073000 0x40073008 0x40073010 0x40073018]
          ©CMP0 @at 0x40073000
          ©CMP1 @at 0x40073008
          ©CMP2 @at 0x40073010
          ©CMP3 @at 0x40073018 {
//---  Register CR0: CMP Control Register 0
  CR0 @offset 0x0 $u8 {
    1
    FILTER_CNT:3 // at 4: Filter Sample Count
    2
    HYSTCTR:2 // at 0: Comparator hard block hysteresis control
  }

//---  Register CR1: CMP Control Register 1
  CR1 @offset 0x1 $u8 {
    SE // at 7: Sample Enable
    WE // at 6: Windowing Enable
    TRIGM // at 5: Trigger Mode Enable
    PMODE // at 4: Power Mode Select
    INV // at 3: Comparator INVERT
    COS // at 2: Comparator Output Select
    OPE // at 1: Comparator Output Pin Enable
    EN // at 0: Comparator Module Enable
  }

//---  Register FPR: CMP Filter Period Register
  FPR @offset 0x2 $u8 {
    FILT_PER:8 // at 0: Filter Sample Period
  }

//---  Register SCR: CMP Status and Control Register
  SCR @offset 0x3 $u8 {
    1
    DMAEN // at 6: DMA Enable Control
    1
    IER // at 4: Comparator Interrupt Enable Rising
    IEF // at 3: Comparator Interrupt Enable Falling
    CFR // at 2: Analog Comparator Flag Rising
    CFF // at 1: Analog Comparator Flag Falling
    COUT // at 0: Analog Comparator Output
  }

//---  Register DACCR: DAC Control Register
  DACCR @offset 0x4 $u8 {
    DACEN // at 7: DAC Enable
    VRSEL // at 6: Supply Voltage Reference Source Select
    VOSEL:6 // at 0: DAC Output Voltage Select
  }

//---  Register MUXCR: MUX Control Register
  MUXCR @offset 0x5 $u8 {
    PSTM // at 7: Pass Through Mode Enable
    1
    PSEL:3 // at 3: Plus Input Mux Control
    MSEL:3 // at 0: Minus Input Mux Control
  }

}

//--- Enumerated values for register CR0, field HYSTCTR
  let CMP0_CR0_HYSTCTR_Level_00 $u2 = 0 // Level 0
  let CMP0_CR0_HYSTCTR_Level_01 $u2 = 1 // Level 1
  let CMP0_CR0_HYSTCTR_Level_10 $u2 = 2 // Level 2
  let CMP0_CR0_HYSTCTR_Level_11 $u2 = 3 // Level 3

//--- Enumerated values for register CR0, field FILTER_CNT
  let CMP0_CR0_FILTER_CNT_Filter_000 $u3 = 0 // Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
  let CMP0_CR0_FILTER_CNT_One_001 $u3 = 1 // One sample must agree. The comparator output is simply sampled.
  let CMP0_CR0_FILTER_CNT_2_010 $u3 = 2 // 2 consecutive samples must agree.
  let CMP0_CR0_FILTER_CNT_3_011 $u3 = 3 // 3 consecutive samples must agree.
  let CMP0_CR0_FILTER_CNT_4_100 $u3 = 4 // 4 consecutive samples must agree.
  let CMP0_CR0_FILTER_CNT_5_101 $u3 = 5 // 5 consecutive samples must agree.
  let CMP0_CR0_FILTER_CNT_6_110 $u3 = 6 // 6 consecutive samples must agree.
  let CMP0_CR0_FILTER_CNT_7_111 $u3 = 7 // 7 consecutive samples must agree.

//--- Enumerated values for register CR1, field EN
  let CMP0_CR1_EN_Analog_0 $bool = no // Analog Comparator is disabled.
  let CMP0_CR1_EN_Analog_1 $bool = yes // Analog Comparator is enabled.

//--- Enumerated values for register CR1, field OPE
  let CMP0_CR1_OPE_CMPO_0 $bool = no // CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
  let CMP0_CR1_OPE_CMPO_1 $bool = yes // CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.

//--- Enumerated values for register CR1, field COS
  let CMP0_CR1_COS_Set_0 $bool = no // Set the filtered comparator output (CMPO) to equal COUT.
  let CMP0_CR1_COS_Set_1 $bool = yes // Set the unfiltered comparator output (CMPO) to equal COUTA.

//--- Enumerated values for register CR1, field INV
  let CMP0_CR1_INV_Does_0 $bool = no // Does not invert the comparator output.
  let CMP0_CR1_INV_Inverts_1 $bool = yes // Inverts the comparator output.

//--- Enumerated values for register CR1, field PMODE
  let CMP0_CR1_PMODE_Low_Speed_0 $bool = no // Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
  let CMP0_CR1_PMODE_High_Speed_1 $bool = yes // High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.

//--- Enumerated values for register CR1, field TRIGM
  let CMP0_CR1_TRIGM_Trigger_0 $bool = no // Trigger mode is disabled.
  let CMP0_CR1_TRIGM_Trigger_1 $bool = yes // Trigger mode is enabled.

//--- Enumerated values for register CR1, field WE
  let CMP0_CR1_WE_Windowing_0 $bool = no // Windowing mode is not selected.
  let CMP0_CR1_WE_Windowing_1 $bool = yes // Windowing mode is selected.

//--- Enumerated values for register CR1, field SE
  let CMP0_CR1_SE_Sampling_0 $bool = no // Sampling mode is not selected.
  let CMP0_CR1_SE_Sampling_1 $bool = yes // Sampling mode is selected.

//--- Enumerated values for register SCR, field CFF
  let CMP0_SCR_CFF_Falling_edge_0 $bool = no // Falling-edge on COUT has not been detected.
  let CMP0_SCR_CFF_Falling_edge_1 $bool = yes // Falling-edge on COUT has occurred.

//--- Enumerated values for register SCR, field CFR
  let CMP0_SCR_CFR_Rising_edge_0 $bool = no // Rising-edge on COUT has not been detected.
  let CMP0_SCR_CFR_Rising_edge_1 $bool = yes // Rising-edge on COUT has occurred.

//--- Enumerated values for register SCR, field IEF
  let CMP0_SCR_IEF_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP0_SCR_IEF_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field IER
  let CMP0_SCR_IER_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP0_SCR_IER_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field DMAEN
  let CMP0_SCR_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let CMP0_SCR_DMAEN_DMA_1 $bool = yes // DMA is enabled.

//--- Enumerated values for register DACCR, field VRSEL
  let CMP0_DACCR_VRSEL_Vin1_0 $bool = no // Vin1 is selected as resistor ladder network supply reference.
  let CMP0_DACCR_VRSEL_Vin2_1 $bool = yes // Vin2 is selected as resistor ladder network supply reference.

//--- Enumerated values for register DACCR, field DACEN
  let CMP0_DACCR_DACEN_DAC_0 $bool = no // DAC is disabled.
  let CMP0_DACCR_DACEN_DAC_1 $bool = yes // DAC is enabled.

//--- Enumerated values for register MUXCR, field MSEL
  let CMP0_MUXCR_MSEL_IN0_000 $u3 = 0 // IN0
  let CMP0_MUXCR_MSEL_IN1_001 $u3 = 1 // IN1
  let CMP0_MUXCR_MSEL_IN2_010 $u3 = 2 // IN2
  let CMP0_MUXCR_MSEL_IN3_011 $u3 = 3 // IN3
  let CMP0_MUXCR_MSEL_IN4_100 $u3 = 4 // IN4
  let CMP0_MUXCR_MSEL_IN5_101 $u3 = 5 // IN5
  let CMP0_MUXCR_MSEL_IN6_110 $u3 = 6 // IN6
  let CMP0_MUXCR_MSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSEL
  let CMP0_MUXCR_PSEL_IN0_000 $u3 = 0 // IN0
  let CMP0_MUXCR_PSEL_IN1_001 $u3 = 1 // IN1
  let CMP0_MUXCR_PSEL_IN2_010 $u3 = 2 // IN2
  let CMP0_MUXCR_PSEL_IN3_011 $u3 = 3 // IN3
  let CMP0_MUXCR_PSEL_IN4_100 $u3 = 4 // IN4
  let CMP0_MUXCR_PSEL_IN5_101 $u3 = 5 // IN5
  let CMP0_MUXCR_PSEL_IN6_110 $u3 = 6 // IN6
  let CMP0_MUXCR_PSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSTM
  let CMP0_MUXCR_PSTM_Pass_0 $bool = no // Pass Through Mode is disabled.
  let CMP0_MUXCR_PSTM_Pass_1 $bool = yes // Pass Through Mode is enabled.

//--- Enumerated values for register CR0, field HYSTCTR
  let CMP1_CR0_HYSTCTR_Level_00 $u2 = 0 // Level 0
  let CMP1_CR0_HYSTCTR_Level_01 $u2 = 1 // Level 1
  let CMP1_CR0_HYSTCTR_Level_10 $u2 = 2 // Level 2
  let CMP1_CR0_HYSTCTR_Level_11 $u2 = 3 // Level 3

//--- Enumerated values for register CR0, field FILTER_CNT
  let CMP1_CR0_FILTER_CNT_Filter_000 $u3 = 0 // Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
  let CMP1_CR0_FILTER_CNT_One_001 $u3 = 1 // One sample must agree. The comparator output is simply sampled.
  let CMP1_CR0_FILTER_CNT_2_010 $u3 = 2 // 2 consecutive samples must agree.
  let CMP1_CR0_FILTER_CNT_3_011 $u3 = 3 // 3 consecutive samples must agree.
  let CMP1_CR0_FILTER_CNT_4_100 $u3 = 4 // 4 consecutive samples must agree.
  let CMP1_CR0_FILTER_CNT_5_101 $u3 = 5 // 5 consecutive samples must agree.
  let CMP1_CR0_FILTER_CNT_6_110 $u3 = 6 // 6 consecutive samples must agree.
  let CMP1_CR0_FILTER_CNT_7_111 $u3 = 7 // 7 consecutive samples must agree.

//--- Enumerated values for register CR1, field EN
  let CMP1_CR1_EN_Analog_0 $bool = no // Analog Comparator is disabled.
  let CMP1_CR1_EN_Analog_1 $bool = yes // Analog Comparator is enabled.

//--- Enumerated values for register CR1, field OPE
  let CMP1_CR1_OPE_CMPO_0 $bool = no // CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
  let CMP1_CR1_OPE_CMPO_1 $bool = yes // CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.

//--- Enumerated values for register CR1, field COS
  let CMP1_CR1_COS_Set_0 $bool = no // Set the filtered comparator output (CMPO) to equal COUT.
  let CMP1_CR1_COS_Set_1 $bool = yes // Set the unfiltered comparator output (CMPO) to equal COUTA.

//--- Enumerated values for register CR1, field INV
  let CMP1_CR1_INV_Does_0 $bool = no // Does not invert the comparator output.
  let CMP1_CR1_INV_Inverts_1 $bool = yes // Inverts the comparator output.

//--- Enumerated values for register CR1, field PMODE
  let CMP1_CR1_PMODE_Low_Speed_0 $bool = no // Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
  let CMP1_CR1_PMODE_High_Speed_1 $bool = yes // High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.

//--- Enumerated values for register CR1, field TRIGM
  let CMP1_CR1_TRIGM_Trigger_0 $bool = no // Trigger mode is disabled.
  let CMP1_CR1_TRIGM_Trigger_1 $bool = yes // Trigger mode is enabled.

//--- Enumerated values for register CR1, field WE
  let CMP1_CR1_WE_Windowing_0 $bool = no // Windowing mode is not selected.
  let CMP1_CR1_WE_Windowing_1 $bool = yes // Windowing mode is selected.

//--- Enumerated values for register CR1, field SE
  let CMP1_CR1_SE_Sampling_0 $bool = no // Sampling mode is not selected.
  let CMP1_CR1_SE_Sampling_1 $bool = yes // Sampling mode is selected.

//--- Enumerated values for register SCR, field CFF
  let CMP1_SCR_CFF_Falling_edge_0 $bool = no // Falling-edge on COUT has not been detected.
  let CMP1_SCR_CFF_Falling_edge_1 $bool = yes // Falling-edge on COUT has occurred.

//--- Enumerated values for register SCR, field CFR
  let CMP1_SCR_CFR_Rising_edge_0 $bool = no // Rising-edge on COUT has not been detected.
  let CMP1_SCR_CFR_Rising_edge_1 $bool = yes // Rising-edge on COUT has occurred.

//--- Enumerated values for register SCR, field IEF
  let CMP1_SCR_IEF_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP1_SCR_IEF_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field IER
  let CMP1_SCR_IER_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP1_SCR_IER_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field DMAEN
  let CMP1_SCR_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let CMP1_SCR_DMAEN_DMA_1 $bool = yes // DMA is enabled.

//--- Enumerated values for register DACCR, field VRSEL
  let CMP1_DACCR_VRSEL_Vin1_0 $bool = no // Vin1 is selected as resistor ladder network supply reference.
  let CMP1_DACCR_VRSEL_Vin2_1 $bool = yes // Vin2 is selected as resistor ladder network supply reference.

//--- Enumerated values for register DACCR, field DACEN
  let CMP1_DACCR_DACEN_DAC_0 $bool = no // DAC is disabled.
  let CMP1_DACCR_DACEN_DAC_1 $bool = yes // DAC is enabled.

//--- Enumerated values for register MUXCR, field MSEL
  let CMP1_MUXCR_MSEL_IN0_000 $u3 = 0 // IN0
  let CMP1_MUXCR_MSEL_IN1_001 $u3 = 1 // IN1
  let CMP1_MUXCR_MSEL_IN2_010 $u3 = 2 // IN2
  let CMP1_MUXCR_MSEL_IN3_011 $u3 = 3 // IN3
  let CMP1_MUXCR_MSEL_IN4_100 $u3 = 4 // IN4
  let CMP1_MUXCR_MSEL_IN5_101 $u3 = 5 // IN5
  let CMP1_MUXCR_MSEL_IN6_110 $u3 = 6 // IN6
  let CMP1_MUXCR_MSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSEL
  let CMP1_MUXCR_PSEL_IN0_000 $u3 = 0 // IN0
  let CMP1_MUXCR_PSEL_IN1_001 $u3 = 1 // IN1
  let CMP1_MUXCR_PSEL_IN2_010 $u3 = 2 // IN2
  let CMP1_MUXCR_PSEL_IN3_011 $u3 = 3 // IN3
  let CMP1_MUXCR_PSEL_IN4_100 $u3 = 4 // IN4
  let CMP1_MUXCR_PSEL_IN5_101 $u3 = 5 // IN5
  let CMP1_MUXCR_PSEL_IN6_110 $u3 = 6 // IN6
  let CMP1_MUXCR_PSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSTM
  let CMP1_MUXCR_PSTM_Pass_0 $bool = no // Pass Through Mode is disabled.
  let CMP1_MUXCR_PSTM_Pass_1 $bool = yes // Pass Through Mode is enabled.

//--- Enumerated values for register CR0, field HYSTCTR
  let CMP2_CR0_HYSTCTR_Level_00 $u2 = 0 // Level 0
  let CMP2_CR0_HYSTCTR_Level_01 $u2 = 1 // Level 1
  let CMP2_CR0_HYSTCTR_Level_10 $u2 = 2 // Level 2
  let CMP2_CR0_HYSTCTR_Level_11 $u2 = 3 // Level 3

//--- Enumerated values for register CR0, field FILTER_CNT
  let CMP2_CR0_FILTER_CNT_Filter_000 $u3 = 0 // Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
  let CMP2_CR0_FILTER_CNT_One_001 $u3 = 1 // One sample must agree. The comparator output is simply sampled.
  let CMP2_CR0_FILTER_CNT_2_010 $u3 = 2 // 2 consecutive samples must agree.
  let CMP2_CR0_FILTER_CNT_3_011 $u3 = 3 // 3 consecutive samples must agree.
  let CMP2_CR0_FILTER_CNT_4_100 $u3 = 4 // 4 consecutive samples must agree.
  let CMP2_CR0_FILTER_CNT_5_101 $u3 = 5 // 5 consecutive samples must agree.
  let CMP2_CR0_FILTER_CNT_6_110 $u3 = 6 // 6 consecutive samples must agree.
  let CMP2_CR0_FILTER_CNT_7_111 $u3 = 7 // 7 consecutive samples must agree.

//--- Enumerated values for register CR1, field EN
  let CMP2_CR1_EN_Analog_0 $bool = no // Analog Comparator is disabled.
  let CMP2_CR1_EN_Analog_1 $bool = yes // Analog Comparator is enabled.

//--- Enumerated values for register CR1, field OPE
  let CMP2_CR1_OPE_CMPO_0 $bool = no // CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
  let CMP2_CR1_OPE_CMPO_1 $bool = yes // CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.

//--- Enumerated values for register CR1, field COS
  let CMP2_CR1_COS_Set_0 $bool = no // Set the filtered comparator output (CMPO) to equal COUT.
  let CMP2_CR1_COS_Set_1 $bool = yes // Set the unfiltered comparator output (CMPO) to equal COUTA.

//--- Enumerated values for register CR1, field INV
  let CMP2_CR1_INV_Does_0 $bool = no // Does not invert the comparator output.
  let CMP2_CR1_INV_Inverts_1 $bool = yes // Inverts the comparator output.

//--- Enumerated values for register CR1, field PMODE
  let CMP2_CR1_PMODE_Low_Speed_0 $bool = no // Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
  let CMP2_CR1_PMODE_High_Speed_1 $bool = yes // High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.

//--- Enumerated values for register CR1, field TRIGM
  let CMP2_CR1_TRIGM_Trigger_0 $bool = no // Trigger mode is disabled.
  let CMP2_CR1_TRIGM_Trigger_1 $bool = yes // Trigger mode is enabled.

//--- Enumerated values for register CR1, field WE
  let CMP2_CR1_WE_Windowing_0 $bool = no // Windowing mode is not selected.
  let CMP2_CR1_WE_Windowing_1 $bool = yes // Windowing mode is selected.

//--- Enumerated values for register CR1, field SE
  let CMP2_CR1_SE_Sampling_0 $bool = no // Sampling mode is not selected.
  let CMP2_CR1_SE_Sampling_1 $bool = yes // Sampling mode is selected.

//--- Enumerated values for register SCR, field CFF
  let CMP2_SCR_CFF_Falling_edge_0 $bool = no // Falling-edge on COUT has not been detected.
  let CMP2_SCR_CFF_Falling_edge_1 $bool = yes // Falling-edge on COUT has occurred.

//--- Enumerated values for register SCR, field CFR
  let CMP2_SCR_CFR_Rising_edge_0 $bool = no // Rising-edge on COUT has not been detected.
  let CMP2_SCR_CFR_Rising_edge_1 $bool = yes // Rising-edge on COUT has occurred.

//--- Enumerated values for register SCR, field IEF
  let CMP2_SCR_IEF_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP2_SCR_IEF_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field IER
  let CMP2_SCR_IER_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP2_SCR_IER_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field DMAEN
  let CMP2_SCR_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let CMP2_SCR_DMAEN_DMA_1 $bool = yes // DMA is enabled.

//--- Enumerated values for register DACCR, field VRSEL
  let CMP2_DACCR_VRSEL_Vin1_0 $bool = no // Vin1 is selected as resistor ladder network supply reference.
  let CMP2_DACCR_VRSEL_Vin2_1 $bool = yes // Vin2 is selected as resistor ladder network supply reference.

//--- Enumerated values for register DACCR, field DACEN
  let CMP2_DACCR_DACEN_DAC_0 $bool = no // DAC is disabled.
  let CMP2_DACCR_DACEN_DAC_1 $bool = yes // DAC is enabled.

//--- Enumerated values for register MUXCR, field MSEL
  let CMP2_MUXCR_MSEL_IN0_000 $u3 = 0 // IN0
  let CMP2_MUXCR_MSEL_IN1_001 $u3 = 1 // IN1
  let CMP2_MUXCR_MSEL_IN2_010 $u3 = 2 // IN2
  let CMP2_MUXCR_MSEL_IN3_011 $u3 = 3 // IN3
  let CMP2_MUXCR_MSEL_IN4_100 $u3 = 4 // IN4
  let CMP2_MUXCR_MSEL_IN5_101 $u3 = 5 // IN5
  let CMP2_MUXCR_MSEL_IN6_110 $u3 = 6 // IN6
  let CMP2_MUXCR_MSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSEL
  let CMP2_MUXCR_PSEL_IN0_000 $u3 = 0 // IN0
  let CMP2_MUXCR_PSEL_IN1_001 $u3 = 1 // IN1
  let CMP2_MUXCR_PSEL_IN2_010 $u3 = 2 // IN2
  let CMP2_MUXCR_PSEL_IN3_011 $u3 = 3 // IN3
  let CMP2_MUXCR_PSEL_IN4_100 $u3 = 4 // IN4
  let CMP2_MUXCR_PSEL_IN5_101 $u3 = 5 // IN5
  let CMP2_MUXCR_PSEL_IN6_110 $u3 = 6 // IN6
  let CMP2_MUXCR_PSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSTM
  let CMP2_MUXCR_PSTM_Pass_0 $bool = no // Pass Through Mode is disabled.
  let CMP2_MUXCR_PSTM_Pass_1 $bool = yes // Pass Through Mode is enabled.

//--- Enumerated values for register CR0, field HYSTCTR
  let CMP3_CR0_HYSTCTR_Level_00 $u2 = 0 // Level 0
  let CMP3_CR0_HYSTCTR_Level_01 $u2 = 1 // Level 1
  let CMP3_CR0_HYSTCTR_Level_10 $u2 = 2 // Level 2
  let CMP3_CR0_HYSTCTR_Level_11 $u2 = 3 // Level 3

//--- Enumerated values for register CR0, field FILTER_CNT
  let CMP3_CR0_FILTER_CNT_Filter_000 $u3 = 0 // Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
  let CMP3_CR0_FILTER_CNT_One_001 $u3 = 1 // One sample must agree. The comparator output is simply sampled.
  let CMP3_CR0_FILTER_CNT_2_010 $u3 = 2 // 2 consecutive samples must agree.
  let CMP3_CR0_FILTER_CNT_3_011 $u3 = 3 // 3 consecutive samples must agree.
  let CMP3_CR0_FILTER_CNT_4_100 $u3 = 4 // 4 consecutive samples must agree.
  let CMP3_CR0_FILTER_CNT_5_101 $u3 = 5 // 5 consecutive samples must agree.
  let CMP3_CR0_FILTER_CNT_6_110 $u3 = 6 // 6 consecutive samples must agree.
  let CMP3_CR0_FILTER_CNT_7_111 $u3 = 7 // 7 consecutive samples must agree.

//--- Enumerated values for register CR1, field EN
  let CMP3_CR1_EN_Analog_0 $bool = no // Analog Comparator is disabled.
  let CMP3_CR1_EN_Analog_1 $bool = yes // Analog Comparator is enabled.

//--- Enumerated values for register CR1, field OPE
  let CMP3_CR1_OPE_CMPO_0 $bool = no // CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
  let CMP3_CR1_OPE_CMPO_1 $bool = yes // CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.

//--- Enumerated values for register CR1, field COS
  let CMP3_CR1_COS_Set_0 $bool = no // Set the filtered comparator output (CMPO) to equal COUT.
  let CMP3_CR1_COS_Set_1 $bool = yes // Set the unfiltered comparator output (CMPO) to equal COUTA.

//--- Enumerated values for register CR1, field INV
  let CMP3_CR1_INV_Does_0 $bool = no // Does not invert the comparator output.
  let CMP3_CR1_INV_Inverts_1 $bool = yes // Inverts the comparator output.

//--- Enumerated values for register CR1, field PMODE
  let CMP3_CR1_PMODE_Low_Speed_0 $bool = no // Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
  let CMP3_CR1_PMODE_High_Speed_1 $bool = yes // High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.

//--- Enumerated values for register CR1, field TRIGM
  let CMP3_CR1_TRIGM_Trigger_0 $bool = no // Trigger mode is disabled.
  let CMP3_CR1_TRIGM_Trigger_1 $bool = yes // Trigger mode is enabled.

//--- Enumerated values for register CR1, field WE
  let CMP3_CR1_WE_Windowing_0 $bool = no // Windowing mode is not selected.
  let CMP3_CR1_WE_Windowing_1 $bool = yes // Windowing mode is selected.

//--- Enumerated values for register CR1, field SE
  let CMP3_CR1_SE_Sampling_0 $bool = no // Sampling mode is not selected.
  let CMP3_CR1_SE_Sampling_1 $bool = yes // Sampling mode is selected.

//--- Enumerated values for register SCR, field CFF
  let CMP3_SCR_CFF_Falling_edge_0 $bool = no // Falling-edge on COUT has not been detected.
  let CMP3_SCR_CFF_Falling_edge_1 $bool = yes // Falling-edge on COUT has occurred.

//--- Enumerated values for register SCR, field CFR
  let CMP3_SCR_CFR_Rising_edge_0 $bool = no // Rising-edge on COUT has not been detected.
  let CMP3_SCR_CFR_Rising_edge_1 $bool = yes // Rising-edge on COUT has occurred.

//--- Enumerated values for register SCR, field IEF
  let CMP3_SCR_IEF_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP3_SCR_IEF_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field IER
  let CMP3_SCR_IER_Interrupt_0 $bool = no // Interrupt is disabled.
  let CMP3_SCR_IER_Interrupt_1 $bool = yes // Interrupt is enabled.

//--- Enumerated values for register SCR, field DMAEN
  let CMP3_SCR_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let CMP3_SCR_DMAEN_DMA_1 $bool = yes // DMA is enabled.

//--- Enumerated values for register DACCR, field VRSEL
  let CMP3_DACCR_VRSEL_Vin1_0 $bool = no // Vin1 is selected as resistor ladder network supply reference.
  let CMP3_DACCR_VRSEL_Vin2_1 $bool = yes // Vin2 is selected as resistor ladder network supply reference.

//--- Enumerated values for register DACCR, field DACEN
  let CMP3_DACCR_DACEN_DAC_0 $bool = no // DAC is disabled.
  let CMP3_DACCR_DACEN_DAC_1 $bool = yes // DAC is enabled.

//--- Enumerated values for register MUXCR, field MSEL
  let CMP3_MUXCR_MSEL_IN0_000 $u3 = 0 // IN0
  let CMP3_MUXCR_MSEL_IN1_001 $u3 = 1 // IN1
  let CMP3_MUXCR_MSEL_IN2_010 $u3 = 2 // IN2
  let CMP3_MUXCR_MSEL_IN3_011 $u3 = 3 // IN3
  let CMP3_MUXCR_MSEL_IN4_100 $u3 = 4 // IN4
  let CMP3_MUXCR_MSEL_IN5_101 $u3 = 5 // IN5
  let CMP3_MUXCR_MSEL_IN6_110 $u3 = 6 // IN6
  let CMP3_MUXCR_MSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSEL
  let CMP3_MUXCR_PSEL_IN0_000 $u3 = 0 // IN0
  let CMP3_MUXCR_PSEL_IN1_001 $u3 = 1 // IN1
  let CMP3_MUXCR_PSEL_IN2_010 $u3 = 2 // IN2
  let CMP3_MUXCR_PSEL_IN3_011 $u3 = 3 // IN3
  let CMP3_MUXCR_PSEL_IN4_100 $u3 = 4 // IN4
  let CMP3_MUXCR_PSEL_IN5_101 $u3 = 5 // IN5
  let CMP3_MUXCR_PSEL_IN6_110 $u3 = 6 // IN6
  let CMP3_MUXCR_PSEL_IN7_111 $u3 = 7 // IN7

//--- Enumerated values for register MUXCR, field PSTM
  let CMP3_MUXCR_PSTM_Pass_0 $bool = no // Pass Through Mode is disabled.
  let CMP3_MUXCR_PSTM_Pass_1 $bool = yes // Pass Through Mode is enabled.

//------------------------------------------------------------------------------
// Peripheral CMT: Carrier Modulator Transmitter
//------------------------------------------------------------------------------

registers ©CMT @at 0x40062000 {
//---  Register CGH1: CMT Carrier Generator High Data Register 1
  CGH1 @offset 0x0 $u8 {
    PH:8 // at 0: Primary Carrier High Time Data Value
  }

//---  Register CGL1: CMT Carrier Generator Low Data Register 1
  CGL1 @offset 0x1 $u8 {
    PL:8 // at 0: Primary Carrier Low Time Data Value
  }

//---  Register CGH2: CMT Carrier Generator High Data Register 2
  CGH2 @offset 0x2 $u8 {
    SH:8 // at 0: Secondary Carrier High Time Data Value
  }

//---  Register CGL2: CMT Carrier Generator Low Data Register 2
  CGL2 @offset 0x3 $u8 {
    SL:8 // at 0: Secondary Carrier Low Time Data Value
  }

//---  Register OC: CMT Output Control Register
  OC @offset 0x4 $u8 {
    IROL // at 7: IRO Latch Control
    CMTPOL // at 6: CMT Output Polarity
    IROPEN // at 5: IRO Pin Enable
    5
  }

//---  Register MSC: CMT Modulator Status and Control Register
  MSC @offset 0x5 $u8 {
    EOCF // at 7: End Of Cycle Status Flag
    CMTDIV:2 // at 5: CMT Clock Divide Prescaler
    EXSPC // at 4: Extended Space Enable
    BASE // at 3: Baseband Enable
    FSK // at 2: FSK Mode Select
    EOCIE // at 1: End of Cycle Interrupt Enable
    MCGEN // at 0: Modulator and Carrier Generator Enable
  }

//---  Register CMD1: CMT Modulator Data Register Mark High
  CMD1 @offset 0x6 $u8 {
    MB:8 // at 0: MB[15:8]
  }

//---  Register CMD2: CMT Modulator Data Register Mark Low
  CMD2 @offset 0x7 $u8 {
    MB:8 // at 0: MB[7:0]
  }

//---  Register CMD3: CMT Modulator Data Register Space High
  CMD3 @offset 0x8 $u8 {
    SB:8 // at 0: SB[15:8]
  }

//---  Register CMD4: CMT Modulator Data Register Space Low
  CMD4 @offset 0x9 $u8 {
    SB:8 // at 0: SB[7:0]
  }

//---  Register PPS: CMT Primary Prescaler Register
  PPS @offset 0xa $u8 {
    4
    PPSDIV:4 // at 0: Primary Prescaler Divider
  }

//---  Register DMA: CMT Direct Memory Access Register
  DMA @offset 0xb $u8 {
    7
    DMA // at 0: DMA Enable
  }

}

//--- Enumerated values for register OC, field IROPEN
  let CMT_OC_IROPEN_The_0 $bool = no // The IRO signal is disabled.
  let CMT_OC_IROPEN_The_1 $bool = yes // The IRO signal is enabled as output.

//--- Enumerated values for register OC, field CMTPOL
  let CMT_OC_CMTPOL_The_0 $bool = no // The IRO signal is active-low.
  let CMT_OC_CMTPOL_The_1 $bool = yes // The IRO signal is active-high.

//--- Enumerated values for register MSC, field MCGEN
  let CMT_MSC_MCGEN_Modulator_0 $bool = no // Modulator and carrier generator disabled
  let CMT_MSC_MCGEN_Modulator_1 $bool = yes // Modulator and carrier generator enabled

//--- Enumerated values for register MSC, field EOCIE
  let CMT_MSC_EOCIE_CPU_0 $bool = no // CPU interrupt is disabled.
  let CMT_MSC_EOCIE_CPU_1 $bool = yes // CPU interrupt is enabled.

//--- Enumerated values for register MSC, field FSK
  let CMT_MSC_FSK_The_0 $bool = no // The CMT operates in Time or Baseband mode.
  let CMT_MSC_FSK_The_1 $bool = yes // The CMT operates in FSK mode.

//--- Enumerated values for register MSC, field BASE
  let CMT_MSC_BASE_Baseband_0 $bool = no // Baseband mode is disabled.
  let CMT_MSC_BASE_Baseband_1 $bool = yes // Baseband mode is enabled.

//--- Enumerated values for register MSC, field EXSPC
  let CMT_MSC_EXSPC_Extended_0 $bool = no // Extended space is disabled.
  let CMT_MSC_EXSPC_Extended_1 $bool = yes // Extended space is enabled.

//--- Enumerated values for register MSC, field CMTDIV
  let CMT_MSC_CMTDIV_IF_00 $u2 = 0 // IF * 1
  let CMT_MSC_CMTDIV_IF_01 $u2 = 1 // IF * 2
  let CMT_MSC_CMTDIV_IF_10 $u2 = 2 // IF * 4
  let CMT_MSC_CMTDIV_IF_11 $u2 = 3 // IF * 8

//--- Enumerated values for register MSC, field EOCF
  let CMT_MSC_EOCF_End_0 $bool = no // End of modulation cycle has not occured since the flag last cleared.
  let CMT_MSC_EOCF_End_1 $bool = yes // End of modulator cycle has occurred.

//--- Enumerated values for register PPS, field PPSDIV
  let CMT_PPS_PPSDIV_Bus_0000 $u4 = 0 // Bus clock * 1
  let CMT_PPS_PPSDIV_Bus_0001 $u4 = 1 // Bus clock * 2
  let CMT_PPS_PPSDIV_Bus_0010 $u4 = 2 // Bus clock * 3
  let CMT_PPS_PPSDIV_Bus_0011 $u4 = 3 // Bus clock * 4
  let CMT_PPS_PPSDIV_Bus_0100 $u4 = 4 // Bus clock * 5
  let CMT_PPS_PPSDIV_Bus_0101 $u4 = 5 // Bus clock * 6
  let CMT_PPS_PPSDIV_Bus_0110 $u4 = 6 // Bus clock * 7
  let CMT_PPS_PPSDIV_Bus_0111 $u4 = 7 // Bus clock * 8
  let CMT_PPS_PPSDIV_Bus_1000 $u4 = 8 // Bus clock * 9
  let CMT_PPS_PPSDIV_Bus_1001 $u4 = 9 // Bus clock * 10
  let CMT_PPS_PPSDIV_Bus_1010 $u4 = 10 // Bus clock * 11
  let CMT_PPS_PPSDIV_Bus_1011 $u4 = 11 // Bus clock * 12
  let CMT_PPS_PPSDIV_Bus_1100 $u4 = 12 // Bus clock * 13
  let CMT_PPS_PPSDIV_Bus_1101 $u4 = 13 // Bus clock * 14
  let CMT_PPS_PPSDIV_Bus_1110 $u4 = 14 // Bus clock * 15
  let CMT_PPS_PPSDIV_Bus_1111 $u4 = 15 // Bus clock * 16

//--- Enumerated values for register DMA, field DMA
  let CMT_DMA_DMA_DMA_0 $bool = no // DMA transfer request and done are disabled.
  let CMT_DMA_DMA_DMA_1 $bool = yes // DMA transfer request and done are enabled.

//------------------------------------------------------------------------------
// Peripheral CRC: Cyclic Redundancy Check
//------------------------------------------------------------------------------

registers ©CRC @at 0x40032000 {
//---  Register DATA: CRC Data register
  DATA @offset 0x0 $u32 {
    HU:8 // at 24: CRC High Upper Byte
    HL:8 // at 16: CRC High Lower Byte
    LU:8 // at 8: CRC Low Upper Byte
    LL:8 // at 0: CRC Low Lower Byte
  }

//---  Register DATAL: CRC_DATAL register.
  DATAL @offset 0x0 $u16 {
    DATAL:16 // at 0: DATAL stores the lower 16 bits of the 16/32 bit CRC
  }

//---  Register DATALL: CRC_DATALL register.
  DATALL @offset 0x0 $u8 {
    DATALL:8 // at 0: CRCLL stores the first 8 bits of the 32 bit DATA
  }

//---  Register DATALU: CRC_DATALU register.
  DATALU @offset 0x1 $u8 {
    DATALU:8 // at 0: DATALL stores the second 8 bits of the 32 bit CRC
  }

//---  Register DATAH: CRC_DATAH register.
  DATAH @offset 0x2 $u16 {
    DATAH:16 // at 0: DATAH stores the high 16 bits of the 16/32 bit CRC
  }

//---  Register DATAHL: CRC_DATAHL register.
  DATAHL @offset 0x2 $u8 {
    DATAHL:8 // at 0: DATAHL stores the third 8 bits of the 32 bit CRC
  }

//---  Register DATAHU: CRC_DATAHU register.
  DATAHU @offset 0x3 $u8 {
    DATAHU:8 // at 0: DATAHU stores the fourth 8 bits of the 32 bit CRC
  }

//---  Register GPOLY: CRC Polynomial register
  GPOLY @offset 0x4 $u32 {
    HIGH:16 // at 16: High Polynominal Half-word
    LOW:16 // at 0: Low Polynominal Half-word
  }

//---  Register GPOLYL: CRC_GPOLYL register.
  GPOLYL @offset 0x4 $u16 {
    GPOLYL:16 // at 0: POLYL stores the lower 16 bits of the 16/32 bit CRC polynomial value
  }

//---  Register GPOLYLL: CRC_GPOLYLL register.
  GPOLYLL @offset 0x4 $u8 {
    GPOLYLL:8 // at 0: POLYLL stores the first 8 bits of the 32 bit CRC
  }

//---  Register GPOLYLU: CRC_GPOLYLU register.
  GPOLYLU @offset 0x5 $u8 {
    GPOLYLU:8 // at 0: POLYLL stores the second 8 bits of the 32 bit CRC
  }

//---  Register GPOLYH: CRC_GPOLYH register.
  GPOLYH @offset 0x6 $u16 {
    GPOLYH:16 // at 0: POLYH stores the high 16 bits of the 16/32 bit CRC polynomial value
  }

//---  Register GPOLYHL: CRC_GPOLYHL register.
  GPOLYHL @offset 0x6 $u8 {
    GPOLYHL:8 // at 0: POLYHL stores the third 8 bits of the 32 bit CRC
  }

//---  Register GPOLYHU: CRC_GPOLYHU register.
  GPOLYHU @offset 0x7 $u8 {
    GPOLYHU:8 // at 0: POLYHU stores the fourth 8 bits of the 32 bit CRC
  }

//---  Register CTRL: CRC Control register
  CTRL @offset 0x8 $u32 {
    TOT:2 // at 30: Type Of Transpose For Writes
    TOTR:2 // at 28: Type Of Transpose For Read
    1
    FXOR // at 26: Complement Read Of CRC Data Register
    WAS // at 25: Write CRC Data Register As Seed
    TCRC // at 24: Width of CRC protocol.
    24
  }

//---  Register CTRLHU: CRC_CTRLHU register.
  CTRLHU @offset 0xb $u8 {
    TOT:2 // at 6: no description available
    TOTR:2 // at 4: no description available
    1
    FXOR // at 2: no description available
    WAS // at 1: no description available
    TCRC // at 0: no description available
  }

}

//--- Enumerated values for register CTRL, field TCRC
  let CRC_CTRL_TCRC_16_bit_0 $bool = no // 16-bit CRC protocol.
  let CRC_CTRL_TCRC_32_bit_1 $bool = yes // 32-bit CRC protocol.

//--- Enumerated values for register CTRL, field WAS
  let CRC_CTRL_WAS_Writes_0 $bool = no // Writes to the CRC data register are data values.
  let CRC_CTRL_WAS_Writes_1 $bool = yes // Writes to the CRC data register are seed values.

//--- Enumerated values for register CTRL, field FXOR
  let CRC_CTRL_FXOR_No_0 $bool = no // No XOR on reading.
  let CRC_CTRL_FXOR_Invert_1 $bool = yes // Invert or complement the read value of the CRC Data register.

//--- Enumerated values for register CTRL, field TOTR
  let CRC_CTRL_TOTR_No_00 $u2 = 0 // No transposition.
  let CRC_CTRL_TOTR_Bits_01 $u2 = 1 // Bits in bytes are transposed; bytes are not transposed.
  let CRC_CTRL_TOTR_Both_10 $u2 = 2 // Both bits in bytes and bytes are transposed.
  let CRC_CTRL_TOTR_Only_11 $u2 = 3 // Only bytes are transposed; no bits in a byte are transposed.

//--- Enumerated values for register CTRL, field TOT
  let CRC_CTRL_TOT_No_00 $u2 = 0 // No transposition.
  let CRC_CTRL_TOT_Bits_01 $u2 = 1 // Bits in bytes are transposed; bytes are not transposed.
  let CRC_CTRL_TOT_Both_10 $u2 = 2 // Both bits in bytes and bytes are transposed.
  let CRC_CTRL_TOT_Only_11 $u2 = 3 // Only bytes are transposed; no bits in a byte are transposed.

//--- Enumerated values for register CTRLHU, field TCRC
  let CRC_CTRLHU_TCRC_16_bit_0 $bool = no // 16-bit CRC protocol.
  let CRC_CTRLHU_TCRC_32_bit_1 $bool = yes // 32-bit CRC protocol.

//--- Enumerated values for register CTRLHU, field WAS
  let CRC_CTRLHU_WAS_Writes_0 $bool = no // Writes to CRC data register are data values.
  let CRC_CTRLHU_WAS_Writes_1 $bool = yes // Writes to CRC data reguster are seed values.

//--- Enumerated values for register CTRLHU, field FXOR
  let CRC_CTRLHU_FXOR_No_0 $bool = no // No XOR on reading.
  let CRC_CTRLHU_FXOR_Invert_1 $bool = yes // Invert or complement the read value of CRC data register.

//--- Enumerated values for register CTRLHU, field TOTR
  let CRC_CTRLHU_TOTR_No_00 $u2 = 0 // No Transposition.
  let CRC_CTRLHU_TOTR_Bits_01 $u2 = 1 // Bits in bytes are transposed, bytes are not transposed.
  let CRC_CTRLHU_TOTR_Both_10 $u2 = 2 // Both bits in bytes and bytes are transposed.
  let CRC_CTRLHU_TOTR_Only_11 $u2 = 3 // Only bytes are transposed; no bits in a byte are transposed.

//--- Enumerated values for register CTRLHU, field TOT
  let CRC_CTRLHU_TOT_No_00 $u2 = 0 // No Transposition.
  let CRC_CTRLHU_TOT_Bits_01 $u2 = 1 // Bits in bytes are transposed, bytes are not transposed.
  let CRC_CTRLHU_TOT_Both_10 $u2 = 2 // Both bits in bytes and bytes are transposed.
  let CRC_CTRLHU_TOT_Only_11 $u2 = 3 // Only bytes are transposed; no bits in a byte are transposed.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©DAC [2]
//        DAC0 at 0x400cc000
//        DAC1 at 0x400cd000
//------------------------------------------------------------------------------

registers ©DAC [2 @at 0x400cc000 0x400cd000]
          ©DAC0 @at 0x400cc000
          ©DAC1 @at 0x400cd000 {
//---  Registers DATL(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data Low Register
  DATL [16 @offset 0x0 @inc 0x2]
  DAT0L @offset 0x0
  DAT1L @offset 0x2
  DAT2L @offset 0x4
  DAT3L @offset 0x6
  DAT4L @offset 0x8
  DAT5L @offset 0xa
  DAT6L @offset 0xc
  DAT7L @offset 0xe
  DAT8L @offset 0x10
  DAT9L @offset 0x12
  DAT10L @offset 0x14
  DAT11L @offset 0x16
  DAT12L @offset 0x18
  DAT13L @offset 0x1a
  DAT14L @offset 0x1c
  DAT15L @offset 0x1e $u8 {
    DATA0:8 // at 0: DATA0
  }

//---  Registers DATH(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): DAC Data High Register
  DATH [16 @offset 0x1 @inc 0x2]
  DAT0H @offset 0x1
  DAT1H @offset 0x3
  DAT2H @offset 0x5
  DAT3H @offset 0x7
  DAT4H @offset 0x9
  DAT5H @offset 0xb
  DAT6H @offset 0xd
  DAT7H @offset 0xf
  DAT8H @offset 0x11
  DAT9H @offset 0x13
  DAT10H @offset 0x15
  DAT11H @offset 0x17
  DAT12H @offset 0x19
  DAT13H @offset 0x1b
  DAT14H @offset 0x1d
  DAT15H @offset 0x1f $u8 {
    4
    DATA1:4 // at 0: DATA1
  }

//---  Register SR: DAC Status Register
  SR @offset 0x20 $u8 {
    5
    DACBFWMF // at 2: DAC Buffer Watermark Flag
    DACBFRPTF // at 1: DAC Buffer Read Pointer Top Position Flag
    DACBFRPBF // at 0: DAC Buffer Read Pointer Bottom Position Flag
  }

//---  Register C0: DAC Control Register
  C0 @offset 0x21 $u8 {
    DACEN // at 7: DAC Enable
    DACRFS // at 6: DAC Reference Select
    DACTRGSEL // at 5: DAC Trigger Select
    DACSWTRG // at 4: DAC Software Trigger
    LPEN // at 3: DAC Low Power Control
    DACBWIEN // at 2: DAC Buffer Watermark Interrupt Enable
    DACBTIEN // at 1: DAC Buffer Read Pointer Top Flag Interrupt Enable
    DACBBIEN // at 0: DAC Buffer Read Pointer Bottom Flag Interrupt Enable
  }

//---  Register C1: DAC Control Register 1
  C1 @offset 0x22 $u8 {
    DMAEN // at 7: DMA Enable Select
    2
    DACBFWM:2 // at 3: DAC Buffer Watermark Select
    DACBFMD:2 // at 1: DAC Buffer Work Mode Select
    DACBFEN // at 0: DAC Buffer Enable
  }

//---  Register C2: DAC Control Register 2
  C2 @offset 0x23 $u8 {
    DACBFRP:4 // at 4: DAC Buffer Read Pointer
    DACBFUP:4 // at 0: DAC Buffer Upper Limit
  }

}

//--- Enumerated values for register SR, field DACBFRPBF
  let DAC0_SR_DACBFRPBF_The_0 $bool = no // The DAC buffer read pointer is not equal to C2[DACBFUP].
  let DAC0_SR_DACBFRPBF_The_1 $bool = yes // The DAC buffer read pointer is equal to C2[DACBFUP].

//--- Enumerated values for register SR, field DACBFRPTF
  let DAC0_SR_DACBFRPTF_The_0 $bool = no // The DAC buffer read pointer is not zero.
  let DAC0_SR_DACBFRPTF_The_1 $bool = yes // The DAC buffer read pointer is zero.

//--- Enumerated values for register SR, field DACBFWMF
  let DAC0_SR_DACBFWMF_The_0 $bool = no // The DAC buffer read pointer has not reached the watermark level.
  let DAC0_SR_DACBFWMF_The_1 $bool = yes // The DAC buffer read pointer has reached the watermark level.

//--- Enumerated values for register C0, field DACBBIEN
  let DAC0_C0_DACBBIEN_The_0 $bool = no // The DAC buffer read pointer bottom flag interrupt is disabled.
  let DAC0_C0_DACBBIEN_The_1 $bool = yes // The DAC buffer read pointer bottom flag interrupt is enabled.

//--- Enumerated values for register C0, field DACBTIEN
  let DAC0_C0_DACBTIEN_The_0 $bool = no // The DAC buffer read pointer top flag interrupt is disabled.
  let DAC0_C0_DACBTIEN_The_1 $bool = yes // The DAC buffer read pointer top flag interrupt is enabled.

//--- Enumerated values for register C0, field DACBWIEN
  let DAC0_C0_DACBWIEN_The_0 $bool = no // The DAC buffer watermark interrupt is disabled.
  let DAC0_C0_DACBWIEN_The_1 $bool = yes // The DAC buffer watermark interrupt is enabled.

//--- Enumerated values for register C0, field LPEN
  let DAC0_C0_LPEN_High_Power_0 $bool = no // High-Power mode
  let DAC0_C0_LPEN_Low_Power_1 $bool = yes // Low-Power mode

//--- Enumerated values for register C0, field DACSWTRG
  let DAC0_C0_DACSWTRG_The_0 $bool = no // The DAC soft trigger is not valid.
  let DAC0_C0_DACSWTRG_The_1 $bool = yes // The DAC soft trigger is valid.

//--- Enumerated values for register C0, field DACTRGSEL
  let DAC0_C0_DACTRGSEL_The_0 $bool = no // The DAC hardware trigger is selected.
  let DAC0_C0_DACTRGSEL_The_1 $bool = yes // The DAC software trigger is selected.

//--- Enumerated values for register C0, field DACRFS
  let DAC0_C0_DACRFS_The_0 $bool = no // The DAC selects DACREF_1 as the reference voltage.
  let DAC0_C0_DACRFS_The_1 $bool = yes // The DAC selects DACREF_2 as the reference voltage.

//--- Enumerated values for register C0, field DACEN
  let DAC0_C0_DACEN_The_0 $bool = no // The DAC system is disabled.
  let DAC0_C0_DACEN_The_1 $bool = yes // The DAC system is enabled.

//--- Enumerated values for register C1, field DACBFEN
  let DAC0_C1_DACBFEN_Buffer_0 $bool = no // Buffer read pointer is disabled. The converted data is always the first word of the buffer.
  let DAC0_C1_DACBFEN_Buffer_1 $bool = yes // Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer.

//--- Enumerated values for register C1, field DACBFMD
  let DAC0_C1_DACBFMD_Normal_00 $u2 = 0 // Normal mode
  let DAC0_C1_DACBFMD_Swing_01 $u2 = 1 // Swing mode
  let DAC0_C1_DACBFMD_One_Time_10 $u2 = 2 // One-Time Scan mode

//--- Enumerated values for register C1, field DACBFWM
  let DAC0_C1_DACBFWM_1_00 $u2 = 0 // 1 word
  let DAC0_C1_DACBFWM_2_01 $u2 = 1 // 2 words
  let DAC0_C1_DACBFWM_3_10 $u2 = 2 // 3 words
  let DAC0_C1_DACBFWM_4_11 $u2 = 3 // 4 words

//--- Enumerated values for register C1, field DMAEN
  let DAC0_C1_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let DAC0_C1_DMAEN_DMA_1 $bool = yes // DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time.

//--- Enumerated values for register SR, field DACBFRPBF
  let DAC1_SR_DACBFRPBF_The_0 $bool = no // The DAC buffer read pointer is not equal to C2[DACBFUP].
  let DAC1_SR_DACBFRPBF_The_1 $bool = yes // The DAC buffer read pointer is equal to C2[DACBFUP].

//--- Enumerated values for register SR, field DACBFRPTF
  let DAC1_SR_DACBFRPTF_The_0 $bool = no // The DAC buffer read pointer is not zero.
  let DAC1_SR_DACBFRPTF_The_1 $bool = yes // The DAC buffer read pointer is zero.

//--- Enumerated values for register SR, field DACBFWMF
  let DAC1_SR_DACBFWMF_The_0 $bool = no // The DAC buffer read pointer has not reached the watermark level.
  let DAC1_SR_DACBFWMF_The_1 $bool = yes // The DAC buffer read pointer has reached the watermark level.

//--- Enumerated values for register C0, field DACBBIEN
  let DAC1_C0_DACBBIEN_The_0 $bool = no // The DAC buffer read pointer bottom flag interrupt is disabled.
  let DAC1_C0_DACBBIEN_The_1 $bool = yes // The DAC buffer read pointer bottom flag interrupt is enabled.

//--- Enumerated values for register C0, field DACBTIEN
  let DAC1_C0_DACBTIEN_The_0 $bool = no // The DAC buffer read pointer top flag interrupt is disabled.
  let DAC1_C0_DACBTIEN_The_1 $bool = yes // The DAC buffer read pointer top flag interrupt is enabled.

//--- Enumerated values for register C0, field DACBWIEN
  let DAC1_C0_DACBWIEN_The_0 $bool = no // The DAC buffer watermark interrupt is disabled.
  let DAC1_C0_DACBWIEN_The_1 $bool = yes // The DAC buffer watermark interrupt is enabled.

//--- Enumerated values for register C0, field LPEN
  let DAC1_C0_LPEN_High_Power_0 $bool = no // High-Power mode
  let DAC1_C0_LPEN_Low_Power_1 $bool = yes // Low-Power mode

//--- Enumerated values for register C0, field DACSWTRG
  let DAC1_C0_DACSWTRG_The_0 $bool = no // The DAC soft trigger is not valid.
  let DAC1_C0_DACSWTRG_The_1 $bool = yes // The DAC soft trigger is valid.

//--- Enumerated values for register C0, field DACTRGSEL
  let DAC1_C0_DACTRGSEL_The_0 $bool = no // The DAC hardware trigger is selected.
  let DAC1_C0_DACTRGSEL_The_1 $bool = yes // The DAC software trigger is selected.

//--- Enumerated values for register C0, field DACRFS
  let DAC1_C0_DACRFS_The_0 $bool = no // The DAC selects DACREF_1 as the reference voltage.
  let DAC1_C0_DACRFS_The_1 $bool = yes // The DAC selects DACREF_2 as the reference voltage.

//--- Enumerated values for register C0, field DACEN
  let DAC1_C0_DACEN_The_0 $bool = no // The DAC system is disabled.
  let DAC1_C0_DACEN_The_1 $bool = yes // The DAC system is enabled.

//--- Enumerated values for register C1, field DACBFEN
  let DAC1_C1_DACBFEN_Buffer_0 $bool = no // Buffer read pointer is disabled. The converted data is always the first word of the buffer.
  let DAC1_C1_DACBFEN_Buffer_1 $bool = yes // Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer.

//--- Enumerated values for register C1, field DACBFMD
  let DAC1_C1_DACBFMD_Normal_00 $u2 = 0 // Normal mode
  let DAC1_C1_DACBFMD_Swing_01 $u2 = 1 // Swing mode
  let DAC1_C1_DACBFMD_One_Time_10 $u2 = 2 // One-Time Scan mode

//--- Enumerated values for register C1, field DACBFWM
  let DAC1_C1_DACBFWM_1_00 $u2 = 0 // 1 word
  let DAC1_C1_DACBFWM_2_01 $u2 = 1 // 2 words
  let DAC1_C1_DACBFWM_3_10 $u2 = 2 // 3 words
  let DAC1_C1_DACBFWM_4_11 $u2 = 3 // 4 words

//--- Enumerated values for register C1, field DMAEN
  let DAC1_C1_DMAEN_DMA_0 $bool = no // DMA is disabled.
  let DAC1_C1_DMAEN_DMA_1 $bool = yes // DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time.

//------------------------------------------------------------------------------
// Peripheral DMA: Enhanced direct memory access controller
//------------------------------------------------------------------------------

registers ©DMA @at 0x40008000 {
//---  Register CR: Control Register
  CR @offset 0x0 $u32 {
    14
    CX // at 17: Cancel Transfer
    ECX // at 16: Error Cancel Transfer
    5
    GRP1PRI // at 10: Channel Group 1 Priority
    1
    GRP0PRI // at 8: Channel Group 0 Priority
    EMLM // at 7: Enable Minor Loop Mapping
    CLM // at 6: Continuous Link Mode
    HALT // at 5: Halt DMA Operations
    HOE // at 4: Halt On Error
    ERGA // at 3: Enable Round Robin Group Arbitration
    ERCA // at 2: Enable Round Robin Channel Arbitration
    EDBG // at 1: Enable Debug
    1
  }

//---  Register ES: Error Status Register
  ES @offset 0x4 @ro $u32 {
    VLD // at 31: Logical OR of all ERR status bits
    14
    ECX // at 16: Transfer Canceled
    GPE // at 15: Group Priority Error
    CPE // at 14: Channel Priority Error
    1
    ERRCHN:5 // at 8: Error Channel Number or Canceled Channel Number
    SAE // at 7: Source Address Error
    SOE // at 6: Source Offset Error
    DAE // at 5: Destination Address Error
    DOE // at 4: Destination Offset Error
    NCE // at 3: NBYTES/CITER Configuration Error
    SGE // at 2: Scatter/Gather Configuration Error
    SBE // at 1: Source Bus Error
    DBE // at 0: Destination Bus Error
  }

//---  Register ERQ: Enable Request Register
  ERQ @offset 0xc $u32 {
    ERQ31 // at 31: Enable DMA Request 31
    ERQ30 // at 30: Enable DMA Request 30
    ERQ29 // at 29: Enable DMA Request 29
    ERQ28 // at 28: Enable DMA Request 28
    ERQ27 // at 27: Enable DMA Request 27
    ERQ26 // at 26: Enable DMA Request 26
    ERQ25 // at 25: Enable DMA Request 25
    ERQ24 // at 24: Enable DMA Request 24
    ERQ23 // at 23: Enable DMA Request 23
    ERQ22 // at 22: Enable DMA Request 22
    ERQ21 // at 21: Enable DMA Request 21
    ERQ20 // at 20: Enable DMA Request 20
    ERQ19 // at 19: Enable DMA Request 19
    ERQ18 // at 18: Enable DMA Request 18
    ERQ17 // at 17: Enable DMA Request 17
    ERQ16 // at 16: Enable DMA Request 16
    ERQ15 // at 15: Enable DMA Request 15
    ERQ14 // at 14: Enable DMA Request 14
    ERQ13 // at 13: Enable DMA Request 13
    ERQ12 // at 12: Enable DMA Request 12
    ERQ11 // at 11: Enable DMA Request 11
    ERQ10 // at 10: Enable DMA Request 10
    ERQ9 // at 9: Enable DMA Request 9
    ERQ8 // at 8: Enable DMA Request 8
    ERQ7 // at 7: Enable DMA Request 7
    ERQ6 // at 6: Enable DMA Request 6
    ERQ5 // at 5: Enable DMA Request 5
    ERQ4 // at 4: Enable DMA Request 4
    ERQ3 // at 3: Enable DMA Request 3
    ERQ2 // at 2: Enable DMA Request 2
    ERQ1 // at 1: Enable DMA Request 1
    ERQ0 // at 0: Enable DMA Request 0
  }

//---  Register EEI: Enable Error Interrupt Register
  EEI @offset 0x14 $u32 {
    EEI31 // at 31: Enable Error Interrupt 31
    EEI30 // at 30: Enable Error Interrupt 30
    EEI29 // at 29: Enable Error Interrupt 29
    EEI28 // at 28: Enable Error Interrupt 28
    EEI27 // at 27: Enable Error Interrupt 27
    EEI26 // at 26: Enable Error Interrupt 26
    EEI25 // at 25: Enable Error Interrupt 25
    EEI24 // at 24: Enable Error Interrupt 24
    EEI23 // at 23: Enable Error Interrupt 23
    EEI22 // at 22: Enable Error Interrupt 22
    EEI21 // at 21: Enable Error Interrupt 21
    EEI20 // at 20: Enable Error Interrupt 20
    EEI19 // at 19: Enable Error Interrupt 19
    EEI18 // at 18: Enable Error Interrupt 18
    EEI17 // at 17: Enable Error Interrupt 17
    EEI16 // at 16: Enable Error Interrupt 16
    EEI15 // at 15: Enable Error Interrupt 15
    EEI14 // at 14: Enable Error Interrupt 14
    EEI13 // at 13: Enable Error Interrupt 13
    EEI12 // at 12: Enable Error Interrupt 12
    EEI11 // at 11: Enable Error Interrupt 11
    EEI10 // at 10: Enable Error Interrupt 10
    EEI9 // at 9: Enable Error Interrupt 9
    EEI8 // at 8: Enable Error Interrupt 8
    EEI7 // at 7: Enable Error Interrupt 7
    EEI6 // at 6: Enable Error Interrupt 6
    EEI5 // at 5: Enable Error Interrupt 5
    EEI4 // at 4: Enable Error Interrupt 4
    EEI3 // at 3: Enable Error Interrupt 3
    EEI2 // at 2: Enable Error Interrupt 2
    EEI1 // at 1: Enable Error Interrupt 1
    EEI0 // at 0: Enable Error Interrupt 0
  }

//---  Register CEEI: Clear Enable Error Interrupt Register
  CEEI @offset 0x18 $u8 {
    NOP // at 7: No Op enable
    CAEE // at 6: Clear All Enable Error Interrupts
    1
    CEEI:5 // at 0: Clear Enable Error Interrupt
  }

//---  Register SEEI: Set Enable Error Interrupt Register
  SEEI @offset 0x19 $u8 {
    NOP // at 7: No Op enable
    SAEE // at 6: Sets All Enable Error Interrupts
    1
    SEEI:5 // at 0: Set Enable Error Interrupt
  }

//---  Register CERQ: Clear Enable Request Register
  CERQ @offset 0x1a $u8 {
    NOP // at 7: No Op enable
    CAER // at 6: Clear All Enable Requests
    1
    CERQ:5 // at 0: Clear Enable Request
  }

//---  Register SERQ: Set Enable Request Register
  SERQ @offset 0x1b $u8 {
    NOP // at 7: No Op enable
    SAER // at 6: Set All Enable Requests
    1
    SERQ:5 // at 0: Set Enable Request
  }

//---  Register CDNE: Clear DONE Status Bit Register
  CDNE @offset 0x1c $u8 {
    NOP // at 7: No Op enable
    CADN // at 6: Clears All DONE Bits
    1
    CDNE:5 // at 0: Clear DONE Bit
  }

//---  Register SSRT: Set START Bit Register
  SSRT @offset 0x1d $u8 {
    NOP // at 7: No Op enable
    SAST // at 6: Set All START Bits (activates all channels)
    1
    SSRT:5 // at 0: Set START Bit
  }

//---  Register CERR: Clear Error Register
  CERR @offset 0x1e $u8 {
    NOP // at 7: No Op enable
    CAEI // at 6: Clear All Error Indicators
    1
    CERR:5 // at 0: Clear Error Indicator
  }

//---  Register CINT: Clear Interrupt Request Register
  CINT @offset 0x1f $u8 {
    NOP // at 7: No Op enable
    CAIR // at 6: Clear All Interrupt Requests
    1
    CINT:5 // at 0: Clear Interrupt Request
  }

//---  Register INT: Interrupt Request Register
  INT @offset 0x24 $u32 {
    INT31 // at 31: Interrupt Request 31
    INT30 // at 30: Interrupt Request 30
    INT29 // at 29: Interrupt Request 29
    INT28 // at 28: Interrupt Request 28
    INT27 // at 27: Interrupt Request 27
    INT26 // at 26: Interrupt Request 26
    INT25 // at 25: Interrupt Request 25
    INT24 // at 24: Interrupt Request 24
    INT23 // at 23: Interrupt Request 23
    INT22 // at 22: Interrupt Request 22
    INT21 // at 21: Interrupt Request 21
    INT20 // at 20: Interrupt Request 20
    INT19 // at 19: Interrupt Request 19
    INT18 // at 18: Interrupt Request 18
    INT17 // at 17: Interrupt Request 17
    INT16 // at 16: Interrupt Request 16
    INT15 // at 15: Interrupt Request 15
    INT14 // at 14: Interrupt Request 14
    INT13 // at 13: Interrupt Request 13
    INT12 // at 12: Interrupt Request 12
    INT11 // at 11: Interrupt Request 11
    INT10 // at 10: Interrupt Request 10
    INT9 // at 9: Interrupt Request 9
    INT8 // at 8: Interrupt Request 8
    INT7 // at 7: Interrupt Request 7
    INT6 // at 6: Interrupt Request 6
    INT5 // at 5: Interrupt Request 5
    INT4 // at 4: Interrupt Request 4
    INT3 // at 3: Interrupt Request 3
    INT2 // at 2: Interrupt Request 2
    INT1 // at 1: Interrupt Request 1
    INT0 // at 0: Interrupt Request 0
  }

//---  Register ERR: Error Register
  ERR @offset 0x2c $u32 {
    ERR31 // at 31: Error In Channel 31
    ERR30 // at 30: Error In Channel 30
    ERR29 // at 29: Error In Channel 29
    ERR28 // at 28: Error In Channel 28
    ERR27 // at 27: Error In Channel 27
    ERR26 // at 26: Error In Channel 26
    ERR25 // at 25: Error In Channel 25
    ERR24 // at 24: Error In Channel 24
    ERR23 // at 23: Error In Channel 23
    ERR22 // at 22: Error In Channel 22
    ERR21 // at 21: Error In Channel 21
    ERR20 // at 20: Error In Channel 20
    ERR19 // at 19: Error In Channel 19
    ERR18 // at 18: Error In Channel 18
    ERR17 // at 17: Error In Channel 17
    ERR16 // at 16: Error In Channel 16
    ERR15 // at 15: Error In Channel 15
    ERR14 // at 14: Error In Channel 14
    ERR13 // at 13: Error In Channel 13
    ERR12 // at 12: Error In Channel 12
    ERR11 // at 11: Error In Channel 11
    ERR10 // at 10: Error In Channel 10
    ERR9 // at 9: Error In Channel 9
    ERR8 // at 8: Error In Channel 8
    ERR7 // at 7: Error In Channel 7
    ERR6 // at 6: Error In Channel 6
    ERR5 // at 5: Error In Channel 5
    ERR4 // at 4: Error In Channel 4
    ERR3 // at 3: Error In Channel 3
    ERR2 // at 2: Error In Channel 2
    ERR1 // at 1: Error In Channel 1
    ERR0 // at 0: Error In Channel 0
  }

//---  Register HRS: Hardware Request Status Register
  HRS @offset 0x34 @ro $u32 {
    HRS31 // at 31: Hardware Request Status Channel 31
    HRS30 // at 30: Hardware Request Status Channel 30
    HRS29 // at 29: Hardware Request Status Channel 29
    HRS28 // at 28: Hardware Request Status Channel 28
    HRS27 // at 27: Hardware Request Status Channel 27
    HRS26 // at 26: Hardware Request Status Channel 26
    HRS25 // at 25: Hardware Request Status Channel 25
    HRS24 // at 24: Hardware Request Status Channel 24
    HRS23 // at 23: Hardware Request Status Channel 23
    HRS22 // at 22: Hardware Request Status Channel 22
    HRS21 // at 21: Hardware Request Status Channel 21
    HRS20 // at 20: Hardware Request Status Channel 20
    HRS19 // at 19: Hardware Request Status Channel 19
    HRS18 // at 18: Hardware Request Status Channel 18
    HRS17 // at 17: Hardware Request Status Channel 17
    HRS16 // at 16: Hardware Request Status Channel 16
    HRS15 // at 15: Hardware Request Status Channel 15
    HRS14 // at 14: Hardware Request Status Channel 14
    HRS13 // at 13: Hardware Request Status Channel 13
    HRS12 // at 12: Hardware Request Status Channel 12
    HRS11 // at 11: Hardware Request Status Channel 11
    HRS10 // at 10: Hardware Request Status Channel 10
    HRS9 // at 9: Hardware Request Status Channel 9
    HRS8 // at 8: Hardware Request Status Channel 8
    HRS7 // at 7: Hardware Request Status Channel 7
    HRS6 // at 6: Hardware Request Status Channel 6
    HRS5 // at 5: Hardware Request Status Channel 5
    HRS4 // at 4: Hardware Request Status Channel 4
    HRS3 // at 3: Hardware Request Status Channel 3
    HRS2 // at 2: Hardware Request Status Channel 2
    HRS1 // at 1: Hardware Request Status Channel 1
    HRS0 // at 0: Hardware Request Status Channel 0
  }

//---  Register EARS: Enable Asynchronous Request in Stop Register
  EARS @offset 0x44 $u32 {
    EDREQ_31 // at 31: Enable asynchronous DMA request in stop mode for channel 31
    EDREQ_30 // at 30: Enable asynchronous DMA request in stop mode for channel 30
    EDREQ_29 // at 29: Enable asynchronous DMA request in stop mode for channel 29
    EDREQ_28 // at 28: Enable asynchronous DMA request in stop mode for channel 28
    EDREQ_27 // at 27: Enable asynchronous DMA request in stop mode for channel 27
    EDREQ_26 // at 26: Enable asynchronous DMA request in stop mode for channel 26
    EDREQ_25 // at 25: Enable asynchronous DMA request in stop mode for channel 25
    EDREQ_24 // at 24: Enable asynchronous DMA request in stop mode for channel 24
    EDREQ_23 // at 23: Enable asynchronous DMA request in stop mode for channel 23
    EDREQ_22 // at 22: Enable asynchronous DMA request in stop mode for channel 22
    EDREQ_21 // at 21: Enable asynchronous DMA request in stop mode for channel 21
    EDREQ_20 // at 20: Enable asynchronous DMA request in stop mode for channel 20
    EDREQ_19 // at 19: Enable asynchronous DMA request in stop mode for channel 19
    EDREQ_18 // at 18: Enable asynchronous DMA request in stop mode for channel 18
    EDREQ_17 // at 17: Enable asynchronous DMA request in stop mode for channel 17
    EDREQ_16 // at 16: Enable asynchronous DMA request in stop mode for channel 16
    EDREQ_15 // at 15: Enable asynchronous DMA request in stop mode for channel 15
    EDREQ_14 // at 14: Enable asynchronous DMA request in stop mode for channel 14
    EDREQ_13 // at 13: Enable asynchronous DMA request in stop mode for channel 13
    EDREQ_12 // at 12: Enable asynchronous DMA request in stop mode for channel 12
    EDREQ_11 // at 11: Enable asynchronous DMA request in stop mode for channel 11
    EDREQ_10 // at 10: Enable asynchronous DMA request in stop mode for channel 10
    EDREQ_9 // at 9: Enable asynchronous DMA request in stop mode for channel 9
    EDREQ_8 // at 8: Enable asynchronous DMA request in stop mode for channel 8
    EDREQ_7 // at 7: Enable asynchronous DMA request in stop mode for channel 7
    EDREQ_6 // at 6: Enable asynchronous DMA request in stop mode for channel 6
    EDREQ_5 // at 5: Enable asynchronous DMA request in stop mode for channel 5
    EDREQ_4 // at 4: Enable asynchronous DMA request in stop mode for channel 4
    EDREQ_3 // at 3: Enable asynchronous DMA request in stop mode for channel 3.
    EDREQ_2 // at 2: Enable asynchronous DMA request in stop mode for channel 2.
    EDREQ_1 // at 1: Enable asynchronous DMA request in stop mode for channel 1.
    EDREQ_0 // at 0: Enable asynchronous DMA request in stop mode for channel 0.
  }

//---  Registers DCHPRI(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12,19,18,17,16,23,22,21,20,27,26,25,24,31,30,29,28): Channel n Priority Register
  DCHPRI [32 @offset 0x100 @inc 0x1]
  DCHPRI3 @offset 0x100
  DCHPRI2 @offset 0x101
  DCHPRI1 @offset 0x102
  DCHPRI0 @offset 0x103
  DCHPRI7 @offset 0x104
  DCHPRI6 @offset 0x105
  DCHPRI5 @offset 0x106
  DCHPRI4 @offset 0x107
  DCHPRI11 @offset 0x108
  DCHPRI10 @offset 0x109
  DCHPRI9 @offset 0x10a
  DCHPRI8 @offset 0x10b
  DCHPRI15 @offset 0x10c
  DCHPRI14 @offset 0x10d
  DCHPRI13 @offset 0x10e
  DCHPRI12 @offset 0x10f
  DCHPRI19 @offset 0x110
  DCHPRI18 @offset 0x111
  DCHPRI17 @offset 0x112
  DCHPRI16 @offset 0x113
  DCHPRI23 @offset 0x114
  DCHPRI22 @offset 0x115
  DCHPRI21 @offset 0x116
  DCHPRI20 @offset 0x117
  DCHPRI27 @offset 0x118
  DCHPRI26 @offset 0x119
  DCHPRI25 @offset 0x11a
  DCHPRI24 @offset 0x11b
  DCHPRI31 @offset 0x11c
  DCHPRI30 @offset 0x11d
  DCHPRI29 @offset 0x11e
  DCHPRI28 @offset 0x11f $u8 {
    ECP // at 7: Enable Channel Preemption.
    DPA // at 6: Disable Preempt Ability.
    GRPPRI:2 // at 4: Channel n Current Group Priority
    CHPRI:4 // at 0: Channel n Arbitration Priority
  }

//---  Registers TCD_SADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Source Address
  TCD_SADDR [32 @offset 0x1000 @inc 0x20]
  TCD0_SADDR @offset 0x1000
  TCD1_SADDR @offset 0x1020
  TCD2_SADDR @offset 0x1040
  TCD3_SADDR @offset 0x1060
  TCD4_SADDR @offset 0x1080
  TCD5_SADDR @offset 0x10a0
  TCD6_SADDR @offset 0x10c0
  TCD7_SADDR @offset 0x10e0
  TCD8_SADDR @offset 0x1100
  TCD9_SADDR @offset 0x1120
  TCD10_SADDR @offset 0x1140
  TCD11_SADDR @offset 0x1160
  TCD12_SADDR @offset 0x1180
  TCD13_SADDR @offset 0x11a0
  TCD14_SADDR @offset 0x11c0
  TCD15_SADDR @offset 0x11e0
  TCD16_SADDR @offset 0x1200
  TCD17_SADDR @offset 0x1220
  TCD18_SADDR @offset 0x1240
  TCD19_SADDR @offset 0x1260
  TCD20_SADDR @offset 0x1280
  TCD21_SADDR @offset 0x12a0
  TCD22_SADDR @offset 0x12c0
  TCD23_SADDR @offset 0x12e0
  TCD24_SADDR @offset 0x1300
  TCD25_SADDR @offset 0x1320
  TCD26_SADDR @offset 0x1340
  TCD27_SADDR @offset 0x1360
  TCD28_SADDR @offset 0x1380
  TCD29_SADDR @offset 0x13a0
  TCD30_SADDR @offset 0x13c0
  TCD31_SADDR @offset 0x13e0 $u32 {
    SADDR:32 // at 0: Source Address
  }

//---  Registers TCD_SOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Source Address Offset
  TCD_SOFF [32 @offset 0x1004 @inc 0x20]
  TCD0_SOFF @offset 0x1004
  TCD1_SOFF @offset 0x1024
  TCD2_SOFF @offset 0x1044
  TCD3_SOFF @offset 0x1064
  TCD4_SOFF @offset 0x1084
  TCD5_SOFF @offset 0x10a4
  TCD6_SOFF @offset 0x10c4
  TCD7_SOFF @offset 0x10e4
  TCD8_SOFF @offset 0x1104
  TCD9_SOFF @offset 0x1124
  TCD10_SOFF @offset 0x1144
  TCD11_SOFF @offset 0x1164
  TCD12_SOFF @offset 0x1184
  TCD13_SOFF @offset 0x11a4
  TCD14_SOFF @offset 0x11c4
  TCD15_SOFF @offset 0x11e4
  TCD16_SOFF @offset 0x1204
  TCD17_SOFF @offset 0x1224
  TCD18_SOFF @offset 0x1244
  TCD19_SOFF @offset 0x1264
  TCD20_SOFF @offset 0x1284
  TCD21_SOFF @offset 0x12a4
  TCD22_SOFF @offset 0x12c4
  TCD23_SOFF @offset 0x12e4
  TCD24_SOFF @offset 0x1304
  TCD25_SOFF @offset 0x1324
  TCD26_SOFF @offset 0x1344
  TCD27_SOFF @offset 0x1364
  TCD28_SOFF @offset 0x1384
  TCD29_SOFF @offset 0x13a4
  TCD30_SOFF @offset 0x13c4
  TCD31_SOFF @offset 0x13e4 $u16 {
    SOFF:16 // at 0: Source address signed offset
  }

//---  Registers TCD_ATTR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Transfer Attributes
  TCD_ATTR [32 @offset 0x1006 @inc 0x20]
  TCD0_ATTR @offset 0x1006
  TCD1_ATTR @offset 0x1026
  TCD2_ATTR @offset 0x1046
  TCD3_ATTR @offset 0x1066
  TCD4_ATTR @offset 0x1086
  TCD5_ATTR @offset 0x10a6
  TCD6_ATTR @offset 0x10c6
  TCD7_ATTR @offset 0x10e6
  TCD8_ATTR @offset 0x1106
  TCD9_ATTR @offset 0x1126
  TCD10_ATTR @offset 0x1146
  TCD11_ATTR @offset 0x1166
  TCD12_ATTR @offset 0x1186
  TCD13_ATTR @offset 0x11a6
  TCD14_ATTR @offset 0x11c6
  TCD15_ATTR @offset 0x11e6
  TCD16_ATTR @offset 0x1206
  TCD17_ATTR @offset 0x1226
  TCD18_ATTR @offset 0x1246
  TCD19_ATTR @offset 0x1266
  TCD20_ATTR @offset 0x1286
  TCD21_ATTR @offset 0x12a6
  TCD22_ATTR @offset 0x12c6
  TCD23_ATTR @offset 0x12e6
  TCD24_ATTR @offset 0x1306
  TCD25_ATTR @offset 0x1326
  TCD26_ATTR @offset 0x1346
  TCD27_ATTR @offset 0x1366
  TCD28_ATTR @offset 0x1386
  TCD29_ATTR @offset 0x13a6
  TCD30_ATTR @offset 0x13c6
  TCD31_ATTR @offset 0x13e6 $u16 {
    SMOD:5 // at 11: Source Address Modulo
    SSIZE:3 // at 8: Source data transfer size
    DMOD:5 // at 3: Destination Address Modulo
    DSIZE:3 // at 0: Destination data transfer size
  }

//---  Registers TCD_NBYTES_MLNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Minor Byte Count (Minor Loop Mapping Disabled)
  TCD_NBYTES_MLNO [32 @offset 0x1008 @inc 0x20]
  TCD0_NBYTES_MLNO @offset 0x1008
  TCD1_NBYTES_MLNO @offset 0x1028
  TCD2_NBYTES_MLNO @offset 0x1048
  TCD3_NBYTES_MLNO @offset 0x1068
  TCD4_NBYTES_MLNO @offset 0x1088
  TCD5_NBYTES_MLNO @offset 0x10a8
  TCD6_NBYTES_MLNO @offset 0x10c8
  TCD7_NBYTES_MLNO @offset 0x10e8
  TCD8_NBYTES_MLNO @offset 0x1108
  TCD9_NBYTES_MLNO @offset 0x1128
  TCD10_NBYTES_MLNO @offset 0x1148
  TCD11_NBYTES_MLNO @offset 0x1168
  TCD12_NBYTES_MLNO @offset 0x1188
  TCD13_NBYTES_MLNO @offset 0x11a8
  TCD14_NBYTES_MLNO @offset 0x11c8
  TCD15_NBYTES_MLNO @offset 0x11e8
  TCD16_NBYTES_MLNO @offset 0x1208
  TCD17_NBYTES_MLNO @offset 0x1228
  TCD18_NBYTES_MLNO @offset 0x1248
  TCD19_NBYTES_MLNO @offset 0x1268
  TCD20_NBYTES_MLNO @offset 0x1288
  TCD21_NBYTES_MLNO @offset 0x12a8
  TCD22_NBYTES_MLNO @offset 0x12c8
  TCD23_NBYTES_MLNO @offset 0x12e8
  TCD24_NBYTES_MLNO @offset 0x1308
  TCD25_NBYTES_MLNO @offset 0x1328
  TCD26_NBYTES_MLNO @offset 0x1348
  TCD27_NBYTES_MLNO @offset 0x1368
  TCD28_NBYTES_MLNO @offset 0x1388
  TCD29_NBYTES_MLNO @offset 0x13a8
  TCD30_NBYTES_MLNO @offset 0x13c8
  TCD31_NBYTES_MLNO @offset 0x13e8 $u32 {
    NBYTES:32 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_NBYTES_MLOFFNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
  TCD_NBYTES_MLOFFNO [32 @offset 0x1008 @inc 0x20]
  TCD0_NBYTES_MLOFFNO @offset 0x1008
  TCD1_NBYTES_MLOFFNO @offset 0x1028
  TCD2_NBYTES_MLOFFNO @offset 0x1048
  TCD3_NBYTES_MLOFFNO @offset 0x1068
  TCD4_NBYTES_MLOFFNO @offset 0x1088
  TCD5_NBYTES_MLOFFNO @offset 0x10a8
  TCD6_NBYTES_MLOFFNO @offset 0x10c8
  TCD7_NBYTES_MLOFFNO @offset 0x10e8
  TCD8_NBYTES_MLOFFNO @offset 0x1108
  TCD9_NBYTES_MLOFFNO @offset 0x1128
  TCD10_NBYTES_MLOFFNO @offset 0x1148
  TCD11_NBYTES_MLOFFNO @offset 0x1168
  TCD12_NBYTES_MLOFFNO @offset 0x1188
  TCD13_NBYTES_MLOFFNO @offset 0x11a8
  TCD14_NBYTES_MLOFFNO @offset 0x11c8
  TCD15_NBYTES_MLOFFNO @offset 0x11e8
  TCD16_NBYTES_MLOFFNO @offset 0x1208
  TCD17_NBYTES_MLOFFNO @offset 0x1228
  TCD18_NBYTES_MLOFFNO @offset 0x1248
  TCD19_NBYTES_MLOFFNO @offset 0x1268
  TCD20_NBYTES_MLOFFNO @offset 0x1288
  TCD21_NBYTES_MLOFFNO @offset 0x12a8
  TCD22_NBYTES_MLOFFNO @offset 0x12c8
  TCD23_NBYTES_MLOFFNO @offset 0x12e8
  TCD24_NBYTES_MLOFFNO @offset 0x1308
  TCD25_NBYTES_MLOFFNO @offset 0x1328
  TCD26_NBYTES_MLOFFNO @offset 0x1348
  TCD27_NBYTES_MLOFFNO @offset 0x1368
  TCD28_NBYTES_MLOFFNO @offset 0x1388
  TCD29_NBYTES_MLOFFNO @offset 0x13a8
  TCD30_NBYTES_MLOFFNO @offset 0x13c8
  TCD31_NBYTES_MLOFFNO @offset 0x13e8 $u32 {
    SMLOE // at 31: Source Minor Loop Offset Enable
    DMLOE // at 30: Destination Minor Loop Offset enable
    NBYTES:30 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_NBYTES_MLOFFYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
  TCD_NBYTES_MLOFFYES [32 @offset 0x1008 @inc 0x20]
  TCD0_NBYTES_MLOFFYES @offset 0x1008
  TCD1_NBYTES_MLOFFYES @offset 0x1028
  TCD2_NBYTES_MLOFFYES @offset 0x1048
  TCD3_NBYTES_MLOFFYES @offset 0x1068
  TCD4_NBYTES_MLOFFYES @offset 0x1088
  TCD5_NBYTES_MLOFFYES @offset 0x10a8
  TCD6_NBYTES_MLOFFYES @offset 0x10c8
  TCD7_NBYTES_MLOFFYES @offset 0x10e8
  TCD8_NBYTES_MLOFFYES @offset 0x1108
  TCD9_NBYTES_MLOFFYES @offset 0x1128
  TCD10_NBYTES_MLOFFYES @offset 0x1148
  TCD11_NBYTES_MLOFFYES @offset 0x1168
  TCD12_NBYTES_MLOFFYES @offset 0x1188
  TCD13_NBYTES_MLOFFYES @offset 0x11a8
  TCD14_NBYTES_MLOFFYES @offset 0x11c8
  TCD15_NBYTES_MLOFFYES @offset 0x11e8
  TCD16_NBYTES_MLOFFYES @offset 0x1208
  TCD17_NBYTES_MLOFFYES @offset 0x1228
  TCD18_NBYTES_MLOFFYES @offset 0x1248
  TCD19_NBYTES_MLOFFYES @offset 0x1268
  TCD20_NBYTES_MLOFFYES @offset 0x1288
  TCD21_NBYTES_MLOFFYES @offset 0x12a8
  TCD22_NBYTES_MLOFFYES @offset 0x12c8
  TCD23_NBYTES_MLOFFYES @offset 0x12e8
  TCD24_NBYTES_MLOFFYES @offset 0x1308
  TCD25_NBYTES_MLOFFYES @offset 0x1328
  TCD26_NBYTES_MLOFFYES @offset 0x1348
  TCD27_NBYTES_MLOFFYES @offset 0x1368
  TCD28_NBYTES_MLOFFYES @offset 0x1388
  TCD29_NBYTES_MLOFFYES @offset 0x13a8
  TCD30_NBYTES_MLOFFYES @offset 0x13c8
  TCD31_NBYTES_MLOFFYES @offset 0x13e8 $u32 {
    SMLOE // at 31: Source Minor Loop Offset Enable
    DMLOE // at 30: Destination Minor Loop Offset enable
    MLOFF:20 // at 10: If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
    NBYTES:10 // at 0: Minor Byte Transfer Count
  }

//---  Registers TCD_SLAST(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Last Source Address Adjustment
  TCD_SLAST [32 @offset 0x100c @inc 0x20]
  TCD0_SLAST @offset 0x100c
  TCD1_SLAST @offset 0x102c
  TCD2_SLAST @offset 0x104c
  TCD3_SLAST @offset 0x106c
  TCD4_SLAST @offset 0x108c
  TCD5_SLAST @offset 0x10ac
  TCD6_SLAST @offset 0x10cc
  TCD7_SLAST @offset 0x10ec
  TCD8_SLAST @offset 0x110c
  TCD9_SLAST @offset 0x112c
  TCD10_SLAST @offset 0x114c
  TCD11_SLAST @offset 0x116c
  TCD12_SLAST @offset 0x118c
  TCD13_SLAST @offset 0x11ac
  TCD14_SLAST @offset 0x11cc
  TCD15_SLAST @offset 0x11ec
  TCD16_SLAST @offset 0x120c
  TCD17_SLAST @offset 0x122c
  TCD18_SLAST @offset 0x124c
  TCD19_SLAST @offset 0x126c
  TCD20_SLAST @offset 0x128c
  TCD21_SLAST @offset 0x12ac
  TCD22_SLAST @offset 0x12cc
  TCD23_SLAST @offset 0x12ec
  TCD24_SLAST @offset 0x130c
  TCD25_SLAST @offset 0x132c
  TCD26_SLAST @offset 0x134c
  TCD27_SLAST @offset 0x136c
  TCD28_SLAST @offset 0x138c
  TCD29_SLAST @offset 0x13ac
  TCD30_SLAST @offset 0x13cc
  TCD31_SLAST @offset 0x13ec $u32 {
    SLAST:32 // at 0: Last Source Address Adjustment
  }

//---  Registers TCD_DADDR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Destination Address
  TCD_DADDR [32 @offset 0x1010 @inc 0x20]
  TCD0_DADDR @offset 0x1010
  TCD1_DADDR @offset 0x1030
  TCD2_DADDR @offset 0x1050
  TCD3_DADDR @offset 0x1070
  TCD4_DADDR @offset 0x1090
  TCD5_DADDR @offset 0x10b0
  TCD6_DADDR @offset 0x10d0
  TCD7_DADDR @offset 0x10f0
  TCD8_DADDR @offset 0x1110
  TCD9_DADDR @offset 0x1130
  TCD10_DADDR @offset 0x1150
  TCD11_DADDR @offset 0x1170
  TCD12_DADDR @offset 0x1190
  TCD13_DADDR @offset 0x11b0
  TCD14_DADDR @offset 0x11d0
  TCD15_DADDR @offset 0x11f0
  TCD16_DADDR @offset 0x1210
  TCD17_DADDR @offset 0x1230
  TCD18_DADDR @offset 0x1250
  TCD19_DADDR @offset 0x1270
  TCD20_DADDR @offset 0x1290
  TCD21_DADDR @offset 0x12b0
  TCD22_DADDR @offset 0x12d0
  TCD23_DADDR @offset 0x12f0
  TCD24_DADDR @offset 0x1310
  TCD25_DADDR @offset 0x1330
  TCD26_DADDR @offset 0x1350
  TCD27_DADDR @offset 0x1370
  TCD28_DADDR @offset 0x1390
  TCD29_DADDR @offset 0x13b0
  TCD30_DADDR @offset 0x13d0
  TCD31_DADDR @offset 0x13f0 $u32 {
    DADDR:32 // at 0: Destination Address
  }

//---  Registers TCD_DOFF(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Signed Destination Address Offset
  TCD_DOFF [32 @offset 0x1014 @inc 0x20]
  TCD0_DOFF @offset 0x1014
  TCD1_DOFF @offset 0x1034
  TCD2_DOFF @offset 0x1054
  TCD3_DOFF @offset 0x1074
  TCD4_DOFF @offset 0x1094
  TCD5_DOFF @offset 0x10b4
  TCD6_DOFF @offset 0x10d4
  TCD7_DOFF @offset 0x10f4
  TCD8_DOFF @offset 0x1114
  TCD9_DOFF @offset 0x1134
  TCD10_DOFF @offset 0x1154
  TCD11_DOFF @offset 0x1174
  TCD12_DOFF @offset 0x1194
  TCD13_DOFF @offset 0x11b4
  TCD14_DOFF @offset 0x11d4
  TCD15_DOFF @offset 0x11f4
  TCD16_DOFF @offset 0x1214
  TCD17_DOFF @offset 0x1234
  TCD18_DOFF @offset 0x1254
  TCD19_DOFF @offset 0x1274
  TCD20_DOFF @offset 0x1294
  TCD21_DOFF @offset 0x12b4
  TCD22_DOFF @offset 0x12d4
  TCD23_DOFF @offset 0x12f4
  TCD24_DOFF @offset 0x1314
  TCD25_DOFF @offset 0x1334
  TCD26_DOFF @offset 0x1354
  TCD27_DOFF @offset 0x1374
  TCD28_DOFF @offset 0x1394
  TCD29_DOFF @offset 0x13b4
  TCD30_DOFF @offset 0x13d4
  TCD31_DOFF @offset 0x13f4 $u16 {
    DOFF:16 // at 0: Destination Address Signed Offset
  }

//---  Registers TCD_CITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  TCD_CITER_ELINKNO [32 @offset 0x1016 @inc 0x20]
  TCD0_CITER_ELINKNO @offset 0x1016
  TCD1_CITER_ELINKNO @offset 0x1036
  TCD2_CITER_ELINKNO @offset 0x1056
  TCD3_CITER_ELINKNO @offset 0x1076
  TCD4_CITER_ELINKNO @offset 0x1096
  TCD5_CITER_ELINKNO @offset 0x10b6
  TCD6_CITER_ELINKNO @offset 0x10d6
  TCD7_CITER_ELINKNO @offset 0x10f6
  TCD8_CITER_ELINKNO @offset 0x1116
  TCD9_CITER_ELINKNO @offset 0x1136
  TCD10_CITER_ELINKNO @offset 0x1156
  TCD11_CITER_ELINKNO @offset 0x1176
  TCD12_CITER_ELINKNO @offset 0x1196
  TCD13_CITER_ELINKNO @offset 0x11b6
  TCD14_CITER_ELINKNO @offset 0x11d6
  TCD15_CITER_ELINKNO @offset 0x11f6
  TCD16_CITER_ELINKNO @offset 0x1216
  TCD17_CITER_ELINKNO @offset 0x1236
  TCD18_CITER_ELINKNO @offset 0x1256
  TCD19_CITER_ELINKNO @offset 0x1276
  TCD20_CITER_ELINKNO @offset 0x1296
  TCD21_CITER_ELINKNO @offset 0x12b6
  TCD22_CITER_ELINKNO @offset 0x12d6
  TCD23_CITER_ELINKNO @offset 0x12f6
  TCD24_CITER_ELINKNO @offset 0x1316
  TCD25_CITER_ELINKNO @offset 0x1336
  TCD26_CITER_ELINKNO @offset 0x1356
  TCD27_CITER_ELINKNO @offset 0x1376
  TCD28_CITER_ELINKNO @offset 0x1396
  TCD29_CITER_ELINKNO @offset 0x13b6
  TCD30_CITER_ELINKNO @offset 0x13d6
  TCD31_CITER_ELINKNO @offset 0x13f6 $u16 {
    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete
    CITER:15 // at 0: Current Major Iteration Count
  }

//---  Registers TCD_CITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
  TCD_CITER_ELINKYES [32 @offset 0x1016 @inc 0x20]
  TCD0_CITER_ELINKYES @offset 0x1016
  TCD1_CITER_ELINKYES @offset 0x1036
  TCD2_CITER_ELINKYES @offset 0x1056
  TCD3_CITER_ELINKYES @offset 0x1076
  TCD4_CITER_ELINKYES @offset 0x1096
  TCD5_CITER_ELINKYES @offset 0x10b6
  TCD6_CITER_ELINKYES @offset 0x10d6
  TCD7_CITER_ELINKYES @offset 0x10f6
  TCD8_CITER_ELINKYES @offset 0x1116
  TCD9_CITER_ELINKYES @offset 0x1136
  TCD10_CITER_ELINKYES @offset 0x1156
  TCD11_CITER_ELINKYES @offset 0x1176
  TCD12_CITER_ELINKYES @offset 0x1196
  TCD13_CITER_ELINKYES @offset 0x11b6
  TCD14_CITER_ELINKYES @offset 0x11d6
  TCD15_CITER_ELINKYES @offset 0x11f6
  TCD16_CITER_ELINKYES @offset 0x1216
  TCD17_CITER_ELINKYES @offset 0x1236
  TCD18_CITER_ELINKYES @offset 0x1256
  TCD19_CITER_ELINKYES @offset 0x1276
  TCD20_CITER_ELINKYES @offset 0x1296
  TCD21_CITER_ELINKYES @offset 0x12b6
  TCD22_CITER_ELINKYES @offset 0x12d6
  TCD23_CITER_ELINKYES @offset 0x12f6
  TCD24_CITER_ELINKYES @offset 0x1316
  TCD25_CITER_ELINKYES @offset 0x1336
  TCD26_CITER_ELINKYES @offset 0x1356
  TCD27_CITER_ELINKYES @offset 0x1376
  TCD28_CITER_ELINKYES @offset 0x1396
  TCD29_CITER_ELINKYES @offset 0x13b6
  TCD30_CITER_ELINKYES @offset 0x13d6
  TCD31_CITER_ELINKYES @offset 0x13f6 $u16 {
    ELINK // at 15: Enable channel-to-channel linking on minor-loop complete
    1
    LINKCH:5 // at 9: Minor Loop Link Channel Number
    CITER:9 // at 0: Current Major Iteration Count
  }

//---  Registers TCD_DLASTSGA(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Last Destination Address Adjustment/Scatter Gather Address
  TCD_DLASTSGA [32 @offset 0x1018 @inc 0x20]
  TCD0_DLASTSGA @offset 0x1018
  TCD1_DLASTSGA @offset 0x1038
  TCD2_DLASTSGA @offset 0x1058
  TCD3_DLASTSGA @offset 0x1078
  TCD4_DLASTSGA @offset 0x1098
  TCD5_DLASTSGA @offset 0x10b8
  TCD6_DLASTSGA @offset 0x10d8
  TCD7_DLASTSGA @offset 0x10f8
  TCD8_DLASTSGA @offset 0x1118
  TCD9_DLASTSGA @offset 0x1138
  TCD10_DLASTSGA @offset 0x1158
  TCD11_DLASTSGA @offset 0x1178
  TCD12_DLASTSGA @offset 0x1198
  TCD13_DLASTSGA @offset 0x11b8
  TCD14_DLASTSGA @offset 0x11d8
  TCD15_DLASTSGA @offset 0x11f8
  TCD16_DLASTSGA @offset 0x1218
  TCD17_DLASTSGA @offset 0x1238
  TCD18_DLASTSGA @offset 0x1258
  TCD19_DLASTSGA @offset 0x1278
  TCD20_DLASTSGA @offset 0x1298
  TCD21_DLASTSGA @offset 0x12b8
  TCD22_DLASTSGA @offset 0x12d8
  TCD23_DLASTSGA @offset 0x12f8
  TCD24_DLASTSGA @offset 0x1318
  TCD25_DLASTSGA @offset 0x1338
  TCD26_DLASTSGA @offset 0x1358
  TCD27_DLASTSGA @offset 0x1378
  TCD28_DLASTSGA @offset 0x1398
  TCD29_DLASTSGA @offset 0x13b8
  TCD30_DLASTSGA @offset 0x13d8
  TCD31_DLASTSGA @offset 0x13f8 $u32 {
    DLASTSGA:32 // at 0: Destination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather)
  }

//---  Registers TCD_CSR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Control and Status
  TCD_CSR [32 @offset 0x101c @inc 0x20]
  TCD0_CSR @offset 0x101c
  TCD1_CSR @offset 0x103c
  TCD2_CSR @offset 0x105c
  TCD3_CSR @offset 0x107c
  TCD4_CSR @offset 0x109c
  TCD5_CSR @offset 0x10bc
  TCD6_CSR @offset 0x10dc
  TCD7_CSR @offset 0x10fc
  TCD8_CSR @offset 0x111c
  TCD9_CSR @offset 0x113c
  TCD10_CSR @offset 0x115c
  TCD11_CSR @offset 0x117c
  TCD12_CSR @offset 0x119c
  TCD13_CSR @offset 0x11bc
  TCD14_CSR @offset 0x11dc
  TCD15_CSR @offset 0x11fc
  TCD16_CSR @offset 0x121c
  TCD17_CSR @offset 0x123c
  TCD18_CSR @offset 0x125c
  TCD19_CSR @offset 0x127c
  TCD20_CSR @offset 0x129c
  TCD21_CSR @offset 0x12bc
  TCD22_CSR @offset 0x12dc
  TCD23_CSR @offset 0x12fc
  TCD24_CSR @offset 0x131c
  TCD25_CSR @offset 0x133c
  TCD26_CSR @offset 0x135c
  TCD27_CSR @offset 0x137c
  TCD28_CSR @offset 0x139c
  TCD29_CSR @offset 0x13bc
  TCD30_CSR @offset 0x13dc
  TCD31_CSR @offset 0x13fc $u16 {
    BWC:2 // at 14: Bandwidth Control
    1
    MAJORLINKCH:5 // at 8: Major Loop Link Channel Number
    DONE // at 7: Channel Done
    ACTIVE // at 6: Channel Active
    MAJORELINK // at 5: Enable channel-to-channel linking on major loop complete
    ESG // at 4: Enable Scatter/Gather Processing
    DREQ // at 3: Disable Request
    INTHALF // at 2: Enable an interrupt when major counter is half complete.
    INTMAJOR // at 1: Enable an interrupt when major iteration count completes.
    START // at 0: Channel Start
  }

//---  Registers TCD_BITER_ELINKNO(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  TCD_BITER_ELINKNO [32 @offset 0x101e @inc 0x20]
  TCD0_BITER_ELINKNO @offset 0x101e
  TCD1_BITER_ELINKNO @offset 0x103e
  TCD2_BITER_ELINKNO @offset 0x105e
  TCD3_BITER_ELINKNO @offset 0x107e
  TCD4_BITER_ELINKNO @offset 0x109e
  TCD5_BITER_ELINKNO @offset 0x10be
  TCD6_BITER_ELINKNO @offset 0x10de
  TCD7_BITER_ELINKNO @offset 0x10fe
  TCD8_BITER_ELINKNO @offset 0x111e
  TCD9_BITER_ELINKNO @offset 0x113e
  TCD10_BITER_ELINKNO @offset 0x115e
  TCD11_BITER_ELINKNO @offset 0x117e
  TCD12_BITER_ELINKNO @offset 0x119e
  TCD13_BITER_ELINKNO @offset 0x11be
  TCD14_BITER_ELINKNO @offset 0x11de
  TCD15_BITER_ELINKNO @offset 0x11fe
  TCD16_BITER_ELINKNO @offset 0x121e
  TCD17_BITER_ELINKNO @offset 0x123e
  TCD18_BITER_ELINKNO @offset 0x125e
  TCD19_BITER_ELINKNO @offset 0x127e
  TCD20_BITER_ELINKNO @offset 0x129e
  TCD21_BITER_ELINKNO @offset 0x12be
  TCD22_BITER_ELINKNO @offset 0x12de
  TCD23_BITER_ELINKNO @offset 0x12fe
  TCD24_BITER_ELINKNO @offset 0x131e
  TCD25_BITER_ELINKNO @offset 0x133e
  TCD26_BITER_ELINKNO @offset 0x135e
  TCD27_BITER_ELINKNO @offset 0x137e
  TCD28_BITER_ELINKNO @offset 0x139e
  TCD29_BITER_ELINKNO @offset 0x13be
  TCD30_BITER_ELINKNO @offset 0x13de
  TCD31_BITER_ELINKNO @offset 0x13fe $u16 {
    ELINK // at 15: Enables channel-to-channel linking on minor loop complete
    BITER:15 // at 0: Starting Major Iteration Count
  }

//---  Registers TCD_BITER_ELINKYES(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
  TCD_BITER_ELINKYES [32 @offset 0x101e @inc 0x20]
  TCD0_BITER_ELINKYES @offset 0x101e
  TCD1_BITER_ELINKYES @offset 0x103e
  TCD2_BITER_ELINKYES @offset 0x105e
  TCD3_BITER_ELINKYES @offset 0x107e
  TCD4_BITER_ELINKYES @offset 0x109e
  TCD5_BITER_ELINKYES @offset 0x10be
  TCD6_BITER_ELINKYES @offset 0x10de
  TCD7_BITER_ELINKYES @offset 0x10fe
  TCD8_BITER_ELINKYES @offset 0x111e
  TCD9_BITER_ELINKYES @offset 0x113e
  TCD10_BITER_ELINKYES @offset 0x115e
  TCD11_BITER_ELINKYES @offset 0x117e
  TCD12_BITER_ELINKYES @offset 0x119e
  TCD13_BITER_ELINKYES @offset 0x11be
  TCD14_BITER_ELINKYES @offset 0x11de
  TCD15_BITER_ELINKYES @offset 0x11fe
  TCD16_BITER_ELINKYES @offset 0x121e
  TCD17_BITER_ELINKYES @offset 0x123e
  TCD18_BITER_ELINKYES @offset 0x125e
  TCD19_BITER_ELINKYES @offset 0x127e
  TCD20_BITER_ELINKYES @offset 0x129e
  TCD21_BITER_ELINKYES @offset 0x12be
  TCD22_BITER_ELINKYES @offset 0x12de
  TCD23_BITER_ELINKYES @offset 0x12fe
  TCD24_BITER_ELINKYES @offset 0x131e
  TCD25_BITER_ELINKYES @offset 0x133e
  TCD26_BITER_ELINKYES @offset 0x135e
  TCD27_BITER_ELINKYES @offset 0x137e
  TCD28_BITER_ELINKYES @offset 0x139e
  TCD29_BITER_ELINKYES @offset 0x13be
  TCD30_BITER_ELINKYES @offset 0x13de
  TCD31_BITER_ELINKYES @offset 0x13fe $u16 {
    ELINK // at 15: Enables channel-to-channel linking on minor loop complete
    1
    LINKCH:5 // at 9: Link Channel Number
    BITER:9 // at 0: Starting major iteration count
  }

}

//--- Enumerated values for register CR, field EDBG
  let DMA_CR_EDBG_When_0 $bool = no // When in debug mode, the DMA continues to operate.
  let DMA_CR_EDBG_When_1 $bool = yes // When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.

//--- Enumerated values for register CR, field ERCA
  let DMA_CR_ERCA_Fixed_0 $bool = no // Fixed priority arbitration is used for channel selection within each group.
  let DMA_CR_ERCA_Round_1 $bool = yes // Round robin arbitration is used for channel selection within each group.

//--- Enumerated values for register CR, field ERGA
  let DMA_CR_ERGA_Fixed_0 $bool = no // Fixed priority arbitration is used for selection among the groups.
  let DMA_CR_ERGA_Round_1 $bool = yes // Round robin arbitration is used for selection among the groups.

//--- Enumerated values for register CR, field HOE
  let DMA_CR_HOE_Normal_0 $bool = no // Normal operation
  let DMA_CR_HOE_Any_1 $bool = yes // Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.

//--- Enumerated values for register CR, field HALT
  let DMA_CR_HALT_Normal_0 $bool = no // Normal operation
  let DMA_CR_HALT_Stall_1 $bool = yes // Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.

//--- Enumerated values for register CR, field CLM
  let DMA_CR_CLM_A_0 $bool = no // A minor loop channel link made to itself goes through channel arbitration before being activated again.
  let DMA_CR_CLM_A_1 $bool = yes // A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.

//--- Enumerated values for register CR, field EMLM
  let DMA_CR_EMLM_Disabled__0 $bool = no // Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
  let DMA_CR_EMLM_Enabled__1 $bool = yes // Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.

//--- Enumerated values for register CR, field ECX
  let DMA_CR_ECX_Normal_0 $bool = no // Normal operation
  let DMA_CR_ECX_Cancel_1 $bool = yes // Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.

//--- Enumerated values for register CR, field CX
  let DMA_CR_CX_Normal_0 $bool = no // Normal operation
  let DMA_CR_CX_Cancel_1 $bool = yes // Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.

//--- Enumerated values for register ES, field DBE
  let DMA_ES_DBE_No_0 $bool = no // No destination bus error
  let DMA_ES_DBE_The_1 $bool = yes // The last recorded error was a bus error on a destination write

//--- Enumerated values for register ES, field SBE
  let DMA_ES_SBE_No_0 $bool = no // No source bus error
  let DMA_ES_SBE_The_1 $bool = yes // The last recorded error was a bus error on a source read

//--- Enumerated values for register ES, field SGE
  let DMA_ES_SGE_No_0 $bool = no // No scatter/gather configuration error
  let DMA_ES_SGE_The_1 $bool = yes // The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.

//--- Enumerated values for register ES, field NCE
  let DMA_ES_NCE_No_0 $bool = no // No NBYTES/CITER configuration error
  let DMA_ES_NCE_The_1 $bool = yes // The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]

//--- Enumerated values for register ES, field DOE
  let DMA_ES_DOE_No_0 $bool = no // No destination offset configuration error
  let DMA_ES_DOE_The_1 $bool = yes // The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].

//--- Enumerated values for register ES, field DAE
  let DMA_ES_DAE_No_0 $bool = no // No destination address configuration error
  let DMA_ES_DAE_The_1 $bool = yes // The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].

//--- Enumerated values for register ES, field SOE
  let DMA_ES_SOE_No_0 $bool = no // No source offset configuration error
  let DMA_ES_SOE_The_1 $bool = yes // The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].

//--- Enumerated values for register ES, field SAE
  let DMA_ES_SAE_No_0 $bool = no // No source address configuration error.
  let DMA_ES_SAE_The_1 $bool = yes // The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].

//--- Enumerated values for register ES, field CPE
  let DMA_ES_CPE_No_0 $bool = no // No channel priority error
  let DMA_ES_CPE_The_1 $bool = yes // The last recorded error was a configuration error in the channel priorities within a group. Channel priorities within a group are not unique.

//--- Enumerated values for register ES, field GPE
  let DMA_ES_GPE_No_0 $bool = no // No group priority error
  let DMA_ES_GPE_The_1 $bool = yes // The last recorded error was a configuration error among the group priorities. All group priorities are not unique.

//--- Enumerated values for register ES, field ECX
  let DMA_ES_ECX_No_0 $bool = no // No canceled transfers
  let DMA_ES_ECX_The_1 $bool = yes // The last recorded entry was a canceled transfer by the error cancel transfer input

//--- Enumerated values for register ES, field VLD
  let DMA_ES_VLD_No_0 $bool = no // No ERR bits are set.
  let DMA_ES_VLD_At_1 $bool = yes // At least one ERR bit is set indicating a valid error exists that has not been cleared.

//--- Enumerated values for register ERQ, field ERQ0
  let DMA_ERQ_ERQ0_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ0_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ1
  let DMA_ERQ_ERQ1_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ1_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ2
  let DMA_ERQ_ERQ2_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ2_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ3
  let DMA_ERQ_ERQ3_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ3_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ4
  let DMA_ERQ_ERQ4_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ4_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ5
  let DMA_ERQ_ERQ5_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ5_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ6
  let DMA_ERQ_ERQ6_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ6_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ7
  let DMA_ERQ_ERQ7_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ7_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ8
  let DMA_ERQ_ERQ8_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ8_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ9
  let DMA_ERQ_ERQ9_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ9_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ10
  let DMA_ERQ_ERQ10_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ10_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ11
  let DMA_ERQ_ERQ11_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ11_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ12
  let DMA_ERQ_ERQ12_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ12_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ13
  let DMA_ERQ_ERQ13_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ13_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ14
  let DMA_ERQ_ERQ14_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ14_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ15
  let DMA_ERQ_ERQ15_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ15_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ16
  let DMA_ERQ_ERQ16_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ16_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ17
  let DMA_ERQ_ERQ17_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ17_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ18
  let DMA_ERQ_ERQ18_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ18_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ19
  let DMA_ERQ_ERQ19_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ19_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ20
  let DMA_ERQ_ERQ20_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ20_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ21
  let DMA_ERQ_ERQ21_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ21_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ22
  let DMA_ERQ_ERQ22_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ22_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ23
  let DMA_ERQ_ERQ23_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ23_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ24
  let DMA_ERQ_ERQ24_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ24_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ25
  let DMA_ERQ_ERQ25_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ25_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ26
  let DMA_ERQ_ERQ26_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ26_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ27
  let DMA_ERQ_ERQ27_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ27_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ28
  let DMA_ERQ_ERQ28_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ28_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ29
  let DMA_ERQ_ERQ29_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ29_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ30
  let DMA_ERQ_ERQ30_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ30_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register ERQ, field ERQ31
  let DMA_ERQ_ERQ31_The_0 $bool = no // The DMA request signal for the corresponding channel is disabled
  let DMA_ERQ_ERQ31_The_1 $bool = yes // The DMA request signal for the corresponding channel is enabled

//--- Enumerated values for register EEI, field EEI0
  let DMA_EEI_EEI0_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI0_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI1
  let DMA_EEI_EEI1_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI1_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI2
  let DMA_EEI_EEI2_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI2_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI3
  let DMA_EEI_EEI3_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI3_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI4
  let DMA_EEI_EEI4_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI4_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI5
  let DMA_EEI_EEI5_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI5_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI6
  let DMA_EEI_EEI6_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI6_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI7
  let DMA_EEI_EEI7_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI7_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI8
  let DMA_EEI_EEI8_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI8_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI9
  let DMA_EEI_EEI9_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI9_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI10
  let DMA_EEI_EEI10_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI10_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI11
  let DMA_EEI_EEI11_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI11_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI12
  let DMA_EEI_EEI12_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI12_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI13
  let DMA_EEI_EEI13_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI13_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI14
  let DMA_EEI_EEI14_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI14_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI15
  let DMA_EEI_EEI15_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI15_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI16
  let DMA_EEI_EEI16_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI16_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI17
  let DMA_EEI_EEI17_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI17_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI18
  let DMA_EEI_EEI18_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI18_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI19
  let DMA_EEI_EEI19_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI19_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI20
  let DMA_EEI_EEI20_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI20_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI21
  let DMA_EEI_EEI21_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI21_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI22
  let DMA_EEI_EEI22_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI22_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI23
  let DMA_EEI_EEI23_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI23_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI24
  let DMA_EEI_EEI24_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI24_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI25
  let DMA_EEI_EEI25_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI25_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI26
  let DMA_EEI_EEI26_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI26_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI27
  let DMA_EEI_EEI27_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI27_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI28
  let DMA_EEI_EEI28_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI28_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI29
  let DMA_EEI_EEI29_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI29_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI30
  let DMA_EEI_EEI30_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI30_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register EEI, field EEI31
  let DMA_EEI_EEI31_The_0 $bool = no // The error signal for corresponding channel does not generate an error interrupt
  let DMA_EEI_EEI31_The_1 $bool = yes // The assertion of the error signal for corresponding channel generates an error interrupt request

//--- Enumerated values for register CEEI, field CAEE
  let DMA_CEEI_CAEE_Clear_0 $bool = no // Clear only the EEI bit specified in the CEEI field
  let DMA_CEEI_CAEE_Clear_1 $bool = yes // Clear all bits in EEI

//--- Enumerated values for register CEEI, field NOP
  let DMA_CEEI_NOP_Normal_0 $bool = no // Normal operation
  let DMA_CEEI_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register SEEI, field SAEE
  let DMA_SEEI_SAEE_Set_0 $bool = no // Set only the EEI bit specified in the SEEI field.
  let DMA_SEEI_SAEE_Sets_1 $bool = yes // Sets all bits in EEI

//--- Enumerated values for register SEEI, field NOP
  let DMA_SEEI_NOP_Normal_0 $bool = no // Normal operation
  let DMA_SEEI_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register CERQ, field CAER
  let DMA_CERQ_CAER_Clear_0 $bool = no // Clear only the ERQ bit specified in the CERQ field
  let DMA_CERQ_CAER_Clear_1 $bool = yes // Clear all bits in ERQ

//--- Enumerated values for register CERQ, field NOP
  let DMA_CERQ_NOP_Normal_0 $bool = no // Normal operation
  let DMA_CERQ_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register SERQ, field SAER
  let DMA_SERQ_SAER_Set_0 $bool = no // Set only the ERQ bit specified in the SERQ field
  let DMA_SERQ_SAER_Set_1 $bool = yes // Set all bits in ERQ

//--- Enumerated values for register SERQ, field NOP
  let DMA_SERQ_NOP_Normal_0 $bool = no // Normal operation
  let DMA_SERQ_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register CDNE, field CADN
  let DMA_CDNE_CADN_Clears_0 $bool = no // Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
  let DMA_CDNE_CADN_Clears_1 $bool = yes // Clears all bits in TCDn_CSR[DONE]

//--- Enumerated values for register CDNE, field NOP
  let DMA_CDNE_NOP_Normal_0 $bool = no // Normal operation
  let DMA_CDNE_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register SSRT, field SAST
  let DMA_SSRT_SAST_Set_0 $bool = no // Set only the TCDn_CSR[START] bit specified in the SSRT field
  let DMA_SSRT_SAST_Set_1 $bool = yes // Set all bits in TCDn_CSR[START]

//--- Enumerated values for register SSRT, field NOP
  let DMA_SSRT_NOP_Normal_0 $bool = no // Normal operation
  let DMA_SSRT_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register CERR, field CAEI
  let DMA_CERR_CAEI_Clear_0 $bool = no // Clear only the ERR bit specified in the CERR field
  let DMA_CERR_CAEI_Clear_1 $bool = yes // Clear all bits in ERR

//--- Enumerated values for register CERR, field NOP
  let DMA_CERR_NOP_Normal_0 $bool = no // Normal operation
  let DMA_CERR_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register CINT, field CAIR
  let DMA_CINT_CAIR_Clear_0 $bool = no // Clear only the INT bit specified in the CINT field
  let DMA_CINT_CAIR_Clear_1 $bool = yes // Clear all bits in INT

//--- Enumerated values for register CINT, field NOP
  let DMA_CINT_NOP_Normal_0 $bool = no // Normal operation
  let DMA_CINT_NOP_No_1 $bool = yes // No operation, ignore the other bits in this register

//--- Enumerated values for register INT, field INT0
  let DMA_INT_INT0_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT0_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT1
  let DMA_INT_INT1_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT1_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT2
  let DMA_INT_INT2_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT2_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT3
  let DMA_INT_INT3_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT3_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT4
  let DMA_INT_INT4_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT4_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT5
  let DMA_INT_INT5_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT5_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT6
  let DMA_INT_INT6_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT6_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT7
  let DMA_INT_INT7_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT7_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT8
  let DMA_INT_INT8_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT8_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT9
  let DMA_INT_INT9_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT9_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT10
  let DMA_INT_INT10_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT10_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT11
  let DMA_INT_INT11_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT11_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT12
  let DMA_INT_INT12_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT12_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT13
  let DMA_INT_INT13_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT13_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT14
  let DMA_INT_INT14_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT14_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT15
  let DMA_INT_INT15_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT15_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT16
  let DMA_INT_INT16_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT16_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT17
  let DMA_INT_INT17_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT17_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT18
  let DMA_INT_INT18_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT18_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT19
  let DMA_INT_INT19_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT19_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT20
  let DMA_INT_INT20_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT20_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT21
  let DMA_INT_INT21_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT21_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT22
  let DMA_INT_INT22_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT22_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT23
  let DMA_INT_INT23_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT23_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT24
  let DMA_INT_INT24_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT24_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT25
  let DMA_INT_INT25_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT25_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT26
  let DMA_INT_INT26_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT26_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT27
  let DMA_INT_INT27_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT27_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT28
  let DMA_INT_INT28_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT28_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT29
  let DMA_INT_INT29_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT29_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT30
  let DMA_INT_INT30_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT30_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register INT, field INT31
  let DMA_INT_INT31_The_0 $bool = no // The interrupt request for corresponding channel is cleared
  let DMA_INT_INT31_The_1 $bool = yes // The interrupt request for corresponding channel is active

//--- Enumerated values for register ERR, field ERR0
  let DMA_ERR_ERR0_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR0_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR1
  let DMA_ERR_ERR1_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR1_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR2
  let DMA_ERR_ERR2_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR2_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR3
  let DMA_ERR_ERR3_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR3_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR4
  let DMA_ERR_ERR4_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR4_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR5
  let DMA_ERR_ERR5_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR5_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR6
  let DMA_ERR_ERR6_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR6_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR7
  let DMA_ERR_ERR7_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR7_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR8
  let DMA_ERR_ERR8_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR8_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR9
  let DMA_ERR_ERR9_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR9_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR10
  let DMA_ERR_ERR10_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR10_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR11
  let DMA_ERR_ERR11_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR11_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR12
  let DMA_ERR_ERR12_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR12_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR13
  let DMA_ERR_ERR13_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR13_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR14
  let DMA_ERR_ERR14_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR14_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR15
  let DMA_ERR_ERR15_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR15_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR16
  let DMA_ERR_ERR16_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR16_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR17
  let DMA_ERR_ERR17_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR17_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR18
  let DMA_ERR_ERR18_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR18_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR19
  let DMA_ERR_ERR19_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR19_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR20
  let DMA_ERR_ERR20_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR20_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR21
  let DMA_ERR_ERR21_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR21_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR22
  let DMA_ERR_ERR22_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR22_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR23
  let DMA_ERR_ERR23_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR23_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR24
  let DMA_ERR_ERR24_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR24_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR25
  let DMA_ERR_ERR25_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR25_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR26
  let DMA_ERR_ERR26_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR26_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR27
  let DMA_ERR_ERR27_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR27_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR28
  let DMA_ERR_ERR28_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR28_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR29
  let DMA_ERR_ERR29_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR29_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR30
  let DMA_ERR_ERR30_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR30_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register ERR, field ERR31
  let DMA_ERR_ERR31_An_0 $bool = no // An error in this channel has not occurred
  let DMA_ERR_ERR31_An_1 $bool = yes // An error in this channel has occurred

//--- Enumerated values for register HRS, field HRS0
  let DMA_HRS_HRS0_A_0 $bool = no // A hardware service request for channel 0 is not present
  let DMA_HRS_HRS0_A_1 $bool = yes // A hardware service request for channel 0 is present

//--- Enumerated values for register HRS, field HRS1
  let DMA_HRS_HRS1_A_0 $bool = no // A hardware service request for channel 1 is not present
  let DMA_HRS_HRS1_A_1 $bool = yes // A hardware service request for channel 1 is present

//--- Enumerated values for register HRS, field HRS2
  let DMA_HRS_HRS2_A_0 $bool = no // A hardware service request for channel 2 is not present
  let DMA_HRS_HRS2_A_1 $bool = yes // A hardware service request for channel 2 is present

//--- Enumerated values for register HRS, field HRS3
  let DMA_HRS_HRS3_A_0 $bool = no // A hardware service request for channel 3 is not present
  let DMA_HRS_HRS3_A_1 $bool = yes // A hardware service request for channel 3 is present

//--- Enumerated values for register HRS, field HRS4
  let DMA_HRS_HRS4_A_0 $bool = no // A hardware service request for channel 4 is not present
  let DMA_HRS_HRS4_A_1 $bool = yes // A hardware service request for channel 4 is present

//--- Enumerated values for register HRS, field HRS5
  let DMA_HRS_HRS5_A_0 $bool = no // A hardware service request for channel 5 is not present
  let DMA_HRS_HRS5_A_1 $bool = yes // A hardware service request for channel 5 is present

//--- Enumerated values for register HRS, field HRS6
  let DMA_HRS_HRS6_A_0 $bool = no // A hardware service request for channel 6 is not present
  let DMA_HRS_HRS6_A_1 $bool = yes // A hardware service request for channel 6 is present

//--- Enumerated values for register HRS, field HRS7
  let DMA_HRS_HRS7_A_0 $bool = no // A hardware service request for channel 7 is not present
  let DMA_HRS_HRS7_A_1 $bool = yes // A hardware service request for channel 7 is present

//--- Enumerated values for register HRS, field HRS8
  let DMA_HRS_HRS8_A_0 $bool = no // A hardware service request for channel 8 is not present
  let DMA_HRS_HRS8_A_1 $bool = yes // A hardware service request for channel 8 is present

//--- Enumerated values for register HRS, field HRS9
  let DMA_HRS_HRS9_A_0 $bool = no // A hardware service request for channel 9 is not present
  let DMA_HRS_HRS9_A_1 $bool = yes // A hardware service request for channel 9 is present

//--- Enumerated values for register HRS, field HRS10
  let DMA_HRS_HRS10_A_0 $bool = no // A hardware service request for channel 10 is not present
  let DMA_HRS_HRS10_A_1 $bool = yes // A hardware service request for channel 10 is present

//--- Enumerated values for register HRS, field HRS11
  let DMA_HRS_HRS11_A_0 $bool = no // A hardware service request for channel 11 is not present
  let DMA_HRS_HRS11_A_1 $bool = yes // A hardware service request for channel 11 is present

//--- Enumerated values for register HRS, field HRS12
  let DMA_HRS_HRS12_A_0 $bool = no // A hardware service request for channel 12 is not present
  let DMA_HRS_HRS12_A_1 $bool = yes // A hardware service request for channel 12 is present

//--- Enumerated values for register HRS, field HRS13
  let DMA_HRS_HRS13_A_0 $bool = no // A hardware service request for channel 13 is not present
  let DMA_HRS_HRS13_A_1 $bool = yes // A hardware service request for channel 13 is present

//--- Enumerated values for register HRS, field HRS14
  let DMA_HRS_HRS14_A_0 $bool = no // A hardware service request for channel 14 is not present
  let DMA_HRS_HRS14_A_1 $bool = yes // A hardware service request for channel 14 is present

//--- Enumerated values for register HRS, field HRS15
  let DMA_HRS_HRS15_A_0 $bool = no // A hardware service request for channel 15 is not present
  let DMA_HRS_HRS15_A_1 $bool = yes // A hardware service request for channel 15 is present

//--- Enumerated values for register HRS, field HRS16
  let DMA_HRS_HRS16_A_0 $bool = no // A hardware service request for channel 16 is not present
  let DMA_HRS_HRS16_A_1 $bool = yes // A hardware service request for channel 16 is present

//--- Enumerated values for register HRS, field HRS17
  let DMA_HRS_HRS17_A_0 $bool = no // A hardware service request for channel 17 is not present
  let DMA_HRS_HRS17_A_1 $bool = yes // A hardware service request for channel 17 is present

//--- Enumerated values for register HRS, field HRS18
  let DMA_HRS_HRS18_A_0 $bool = no // A hardware service request for channel 18 is not present
  let DMA_HRS_HRS18_A_1 $bool = yes // A hardware service request for channel 18 is present

//--- Enumerated values for register HRS, field HRS19
  let DMA_HRS_HRS19_A_0 $bool = no // A hardware service request for channel 19 is not present
  let DMA_HRS_HRS19_A_1 $bool = yes // A hardware service request for channel 19 is present

//--- Enumerated values for register HRS, field HRS20
  let DMA_HRS_HRS20_A_0 $bool = no // A hardware service request for channel 20 is not present
  let DMA_HRS_HRS20_A_1 $bool = yes // A hardware service request for channel 20 is present

//--- Enumerated values for register HRS, field HRS21
  let DMA_HRS_HRS21_A_0 $bool = no // A hardware service request for channel 21 is not present
  let DMA_HRS_HRS21_A_1 $bool = yes // A hardware service request for channel 21 is present

//--- Enumerated values for register HRS, field HRS22
  let DMA_HRS_HRS22_A_0 $bool = no // A hardware service request for channel 22 is not present
  let DMA_HRS_HRS22_A_1 $bool = yes // A hardware service request for channel 22 is present

//--- Enumerated values for register HRS, field HRS23
  let DMA_HRS_HRS23_A_0 $bool = no // A hardware service request for channel 23 is not present
  let DMA_HRS_HRS23_A_1 $bool = yes // A hardware service request for channel 23 is present

//--- Enumerated values for register HRS, field HRS24
  let DMA_HRS_HRS24_A_0 $bool = no // A hardware service request for channel 24 is not present
  let DMA_HRS_HRS24_A_1 $bool = yes // A hardware service request for channel 24 is present

//--- Enumerated values for register HRS, field HRS25
  let DMA_HRS_HRS25_A_0 $bool = no // A hardware service request for channel 25 is not present
  let DMA_HRS_HRS25_A_1 $bool = yes // A hardware service request for channel 25 is present

//--- Enumerated values for register HRS, field HRS26
  let DMA_HRS_HRS26_A_0 $bool = no // A hardware service request for channel 26 is not present
  let DMA_HRS_HRS26_A_1 $bool = yes // A hardware service request for channel 26 is present

//--- Enumerated values for register HRS, field HRS27
  let DMA_HRS_HRS27_A_0 $bool = no // A hardware service request for channel 27 is not present
  let DMA_HRS_HRS27_A_1 $bool = yes // A hardware service request for channel 27 is present

//--- Enumerated values for register HRS, field HRS28
  let DMA_HRS_HRS28_A_0 $bool = no // A hardware service request for channel 28 is not present
  let DMA_HRS_HRS28_A_1 $bool = yes // A hardware service request for channel 28 is present

//--- Enumerated values for register HRS, field HRS29
  let DMA_HRS_HRS29_A_0 $bool = no // A hardware service request for channel 29 is not preset
  let DMA_HRS_HRS29_A_1 $bool = yes // A hardware service request for channel 29 is present

//--- Enumerated values for register HRS, field HRS30
  let DMA_HRS_HRS30_A_0 $bool = no // A hardware service request for channel 30 is not present
  let DMA_HRS_HRS30_A_1 $bool = yes // A hardware service request for for channel 30 is present

//--- Enumerated values for register HRS, field HRS31
  let DMA_HRS_HRS31_A_0 $bool = no // A hardware service request for channel 31 is not present
  let DMA_HRS_HRS31_A_1 $bool = yes // A hardware service request for channel 31 is present

//--- Enumerated values for register EARS, field EDREQ_0
  let DMA_EARS_EDREQ_0_Disable_0 $bool = no // Disable asynchronous DMA request for channel 0.
  let DMA_EARS_EDREQ_0_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 0.

//--- Enumerated values for register EARS, field EDREQ_1
  let DMA_EARS_EDREQ_1_Disable_0 $bool = no // Disable asynchronous DMA request for channel 1
  let DMA_EARS_EDREQ_1_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 1.

//--- Enumerated values for register EARS, field EDREQ_2
  let DMA_EARS_EDREQ_2_Disable_0 $bool = no // Disable asynchronous DMA request for channel 2.
  let DMA_EARS_EDREQ_2_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 2.

//--- Enumerated values for register EARS, field EDREQ_3
  let DMA_EARS_EDREQ_3_Disable_0 $bool = no // Disable asynchronous DMA request for channel 3.
  let DMA_EARS_EDREQ_3_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 3.

//--- Enumerated values for register EARS, field EDREQ_4
  let DMA_EARS_EDREQ_4_Disable_0 $bool = no // Disable asynchronous DMA request for channel 4.
  let DMA_EARS_EDREQ_4_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 4.

//--- Enumerated values for register EARS, field EDREQ_5
  let DMA_EARS_EDREQ_5_Disable_0 $bool = no // Disable asynchronous DMA request for channel 5.
  let DMA_EARS_EDREQ_5_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 5.

//--- Enumerated values for register EARS, field EDREQ_6
  let DMA_EARS_EDREQ_6_Disable_0 $bool = no // Disable asynchronous DMA request for channel 6.
  let DMA_EARS_EDREQ_6_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 6.

//--- Enumerated values for register EARS, field EDREQ_7
  let DMA_EARS_EDREQ_7_Disable_0 $bool = no // Disable asynchronous DMA request for channel 7.
  let DMA_EARS_EDREQ_7_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 7.

//--- Enumerated values for register EARS, field EDREQ_8
  let DMA_EARS_EDREQ_8_Disable_0 $bool = no // Disable asynchronous DMA request for channel 8.
  let DMA_EARS_EDREQ_8_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 8.

//--- Enumerated values for register EARS, field EDREQ_9
  let DMA_EARS_EDREQ_9_Disable_0 $bool = no // Disable asynchronous DMA request for channel 9.
  let DMA_EARS_EDREQ_9_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 9.

//--- Enumerated values for register EARS, field EDREQ_10
  let DMA_EARS_EDREQ_10_Disable_0 $bool = no // Disable asynchronous DMA request for channel 10.
  let DMA_EARS_EDREQ_10_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 10.

//--- Enumerated values for register EARS, field EDREQ_11
  let DMA_EARS_EDREQ_11_Disable_0 $bool = no // Disable asynchronous DMA request for channel 11.
  let DMA_EARS_EDREQ_11_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 11.

//--- Enumerated values for register EARS, field EDREQ_12
  let DMA_EARS_EDREQ_12_Disable_0 $bool = no // Disable asynchronous DMA request for channel 12.
  let DMA_EARS_EDREQ_12_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 12.

//--- Enumerated values for register EARS, field EDREQ_13
  let DMA_EARS_EDREQ_13_Disable_0 $bool = no // Disable asynchronous DMA request for channel 13.
  let DMA_EARS_EDREQ_13_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 13.

//--- Enumerated values for register EARS, field EDREQ_14
  let DMA_EARS_EDREQ_14_Disable_0 $bool = no // Disable asynchronous DMA request for channel 14.
  let DMA_EARS_EDREQ_14_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 14.

//--- Enumerated values for register EARS, field EDREQ_15
  let DMA_EARS_EDREQ_15_Disable_0 $bool = no // Disable asynchronous DMA request for channel 15.
  let DMA_EARS_EDREQ_15_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 15.

//--- Enumerated values for register EARS, field EDREQ_16
  let DMA_EARS_EDREQ_16_Disable_0 $bool = no // Disable asynchronous DMA request for channel 16
  let DMA_EARS_EDREQ_16_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 16

//--- Enumerated values for register EARS, field EDREQ_17
  let DMA_EARS_EDREQ_17_Disable_0 $bool = no // Disable asynchronous DMA request for channel 17
  let DMA_EARS_EDREQ_17_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 17

//--- Enumerated values for register EARS, field EDREQ_18
  let DMA_EARS_EDREQ_18_Disable_0 $bool = no // Disable asynchronous DMA request for channel 18
  let DMA_EARS_EDREQ_18_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 18

//--- Enumerated values for register EARS, field EDREQ_19
  let DMA_EARS_EDREQ_19_Disable_0 $bool = no // Disable asynchronous DMA request for channel 19
  let DMA_EARS_EDREQ_19_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 19

//--- Enumerated values for register EARS, field EDREQ_20
  let DMA_EARS_EDREQ_20_Disable_0 $bool = no // Disable asynchronous DMA request for channel 20
  let DMA_EARS_EDREQ_20_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 20

//--- Enumerated values for register EARS, field EDREQ_21
  let DMA_EARS_EDREQ_21_Disable_0 $bool = no // Disable asynchronous DMA request for channel 21
  let DMA_EARS_EDREQ_21_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 21

//--- Enumerated values for register EARS, field EDREQ_22
  let DMA_EARS_EDREQ_22_Disable_0 $bool = no // Disable asynchronous DMA request for channel 22
  let DMA_EARS_EDREQ_22_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 22

//--- Enumerated values for register EARS, field EDREQ_23
  let DMA_EARS_EDREQ_23_Disable_0 $bool = no // Disable asynchronous DMA request for channel 23
  let DMA_EARS_EDREQ_23_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 23

//--- Enumerated values for register EARS, field EDREQ_24
  let DMA_EARS_EDREQ_24_Disable_0 $bool = no // Disable asynchronous DMA request for channel 24
  let DMA_EARS_EDREQ_24_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 24

//--- Enumerated values for register EARS, field EDREQ_25
  let DMA_EARS_EDREQ_25_Disable_0 $bool = no // Disable asynchronous DMA request for channel 25
  let DMA_EARS_EDREQ_25_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 25

//--- Enumerated values for register EARS, field EDREQ_26
  let DMA_EARS_EDREQ_26_Disable_0 $bool = no // Disable asynchronous DMA request for channel 26
  let DMA_EARS_EDREQ_26_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 26

//--- Enumerated values for register EARS, field EDREQ_27
  let DMA_EARS_EDREQ_27_Disable_0 $bool = no // Disable asynchronous DMA request for channel 27
  let DMA_EARS_EDREQ_27_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 27

//--- Enumerated values for register EARS, field EDREQ_28
  let DMA_EARS_EDREQ_28_Disable_0 $bool = no // Disable asynchronous DMA request for channel 28
  let DMA_EARS_EDREQ_28_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 28

//--- Enumerated values for register EARS, field EDREQ_29
  let DMA_EARS_EDREQ_29_Disable_0 $bool = no // Disable asynchronous DMA request for channel 29
  let DMA_EARS_EDREQ_29_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 29

//--- Enumerated values for register EARS, field EDREQ_30
  let DMA_EARS_EDREQ_30_Disable_0 $bool = no // Disable asynchronous DMA request for channel 30
  let DMA_EARS_EDREQ_30_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 30

//--- Enumerated values for register EARS, field EDREQ_31
  let DMA_EARS_EDREQ_31_Disable_0 $bool = no // Disable asynchronous DMA request for channel 31
  let DMA_EARS_EDREQ_31_Enable_1 $bool = yes // Enable asynchronous DMA request for channel 31

//--- Enumerated values for register DCHPRI%s, field DPA
  let DMA_DCHPRI_DPA_Channel_0 $bool = no // Channel n can suspend a lower priority channel.
  let DMA_DCHPRI_DPA_Channel_1 $bool = yes // Channel n cannot suspend any channel, regardless of channel priority.

//--- Enumerated values for register DCHPRI%s, field ECP
  let DMA_DCHPRI_ECP_Channel_0 $bool = no // Channel n cannot be suspended by a higher priority channel's service request.
  let DMA_DCHPRI_ECP_Channel_1 $bool = yes // Channel n can be temporarily suspended by the service request of a higher priority channel.

//--- Enumerated values for register TCD%s_ATTR, field SSIZE
  let DMA_TCD_ATTR_SSIZE_8_bit_000 $u3 = 0 // 8-bit
  let DMA_TCD_ATTR_SSIZE_16_bit_001 $u3 = 1 // 16-bit
  let DMA_TCD_ATTR_SSIZE_32_bit_010 $u3 = 2 // 32-bit
  let DMA_TCD_ATTR_SSIZE_16_byte_100 $u3 = 4 // 16-byte burst
  let DMA_TCD_ATTR_SSIZE_32_byte_101 $u3 = 5 // 32-byte burst

//--- Enumerated values for register TCD%s_ATTR, field SMOD
  let DMA_TCD_ATTR_SMOD_Source_0 $u5 = 0 // Source address modulo feature is disabled

//--- Enumerated values for register TCD%s_NBYTES_MLOFFNO, field DMLOE
  let DMA_TCD_NBYTES_MLOFFNO_DMLOE_The_0 $bool = no // The minor loop offset is not applied to the DADDR
  let DMA_TCD_NBYTES_MLOFFNO_DMLOE_The_1 $bool = yes // The minor loop offset is applied to the DADDR

//--- Enumerated values for register TCD%s_NBYTES_MLOFFNO, field SMLOE
  let DMA_TCD_NBYTES_MLOFFNO_SMLOE_The_0 $bool = no // The minor loop offset is not applied to the SADDR
  let DMA_TCD_NBYTES_MLOFFNO_SMLOE_The_1 $bool = yes // The minor loop offset is applied to the SADDR

//--- Enumerated values for register TCD%s_NBYTES_MLOFFYES, field DMLOE
  let DMA_TCD_NBYTES_MLOFFYES_DMLOE_The_0 $bool = no // The minor loop offset is not applied to the DADDR
  let DMA_TCD_NBYTES_MLOFFYES_DMLOE_The_1 $bool = yes // The minor loop offset is applied to the DADDR

//--- Enumerated values for register TCD%s_NBYTES_MLOFFYES, field SMLOE
  let DMA_TCD_NBYTES_MLOFFYES_SMLOE_The_0 $bool = no // The minor loop offset is not applied to the SADDR
  let DMA_TCD_NBYTES_MLOFFYES_SMLOE_The_1 $bool = yes // The minor loop offset is applied to the SADDR

//--- Enumerated values for register TCD%s_CITER_ELINKNO, field ELINK
  let DMA_TCD_CITER_ELINKNO_ELINK_The_0 $bool = no // The channel-to-channel linking is disabled
  let DMA_TCD_CITER_ELINKNO_ELINK_The_1 $bool = yes // The channel-to-channel linking is enabled

//--- Enumerated values for register TCD%s_CITER_ELINKYES, field ELINK
  let DMA_TCD_CITER_ELINKYES_ELINK_The_0 $bool = no // The channel-to-channel linking is disabled
  let DMA_TCD_CITER_ELINKYES_ELINK_The_1 $bool = yes // The channel-to-channel linking is enabled

//--- Enumerated values for register TCD%s_CSR, field START
  let DMA_TCD_CSR_START_The_0 $bool = no // The channel is not explicitly started.
  let DMA_TCD_CSR_START_The_1 $bool = yes // The channel is explicitly started via a software initiated service request.

//--- Enumerated values for register TCD%s_CSR, field INTMAJOR
  let DMA_TCD_CSR_INTMAJOR_The_0 $bool = no // The end-of-major loop interrupt is disabled.
  let DMA_TCD_CSR_INTMAJOR_The_1 $bool = yes // The end-of-major loop interrupt is enabled.

//--- Enumerated values for register TCD%s_CSR, field INTHALF
  let DMA_TCD_CSR_INTHALF_The_0 $bool = no // The half-point interrupt is disabled.
  let DMA_TCD_CSR_INTHALF_The_1 $bool = yes // The half-point interrupt is enabled.

//--- Enumerated values for register TCD%s_CSR, field DREQ
  let DMA_TCD_CSR_DREQ_The_0 $bool = no // The channel's ERQ bit is not affected.
  let DMA_TCD_CSR_DREQ_The_1 $bool = yes // The channel's ERQ bit is cleared when the major loop is complete.

//--- Enumerated values for register TCD%s_CSR, field ESG
  let DMA_TCD_CSR_ESG_The_0 $bool = no // The current channel's TCD is normal format.
  let DMA_TCD_CSR_ESG_The_1 $bool = yes // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.

//--- Enumerated values for register TCD%s_CSR, field MAJORELINK
  let DMA_TCD_CSR_MAJORELINK_The_0 $bool = no // The channel-to-channel linking is disabled.
  let DMA_TCD_CSR_MAJORELINK_The_1 $bool = yes // The channel-to-channel linking is enabled.

//--- Enumerated values for register TCD%s_CSR, field BWC
  let DMA_TCD_CSR_BWC_No_00 $u2 = 0 // No eDMA engine stalls
  let DMA_TCD_CSR_BWC_eDMA_10 $u2 = 2 // eDMA engine stalls for 4 cycles after each R/W.
  let DMA_TCD_CSR_BWC_eDMA_11 $u2 = 3 // eDMA engine stalls for 8 cycles after each R/W.

//--- Enumerated values for register TCD%s_BITER_ELINKNO, field ELINK
  let DMA_TCD_BITER_ELINKNO_ELINK_The_0 $bool = no // The channel-to-channel linking is disabled
  let DMA_TCD_BITER_ELINKNO_ELINK_The_1 $bool = yes // The channel-to-channel linking is enabled

//--- Enumerated values for register TCD%s_BITER_ELINKYES, field ELINK
  let DMA_TCD_BITER_ELINKYES_ELINK_The_0 $bool = no // The channel-to-channel linking is disabled
  let DMA_TCD_BITER_ELINKYES_ELINK_The_1 $bool = yes // The channel-to-channel linking is enabled

//------------------------------------------------------------------------------
// Peripheral DMAMUX: DMA channel multiplexor
//------------------------------------------------------------------------------

registers ©DMAMUX @at 0x40021000 {
//---  Registers CHCFG(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Channel Configuration register
  CHCFG [32 @offset 0x0 @inc 0x1]
  CHCFG0 @offset 0x0
  CHCFG1 @offset 0x1
  CHCFG2 @offset 0x2
  CHCFG3 @offset 0x3
  CHCFG4 @offset 0x4
  CHCFG5 @offset 0x5
  CHCFG6 @offset 0x6
  CHCFG7 @offset 0x7
  CHCFG8 @offset 0x8
  CHCFG9 @offset 0x9
  CHCFG10 @offset 0xa
  CHCFG11 @offset 0xb
  CHCFG12 @offset 0xc
  CHCFG13 @offset 0xd
  CHCFG14 @offset 0xe
  CHCFG15 @offset 0xf
  CHCFG16 @offset 0x10
  CHCFG17 @offset 0x11
  CHCFG18 @offset 0x12
  CHCFG19 @offset 0x13
  CHCFG20 @offset 0x14
  CHCFG21 @offset 0x15
  CHCFG22 @offset 0x16
  CHCFG23 @offset 0x17
  CHCFG24 @offset 0x18
  CHCFG25 @offset 0x19
  CHCFG26 @offset 0x1a
  CHCFG27 @offset 0x1b
  CHCFG28 @offset 0x1c
  CHCFG29 @offset 0x1d
  CHCFG30 @offset 0x1e
  CHCFG31 @offset 0x1f $u8 {
    ENBL // at 7: DMA Channel Enable
    TRIG // at 6: DMA Channel Trigger Enable
    SOURCE:6 // at 0: DMA Channel Source (Slot)
  }

}

//--- Enumerated values for register CHCFG%s, field SOURCE
  let DMAMUX_CHCFG_SOURCE_Disable_Signal_0 $u6 = 0 // Disable_Signal
  let DMAMUX_CHCFG_SOURCE_TSI0_Signal_1 $u6 = 1 // TSI0_Signal
  let DMAMUX_CHCFG_SOURCE_UART0_Rx_Signal_2 $u6 = 2 // UART0_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_UART0_Tx_Signal_3 $u6 = 3 // UART0_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_UART1_Rx_Signal_4 $u6 = 4 // UART1_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_UART1_Tx_Signal_5 $u6 = 5 // UART1_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_UART2_Rx_Signal_6 $u6 = 6 // UART2_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_UART2_Tx_Signal_7 $u6 = 7 // UART2_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_UART3_Rx_Signal_8 $u6 = 8 // UART3_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_UART3_Tx_Signal_9 $u6 = 9 // UART3_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_UART4_Signal_10 $u6 = 10 // UART4_Signal
  let DMAMUX_CHCFG_SOURCE_I2S0_Rx_Signal_12 $u6 = 12 // I2S0_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_I2S0_Tx_Signal_13 $u6 = 13 // I2S0_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_SPI0_Rx_Signal_14 $u6 = 14 // SPI0_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_SPI0_Tx_Signal_15 $u6 = 15 // SPI0_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_SPI1_Rx_Signal_16 $u6 = 16 // SPI1_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_SPI1_Tx_Signal_17 $u6 = 17 // SPI1_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_I2C0_I2C3_Signal_18 $u6 = 18 // I2C0_I2C3_Signal
  let DMAMUX_CHCFG_SOURCE_I2C1_I2C2_Signal_19 $u6 = 19 // I2C1_I2C2_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel0_Signal_20 $u6 = 20 // FTM0_Channel0_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel1_Signal_21 $u6 = 21 // FTM0_Channel1_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel2_Signal_22 $u6 = 22 // FTM0_Channel2_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel3_Signal_23 $u6 = 23 // FTM0_Channel3_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel4_Signal_24 $u6 = 24 // FTM0_Channel4_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel5_Signal_25 $u6 = 25 // FTM0_Channel5_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel6_Signal_26 $u6 = 26 // FTM0_Channel6_Signal
  let DMAMUX_CHCFG_SOURCE_FTM0_Channel7_Signal_27 $u6 = 27 // FTM0_Channel7_Signal
  let DMAMUX_CHCFG_SOURCE_FTM1_TPM1_Channel0_Signal_28 $u6 = 28 // FTM1_TPM1_Channel0_Signal
  let DMAMUX_CHCFG_SOURCE_FTM1_TPM1_Channel1_Signal_29 $u6 = 29 // FTM1_TPM1_Channel1_Signal
  let DMAMUX_CHCFG_SOURCE_FTM2_TPM2_Channel0_Signal_30 $u6 = 30 // FTM2_TPM2_Channel0_Signal
  let DMAMUX_CHCFG_SOURCE_FTM2_TPM2_Channel1_Signal_31 $u6 = 31 // FTM2_TPM2_Channel1_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel0_Signal_32 $u6 = 32 // FTM3_Channel0_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel1_Signal_33 $u6 = 33 // FTM3_Channel1_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel2_Signal_34 $u6 = 34 // FTM3_Channel2_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel3_Signal_35 $u6 = 35 // FTM3_Channel3_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel4_Signal_36 $u6 = 36 // FTM3_Channel4_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel5_Signal_37 $u6 = 37 // FTM3_Channel5_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel6_SPI2_Rx_Signal_38 $u6 = 38 // FTM3_Channel6_SPI2_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_FTM3_Channel7_SPI2_Tx_Signal_39 $u6 = 39 // FTM3_Channel7_SPI2_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_ADC0_Signal_40 $u6 = 40 // ADC0_Signal
  let DMAMUX_CHCFG_SOURCE_ADC1_Signal_41 $u6 = 41 // ADC1_Signal
  let DMAMUX_CHCFG_SOURCE_CMP0_Signal_42 $u6 = 42 // CMP0_Signal
  let DMAMUX_CHCFG_SOURCE_CMP1_Signal_43 $u6 = 43 // CMP1_Signal
  let DMAMUX_CHCFG_SOURCE_CMP2_CMP3_Signal_44 $u6 = 44 // CMP2_CMP3_Signal
  let DMAMUX_CHCFG_SOURCE_DAC0_Signal_45 $u6 = 45 // DAC0_Signal
  let DMAMUX_CHCFG_SOURCE_DAC1_Signal_46 $u6 = 46 // DAC1_Signal
  let DMAMUX_CHCFG_SOURCE_CMT_Signal_47 $u6 = 47 // CMT_Signal
  let DMAMUX_CHCFG_SOURCE_PDB_Signal_48 $u6 = 48 // PDB_Signal
  let DMAMUX_CHCFG_SOURCE_PortA_Signal_49 $u6 = 49 // PortA_Signal
  let DMAMUX_CHCFG_SOURCE_PortB_Signal_50 $u6 = 50 // PortB_Signal
  let DMAMUX_CHCFG_SOURCE_PortC_Signal_51 $u6 = 51 // PortC_Signal
  let DMAMUX_CHCFG_SOURCE_PortD_Signal_52 $u6 = 52 // PortD_Signal
  let DMAMUX_CHCFG_SOURCE_PortE_Signal_53 $u6 = 53 // PortE_Signal
  let DMAMUX_CHCFG_SOURCE_IEEE1588Timer0_Signal_54 $u6 = 54 // IEEE1588Timer0_Signal
  let DMAMUX_CHCFG_SOURCE_IEEE1588Timer1_TPM1_Overflow_Signal_55 $u6 = 55 // IEEE1588Timer1_TPM1_Overflow_Signal
  let DMAMUX_CHCFG_SOURCE_IEEE1588Timer2_TPM2_Overflow_Signal_56 $u6 = 56 // IEEE1588Timer2_TPM2_Overflow_Signal
  let DMAMUX_CHCFG_SOURCE_IEEE1588Timer3_Signal_57 $u6 = 57 // IEEE1588Timer3_Signal
  let DMAMUX_CHCFG_SOURCE_LPUART0_Rx_Signal_58 $u6 = 58 // LPUART0_Rx_Signal
  let DMAMUX_CHCFG_SOURCE_LPUART0_Tx_Signal_59 $u6 = 59 // LPUART0_Tx_Signal
  let DMAMUX_CHCFG_SOURCE_AlwaysOn60_Signal_60 $u6 = 60 // AlwaysOn60_Signal
  let DMAMUX_CHCFG_SOURCE_AlwaysOn61_Signal_61 $u6 = 61 // AlwaysOn61_Signal
  let DMAMUX_CHCFG_SOURCE_AlwaysOn62_Signal_62 $u6 = 62 // AlwaysOn62_Signal
  let DMAMUX_CHCFG_SOURCE_AlwaysOn63_Signal_63 $u6 = 63 // AlwaysOn63_Signal

//--- Enumerated values for register CHCFG%s, field TRIG
  let DMAMUX_CHCFG_TRIG_Triggering_0 $bool = no // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
  let DMAMUX_CHCFG_TRIG_Triggering_1 $bool = yes // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.

//--- Enumerated values for register CHCFG%s, field ENBL
  let DMAMUX_CHCFG_ENBL_DMA_0 $bool = no // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
  let DMAMUX_CHCFG_ENBL_DMA_1 $bool = yes // DMA channel is enabled

//------------------------------------------------------------------------------
// Peripheral ENET: Ethernet MAC-NET Core
//------------------------------------------------------------------------------

registers ©ENET @at 0x400c0000 {
//---  Register EIR: Interrupt Event Register
  EIR @offset 0x4 $u32 {
    1
    BABR // at 30: Babbling Receive Error
    BABT // at 29: Babbling Transmit Error
    GRA // at 28: Graceful Stop Complete
    TXF // at 27: Transmit Frame Interrupt
    TXB // at 26: Transmit Buffer Interrupt
    RXF // at 25: Receive Frame Interrupt
    RXB // at 24: Receive Buffer Interrupt
    MII // at 23: MII Interrupt.
    EBERR // at 22: Ethernet Bus Error
    LC // at 21: Late Collision
    RL // at 20: Collision Retry Limit
    UN // at 19: Transmit FIFO Underrun
    PLR // at 18: Payload Receive Error
    WAKEUP // at 17: Node Wakeup Request Indication
    TS_AVAIL // at 16: Transmit Timestamp Available
    TS_TIMER // at 15: Timestamp Timer
    15
  }

//---  Register EIMR: Interrupt Mask Register
  EIMR @offset 0x8 $u32 {
    1
    BABR // at 30: BABR Interrupt Mask
    BABT // at 29: BABT Interrupt Mask
    GRA // at 28: GRA Interrupt Mask
    TXF // at 27: TXF Interrupt Mask
    TXB // at 26: TXB Interrupt Mask
    RXF // at 25: RXF Interrupt Mask
    RXB // at 24: RXB Interrupt Mask
    MII // at 23: MII Interrupt Mask
    EBERR // at 22: EBERR Interrupt Mask
    LC // at 21: LC Interrupt Mask
    RL // at 20: RL Interrupt Mask
    UN // at 19: UN Interrupt Mask
    PLR // at 18: PLR Interrupt Mask
    WAKEUP // at 17: WAKEUP Interrupt Mask
    TS_AVAIL // at 16: TS_AVAIL Interrupt Mask
    TS_TIMER // at 15: TS_TIMER Interrupt Mask
    15
  }

//---  Register RDAR: Receive Descriptor Active Register
  RDAR @offset 0x10 $u32 {
    7
    RDAR // at 24: Receive Descriptor Active
    24
  }

//---  Register TDAR: Transmit Descriptor Active Register
  TDAR @offset 0x14 $u32 {
    7
    TDAR // at 24: Transmit Descriptor Active
    24
  }

//---  Register ECR: Ethernet Control Register
  ECR @offset 0x24 $u32 {
    23
    DBSWP // at 8: Descriptor Byte Swapping Enable
    STOPEN // at 7: STOPEN Signal Control
    DBGEN // at 6: Debug Enable
    1
    EN1588 // at 4: EN1588 Enable
    SLEEP // at 3: Sleep Mode Enable
    MAGICEN // at 2: Magic Packet Detection Enable
    ETHEREN // at 1: Ethernet Enable
    RESET // at 0: Ethernet MAC Reset
  }

//---  Register MMFR: MII Management Frame Register
  MMFR @offset 0x40 $u32 {
    ST:2 // at 30: Start Of Frame Delimiter
    OP:2 // at 28: Operation Code
    PA:5 // at 23: PHY Address
    RA:5 // at 18: Register Address
    TA:2 // at 16: Turn Around
    DATA:16 // at 0: Management Frame Data
  }

//---  Register MSCR: MII Speed Control Register
  MSCR @offset 0x44 $u32 {
    21
    HOLDTIME:3 // at 8: Hold time On MDIO Output
    DIS_PRE // at 7: Disable Preamble
    MII_SPEED:6 // at 1: MII Speed
    1
  }

//---  Register MIBC: MIB Control Register
  MIBC @offset 0x64 $u32 {
    MIB_DIS // at 31: Disable MIB Logic
    MIB_IDLE // at 30: MIB Idle
    MIB_CLEAR // at 29: MIB Clear
    29
  }

//---  Register RCR: Receive Control Register
  RCR @offset 0x84 $u32 {
    GRS // at 31: Graceful Receive Stopped
    NLC // at 30: Payload Length Check Disable
    MAX_FL:14 // at 16: Maximum Frame Length
    CFEN // at 15: MAC Control Frame Enable
    CRCFWD // at 14: Terminate/Forward Received CRC
    PAUFWD // at 13: Terminate/Forward Pause Frames
    PADEN // at 12: Enable Frame Padding Remove On Receive
    2
    RMII_10T // at 9: Enables 10-Mbps mode of the RMII .
    RMII_MODE // at 8: RMII Mode Enable
    2
    FCE // at 5: Flow Control Enable
    BC_REJ // at 4: Broadcast Frame Reject
    PROM // at 3: Promiscuous Mode
    MII_MODE // at 2: Media Independent Interface Mode
    DRT // at 1: Disable Receive On Transmit
    LOOP // at 0: Internal Loopback
  }

//---  Register TCR: Transmit Control Register
  TCR @offset 0xc4 $u32 {
    22
    CRCFWD // at 9: Forward Frame From Application With CRC
    ADDINS // at 8: Set MAC Address On Transmit
    ADDSEL:3 // at 5: Source MAC Address Select On Transmit
    RFC_PAUSE // at 4: Receive Frame Control Pause
    TFC_PAUSE // at 3: Transmit Frame Control Pause
    FDEN // at 2: Full-Duplex Enable
    1
    GTS // at 0: Graceful Transmit Stop
  }

//---  Register PALR: Physical Address Lower Register
  PALR @offset 0xe4 $u32 {
    PADDR1:32 // at 0: Pause Address
  }

//---  Register PAUR: Physical Address Upper Register
  PAUR @offset 0xe8 $u32 {
    PADDR2:16 // at 16: Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames
    TYPE:16 // at 0: Type Field In PAUSE Frames
  }

//---  Register OPD: Opcode/Pause Duration Register
  OPD @offset 0xec $u32 {
    OPCODE:16 // at 16: Opcode Field In PAUSE Frames
    PAUSE_DUR:16 // at 0: Pause Duration
  }

//---  Register IAUR: Descriptor Individual Upper Address Register
  IAUR @offset 0x118 $u32 {
    IADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
  }

//---  Register IALR: Descriptor Individual Lower Address Register
  IALR @offset 0x11c $u32 {
    IADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address
  }

//---  Register GAUR: Descriptor Group Upper Address Register
  GAUR @offset 0x120 $u32 {
    GADDR1:32 // at 0: Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
  }

//---  Register GALR: Descriptor Group Lower Address Register
  GALR @offset 0x124 $u32 {
    GADDR2:32 // at 0: Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address
  }

//---  Register TFWR: Transmit FIFO Watermark Register
  TFWR @offset 0x144 $u32 {
    23
    STRFWD // at 8: Store And Forward Enable
    2
    TFWR:6 // at 0: Transmit FIFO Write
  }

//---  Register RDSR: Receive Descriptor Ring Start Register
  RDSR @offset 0x180 $u32 {
    R_DES_START:29 // at 3: Pointer to the beginning of the receive buffer descriptor queue.
    3
  }

//---  Register TDSR: Transmit Buffer Descriptor Ring Start Register
  TDSR @offset 0x184 $u32 {
    X_DES_START:29 // at 3: Pointer to the beginning of the transmit buffer descriptor queue.
    3
  }

//---  Register MRBR: Maximum Receive Buffer Size Register
  MRBR @offset 0x188 $u32 {
    21
    R_BUF_SIZE:7 // at 4: Receive buffer size in bytes
    4
  }

//---  Register RSFL: Receive FIFO Section Full Threshold
  RSFL @offset 0x190 $u32 {
    24
    RX_SECTION_FULL:8 // at 0: Value Of Receive FIFO Section Full Threshold
  }

//---  Register RSEM: Receive FIFO Section Empty Threshold
  RSEM @offset 0x194 $u32 {
    11
    STAT_SECTION_EMPTY:5 // at 16: RX Status FIFO Section Empty Threshold
    8
    RX_SECTION_EMPTY:8 // at 0: Value Of The Receive FIFO Section Empty Threshold
  }

//---  Register RAEM: Receive FIFO Almost Empty Threshold
  RAEM @offset 0x198 $u32 {
    24
    RX_ALMOST_EMPTY:8 // at 0: Value Of The Receive FIFO Almost Empty Threshold
  }

//---  Register RAFL: Receive FIFO Almost Full Threshold
  RAFL @offset 0x19c $u32 {
    24
    RX_ALMOST_FULL:8 // at 0: Value Of The Receive FIFO Almost Full Threshold
  }

//---  Register TSEM: Transmit FIFO Section Empty Threshold
  TSEM @offset 0x1a0 $u32 {
    24
    TX_SECTION_EMPTY:8 // at 0: Value Of The Transmit FIFO Section Empty Threshold
  }

//---  Register TAEM: Transmit FIFO Almost Empty Threshold
  TAEM @offset 0x1a4 $u32 {
    24
    TX_ALMOST_EMPTY:8 // at 0: Value of Transmit FIFO Almost Empty Threshold
  }

//---  Register TAFL: Transmit FIFO Almost Full Threshold
  TAFL @offset 0x1a8 $u32 {
    24
    TX_ALMOST_FULL:8 // at 0: Value Of The Transmit FIFO Almost Full Threshold
  }

//---  Register TIPG: Transmit Inter-Packet Gap
  TIPG @offset 0x1ac $u32 {
    27
    IPG:5 // at 0: Transmit Inter-Packet Gap
  }

//---  Register FTRL: Frame Truncation Length
  FTRL @offset 0x1b0 $u32 {
    18
    TRUNC_FL:14 // at 0: Frame Truncation Length
  }

//---  Register TACC: Transmit Accelerator Function Configuration
  TACC @offset 0x1c0 $u32 {
    27
    PROCHK // at 4: Enables insertion of protocol checksum.
    IPCHK // at 3: Enables insertion of IP header checksum.
    2
    SHIFT16 // at 0: TX FIFO Shift-16
  }

//---  Register RACC: Receive Accelerator Function Configuration
  RACC @offset 0x1c4 $u32 {
    24
    SHIFT16 // at 7: RX FIFO Shift-16
    LINEDIS // at 6: Enable Discard Of Frames With MAC Layer Errors
    3
    PRODIS // at 2: Enable Discard Of Frames With Wrong Protocol Checksum
    IPDIS // at 1: Enable Discard Of Frames With Wrong IPv4 Header Checksum
    PADREM // at 0: Enable Padding Removal For Short IP Frames
  }

//---  Register RMON_T_DROP: Reserved Statistic Register
  RMON_T_DROP @offset 0x200 @ro $u32
//---  Register RMON_T_PACKETS: Tx Packet Count Statistic Register
  RMON_T_PACKETS @offset 0x204 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packet count
  }

//---  Register RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
  RMON_T_BC_PKT @offset 0x208 @ro $u32 {
    16
    TXPKTS:16 // at 0: Broadcast packets
  }

//---  Register RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
  RMON_T_MC_PKT @offset 0x20c @ro $u32 {
    16
    TXPKTS:16 // at 0: Multicast packets
  }

//---  Register RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
  RMON_T_CRC_ALIGN @offset 0x210 @ro $u32 {
    16
    TXPKTS:16 // at 0: Packets with CRC/align error
  }

//---  Register RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
  RMON_T_UNDERSIZE @offset 0x214 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets less than 64 bytes with good CRC
  }

//---  Register RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
  RMON_T_OVERSIZE @offset 0x218 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets greater than MAX_FL bytes with good CRC
  }

//---  Register RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
  RMON_T_FRAG @offset 0x21c @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of packets less than 64 bytes with bad CRC
  }

//---  Register RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
  RMON_T_JAB @offset 0x220 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets greater than MAX_FL bytes and bad CRC
  }

//---  Register RMON_T_COL: Tx Collision Count Statistic Register
  RMON_T_COL @offset 0x224 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit collisions
  }

//---  Register RMON_T_P64: Tx 64-Byte Packets Statistic Register
  RMON_T_P64 @offset 0x228 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 64-byte transmit packets
  }

//---  Register RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
  RMON_T_P65TO127 @offset 0x22c @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 65- to 127-byte transmit packets
  }

//---  Register RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
  RMON_T_P128TO255 @offset 0x230 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 128- to 255-byte transmit packets
  }

//---  Register RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
  RMON_T_P256TO511 @offset 0x234 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 256- to 511-byte transmit packets
  }

//---  Register RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
  RMON_T_P512TO1023 @offset 0x238 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 512- to 1023-byte transmit packets
  }

//---  Register RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
  RMON_T_P1024TO2047 @offset 0x23c @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of 1024- to 2047-byte transmit packets
  }

//---  Register RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
  RMON_T_P_GTE2048 @offset 0x240 @ro $u32 {
    16
    TXPKTS:16 // at 0: Number of transmit packets greater than 2048 bytes
  }

//---  Register RMON_T_OCTETS: Tx Octets Statistic Register
  RMON_T_OCTETS @offset 0x244 @ro $u32 {
    TXOCTS:32 // at 0: Number of transmit octets
  }

//---  Register IEEE_T_DROP: IEEE_T_DROP Reserved Statistic Register
  IEEE_T_DROP @offset 0x248 @ro $u32
//---  Register IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
  IEEE_T_FRAME_OK @offset 0x24c @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted OK
  }

//---  Register IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
  IEEE_T_1COL @offset 0x250 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with one collision
  }

//---  Register IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
  IEEE_T_MCOL @offset 0x254 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with multiple collisions
  }

//---  Register IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
  IEEE_T_DEF @offset 0x258 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with deferral delay
  }

//---  Register IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
  IEEE_T_LCOL @offset 0x25c @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with late collision
  }

//---  Register IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
  IEEE_T_EXCOL @offset 0x260 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with excessive collisions
  }

//---  Register IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
  IEEE_T_MACERR @offset 0x264 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with transmit FIFO underrun
  }

//---  Register IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
  IEEE_T_CSERR @offset 0x268 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with carrier sense error
  }

//---  Register IEEE_T_SQE: no description available
  IEEE_T_SQE @offset 0x26c @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames transmitted with SQE error
  }

//---  Register IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
  IEEE_T_FDXFC @offset 0x270 @ro $u32 {
    16
    COUNT:16 // at 0: Number of flow-control pause frames transmitted
  }

//---  Register IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
  IEEE_T_OCTETS_OK @offset 0x274 @ro $u32 {
    COUNT:32 // at 0: Octet count for frames transmitted without error Counts total octets (includes header and FCS fields).
  }

//---  Register RMON_R_PACKETS: Rx Packet Count Statistic Register
  RMON_R_PACKETS @offset 0x284 @ro $u32 {
    16
    COUNT:16 // at 0: Number of packets received
  }

//---  Register RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
  RMON_R_BC_PKT @offset 0x288 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive broadcast packets
  }

//---  Register RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
  RMON_R_MC_PKT @offset 0x28c @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive multicast packets
  }

//---  Register RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
  RMON_R_CRC_ALIGN @offset 0x290 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets with CRC or align error
  }

//---  Register RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
  RMON_R_UNDERSIZE @offset 0x294 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets with less than 64 bytes and good CRC
  }

//---  Register RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
  RMON_R_OVERSIZE @offset 0x298 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets greater than MAX_FL and good CRC
  }

//---  Register RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
  RMON_R_FRAG @offset 0x29c @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets with less than 64 bytes and bad CRC
  }

//---  Register RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
  RMON_R_JAB @offset 0x2a0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of receive packets greater than MAX_FL and bad CRC
  }

//---  Register RMON_R_RESVD_0: Reserved Statistic Register
  RMON_R_RESVD_0 @offset 0x2a4 @ro $u32
//---  Register RMON_R_P64: Rx 64-Byte Packets Statistic Register
  RMON_R_P64 @offset 0x2a8 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 64-byte receive packets
  }

//---  Register RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
  RMON_R_P65TO127 @offset 0x2ac @ro $u32 {
    16
    COUNT:16 // at 0: Number of 65- to 127-byte recieve packets
  }

//---  Register RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
  RMON_R_P128TO255 @offset 0x2b0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 128- to 255-byte recieve packets
  }

//---  Register RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
  RMON_R_P256TO511 @offset 0x2b4 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 256- to 511-byte recieve packets
  }

//---  Register RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
  RMON_R_P512TO1023 @offset 0x2b8 @ro $u32 {
    16
    COUNT:16 // at 0: Number of 512- to 1023-byte recieve packets
  }

//---  Register RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
  RMON_R_P1024TO2047 @offset 0x2bc @ro $u32 {
    16
    COUNT:16 // at 0: Number of 1024- to 2047-byte recieve packets
  }

//---  Register RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
  RMON_R_P_GTE2048 @offset 0x2c0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of greater-than-2048-byte recieve packets
  }

//---  Register RMON_R_OCTETS: Rx Octets Statistic Register
  RMON_R_OCTETS @offset 0x2c4 @ro $u32 {
    COUNT:32 // at 0: Number of receive octets
  }

//---  Register IEEE_R_DROP: Frames not Counted Correctly Statistic Register
  IEEE_R_DROP @offset 0x2c8 @ro $u32 {
    16
    COUNT:16 // at 0: Frame count
  }

//---  Register IEEE_R_FRAME_OK: Frames Received OK Statistic Register
  IEEE_R_FRAME_OK @offset 0x2cc @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames received OK
  }

//---  Register IEEE_R_CRC: Frames Received with CRC Error Statistic Register
  IEEE_R_CRC @offset 0x2d0 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames received with CRC error
  }

//---  Register IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
  IEEE_R_ALIGN @offset 0x2d4 @ro $u32 {
    16
    COUNT:16 // at 0: Number of frames received with alignment error
  }

//---  Register IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
  IEEE_R_MACERR @offset 0x2d8 @ro $u32 {
    16
    COUNT:16 // at 0: Receive FIFO overflow count
  }

//---  Register IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
  IEEE_R_FDXFC @offset 0x2dc @ro $u32 {
    16
    COUNT:16 // at 0: Number of flow-control pause frames received
  }

//---  Register IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
  IEEE_R_OCTETS_OK @offset 0x2e0 @ro $u32 {
    COUNT:32 // at 0: Number of octets for frames received without error
  }

//---  Register ATCR: Adjustable Timer Control Register
  ATCR @offset 0x400 $u32 {
    18
    SLAVE // at 13: Enable Timer Slave Mode
    1
    CAPTURE // at 11: Capture Timer Value
    1
    RESTART // at 9: Reset Timer
    1
    PINPER // at 7: Enables event signal output assertion on period event
    2
    PEREN // at 4: Enable Periodical Event
    OFFRST // at 3: Reset Timer On Offset Event
    OFFEN // at 2: Enable One-Shot Offset Event
    1
    EN // at 0: Enable Timer
  }

//---  Register ATVR: Timer Value Register
  ATVR @offset 0x404 $u32 {
    ATIME:32 // at 0: A write sets the timer
  }

//---  Register ATOFF: Timer Offset Register
  ATOFF @offset 0x408 $u32 {
    OFFSET:32 // at 0: Offset value for one-shot event generation
  }

//---  Register ATPER: Timer Period Register
  ATPER @offset 0x40c $u32 {
    PERIOD:32 // at 0: Value for generating periodic events
  }

//---  Register ATCOR: Timer Correction Register
  ATCOR @offset 0x410 $u32 {
    1
    COR:31 // at 0: Correction Counter Wrap-Around Value
  }

//---  Register ATINC: Time-Stamping Clock Period Register
  ATINC @offset 0x414 $u32 {
    17
    INC_CORR:7 // at 8: Correction Increment Value
    1
    INC:7 // at 0: Clock Period Of The Timestamping Clock (ts_clk) In Nanoseconds
  }

//---  Register ATSTMP: Timestamp of Last Transmitted Frame
  ATSTMP @offset 0x418 @ro $u32 {
    TIMESTAMP:32 // at 0: Timestamp of the last frame transmitted by the core that had TxBD[TS] set
  }

//---  Register TGSR: Timer Global Status Register
  TGSR @offset 0x604 $u32 {
    28
    TF3 // at 3: Copy Of Timer Flag For Channel 3
    TF2 // at 2: Copy Of Timer Flag For Channel 2
    TF1 // at 1: Copy Of Timer Flag For Channel 1
    TF0 // at 0: Copy Of Timer Flag For Channel 0
  }

//---  Registers TCSR(0,1,2,3): Timer Control Status Register
  TCSR [4 @offset 0x608 @inc 0x8]
  TCSR0 @offset 0x608
  TCSR1 @offset 0x610
  TCSR2 @offset 0x618
  TCSR3 @offset 0x620 $u32 {
    24
    TF // at 7: Timer Flag
    TIE // at 6: Timer Interrupt Enable
    TMODE:4 // at 2: Timer Mode
    1
    TDRE // at 0: Timer DMA Request Enable
  }

//---  Registers TCCR(0,1,2,3): Timer Compare Capture Register
  TCCR [4 @offset 0x60c @inc 0x8]
  TCCR0 @offset 0x60c
  TCCR1 @offset 0x614
  TCCR2 @offset 0x61c
  TCCR3 @offset 0x624 $u32 {
    TCC:32 // at 0: Timer Capture Compare
  }

}

//--- Enumerated values for register EIMR, field TXB
  let ENET_EIMR_TXB_The_0 $bool = no // The corresponding interrupt source is masked.
  let ENET_EIMR_TXB_The_1 $bool = yes // The corresponding interrupt source is not masked.

//--- Enumerated values for register EIMR, field TXF
  let ENET_EIMR_TXF_The_0 $bool = no // The corresponding interrupt source is masked.
  let ENET_EIMR_TXF_The_1 $bool = yes // The corresponding interrupt source is not masked.

//--- Enumerated values for register EIMR, field GRA
  let ENET_EIMR_GRA_The_0 $bool = no // The corresponding interrupt source is masked.
  let ENET_EIMR_GRA_The_1 $bool = yes // The corresponding interrupt source is not masked.

//--- Enumerated values for register EIMR, field BABT
  let ENET_EIMR_BABT_The_0 $bool = no // The corresponding interrupt source is masked.
  let ENET_EIMR_BABT_The_1 $bool = yes // The corresponding interrupt source is not masked.

//--- Enumerated values for register EIMR, field BABR
  let ENET_EIMR_BABR_The_0 $bool = no // The corresponding interrupt source is masked.
  let ENET_EIMR_BABR_The_1 $bool = yes // The corresponding interrupt source is not masked.

//--- Enumerated values for register ECR, field ETHEREN
  let ENET_ECR_ETHEREN_Reception_0 $bool = no // Reception immediately stops and transmission stops after a bad CRC is appended to any currently transmitted frame.
  let ENET_ECR_ETHEREN_MAC_1 $bool = yes // MAC is enabled, and reception and transmission are possible.

//--- Enumerated values for register ECR, field MAGICEN
  let ENET_ECR_MAGICEN_Magic_0 $bool = no // Magic detection logic disabled.
  let ENET_ECR_MAGICEN_The_1 $bool = yes // The MAC core detects magic packets and asserts EIR[WAKEUP] when a frame is detected.

//--- Enumerated values for register ECR, field SLEEP
  let ENET_ECR_SLEEP_Normal_0 $bool = no // Normal operating mode.
  let ENET_ECR_SLEEP_Sleep_1 $bool = yes // Sleep mode.

//--- Enumerated values for register ECR, field EN1588
  let ENET_ECR_EN1588_Legacy_0 $bool = no // Legacy FEC buffer descriptors and functions enabled.
  let ENET_ECR_EN1588_Enhanced_1 $bool = yes // Enhanced frame time-stamping functions enabled.

//--- Enumerated values for register ECR, field DBGEN
  let ENET_ECR_DBGEN_MAC_0 $bool = no // MAC continues operation in debug mode.
  let ENET_ECR_DBGEN_MAC_1 $bool = yes // MAC enters hardware freeze mode when the processor is in debug mode.

//--- Enumerated values for register ECR, field DBSWP
  let ENET_ECR_DBSWP_The_0 $bool = no // The buffer descriptor bytes are not swapped to support big-endian devices.
  let ENET_ECR_DBSWP_The_1 $bool = yes // The buffer descriptor bytes are swapped to support little-endian devices.

//--- Enumerated values for register MSCR, field DIS_PRE
  let ENET_MSCR_DIS_PRE_Preamble_0 $bool = no // Preamble enabled.
  let ENET_MSCR_DIS_PRE_Preamble_1 $bool = yes // Preamble (32 ones) is not prepended to the MII management frame.

//--- Enumerated values for register MSCR, field HOLDTIME
  let ENET_MSCR_HOLDTIME_1_000 $u3 = 0 // 1 internal module clock cycle
  let ENET_MSCR_HOLDTIME_2_001 $u3 = 1 // 2 internal module clock cycles
  let ENET_MSCR_HOLDTIME_3_010 $u3 = 2 // 3 internal module clock cycles
  let ENET_MSCR_HOLDTIME_8_111 $u3 = 7 // 8 internal module clock cycles

//--- Enumerated values for register MIBC, field MIB_CLEAR
  let ENET_MIBC_MIB_CLEAR_See_0 $bool = no // See note above.
  let ENET_MIBC_MIB_CLEAR_All_1 $bool = yes // All statistics counters are reset to 0.

//--- Enumerated values for register MIBC, field MIB_IDLE
  let ENET_MIBC_MIB_IDLE_The_0 $bool = no // The MIB block is updating MIB counters.
  let ENET_MIBC_MIB_IDLE_The_1 $bool = yes // The MIB block is not currently updating any MIB counters.

//--- Enumerated values for register MIBC, field MIB_DIS
  let ENET_MIBC_MIB_DIS_MIB_0 $bool = no // MIB logic is enabled.
  let ENET_MIBC_MIB_DIS_MIB_1 $bool = yes // MIB logic is disabled. The MIB logic halts and does not update any MIB counters.

//--- Enumerated values for register RCR, field LOOP
  let ENET_RCR_LOOP_Loopback_0 $bool = no // Loopback disabled.
  let ENET_RCR_LOOP_Transmitted_1 $bool = yes // Transmitted frames are looped back internal to the device and transmit MII output signals are not asserted. DRT must be cleared.

//--- Enumerated values for register RCR, field DRT
  let ENET_RCR_DRT_Receive_0 $bool = no // Receive path operates independently of transmit. Used for full-duplex or to monitor transmit activity in half-duplex mode.
  let ENET_RCR_DRT_Disable_1 $bool = yes // Disable reception of frames while transmitting. Normally used for half-duplex mode.

//--- Enumerated values for register RCR, field MII_MODE
  let ENET_RCR_MII_MODE_MII_1 $bool = yes // MII or RMII mode, as indicated by the RMII_MODE field.

//--- Enumerated values for register RCR, field PROM
  let ENET_RCR_PROM_Disabled__0 $bool = no // Disabled.
  let ENET_RCR_PROM_Enabled__1 $bool = yes // Enabled.

//--- Enumerated values for register RCR, field RMII_MODE
  let ENET_RCR_RMII_MODE_MAC_0 $bool = no // MAC configured for MII mode.
  let ENET_RCR_RMII_MODE_MAC_1 $bool = yes // MAC configured for RMII operation.

//--- Enumerated values for register RCR, field RMII_10T
  let ENET_RCR_RMII_10T_100_0 $bool = no // 100 Mbps operation.
  let ENET_RCR_RMII_10T_10_1 $bool = yes // 10 Mbps operation.

//--- Enumerated values for register RCR, field PADEN
  let ENET_RCR_PADEN_No_0 $bool = no // No padding is removed on receive by the MAC.
  let ENET_RCR_PADEN_Padding_1 $bool = yes // Padding is removed from received frames.

//--- Enumerated values for register RCR, field PAUFWD
  let ENET_RCR_PAUFWD_Pause_0 $bool = no // Pause frames are terminated and discarded in the MAC.
  let ENET_RCR_PAUFWD_Pause_1 $bool = yes // Pause frames are forwarded to the user application.

//--- Enumerated values for register RCR, field CRCFWD
  let ENET_RCR_CRCFWD_The_0 $bool = no // The CRC field of received frames is transmitted to the user application.
  let ENET_RCR_CRCFWD_The_1 $bool = yes // The CRC field is stripped from the frame.

//--- Enumerated values for register RCR, field CFEN
  let ENET_RCR_CFEN_MAC_0 $bool = no // MAC control frames with any opcode other than 0x0001 (pause frame) are accepted and forwarded to the client interface.
  let ENET_RCR_CFEN_MAC_1 $bool = yes // MAC control frames with any opcode other than 0x0001 (pause frame) are silently discarded.

//--- Enumerated values for register RCR, field NLC
  let ENET_RCR_NLC_The_0 $bool = no // The payload length check is disabled.
  let ENET_RCR_NLC_The_1 $bool = yes // The core checks the frame's payload length with the frame length/type field. Errors are indicated in the EIR[PLC] field.

//--- Enumerated values for register TCR, field TFC_PAUSE
  let ENET_TCR_TFC_PAUSE_No_0 $bool = no // No PAUSE frame transmitted.
  let ENET_TCR_TFC_PAUSE_The_1 $bool = yes // The MAC stops transmission of data frames after the current transmission is complete.

//--- Enumerated values for register TCR, field ADDSEL
  let ENET_TCR_ADDSEL_Node_000 $u3 = 0 // Node MAC address programmed on PADDR1/2 registers.

//--- Enumerated values for register TCR, field ADDINS
  let ENET_TCR_ADDINS_The_0 $bool = no // The source MAC address is not modified by the MAC.
  let ENET_TCR_ADDINS_The_1 $bool = yes // The MAC overwrites the source MAC address with the programmed MAC address according to ADDSEL.

//--- Enumerated values for register TCR, field CRCFWD
  let ENET_TCR_CRCFWD_TxBD_TC__0 $bool = no // TxBD[TC] controls whether the frame has a CRC from the application.
  let ENET_TCR_CRCFWD_The_1 $bool = yes // The transmitter does not append any CRC to transmitted frames, as it is expecting a frame with CRC from the application.

//--- Enumerated values for register TFWR, field TFWR
  let ENET_TFWR_TFWR_64_000000 $u6 = 0 // 64 bytes written.
  let ENET_TFWR_TFWR_64_000001 $u6 = 1 // 64 bytes written.
  let ENET_TFWR_TFWR_128_000010 $u6 = 2 // 128 bytes written.
  let ENET_TFWR_TFWR_192_000011 $u6 = 3 // 192 bytes written.
  let ENET_TFWR_TFWR_1984_011111 $u6 = 31 // 1984 bytes written.

//--- Enumerated values for register TFWR, field STRFWD
  let ENET_TFWR_STRFWD_Reset__0 $bool = no // Reset. The transmission start threshold is programmed in TFWR[TFWR].
  let ENET_TFWR_STRFWD_Enabled__1 $bool = yes // Enabled.

//--- Enumerated values for register TACC, field SHIFT16
  let ENET_TACC_SHIFT16_Disabled__0 $bool = no // Disabled.
  let ENET_TACC_SHIFT16_Indicates_1 $bool = yes // Indicates to the transmit data FIFO that the written frames contain two additional octets before the frame data. This means the actual frame begins at bit 16 of the first word written into the FIFO. This function allows putting the frame payload on a 32-bit boundary in memory, as the 14-byte Ethernet header is extended to a 16-byte header.

//--- Enumerated values for register TACC, field IPCHK
  let ENET_TACC_IPCHK_Checksum_0 $bool = no // Checksum is not inserted.
  let ENET_TACC_IPCHK_If_1 $bool = yes // If an IP frame is transmitted, the checksum is inserted automatically. The IP header checksum field must be cleared. If a non-IP frame is transmitted the frame is not modified.

//--- Enumerated values for register TACC, field PROCHK
  let ENET_TACC_PROCHK_Checksum_0 $bool = no // Checksum not inserted.
  let ENET_TACC_PROCHK_If_1 $bool = yes // If an IP frame with a known protocol is transmitted, the checksum is inserted automatically into the frame. The checksum field must be cleared. The other frames are not modified.

//--- Enumerated values for register RACC, field PADREM
  let ENET_RACC_PADREM_Padding_0 $bool = no // Padding not removed.
  let ENET_RACC_PADREM_Any_1 $bool = yes // Any bytes following the IP payload section of the frame are removed from the frame.

//--- Enumerated values for register RACC, field IPDIS
  let ENET_RACC_IPDIS_Frames_0 $bool = no // Frames with wrong IPv4 header checksum are not discarded.
  let ENET_RACC_IPDIS_If_1 $bool = yes // If an IPv4 frame is received with a mismatching header checksum, the frame is discarded. IPv6 has no header checksum and is not affected by this setting. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).

//--- Enumerated values for register RACC, field PRODIS
  let ENET_RACC_PRODIS_Frames_0 $bool = no // Frames with wrong checksum are not discarded.
  let ENET_RACC_PRODIS_If_1 $bool = yes // If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong TCP, UDP, or ICMP checksum, the frame is discarded. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).

//--- Enumerated values for register RACC, field LINEDIS
  let ENET_RACC_LINEDIS_Frames_0 $bool = no // Frames with errors are not discarded.
  let ENET_RACC_LINEDIS_Any_1 $bool = yes // Any frame received with a CRC, length, or PHY error is automatically discarded and not forwarded to the user application interface.

//--- Enumerated values for register RACC, field SHIFT16
  let ENET_RACC_SHIFT16_Disabled__0 $bool = no // Disabled.
  let ENET_RACC_SHIFT16_Instructs_1 $bool = yes // Instructs the MAC to write two additional bytes in front of each frame received into the RX FIFO.

//--- Enumerated values for register ATCR, field EN
  let ENET_ATCR_EN_The_0 $bool = no // The timer stops at the current value.
  let ENET_ATCR_EN_The_1 $bool = yes // The timer starts incrementing.

//--- Enumerated values for register ATCR, field OFFEN
  let ENET_ATCR_OFFEN_Disable__0 $bool = no // Disable.
  let ENET_ATCR_OFFEN_The_1 $bool = yes // The timer can be reset to zero when the given offset time is reached (offset event). The field is cleared when the offset event is reached, so no further event occurs until the field is set again. The timer offset value must be set before setting this field.

//--- Enumerated values for register ATCR, field OFFRST
  let ENET_ATCR_OFFRST_The_0 $bool = no // The timer is not affected and no action occurs, besides clearing OFFEN, when the offset is reached.
  let ENET_ATCR_OFFRST_If_1 $bool = yes // If OFFEN is set, the timer resets to zero when the offset setting is reached. The offset event does not cause a timer interrupt.

//--- Enumerated values for register ATCR, field PEREN
  let ENET_ATCR_PEREN_Disable__0 $bool = no // Disable.
  let ENET_ATCR_PEREN_A_1 $bool = yes // A period event interrupt can be generated (EIR[TS_TIMER]) and the event signal output is asserted when the timer wraps around according to the periodic setting ATPER. The timer period value must be set before setting this bit. Not all devices contain the event signal output. See the chip configuration details.

//--- Enumerated values for register ATCR, field PINPER
  let ENET_ATCR_PINPER_Disable__0 $bool = no // Disable.
  let ENET_ATCR_PINPER_Enable__1 $bool = yes // Enable.

//--- Enumerated values for register ATCR, field CAPTURE
  let ENET_ATCR_CAPTURE_No_0 $bool = no // No effect.
  let ENET_ATCR_CAPTURE_The_1 $bool = yes // The current time is captured and can be read from the ATVR register.

//--- Enumerated values for register ATCR, field SLAVE
  let ENET_ATCR_SLAVE_The_0 $bool = no // The timer is active and all configuration fields in this register are relevant.
  let ENET_ATCR_SLAVE_The_1 $bool = yes // The internal timer is disabled and the externally provided timer value is used. All other fields, except CAPTURE, in this register have no effect. CAPTURE can still be used to capture the current timer value.

//--- Enumerated values for register TGSR, field TF0
  let ENET_TGSR_TF0_Timer_0 $bool = no // Timer Flag for Channel 0 is clear
  let ENET_TGSR_TF0_Timer_1 $bool = yes // Timer Flag for Channel 0 is set

//--- Enumerated values for register TGSR, field TF1
  let ENET_TGSR_TF1_Timer_0 $bool = no // Timer Flag for Channel 1 is clear
  let ENET_TGSR_TF1_Timer_1 $bool = yes // Timer Flag for Channel 1 is set

//--- Enumerated values for register TGSR, field TF2
  let ENET_TGSR_TF2_Timer_0 $bool = no // Timer Flag for Channel 2 is clear
  let ENET_TGSR_TF2_Timer_1 $bool = yes // Timer Flag for Channel 2 is set

//--- Enumerated values for register TGSR, field TF3
  let ENET_TGSR_TF3_Timer_0 $bool = no // Timer Flag for Channel 3 is clear
  let ENET_TGSR_TF3_Timer_1 $bool = yes // Timer Flag for Channel 3 is set

//--- Enumerated values for register TCSR%s, field TDRE
  let ENET_TCSR_TDRE_DMA_0 $bool = no // DMA request is disabled
  let ENET_TCSR_TDRE_DMA_1 $bool = yes // DMA request is enabled

//--- Enumerated values for register TCSR%s, field TMODE
  let ENET_TCSR_TMODE_Timer_0000 $u4 = 0 // Timer Channel is disabled.
  let ENET_TCSR_TMODE_Timer_0001 $u4 = 1 // Timer Channel is configured for Input Capture on rising edge.
  let ENET_TCSR_TMODE_Timer_0010 $u4 = 2 // Timer Channel is configured for Input Capture on falling edge.
  let ENET_TCSR_TMODE_Timer_0011 $u4 = 3 // Timer Channel is configured for Input Capture on both edges.
  let ENET_TCSR_TMODE_Timer_0100 $u4 = 4 // Timer Channel is configured for Output Compare - software only.
  let ENET_TCSR_TMODE_Timer_0101 $u4 = 5 // Timer Channel is configured for Output Compare - toggle output on compare.
  let ENET_TCSR_TMODE_Timer_0110 $u4 = 6 // Timer Channel is configured for Output Compare - clear output on compare.
  let ENET_TCSR_TMODE_Timer_0111 $u4 = 7 // Timer Channel is configured for Output Compare - set output on compare.
  let ENET_TCSR_TMODE_Timer_1010 $u4 = 10 // Timer Channel is configured for Output Compare - clear output on compare, set output on overflow.
  let ENET_TCSR_TMODE_Timer_10X1 $u4 = 9 // Timer Channel is configured for Output Compare - set output on compare, clear output on overflow.
  let ENET_TCSR_TMODE_Timer_1110 $u4 = 14 // Timer Channel is configured for Output Compare - pulse output low on compare for one 1588-clock cycle.
  let ENET_TCSR_TMODE_Timer_1111 $u4 = 15 // Timer Channel is configured for Output Compare - pulse output high on compare for one 1588-clock cycle.

//--- Enumerated values for register TCSR%s, field TIE
  let ENET_TCSR_TIE_Interrupt_0 $bool = no // Interrupt is disabled
  let ENET_TCSR_TIE_Interrupt_1 $bool = yes // Interrupt is enabled

//--- Enumerated values for register TCSR%s, field TF
  let ENET_TCSR_TF_Input_0 $bool = no // Input Capture or Output Compare has not occurred.
  let ENET_TCSR_TF_Input_1 $bool = yes // Input Capture or Output Compare has occurred.

//------------------------------------------------------------------------------
// Peripheral EWM: External Watchdog Monitor
//------------------------------------------------------------------------------

registers ©EWM @at 0x40061000 {
//---  Register CTRL: Control Register
  CTRL @offset 0x0 $u8 {
    4
    INTEN // at 3: Interrupt Enable.
    INEN // at 2: Input Enable.
    ASSIN // at 1: EWM_in's Assertion State Select.
    EWMEN // at 0: EWM enable.
  }

//---  Register SERV: Service Register
  SERV @offset 0x1 $u8 {
    SERVICE:8 // at 0: The EWM service mechanism requires the CPU to write two values to the SERV register: a first data byte of 0xB4, followed by a second data byte of 0x2C
  }

//---  Register CMPL: Compare Low Register
  CMPL @offset 0x2 $u8 {
    COMPAREL:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) minimum service time is required
  }

//---  Register CMPH: Compare High Register
  CMPH @offset 0x3 $u8 {
    COMPAREH:8 // at 0: To prevent runaway code from changing this field, software should write to this field after a CPU reset even if the (default) maximum service time is required
  }

}

//------------------------------------------------------------------------------
// Peripheral FB: FlexBus external bus interface
//------------------------------------------------------------------------------

registers ©FB @at 0x4000c000 {
//---  Registers CSAR(0,1,2,3,4,5): Chip Select Address Register
  CSAR [6 @offset 0x0 @inc 0xc]
  CSAR0 @offset 0x0
  CSAR1 @offset 0xc
  CSAR2 @offset 0x18
  CSAR3 @offset 0x24
  CSAR4 @offset 0x30
  CSAR5 @offset 0x3c $u32 {
    BA:16 // at 16: Base Address
    16
  }

//---  Registers CSMR(0,1,2,3,4,5): Chip Select Mask Register
  CSMR [6 @offset 0x4 @inc 0xc]
  CSMR0 @offset 0x4
  CSMR1 @offset 0x10
  CSMR2 @offset 0x1c
  CSMR3 @offset 0x28
  CSMR4 @offset 0x34
  CSMR5 @offset 0x40 $u32 {
    BAM:16 // at 16: Base Address Mask
    7
    WP // at 8: Write Protect
    7
    V // at 0: Valid
  }

//---  Registers CSCR(0,1,2,3,4,5): Chip Select Control Register
  CSCR [6 @offset 0x8 @inc 0xc]
  CSCR0 @offset 0x8
  CSCR1 @offset 0x14
  CSCR2 @offset 0x20
  CSCR3 @offset 0x2c
  CSCR4 @offset 0x38
  CSCR5 @offset 0x44 $u32 {
    SWS:6 // at 26: Secondary Wait States
    2
    SWSEN // at 23: Secondary Wait State Enable
    EXTS // at 22: Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS /FB_ALE is asserted.
    ASET:2 // at 20: Address Setup
    RDAH:2 // at 18: Read Address Hold or Deselect
    WRAH:2 // at 16: Write Address Hold or Deselect
    WS:6 // at 10: Wait States
    BLS // at 9: Byte-Lane Shift
    AA // at 8: Auto-Acknowledge Enable
    PS:2 // at 6: Port Size
    BEM // at 5: Byte-Enable Mode
    BSTR // at 4: Burst-Read Enable
    BSTW // at 3: Burst-Write Enable
    3
  }

//---  Register CSPMCR: Chip Select port Multiplexing Control Register
  CSPMCR @offset 0x60 $u32 {
    GROUP1:4 // at 28: FlexBus Signal Group 1 Multiplex control
    GROUP2:4 // at 24: FlexBus Signal Group 2 Multiplex control
    GROUP3:4 // at 20: FlexBus Signal Group 3 Multiplex control
    GROUP4:4 // at 16: FlexBus Signal Group 4 Multiplex control
    GROUP5:4 // at 12: FlexBus Signal Group 5 Multiplex control
    12
  }

}

//--- Enumerated values for register CSMR%s, field V
  let FB_CSMR_V_Chip_select_0 $bool = no // Chip-select is invalid.
  let FB_CSMR_V_Chip_select_1 $bool = yes // Chip-select is valid.

//--- Enumerated values for register CSMR%s, field WP
  let FB_CSMR_WP_Write_0 $bool = no // Write accesses are allowed.
  let FB_CSMR_WP_Write_1 $bool = yes // Write accesses are not allowed. Attempting to write to the range of addresses for which the WP bit is set results in a bus error termination of the internal cycle and no external cycle.

//--- Enumerated values for register CSMR%s, field BAM
  let FB_CSMR_BAM_The_0 $u16 = 0 // The corresponding address bit in CSAR is used in the chip-select decode.
  let FB_CSMR_BAM_The_1 $u16 = 1 // The corresponding address bit in CSAR is a don't care in the chip-select decode.

//--- Enumerated values for register CSCR%s, field BSTW
  let FB_CSCR_BSTW_Disabled__0 $bool = no // Disabled. Data exceeding the specified port size is broken into individual, port-sized, non-burst writes. For example, a 32-bit write to an 8-bit port takes four byte writes.
  let FB_CSCR_BSTW_Enabled__1 $bool = yes // Enabled. Enables burst write of data larger than the specified port size, including 32-bit writes to 8- and 16-bit ports, 16-bit writes to 8-bit ports, and line writes to 8-, 16-, and 32-bit ports.

//--- Enumerated values for register CSCR%s, field BSTR
  let FB_CSCR_BSTR_Disabled__0 $bool = no // Disabled. Data exceeding the specified port size is broken into individual, port-sized, non-burst reads. For example, a 32-bit read from an 8-bit port is broken into four 8-bit reads.
  let FB_CSCR_BSTR_Enabled__1 $bool = yes // Enabled. Enables data burst reads larger than the specified port size, including 32-bit reads from 8- and 16-bit ports, 16-bit reads from 8-bit ports, and line reads from 8-, 16-, and 32-bit ports.

//--- Enumerated values for register CSCR%s, field BEM
  let FB_CSCR_BEM_FB_BE_0 $bool = no // FB_BE is asserted for data write only.
  let FB_CSCR_BEM_FB_BE_1 $bool = yes // FB_BE is asserted for data read and write accesses.

//--- Enumerated values for register CSCR%s, field PS
  let FB_CSCR_PS_32_bit_00 $u2 = 0 // 32-bit port size. Valid data is sampled and driven on FB_D[31:0].
  let FB_CSCR_PS_8_bit_01 $u2 = 1 // 8-bit port size. Valid data is sampled and driven on FB_D[31:24] when BLS is 0b, or FB_D[7:0] when BLS is 1b.
  let FB_CSCR_PS_16_bit_1X $u2 = 2 // 16-bit port size. Valid data is sampled and driven on FB_D[31:16] when BLS is 0b, or FB_D[15:0] when BLS is 1b.

//--- Enumerated values for register CSCR%s, field AA
  let FB_CSCR_AA_Disabled__0 $bool = no // Disabled. No internal transfer acknowledge is asserted and the cycle is terminated externally.
  let FB_CSCR_AA_Enabled__1 $bool = yes // Enabled. Internal transfer acknowledge is asserted as specified by WS.

//--- Enumerated values for register CSCR%s, field BLS
  let FB_CSCR_BLS_Not_0 $bool = no // Not shifted. Data is left-aligned on FB_AD.
  let FB_CSCR_BLS_Shifted__1 $bool = yes // Shifted. Data is right-aligned on FB_AD.

//--- Enumerated values for register CSCR%s, field WRAH
  let FB_CSCR_WRAH_1_00 $u2 = 0 // 1 cycle (default for all but FB_CS0 )
  let FB_CSCR_WRAH_2_01 $u2 = 1 // 2 cycles
  let FB_CSCR_WRAH_3_10 $u2 = 2 // 3 cycles
  let FB_CSCR_WRAH_4_11 $u2 = 3 // 4 cycles (default for FB_CS0 )

//--- Enumerated values for register CSCR%s, field RDAH
  let FB_CSCR_RDAH_When_00 $u2 = 0 // When AA is 1b, 1 cycle. When AA is 0b, 0 cycles.
  let FB_CSCR_RDAH_When_01 $u2 = 1 // When AA is 1b, 2 cycles. When AA is 0b, 1 cycle.
  let FB_CSCR_RDAH_When_10 $u2 = 2 // When AA is 1b, 3 cycles. When AA is 0b, 2 cycles.
  let FB_CSCR_RDAH_When_11 $u2 = 3 // When AA is 1b, 4 cycles. When AA is 0b, 3 cycles.

//--- Enumerated values for register CSCR%s, field ASET
  let FB_CSCR_ASET_Assert_00 $u2 = 0 // Assert FB_CSn on the first rising clock edge after the address is asserted (default for all but FB_CS0 ).
  let FB_CSCR_ASET_Assert_01 $u2 = 1 // Assert FB_CSn on the second rising clock edge after the address is asserted.
  let FB_CSCR_ASET_Assert_10 $u2 = 2 // Assert FB_CSn on the third rising clock edge after the address is asserted.
  let FB_CSCR_ASET_Assert_11 $u2 = 3 // Assert FB_CSn on the fourth rising clock edge after the address is asserted (default for FB_CS0 ).

//--- Enumerated values for register CSCR%s, field EXTS
  let FB_CSCR_EXTS_Disabled__0 $bool = no // Disabled. FB_TS /FB_ALE asserts for one bus clock cycle.
  let FB_CSCR_EXTS_Enabled__1 $bool = yes // Enabled. FB_TS /FB_ALE remains asserted until the first positive clock edge after FB_CSn asserts.

//--- Enumerated values for register CSCR%s, field SWSEN
  let FB_CSCR_SWSEN_Disabled__0 $bool = no // Disabled. A number of wait states (specified by WS) are inserted before an internal transfer acknowledge is generated for all transfers.
  let FB_CSCR_SWSEN_Enabled__1 $bool = yes // Enabled. A number of wait states (specified by SWS) are inserted before an internal transfer acknowledge is generated for burst transfer secondary terminations.

//--- Enumerated values for register CSPMCR, field GROUP5
  let FB_CSPMCR_GROUP5_FB_TA_0000 $u4 = 0 // FB_TA
  let FB_CSPMCR_GROUP5_FB_CS3_0001 $u4 = 1 // FB_CS3 . You must also write 1b to CSCR[AA].
  let FB_CSPMCR_GROUP5_FB_BE_7_0_0010 $u4 = 2 // FB_BE_7_0 . You must also write 1b to CSCR[AA].

//--- Enumerated values for register CSPMCR, field GROUP4
  let FB_CSPMCR_GROUP4_FB_TBST_0000 $u4 = 0 // FB_TBST
  let FB_CSPMCR_GROUP4_FB_CS2_0001 $u4 = 1 // FB_CS2
  let FB_CSPMCR_GROUP4_FB_BE_15_8_0010 $u4 = 2 // FB_BE_15_8

//--- Enumerated values for register CSPMCR, field GROUP3
  let FB_CSPMCR_GROUP3_FB_CS5_0000 $u4 = 0 // FB_CS5
  let FB_CSPMCR_GROUP3_FB_TSIZ1_0001 $u4 = 1 // FB_TSIZ1
  let FB_CSPMCR_GROUP3_FB_BE_23_16_0010 $u4 = 2 // FB_BE_23_16

//--- Enumerated values for register CSPMCR, field GROUP2
  let FB_CSPMCR_GROUP2_FB_CS4_0000 $u4 = 0 // FB_CS4
  let FB_CSPMCR_GROUP2_FB_TSIZ0_0001 $u4 = 1 // FB_TSIZ0
  let FB_CSPMCR_GROUP2_FB_BE_31_24_0010 $u4 = 2 // FB_BE_31_24

//--- Enumerated values for register CSPMCR, field GROUP1
  let FB_CSPMCR_GROUP1_FB_ALE_0000 $u4 = 0 // FB_ALE
  let FB_CSPMCR_GROUP1_FB_CS1_0001 $u4 = 1 // FB_CS1
  let FB_CSPMCR_GROUP1_FB_TS_0010 $u4 = 2 // FB_TS

//------------------------------------------------------------------------------
// Peripheral FMC: Flash Memory Controller-greg
//------------------------------------------------------------------------------

registers ©FMC @at 0x4001f000 {
//---  Register PFAPR: Flash Access Protection Register
  PFAPR @offset 0x0 $u32 {
    8
    M7PFD // at 23: Master 7 Prefetch Disable
    M6PFD // at 22: Master 6 Prefetch Disable
    M5PFD // at 21: Master 5 Prefetch Disable
    M4PFD // at 20: Master 4 Prefetch Disable
    M3PFD // at 19: Master 3 Prefetch Disable
    M2PFD // at 18: Master 2 Prefetch Disable
    M1PFD // at 17: Master 1 Prefetch Disable
    M0PFD // at 16: Master 0 Prefetch Disable
    M7AP:2 // at 14: Master 7 Access Protection
    M6AP:2 // at 12: Master 6 Access Protection
    M5AP:2 // at 10: Master 5 Access Protection
    M4AP:2 // at 8: Master 4 Access Protection
    M3AP:2 // at 6: Master 3 Access Protection
    M2AP:2 // at 4: Master 2 Access Protection
    M1AP:2 // at 2: Master 1 Access Protection
    M0AP:2 // at 0: Master 0 Access Protection
  }

//---  Register PFB01CR: Flash Bank 0-1 Control Register
  PFB01CR @offset 0x4 $u32 {
    B0RWSC:4 // at 28: Bank 0 Read Wait State Control
    CLCK_WAY:4 // at 24: Cache Lock Way x
    CINV_WAY:4 // at 20: Cache Invalidate Way x
    S_B_INV // at 19: Invalidate Prefetch Speculation Buffer
    B0MW:2 // at 17: Bank 0 Memory Width
    9
    CRC:3 // at 5: Cache Replacement Control
    B0DCE // at 4: Bank 0 Data Cache Enable
    B0ICE // at 3: Bank 0 Instruction Cache Enable
    B0DPE // at 2: Bank 0 Data Prefetch Enable
    B0IPE // at 1: Bank 0 Instruction Prefetch Enable
    RFU // at 0: Reserved for future use
  }

//---  Register PFB23CR: Flash Bank 2-3 Control Register
  PFB23CR @offset 0x8 $u32 {
    B1RWSC:4 // at 28: Bank 1 Read Wait State Control
    9
    B1MW:2 // at 17: Bank 1 Memory Width
    12
    B1DCE // at 4: Bank 1 Data Cache Enable
    B1ICE // at 3: Bank 1 Instruction Cache Enable
    B1DPE // at 2: Bank 1 Data Prefetch Enable
    B1IPE // at 1: Bank 1 Instruction Prefetch Enable
    RFU // at 0: Reserved for future use
  }

//---  Registers TAGVDW0S(0,1,2,3): Cache Tag Storage
  TAGVDW0S [4 @offset 0x100 @inc 0x4]
  TAGVDW0S0 @offset 0x100
  TAGVDW0S1 @offset 0x104
  TAGVDW0S2 @offset 0x108
  TAGVDW0S3 @offset 0x10c $u32 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW1S(0,1,2,3): Cache Tag Storage
  TAGVDW1S [4 @offset 0x110 @inc 0x4]
  TAGVDW1S0 @offset 0x110
  TAGVDW1S1 @offset 0x114
  TAGVDW1S2 @offset 0x118
  TAGVDW1S3 @offset 0x11c $u32 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW2S(0,1,2,3): Cache Tag Storage
  TAGVDW2S [4 @offset 0x120 @inc 0x4]
  TAGVDW2S0 @offset 0x120
  TAGVDW2S1 @offset 0x124
  TAGVDW2S2 @offset 0x128
  TAGVDW2S3 @offset 0x12c $u32 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers TAGVDW3S(0,1,2,3): Cache Tag Storage
  TAGVDW3S [4 @offset 0x130 @inc 0x4]
  TAGVDW3S0 @offset 0x130
  TAGVDW3S1 @offset 0x134
  TAGVDW3S2 @offset 0x138
  TAGVDW3S3 @offset 0x13c $u32 {
    10
    tag:16 // at 6: 16-bit tag for cache entry
    5
    valid // at 0: 1-bit valid for cache entry
  }

//---  Registers DATAW0SUM(0,1,2,3): Cache Data Storage (uppermost word)
  DATAW0SUM [4 @offset 0x200 @inc 0x10]
  DATAW0S0UM @offset 0x200
  DATAW0S1UM @offset 0x210
  DATAW0S2UM @offset 0x220
  DATAW0S3UM @offset 0x230 $u32 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW0SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  DATAW0SMU [4 @offset 0x204 @inc 0x10]
  DATAW0S0MU @offset 0x204
  DATAW0S1MU @offset 0x214
  DATAW0S2MU @offset 0x224
  DATAW0S3MU @offset 0x234 $u32 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW0SML(0,1,2,3): Cache Data Storage (mid-lower word)
  DATAW0SML [4 @offset 0x208 @inc 0x10]
  DATAW0S0ML @offset 0x208
  DATAW0S1ML @offset 0x218
  DATAW0S2ML @offset 0x228
  DATAW0S3ML @offset 0x238 $u32 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW0SLM(0,1,2,3): Cache Data Storage (lowermost word)
  DATAW0SLM [4 @offset 0x20c @inc 0x10]
  DATAW0S0LM @offset 0x20c
  DATAW0S1LM @offset 0x21c
  DATAW0S2LM @offset 0x22c
  DATAW0S3LM @offset 0x23c $u32 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW1SUM(0,1,2,3): Cache Data Storage (uppermost word)
  DATAW1SUM [4 @offset 0x240 @inc 0x10]
  DATAW1S0UM @offset 0x240
  DATAW1S1UM @offset 0x250
  DATAW1S2UM @offset 0x260
  DATAW1S3UM @offset 0x270 $u32 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW1SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  DATAW1SMU [4 @offset 0x244 @inc 0x10]
  DATAW1S0MU @offset 0x244
  DATAW1S1MU @offset 0x254
  DATAW1S2MU @offset 0x264
  DATAW1S3MU @offset 0x274 $u32 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW1SML(0,1,2,3): Cache Data Storage (mid-lower word)
  DATAW1SML [4 @offset 0x248 @inc 0x10]
  DATAW1S0ML @offset 0x248
  DATAW1S1ML @offset 0x258
  DATAW1S2ML @offset 0x268
  DATAW1S3ML @offset 0x278 $u32 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW1SLM(0,1,2,3): Cache Data Storage (lowermost word)
  DATAW1SLM [4 @offset 0x24c @inc 0x10]
  DATAW1S0LM @offset 0x24c
  DATAW1S1LM @offset 0x25c
  DATAW1S2LM @offset 0x26c
  DATAW1S3LM @offset 0x27c $u32 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW2SUM(0,1,2,3): Cache Data Storage (uppermost word)
  DATAW2SUM [4 @offset 0x280 @inc 0x10]
  DATAW2S0UM @offset 0x280
  DATAW2S1UM @offset 0x290
  DATAW2S2UM @offset 0x2a0
  DATAW2S3UM @offset 0x2b0 $u32 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW2SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  DATAW2SMU [4 @offset 0x284 @inc 0x10]
  DATAW2S0MU @offset 0x284
  DATAW2S1MU @offset 0x294
  DATAW2S2MU @offset 0x2a4
  DATAW2S3MU @offset 0x2b4 $u32 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW2SML(0,1,2,3): Cache Data Storage (mid-lower word)
  DATAW2SML [4 @offset 0x288 @inc 0x10]
  DATAW2S0ML @offset 0x288
  DATAW2S1ML @offset 0x298
  DATAW2S2ML @offset 0x2a8
  DATAW2S3ML @offset 0x2b8 $u32 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW2SLM(0,1,2,3): Cache Data Storage (lowermost word)
  DATAW2SLM [4 @offset 0x28c @inc 0x10]
  DATAW2S0LM @offset 0x28c
  DATAW2S1LM @offset 0x29c
  DATAW2S2LM @offset 0x2ac
  DATAW2S3LM @offset 0x2bc $u32 {
    data:32 // at 0: Bits [31:0] of data entry
  }

//---  Registers DATAW3SUM(0,1,2,3): Cache Data Storage (uppermost word)
  DATAW3SUM [4 @offset 0x2c0 @inc 0x10]
  DATAW3S0UM @offset 0x2c0
  DATAW3S1UM @offset 0x2d0
  DATAW3S2UM @offset 0x2e0
  DATAW3S3UM @offset 0x2f0 $u32 {
    data:32 // at 0: Bits [127:96] of data entry
  }

//---  Registers DATAW3SMU(0,1,2,3): Cache Data Storage (mid-upper word)
  DATAW3SMU [4 @offset 0x2c4 @inc 0x10]
  DATAW3S0MU @offset 0x2c4
  DATAW3S1MU @offset 0x2d4
  DATAW3S2MU @offset 0x2e4
  DATAW3S3MU @offset 0x2f4 $u32 {
    data:32 // at 0: Bits [95:64] of data entry
  }

//---  Registers DATAW3SML(0,1,2,3): Cache Data Storage (mid-lower word)
  DATAW3SML [4 @offset 0x2c8 @inc 0x10]
  DATAW3S0ML @offset 0x2c8
  DATAW3S1ML @offset 0x2d8
  DATAW3S2ML @offset 0x2e8
  DATAW3S3ML @offset 0x2f8 $u32 {
    data:32 // at 0: Bits [63:32] of data entry
  }

//---  Registers DATAW3SLM(0,1,2,3): Cache Data Storage (lowermost word)
  DATAW3SLM [4 @offset 0x2cc @inc 0x10]
  DATAW3S0LM @offset 0x2cc
  DATAW3S1LM @offset 0x2dc
  DATAW3S2LM @offset 0x2ec
  DATAW3S3LM @offset 0x2fc $u32 {
    data:32 // at 0: Bits [31:0] of data entry
  }

}

//--- Enumerated values for register PFAPR, field M0AP
  let FMC_PFAPR_M0AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M0AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M0AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M0AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M1AP
  let FMC_PFAPR_M1AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M1AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M1AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M1AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M2AP
  let FMC_PFAPR_M2AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M2AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M2AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M2AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M3AP
  let FMC_PFAPR_M3AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M3AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M3AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M3AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M4AP
  let FMC_PFAPR_M4AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M4AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M4AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M4AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M5AP
  let FMC_PFAPR_M5AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M5AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M5AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M5AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M6AP
  let FMC_PFAPR_M6AP_No_00 $u2 = 0 // No access may be performed by this master
  let FMC_PFAPR_M6AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master
  let FMC_PFAPR_M6AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master
  let FMC_PFAPR_M6AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master

//--- Enumerated values for register PFAPR, field M7AP
  let FMC_PFAPR_M7AP_No_00 $u2 = 0 // No access may be performed by this master.
  let FMC_PFAPR_M7AP_Only_01 $u2 = 1 // Only read accesses may be performed by this master.
  let FMC_PFAPR_M7AP_Only_10 $u2 = 2 // Only write accesses may be performed by this master.
  let FMC_PFAPR_M7AP_Both_11 $u2 = 3 // Both read and write accesses may be performed by this master.

//--- Enumerated values for register PFAPR, field M0PFD
  let FMC_PFAPR_M0PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M0PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M1PFD
  let FMC_PFAPR_M1PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M1PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M2PFD
  let FMC_PFAPR_M2PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M2PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M3PFD
  let FMC_PFAPR_M3PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M3PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M4PFD
  let FMC_PFAPR_M4PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M4PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M5PFD
  let FMC_PFAPR_M5PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M5PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M6PFD
  let FMC_PFAPR_M6PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M6PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFAPR, field M7PFD
  let FMC_PFAPR_M7PFD_Prefetching_0 $bool = no // Prefetching for this master is enabled.
  let FMC_PFAPR_M7PFD_Prefetching_1 $bool = yes // Prefetching for this master is disabled.

//--- Enumerated values for register PFB01CR, field B0IPE
  let FMC_PFB01CR_B0IPE_Do_0 $bool = no // Do not prefetch in response to instruction fetches.
  let FMC_PFB01CR_B0IPE_Enable_1 $bool = yes // Enable prefetches in response to instruction fetches.

//--- Enumerated values for register PFB01CR, field B0DPE
  let FMC_PFB01CR_B0DPE_Do_0 $bool = no // Do not prefetch in response to data references.
  let FMC_PFB01CR_B0DPE_Enable_1 $bool = yes // Enable prefetches in response to data references.

//--- Enumerated values for register PFB01CR, field B0ICE
  let FMC_PFB01CR_B0ICE_Do_0 $bool = no // Do not cache instruction fetches.
  let FMC_PFB01CR_B0ICE_Cache_1 $bool = yes // Cache instruction fetches.

//--- Enumerated values for register PFB01CR, field B0DCE
  let FMC_PFB01CR_B0DCE_Do_0 $bool = no // Do not cache data references.
  let FMC_PFB01CR_B0DCE_Cache_1 $bool = yes // Cache data references.

//--- Enumerated values for register PFB01CR, field CRC
  let FMC_PFB01CR_CRC_LRU_000 $u3 = 0 // LRU replacement algorithm per set across all four ways
  let FMC_PFB01CR_CRC_Independent_010 $u3 = 2 // Independent LRU with ways [0-1] for ifetches, [2-3] for data
  let FMC_PFB01CR_CRC_Independent_011 $u3 = 3 // Independent LRU with ways [0-2] for ifetches, [3] for data

//--- Enumerated values for register PFB01CR, field B0MW
  let FMC_PFB01CR_B0MW_32_00 $u2 = 0 // 32 bits
  let FMC_PFB01CR_B0MW_64_01 $u2 = 1 // 64 bits
  let FMC_PFB01CR_B0MW_128_10 $u2 = 2 // 128 bits

//--- Enumerated values for register PFB01CR, field S_B_INV
  let FMC_PFB01CR_S_B_INV_Speculation_0 $bool = no // Speculation buffer is not affected
  let FMC_PFB01CR_S_B_INV_Invalidate_1 $bool = yes // Invalidate (clear) speculation buffer

//--- Enumerated values for register PFB01CR, field CINV_WAY
  let FMC_PFB01CR_CINV_WAY_No_0 $u4 = 0 // No cache way invalidation for the corresponding cache
  let FMC_PFB01CR_CINV_WAY_Invalidate_1 $u4 = 1 // Invalidate cache way for the corresponding cache: clear the tag, data, and vld bits of ways selected

//--- Enumerated values for register PFB01CR, field CLCK_WAY
  let FMC_PFB01CR_CLCK_WAY_Cache_0 $u4 = 0 // Cache way is unlocked and may be displaced
  let FMC_PFB01CR_CLCK_WAY_Cache_1 $u4 = 1 // Cache way is locked and its contents are not displaced

//--- Enumerated values for register PFB23CR, field B1IPE
  let FMC_PFB23CR_B1IPE_Do_0 $bool = no // Do not prefetch in response to instruction fetches.
  let FMC_PFB23CR_B1IPE_Enable_1 $bool = yes // Enable prefetches in response to instruction fetches.

//--- Enumerated values for register PFB23CR, field B1DPE
  let FMC_PFB23CR_B1DPE_Do_0 $bool = no // Do not prefetch in response to data references.
  let FMC_PFB23CR_B1DPE_Enable_1 $bool = yes // Enable prefetches in response to data references.

//--- Enumerated values for register PFB23CR, field B1ICE
  let FMC_PFB23CR_B1ICE_Do_0 $bool = no // Do not cache instruction fetches.
  let FMC_PFB23CR_B1ICE_Cache_1 $bool = yes // Cache instruction fetches.

//--- Enumerated values for register PFB23CR, field B1DCE
  let FMC_PFB23CR_B1DCE_Do_0 $bool = no // Do not cache data references.
  let FMC_PFB23CR_B1DCE_Cache_1 $bool = yes // Cache data references.

//--- Enumerated values for register PFB23CR, field B1MW
  let FMC_PFB23CR_B1MW_32_00 $u2 = 0 // 32 bits
  let FMC_PFB23CR_B1MW_64_01 $u2 = 1 // 64 bits
  let FMC_PFB23CR_B1MW_128_10 $u2 = 2 // 128 bits

//------------------------------------------------------------------------------
// Peripheral FTFE: Flash Memory Interface
//------------------------------------------------------------------------------

registers ©FTFE @at 0x40020000 {
//---  Register FSTAT: Flash Status Register
  FSTAT @offset 0x0 $u8 {
    CCIF // at 7: Command Complete Interrupt Flag
    RDCOLERR // at 6: FTFE Read Collision Error Flag
    ACCERR // at 5: Flash Access Error Flag
    FPVIOL // at 4: Flash Protection Violation Flag
    3
    MGSTAT0 // at 0: Memory Controller Command Completion Status Flag
  }

//---  Register FCNFG: Flash Configuration Register
  FCNFG @offset 0x1 $u8 {
    CCIE // at 7: Command Complete Interrupt Enable
    RDCOLLIE // at 6: Read Collision Error Interrupt Enable
    ERSAREQ // at 5: Erase All Request
    ERSSUSP // at 4: Erase Suspend
    SWAP // at 3: Swap
    PFLSH // at 2: FTFE configuration
    RAMRDY // at 1: RAM Ready
    EEERDY // at 0: For devices with FlexNVM: This flag indicates if the EEPROM backup data has been copied to the FlexRAM and is therefore available for read access
  }

//---  Register FSEC: Flash Security Register
  FSEC @offset 0x2 @ro $u8 {
    KEYEN:2 // at 6: Backdoor Key Security Enable
    MEEN:2 // at 4: Mass Erase Enable Bits
    FSLACC:2 // at 2: Freescale Failure Analysis Access Code
    SEC:2 // at 0: Flash Security
  }

//---  Register FOPT: Flash Option Register
  FOPT @offset 0x3 @ro $u8 {
    OPT:8 // at 0: Nonvolatile Option
  }

//---  Register FCCOB_0_3: Flash Common Command Object Registers (0 ... 3)
  FCCOB_0_3 @offset 0x4 $u32
//---  Register FCCOB_4_7: Flash Common Command Object Registers (4 ... 7)
  FCCOB_4_7 @offset 0x8 $u32
//---  Register FCCOB_8_11: Flash Common Command Object Registers (8 ... 11)
  FCCOB_8_11 @offset 0xc $u32
//---  Registers FPROT(3,2,1,0): Program Flash Protection Registers
  FPROT [4 @offset 0x10 @inc 0x1]
  FPROT3 @offset 0x10
  FPROT2 @offset 0x11
  FPROT1 @offset 0x12
  FPROT0 @offset 0x13 $u8 {
    PROT:8 // at 0: Program Flash Region Protect
  }

//---  Register FEPROT: EEPROM Protection Register
  FEPROT @offset 0x16 $u8 {
    EPROT:8 // at 0: EEPROM Region Protect
  }

//---  Register FDPROT: Data Flash Protection Register
  FDPROT @offset 0x17 $u8 {
    DPROT:8 // at 0: Data Flash Region Protect
  }

//---  Registers XACC(H3,H2,H1,H0,L3,L2,L1,L0): Execute-only Access Registers
  XACC [8 @offset 0x18 @inc 0x1]
  XACCH3 @offset 0x18
  XACCH2 @offset 0x19
  XACCH1 @offset 0x1a
  XACCH0 @offset 0x1b
  XACCL3 @offset 0x1c
  XACCL2 @offset 0x1d
  XACCL1 @offset 0x1e
  XACCL0 @offset 0x1f @ro $u8 {
    XA:8 // at 0: Execute-only access control
  }

//---  Registers SACC(H3,H2,H1,H0,L3,L2,L1,L0): Supervisor-only Access Registers
  SACC [8 @offset 0x20 @inc 0x1]
  SACCH3 @offset 0x20
  SACCH2 @offset 0x21
  SACCH1 @offset 0x22
  SACCH0 @offset 0x23
  SACCL3 @offset 0x24
  SACCL2 @offset 0x25
  SACCL1 @offset 0x26
  SACCL0 @offset 0x27 @ro $u8 {
    SA:8 // at 0: Supervisor-only access control
  }

//---  Register FACSS: Flash Access Segment Size Register
  FACSS @offset 0x28 @ro $u8 {
    SGSIZE:8 // at 0: Segment Size
  }

//---  Register FACSN: Flash Access Segment Number Register
  FACSN @offset 0x2b @ro $u8 {
    NUMSG:8 // at 0: Number of Segments Indicator
  }

}

//--- Enumerated values for register FSTAT, field FPVIOL
  let FTFE_FSTAT_FPVIOL_No_0 $bool = no // No protection violation detected
  let FTFE_FSTAT_FPVIOL_Protection_1 $bool = yes // Protection violation detected

//--- Enumerated values for register FSTAT, field ACCERR
  let FTFE_FSTAT_ACCERR_No_0 $bool = no // No access error detected
  let FTFE_FSTAT_ACCERR_Access_1 $bool = yes // Access error detected

//--- Enumerated values for register FSTAT, field RDCOLERR
  let FTFE_FSTAT_RDCOLERR_No_0 $bool = no // No collision error detected
  let FTFE_FSTAT_RDCOLERR_Collision_1 $bool = yes // Collision error detected

//--- Enumerated values for register FSTAT, field CCIF
  let FTFE_FSTAT_CCIF_FTFE_0 $bool = no // FTFE command or EEPROM file system operation in progress
  let FTFE_FSTAT_CCIF_FTFE_1 $bool = yes // FTFE command or EEPROM file system operation has completed

//--- Enumerated values for register FCNFG, field EEERDY
  let FTFE_FCNFG_EEERDY_For_0 $bool = no // For devices with FlexNVM: FlexRAM is not available for EEPROM operation For devices without FlexNVM: See RAMRDY for availability of programming acceleration RAM
  let FTFE_FCNFG_EEERDY_For_1 $bool = yes // For devices with FlexNVM: FlexRAM is available for EEPROM operations where: reads from the FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes launch an EEPROM operation to store the written data in the FlexRAM and EEPROM backup For devices without FlexNVM: Reserved

//--- Enumerated values for register FCNFG, field RAMRDY
  let FTFE_FCNFG_RAMRDY_For_0 $bool = no // For devices with FlexNVM: FlexRAM is not available for traditional RAM access For devices without FlexNVM: Programming acceleration RAM is not available
  let FTFE_FCNFG_RAMRDY_For_1 $bool = yes // For devices with FlexNVM: FlexRAM is available as traditional RAM only; writes to the FlexRAM do not trigger EEPROM operations For devices without FlexNVM: Programming acceleration RAM is available

//--- Enumerated values for register FCNFG, field PFLSH
  let FTFE_FCNFG_PFLSH_For_0 $bool = no // For devices with FlexNVM: FTFE configuration supports two or three program flash blocks and two FlexNVM blocks For devices with program flash only: Reserved
  let FTFE_FCNFG_PFLSH_For_1 $bool = yes // For devices with FlexNVM: Reserved For devices with program flash only: FTFE configuration supports four program flash blocks

//--- Enumerated values for register FCNFG, field SWAP
  let FTFE_FCNFG_SWAP_For_0 $bool = no // For devices with FlexNVM: Program flash 0 block is located at relative address 0x0000 For devices with program flash only: Program flash 0/1 blocks are located at relative address 0x0000
  let FTFE_FCNFG_SWAP_For_1 $bool = yes // For devices with FlexNVM: Reserved For devices with program flash only: Program flash 2/3 blocks are located at relative address 0x0000

//--- Enumerated values for register FCNFG, field ERSSUSP
  let FTFE_FCNFG_ERSSUSP_No_0 $bool = no // No suspend requested
  let FTFE_FCNFG_ERSSUSP_Suspend_1 $bool = yes // Suspend the current Erase Flash Sector command execution

//--- Enumerated values for register FCNFG, field ERSAREQ
  let FTFE_FCNFG_ERSAREQ_No_0 $bool = no // No request or request complete
  let FTFE_FCNFG_ERSAREQ_Request_1 $bool = yes // Request to: run the Erase All Blocks command, verify the erased state, program the security byte in the Flash Configuration Field to the unsecure state, and release MCU security by setting the FSEC[SEC] field to the unsecure state

//--- Enumerated values for register FCNFG, field RDCOLLIE
  let FTFE_FCNFG_RDCOLLIE_Read_0 $bool = no // Read collision error interrupt disabled
  let FTFE_FCNFG_RDCOLLIE_Read_1 $bool = yes // Read collision error interrupt enabled. An interrupt request is generated whenever an FTFE read collision error is detected (see the description of FSTAT[RDCOLERR]).

//--- Enumerated values for register FCNFG, field CCIE
  let FTFE_FCNFG_CCIE_Command_0 $bool = no // Command complete interrupt disabled
  let FTFE_FCNFG_CCIE_Command_1 $bool = yes // Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT[CCIF] flag is set.

//--- Enumerated values for register FSEC, field SEC
  let FTFE_FSEC_SEC_MCU_00 $u2 = 0 // MCU security status is secure
  let FTFE_FSEC_SEC_MCU_01 $u2 = 1 // MCU security status is secure
  let FTFE_FSEC_SEC_MCU_10 $u2 = 2 // MCU security status is unsecure (The standard shipping condition of the FTFE is unsecure.)
  let FTFE_FSEC_SEC_MCU_11 $u2 = 3 // MCU security status is secure

//--- Enumerated values for register FSEC, field FSLACC
  let FTFE_FSEC_FSLACC_Freescale_00 $u2 = 0 // Freescale factory access granted
  let FTFE_FSEC_FSLACC_Freescale_01 $u2 = 1 // Freescale factory access denied
  let FTFE_FSEC_FSLACC_Freescale_10 $u2 = 2 // Freescale factory access denied
  let FTFE_FSEC_FSLACC_Freescale_11 $u2 = 3 // Freescale factory access granted

//--- Enumerated values for register FSEC, field MEEN
  let FTFE_FSEC_MEEN_Mass_00 $u2 = 0 // Mass erase is enabled
  let FTFE_FSEC_MEEN_Mass_01 $u2 = 1 // Mass erase is enabled
  let FTFE_FSEC_MEEN_Mass_10 $u2 = 2 // Mass erase is disabled
  let FTFE_FSEC_MEEN_Mass_11 $u2 = 3 // Mass erase is enabled

//--- Enumerated values for register FSEC, field KEYEN
  let FTFE_FSEC_KEYEN_Backdoor_00 $u2 = 0 // Backdoor key access disabled
  let FTFE_FSEC_KEYEN_Backdoor_01 $u2 = 1 // Backdoor key access disabled (preferred KEYEN state to disable backdoor key access)
  let FTFE_FSEC_KEYEN_Backdoor_10 $u2 = 2 // Backdoor key access enabled
  let FTFE_FSEC_KEYEN_Backdoor_11 $u2 = 3 // Backdoor key access disabled

//--- Enumerated values for register FPROT%s, field PROT
  let FTFE_FPROT_PROT_Program_0 $u8 = 0 // Program flash region is protected.
  let FTFE_FPROT_PROT_Program_1 $u8 = 1 // Program flash region is not protected

//--- Enumerated values for register FEPROT, field EPROT
  let FTFE_FEPROT_EPROT_For_0 $u8 = 0 // For devices with program flash only: Reserved For devices with FlexNVM: EEPROM region is protected
  let FTFE_FEPROT_EPROT_For_1 $u8 = 1 // For devices with program flash only: Reserved For devices with FlexNVM: EEPROM region is not protected

//--- Enumerated values for register FDPROT, field DPROT
  let FTFE_FDPROT_DPROT_Data_0 $u8 = 0 // Data Flash region is protected
  let FTFE_FDPROT_DPROT_Data_1 $u8 = 1 // Data Flash region is not protected

//--- Enumerated values for register XACC%s, field XA
  let FTFE_XACC_XA_Associated_0 $u8 = 0 // Associated segment is accessible in execute mode only (as an instruction fetch)
  let FTFE_XACC_XA_Associated_1 $u8 = 1 // Associated segment is accessible as data or in execute mode

//--- Enumerated values for register SACC%s, field SA
  let FTFE_SACC_SA_Associated_0 $u8 = 0 // Associated segment is accessible in supervisor mode only
  let FTFE_SACC_SA_Associated_1 $u8 = 1 // Associated segment is accessible in user or supervisor mode

//--- Enumerated values for register FACSN, field NUMSG
  let FTFE_FACSN_NUMSG_Program_110000 $u8 = 48 // Program flash memory is divided into 48 segments (768 Kbytes, 1.5 Mbytes)
  let FTFE_FACSN_NUMSG_Program_1000000 $u8 = 64 // Program flash memory is divided into 64 segments (512 Kbytes, 1 Mbyte, 2 Mbytes)

//------------------------------------------------------------------------------
// Peripheral FTFE_FlashConfig: Flash configuration field
//------------------------------------------------------------------------------

registers ©FTFE_FlashConfig @at 0x400 {
//---  Register BACKKEY3: Backdoor Comparison Key 3.
  BACKKEY3 @offset 0x0 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY2: Backdoor Comparison Key 2.
  BACKKEY2 @offset 0x1 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY1: Backdoor Comparison Key 1.
  BACKKEY1 @offset 0x2 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY0: Backdoor Comparison Key 0.
  BACKKEY0 @offset 0x3 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY7: Backdoor Comparison Key 7.
  BACKKEY7 @offset 0x4 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY6: Backdoor Comparison Key 6.
  BACKKEY6 @offset 0x5 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY5: Backdoor Comparison Key 5.
  BACKKEY5 @offset 0x6 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register BACKKEY4: Backdoor Comparison Key 4.
  BACKKEY4 @offset 0x7 @ro $u8 {
    KEY:8 // at 0: Backdoor Comparison Key.
  }

//---  Register FPROT3: Non-volatile P-Flash Protection 1 - Low Register
  FPROT3 @offset 0x8 @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT2: Non-volatile P-Flash Protection 1 - High Register
  FPROT2 @offset 0x9 @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT1: Non-volatile P-Flash Protection 0 - Low Register
  FPROT1 @offset 0xa @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FPROT0: Non-volatile P-Flash Protection 0 - High Register
  FPROT0 @offset 0xb @ro $u8 {
    PROT:8 // at 0: P-Flash Region Protect
  }

//---  Register FSEC: Non-volatile Flash Security Register
  FSEC @offset 0xc @ro $u8 {
    KEYEN:2 // at 6: Backdoor Key Security Enable
    MEEN:2 // at 4: no description available
    FSLACC:2 // at 2: Freescale Failure Analysis Access Code
    SEC:2 // at 0: Flash Security
  }

//---  Register FOPT: Non-volatile Flash Option Register
  FOPT @offset 0xd @ro $u8 {
    5
    NMI_DIS // at 2: no description available
    EZPORT_DIS // at 1: no description available
    LPBOOT // at 0: no description available
  }

//---  Register FEPROT: Non-volatile EERAM Protection Register
  FEPROT @offset 0xe @ro $u8 {
    EPROT:8 // at 0: no description available
  }

//---  Register FDPROT: Non-volatile D-Flash Protection Register
  FDPROT @offset 0xf @ro $u8 {
    DPROT:8 // at 0: D-Flash Region Protect
  }

}

//--- Enumerated values for register FSEC, field SEC
  let FTFE_FlashConfig_FSEC_SEC_MCU_10 $u2 = 2 // MCU security status is unsecure
  let FTFE_FlashConfig_FSEC_SEC_MCU_11 $u2 = 3 // MCU security status is secure

//--- Enumerated values for register FSEC, field FSLACC
  let FTFE_FlashConfig_FSEC_FSLACC_Freescale_10 $u2 = 2 // Freescale factory access denied
  let FTFE_FlashConfig_FSEC_FSLACC_Freescale_11 $u2 = 3 // Freescale factory access granted

//--- Enumerated values for register FSEC, field MEEN
  let FTFE_FlashConfig_FSEC_MEEN_Mass_10 $u2 = 2 // Mass erase is disabled
  let FTFE_FlashConfig_FSEC_MEEN_Mass_11 $u2 = 3 // Mass erase is enabled

//--- Enumerated values for register FSEC, field KEYEN
  let FTFE_FlashConfig_FSEC_KEYEN_Backdoor_10 $u2 = 2 // Backdoor key access enabled
  let FTFE_FlashConfig_FSEC_KEYEN_Backdoor_11 $u2 = 3 // Backdoor key access disabled

//--- Enumerated values for register FOPT, field LPBOOT
  let FTFE_FlashConfig_FOPT_LPBOOT_Low_power_00 $bool = no // Low-power boot
  let FTFE_FlashConfig_FOPT_LPBOOT_Normal_01 $bool = yes // Normal boot

//--- Enumerated values for register FOPT, field EZPORT_DIS
  let FTFE_FlashConfig_FOPT_EZPORT_DIS_EzPort_00 $bool = no // EzPort operation is disabled
  let FTFE_FlashConfig_FOPT_EZPORT_DIS_EzPort_01 $bool = yes // EzPort operation is enabled

//--- Enumerated values for register FOPT, field NMI_DIS
  let FTFE_FlashConfig_FOPT_NMI_DIS_NMI_00 $bool = no // NMI interrupts are always blocked
  let FTFE_FlashConfig_FOPT_NMI_DIS_NMI_b_01 $bool = yes // NMI_b pin/interrupts reset default to enabled

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©FTM [4]
//        FTM0 at 0x40038000
//        FTM1 at 0x40039000
//        FTM2 at 0x4003a000
//        FTM3 at 0x400b9000
//------------------------------------------------------------------------------

registers ©FTM [4 @at 0x40038000 0x40039000 0x4003a000 0x400b9000]
          ©FTM0 @at 0x40038000
          ©FTM1 @at 0x40039000
          ©FTM2 @at 0x4003a000
          ©FTM3 @at 0x400b9000 {
//---  Register SC: Status And Control
  SC @offset 0x0 $u32 {
    24
    TOF // at 7: Timer Overflow Flag
    TOIE // at 6: Timer Overflow Interrupt Enable
    CPWMS // at 5: Center-Aligned PWM Select
    CLKS:2 // at 3: Clock Source Selection
    PS:3 // at 0: Prescale Factor Selection
  }

//---  Register CNT: Counter
  CNT @offset 0x4 $u32 {
    16
    COUNT:16 // at 0: Counter Value
  }

//---  Register MOD: Modulo
  MOD @offset 0x8 $u32 {
    16
    MOD:16 // at 0: Modulo Value
  }

//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status And Control
  CSC [8 @offset 0xc @inc 0x8]
  C0SC @offset 0xc
  C1SC @offset 0x14
  C2SC @offset 0x1c
  C3SC @offset 0x24
  C4SC @offset 0x2c
  C5SC @offset 0x34
  C6SC @offset 0x3c
  C7SC @offset 0x44 $u32 {
    24
    CHF // at 7: Channel Flag
    CHIE // at 6: Channel Interrupt Enable
    MSB // at 5: Channel Mode Select
    MSA // at 4: Channel Mode Select
    ELSB // at 3: Edge or Level Select
    ELSA // at 2: Edge or Level Select
    1
    DMA // at 0: DMA Enable
  }

//---  Registers CV(0,1,2,3,4,5,6,7): Channel (n) Value
  CV [8 @offset 0x10 @inc 0x8]
  C0V @offset 0x10
  C1V @offset 0x18
  C2V @offset 0x20
  C3V @offset 0x28
  C4V @offset 0x30
  C5V @offset 0x38
  C6V @offset 0x40
  C7V @offset 0x48 $u32 {
    16
    VAL:16 // at 0: Channel Value
  }

//---  Register CNTIN: Counter Initial Value
  CNTIN @offset 0x4c $u32 {
    16
    INIT:16 // at 0: Initial Value Of The FTM Counter
  }

//---  Register STATUS: Capture And Compare Status
  STATUS @offset 0x50 $u32 {
    24
    CH7F // at 7: Channel 7 Flag
    CH6F // at 6: Channel 6 Flag
    CH5F // at 5: Channel 5 Flag
    CH4F // at 4: Channel 4 Flag
    CH3F // at 3: Channel 3 Flag
    CH2F // at 2: Channel 2 Flag
    CH1F // at 1: Channel 1 Flag
    CH0F // at 0: Channel 0 Flag
  }

//---  Register MODE: Features Mode Selection
  MODE @offset 0x54 $u32 {
    24
    FAULTIE // at 7: Fault Interrupt Enable
    FAULTM:2 // at 5: Fault Control Mode
    CAPTEST // at 4: Capture Test Mode Enable
    PWMSYNC // at 3: PWM Synchronization Mode
    WPDIS // at 2: Write Protection Disable
    INIT // at 1: Initialize The Channels Output
    FTMEN // at 0: FTM Enable
  }

//---  Register SYNC: Synchronization
  SYNC @offset 0x58 $u32 {
    24
    SWSYNC // at 7: PWM Synchronization Software Trigger
    TRIG2 // at 6: PWM Synchronization Hardware Trigger 2
    TRIG1 // at 5: PWM Synchronization Hardware Trigger 1
    TRIG0 // at 4: PWM Synchronization Hardware Trigger 0
    SYNCHOM // at 3: Output Mask Synchronization
    REINIT // at 2: FTM Counter Reinitialization By Synchronization (FTM counter synchronization)
    CNTMAX // at 1: Maximum Loading Point Enable
    CNTMIN // at 0: Minimum Loading Point Enable
  }

//---  Register OUTINIT: Initial State For Channels Output
  OUTINIT @offset 0x5c $u32 {
    24
    CH7OI // at 7: Channel 7 Output Initialization Value
    CH6OI // at 6: Channel 6 Output Initialization Value
    CH5OI // at 5: Channel 5 Output Initialization Value
    CH4OI // at 4: Channel 4 Output Initialization Value
    CH3OI // at 3: Channel 3 Output Initialization Value
    CH2OI // at 2: Channel 2 Output Initialization Value
    CH1OI // at 1: Channel 1 Output Initialization Value
    CH0OI // at 0: Channel 0 Output Initialization Value
  }

//---  Register OUTMASK: Output Mask
  OUTMASK @offset 0x60 $u32 {
    24
    CH7OM // at 7: Channel 7 Output Mask
    CH6OM // at 6: Channel 6 Output Mask
    CH5OM // at 5: Channel 5 Output Mask
    CH4OM // at 4: Channel 4 Output Mask
    CH3OM // at 3: Channel 3 Output Mask
    CH2OM // at 2: Channel 2 Output Mask
    CH1OM // at 1: Channel 1 Output Mask
    CH0OM // at 0: Channel 0 Output Mask
  }

//---  Register COMBINE: Function For Linked Channels
  COMBINE @offset 0x64 $u32 {
    1
    FAULTEN3 // at 30: Fault Control Enable For n = 6
    SYNCEN3 // at 29: Synchronization Enable For n = 6
    DTEN3 // at 28: Deadtime Enable For n = 6
    DECAP3 // at 27: Dual Edge Capture Mode Captures For n = 6
    DECAPEN3 // at 26: Dual Edge Capture Mode Enable For n = 6
    COMP3 // at 25: Complement Of Channel (n) for n = 6
    COMBINE3 // at 24: Combine Channels For n = 6
    1
    FAULTEN2 // at 22: Fault Control Enable For n = 4
    SYNCEN2 // at 21: Synchronization Enable For n = 4
    DTEN2 // at 20: Deadtime Enable For n = 4
    DECAP2 // at 19: Dual Edge Capture Mode Captures For n = 4
    DECAPEN2 // at 18: Dual Edge Capture Mode Enable For n = 4
    COMP2 // at 17: Complement Of Channel (n) For n = 4
    COMBINE2 // at 16: Combine Channels For n = 4
    1
    FAULTEN1 // at 14: Fault Control Enable For n = 2
    SYNCEN1 // at 13: Synchronization Enable For n = 2
    DTEN1 // at 12: Deadtime Enable For n = 2
    DECAP1 // at 11: Dual Edge Capture Mode Captures For n = 2
    DECAPEN1 // at 10: Dual Edge Capture Mode Enable For n = 2
    COMP1 // at 9: Complement Of Channel (n) For n = 2
    COMBINE1 // at 8: Combine Channels For n = 2
    1
    FAULTEN0 // at 6: Fault Control Enable For n = 0
    SYNCEN0 // at 5: Synchronization Enable For n = 0
    DTEN0 // at 4: Deadtime Enable For n = 0
    DECAP0 // at 3: Dual Edge Capture Mode Captures For n = 0
    DECAPEN0 // at 2: Dual Edge Capture Mode Enable For n = 0
    COMP0 // at 1: Complement Of Channel (n) For n = 0
    COMBINE0 // at 0: Combine Channels For n = 0
  }

//---  Register DEADTIME: Deadtime Insertion Control
  DEADTIME @offset 0x68 $u32 {
    24
    DTPS:2 // at 6: Deadtime Prescaler Value
    DTVAL:6 // at 0: Deadtime Value
  }

//---  Register EXTTRIG: FTM External Trigger
  EXTTRIG @offset 0x6c $u32 {
    24
    TRIGF // at 7: Channel Trigger Flag
    INITTRIGEN // at 6: Initialization Trigger Enable
    CH1TRIG // at 5: Channel 1 Trigger Enable
    CH0TRIG // at 4: Channel 0 Trigger Enable
    CH5TRIG // at 3: Channel 5 Trigger Enable
    CH4TRIG // at 2: Channel 4 Trigger Enable
    CH3TRIG // at 1: Channel 3 Trigger Enable
    CH2TRIG // at 0: Channel 2 Trigger Enable
  }

//---  Register POL: Channels Polarity
  POL @offset 0x70 $u32 {
    24
    POL7 // at 7: Channel 7 Polarity
    POL6 // at 6: Channel 6 Polarity
    POL5 // at 5: Channel 5 Polarity
    POL4 // at 4: Channel 4 Polarity
    POL3 // at 3: Channel 3 Polarity
    POL2 // at 2: Channel 2 Polarity
    POL1 // at 1: Channel 1 Polarity
    POL0 // at 0: Channel 0 Polarity
  }

//---  Register FMS: Fault Mode Status
  FMS @offset 0x74 $u32 {
    24
    FAULTF // at 7: Fault Detection Flag
    WPEN // at 6: Write Protection Enable
    FAULTIN // at 5: Fault Inputs
    1
    FAULTF3 // at 3: Fault Detection Flag 3
    FAULTF2 // at 2: Fault Detection Flag 2
    FAULTF1 // at 1: Fault Detection Flag 1
    FAULTF0 // at 0: Fault Detection Flag 0
  }

//---  Register FILTER: Input Capture Filter Control
  FILTER @offset 0x78 $u32 {
    16
    CH3FVAL:4 // at 12: Channel 3 Input Filter
    CH2FVAL:4 // at 8: Channel 2 Input Filter
    CH1FVAL:4 // at 4: Channel 1 Input Filter
    CH0FVAL:4 // at 0: Channel 0 Input Filter
  }

//---  Register FLTCTRL: Fault Control
  FLTCTRL @offset 0x7c $u32 {
    20
    FFVAL:4 // at 8: Fault Input Filter
    FFLTR3EN // at 7: Fault Input 3 Filter Enable
    FFLTR2EN // at 6: Fault Input 2 Filter Enable
    FFLTR1EN // at 5: Fault Input 1 Filter Enable
    FFLTR0EN // at 4: Fault Input 0 Filter Enable
    FAULT3EN // at 3: Fault Input 3 Enable
    FAULT2EN // at 2: Fault Input 2 Enable
    FAULT1EN // at 1: Fault Input 1 Enable
    FAULT0EN // at 0: Fault Input 0 Enable
  }

//---  Register QDCTRL: Quadrature Decoder Control And Status
  QDCTRL @offset 0x80 $u32 {
    24
    PHAFLTREN // at 7: Phase A Input Filter Enable
    PHBFLTREN // at 6: Phase B Input Filter Enable
    PHAPOL // at 5: Phase A Input Polarity
    PHBPOL // at 4: Phase B Input Polarity
    QUADMODE // at 3: Quadrature Decoder Mode
    QUADIR // at 2: FTM Counter Direction In Quadrature Decoder Mode
    TOFDIR // at 1: Timer Overflow Direction In Quadrature Decoder Mode
    QUADEN // at 0: Quadrature Decoder Mode Enable
  }

//---  Register CONF: Configuration
  CONF @offset 0x84 $u32 {
    21
    GTBEOUT // at 10: Global Time Base Output
    GTBEEN // at 9: Global Time Base Enable
    1
    BDMMODE:2 // at 6: BDM Mode
    1
    NUMTOF:5 // at 0: TOF Frequency
  }

//---  Register FLTPOL: FTM Fault Input Polarity
  FLTPOL @offset 0x88 $u32 {
    28
    FLT3POL // at 3: Fault Input 3 Polarity
    FLT2POL // at 2: Fault Input 2 Polarity
    FLT1POL // at 1: Fault Input 1 Polarity
    FLT0POL // at 0: Fault Input 0 Polarity
  }

//---  Register SYNCONF: Synchronization Configuration
  SYNCONF @offset 0x8c $u32 {
    11
    HWSOC // at 20: Software output control synchronization is activated by a hardware trigger.
    HWINVC // at 19: Inverting control synchronization is activated by a hardware trigger.
    HWOM // at 18: Output mask synchronization is activated by a hardware trigger.
    HWWRBUF // at 17: MOD, CNTIN, and CV registers synchronization is activated by a hardware trigger.
    HWRSTCNT // at 16: FTM counter synchronization is activated by a hardware trigger.
    3
    SWSOC // at 12: Software output control synchronization is activated by the software trigger.
    SWINVC // at 11: Inverting control synchronization is activated by the software trigger.
    SWOM // at 10: Output mask synchronization is activated by the software trigger.
    SWWRBUF // at 9: MOD, CNTIN, and CV registers synchronization is activated by the software trigger.
    SWRSTCNT // at 8: FTM counter synchronization is activated by the software trigger.
    SYNCMODE // at 7: Synchronization Mode
    1
    SWOC // at 5: SWOCTRL Register Synchronization
    INVC // at 4: INVCTRL Register Synchronization
    1
    CNTINC // at 2: CNTIN Register Synchronization
    1
    HWTRIGMODE // at 0: Hardware Trigger Mode
  }

//---  Register INVCTRL: FTM Inverting Control
  INVCTRL @offset 0x90 $u32 {
    28
    INV3EN // at 3: Pair Channels 3 Inverting Enable
    INV2EN // at 2: Pair Channels 2 Inverting Enable
    INV1EN // at 1: Pair Channels 1 Inverting Enable
    INV0EN // at 0: Pair Channels 0 Inverting Enable
  }

//---  Register SWOCTRL: FTM Software Output Control
  SWOCTRL @offset 0x94 $u32 {
    16
    CH7OCV // at 15: Channel 7 Software Output Control Value
    CH6OCV // at 14: Channel 6 Software Output Control Value
    CH5OCV // at 13: Channel 5 Software Output Control Value
    CH4OCV // at 12: Channel 4 Software Output Control Value
    CH3OCV // at 11: Channel 3 Software Output Control Value
    CH2OCV // at 10: Channel 2 Software Output Control Value
    CH1OCV // at 9: Channel 1 Software Output Control Value
    CH0OCV // at 8: Channel 0 Software Output Control Value
    CH7OC // at 7: Channel 7 Software Output Control Enable
    CH6OC // at 6: Channel 6 Software Output Control Enable
    CH5OC // at 5: Channel 5 Software Output Control Enable
    CH4OC // at 4: Channel 4 Software Output Control Enable
    CH3OC // at 3: Channel 3 Software Output Control Enable
    CH2OC // at 2: Channel 2 Software Output Control Enable
    CH1OC // at 1: Channel 1 Software Output Control Enable
    CH0OC // at 0: Channel 0 Software Output Control Enable
  }

//---  Register PWMLOAD: FTM PWM Load
  PWMLOAD @offset 0x98 $u32 {
    22
    LDOK // at 9: Load Enable
    1
    CH7SEL // at 7: Channel 7 Select
    CH6SEL // at 6: Channel 6 Select
    CH5SEL // at 5: Channel 5 Select
    CH4SEL // at 4: Channel 4 Select
    CH3SEL // at 3: Channel 3 Select
    CH2SEL // at 2: Channel 2 Select
    CH1SEL // at 1: Channel 1 Select
    CH0SEL // at 0: Channel 0 Select
  }

}

//--- Enumerated values for register SC, field PS
  let FTM0_SC_PS_Divide_000 $u3 = 0 // Divide by 1
  let FTM0_SC_PS_Divide_001 $u3 = 1 // Divide by 2
  let FTM0_SC_PS_Divide_010 $u3 = 2 // Divide by 4
  let FTM0_SC_PS_Divide_011 $u3 = 3 // Divide by 8
  let FTM0_SC_PS_Divide_100 $u3 = 4 // Divide by 16
  let FTM0_SC_PS_Divide_101 $u3 = 5 // Divide by 32
  let FTM0_SC_PS_Divide_110 $u3 = 6 // Divide by 64
  let FTM0_SC_PS_Divide_111 $u3 = 7 // Divide by 128

//--- Enumerated values for register SC, field CLKS
  let FTM0_SC_CLKS_No_00 $u2 = 0 // No clock selected. This in effect disables the FTM counter.
  let FTM0_SC_CLKS_System_01 $u2 = 1 // System clock
  let FTM0_SC_CLKS_Fixed_10 $u2 = 2 // Fixed frequency clock
  let FTM0_SC_CLKS_External_11 $u2 = 3 // External clock

//--- Enumerated values for register SC, field CPWMS
  let FTM0_SC_CPWMS_FTM_0 $bool = no // FTM counter operates in Up Counting mode.
  let FTM0_SC_CPWMS_FTM_1 $bool = yes // FTM counter operates in Up-Down Counting mode.

//--- Enumerated values for register SC, field TOIE
  let FTM0_SC_TOIE_Disable_0 $bool = no // Disable TOF interrupts. Use software polling.
  let FTM0_SC_TOIE_Enable_1 $bool = yes // Enable TOF interrupts. An interrupt is generated when TOF equals one.

//--- Enumerated values for register SC, field TOF
  let FTM0_SC_TOF_FTM_0 $bool = no // FTM counter has not overflowed.
  let FTM0_SC_TOF_FTM_1 $bool = yes // FTM counter has overflowed.

//--- Enumerated values for register C%sSC, field DMA
  let FTM0_CSC_DMA_Disable_0 $bool = no // Disable DMA transfers.
  let FTM0_CSC_DMA_Enable_1 $bool = yes // Enable DMA transfers.

//--- Enumerated values for register C%sSC, field CHIE
  let FTM0_CSC_CHIE_Disable_0 $bool = no // Disable channel interrupts. Use software polling.
  let FTM0_CSC_CHIE_Enable_1 $bool = yes // Enable channel interrupts.

//--- Enumerated values for register C%sSC, field CHF
  let FTM0_CSC_CHF_No_0 $bool = no // No channel event has occurred.
  let FTM0_CSC_CHF_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH0F
  let FTM0_STATUS_CH0F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH0F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH1F
  let FTM0_STATUS_CH1F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH1F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH2F
  let FTM0_STATUS_CH2F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH2F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH3F
  let FTM0_STATUS_CH3F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH3F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH4F
  let FTM0_STATUS_CH4F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH4F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH5F
  let FTM0_STATUS_CH5F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH5F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH6F
  let FTM0_STATUS_CH6F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH6F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH7F
  let FTM0_STATUS_CH7F_No_0 $bool = no // No channel event has occurred.
  let FTM0_STATUS_CH7F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register MODE, field FTMEN
  let FTM0_MODE_FTMEN_TPM_0 $bool = no // TPM compatibility. Free running counter and synchronization compatible with TPM.
  let FTM0_MODE_FTMEN_Free_1 $bool = yes // Free running counter and synchronization are different from TPM behavior.

//--- Enumerated values for register MODE, field WPDIS
  let FTM0_MODE_WPDIS_Write_0 $bool = no // Write protection is enabled.
  let FTM0_MODE_WPDIS_Write_1 $bool = yes // Write protection is disabled.

//--- Enumerated values for register MODE, field PWMSYNC
  let FTM0_MODE_PWMSYNC_No_0 $bool = no // No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
  let FTM0_MODE_PWMSYNC_Software_1 $bool = yes // Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.

//--- Enumerated values for register MODE, field CAPTEST
  let FTM0_MODE_CAPTEST_Capture_0 $bool = no // Capture test mode is disabled.
  let FTM0_MODE_CAPTEST_Capture_1 $bool = yes // Capture test mode is enabled.

//--- Enumerated values for register MODE, field FAULTM
  let FTM0_MODE_FAULTM_Fault_00 $u2 = 0 // Fault control is disabled for all channels.
  let FTM0_MODE_FAULTM_Fault_01 $u2 = 1 // Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
  let FTM0_MODE_FAULTM_Fault_10 $u2 = 2 // Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
  let FTM0_MODE_FAULTM_Fault_11 $u2 = 3 // Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.

//--- Enumerated values for register MODE, field FAULTIE
  let FTM0_MODE_FAULTIE_Fault_0 $bool = no // Fault control interrupt is disabled.
  let FTM0_MODE_FAULTIE_Fault_1 $bool = yes // Fault control interrupt is enabled.

//--- Enumerated values for register SYNC, field CNTMIN
  let FTM0_SYNC_CNTMIN_The_0 $bool = no // The minimum loading point is disabled.
  let FTM0_SYNC_CNTMIN_The_1 $bool = yes // The minimum loading point is enabled.

//--- Enumerated values for register SYNC, field CNTMAX
  let FTM0_SYNC_CNTMAX_The_0 $bool = no // The maximum loading point is disabled.
  let FTM0_SYNC_CNTMAX_The_1 $bool = yes // The maximum loading point is enabled.

//--- Enumerated values for register SYNC, field REINIT
  let FTM0_SYNC_REINIT_FTM_0 $bool = no // FTM counter continues to count normally.
  let FTM0_SYNC_REINIT_FTM_1 $bool = yes // FTM counter is updated with its initial value when the selected trigger is detected.

//--- Enumerated values for register SYNC, field SYNCHOM
  let FTM0_SYNC_SYNCHOM_OUTMASK_0 $bool = no // OUTMASK register is updated with the value of its buffer in all rising edges of the system clock.
  let FTM0_SYNC_SYNCHOM_OUTMASK_1 $bool = yes // OUTMASK register is updated with the value of its buffer only by the PWM synchronization.

//--- Enumerated values for register SYNC, field TRIG0
  let FTM0_SYNC_TRIG0_Trigger_0 $bool = no // Trigger is disabled.
  let FTM0_SYNC_TRIG0_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG1
  let FTM0_SYNC_TRIG1_Trigger_0 $bool = no // Trigger is disabled.
  let FTM0_SYNC_TRIG1_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG2
  let FTM0_SYNC_TRIG2_Trigger_0 $bool = no // Trigger is disabled.
  let FTM0_SYNC_TRIG2_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field SWSYNC
  let FTM0_SYNC_SWSYNC_Software_0 $bool = no // Software trigger is not selected.
  let FTM0_SYNC_SWSYNC_Software_1 $bool = yes // Software trigger is selected.

//--- Enumerated values for register OUTINIT, field CH0OI
  let FTM0_OUTINIT_CH0OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH0OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH1OI
  let FTM0_OUTINIT_CH1OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH1OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH2OI
  let FTM0_OUTINIT_CH2OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH2OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH3OI
  let FTM0_OUTINIT_CH3OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH3OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH4OI
  let FTM0_OUTINIT_CH4OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH4OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH5OI
  let FTM0_OUTINIT_CH5OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH5OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH6OI
  let FTM0_OUTINIT_CH6OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH6OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH7OI
  let FTM0_OUTINIT_CH7OI_The_0 $bool = no // The initialization value is 0.
  let FTM0_OUTINIT_CH7OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTMASK, field CH0OM
  let FTM0_OUTMASK_CH0OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH0OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH1OM
  let FTM0_OUTMASK_CH1OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH1OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH2OM
  let FTM0_OUTMASK_CH2OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH2OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH3OM
  let FTM0_OUTMASK_CH3OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH3OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH4OM
  let FTM0_OUTMASK_CH4OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH4OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH5OM
  let FTM0_OUTMASK_CH5OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH5OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH6OM
  let FTM0_OUTMASK_CH6OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH6OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH7OM
  let FTM0_OUTMASK_CH7OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM0_OUTMASK_CH7OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register COMBINE, field COMBINE0
  let FTM0_COMBINE_COMBINE0_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM0_COMBINE_COMBINE0_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP0
  let FTM0_COMBINE_COMP0_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM0_COMBINE_COMP0_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN0
  let FTM0_COMBINE_DECAPEN0_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM0_COMBINE_DECAPEN0_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP0
  let FTM0_COMBINE_DECAP0_The_0 $bool = no // The dual edge captures are inactive.
  let FTM0_COMBINE_DECAP0_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN0
  let FTM0_COMBINE_DTEN0_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM0_COMBINE_DTEN0_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN0
  let FTM0_COMBINE_SYNCEN0_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM0_COMBINE_SYNCEN0_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN0
  let FTM0_COMBINE_FAULTEN0_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM0_COMBINE_FAULTEN0_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE1
  let FTM0_COMBINE_COMBINE1_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM0_COMBINE_COMBINE1_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP1
  let FTM0_COMBINE_COMP1_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM0_COMBINE_COMP1_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN1
  let FTM0_COMBINE_DECAPEN1_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM0_COMBINE_DECAPEN1_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP1
  let FTM0_COMBINE_DECAP1_The_0 $bool = no // The dual edge captures are inactive.
  let FTM0_COMBINE_DECAP1_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN1
  let FTM0_COMBINE_DTEN1_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM0_COMBINE_DTEN1_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN1
  let FTM0_COMBINE_SYNCEN1_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM0_COMBINE_SYNCEN1_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN1
  let FTM0_COMBINE_FAULTEN1_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM0_COMBINE_FAULTEN1_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE2
  let FTM0_COMBINE_COMBINE2_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM0_COMBINE_COMBINE2_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP2
  let FTM0_COMBINE_COMP2_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM0_COMBINE_COMP2_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN2
  let FTM0_COMBINE_DECAPEN2_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM0_COMBINE_DECAPEN2_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP2
  let FTM0_COMBINE_DECAP2_The_0 $bool = no // The dual edge captures are inactive.
  let FTM0_COMBINE_DECAP2_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN2
  let FTM0_COMBINE_DTEN2_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM0_COMBINE_DTEN2_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN2
  let FTM0_COMBINE_SYNCEN2_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM0_COMBINE_SYNCEN2_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN2
  let FTM0_COMBINE_FAULTEN2_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM0_COMBINE_FAULTEN2_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE3
  let FTM0_COMBINE_COMBINE3_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM0_COMBINE_COMBINE3_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP3
  let FTM0_COMBINE_COMP3_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM0_COMBINE_COMP3_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN3
  let FTM0_COMBINE_DECAPEN3_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM0_COMBINE_DECAPEN3_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP3
  let FTM0_COMBINE_DECAP3_The_0 $bool = no // The dual edge captures are inactive.
  let FTM0_COMBINE_DECAP3_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN3
  let FTM0_COMBINE_DTEN3_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM0_COMBINE_DTEN3_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN3
  let FTM0_COMBINE_SYNCEN3_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM0_COMBINE_SYNCEN3_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN3
  let FTM0_COMBINE_FAULTEN3_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM0_COMBINE_FAULTEN3_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register DEADTIME, field DTPS
  let FTM0_DEADTIME_DTPS_Divide_0x $u2 = 0 // Divide the system clock by 1.
  let FTM0_DEADTIME_DTPS_Divide_10 $u2 = 2 // Divide the system clock by 4.
  let FTM0_DEADTIME_DTPS_Divide_11 $u2 = 3 // Divide the system clock by 16.

//--- Enumerated values for register EXTTRIG, field CH2TRIG
  let FTM0_EXTTRIG_CH2TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM0_EXTTRIG_CH2TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH3TRIG
  let FTM0_EXTTRIG_CH3TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM0_EXTTRIG_CH3TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH4TRIG
  let FTM0_EXTTRIG_CH4TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM0_EXTTRIG_CH4TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH5TRIG
  let FTM0_EXTTRIG_CH5TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM0_EXTTRIG_CH5TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH0TRIG
  let FTM0_EXTTRIG_CH0TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM0_EXTTRIG_CH0TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH1TRIG
  let FTM0_EXTTRIG_CH1TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM0_EXTTRIG_CH1TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field INITTRIGEN
  let FTM0_EXTTRIG_INITTRIGEN_The_0 $bool = no // The generation of initialization trigger is disabled.
  let FTM0_EXTTRIG_INITTRIGEN_The_1 $bool = yes // The generation of initialization trigger is enabled.

//--- Enumerated values for register EXTTRIG, field TRIGF
  let FTM0_EXTTRIG_TRIGF_No_0 $bool = no // No channel trigger was generated.
  let FTM0_EXTTRIG_TRIGF_A_1 $bool = yes // A channel trigger was generated.

//--- Enumerated values for register POL, field POL0
  let FTM0_POL_POL0_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL0_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL1
  let FTM0_POL_POL1_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL1_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL2
  let FTM0_POL_POL2_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL2_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL3
  let FTM0_POL_POL3_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL3_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL4
  let FTM0_POL_POL4_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL4_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL5
  let FTM0_POL_POL5_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL5_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL6
  let FTM0_POL_POL6_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL6_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL7
  let FTM0_POL_POL7_The_0 $bool = no // The channel polarity is active high.
  let FTM0_POL_POL7_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register FMS, field FAULTF0
  let FTM0_FMS_FAULTF0_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM0_FMS_FAULTF0_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF1
  let FTM0_FMS_FAULTF1_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM0_FMS_FAULTF1_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF2
  let FTM0_FMS_FAULTF2_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM0_FMS_FAULTF2_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF3
  let FTM0_FMS_FAULTF3_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM0_FMS_FAULTF3_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTIN
  let FTM0_FMS_FAULTIN_The_0 $bool = no // The logic OR of the enabled fault inputs is 0.
  let FTM0_FMS_FAULTIN_The_1 $bool = yes // The logic OR of the enabled fault inputs is 1.

//--- Enumerated values for register FMS, field WPEN
  let FTM0_FMS_WPEN_Write_0 $bool = no // Write protection is disabled. Write protected bits can be written.
  let FTM0_FMS_WPEN_Write_1 $bool = yes // Write protection is enabled. Write protected bits cannot be written.

//--- Enumerated values for register FMS, field FAULTF
  let FTM0_FMS_FAULTF_No_0 $bool = no // No fault condition was detected.
  let FTM0_FMS_FAULTF_A_1 $bool = yes // A fault condition was detected.

//--- Enumerated values for register FLTCTRL, field FAULT0EN
  let FTM0_FLTCTRL_FAULT0EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM0_FLTCTRL_FAULT0EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT1EN
  let FTM0_FLTCTRL_FAULT1EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM0_FLTCTRL_FAULT1EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT2EN
  let FTM0_FLTCTRL_FAULT2EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM0_FLTCTRL_FAULT2EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT3EN
  let FTM0_FLTCTRL_FAULT3EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM0_FLTCTRL_FAULT3EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR0EN
  let FTM0_FLTCTRL_FFLTR0EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM0_FLTCTRL_FFLTR0EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR1EN
  let FTM0_FLTCTRL_FFLTR1EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM0_FLTCTRL_FFLTR1EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR2EN
  let FTM0_FLTCTRL_FFLTR2EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM0_FLTCTRL_FFLTR2EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR3EN
  let FTM0_FLTCTRL_FFLTR3EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM0_FLTCTRL_FFLTR3EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register QDCTRL, field QUADEN
  let FTM0_QDCTRL_QUADEN_Quadrature_0 $bool = no // Quadrature Decoder mode is disabled.
  let FTM0_QDCTRL_QUADEN_Quadrature_1 $bool = yes // Quadrature Decoder mode is enabled.

//--- Enumerated values for register QDCTRL, field TOFDIR
  let FTM0_QDCTRL_TOFDIR_TOF_0 $bool = no // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
  let FTM0_QDCTRL_TOFDIR_TOF_1 $bool = yes // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).

//--- Enumerated values for register QDCTRL, field QUADIR
  let FTM0_QDCTRL_QUADIR_Counting_0 $bool = no // Counting direction is decreasing (FTM counter decrement).
  let FTM0_QDCTRL_QUADIR_Counting_1 $bool = yes // Counting direction is increasing (FTM counter increment).

//--- Enumerated values for register QDCTRL, field QUADMODE
  let FTM0_QDCTRL_QUADMODE_Phase_0 $bool = no // Phase A and phase B encoding mode.
  let FTM0_QDCTRL_QUADMODE_Count_1 $bool = yes // Count and direction encoding mode.

//--- Enumerated values for register QDCTRL, field PHBPOL
  let FTM0_QDCTRL_PHBPOL_Normal_0 $bool = no // Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM0_QDCTRL_PHBPOL_Inverted_1 $bool = yes // Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHAPOL
  let FTM0_QDCTRL_PHAPOL_Normal_0 $bool = no // Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM0_QDCTRL_PHAPOL_Inverted_1 $bool = yes // Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHBFLTREN
  let FTM0_QDCTRL_PHBFLTREN_Phase_0 $bool = no // Phase B input filter is disabled.
  let FTM0_QDCTRL_PHBFLTREN_Phase_1 $bool = yes // Phase B input filter is enabled.

//--- Enumerated values for register QDCTRL, field PHAFLTREN
  let FTM0_QDCTRL_PHAFLTREN_Phase_0 $bool = no // Phase A input filter is disabled.
  let FTM0_QDCTRL_PHAFLTREN_Phase_1 $bool = yes // Phase A input filter is enabled.

//--- Enumerated values for register CONF, field GTBEEN
  let FTM0_CONF_GTBEEN_Use_0 $bool = no // Use of an external global time base is disabled.
  let FTM0_CONF_GTBEEN_Use_1 $bool = yes // Use of an external global time base is enabled.

//--- Enumerated values for register CONF, field GTBEOUT
  let FTM0_CONF_GTBEOUT_A_0 $bool = no // A global time base signal generation is disabled.
  let FTM0_CONF_GTBEOUT_A_1 $bool = yes // A global time base signal generation is enabled.

//--- Enumerated values for register FLTPOL, field FLT0POL
  let FTM0_FLTPOL_FLT0POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM0_FLTPOL_FLT0POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT1POL
  let FTM0_FLTPOL_FLT1POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM0_FLTPOL_FLT1POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT2POL
  let FTM0_FLTPOL_FLT2POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM0_FLTPOL_FLT2POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT3POL
  let FTM0_FLTPOL_FLT3POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM0_FLTPOL_FLT3POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register SYNCONF, field HWTRIGMODE
  let FTM0_SYNCONF_HWTRIGMODE_FTM_0 $bool = no // FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
  let FTM0_SYNCONF_HWTRIGMODE_FTM_1 $bool = yes // FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.

//--- Enumerated values for register SYNCONF, field CNTINC
  let FTM0_SYNCONF_CNTINC_CNTIN_0 $bool = no // CNTIN register is updated with its buffer value at all rising edges of system clock.
  let FTM0_SYNCONF_CNTINC_CNTIN_1 $bool = yes // CNTIN register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field INVC
  let FTM0_SYNCONF_INVC_INVCTRL_0 $bool = no // INVCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM0_SYNCONF_INVC_INVCTRL_1 $bool = yes // INVCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SWOC
  let FTM0_SYNCONF_SWOC_SWOCTRL_0 $bool = no // SWOCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM0_SYNCONF_SWOC_SWOCTRL_1 $bool = yes // SWOCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SYNCMODE
  let FTM0_SYNCONF_SYNCMODE_Legacy_0 $bool = no // Legacy PWM synchronization is selected.
  let FTM0_SYNCONF_SYNCMODE_Enhanced_1 $bool = yes // Enhanced PWM synchronization is selected.

//--- Enumerated values for register SYNCONF, field SWRSTCNT
  let FTM0_SYNCONF_SWRSTCNT_The_0 $bool = no // The software trigger does not activate the FTM counter synchronization.
  let FTM0_SYNCONF_SWRSTCNT_The_1 $bool = yes // The software trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field SWWRBUF
  let FTM0_SYNCONF_SWWRBUF_The_0 $bool = no // The software trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM0_SYNCONF_SWWRBUF_The_1 $bool = yes // The software trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field SWOM
  let FTM0_SYNCONF_SWOM_The_0 $bool = no // The software trigger does not activate the OUTMASK register synchronization.
  let FTM0_SYNCONF_SWOM_The_1 $bool = yes // The software trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field SWINVC
  let FTM0_SYNCONF_SWINVC_The_0 $bool = no // The software trigger does not activate the INVCTRL register synchronization.
  let FTM0_SYNCONF_SWINVC_The_1 $bool = yes // The software trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field SWSOC
  let FTM0_SYNCONF_SWSOC_The_0 $bool = no // The software trigger does not activate the SWOCTRL register synchronization.
  let FTM0_SYNCONF_SWSOC_The_1 $bool = yes // The software trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWRSTCNT
  let FTM0_SYNCONF_HWRSTCNT_A_0 $bool = no // A hardware trigger does not activate the FTM counter synchronization.
  let FTM0_SYNCONF_HWRSTCNT_A_1 $bool = yes // A hardware trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field HWWRBUF
  let FTM0_SYNCONF_HWWRBUF_A_0 $bool = no // A hardware trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM0_SYNCONF_HWWRBUF_A_1 $bool = yes // A hardware trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field HWOM
  let FTM0_SYNCONF_HWOM_A_0 $bool = no // A hardware trigger does not activate the OUTMASK register synchronization.
  let FTM0_SYNCONF_HWOM_A_1 $bool = yes // A hardware trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field HWINVC
  let FTM0_SYNCONF_HWINVC_A_0 $bool = no // A hardware trigger does not activate the INVCTRL register synchronization.
  let FTM0_SYNCONF_HWINVC_A_1 $bool = yes // A hardware trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWSOC
  let FTM0_SYNCONF_HWSOC_A_0 $bool = no // A hardware trigger does not activate the SWOCTRL register synchronization.
  let FTM0_SYNCONF_HWSOC_A_1 $bool = yes // A hardware trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register INVCTRL, field INV0EN
  let FTM0_INVCTRL_INV0EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM0_INVCTRL_INV0EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV1EN
  let FTM0_INVCTRL_INV1EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM0_INVCTRL_INV1EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV2EN
  let FTM0_INVCTRL_INV2EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM0_INVCTRL_INV2EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV3EN
  let FTM0_INVCTRL_INV3EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM0_INVCTRL_INV3EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register SWOCTRL, field CH0OC
  let FTM0_SWOCTRL_CH0OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH0OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH1OC
  let FTM0_SWOCTRL_CH1OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH1OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH2OC
  let FTM0_SWOCTRL_CH2OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH2OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH3OC
  let FTM0_SWOCTRL_CH3OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH3OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH4OC
  let FTM0_SWOCTRL_CH4OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH4OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH5OC
  let FTM0_SWOCTRL_CH5OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH5OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH6OC
  let FTM0_SWOCTRL_CH6OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH6OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH7OC
  let FTM0_SWOCTRL_CH7OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM0_SWOCTRL_CH7OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH0OCV
  let FTM0_SWOCTRL_CH0OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH0OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH1OCV
  let FTM0_SWOCTRL_CH1OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH1OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH2OCV
  let FTM0_SWOCTRL_CH2OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH2OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH3OCV
  let FTM0_SWOCTRL_CH3OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH3OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH4OCV
  let FTM0_SWOCTRL_CH4OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH4OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH5OCV
  let FTM0_SWOCTRL_CH5OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH5OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH6OCV
  let FTM0_SWOCTRL_CH6OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH6OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH7OCV
  let FTM0_SWOCTRL_CH7OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM0_SWOCTRL_CH7OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register PWMLOAD, field CH0SEL
  let FTM0_PWMLOAD_CH0SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH0SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH1SEL
  let FTM0_PWMLOAD_CH1SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH1SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH2SEL
  let FTM0_PWMLOAD_CH2SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH2SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH3SEL
  let FTM0_PWMLOAD_CH3SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH3SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH4SEL
  let FTM0_PWMLOAD_CH4SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH4SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH5SEL
  let FTM0_PWMLOAD_CH5SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH5SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH6SEL
  let FTM0_PWMLOAD_CH6SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH6SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH7SEL
  let FTM0_PWMLOAD_CH7SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM0_PWMLOAD_CH7SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field LDOK
  let FTM0_PWMLOAD_LDOK_Loading_0 $bool = no // Loading updated values is disabled.
  let FTM0_PWMLOAD_LDOK_Loading_1 $bool = yes // Loading updated values is enabled.

//--- Enumerated values for register SC, field PS
  let FTM1_SC_PS_Divide_000 $u3 = 0 // Divide by 1
  let FTM1_SC_PS_Divide_001 $u3 = 1 // Divide by 2
  let FTM1_SC_PS_Divide_010 $u3 = 2 // Divide by 4
  let FTM1_SC_PS_Divide_011 $u3 = 3 // Divide by 8
  let FTM1_SC_PS_Divide_100 $u3 = 4 // Divide by 16
  let FTM1_SC_PS_Divide_101 $u3 = 5 // Divide by 32
  let FTM1_SC_PS_Divide_110 $u3 = 6 // Divide by 64
  let FTM1_SC_PS_Divide_111 $u3 = 7 // Divide by 128

//--- Enumerated values for register SC, field CLKS
  let FTM1_SC_CLKS_No_00 $u2 = 0 // No clock selected. This in effect disables the FTM counter.
  let FTM1_SC_CLKS_System_01 $u2 = 1 // System clock
  let FTM1_SC_CLKS_Fixed_10 $u2 = 2 // Fixed frequency clock
  let FTM1_SC_CLKS_External_11 $u2 = 3 // External clock

//--- Enumerated values for register SC, field CPWMS
  let FTM1_SC_CPWMS_FTM_0 $bool = no // FTM counter operates in Up Counting mode.
  let FTM1_SC_CPWMS_FTM_1 $bool = yes // FTM counter operates in Up-Down Counting mode.

//--- Enumerated values for register SC, field TOIE
  let FTM1_SC_TOIE_Disable_0 $bool = no // Disable TOF interrupts. Use software polling.
  let FTM1_SC_TOIE_Enable_1 $bool = yes // Enable TOF interrupts. An interrupt is generated when TOF equals one.

//--- Enumerated values for register SC, field TOF
  let FTM1_SC_TOF_FTM_0 $bool = no // FTM counter has not overflowed.
  let FTM1_SC_TOF_FTM_1 $bool = yes // FTM counter has overflowed.

//--- Enumerated values for register C%sSC, field DMA
  let FTM1_CSC_DMA_Disable_0 $bool = no // Disable DMA transfers.
  let FTM1_CSC_DMA_Enable_1 $bool = yes // Enable DMA transfers.

//--- Enumerated values for register C%sSC, field CHIE
  let FTM1_CSC_CHIE_Disable_0 $bool = no // Disable channel interrupts. Use software polling.
  let FTM1_CSC_CHIE_Enable_1 $bool = yes // Enable channel interrupts.

//--- Enumerated values for register C%sSC, field CHF
  let FTM1_CSC_CHF_No_0 $bool = no // No channel event has occurred.
  let FTM1_CSC_CHF_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH0F
  let FTM1_STATUS_CH0F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH0F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH1F
  let FTM1_STATUS_CH1F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH1F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH2F
  let FTM1_STATUS_CH2F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH2F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH3F
  let FTM1_STATUS_CH3F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH3F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH4F
  let FTM1_STATUS_CH4F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH4F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH5F
  let FTM1_STATUS_CH5F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH5F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH6F
  let FTM1_STATUS_CH6F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH6F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH7F
  let FTM1_STATUS_CH7F_No_0 $bool = no // No channel event has occurred.
  let FTM1_STATUS_CH7F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register MODE, field FTMEN
  let FTM1_MODE_FTMEN_TPM_0 $bool = no // TPM compatibility. Free running counter and synchronization compatible with TPM.
  let FTM1_MODE_FTMEN_Free_1 $bool = yes // Free running counter and synchronization are different from TPM behavior.

//--- Enumerated values for register MODE, field WPDIS
  let FTM1_MODE_WPDIS_Write_0 $bool = no // Write protection is enabled.
  let FTM1_MODE_WPDIS_Write_1 $bool = yes // Write protection is disabled.

//--- Enumerated values for register MODE, field PWMSYNC
  let FTM1_MODE_PWMSYNC_No_0 $bool = no // No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
  let FTM1_MODE_PWMSYNC_Software_1 $bool = yes // Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.

//--- Enumerated values for register MODE, field CAPTEST
  let FTM1_MODE_CAPTEST_Capture_0 $bool = no // Capture test mode is disabled.
  let FTM1_MODE_CAPTEST_Capture_1 $bool = yes // Capture test mode is enabled.

//--- Enumerated values for register MODE, field FAULTM
  let FTM1_MODE_FAULTM_Fault_00 $u2 = 0 // Fault control is disabled for all channels.
  let FTM1_MODE_FAULTM_Fault_01 $u2 = 1 // Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
  let FTM1_MODE_FAULTM_Fault_10 $u2 = 2 // Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
  let FTM1_MODE_FAULTM_Fault_11 $u2 = 3 // Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.

//--- Enumerated values for register MODE, field FAULTIE
  let FTM1_MODE_FAULTIE_Fault_0 $bool = no // Fault control interrupt is disabled.
  let FTM1_MODE_FAULTIE_Fault_1 $bool = yes // Fault control interrupt is enabled.

//--- Enumerated values for register SYNC, field CNTMIN
  let FTM1_SYNC_CNTMIN_The_0 $bool = no // The minimum loading point is disabled.
  let FTM1_SYNC_CNTMIN_The_1 $bool = yes // The minimum loading point is enabled.

//--- Enumerated values for register SYNC, field CNTMAX
  let FTM1_SYNC_CNTMAX_The_0 $bool = no // The maximum loading point is disabled.
  let FTM1_SYNC_CNTMAX_The_1 $bool = yes // The maximum loading point is enabled.

//--- Enumerated values for register SYNC, field REINIT
  let FTM1_SYNC_REINIT_FTM_0 $bool = no // FTM counter continues to count normally.
  let FTM1_SYNC_REINIT_FTM_1 $bool = yes // FTM counter is updated with its initial value when the selected trigger is detected.

//--- Enumerated values for register SYNC, field SYNCHOM
  let FTM1_SYNC_SYNCHOM_OUTMASK_0 $bool = no // OUTMASK register is updated with the value of its buffer in all rising edges of the system clock.
  let FTM1_SYNC_SYNCHOM_OUTMASK_1 $bool = yes // OUTMASK register is updated with the value of its buffer only by the PWM synchronization.

//--- Enumerated values for register SYNC, field TRIG0
  let FTM1_SYNC_TRIG0_Trigger_0 $bool = no // Trigger is disabled.
  let FTM1_SYNC_TRIG0_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG1
  let FTM1_SYNC_TRIG1_Trigger_0 $bool = no // Trigger is disabled.
  let FTM1_SYNC_TRIG1_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG2
  let FTM1_SYNC_TRIG2_Trigger_0 $bool = no // Trigger is disabled.
  let FTM1_SYNC_TRIG2_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field SWSYNC
  let FTM1_SYNC_SWSYNC_Software_0 $bool = no // Software trigger is not selected.
  let FTM1_SYNC_SWSYNC_Software_1 $bool = yes // Software trigger is selected.

//--- Enumerated values for register OUTINIT, field CH0OI
  let FTM1_OUTINIT_CH0OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH0OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH1OI
  let FTM1_OUTINIT_CH1OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH1OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH2OI
  let FTM1_OUTINIT_CH2OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH2OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH3OI
  let FTM1_OUTINIT_CH3OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH3OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH4OI
  let FTM1_OUTINIT_CH4OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH4OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH5OI
  let FTM1_OUTINIT_CH5OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH5OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH6OI
  let FTM1_OUTINIT_CH6OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH6OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH7OI
  let FTM1_OUTINIT_CH7OI_The_0 $bool = no // The initialization value is 0.
  let FTM1_OUTINIT_CH7OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTMASK, field CH0OM
  let FTM1_OUTMASK_CH0OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH0OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH1OM
  let FTM1_OUTMASK_CH1OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH1OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH2OM
  let FTM1_OUTMASK_CH2OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH2OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH3OM
  let FTM1_OUTMASK_CH3OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH3OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH4OM
  let FTM1_OUTMASK_CH4OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH4OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH5OM
  let FTM1_OUTMASK_CH5OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH5OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH6OM
  let FTM1_OUTMASK_CH6OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH6OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH7OM
  let FTM1_OUTMASK_CH7OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM1_OUTMASK_CH7OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register COMBINE, field COMBINE0
  let FTM1_COMBINE_COMBINE0_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM1_COMBINE_COMBINE0_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP0
  let FTM1_COMBINE_COMP0_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM1_COMBINE_COMP0_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN0
  let FTM1_COMBINE_DECAPEN0_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM1_COMBINE_DECAPEN0_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP0
  let FTM1_COMBINE_DECAP0_The_0 $bool = no // The dual edge captures are inactive.
  let FTM1_COMBINE_DECAP0_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN0
  let FTM1_COMBINE_DTEN0_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM1_COMBINE_DTEN0_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN0
  let FTM1_COMBINE_SYNCEN0_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM1_COMBINE_SYNCEN0_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN0
  let FTM1_COMBINE_FAULTEN0_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM1_COMBINE_FAULTEN0_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE1
  let FTM1_COMBINE_COMBINE1_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM1_COMBINE_COMBINE1_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP1
  let FTM1_COMBINE_COMP1_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM1_COMBINE_COMP1_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN1
  let FTM1_COMBINE_DECAPEN1_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM1_COMBINE_DECAPEN1_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP1
  let FTM1_COMBINE_DECAP1_The_0 $bool = no // The dual edge captures are inactive.
  let FTM1_COMBINE_DECAP1_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN1
  let FTM1_COMBINE_DTEN1_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM1_COMBINE_DTEN1_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN1
  let FTM1_COMBINE_SYNCEN1_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM1_COMBINE_SYNCEN1_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN1
  let FTM1_COMBINE_FAULTEN1_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM1_COMBINE_FAULTEN1_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE2
  let FTM1_COMBINE_COMBINE2_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM1_COMBINE_COMBINE2_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP2
  let FTM1_COMBINE_COMP2_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM1_COMBINE_COMP2_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN2
  let FTM1_COMBINE_DECAPEN2_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM1_COMBINE_DECAPEN2_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP2
  let FTM1_COMBINE_DECAP2_The_0 $bool = no // The dual edge captures are inactive.
  let FTM1_COMBINE_DECAP2_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN2
  let FTM1_COMBINE_DTEN2_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM1_COMBINE_DTEN2_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN2
  let FTM1_COMBINE_SYNCEN2_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM1_COMBINE_SYNCEN2_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN2
  let FTM1_COMBINE_FAULTEN2_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM1_COMBINE_FAULTEN2_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE3
  let FTM1_COMBINE_COMBINE3_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM1_COMBINE_COMBINE3_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP3
  let FTM1_COMBINE_COMP3_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM1_COMBINE_COMP3_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN3
  let FTM1_COMBINE_DECAPEN3_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM1_COMBINE_DECAPEN3_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP3
  let FTM1_COMBINE_DECAP3_The_0 $bool = no // The dual edge captures are inactive.
  let FTM1_COMBINE_DECAP3_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN3
  let FTM1_COMBINE_DTEN3_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM1_COMBINE_DTEN3_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN3
  let FTM1_COMBINE_SYNCEN3_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM1_COMBINE_SYNCEN3_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN3
  let FTM1_COMBINE_FAULTEN3_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM1_COMBINE_FAULTEN3_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register DEADTIME, field DTPS
  let FTM1_DEADTIME_DTPS_Divide_0x $u2 = 0 // Divide the system clock by 1.
  let FTM1_DEADTIME_DTPS_Divide_10 $u2 = 2 // Divide the system clock by 4.
  let FTM1_DEADTIME_DTPS_Divide_11 $u2 = 3 // Divide the system clock by 16.

//--- Enumerated values for register EXTTRIG, field CH2TRIG
  let FTM1_EXTTRIG_CH2TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM1_EXTTRIG_CH2TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH3TRIG
  let FTM1_EXTTRIG_CH3TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM1_EXTTRIG_CH3TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH4TRIG
  let FTM1_EXTTRIG_CH4TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM1_EXTTRIG_CH4TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH5TRIG
  let FTM1_EXTTRIG_CH5TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM1_EXTTRIG_CH5TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH0TRIG
  let FTM1_EXTTRIG_CH0TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM1_EXTTRIG_CH0TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH1TRIG
  let FTM1_EXTTRIG_CH1TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM1_EXTTRIG_CH1TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field INITTRIGEN
  let FTM1_EXTTRIG_INITTRIGEN_The_0 $bool = no // The generation of initialization trigger is disabled.
  let FTM1_EXTTRIG_INITTRIGEN_The_1 $bool = yes // The generation of initialization trigger is enabled.

//--- Enumerated values for register EXTTRIG, field TRIGF
  let FTM1_EXTTRIG_TRIGF_No_0 $bool = no // No channel trigger was generated.
  let FTM1_EXTTRIG_TRIGF_A_1 $bool = yes // A channel trigger was generated.

//--- Enumerated values for register POL, field POL0
  let FTM1_POL_POL0_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL0_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL1
  let FTM1_POL_POL1_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL1_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL2
  let FTM1_POL_POL2_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL2_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL3
  let FTM1_POL_POL3_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL3_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL4
  let FTM1_POL_POL4_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL4_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL5
  let FTM1_POL_POL5_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL5_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL6
  let FTM1_POL_POL6_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL6_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL7
  let FTM1_POL_POL7_The_0 $bool = no // The channel polarity is active high.
  let FTM1_POL_POL7_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register FMS, field FAULTF0
  let FTM1_FMS_FAULTF0_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM1_FMS_FAULTF0_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF1
  let FTM1_FMS_FAULTF1_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM1_FMS_FAULTF1_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF2
  let FTM1_FMS_FAULTF2_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM1_FMS_FAULTF2_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF3
  let FTM1_FMS_FAULTF3_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM1_FMS_FAULTF3_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTIN
  let FTM1_FMS_FAULTIN_The_0 $bool = no // The logic OR of the enabled fault inputs is 0.
  let FTM1_FMS_FAULTIN_The_1 $bool = yes // The logic OR of the enabled fault inputs is 1.

//--- Enumerated values for register FMS, field WPEN
  let FTM1_FMS_WPEN_Write_0 $bool = no // Write protection is disabled. Write protected bits can be written.
  let FTM1_FMS_WPEN_Write_1 $bool = yes // Write protection is enabled. Write protected bits cannot be written.

//--- Enumerated values for register FMS, field FAULTF
  let FTM1_FMS_FAULTF_No_0 $bool = no // No fault condition was detected.
  let FTM1_FMS_FAULTF_A_1 $bool = yes // A fault condition was detected.

//--- Enumerated values for register FLTCTRL, field FAULT0EN
  let FTM1_FLTCTRL_FAULT0EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM1_FLTCTRL_FAULT0EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT1EN
  let FTM1_FLTCTRL_FAULT1EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM1_FLTCTRL_FAULT1EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT2EN
  let FTM1_FLTCTRL_FAULT2EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM1_FLTCTRL_FAULT2EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT3EN
  let FTM1_FLTCTRL_FAULT3EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM1_FLTCTRL_FAULT3EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR0EN
  let FTM1_FLTCTRL_FFLTR0EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM1_FLTCTRL_FFLTR0EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR1EN
  let FTM1_FLTCTRL_FFLTR1EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM1_FLTCTRL_FFLTR1EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR2EN
  let FTM1_FLTCTRL_FFLTR2EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM1_FLTCTRL_FFLTR2EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR3EN
  let FTM1_FLTCTRL_FFLTR3EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM1_FLTCTRL_FFLTR3EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register QDCTRL, field QUADEN
  let FTM1_QDCTRL_QUADEN_Quadrature_0 $bool = no // Quadrature Decoder mode is disabled.
  let FTM1_QDCTRL_QUADEN_Quadrature_1 $bool = yes // Quadrature Decoder mode is enabled.

//--- Enumerated values for register QDCTRL, field TOFDIR
  let FTM1_QDCTRL_TOFDIR_TOF_0 $bool = no // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
  let FTM1_QDCTRL_TOFDIR_TOF_1 $bool = yes // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).

//--- Enumerated values for register QDCTRL, field QUADIR
  let FTM1_QDCTRL_QUADIR_Counting_0 $bool = no // Counting direction is decreasing (FTM counter decrement).
  let FTM1_QDCTRL_QUADIR_Counting_1 $bool = yes // Counting direction is increasing (FTM counter increment).

//--- Enumerated values for register QDCTRL, field QUADMODE
  let FTM1_QDCTRL_QUADMODE_Phase_0 $bool = no // Phase A and phase B encoding mode.
  let FTM1_QDCTRL_QUADMODE_Count_1 $bool = yes // Count and direction encoding mode.

//--- Enumerated values for register QDCTRL, field PHBPOL
  let FTM1_QDCTRL_PHBPOL_Normal_0 $bool = no // Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM1_QDCTRL_PHBPOL_Inverted_1 $bool = yes // Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHAPOL
  let FTM1_QDCTRL_PHAPOL_Normal_0 $bool = no // Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM1_QDCTRL_PHAPOL_Inverted_1 $bool = yes // Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHBFLTREN
  let FTM1_QDCTRL_PHBFLTREN_Phase_0 $bool = no // Phase B input filter is disabled.
  let FTM1_QDCTRL_PHBFLTREN_Phase_1 $bool = yes // Phase B input filter is enabled.

//--- Enumerated values for register QDCTRL, field PHAFLTREN
  let FTM1_QDCTRL_PHAFLTREN_Phase_0 $bool = no // Phase A input filter is disabled.
  let FTM1_QDCTRL_PHAFLTREN_Phase_1 $bool = yes // Phase A input filter is enabled.

//--- Enumerated values for register CONF, field GTBEEN
  let FTM1_CONF_GTBEEN_Use_0 $bool = no // Use of an external global time base is disabled.
  let FTM1_CONF_GTBEEN_Use_1 $bool = yes // Use of an external global time base is enabled.

//--- Enumerated values for register CONF, field GTBEOUT
  let FTM1_CONF_GTBEOUT_A_0 $bool = no // A global time base signal generation is disabled.
  let FTM1_CONF_GTBEOUT_A_1 $bool = yes // A global time base signal generation is enabled.

//--- Enumerated values for register FLTPOL, field FLT0POL
  let FTM1_FLTPOL_FLT0POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM1_FLTPOL_FLT0POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT1POL
  let FTM1_FLTPOL_FLT1POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM1_FLTPOL_FLT1POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT2POL
  let FTM1_FLTPOL_FLT2POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM1_FLTPOL_FLT2POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT3POL
  let FTM1_FLTPOL_FLT3POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM1_FLTPOL_FLT3POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register SYNCONF, field HWTRIGMODE
  let FTM1_SYNCONF_HWTRIGMODE_FTM_0 $bool = no // FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
  let FTM1_SYNCONF_HWTRIGMODE_FTM_1 $bool = yes // FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.

//--- Enumerated values for register SYNCONF, field CNTINC
  let FTM1_SYNCONF_CNTINC_CNTIN_0 $bool = no // CNTIN register is updated with its buffer value at all rising edges of system clock.
  let FTM1_SYNCONF_CNTINC_CNTIN_1 $bool = yes // CNTIN register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field INVC
  let FTM1_SYNCONF_INVC_INVCTRL_0 $bool = no // INVCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM1_SYNCONF_INVC_INVCTRL_1 $bool = yes // INVCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SWOC
  let FTM1_SYNCONF_SWOC_SWOCTRL_0 $bool = no // SWOCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM1_SYNCONF_SWOC_SWOCTRL_1 $bool = yes // SWOCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SYNCMODE
  let FTM1_SYNCONF_SYNCMODE_Legacy_0 $bool = no // Legacy PWM synchronization is selected.
  let FTM1_SYNCONF_SYNCMODE_Enhanced_1 $bool = yes // Enhanced PWM synchronization is selected.

//--- Enumerated values for register SYNCONF, field SWRSTCNT
  let FTM1_SYNCONF_SWRSTCNT_The_0 $bool = no // The software trigger does not activate the FTM counter synchronization.
  let FTM1_SYNCONF_SWRSTCNT_The_1 $bool = yes // The software trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field SWWRBUF
  let FTM1_SYNCONF_SWWRBUF_The_0 $bool = no // The software trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM1_SYNCONF_SWWRBUF_The_1 $bool = yes // The software trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field SWOM
  let FTM1_SYNCONF_SWOM_The_0 $bool = no // The software trigger does not activate the OUTMASK register synchronization.
  let FTM1_SYNCONF_SWOM_The_1 $bool = yes // The software trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field SWINVC
  let FTM1_SYNCONF_SWINVC_The_0 $bool = no // The software trigger does not activate the INVCTRL register synchronization.
  let FTM1_SYNCONF_SWINVC_The_1 $bool = yes // The software trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field SWSOC
  let FTM1_SYNCONF_SWSOC_The_0 $bool = no // The software trigger does not activate the SWOCTRL register synchronization.
  let FTM1_SYNCONF_SWSOC_The_1 $bool = yes // The software trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWRSTCNT
  let FTM1_SYNCONF_HWRSTCNT_A_0 $bool = no // A hardware trigger does not activate the FTM counter synchronization.
  let FTM1_SYNCONF_HWRSTCNT_A_1 $bool = yes // A hardware trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field HWWRBUF
  let FTM1_SYNCONF_HWWRBUF_A_0 $bool = no // A hardware trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM1_SYNCONF_HWWRBUF_A_1 $bool = yes // A hardware trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field HWOM
  let FTM1_SYNCONF_HWOM_A_0 $bool = no // A hardware trigger does not activate the OUTMASK register synchronization.
  let FTM1_SYNCONF_HWOM_A_1 $bool = yes // A hardware trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field HWINVC
  let FTM1_SYNCONF_HWINVC_A_0 $bool = no // A hardware trigger does not activate the INVCTRL register synchronization.
  let FTM1_SYNCONF_HWINVC_A_1 $bool = yes // A hardware trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWSOC
  let FTM1_SYNCONF_HWSOC_A_0 $bool = no // A hardware trigger does not activate the SWOCTRL register synchronization.
  let FTM1_SYNCONF_HWSOC_A_1 $bool = yes // A hardware trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register INVCTRL, field INV0EN
  let FTM1_INVCTRL_INV0EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM1_INVCTRL_INV0EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV1EN
  let FTM1_INVCTRL_INV1EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM1_INVCTRL_INV1EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV2EN
  let FTM1_INVCTRL_INV2EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM1_INVCTRL_INV2EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV3EN
  let FTM1_INVCTRL_INV3EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM1_INVCTRL_INV3EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register SWOCTRL, field CH0OC
  let FTM1_SWOCTRL_CH0OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH0OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH1OC
  let FTM1_SWOCTRL_CH1OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH1OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH2OC
  let FTM1_SWOCTRL_CH2OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH2OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH3OC
  let FTM1_SWOCTRL_CH3OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH3OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH4OC
  let FTM1_SWOCTRL_CH4OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH4OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH5OC
  let FTM1_SWOCTRL_CH5OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH5OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH6OC
  let FTM1_SWOCTRL_CH6OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH6OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH7OC
  let FTM1_SWOCTRL_CH7OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM1_SWOCTRL_CH7OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH0OCV
  let FTM1_SWOCTRL_CH0OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH0OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH1OCV
  let FTM1_SWOCTRL_CH1OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH1OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH2OCV
  let FTM1_SWOCTRL_CH2OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH2OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH3OCV
  let FTM1_SWOCTRL_CH3OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH3OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH4OCV
  let FTM1_SWOCTRL_CH4OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH4OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH5OCV
  let FTM1_SWOCTRL_CH5OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH5OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH6OCV
  let FTM1_SWOCTRL_CH6OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH6OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH7OCV
  let FTM1_SWOCTRL_CH7OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM1_SWOCTRL_CH7OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register PWMLOAD, field CH0SEL
  let FTM1_PWMLOAD_CH0SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH0SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH1SEL
  let FTM1_PWMLOAD_CH1SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH1SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH2SEL
  let FTM1_PWMLOAD_CH2SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH2SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH3SEL
  let FTM1_PWMLOAD_CH3SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH3SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH4SEL
  let FTM1_PWMLOAD_CH4SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH4SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH5SEL
  let FTM1_PWMLOAD_CH5SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH5SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH6SEL
  let FTM1_PWMLOAD_CH6SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH6SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH7SEL
  let FTM1_PWMLOAD_CH7SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM1_PWMLOAD_CH7SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field LDOK
  let FTM1_PWMLOAD_LDOK_Loading_0 $bool = no // Loading updated values is disabled.
  let FTM1_PWMLOAD_LDOK_Loading_1 $bool = yes // Loading updated values is enabled.

//--- Enumerated values for register SC, field PS
  let FTM2_SC_PS_Divide_000 $u3 = 0 // Divide by 1
  let FTM2_SC_PS_Divide_001 $u3 = 1 // Divide by 2
  let FTM2_SC_PS_Divide_010 $u3 = 2 // Divide by 4
  let FTM2_SC_PS_Divide_011 $u3 = 3 // Divide by 8
  let FTM2_SC_PS_Divide_100 $u3 = 4 // Divide by 16
  let FTM2_SC_PS_Divide_101 $u3 = 5 // Divide by 32
  let FTM2_SC_PS_Divide_110 $u3 = 6 // Divide by 64
  let FTM2_SC_PS_Divide_111 $u3 = 7 // Divide by 128

//--- Enumerated values for register SC, field CLKS
  let FTM2_SC_CLKS_No_00 $u2 = 0 // No clock selected. This in effect disables the FTM counter.
  let FTM2_SC_CLKS_System_01 $u2 = 1 // System clock
  let FTM2_SC_CLKS_Fixed_10 $u2 = 2 // Fixed frequency clock
  let FTM2_SC_CLKS_External_11 $u2 = 3 // External clock

//--- Enumerated values for register SC, field CPWMS
  let FTM2_SC_CPWMS_FTM_0 $bool = no // FTM counter operates in Up Counting mode.
  let FTM2_SC_CPWMS_FTM_1 $bool = yes // FTM counter operates in Up-Down Counting mode.

//--- Enumerated values for register SC, field TOIE
  let FTM2_SC_TOIE_Disable_0 $bool = no // Disable TOF interrupts. Use software polling.
  let FTM2_SC_TOIE_Enable_1 $bool = yes // Enable TOF interrupts. An interrupt is generated when TOF equals one.

//--- Enumerated values for register SC, field TOF
  let FTM2_SC_TOF_FTM_0 $bool = no // FTM counter has not overflowed.
  let FTM2_SC_TOF_FTM_1 $bool = yes // FTM counter has overflowed.

//--- Enumerated values for register C%sSC, field DMA
  let FTM2_CSC_DMA_Disable_0 $bool = no // Disable DMA transfers.
  let FTM2_CSC_DMA_Enable_1 $bool = yes // Enable DMA transfers.

//--- Enumerated values for register C%sSC, field CHIE
  let FTM2_CSC_CHIE_Disable_0 $bool = no // Disable channel interrupts. Use software polling.
  let FTM2_CSC_CHIE_Enable_1 $bool = yes // Enable channel interrupts.

//--- Enumerated values for register C%sSC, field CHF
  let FTM2_CSC_CHF_No_0 $bool = no // No channel event has occurred.
  let FTM2_CSC_CHF_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH0F
  let FTM2_STATUS_CH0F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH0F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH1F
  let FTM2_STATUS_CH1F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH1F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH2F
  let FTM2_STATUS_CH2F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH2F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH3F
  let FTM2_STATUS_CH3F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH3F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH4F
  let FTM2_STATUS_CH4F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH4F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH5F
  let FTM2_STATUS_CH5F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH5F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH6F
  let FTM2_STATUS_CH6F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH6F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH7F
  let FTM2_STATUS_CH7F_No_0 $bool = no // No channel event has occurred.
  let FTM2_STATUS_CH7F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register MODE, field FTMEN
  let FTM2_MODE_FTMEN_TPM_0 $bool = no // TPM compatibility. Free running counter and synchronization compatible with TPM.
  let FTM2_MODE_FTMEN_Free_1 $bool = yes // Free running counter and synchronization are different from TPM behavior.

//--- Enumerated values for register MODE, field WPDIS
  let FTM2_MODE_WPDIS_Write_0 $bool = no // Write protection is enabled.
  let FTM2_MODE_WPDIS_Write_1 $bool = yes // Write protection is disabled.

//--- Enumerated values for register MODE, field PWMSYNC
  let FTM2_MODE_PWMSYNC_No_0 $bool = no // No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
  let FTM2_MODE_PWMSYNC_Software_1 $bool = yes // Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.

//--- Enumerated values for register MODE, field CAPTEST
  let FTM2_MODE_CAPTEST_Capture_0 $bool = no // Capture test mode is disabled.
  let FTM2_MODE_CAPTEST_Capture_1 $bool = yes // Capture test mode is enabled.

//--- Enumerated values for register MODE, field FAULTM
  let FTM2_MODE_FAULTM_Fault_00 $u2 = 0 // Fault control is disabled for all channels.
  let FTM2_MODE_FAULTM_Fault_01 $u2 = 1 // Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
  let FTM2_MODE_FAULTM_Fault_10 $u2 = 2 // Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
  let FTM2_MODE_FAULTM_Fault_11 $u2 = 3 // Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.

//--- Enumerated values for register MODE, field FAULTIE
  let FTM2_MODE_FAULTIE_Fault_0 $bool = no // Fault control interrupt is disabled.
  let FTM2_MODE_FAULTIE_Fault_1 $bool = yes // Fault control interrupt is enabled.

//--- Enumerated values for register SYNC, field CNTMIN
  let FTM2_SYNC_CNTMIN_The_0 $bool = no // The minimum loading point is disabled.
  let FTM2_SYNC_CNTMIN_The_1 $bool = yes // The minimum loading point is enabled.

//--- Enumerated values for register SYNC, field CNTMAX
  let FTM2_SYNC_CNTMAX_The_0 $bool = no // The maximum loading point is disabled.
  let FTM2_SYNC_CNTMAX_The_1 $bool = yes // The maximum loading point is enabled.

//--- Enumerated values for register SYNC, field REINIT
  let FTM2_SYNC_REINIT_FTM_0 $bool = no // FTM counter continues to count normally.
  let FTM2_SYNC_REINIT_FTM_1 $bool = yes // FTM counter is updated with its initial value when the selected trigger is detected.

//--- Enumerated values for register SYNC, field SYNCHOM
  let FTM2_SYNC_SYNCHOM_OUTMASK_0 $bool = no // OUTMASK register is updated with the value of its buffer in all rising edges of the system clock.
  let FTM2_SYNC_SYNCHOM_OUTMASK_1 $bool = yes // OUTMASK register is updated with the value of its buffer only by the PWM synchronization.

//--- Enumerated values for register SYNC, field TRIG0
  let FTM2_SYNC_TRIG0_Trigger_0 $bool = no // Trigger is disabled.
  let FTM2_SYNC_TRIG0_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG1
  let FTM2_SYNC_TRIG1_Trigger_0 $bool = no // Trigger is disabled.
  let FTM2_SYNC_TRIG1_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG2
  let FTM2_SYNC_TRIG2_Trigger_0 $bool = no // Trigger is disabled.
  let FTM2_SYNC_TRIG2_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field SWSYNC
  let FTM2_SYNC_SWSYNC_Software_0 $bool = no // Software trigger is not selected.
  let FTM2_SYNC_SWSYNC_Software_1 $bool = yes // Software trigger is selected.

//--- Enumerated values for register OUTINIT, field CH0OI
  let FTM2_OUTINIT_CH0OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH0OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH1OI
  let FTM2_OUTINIT_CH1OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH1OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH2OI
  let FTM2_OUTINIT_CH2OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH2OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH3OI
  let FTM2_OUTINIT_CH3OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH3OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH4OI
  let FTM2_OUTINIT_CH4OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH4OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH5OI
  let FTM2_OUTINIT_CH5OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH5OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH6OI
  let FTM2_OUTINIT_CH6OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH6OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH7OI
  let FTM2_OUTINIT_CH7OI_The_0 $bool = no // The initialization value is 0.
  let FTM2_OUTINIT_CH7OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTMASK, field CH0OM
  let FTM2_OUTMASK_CH0OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH0OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH1OM
  let FTM2_OUTMASK_CH1OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH1OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH2OM
  let FTM2_OUTMASK_CH2OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH2OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH3OM
  let FTM2_OUTMASK_CH3OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH3OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH4OM
  let FTM2_OUTMASK_CH4OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH4OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH5OM
  let FTM2_OUTMASK_CH5OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH5OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH6OM
  let FTM2_OUTMASK_CH6OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH6OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH7OM
  let FTM2_OUTMASK_CH7OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM2_OUTMASK_CH7OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register COMBINE, field COMBINE0
  let FTM2_COMBINE_COMBINE0_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM2_COMBINE_COMBINE0_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP0
  let FTM2_COMBINE_COMP0_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM2_COMBINE_COMP0_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN0
  let FTM2_COMBINE_DECAPEN0_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM2_COMBINE_DECAPEN0_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP0
  let FTM2_COMBINE_DECAP0_The_0 $bool = no // The dual edge captures are inactive.
  let FTM2_COMBINE_DECAP0_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN0
  let FTM2_COMBINE_DTEN0_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM2_COMBINE_DTEN0_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN0
  let FTM2_COMBINE_SYNCEN0_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM2_COMBINE_SYNCEN0_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN0
  let FTM2_COMBINE_FAULTEN0_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM2_COMBINE_FAULTEN0_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE1
  let FTM2_COMBINE_COMBINE1_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM2_COMBINE_COMBINE1_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP1
  let FTM2_COMBINE_COMP1_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM2_COMBINE_COMP1_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN1
  let FTM2_COMBINE_DECAPEN1_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM2_COMBINE_DECAPEN1_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP1
  let FTM2_COMBINE_DECAP1_The_0 $bool = no // The dual edge captures are inactive.
  let FTM2_COMBINE_DECAP1_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN1
  let FTM2_COMBINE_DTEN1_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM2_COMBINE_DTEN1_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN1
  let FTM2_COMBINE_SYNCEN1_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM2_COMBINE_SYNCEN1_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN1
  let FTM2_COMBINE_FAULTEN1_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM2_COMBINE_FAULTEN1_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE2
  let FTM2_COMBINE_COMBINE2_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM2_COMBINE_COMBINE2_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP2
  let FTM2_COMBINE_COMP2_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM2_COMBINE_COMP2_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN2
  let FTM2_COMBINE_DECAPEN2_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM2_COMBINE_DECAPEN2_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP2
  let FTM2_COMBINE_DECAP2_The_0 $bool = no // The dual edge captures are inactive.
  let FTM2_COMBINE_DECAP2_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN2
  let FTM2_COMBINE_DTEN2_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM2_COMBINE_DTEN2_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN2
  let FTM2_COMBINE_SYNCEN2_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM2_COMBINE_SYNCEN2_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN2
  let FTM2_COMBINE_FAULTEN2_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM2_COMBINE_FAULTEN2_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE3
  let FTM2_COMBINE_COMBINE3_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM2_COMBINE_COMBINE3_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP3
  let FTM2_COMBINE_COMP3_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM2_COMBINE_COMP3_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN3
  let FTM2_COMBINE_DECAPEN3_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM2_COMBINE_DECAPEN3_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP3
  let FTM2_COMBINE_DECAP3_The_0 $bool = no // The dual edge captures are inactive.
  let FTM2_COMBINE_DECAP3_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN3
  let FTM2_COMBINE_DTEN3_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM2_COMBINE_DTEN3_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN3
  let FTM2_COMBINE_SYNCEN3_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM2_COMBINE_SYNCEN3_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN3
  let FTM2_COMBINE_FAULTEN3_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM2_COMBINE_FAULTEN3_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register DEADTIME, field DTPS
  let FTM2_DEADTIME_DTPS_Divide_0x $u2 = 0 // Divide the system clock by 1.
  let FTM2_DEADTIME_DTPS_Divide_10 $u2 = 2 // Divide the system clock by 4.
  let FTM2_DEADTIME_DTPS_Divide_11 $u2 = 3 // Divide the system clock by 16.

//--- Enumerated values for register EXTTRIG, field CH2TRIG
  let FTM2_EXTTRIG_CH2TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM2_EXTTRIG_CH2TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH3TRIG
  let FTM2_EXTTRIG_CH3TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM2_EXTTRIG_CH3TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH4TRIG
  let FTM2_EXTTRIG_CH4TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM2_EXTTRIG_CH4TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH5TRIG
  let FTM2_EXTTRIG_CH5TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM2_EXTTRIG_CH5TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH0TRIG
  let FTM2_EXTTRIG_CH0TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM2_EXTTRIG_CH0TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH1TRIG
  let FTM2_EXTTRIG_CH1TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM2_EXTTRIG_CH1TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field INITTRIGEN
  let FTM2_EXTTRIG_INITTRIGEN_The_0 $bool = no // The generation of initialization trigger is disabled.
  let FTM2_EXTTRIG_INITTRIGEN_The_1 $bool = yes // The generation of initialization trigger is enabled.

//--- Enumerated values for register EXTTRIG, field TRIGF
  let FTM2_EXTTRIG_TRIGF_No_0 $bool = no // No channel trigger was generated.
  let FTM2_EXTTRIG_TRIGF_A_1 $bool = yes // A channel trigger was generated.

//--- Enumerated values for register POL, field POL0
  let FTM2_POL_POL0_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL0_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL1
  let FTM2_POL_POL1_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL1_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL2
  let FTM2_POL_POL2_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL2_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL3
  let FTM2_POL_POL3_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL3_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL4
  let FTM2_POL_POL4_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL4_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL5
  let FTM2_POL_POL5_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL5_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL6
  let FTM2_POL_POL6_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL6_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL7
  let FTM2_POL_POL7_The_0 $bool = no // The channel polarity is active high.
  let FTM2_POL_POL7_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register FMS, field FAULTF0
  let FTM2_FMS_FAULTF0_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM2_FMS_FAULTF0_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF1
  let FTM2_FMS_FAULTF1_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM2_FMS_FAULTF1_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF2
  let FTM2_FMS_FAULTF2_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM2_FMS_FAULTF2_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF3
  let FTM2_FMS_FAULTF3_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM2_FMS_FAULTF3_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTIN
  let FTM2_FMS_FAULTIN_The_0 $bool = no // The logic OR of the enabled fault inputs is 0.
  let FTM2_FMS_FAULTIN_The_1 $bool = yes // The logic OR of the enabled fault inputs is 1.

//--- Enumerated values for register FMS, field WPEN
  let FTM2_FMS_WPEN_Write_0 $bool = no // Write protection is disabled. Write protected bits can be written.
  let FTM2_FMS_WPEN_Write_1 $bool = yes // Write protection is enabled. Write protected bits cannot be written.

//--- Enumerated values for register FMS, field FAULTF
  let FTM2_FMS_FAULTF_No_0 $bool = no // No fault condition was detected.
  let FTM2_FMS_FAULTF_A_1 $bool = yes // A fault condition was detected.

//--- Enumerated values for register FLTCTRL, field FAULT0EN
  let FTM2_FLTCTRL_FAULT0EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM2_FLTCTRL_FAULT0EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT1EN
  let FTM2_FLTCTRL_FAULT1EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM2_FLTCTRL_FAULT1EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT2EN
  let FTM2_FLTCTRL_FAULT2EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM2_FLTCTRL_FAULT2EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT3EN
  let FTM2_FLTCTRL_FAULT3EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM2_FLTCTRL_FAULT3EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR0EN
  let FTM2_FLTCTRL_FFLTR0EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM2_FLTCTRL_FFLTR0EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR1EN
  let FTM2_FLTCTRL_FFLTR1EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM2_FLTCTRL_FFLTR1EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR2EN
  let FTM2_FLTCTRL_FFLTR2EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM2_FLTCTRL_FFLTR2EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR3EN
  let FTM2_FLTCTRL_FFLTR3EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM2_FLTCTRL_FFLTR3EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register QDCTRL, field QUADEN
  let FTM2_QDCTRL_QUADEN_Quadrature_0 $bool = no // Quadrature Decoder mode is disabled.
  let FTM2_QDCTRL_QUADEN_Quadrature_1 $bool = yes // Quadrature Decoder mode is enabled.

//--- Enumerated values for register QDCTRL, field TOFDIR
  let FTM2_QDCTRL_TOFDIR_TOF_0 $bool = no // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
  let FTM2_QDCTRL_TOFDIR_TOF_1 $bool = yes // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).

//--- Enumerated values for register QDCTRL, field QUADIR
  let FTM2_QDCTRL_QUADIR_Counting_0 $bool = no // Counting direction is decreasing (FTM counter decrement).
  let FTM2_QDCTRL_QUADIR_Counting_1 $bool = yes // Counting direction is increasing (FTM counter increment).

//--- Enumerated values for register QDCTRL, field QUADMODE
  let FTM2_QDCTRL_QUADMODE_Phase_0 $bool = no // Phase A and phase B encoding mode.
  let FTM2_QDCTRL_QUADMODE_Count_1 $bool = yes // Count and direction encoding mode.

//--- Enumerated values for register QDCTRL, field PHBPOL
  let FTM2_QDCTRL_PHBPOL_Normal_0 $bool = no // Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM2_QDCTRL_PHBPOL_Inverted_1 $bool = yes // Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHAPOL
  let FTM2_QDCTRL_PHAPOL_Normal_0 $bool = no // Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM2_QDCTRL_PHAPOL_Inverted_1 $bool = yes // Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHBFLTREN
  let FTM2_QDCTRL_PHBFLTREN_Phase_0 $bool = no // Phase B input filter is disabled.
  let FTM2_QDCTRL_PHBFLTREN_Phase_1 $bool = yes // Phase B input filter is enabled.

//--- Enumerated values for register QDCTRL, field PHAFLTREN
  let FTM2_QDCTRL_PHAFLTREN_Phase_0 $bool = no // Phase A input filter is disabled.
  let FTM2_QDCTRL_PHAFLTREN_Phase_1 $bool = yes // Phase A input filter is enabled.

//--- Enumerated values for register CONF, field GTBEEN
  let FTM2_CONF_GTBEEN_Use_0 $bool = no // Use of an external global time base is disabled.
  let FTM2_CONF_GTBEEN_Use_1 $bool = yes // Use of an external global time base is enabled.

//--- Enumerated values for register CONF, field GTBEOUT
  let FTM2_CONF_GTBEOUT_A_0 $bool = no // A global time base signal generation is disabled.
  let FTM2_CONF_GTBEOUT_A_1 $bool = yes // A global time base signal generation is enabled.

//--- Enumerated values for register FLTPOL, field FLT0POL
  let FTM2_FLTPOL_FLT0POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM2_FLTPOL_FLT0POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT1POL
  let FTM2_FLTPOL_FLT1POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM2_FLTPOL_FLT1POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT2POL
  let FTM2_FLTPOL_FLT2POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM2_FLTPOL_FLT2POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT3POL
  let FTM2_FLTPOL_FLT3POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM2_FLTPOL_FLT3POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register SYNCONF, field HWTRIGMODE
  let FTM2_SYNCONF_HWTRIGMODE_FTM_0 $bool = no // FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
  let FTM2_SYNCONF_HWTRIGMODE_FTM_1 $bool = yes // FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.

//--- Enumerated values for register SYNCONF, field CNTINC
  let FTM2_SYNCONF_CNTINC_CNTIN_0 $bool = no // CNTIN register is updated with its buffer value at all rising edges of system clock.
  let FTM2_SYNCONF_CNTINC_CNTIN_1 $bool = yes // CNTIN register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field INVC
  let FTM2_SYNCONF_INVC_INVCTRL_0 $bool = no // INVCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM2_SYNCONF_INVC_INVCTRL_1 $bool = yes // INVCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SWOC
  let FTM2_SYNCONF_SWOC_SWOCTRL_0 $bool = no // SWOCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM2_SYNCONF_SWOC_SWOCTRL_1 $bool = yes // SWOCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SYNCMODE
  let FTM2_SYNCONF_SYNCMODE_Legacy_0 $bool = no // Legacy PWM synchronization is selected.
  let FTM2_SYNCONF_SYNCMODE_Enhanced_1 $bool = yes // Enhanced PWM synchronization is selected.

//--- Enumerated values for register SYNCONF, field SWRSTCNT
  let FTM2_SYNCONF_SWRSTCNT_The_0 $bool = no // The software trigger does not activate the FTM counter synchronization.
  let FTM2_SYNCONF_SWRSTCNT_The_1 $bool = yes // The software trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field SWWRBUF
  let FTM2_SYNCONF_SWWRBUF_The_0 $bool = no // The software trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM2_SYNCONF_SWWRBUF_The_1 $bool = yes // The software trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field SWOM
  let FTM2_SYNCONF_SWOM_The_0 $bool = no // The software trigger does not activate the OUTMASK register synchronization.
  let FTM2_SYNCONF_SWOM_The_1 $bool = yes // The software trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field SWINVC
  let FTM2_SYNCONF_SWINVC_The_0 $bool = no // The software trigger does not activate the INVCTRL register synchronization.
  let FTM2_SYNCONF_SWINVC_The_1 $bool = yes // The software trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field SWSOC
  let FTM2_SYNCONF_SWSOC_The_0 $bool = no // The software trigger does not activate the SWOCTRL register synchronization.
  let FTM2_SYNCONF_SWSOC_The_1 $bool = yes // The software trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWRSTCNT
  let FTM2_SYNCONF_HWRSTCNT_A_0 $bool = no // A hardware trigger does not activate the FTM counter synchronization.
  let FTM2_SYNCONF_HWRSTCNT_A_1 $bool = yes // A hardware trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field HWWRBUF
  let FTM2_SYNCONF_HWWRBUF_A_0 $bool = no // A hardware trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM2_SYNCONF_HWWRBUF_A_1 $bool = yes // A hardware trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field HWOM
  let FTM2_SYNCONF_HWOM_A_0 $bool = no // A hardware trigger does not activate the OUTMASK register synchronization.
  let FTM2_SYNCONF_HWOM_A_1 $bool = yes // A hardware trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field HWINVC
  let FTM2_SYNCONF_HWINVC_A_0 $bool = no // A hardware trigger does not activate the INVCTRL register synchronization.
  let FTM2_SYNCONF_HWINVC_A_1 $bool = yes // A hardware trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWSOC
  let FTM2_SYNCONF_HWSOC_A_0 $bool = no // A hardware trigger does not activate the SWOCTRL register synchronization.
  let FTM2_SYNCONF_HWSOC_A_1 $bool = yes // A hardware trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register INVCTRL, field INV0EN
  let FTM2_INVCTRL_INV0EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM2_INVCTRL_INV0EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV1EN
  let FTM2_INVCTRL_INV1EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM2_INVCTRL_INV1EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV2EN
  let FTM2_INVCTRL_INV2EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM2_INVCTRL_INV2EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV3EN
  let FTM2_INVCTRL_INV3EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM2_INVCTRL_INV3EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register SWOCTRL, field CH0OC
  let FTM2_SWOCTRL_CH0OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH0OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH1OC
  let FTM2_SWOCTRL_CH1OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH1OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH2OC
  let FTM2_SWOCTRL_CH2OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH2OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH3OC
  let FTM2_SWOCTRL_CH3OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH3OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH4OC
  let FTM2_SWOCTRL_CH4OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH4OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH5OC
  let FTM2_SWOCTRL_CH5OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH5OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH6OC
  let FTM2_SWOCTRL_CH6OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH6OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH7OC
  let FTM2_SWOCTRL_CH7OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM2_SWOCTRL_CH7OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH0OCV
  let FTM2_SWOCTRL_CH0OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH0OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH1OCV
  let FTM2_SWOCTRL_CH1OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH1OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH2OCV
  let FTM2_SWOCTRL_CH2OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH2OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH3OCV
  let FTM2_SWOCTRL_CH3OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH3OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH4OCV
  let FTM2_SWOCTRL_CH4OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH4OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH5OCV
  let FTM2_SWOCTRL_CH5OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH5OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH6OCV
  let FTM2_SWOCTRL_CH6OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH6OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH7OCV
  let FTM2_SWOCTRL_CH7OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM2_SWOCTRL_CH7OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register PWMLOAD, field CH0SEL
  let FTM2_PWMLOAD_CH0SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH0SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH1SEL
  let FTM2_PWMLOAD_CH1SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH1SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH2SEL
  let FTM2_PWMLOAD_CH2SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH2SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH3SEL
  let FTM2_PWMLOAD_CH3SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH3SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH4SEL
  let FTM2_PWMLOAD_CH4SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH4SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH5SEL
  let FTM2_PWMLOAD_CH5SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH5SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH6SEL
  let FTM2_PWMLOAD_CH6SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH6SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH7SEL
  let FTM2_PWMLOAD_CH7SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM2_PWMLOAD_CH7SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field LDOK
  let FTM2_PWMLOAD_LDOK_Loading_0 $bool = no // Loading updated values is disabled.
  let FTM2_PWMLOAD_LDOK_Loading_1 $bool = yes // Loading updated values is enabled.

//--- Enumerated values for register SC, field PS
  let FTM3_SC_PS_Divide_000 $u3 = 0 // Divide by 1
  let FTM3_SC_PS_Divide_001 $u3 = 1 // Divide by 2
  let FTM3_SC_PS_Divide_010 $u3 = 2 // Divide by 4
  let FTM3_SC_PS_Divide_011 $u3 = 3 // Divide by 8
  let FTM3_SC_PS_Divide_100 $u3 = 4 // Divide by 16
  let FTM3_SC_PS_Divide_101 $u3 = 5 // Divide by 32
  let FTM3_SC_PS_Divide_110 $u3 = 6 // Divide by 64
  let FTM3_SC_PS_Divide_111 $u3 = 7 // Divide by 128

//--- Enumerated values for register SC, field CLKS
  let FTM3_SC_CLKS_No_00 $u2 = 0 // No clock selected. This in effect disables the FTM counter.
  let FTM3_SC_CLKS_System_01 $u2 = 1 // System clock
  let FTM3_SC_CLKS_Fixed_10 $u2 = 2 // Fixed frequency clock
  let FTM3_SC_CLKS_External_11 $u2 = 3 // External clock

//--- Enumerated values for register SC, field CPWMS
  let FTM3_SC_CPWMS_FTM_0 $bool = no // FTM counter operates in Up Counting mode.
  let FTM3_SC_CPWMS_FTM_1 $bool = yes // FTM counter operates in Up-Down Counting mode.

//--- Enumerated values for register SC, field TOIE
  let FTM3_SC_TOIE_Disable_0 $bool = no // Disable TOF interrupts. Use software polling.
  let FTM3_SC_TOIE_Enable_1 $bool = yes // Enable TOF interrupts. An interrupt is generated when TOF equals one.

//--- Enumerated values for register SC, field TOF
  let FTM3_SC_TOF_FTM_0 $bool = no // FTM counter has not overflowed.
  let FTM3_SC_TOF_FTM_1 $bool = yes // FTM counter has overflowed.

//--- Enumerated values for register C%sSC, field DMA
  let FTM3_CSC_DMA_Disable_0 $bool = no // Disable DMA transfers.
  let FTM3_CSC_DMA_Enable_1 $bool = yes // Enable DMA transfers.

//--- Enumerated values for register C%sSC, field CHIE
  let FTM3_CSC_CHIE_Disable_0 $bool = no // Disable channel interrupts. Use software polling.
  let FTM3_CSC_CHIE_Enable_1 $bool = yes // Enable channel interrupts.

//--- Enumerated values for register C%sSC, field CHF
  let FTM3_CSC_CHF_No_0 $bool = no // No channel event has occurred.
  let FTM3_CSC_CHF_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH0F
  let FTM3_STATUS_CH0F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH0F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH1F
  let FTM3_STATUS_CH1F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH1F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH2F
  let FTM3_STATUS_CH2F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH2F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH3F
  let FTM3_STATUS_CH3F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH3F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH4F
  let FTM3_STATUS_CH4F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH4F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH5F
  let FTM3_STATUS_CH5F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH5F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH6F
  let FTM3_STATUS_CH6F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH6F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH7F
  let FTM3_STATUS_CH7F_No_0 $bool = no // No channel event has occurred.
  let FTM3_STATUS_CH7F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register MODE, field FTMEN
  let FTM3_MODE_FTMEN_TPM_0 $bool = no // TPM compatibility. Free running counter and synchronization compatible with TPM.
  let FTM3_MODE_FTMEN_Free_1 $bool = yes // Free running counter and synchronization are different from TPM behavior.

//--- Enumerated values for register MODE, field WPDIS
  let FTM3_MODE_WPDIS_Write_0 $bool = no // Write protection is enabled.
  let FTM3_MODE_WPDIS_Write_1 $bool = yes // Write protection is disabled.

//--- Enumerated values for register MODE, field PWMSYNC
  let FTM3_MODE_PWMSYNC_No_0 $bool = no // No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
  let FTM3_MODE_PWMSYNC_Software_1 $bool = yes // Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.

//--- Enumerated values for register MODE, field CAPTEST
  let FTM3_MODE_CAPTEST_Capture_0 $bool = no // Capture test mode is disabled.
  let FTM3_MODE_CAPTEST_Capture_1 $bool = yes // Capture test mode is enabled.

//--- Enumerated values for register MODE, field FAULTM
  let FTM3_MODE_FAULTM_Fault_00 $u2 = 0 // Fault control is disabled for all channels.
  let FTM3_MODE_FAULTM_Fault_01 $u2 = 1 // Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
  let FTM3_MODE_FAULTM_Fault_10 $u2 = 2 // Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
  let FTM3_MODE_FAULTM_Fault_11 $u2 = 3 // Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.

//--- Enumerated values for register MODE, field FAULTIE
  let FTM3_MODE_FAULTIE_Fault_0 $bool = no // Fault control interrupt is disabled.
  let FTM3_MODE_FAULTIE_Fault_1 $bool = yes // Fault control interrupt is enabled.

//--- Enumerated values for register SYNC, field CNTMIN
  let FTM3_SYNC_CNTMIN_The_0 $bool = no // The minimum loading point is disabled.
  let FTM3_SYNC_CNTMIN_The_1 $bool = yes // The minimum loading point is enabled.

//--- Enumerated values for register SYNC, field CNTMAX
  let FTM3_SYNC_CNTMAX_The_0 $bool = no // The maximum loading point is disabled.
  let FTM3_SYNC_CNTMAX_The_1 $bool = yes // The maximum loading point is enabled.

//--- Enumerated values for register SYNC, field REINIT
  let FTM3_SYNC_REINIT_FTM_0 $bool = no // FTM counter continues to count normally.
  let FTM3_SYNC_REINIT_FTM_1 $bool = yes // FTM counter is updated with its initial value when the selected trigger is detected.

//--- Enumerated values for register SYNC, field SYNCHOM
  let FTM3_SYNC_SYNCHOM_OUTMASK_0 $bool = no // OUTMASK register is updated with the value of its buffer in all rising edges of the system clock.
  let FTM3_SYNC_SYNCHOM_OUTMASK_1 $bool = yes // OUTMASK register is updated with the value of its buffer only by the PWM synchronization.

//--- Enumerated values for register SYNC, field TRIG0
  let FTM3_SYNC_TRIG0_Trigger_0 $bool = no // Trigger is disabled.
  let FTM3_SYNC_TRIG0_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG1
  let FTM3_SYNC_TRIG1_Trigger_0 $bool = no // Trigger is disabled.
  let FTM3_SYNC_TRIG1_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field TRIG2
  let FTM3_SYNC_TRIG2_Trigger_0 $bool = no // Trigger is disabled.
  let FTM3_SYNC_TRIG2_Trigger_1 $bool = yes // Trigger is enabled.

//--- Enumerated values for register SYNC, field SWSYNC
  let FTM3_SYNC_SWSYNC_Software_0 $bool = no // Software trigger is not selected.
  let FTM3_SYNC_SWSYNC_Software_1 $bool = yes // Software trigger is selected.

//--- Enumerated values for register OUTINIT, field CH0OI
  let FTM3_OUTINIT_CH0OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH0OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH1OI
  let FTM3_OUTINIT_CH1OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH1OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH2OI
  let FTM3_OUTINIT_CH2OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH2OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH3OI
  let FTM3_OUTINIT_CH3OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH3OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH4OI
  let FTM3_OUTINIT_CH4OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH4OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH5OI
  let FTM3_OUTINIT_CH5OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH5OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH6OI
  let FTM3_OUTINIT_CH6OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH6OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTINIT, field CH7OI
  let FTM3_OUTINIT_CH7OI_The_0 $bool = no // The initialization value is 0.
  let FTM3_OUTINIT_CH7OI_The_1 $bool = yes // The initialization value is 1.

//--- Enumerated values for register OUTMASK, field CH0OM
  let FTM3_OUTMASK_CH0OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH0OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH1OM
  let FTM3_OUTMASK_CH1OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH1OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH2OM
  let FTM3_OUTMASK_CH2OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH2OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH3OM
  let FTM3_OUTMASK_CH3OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH3OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH4OM
  let FTM3_OUTMASK_CH4OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH4OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH5OM
  let FTM3_OUTMASK_CH5OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH5OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH6OM
  let FTM3_OUTMASK_CH6OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH6OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register OUTMASK, field CH7OM
  let FTM3_OUTMASK_CH7OM_Channel_0 $bool = no // Channel output is not masked. It continues to operate normally.
  let FTM3_OUTMASK_CH7OM_Channel_1 $bool = yes // Channel output is masked. It is forced to its inactive state.

//--- Enumerated values for register COMBINE, field COMBINE0
  let FTM3_COMBINE_COMBINE0_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM3_COMBINE_COMBINE0_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP0
  let FTM3_COMBINE_COMP0_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM3_COMBINE_COMP0_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN0
  let FTM3_COMBINE_DECAPEN0_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM3_COMBINE_DECAPEN0_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP0
  let FTM3_COMBINE_DECAP0_The_0 $bool = no // The dual edge captures are inactive.
  let FTM3_COMBINE_DECAP0_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN0
  let FTM3_COMBINE_DTEN0_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM3_COMBINE_DTEN0_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN0
  let FTM3_COMBINE_SYNCEN0_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM3_COMBINE_SYNCEN0_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN0
  let FTM3_COMBINE_FAULTEN0_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM3_COMBINE_FAULTEN0_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE1
  let FTM3_COMBINE_COMBINE1_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM3_COMBINE_COMBINE1_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP1
  let FTM3_COMBINE_COMP1_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM3_COMBINE_COMP1_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN1
  let FTM3_COMBINE_DECAPEN1_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM3_COMBINE_DECAPEN1_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP1
  let FTM3_COMBINE_DECAP1_The_0 $bool = no // The dual edge captures are inactive.
  let FTM3_COMBINE_DECAP1_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN1
  let FTM3_COMBINE_DTEN1_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM3_COMBINE_DTEN1_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN1
  let FTM3_COMBINE_SYNCEN1_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM3_COMBINE_SYNCEN1_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN1
  let FTM3_COMBINE_FAULTEN1_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM3_COMBINE_FAULTEN1_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE2
  let FTM3_COMBINE_COMBINE2_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM3_COMBINE_COMBINE2_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP2
  let FTM3_COMBINE_COMP2_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM3_COMBINE_COMP2_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN2
  let FTM3_COMBINE_DECAPEN2_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM3_COMBINE_DECAPEN2_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP2
  let FTM3_COMBINE_DECAP2_The_0 $bool = no // The dual edge captures are inactive.
  let FTM3_COMBINE_DECAP2_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN2
  let FTM3_COMBINE_DTEN2_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM3_COMBINE_DTEN2_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN2
  let FTM3_COMBINE_SYNCEN2_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM3_COMBINE_SYNCEN2_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN2
  let FTM3_COMBINE_FAULTEN2_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM3_COMBINE_FAULTEN2_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field COMBINE3
  let FTM3_COMBINE_COMBINE3_Channels_0 $bool = no // Channels (n) and (n+1) are independent.
  let FTM3_COMBINE_COMBINE3_Channels_1 $bool = yes // Channels (n) and (n+1) are combined.

//--- Enumerated values for register COMBINE, field COMP3
  let FTM3_COMBINE_COMP3_The_0 $bool = no // The channel (n+1) output is the same as the channel (n) output.
  let FTM3_COMBINE_COMP3_The_1 $bool = yes // The channel (n+1) output is the complement of the channel (n) output.

//--- Enumerated values for register COMBINE, field DECAPEN3
  let FTM3_COMBINE_DECAPEN3_The_0 $bool = no // The Dual Edge Capture mode in this pair of channels is disabled.
  let FTM3_COMBINE_DECAPEN3_The_1 $bool = yes // The Dual Edge Capture mode in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field DECAP3
  let FTM3_COMBINE_DECAP3_The_0 $bool = no // The dual edge captures are inactive.
  let FTM3_COMBINE_DECAP3_The_1 $bool = yes // The dual edge captures are active.

//--- Enumerated values for register COMBINE, field DTEN3
  let FTM3_COMBINE_DTEN3_The_0 $bool = no // The deadtime insertion in this pair of channels is disabled.
  let FTM3_COMBINE_DTEN3_The_1 $bool = yes // The deadtime insertion in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field SYNCEN3
  let FTM3_COMBINE_SYNCEN3_The_0 $bool = no // The PWM synchronization in this pair of channels is disabled.
  let FTM3_COMBINE_SYNCEN3_The_1 $bool = yes // The PWM synchronization in this pair of channels is enabled.

//--- Enumerated values for register COMBINE, field FAULTEN3
  let FTM3_COMBINE_FAULTEN3_The_0 $bool = no // The fault control in this pair of channels is disabled.
  let FTM3_COMBINE_FAULTEN3_The_1 $bool = yes // The fault control in this pair of channels is enabled.

//--- Enumerated values for register DEADTIME, field DTPS
  let FTM3_DEADTIME_DTPS_Divide_0x $u2 = 0 // Divide the system clock by 1.
  let FTM3_DEADTIME_DTPS_Divide_10 $u2 = 2 // Divide the system clock by 4.
  let FTM3_DEADTIME_DTPS_Divide_11 $u2 = 3 // Divide the system clock by 16.

//--- Enumerated values for register EXTTRIG, field CH2TRIG
  let FTM3_EXTTRIG_CH2TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM3_EXTTRIG_CH2TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH3TRIG
  let FTM3_EXTTRIG_CH3TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM3_EXTTRIG_CH3TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH4TRIG
  let FTM3_EXTTRIG_CH4TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM3_EXTTRIG_CH4TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH5TRIG
  let FTM3_EXTTRIG_CH5TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM3_EXTTRIG_CH5TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH0TRIG
  let FTM3_EXTTRIG_CH0TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM3_EXTTRIG_CH0TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field CH1TRIG
  let FTM3_EXTTRIG_CH1TRIG_The_0 $bool = no // The generation of the channel trigger is disabled.
  let FTM3_EXTTRIG_CH1TRIG_The_1 $bool = yes // The generation of the channel trigger is enabled.

//--- Enumerated values for register EXTTRIG, field INITTRIGEN
  let FTM3_EXTTRIG_INITTRIGEN_The_0 $bool = no // The generation of initialization trigger is disabled.
  let FTM3_EXTTRIG_INITTRIGEN_The_1 $bool = yes // The generation of initialization trigger is enabled.

//--- Enumerated values for register EXTTRIG, field TRIGF
  let FTM3_EXTTRIG_TRIGF_No_0 $bool = no // No channel trigger was generated.
  let FTM3_EXTTRIG_TRIGF_A_1 $bool = yes // A channel trigger was generated.

//--- Enumerated values for register POL, field POL0
  let FTM3_POL_POL0_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL0_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL1
  let FTM3_POL_POL1_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL1_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL2
  let FTM3_POL_POL2_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL2_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL3
  let FTM3_POL_POL3_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL3_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL4
  let FTM3_POL_POL4_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL4_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL5
  let FTM3_POL_POL5_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL5_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL6
  let FTM3_POL_POL6_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL6_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL7
  let FTM3_POL_POL7_The_0 $bool = no // The channel polarity is active high.
  let FTM3_POL_POL7_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register FMS, field FAULTF0
  let FTM3_FMS_FAULTF0_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM3_FMS_FAULTF0_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF1
  let FTM3_FMS_FAULTF1_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM3_FMS_FAULTF1_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF2
  let FTM3_FMS_FAULTF2_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM3_FMS_FAULTF2_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTF3
  let FTM3_FMS_FAULTF3_No_0 $bool = no // No fault condition was detected at the fault input.
  let FTM3_FMS_FAULTF3_A_1 $bool = yes // A fault condition was detected at the fault input.

//--- Enumerated values for register FMS, field FAULTIN
  let FTM3_FMS_FAULTIN_The_0 $bool = no // The logic OR of the enabled fault inputs is 0.
  let FTM3_FMS_FAULTIN_The_1 $bool = yes // The logic OR of the enabled fault inputs is 1.

//--- Enumerated values for register FMS, field WPEN
  let FTM3_FMS_WPEN_Write_0 $bool = no // Write protection is disabled. Write protected bits can be written.
  let FTM3_FMS_WPEN_Write_1 $bool = yes // Write protection is enabled. Write protected bits cannot be written.

//--- Enumerated values for register FMS, field FAULTF
  let FTM3_FMS_FAULTF_No_0 $bool = no // No fault condition was detected.
  let FTM3_FMS_FAULTF_A_1 $bool = yes // A fault condition was detected.

//--- Enumerated values for register FLTCTRL, field FAULT0EN
  let FTM3_FLTCTRL_FAULT0EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM3_FLTCTRL_FAULT0EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT1EN
  let FTM3_FLTCTRL_FAULT1EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM3_FLTCTRL_FAULT1EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT2EN
  let FTM3_FLTCTRL_FAULT2EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM3_FLTCTRL_FAULT2EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FAULT3EN
  let FTM3_FLTCTRL_FAULT3EN_Fault_0 $bool = no // Fault input is disabled.
  let FTM3_FLTCTRL_FAULT3EN_Fault_1 $bool = yes // Fault input is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR0EN
  let FTM3_FLTCTRL_FFLTR0EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM3_FLTCTRL_FFLTR0EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR1EN
  let FTM3_FLTCTRL_FFLTR1EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM3_FLTCTRL_FFLTR1EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR2EN
  let FTM3_FLTCTRL_FFLTR2EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM3_FLTCTRL_FFLTR2EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register FLTCTRL, field FFLTR3EN
  let FTM3_FLTCTRL_FFLTR3EN_Fault_0 $bool = no // Fault input filter is disabled.
  let FTM3_FLTCTRL_FFLTR3EN_Fault_1 $bool = yes // Fault input filter is enabled.

//--- Enumerated values for register QDCTRL, field QUADEN
  let FTM3_QDCTRL_QUADEN_Quadrature_0 $bool = no // Quadrature Decoder mode is disabled.
  let FTM3_QDCTRL_QUADEN_Quadrature_1 $bool = yes // Quadrature Decoder mode is enabled.

//--- Enumerated values for register QDCTRL, field TOFDIR
  let FTM3_QDCTRL_TOFDIR_TOF_0 $bool = no // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
  let FTM3_QDCTRL_TOFDIR_TOF_1 $bool = yes // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).

//--- Enumerated values for register QDCTRL, field QUADIR
  let FTM3_QDCTRL_QUADIR_Counting_0 $bool = no // Counting direction is decreasing (FTM counter decrement).
  let FTM3_QDCTRL_QUADIR_Counting_1 $bool = yes // Counting direction is increasing (FTM counter increment).

//--- Enumerated values for register QDCTRL, field QUADMODE
  let FTM3_QDCTRL_QUADMODE_Phase_0 $bool = no // Phase A and phase B encoding mode.
  let FTM3_QDCTRL_QUADMODE_Count_1 $bool = yes // Count and direction encoding mode.

//--- Enumerated values for register QDCTRL, field PHBPOL
  let FTM3_QDCTRL_PHBPOL_Normal_0 $bool = no // Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM3_QDCTRL_PHBPOL_Inverted_1 $bool = yes // Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHAPOL
  let FTM3_QDCTRL_PHAPOL_Normal_0 $bool = no // Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
  let FTM3_QDCTRL_PHAPOL_Inverted_1 $bool = yes // Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.

//--- Enumerated values for register QDCTRL, field PHBFLTREN
  let FTM3_QDCTRL_PHBFLTREN_Phase_0 $bool = no // Phase B input filter is disabled.
  let FTM3_QDCTRL_PHBFLTREN_Phase_1 $bool = yes // Phase B input filter is enabled.

//--- Enumerated values for register QDCTRL, field PHAFLTREN
  let FTM3_QDCTRL_PHAFLTREN_Phase_0 $bool = no // Phase A input filter is disabled.
  let FTM3_QDCTRL_PHAFLTREN_Phase_1 $bool = yes // Phase A input filter is enabled.

//--- Enumerated values for register CONF, field GTBEEN
  let FTM3_CONF_GTBEEN_Use_0 $bool = no // Use of an external global time base is disabled.
  let FTM3_CONF_GTBEEN_Use_1 $bool = yes // Use of an external global time base is enabled.

//--- Enumerated values for register CONF, field GTBEOUT
  let FTM3_CONF_GTBEOUT_A_0 $bool = no // A global time base signal generation is disabled.
  let FTM3_CONF_GTBEOUT_A_1 $bool = yes // A global time base signal generation is enabled.

//--- Enumerated values for register FLTPOL, field FLT0POL
  let FTM3_FLTPOL_FLT0POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM3_FLTPOL_FLT0POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT1POL
  let FTM3_FLTPOL_FLT1POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM3_FLTPOL_FLT1POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT2POL
  let FTM3_FLTPOL_FLT2POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM3_FLTPOL_FLT2POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register FLTPOL, field FLT3POL
  let FTM3_FLTPOL_FLT3POL_The_0 $bool = no // The fault input polarity is active high. A 1 at the fault input indicates a fault.
  let FTM3_FLTPOL_FLT3POL_The_1 $bool = yes // The fault input polarity is active low. A 0 at the fault input indicates a fault.

//--- Enumerated values for register SYNCONF, field HWTRIGMODE
  let FTM3_SYNCONF_HWTRIGMODE_FTM_0 $bool = no // FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
  let FTM3_SYNCONF_HWTRIGMODE_FTM_1 $bool = yes // FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.

//--- Enumerated values for register SYNCONF, field CNTINC
  let FTM3_SYNCONF_CNTINC_CNTIN_0 $bool = no // CNTIN register is updated with its buffer value at all rising edges of system clock.
  let FTM3_SYNCONF_CNTINC_CNTIN_1 $bool = yes // CNTIN register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field INVC
  let FTM3_SYNCONF_INVC_INVCTRL_0 $bool = no // INVCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM3_SYNCONF_INVC_INVCTRL_1 $bool = yes // INVCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SWOC
  let FTM3_SYNCONF_SWOC_SWOCTRL_0 $bool = no // SWOCTRL register is updated with its buffer value at all rising edges of system clock.
  let FTM3_SYNCONF_SWOC_SWOCTRL_1 $bool = yes // SWOCTRL register is updated with its buffer value by the PWM synchronization.

//--- Enumerated values for register SYNCONF, field SYNCMODE
  let FTM3_SYNCONF_SYNCMODE_Legacy_0 $bool = no // Legacy PWM synchronization is selected.
  let FTM3_SYNCONF_SYNCMODE_Enhanced_1 $bool = yes // Enhanced PWM synchronization is selected.

//--- Enumerated values for register SYNCONF, field SWRSTCNT
  let FTM3_SYNCONF_SWRSTCNT_The_0 $bool = no // The software trigger does not activate the FTM counter synchronization.
  let FTM3_SYNCONF_SWRSTCNT_The_1 $bool = yes // The software trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field SWWRBUF
  let FTM3_SYNCONF_SWWRBUF_The_0 $bool = no // The software trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM3_SYNCONF_SWWRBUF_The_1 $bool = yes // The software trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field SWOM
  let FTM3_SYNCONF_SWOM_The_0 $bool = no // The software trigger does not activate the OUTMASK register synchronization.
  let FTM3_SYNCONF_SWOM_The_1 $bool = yes // The software trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field SWINVC
  let FTM3_SYNCONF_SWINVC_The_0 $bool = no // The software trigger does not activate the INVCTRL register synchronization.
  let FTM3_SYNCONF_SWINVC_The_1 $bool = yes // The software trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field SWSOC
  let FTM3_SYNCONF_SWSOC_The_0 $bool = no // The software trigger does not activate the SWOCTRL register synchronization.
  let FTM3_SYNCONF_SWSOC_The_1 $bool = yes // The software trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWRSTCNT
  let FTM3_SYNCONF_HWRSTCNT_A_0 $bool = no // A hardware trigger does not activate the FTM counter synchronization.
  let FTM3_SYNCONF_HWRSTCNT_A_1 $bool = yes // A hardware trigger activates the FTM counter synchronization.

//--- Enumerated values for register SYNCONF, field HWWRBUF
  let FTM3_SYNCONF_HWWRBUF_A_0 $bool = no // A hardware trigger does not activate MOD, CNTIN, and CV registers synchronization.
  let FTM3_SYNCONF_HWWRBUF_A_1 $bool = yes // A hardware trigger activates MOD, CNTIN, and CV registers synchronization.

//--- Enumerated values for register SYNCONF, field HWOM
  let FTM3_SYNCONF_HWOM_A_0 $bool = no // A hardware trigger does not activate the OUTMASK register synchronization.
  let FTM3_SYNCONF_HWOM_A_1 $bool = yes // A hardware trigger activates the OUTMASK register synchronization.

//--- Enumerated values for register SYNCONF, field HWINVC
  let FTM3_SYNCONF_HWINVC_A_0 $bool = no // A hardware trigger does not activate the INVCTRL register synchronization.
  let FTM3_SYNCONF_HWINVC_A_1 $bool = yes // A hardware trigger activates the INVCTRL register synchronization.

//--- Enumerated values for register SYNCONF, field HWSOC
  let FTM3_SYNCONF_HWSOC_A_0 $bool = no // A hardware trigger does not activate the SWOCTRL register synchronization.
  let FTM3_SYNCONF_HWSOC_A_1 $bool = yes // A hardware trigger activates the SWOCTRL register synchronization.

//--- Enumerated values for register INVCTRL, field INV0EN
  let FTM3_INVCTRL_INV0EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM3_INVCTRL_INV0EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV1EN
  let FTM3_INVCTRL_INV1EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM3_INVCTRL_INV1EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV2EN
  let FTM3_INVCTRL_INV2EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM3_INVCTRL_INV2EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register INVCTRL, field INV3EN
  let FTM3_INVCTRL_INV3EN_Inverting_0 $bool = no // Inverting is disabled.
  let FTM3_INVCTRL_INV3EN_Inverting_1 $bool = yes // Inverting is enabled.

//--- Enumerated values for register SWOCTRL, field CH0OC
  let FTM3_SWOCTRL_CH0OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH0OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH1OC
  let FTM3_SWOCTRL_CH1OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH1OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH2OC
  let FTM3_SWOCTRL_CH2OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH2OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH3OC
  let FTM3_SWOCTRL_CH3OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH3OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH4OC
  let FTM3_SWOCTRL_CH4OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH4OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH5OC
  let FTM3_SWOCTRL_CH5OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH5OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH6OC
  let FTM3_SWOCTRL_CH6OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH6OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH7OC
  let FTM3_SWOCTRL_CH7OC_The_0 $bool = no // The channel output is not affected by software output control.
  let FTM3_SWOCTRL_CH7OC_The_1 $bool = yes // The channel output is affected by software output control.

//--- Enumerated values for register SWOCTRL, field CH0OCV
  let FTM3_SWOCTRL_CH0OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH0OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH1OCV
  let FTM3_SWOCTRL_CH1OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH1OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH2OCV
  let FTM3_SWOCTRL_CH2OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH2OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH3OCV
  let FTM3_SWOCTRL_CH3OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH3OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH4OCV
  let FTM3_SWOCTRL_CH4OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH4OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH5OCV
  let FTM3_SWOCTRL_CH5OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH5OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH6OCV
  let FTM3_SWOCTRL_CH6OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH6OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register SWOCTRL, field CH7OCV
  let FTM3_SWOCTRL_CH7OCV_The_0 $bool = no // The software output control forces 0 to the channel output.
  let FTM3_SWOCTRL_CH7OCV_The_1 $bool = yes // The software output control forces 1 to the channel output.

//--- Enumerated values for register PWMLOAD, field CH0SEL
  let FTM3_PWMLOAD_CH0SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH0SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH1SEL
  let FTM3_PWMLOAD_CH1SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH1SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH2SEL
  let FTM3_PWMLOAD_CH2SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH2SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH3SEL
  let FTM3_PWMLOAD_CH3SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH3SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH4SEL
  let FTM3_PWMLOAD_CH4SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH4SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH5SEL
  let FTM3_PWMLOAD_CH5SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH5SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH6SEL
  let FTM3_PWMLOAD_CH6SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH6SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field CH7SEL
  let FTM3_PWMLOAD_CH7SEL_Do_0 $bool = no // Do not include the channel in the matching process.
  let FTM3_PWMLOAD_CH7SEL_Include_1 $bool = yes // Include the channel in the matching process.

//--- Enumerated values for register PWMLOAD, field LDOK
  let FTM3_PWMLOAD_LDOK_Loading_0 $bool = no // Loading updated values is disabled.
  let FTM3_PWMLOAD_LDOK_Loading_1 $bool = yes // Loading updated values is enabled.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©GPIO [5]
//        GPIOA at 0x400ff000
//        GPIOB at 0x400ff040
//        GPIOC at 0x400ff080
//        GPIOD at 0x400ff0c0
//        GPIOE at 0x400ff100
//------------------------------------------------------------------------------

registers ©GPIO [5 @at 0x400ff000 0x400ff040 0x400ff080 0x400ff0c0 0x400ff100]
          ©GPIOA @at 0x400ff000
          ©GPIOB @at 0x400ff040
          ©GPIOC @at 0x400ff080
          ©GPIOD @at 0x400ff0c0
          ©GPIOE @at 0x400ff100 {
//---  Register PDOR: Port Data Output Register
  PDOR @offset 0x0 $u32 {
    PDO:32 // at 0: Port Data Output
  }

//---  Register PSOR: Port Set Output Register
  PSOR @offset 0x4 $u32 {
    PTSO:32 // at 0: Port Set Output
  }

//---  Register PCOR: Port Clear Output Register
  PCOR @offset 0x8 $u32 {
    PTCO:32 // at 0: Port Clear Output
  }

//---  Register PTOR: Port Toggle Output Register
  PTOR @offset 0xc $u32 {
    PTTO:32 // at 0: Port Toggle Output
  }

//---  Register PDIR: Port Data Input Register
  PDIR @offset 0x10 @ro $u32 {
    PDI:32 // at 0: Port Data Input
  }

//---  Register PDDR: Port Data Direction Register
  PDDR @offset 0x14 $u32 {
    PDD:32 // at 0: Port Data Direction
  }

}

//--- Enumerated values for register PDOR, field PDO
  let GPIOA_PDOR_PDO_Logic_0 $u32 = 0 // Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
  let GPIOA_PDOR_PDO_Logic_1 $u32 = 1 // Logic level 1 is driven on pin, provided pin is configured for general-purpose output.

//--- Enumerated values for register PSOR, field PTSO
  let GPIOA_PSOR_PTSO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOA_PSOR_PTSO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to logic 1.

//--- Enumerated values for register PCOR, field PTCO
  let GPIOA_PCOR_PTCO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOA_PCOR_PTCO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is cleared to logic 0.

//--- Enumerated values for register PTOR, field PTTO
  let GPIOA_PTOR_PTTO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOA_PTOR_PTTO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to the inverse of its existing logic state.

//--- Enumerated values for register PDIR, field PDI
  let GPIOA_PDIR_PDI_Pin_0 $u32 = 0 // Pin logic level is logic 0, or is not configured for use by digital function.
  let GPIOA_PDIR_PDI_Pin_1 $u32 = 1 // Pin logic level is logic 1.

//--- Enumerated values for register PDDR, field PDD
  let GPIOA_PDDR_PDD_Pin_0 $u32 = 0 // Pin is configured as general-purpose input, for the GPIO function.
  let GPIOA_PDDR_PDD_Pin_1 $u32 = 1 // Pin is configured as general-purpose output, for the GPIO function.

//--- Enumerated values for register PDOR, field PDO
  let GPIOB_PDOR_PDO_Logic_0 $u32 = 0 // Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
  let GPIOB_PDOR_PDO_Logic_1 $u32 = 1 // Logic level 1 is driven on pin, provided pin is configured for general-purpose output.

//--- Enumerated values for register PSOR, field PTSO
  let GPIOB_PSOR_PTSO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOB_PSOR_PTSO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to logic 1.

//--- Enumerated values for register PCOR, field PTCO
  let GPIOB_PCOR_PTCO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOB_PCOR_PTCO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is cleared to logic 0.

//--- Enumerated values for register PTOR, field PTTO
  let GPIOB_PTOR_PTTO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOB_PTOR_PTTO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to the inverse of its existing logic state.

//--- Enumerated values for register PDIR, field PDI
  let GPIOB_PDIR_PDI_Pin_0 $u32 = 0 // Pin logic level is logic 0, or is not configured for use by digital function.
  let GPIOB_PDIR_PDI_Pin_1 $u32 = 1 // Pin logic level is logic 1.

//--- Enumerated values for register PDDR, field PDD
  let GPIOB_PDDR_PDD_Pin_0 $u32 = 0 // Pin is configured as general-purpose input, for the GPIO function.
  let GPIOB_PDDR_PDD_Pin_1 $u32 = 1 // Pin is configured as general-purpose output, for the GPIO function.

//--- Enumerated values for register PDOR, field PDO
  let GPIOC_PDOR_PDO_Logic_0 $u32 = 0 // Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
  let GPIOC_PDOR_PDO_Logic_1 $u32 = 1 // Logic level 1 is driven on pin, provided pin is configured for general-purpose output.

//--- Enumerated values for register PSOR, field PTSO
  let GPIOC_PSOR_PTSO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOC_PSOR_PTSO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to logic 1.

//--- Enumerated values for register PCOR, field PTCO
  let GPIOC_PCOR_PTCO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOC_PCOR_PTCO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is cleared to logic 0.

//--- Enumerated values for register PTOR, field PTTO
  let GPIOC_PTOR_PTTO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOC_PTOR_PTTO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to the inverse of its existing logic state.

//--- Enumerated values for register PDIR, field PDI
  let GPIOC_PDIR_PDI_Pin_0 $u32 = 0 // Pin logic level is logic 0, or is not configured for use by digital function.
  let GPIOC_PDIR_PDI_Pin_1 $u32 = 1 // Pin logic level is logic 1.

//--- Enumerated values for register PDDR, field PDD
  let GPIOC_PDDR_PDD_Pin_0 $u32 = 0 // Pin is configured as general-purpose input, for the GPIO function.
  let GPIOC_PDDR_PDD_Pin_1 $u32 = 1 // Pin is configured as general-purpose output, for the GPIO function.

//--- Enumerated values for register PDOR, field PDO
  let GPIOD_PDOR_PDO_Logic_0 $u32 = 0 // Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
  let GPIOD_PDOR_PDO_Logic_1 $u32 = 1 // Logic level 1 is driven on pin, provided pin is configured for general-purpose output.

//--- Enumerated values for register PSOR, field PTSO
  let GPIOD_PSOR_PTSO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOD_PSOR_PTSO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to logic 1.

//--- Enumerated values for register PCOR, field PTCO
  let GPIOD_PCOR_PTCO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOD_PCOR_PTCO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is cleared to logic 0.

//--- Enumerated values for register PTOR, field PTTO
  let GPIOD_PTOR_PTTO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOD_PTOR_PTTO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to the inverse of its existing logic state.

//--- Enumerated values for register PDIR, field PDI
  let GPIOD_PDIR_PDI_Pin_0 $u32 = 0 // Pin logic level is logic 0, or is not configured for use by digital function.
  let GPIOD_PDIR_PDI_Pin_1 $u32 = 1 // Pin logic level is logic 1.

//--- Enumerated values for register PDDR, field PDD
  let GPIOD_PDDR_PDD_Pin_0 $u32 = 0 // Pin is configured as general-purpose input, for the GPIO function.
  let GPIOD_PDDR_PDD_Pin_1 $u32 = 1 // Pin is configured as general-purpose output, for the GPIO function.

//--- Enumerated values for register PDOR, field PDO
  let GPIOE_PDOR_PDO_Logic_0 $u32 = 0 // Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
  let GPIOE_PDOR_PDO_Logic_1 $u32 = 1 // Logic level 1 is driven on pin, provided pin is configured for general-purpose output.

//--- Enumerated values for register PSOR, field PTSO
  let GPIOE_PSOR_PTSO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOE_PSOR_PTSO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to logic 1.

//--- Enumerated values for register PCOR, field PTCO
  let GPIOE_PCOR_PTCO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOE_PCOR_PTCO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is cleared to logic 0.

//--- Enumerated values for register PTOR, field PTTO
  let GPIOE_PTOR_PTTO_Corresponding_0 $u32 = 0 // Corresponding bit in PDORn does not change.
  let GPIOE_PTOR_PTTO_Corresponding_1 $u32 = 1 // Corresponding bit in PDORn is set to the inverse of its existing logic state.

//--- Enumerated values for register PDIR, field PDI
  let GPIOE_PDIR_PDI_Pin_0 $u32 = 0 // Pin logic level is logic 0, or is not configured for use by digital function.
  let GPIOE_PDIR_PDI_Pin_1 $u32 = 1 // Pin logic level is logic 1.

//--- Enumerated values for register PDDR, field PDD
  let GPIOE_PDDR_PDD_Pin_0 $u32 = 0 // Pin is configured as general-purpose input, for the GPIO function.
  let GPIOE_PDDR_PDD_Pin_1 $u32 = 1 // Pin is configured as general-purpose output, for the GPIO function.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©I2C [4]
//        I2C0 at 0x40066000
//        I2C1 at 0x40067000
//        I2C2 at 0x400e6000
//        I2C3 at 0x400e7000
//------------------------------------------------------------------------------

registers ©I2C [4 @at 0x40066000 0x40067000 0x400e6000 0x400e7000]
          ©I2C0 @at 0x40066000
          ©I2C1 @at 0x40067000
          ©I2C2 @at 0x400e6000
          ©I2C3 @at 0x400e7000 {
//---  Register A1: I2C Address Register 1
  A1 @offset 0x0 $u8 {
    AD:7 // at 1: Address
    1
  }

//---  Register F: I2C Frequency Divider register
  F @offset 0x1 $u8 {
    MULT:2 // at 6: Multiplier Factor
    ICR:6 // at 0: ClockRate
  }

//---  Register C1: I2C Control Register 1
  C1 @offset 0x2 $u8 {
    IICEN // at 7: I2C Enable
    IICIE // at 6: I2C Interrupt Enable
    MST // at 5: Master Mode Select
    TX // at 4: Transmit Mode Select
    TXAK // at 3: Transmit Acknowledge Enable
    RSTA // at 2: Repeat START
    WUEN // at 1: Wakeup Enable
    DMAEN // at 0: DMA Enable
  }

//---  Register S: I2C Status register
  S @offset 0x3 $u8 {
    TCF // at 7: Transfer Complete Flag
    IAAS // at 6: Addressed As A Slave
    BUSY // at 5: Bus Busy
    ARBL // at 4: Arbitration Lost
    RAM // at 3: Range Address Match
    SRW // at 2: Slave Read/Write
    IICIF // at 1: Interrupt Flag
    RXAK // at 0: Receive Acknowledge
  }

//---  Register D: I2C Data I/O register
  D @offset 0x4 $u8 {
    DATA:8 // at 0: Data
  }

//---  Register C2: I2C Control Register 2
  C2 @offset 0x5 $u8 {
    GCAEN // at 7: General Call Address Enable
    ADEXT // at 6: Address Extension
    HDRS // at 5: High Drive Select
    SBRC // at 4: Slave Baud Rate Control
    RMEN // at 3: Range Address Matching Enable
    AD:3 // at 0: Slave Address
  }

//---  Register FLT: I2C Programmable Input Glitch Filter Register
  FLT @offset 0x6 $u8 {
    SHEN // at 7: Stop Hold Enable
    STOPF // at 6: I2C Bus Stop Detect Flag
    SSIE // at 5: I2C Bus Stop or Start Interrupt Enable
    STARTF // at 4: I2C Bus Start Detect Flag
    FLT:4 // at 0: I2C Programmable Filter Factor
  }

//---  Register RA: I2C Range Address register
  RA @offset 0x7 $u8 {
    RAD:7 // at 1: Range Slave Address
    1
  }

//---  Register SMB: I2C SMBus Control and Status register
  SMB @offset 0x8 $u8 {
    FACK // at 7: Fast NACK/ACK Enable
    ALERTEN // at 6: SMBus Alert Response Address Enable
    SIICAEN // at 5: Second I2C Address Enable
    TCKSEL // at 4: Timeout Counter Clock Select
    SLTF // at 3: SCL Low Timeout Flag
    SHTF1 // at 2: SCL High Timeout Flag 1
    SHTF2 // at 1: SCL High Timeout Flag 2
    SHTF2IE // at 0: SHTF2 Interrupt Enable
  }

//---  Register A2: I2C Address Register 2
  A2 @offset 0x9 $u8 {
    SAD:7 // at 1: SMBus Address
    1
  }

//---  Register SLTH: I2C SCL Low Timeout Register High
  SLTH @offset 0xa $u8 {
    SSLT:8 // at 0: SSLT[15:8]
  }

//---  Register SLTL: I2C SCL Low Timeout Register Low
  SLTL @offset 0xb $u8 {
    SSLT:8 // at 0: SSLT[7:0]
  }

}

//--- Enumerated values for register F, field MULT
  let I2C0_F_MULT_mul_00 $u2 = 0 // mul = 1
  let I2C0_F_MULT_mul_01 $u2 = 1 // mul = 2
  let I2C0_F_MULT_mul_10 $u2 = 2 // mul = 4

//--- Enumerated values for register C1, field DMAEN
  let I2C0_C1_DMAEN_All_0 $bool = no // All DMA signalling disabled.
  let I2C0_C1_DMAEN_DMA_1 $bool = yes // DMA transfer is enabled. While SMB[FACK] = 0, the following conditions trigger the DMA request: a data byte is received, and either address or data is transmitted. (ACK/NACK is automatic) the first byte received matches the A1 register or is a general call address. If any address matching occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known from master to slave, then it is not required to check S[SRW]. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.

//--- Enumerated values for register C1, field WUEN
  let I2C0_C1_WUEN_Normal_0 $bool = no // Normal operation. No interrupt generated when address matching in low power mode.
  let I2C0_C1_WUEN_Enables_1 $bool = yes // Enables the wakeup function in low power mode.

//--- Enumerated values for register C1, field TXAK
  let I2C0_C1_TXAK_An_0 $bool = no // An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
  let I2C0_C1_TXAK_No_1 $bool = yes // No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).

//--- Enumerated values for register C1, field TX
  let I2C0_C1_TX_Receive_0 $bool = no // Receive
  let I2C0_C1_TX_Transmit_1 $bool = yes // Transmit

//--- Enumerated values for register C1, field MST
  let I2C0_C1_MST_Slave_0 $bool = no // Slave mode
  let I2C0_C1_MST_Master_1 $bool = yes // Master mode

//--- Enumerated values for register C1, field IICIE
  let I2C0_C1_IICIE_Disabled_0 $bool = no // Disabled
  let I2C0_C1_IICIE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register C1, field IICEN
  let I2C0_C1_IICEN_Disabled_0 $bool = no // Disabled
  let I2C0_C1_IICEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register S, field RXAK
  let I2C0_S_RXAK_Acknowledge_0 $bool = no // Acknowledge signal was received after the completion of one byte of data transmission on the bus
  let I2C0_S_RXAK_No_1 $bool = yes // No acknowledge signal detected

//--- Enumerated values for register S, field IICIF
  let I2C0_S_IICIF_No_0 $bool = no // No interrupt pending
  let I2C0_S_IICIF_Interrupt_1 $bool = yes // Interrupt pending

//--- Enumerated values for register S, field SRW
  let I2C0_S_SRW_Slave_0 $bool = no // Slave receive, master writing to slave
  let I2C0_S_SRW_Slave_1 $bool = yes // Slave transmit, master reading from slave

//--- Enumerated values for register S, field RAM
  let I2C0_S_RAM_Not_0 $bool = no // Not addressed
  let I2C0_S_RAM_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field ARBL
  let I2C0_S_ARBL_Standard_0 $bool = no // Standard bus operation.
  let I2C0_S_ARBL_Loss_1 $bool = yes // Loss of arbitration.

//--- Enumerated values for register S, field BUSY
  let I2C0_S_BUSY_Bus_0 $bool = no // Bus is idle
  let I2C0_S_BUSY_Bus_1 $bool = yes // Bus is busy

//--- Enumerated values for register S, field IAAS
  let I2C0_S_IAAS_Not_0 $bool = no // Not addressed
  let I2C0_S_IAAS_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field TCF
  let I2C0_S_TCF_Transfer_0 $bool = no // Transfer in progress
  let I2C0_S_TCF_Transfer_1 $bool = yes // Transfer complete

//--- Enumerated values for register C2, field RMEN
  let I2C0_C2_RMEN_Range_0 $bool = no // Range mode disabled. No address matching occurs for an address within the range of values of the A1 and RA registers.
  let I2C0_C2_RMEN_Range_1 $bool = yes // Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.

//--- Enumerated values for register C2, field SBRC
  let I2C0_C2_SBRC_The_0 $bool = no // The slave baud rate follows the master baud rate and clock stretching may occur
  let I2C0_C2_SBRC_Slave_1 $bool = yes // Slave baud rate is independent of the master baud rate

//--- Enumerated values for register C2, field HDRS
  let I2C0_C2_HDRS_Normal_0 $bool = no // Normal drive mode
  let I2C0_C2_HDRS_High_1 $bool = yes // High drive mode

//--- Enumerated values for register C2, field ADEXT
  let I2C0_C2_ADEXT_7_bit_0 $bool = no // 7-bit address scheme
  let I2C0_C2_ADEXT_10_bit_1 $bool = yes // 10-bit address scheme

//--- Enumerated values for register C2, field GCAEN
  let I2C0_C2_GCAEN_Disabled_0 $bool = no // Disabled
  let I2C0_C2_GCAEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register FLT, field FLT
  let I2C0_FLT_FLT_No_0 $u4 = 0 // No filter/bypass

//--- Enumerated values for register FLT, field STARTF
  let I2C0_FLT_STARTF_No_0 $bool = no // No start happens on I2C bus
  let I2C0_FLT_STARTF_Start_1 $bool = yes // Start detected on I2C bus

//--- Enumerated values for register FLT, field SSIE
  let I2C0_FLT_SSIE_Stop_0 $bool = no // Stop or start detection interrupt is disabled
  let I2C0_FLT_SSIE_Stop_1 $bool = yes // Stop or start detection interrupt is enabled

//--- Enumerated values for register FLT, field STOPF
  let I2C0_FLT_STOPF_No_0 $bool = no // No stop happens on I2C bus
  let I2C0_FLT_STOPF_Stop_1 $bool = yes // Stop detected on I2C bus

//--- Enumerated values for register FLT, field SHEN
  let I2C0_FLT_SHEN_Stop_0 $bool = no // Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
  let I2C0_FLT_SHEN_Stop_1 $bool = yes // Stop holdoff is enabled.

//--- Enumerated values for register SMB, field SHTF2IE
  let I2C0_SMB_SHTF2IE_SHTF2_0 $bool = no // SHTF2 interrupt is disabled
  let I2C0_SMB_SHTF2IE_SHTF2_1 $bool = yes // SHTF2 interrupt is enabled

//--- Enumerated values for register SMB, field SHTF2
  let I2C0_SMB_SHTF2_No_0 $bool = no // No SCL high and SDA low timeout occurs
  let I2C0_SMB_SHTF2_SCL_1 $bool = yes // SCL high and SDA low timeout occurs

//--- Enumerated values for register SMB, field SHTF1
  let I2C0_SMB_SHTF1_No_0 $bool = no // No SCL high and SDA high timeout occurs
  let I2C0_SMB_SHTF1_SCL_1 $bool = yes // SCL high and SDA high timeout occurs

//--- Enumerated values for register SMB, field SLTF
  let I2C0_SMB_SLTF_No_0 $bool = no // No low timeout occurs
  let I2C0_SMB_SLTF_Low_1 $bool = yes // Low timeout occurs

//--- Enumerated values for register SMB, field TCKSEL
  let I2C0_SMB_TCKSEL_Timeout_0 $bool = no // Timeout counter counts at the frequency of the I2C module clock / 64
  let I2C0_SMB_TCKSEL_Timeout_1 $bool = yes // Timeout counter counts at the frequency of the I2C module clock

//--- Enumerated values for register SMB, field SIICAEN
  let I2C0_SMB_SIICAEN_I2C_0 $bool = no // I2C address register 2 matching is disabled
  let I2C0_SMB_SIICAEN_I2C_1 $bool = yes // I2C address register 2 matching is enabled

//--- Enumerated values for register SMB, field ALERTEN
  let I2C0_SMB_ALERTEN_SMBus_0 $bool = no // SMBus alert response address matching is disabled
  let I2C0_SMB_ALERTEN_SMBus_1 $bool = yes // SMBus alert response address matching is enabled

//--- Enumerated values for register SMB, field FACK
  let I2C0_SMB_FACK_An_0 $bool = no // An ACK or NACK is sent on the following receiving data byte
  let I2C0_SMB_FACK_Writing_1 $bool = yes // Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.

//--- Enumerated values for register F, field MULT
  let I2C1_F_MULT_mul_00 $u2 = 0 // mul = 1
  let I2C1_F_MULT_mul_01 $u2 = 1 // mul = 2
  let I2C1_F_MULT_mul_10 $u2 = 2 // mul = 4

//--- Enumerated values for register C1, field DMAEN
  let I2C1_C1_DMAEN_All_0 $bool = no // All DMA signalling disabled.
  let I2C1_C1_DMAEN_DMA_1 $bool = yes // DMA transfer is enabled. While SMB[FACK] = 0, the following conditions trigger the DMA request: a data byte is received, and either address or data is transmitted. (ACK/NACK is automatic) the first byte received matches the A1 register or is a general call address. If any address matching occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known from master to slave, then it is not required to check S[SRW]. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.

//--- Enumerated values for register C1, field WUEN
  let I2C1_C1_WUEN_Normal_0 $bool = no // Normal operation. No interrupt generated when address matching in low power mode.
  let I2C1_C1_WUEN_Enables_1 $bool = yes // Enables the wakeup function in low power mode.

//--- Enumerated values for register C1, field TXAK
  let I2C1_C1_TXAK_An_0 $bool = no // An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
  let I2C1_C1_TXAK_No_1 $bool = yes // No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).

//--- Enumerated values for register C1, field TX
  let I2C1_C1_TX_Receive_0 $bool = no // Receive
  let I2C1_C1_TX_Transmit_1 $bool = yes // Transmit

//--- Enumerated values for register C1, field MST
  let I2C1_C1_MST_Slave_0 $bool = no // Slave mode
  let I2C1_C1_MST_Master_1 $bool = yes // Master mode

//--- Enumerated values for register C1, field IICIE
  let I2C1_C1_IICIE_Disabled_0 $bool = no // Disabled
  let I2C1_C1_IICIE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register C1, field IICEN
  let I2C1_C1_IICEN_Disabled_0 $bool = no // Disabled
  let I2C1_C1_IICEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register S, field RXAK
  let I2C1_S_RXAK_Acknowledge_0 $bool = no // Acknowledge signal was received after the completion of one byte of data transmission on the bus
  let I2C1_S_RXAK_No_1 $bool = yes // No acknowledge signal detected

//--- Enumerated values for register S, field IICIF
  let I2C1_S_IICIF_No_0 $bool = no // No interrupt pending
  let I2C1_S_IICIF_Interrupt_1 $bool = yes // Interrupt pending

//--- Enumerated values for register S, field SRW
  let I2C1_S_SRW_Slave_0 $bool = no // Slave receive, master writing to slave
  let I2C1_S_SRW_Slave_1 $bool = yes // Slave transmit, master reading from slave

//--- Enumerated values for register S, field RAM
  let I2C1_S_RAM_Not_0 $bool = no // Not addressed
  let I2C1_S_RAM_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field ARBL
  let I2C1_S_ARBL_Standard_0 $bool = no // Standard bus operation.
  let I2C1_S_ARBL_Loss_1 $bool = yes // Loss of arbitration.

//--- Enumerated values for register S, field BUSY
  let I2C1_S_BUSY_Bus_0 $bool = no // Bus is idle
  let I2C1_S_BUSY_Bus_1 $bool = yes // Bus is busy

//--- Enumerated values for register S, field IAAS
  let I2C1_S_IAAS_Not_0 $bool = no // Not addressed
  let I2C1_S_IAAS_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field TCF
  let I2C1_S_TCF_Transfer_0 $bool = no // Transfer in progress
  let I2C1_S_TCF_Transfer_1 $bool = yes // Transfer complete

//--- Enumerated values for register C2, field RMEN
  let I2C1_C2_RMEN_Range_0 $bool = no // Range mode disabled. No address matching occurs for an address within the range of values of the A1 and RA registers.
  let I2C1_C2_RMEN_Range_1 $bool = yes // Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.

//--- Enumerated values for register C2, field SBRC
  let I2C1_C2_SBRC_The_0 $bool = no // The slave baud rate follows the master baud rate and clock stretching may occur
  let I2C1_C2_SBRC_Slave_1 $bool = yes // Slave baud rate is independent of the master baud rate

//--- Enumerated values for register C2, field HDRS
  let I2C1_C2_HDRS_Normal_0 $bool = no // Normal drive mode
  let I2C1_C2_HDRS_High_1 $bool = yes // High drive mode

//--- Enumerated values for register C2, field ADEXT
  let I2C1_C2_ADEXT_7_bit_0 $bool = no // 7-bit address scheme
  let I2C1_C2_ADEXT_10_bit_1 $bool = yes // 10-bit address scheme

//--- Enumerated values for register C2, field GCAEN
  let I2C1_C2_GCAEN_Disabled_0 $bool = no // Disabled
  let I2C1_C2_GCAEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register FLT, field FLT
  let I2C1_FLT_FLT_No_0 $u4 = 0 // No filter/bypass

//--- Enumerated values for register FLT, field STARTF
  let I2C1_FLT_STARTF_No_0 $bool = no // No start happens on I2C bus
  let I2C1_FLT_STARTF_Start_1 $bool = yes // Start detected on I2C bus

//--- Enumerated values for register FLT, field SSIE
  let I2C1_FLT_SSIE_Stop_0 $bool = no // Stop or start detection interrupt is disabled
  let I2C1_FLT_SSIE_Stop_1 $bool = yes // Stop or start detection interrupt is enabled

//--- Enumerated values for register FLT, field STOPF
  let I2C1_FLT_STOPF_No_0 $bool = no // No stop happens on I2C bus
  let I2C1_FLT_STOPF_Stop_1 $bool = yes // Stop detected on I2C bus

//--- Enumerated values for register FLT, field SHEN
  let I2C1_FLT_SHEN_Stop_0 $bool = no // Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
  let I2C1_FLT_SHEN_Stop_1 $bool = yes // Stop holdoff is enabled.

//--- Enumerated values for register SMB, field SHTF2IE
  let I2C1_SMB_SHTF2IE_SHTF2_0 $bool = no // SHTF2 interrupt is disabled
  let I2C1_SMB_SHTF2IE_SHTF2_1 $bool = yes // SHTF2 interrupt is enabled

//--- Enumerated values for register SMB, field SHTF2
  let I2C1_SMB_SHTF2_No_0 $bool = no // No SCL high and SDA low timeout occurs
  let I2C1_SMB_SHTF2_SCL_1 $bool = yes // SCL high and SDA low timeout occurs

//--- Enumerated values for register SMB, field SHTF1
  let I2C1_SMB_SHTF1_No_0 $bool = no // No SCL high and SDA high timeout occurs
  let I2C1_SMB_SHTF1_SCL_1 $bool = yes // SCL high and SDA high timeout occurs

//--- Enumerated values for register SMB, field SLTF
  let I2C1_SMB_SLTF_No_0 $bool = no // No low timeout occurs
  let I2C1_SMB_SLTF_Low_1 $bool = yes // Low timeout occurs

//--- Enumerated values for register SMB, field TCKSEL
  let I2C1_SMB_TCKSEL_Timeout_0 $bool = no // Timeout counter counts at the frequency of the I2C module clock / 64
  let I2C1_SMB_TCKSEL_Timeout_1 $bool = yes // Timeout counter counts at the frequency of the I2C module clock

//--- Enumerated values for register SMB, field SIICAEN
  let I2C1_SMB_SIICAEN_I2C_0 $bool = no // I2C address register 2 matching is disabled
  let I2C1_SMB_SIICAEN_I2C_1 $bool = yes // I2C address register 2 matching is enabled

//--- Enumerated values for register SMB, field ALERTEN
  let I2C1_SMB_ALERTEN_SMBus_0 $bool = no // SMBus alert response address matching is disabled
  let I2C1_SMB_ALERTEN_SMBus_1 $bool = yes // SMBus alert response address matching is enabled

//--- Enumerated values for register SMB, field FACK
  let I2C1_SMB_FACK_An_0 $bool = no // An ACK or NACK is sent on the following receiving data byte
  let I2C1_SMB_FACK_Writing_1 $bool = yes // Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.

//--- Enumerated values for register F, field MULT
  let I2C2_F_MULT_mul_00 $u2 = 0 // mul = 1
  let I2C2_F_MULT_mul_01 $u2 = 1 // mul = 2
  let I2C2_F_MULT_mul_10 $u2 = 2 // mul = 4

//--- Enumerated values for register C1, field DMAEN
  let I2C2_C1_DMAEN_All_0 $bool = no // All DMA signalling disabled.
  let I2C2_C1_DMAEN_DMA_1 $bool = yes // DMA transfer is enabled. While SMB[FACK] = 0, the following conditions trigger the DMA request: a data byte is received, and either address or data is transmitted. (ACK/NACK is automatic) the first byte received matches the A1 register or is a general call address. If any address matching occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known from master to slave, then it is not required to check S[SRW]. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.

//--- Enumerated values for register C1, field WUEN
  let I2C2_C1_WUEN_Normal_0 $bool = no // Normal operation. No interrupt generated when address matching in low power mode.
  let I2C2_C1_WUEN_Enables_1 $bool = yes // Enables the wakeup function in low power mode.

//--- Enumerated values for register C1, field TXAK
  let I2C2_C1_TXAK_An_0 $bool = no // An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
  let I2C2_C1_TXAK_No_1 $bool = yes // No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).

//--- Enumerated values for register C1, field TX
  let I2C2_C1_TX_Receive_0 $bool = no // Receive
  let I2C2_C1_TX_Transmit_1 $bool = yes // Transmit

//--- Enumerated values for register C1, field MST
  let I2C2_C1_MST_Slave_0 $bool = no // Slave mode
  let I2C2_C1_MST_Master_1 $bool = yes // Master mode

//--- Enumerated values for register C1, field IICIE
  let I2C2_C1_IICIE_Disabled_0 $bool = no // Disabled
  let I2C2_C1_IICIE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register C1, field IICEN
  let I2C2_C1_IICEN_Disabled_0 $bool = no // Disabled
  let I2C2_C1_IICEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register S, field RXAK
  let I2C2_S_RXAK_Acknowledge_0 $bool = no // Acknowledge signal was received after the completion of one byte of data transmission on the bus
  let I2C2_S_RXAK_No_1 $bool = yes // No acknowledge signal detected

//--- Enumerated values for register S, field IICIF
  let I2C2_S_IICIF_No_0 $bool = no // No interrupt pending
  let I2C2_S_IICIF_Interrupt_1 $bool = yes // Interrupt pending

//--- Enumerated values for register S, field SRW
  let I2C2_S_SRW_Slave_0 $bool = no // Slave receive, master writing to slave
  let I2C2_S_SRW_Slave_1 $bool = yes // Slave transmit, master reading from slave

//--- Enumerated values for register S, field RAM
  let I2C2_S_RAM_Not_0 $bool = no // Not addressed
  let I2C2_S_RAM_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field ARBL
  let I2C2_S_ARBL_Standard_0 $bool = no // Standard bus operation.
  let I2C2_S_ARBL_Loss_1 $bool = yes // Loss of arbitration.

//--- Enumerated values for register S, field BUSY
  let I2C2_S_BUSY_Bus_0 $bool = no // Bus is idle
  let I2C2_S_BUSY_Bus_1 $bool = yes // Bus is busy

//--- Enumerated values for register S, field IAAS
  let I2C2_S_IAAS_Not_0 $bool = no // Not addressed
  let I2C2_S_IAAS_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field TCF
  let I2C2_S_TCF_Transfer_0 $bool = no // Transfer in progress
  let I2C2_S_TCF_Transfer_1 $bool = yes // Transfer complete

//--- Enumerated values for register C2, field RMEN
  let I2C2_C2_RMEN_Range_0 $bool = no // Range mode disabled. No address matching occurs for an address within the range of values of the A1 and RA registers.
  let I2C2_C2_RMEN_Range_1 $bool = yes // Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.

//--- Enumerated values for register C2, field SBRC
  let I2C2_C2_SBRC_The_0 $bool = no // The slave baud rate follows the master baud rate and clock stretching may occur
  let I2C2_C2_SBRC_Slave_1 $bool = yes // Slave baud rate is independent of the master baud rate

//--- Enumerated values for register C2, field HDRS
  let I2C2_C2_HDRS_Normal_0 $bool = no // Normal drive mode
  let I2C2_C2_HDRS_High_1 $bool = yes // High drive mode

//--- Enumerated values for register C2, field ADEXT
  let I2C2_C2_ADEXT_7_bit_0 $bool = no // 7-bit address scheme
  let I2C2_C2_ADEXT_10_bit_1 $bool = yes // 10-bit address scheme

//--- Enumerated values for register C2, field GCAEN
  let I2C2_C2_GCAEN_Disabled_0 $bool = no // Disabled
  let I2C2_C2_GCAEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register FLT, field FLT
  let I2C2_FLT_FLT_No_0 $u4 = 0 // No filter/bypass

//--- Enumerated values for register FLT, field STARTF
  let I2C2_FLT_STARTF_No_0 $bool = no // No start happens on I2C bus
  let I2C2_FLT_STARTF_Start_1 $bool = yes // Start detected on I2C bus

//--- Enumerated values for register FLT, field SSIE
  let I2C2_FLT_SSIE_Stop_0 $bool = no // Stop or start detection interrupt is disabled
  let I2C2_FLT_SSIE_Stop_1 $bool = yes // Stop or start detection interrupt is enabled

//--- Enumerated values for register FLT, field STOPF
  let I2C2_FLT_STOPF_No_0 $bool = no // No stop happens on I2C bus
  let I2C2_FLT_STOPF_Stop_1 $bool = yes // Stop detected on I2C bus

//--- Enumerated values for register FLT, field SHEN
  let I2C2_FLT_SHEN_Stop_0 $bool = no // Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
  let I2C2_FLT_SHEN_Stop_1 $bool = yes // Stop holdoff is enabled.

//--- Enumerated values for register SMB, field SHTF2IE
  let I2C2_SMB_SHTF2IE_SHTF2_0 $bool = no // SHTF2 interrupt is disabled
  let I2C2_SMB_SHTF2IE_SHTF2_1 $bool = yes // SHTF2 interrupt is enabled

//--- Enumerated values for register SMB, field SHTF2
  let I2C2_SMB_SHTF2_No_0 $bool = no // No SCL high and SDA low timeout occurs
  let I2C2_SMB_SHTF2_SCL_1 $bool = yes // SCL high and SDA low timeout occurs

//--- Enumerated values for register SMB, field SHTF1
  let I2C2_SMB_SHTF1_No_0 $bool = no // No SCL high and SDA high timeout occurs
  let I2C2_SMB_SHTF1_SCL_1 $bool = yes // SCL high and SDA high timeout occurs

//--- Enumerated values for register SMB, field SLTF
  let I2C2_SMB_SLTF_No_0 $bool = no // No low timeout occurs
  let I2C2_SMB_SLTF_Low_1 $bool = yes // Low timeout occurs

//--- Enumerated values for register SMB, field TCKSEL
  let I2C2_SMB_TCKSEL_Timeout_0 $bool = no // Timeout counter counts at the frequency of the I2C module clock / 64
  let I2C2_SMB_TCKSEL_Timeout_1 $bool = yes // Timeout counter counts at the frequency of the I2C module clock

//--- Enumerated values for register SMB, field SIICAEN
  let I2C2_SMB_SIICAEN_I2C_0 $bool = no // I2C address register 2 matching is disabled
  let I2C2_SMB_SIICAEN_I2C_1 $bool = yes // I2C address register 2 matching is enabled

//--- Enumerated values for register SMB, field ALERTEN
  let I2C2_SMB_ALERTEN_SMBus_0 $bool = no // SMBus alert response address matching is disabled
  let I2C2_SMB_ALERTEN_SMBus_1 $bool = yes // SMBus alert response address matching is enabled

//--- Enumerated values for register SMB, field FACK
  let I2C2_SMB_FACK_An_0 $bool = no // An ACK or NACK is sent on the following receiving data byte
  let I2C2_SMB_FACK_Writing_1 $bool = yes // Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.

//--- Enumerated values for register F, field MULT
  let I2C3_F_MULT_mul_00 $u2 = 0 // mul = 1
  let I2C3_F_MULT_mul_01 $u2 = 1 // mul = 2
  let I2C3_F_MULT_mul_10 $u2 = 2 // mul = 4

//--- Enumerated values for register C1, field DMAEN
  let I2C3_C1_DMAEN_All_0 $bool = no // All DMA signalling disabled.
  let I2C3_C1_DMAEN_DMA_1 $bool = yes // DMA transfer is enabled. While SMB[FACK] = 0, the following conditions trigger the DMA request: a data byte is received, and either address or data is transmitted. (ACK/NACK is automatic) the first byte received matches the A1 register or is a general call address. If any address matching occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known from master to slave, then it is not required to check S[SRW]. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.

//--- Enumerated values for register C1, field WUEN
  let I2C3_C1_WUEN_Normal_0 $bool = no // Normal operation. No interrupt generated when address matching in low power mode.
  let I2C3_C1_WUEN_Enables_1 $bool = yes // Enables the wakeup function in low power mode.

//--- Enumerated values for register C1, field TXAK
  let I2C3_C1_TXAK_An_0 $bool = no // An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
  let I2C3_C1_TXAK_No_1 $bool = yes // No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).

//--- Enumerated values for register C1, field TX
  let I2C3_C1_TX_Receive_0 $bool = no // Receive
  let I2C3_C1_TX_Transmit_1 $bool = yes // Transmit

//--- Enumerated values for register C1, field MST
  let I2C3_C1_MST_Slave_0 $bool = no // Slave mode
  let I2C3_C1_MST_Master_1 $bool = yes // Master mode

//--- Enumerated values for register C1, field IICIE
  let I2C3_C1_IICIE_Disabled_0 $bool = no // Disabled
  let I2C3_C1_IICIE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register C1, field IICEN
  let I2C3_C1_IICEN_Disabled_0 $bool = no // Disabled
  let I2C3_C1_IICEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register S, field RXAK
  let I2C3_S_RXAK_Acknowledge_0 $bool = no // Acknowledge signal was received after the completion of one byte of data transmission on the bus
  let I2C3_S_RXAK_No_1 $bool = yes // No acknowledge signal detected

//--- Enumerated values for register S, field IICIF
  let I2C3_S_IICIF_No_0 $bool = no // No interrupt pending
  let I2C3_S_IICIF_Interrupt_1 $bool = yes // Interrupt pending

//--- Enumerated values for register S, field SRW
  let I2C3_S_SRW_Slave_0 $bool = no // Slave receive, master writing to slave
  let I2C3_S_SRW_Slave_1 $bool = yes // Slave transmit, master reading from slave

//--- Enumerated values for register S, field RAM
  let I2C3_S_RAM_Not_0 $bool = no // Not addressed
  let I2C3_S_RAM_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field ARBL
  let I2C3_S_ARBL_Standard_0 $bool = no // Standard bus operation.
  let I2C3_S_ARBL_Loss_1 $bool = yes // Loss of arbitration.

//--- Enumerated values for register S, field BUSY
  let I2C3_S_BUSY_Bus_0 $bool = no // Bus is idle
  let I2C3_S_BUSY_Bus_1 $bool = yes // Bus is busy

//--- Enumerated values for register S, field IAAS
  let I2C3_S_IAAS_Not_0 $bool = no // Not addressed
  let I2C3_S_IAAS_Addressed_1 $bool = yes // Addressed as a slave

//--- Enumerated values for register S, field TCF
  let I2C3_S_TCF_Transfer_0 $bool = no // Transfer in progress
  let I2C3_S_TCF_Transfer_1 $bool = yes // Transfer complete

//--- Enumerated values for register C2, field RMEN
  let I2C3_C2_RMEN_Range_0 $bool = no // Range mode disabled. No address matching occurs for an address within the range of values of the A1 and RA registers.
  let I2C3_C2_RMEN_Range_1 $bool = yes // Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.

//--- Enumerated values for register C2, field SBRC
  let I2C3_C2_SBRC_The_0 $bool = no // The slave baud rate follows the master baud rate and clock stretching may occur
  let I2C3_C2_SBRC_Slave_1 $bool = yes // Slave baud rate is independent of the master baud rate

//--- Enumerated values for register C2, field HDRS
  let I2C3_C2_HDRS_Normal_0 $bool = no // Normal drive mode
  let I2C3_C2_HDRS_High_1 $bool = yes // High drive mode

//--- Enumerated values for register C2, field ADEXT
  let I2C3_C2_ADEXT_7_bit_0 $bool = no // 7-bit address scheme
  let I2C3_C2_ADEXT_10_bit_1 $bool = yes // 10-bit address scheme

//--- Enumerated values for register C2, field GCAEN
  let I2C3_C2_GCAEN_Disabled_0 $bool = no // Disabled
  let I2C3_C2_GCAEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register FLT, field FLT
  let I2C3_FLT_FLT_No_0 $u4 = 0 // No filter/bypass

//--- Enumerated values for register FLT, field STARTF
  let I2C3_FLT_STARTF_No_0 $bool = no // No start happens on I2C bus
  let I2C3_FLT_STARTF_Start_1 $bool = yes // Start detected on I2C bus

//--- Enumerated values for register FLT, field SSIE
  let I2C3_FLT_SSIE_Stop_0 $bool = no // Stop or start detection interrupt is disabled
  let I2C3_FLT_SSIE_Stop_1 $bool = yes // Stop or start detection interrupt is enabled

//--- Enumerated values for register FLT, field STOPF
  let I2C3_FLT_STOPF_No_0 $bool = no // No stop happens on I2C bus
  let I2C3_FLT_STOPF_Stop_1 $bool = yes // Stop detected on I2C bus

//--- Enumerated values for register FLT, field SHEN
  let I2C3_FLT_SHEN_Stop_0 $bool = no // Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
  let I2C3_FLT_SHEN_Stop_1 $bool = yes // Stop holdoff is enabled.

//--- Enumerated values for register SMB, field SHTF2IE
  let I2C3_SMB_SHTF2IE_SHTF2_0 $bool = no // SHTF2 interrupt is disabled
  let I2C3_SMB_SHTF2IE_SHTF2_1 $bool = yes // SHTF2 interrupt is enabled

//--- Enumerated values for register SMB, field SHTF2
  let I2C3_SMB_SHTF2_No_0 $bool = no // No SCL high and SDA low timeout occurs
  let I2C3_SMB_SHTF2_SCL_1 $bool = yes // SCL high and SDA low timeout occurs

//--- Enumerated values for register SMB, field SHTF1
  let I2C3_SMB_SHTF1_No_0 $bool = no // No SCL high and SDA high timeout occurs
  let I2C3_SMB_SHTF1_SCL_1 $bool = yes // SCL high and SDA high timeout occurs

//--- Enumerated values for register SMB, field SLTF
  let I2C3_SMB_SLTF_No_0 $bool = no // No low timeout occurs
  let I2C3_SMB_SLTF_Low_1 $bool = yes // Low timeout occurs

//--- Enumerated values for register SMB, field TCKSEL
  let I2C3_SMB_TCKSEL_Timeout_0 $bool = no // Timeout counter counts at the frequency of the I2C module clock / 64
  let I2C3_SMB_TCKSEL_Timeout_1 $bool = yes // Timeout counter counts at the frequency of the I2C module clock

//--- Enumerated values for register SMB, field SIICAEN
  let I2C3_SMB_SIICAEN_I2C_0 $bool = no // I2C address register 2 matching is disabled
  let I2C3_SMB_SIICAEN_I2C_1 $bool = yes // I2C address register 2 matching is enabled

//--- Enumerated values for register SMB, field ALERTEN
  let I2C3_SMB_ALERTEN_SMBus_0 $bool = no // SMBus alert response address matching is disabled
  let I2C3_SMB_ALERTEN_SMBus_1 $bool = yes // SMBus alert response address matching is enabled

//--- Enumerated values for register SMB, field FACK
  let I2C3_SMB_FACK_An_0 $bool = no // An ACK or NACK is sent on the following receiving data byte
  let I2C3_SMB_FACK_Writing_1 $bool = yes // Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.

//------------------------------------------------------------------------------
// Peripheral I2S0: Inter-IC Sound / Synchronous Audio Interface
//------------------------------------------------------------------------------

registers ©I2S0 @at 0x4002f000 {
//---  Register TCSR: SAI Transmit Control Register
  TCSR @offset 0x0 $u32 {
    TE // at 31: Transmitter Enable
    STOPE // at 30: Stop Enable
    DBGE // at 29: Debug Enable
    BCE // at 28: Bit Clock Enable
    2
    FR // at 25: FIFO Reset
    SR // at 24: Software Reset
    3
    WSF // at 20: Word Start Flag
    SEF // at 19: Sync Error Flag
    FEF // at 18: FIFO Error Flag
    FWF // at 17: FIFO Warning Flag
    FRF // at 16: FIFO Request Flag
    3
    WSIE // at 12: Word Start Interrupt Enable
    SEIE // at 11: Sync Error Interrupt Enable
    FEIE // at 10: FIFO Error Interrupt Enable
    FWIE // at 9: FIFO Warning Interrupt Enable
    FRIE // at 8: FIFO Request Interrupt Enable
    6
    FWDE // at 1: FIFO Warning DMA Enable
    FRDE // at 0: FIFO Request DMA Enable
  }

//---  Register TCR1: SAI Transmit Configuration 1 Register
  TCR1 @offset 0x4 $u32 {
    29
    TFW:3 // at 0: Transmit FIFO Watermark
  }

//---  Register TCR2: SAI Transmit Configuration 2 Register
  TCR2 @offset 0x8 $u32 {
    SYNC:2 // at 30: Synchronous Mode
    BCS // at 29: Bit Clock Swap
    BCI // at 28: Bit Clock Input
    MSEL:2 // at 26: MCLK Select
    BCP // at 25: Bit Clock Polarity
    BCD // at 24: Bit Clock Direction
    16
    DIV:8 // at 0: Bit Clock Divide
  }

//---  Register TCR3: SAI Transmit Configuration 3 Register
  TCR3 @offset 0xc $u32 {
    6
    CFR:2 // at 24: Channel FIFO Reset
    6
    TCE:2 // at 16: Transmit Channel Enable
    11
    WDFL:5 // at 0: Word Flag Configuration
  }

//---  Register TCR4: SAI Transmit Configuration 4 Register
  TCR4 @offset 0x10 $u32 {
    3
    FCONT // at 28: FIFO Continue on Error
    FCOMB:2 // at 26: FIFO Combine Mode
    FPACK:2 // at 24: FIFO Packing Mode
    3
    FRSZ:5 // at 16: Frame size
    3
    SYWD:5 // at 8: Sync Width
    3
    MF // at 4: MSB First
    FSE // at 3: Frame Sync Early
    ONDEM // at 2: On Demand Mode
    FSP // at 1: Frame Sync Polarity
    FSD // at 0: Frame Sync Direction
  }

//---  Register TCR5: SAI Transmit Configuration 5 Register
  TCR5 @offset 0x14 $u32 {
    3
    WNW:5 // at 24: Word N Width
    3
    W0W:5 // at 16: Word 0 Width
    3
    FBT:5 // at 8: First Bit Shifted
    8
  }

//---  Registers TDR(0,1): SAI Transmit Data Register
  TDR [2 @offset 0x20 @inc 0x4]
  TDR0 @offset 0x20
  TDR1 @offset 0x24 $u32 {
    TDR:32 // at 0: Transmit Data Register
  }

//---  Registers TFR(0,1): SAI Transmit FIFO Register
  TFR [2 @offset 0x40 @inc 0x4]
  TFR0 @offset 0x40
  TFR1 @offset 0x44 @ro $u32 {
    WCP // at 31: Write Channel Pointer
    11
    WFP:4 // at 16: Write FIFO Pointer
    12
    RFP:4 // at 0: Read FIFO Pointer
  }

//---  Register TMR: SAI Transmit Mask Register
  TMR @offset 0x60 $u32 {
    TWM:32 // at 0: Transmit Word Mask
  }

//---  Register RCSR: SAI Receive Control Register
  RCSR @offset 0x80 $u32 {
    RE // at 31: Receiver Enable
    STOPE // at 30: Stop Enable
    DBGE // at 29: Debug Enable
    BCE // at 28: Bit Clock Enable
    2
    FR // at 25: FIFO Reset
    SR // at 24: Software Reset
    3
    WSF // at 20: Word Start Flag
    SEF // at 19: Sync Error Flag
    FEF // at 18: FIFO Error Flag
    FWF // at 17: FIFO Warning Flag
    FRF // at 16: FIFO Request Flag
    3
    WSIE // at 12: Word Start Interrupt Enable
    SEIE // at 11: Sync Error Interrupt Enable
    FEIE // at 10: FIFO Error Interrupt Enable
    FWIE // at 9: FIFO Warning Interrupt Enable
    FRIE // at 8: FIFO Request Interrupt Enable
    6
    FWDE // at 1: FIFO Warning DMA Enable
    FRDE // at 0: FIFO Request DMA Enable
  }

//---  Register RCR1: SAI Receive Configuration 1 Register
  RCR1 @offset 0x84 $u32 {
    29
    RFW:3 // at 0: Receive FIFO Watermark
  }

//---  Register RCR2: SAI Receive Configuration 2 Register
  RCR2 @offset 0x88 $u32 {
    SYNC:2 // at 30: Synchronous Mode
    BCS // at 29: Bit Clock Swap
    BCI // at 28: Bit Clock Input
    MSEL:2 // at 26: MCLK Select
    BCP // at 25: Bit Clock Polarity
    BCD // at 24: Bit Clock Direction
    16
    DIV:8 // at 0: Bit Clock Divide
  }

//---  Register RCR3: SAI Receive Configuration 3 Register
  RCR3 @offset 0x8c $u32 {
    6
    CFR:2 // at 24: Channel FIFO Reset
    6
    RCE:2 // at 16: Receive Channel Enable
    11
    WDFL:5 // at 0: Word Flag Configuration
  }

//---  Register RCR4: SAI Receive Configuration 4 Register
  RCR4 @offset 0x90 $u32 {
    3
    FCONT // at 28: FIFO Continue on Error
    FCOMB:2 // at 26: FIFO Combine Mode
    FPACK:2 // at 24: FIFO Packing Mode
    3
    FRSZ:5 // at 16: Frame Size
    3
    SYWD:5 // at 8: Sync Width
    3
    MF // at 4: MSB First
    FSE // at 3: Frame Sync Early
    ONDEM // at 2: On Demand Mode
    FSP // at 1: Frame Sync Polarity
    FSD // at 0: Frame Sync Direction
  }

//---  Register RCR5: SAI Receive Configuration 5 Register
  RCR5 @offset 0x94 $u32 {
    3
    WNW:5 // at 24: Word N Width
    3
    W0W:5 // at 16: Word 0 Width
    3
    FBT:5 // at 8: First Bit Shifted
    8
  }

//---  Registers RDR(0,1): SAI Receive Data Register
  RDR [2 @offset 0xa0 @inc 0x4]
  RDR0 @offset 0xa0
  RDR1 @offset 0xa4 @ro $u32 {
    RDR:32 // at 0: Receive Data Register
  }

//---  Registers RFR(0,1): SAI Receive FIFO Register
  RFR [2 @offset 0xc0 @inc 0x4]
  RFR0 @offset 0xc0
  RFR1 @offset 0xc4 @ro $u32 {
    12
    WFP:4 // at 16: Write FIFO Pointer
    RCP // at 15: Receive Channel Pointer
    11
    RFP:4 // at 0: Read FIFO Pointer
  }

//---  Register RMR: SAI Receive Mask Register
  RMR @offset 0xe0 $u32 {
    RWM:32 // at 0: Receive Word Mask
  }

//---  Register MCR: SAI MCLK Control Register
  MCR @offset 0x100 $u32 {
    DUF // at 31: Divider Update Flag
    MOE // at 30: MCLK Output Enable
    4
    MICS:2 // at 24: MCLK Input Clock Select
    24
  }

//---  Register MDR: SAI MCLK Divide Register
  MDR @offset 0x104 $u32 {
    12
    FRACT:8 // at 12: MCLK Fraction
    DIVIDE:12 // at 0: MCLK Divide
  }

}

//--- Enumerated values for register TCSR, field FRDE
  let I2S0_TCSR_FRDE_Disables_0 $bool = no // Disables the DMA request.
  let I2S0_TCSR_FRDE_Enables_1 $bool = yes // Enables the DMA request.

//--- Enumerated values for register TCSR, field FWDE
  let I2S0_TCSR_FWDE_Disables_0 $bool = no // Disables the DMA request.
  let I2S0_TCSR_FWDE_Enables_1 $bool = yes // Enables the DMA request.

//--- Enumerated values for register TCSR, field FRIE
  let I2S0_TCSR_FRIE_Disables_0 $bool = no // Disables the interrupt.
  let I2S0_TCSR_FRIE_Enables_1 $bool = yes // Enables the interrupt.

//--- Enumerated values for register TCSR, field FWIE
  let I2S0_TCSR_FWIE_Disables_0 $bool = no // Disables the interrupt.
  let I2S0_TCSR_FWIE_Enables_1 $bool = yes // Enables the interrupt.

//--- Enumerated values for register TCSR, field FEIE
  let I2S0_TCSR_FEIE_Disables_0 $bool = no // Disables the interrupt.
  let I2S0_TCSR_FEIE_Enables_1 $bool = yes // Enables the interrupt.

//--- Enumerated values for register TCSR, field SEIE
  let I2S0_TCSR_SEIE_Disables_0 $bool = no // Disables interrupt.
  let I2S0_TCSR_SEIE_Enables_1 $bool = yes // Enables interrupt.

//--- Enumerated values for register TCSR, field WSIE
  let I2S0_TCSR_WSIE_Disables_0 $bool = no // Disables interrupt.
  let I2S0_TCSR_WSIE_Enables_1 $bool = yes // Enables interrupt.

//--- Enumerated values for register TCSR, field FRF
  let I2S0_TCSR_FRF_Transmit_0 $bool = no // Transmit FIFO watermark has not been reached.
  let I2S0_TCSR_FRF_Transmit_1 $bool = yes // Transmit FIFO watermark has been reached.

//--- Enumerated values for register TCSR, field FWF
  let I2S0_TCSR_FWF_No_0 $bool = no // No enabled transmit FIFO is empty.
  let I2S0_TCSR_FWF_Enabled_1 $bool = yes // Enabled transmit FIFO is empty.

//--- Enumerated values for register TCSR, field FEF
  let I2S0_TCSR_FEF_Transmit_0 $bool = no // Transmit underrun not detected.
  let I2S0_TCSR_FEF_Transmit_1 $bool = yes // Transmit underrun detected.

//--- Enumerated values for register TCSR, field SEF
  let I2S0_TCSR_SEF_Sync_0 $bool = no // Sync error not detected.
  let I2S0_TCSR_SEF_Frame_1 $bool = yes // Frame sync error detected.

//--- Enumerated values for register TCSR, field WSF
  let I2S0_TCSR_WSF_Start_0 $bool = no // Start of word not detected.
  let I2S0_TCSR_WSF_Start_1 $bool = yes // Start of word detected.

//--- Enumerated values for register TCSR, field SR
  let I2S0_TCSR_SR_No_0 $bool = no // No effect.
  let I2S0_TCSR_SR_Software_1 $bool = yes // Software reset.

//--- Enumerated values for register TCSR, field FR
  let I2S0_TCSR_FR_No_0 $bool = no // No effect.
  let I2S0_TCSR_FR_FIFO_1 $bool = yes // FIFO reset.

//--- Enumerated values for register TCSR, field BCE
  let I2S0_TCSR_BCE_Transmit_0 $bool = no // Transmit bit clock is disabled.
  let I2S0_TCSR_BCE_Transmit_1 $bool = yes // Transmit bit clock is enabled.

//--- Enumerated values for register TCSR, field DBGE
  let I2S0_TCSR_DBGE_Transmitter_0 $bool = no // Transmitter is disabled in Debug mode, after completing the current frame.
  let I2S0_TCSR_DBGE_Transmitter_1 $bool = yes // Transmitter is enabled in Debug mode.

//--- Enumerated values for register TCSR, field STOPE
  let I2S0_TCSR_STOPE_Transmitter_0 $bool = no // Transmitter disabled in Stop mode.
  let I2S0_TCSR_STOPE_Transmitter_1 $bool = yes // Transmitter enabled in Stop mode.

//--- Enumerated values for register TCSR, field TE
  let I2S0_TCSR_TE_Transmitter_0 $bool = no // Transmitter is disabled.
  let I2S0_TCSR_TE_Transmitter_1 $bool = yes // Transmitter is enabled, or transmitter has been disabled and has not yet reached end of frame.

//--- Enumerated values for register TCR2, field BCD
  let I2S0_TCR2_BCD_Bit_0 $bool = no // Bit clock is generated externally in Slave mode.
  let I2S0_TCR2_BCD_Bit_1 $bool = yes // Bit clock is generated internally in Master mode.

//--- Enumerated values for register TCR2, field BCP
  let I2S0_TCR2_BCP_Bit_0 $bool = no // Bit clock is active high with drive outputs on rising edge and sample inputs on falling edge.
  let I2S0_TCR2_BCP_Bit_1 $bool = yes // Bit clock is active low with drive outputs on falling edge and sample inputs on rising edge.

//--- Enumerated values for register TCR2, field MSEL
  let I2S0_TCR2_MSEL_Bus_00 $u2 = 0 // Bus Clock selected.
  let I2S0_TCR2_MSEL_Master_01 $u2 = 1 // Master Clock (MCLK) 1 option selected.
  let I2S0_TCR2_MSEL_Master_10 $u2 = 2 // Master Clock (MCLK) 2 option selected.
  let I2S0_TCR2_MSEL_Master_11 $u2 = 3 // Master Clock (MCLK) 3 option selected.

//--- Enumerated values for register TCR2, field BCI
  let I2S0_TCR2_BCI_No_0 $bool = no // No effect.
  let I2S0_TCR2_BCI_Internal_1 $bool = yes // Internal logic is clocked as if bit clock was externally generated.

//--- Enumerated values for register TCR2, field BCS
  let I2S0_TCR2_BCS_Use_0 $bool = no // Use the normal bit clock source.
  let I2S0_TCR2_BCS_Swap_1 $bool = yes // Swap the bit clock source.

//--- Enumerated values for register TCR2, field SYNC
  let I2S0_TCR2_SYNC_Asynchronous_00 $u2 = 0 // Asynchronous mode.
  let I2S0_TCR2_SYNC_Synchronous_01 $u2 = 1 // Synchronous with receiver.
  let I2S0_TCR2_SYNC_Synchronous_10 $u2 = 2 // Synchronous with another SAI transmitter.
  let I2S0_TCR2_SYNC_Synchronous_11 $u2 = 3 // Synchronous with another SAI receiver.

//--- Enumerated values for register TCR3, field TCE
  let I2S0_TCR3_TCE_Transmit_0 $u2 = 0 // Transmit data channel N is disabled.
  let I2S0_TCR3_TCE_Transmit_1 $u2 = 1 // Transmit data channel N is enabled.

//--- Enumerated values for register TCR3, field CFR
  let I2S0_TCR3_CFR_No_0 $u2 = 0 // No effect.
  let I2S0_TCR3_CFR_Transmit_1 $u2 = 1 // Transmit data channel N FIFO is reset.

//--- Enumerated values for register TCR4, field FSD
  let I2S0_TCR4_FSD_Frame_0 $bool = no // Frame sync is generated externally in Slave mode.
  let I2S0_TCR4_FSD_Frame_1 $bool = yes // Frame sync is generated internally in Master mode.

//--- Enumerated values for register TCR4, field FSP
  let I2S0_TCR4_FSP_Frame_0 $bool = no // Frame sync is active high.
  let I2S0_TCR4_FSP_Frame_1 $bool = yes // Frame sync is active low.

//--- Enumerated values for register TCR4, field ONDEM
  let I2S0_TCR4_ONDEM_Internal_0 $bool = no // Internal frame sync is generated continuously.
  let I2S0_TCR4_ONDEM_Internal_1 $bool = yes // Internal frame sync is generated when the FIFO warning flag is clear.

//--- Enumerated values for register TCR4, field FSE
  let I2S0_TCR4_FSE_Frame_0 $bool = no // Frame sync asserts with the first bit of the frame.
  let I2S0_TCR4_FSE_Frame_1 $bool = yes // Frame sync asserts one bit before the first bit of the frame.

//--- Enumerated values for register TCR4, field MF
  let I2S0_TCR4_MF_LSB_0 $bool = no // LSB is transmitted first.
  let I2S0_TCR4_MF_MSB_1 $bool = yes // MSB is transmitted first.

//--- Enumerated values for register TCR4, field FPACK
  let I2S0_TCR4_FPACK_FIFO_00 $u2 = 0 // FIFO packing is disabled
  let I2S0_TCR4_FPACK_8_bit_10 $u2 = 2 // 8-bit FIFO packing is enabled
  let I2S0_TCR4_FPACK_16_bit_11 $u2 = 3 // 16-bit FIFO packing is enabled

//--- Enumerated values for register TCR4, field FCOMB
  let I2S0_TCR4_FCOMB_FIFO_00 $u2 = 0 // FIFO combine mode disabled.
  let I2S0_TCR4_FCOMB_FIFO_01 $u2 = 1 // FIFO combine mode enabled on FIFO reads (from transmit shift registers).
  let I2S0_TCR4_FCOMB_FIFO_10 $u2 = 2 // FIFO combine mode enabled on FIFO writes (by software).
  let I2S0_TCR4_FCOMB_FIFO_11 $u2 = 3 // FIFO combine mode enabled on FIFO reads (from transmit shift registers) and writes (by software).

//--- Enumerated values for register TCR4, field FCONT
  let I2S0_TCR4_FCONT_On_0 $bool = no // On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
  let I2S0_TCR4_FCONT_On_1 $bool = yes // On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.

//--- Enumerated values for register TFR%s, field WCP
  let I2S0_TFR_WCP_No_0 $bool = no // No effect.
  let I2S0_TFR_WCP_FIFO_1 $bool = yes // FIFO combine is enabled for FIFO writes and this FIFO will be written on the next FIFO write.

//--- Enumerated values for register TMR, field TWM
  let I2S0_TMR_TWM_Word_0 $u32 = 0 // Word N is enabled.
  let I2S0_TMR_TWM_Word_1 $u32 = 1 // Word N is masked. The transmit data pins are tri-stated when masked.

//--- Enumerated values for register RCSR, field FRDE
  let I2S0_RCSR_FRDE_Disables_0 $bool = no // Disables the DMA request.
  let I2S0_RCSR_FRDE_Enables_1 $bool = yes // Enables the DMA request.

//--- Enumerated values for register RCSR, field FWDE
  let I2S0_RCSR_FWDE_Disables_0 $bool = no // Disables the DMA request.
  let I2S0_RCSR_FWDE_Enables_1 $bool = yes // Enables the DMA request.

//--- Enumerated values for register RCSR, field FRIE
  let I2S0_RCSR_FRIE_Disables_0 $bool = no // Disables the interrupt.
  let I2S0_RCSR_FRIE_Enables_1 $bool = yes // Enables the interrupt.

//--- Enumerated values for register RCSR, field FWIE
  let I2S0_RCSR_FWIE_Disables_0 $bool = no // Disables the interrupt.
  let I2S0_RCSR_FWIE_Enables_1 $bool = yes // Enables the interrupt.

//--- Enumerated values for register RCSR, field FEIE
  let I2S0_RCSR_FEIE_Disables_0 $bool = no // Disables the interrupt.
  let I2S0_RCSR_FEIE_Enables_1 $bool = yes // Enables the interrupt.

//--- Enumerated values for register RCSR, field SEIE
  let I2S0_RCSR_SEIE_Disables_0 $bool = no // Disables interrupt.
  let I2S0_RCSR_SEIE_Enables_1 $bool = yes // Enables interrupt.

//--- Enumerated values for register RCSR, field WSIE
  let I2S0_RCSR_WSIE_Disables_0 $bool = no // Disables interrupt.
  let I2S0_RCSR_WSIE_Enables_1 $bool = yes // Enables interrupt.

//--- Enumerated values for register RCSR, field FRF
  let I2S0_RCSR_FRF_Receive_0 $bool = no // Receive FIFO watermark not reached.
  let I2S0_RCSR_FRF_Receive_1 $bool = yes // Receive FIFO watermark has been reached.

//--- Enumerated values for register RCSR, field FWF
  let I2S0_RCSR_FWF_No_0 $bool = no // No enabled receive FIFO is full.
  let I2S0_RCSR_FWF_Enabled_1 $bool = yes // Enabled receive FIFO is full.

//--- Enumerated values for register RCSR, field FEF
  let I2S0_RCSR_FEF_Receive_0 $bool = no // Receive overflow not detected.
  let I2S0_RCSR_FEF_Receive_1 $bool = yes // Receive overflow detected.

//--- Enumerated values for register RCSR, field SEF
  let I2S0_RCSR_SEF_Sync_0 $bool = no // Sync error not detected.
  let I2S0_RCSR_SEF_Frame_1 $bool = yes // Frame sync error detected.

//--- Enumerated values for register RCSR, field WSF
  let I2S0_RCSR_WSF_Start_0 $bool = no // Start of word not detected.
  let I2S0_RCSR_WSF_Start_1 $bool = yes // Start of word detected.

//--- Enumerated values for register RCSR, field SR
  let I2S0_RCSR_SR_No_0 $bool = no // No effect.
  let I2S0_RCSR_SR_Software_1 $bool = yes // Software reset.

//--- Enumerated values for register RCSR, field FR
  let I2S0_RCSR_FR_No_0 $bool = no // No effect.
  let I2S0_RCSR_FR_FIFO_1 $bool = yes // FIFO reset.

//--- Enumerated values for register RCSR, field BCE
  let I2S0_RCSR_BCE_Receive_0 $bool = no // Receive bit clock is disabled.
  let I2S0_RCSR_BCE_Receive_1 $bool = yes // Receive bit clock is enabled.

//--- Enumerated values for register RCSR, field DBGE
  let I2S0_RCSR_DBGE_Receiver_0 $bool = no // Receiver is disabled in Debug mode, after completing the current frame.
  let I2S0_RCSR_DBGE_Receiver_1 $bool = yes // Receiver is enabled in Debug mode.

//--- Enumerated values for register RCSR, field STOPE
  let I2S0_RCSR_STOPE_Receiver_0 $bool = no // Receiver disabled in Stop mode.
  let I2S0_RCSR_STOPE_Receiver_1 $bool = yes // Receiver enabled in Stop mode.

//--- Enumerated values for register RCSR, field RE
  let I2S0_RCSR_RE_Receiver_0 $bool = no // Receiver is disabled.
  let I2S0_RCSR_RE_Receiver_1 $bool = yes // Receiver is enabled, or receiver has been disabled and has not yet reached end of frame.

//--- Enumerated values for register RCR2, field BCD
  let I2S0_RCR2_BCD_Bit_0 $bool = no // Bit clock is generated externally in Slave mode.
  let I2S0_RCR2_BCD_Bit_1 $bool = yes // Bit clock is generated internally in Master mode.

//--- Enumerated values for register RCR2, field BCP
  let I2S0_RCR2_BCP_Bit_0 $bool = no // Bit Clock is active high with drive outputs on rising edge and sample inputs on falling edge.
  let I2S0_RCR2_BCP_Bit_1 $bool = yes // Bit Clock is active low with drive outputs on falling edge and sample inputs on rising edge.

//--- Enumerated values for register RCR2, field MSEL
  let I2S0_RCR2_MSEL_Bus_00 $u2 = 0 // Bus Clock selected.
  let I2S0_RCR2_MSEL_Master_01 $u2 = 1 // Master Clock (MCLK) 1 option selected.
  let I2S0_RCR2_MSEL_Master_10 $u2 = 2 // Master Clock (MCLK) 2 option selected.
  let I2S0_RCR2_MSEL_Master_11 $u2 = 3 // Master Clock (MCLK) 3 option selected.

//--- Enumerated values for register RCR2, field BCI
  let I2S0_RCR2_BCI_No_0 $bool = no // No effect.
  let I2S0_RCR2_BCI_Internal_1 $bool = yes // Internal logic is clocked as if bit clock was externally generated.

//--- Enumerated values for register RCR2, field BCS
  let I2S0_RCR2_BCS_Use_0 $bool = no // Use the normal bit clock source.
  let I2S0_RCR2_BCS_Swap_1 $bool = yes // Swap the bit clock source.

//--- Enumerated values for register RCR2, field SYNC
  let I2S0_RCR2_SYNC_Asynchronous_00 $u2 = 0 // Asynchronous mode.
  let I2S0_RCR2_SYNC_Synchronous_01 $u2 = 1 // Synchronous with transmitter.
  let I2S0_RCR2_SYNC_Synchronous_10 $u2 = 2 // Synchronous with another SAI receiver.
  let I2S0_RCR2_SYNC_Synchronous_11 $u2 = 3 // Synchronous with another SAI transmitter.

//--- Enumerated values for register RCR3, field RCE
  let I2S0_RCR3_RCE_Receive_0 $u2 = 0 // Receive data channel N is disabled.
  let I2S0_RCR3_RCE_Receive_1 $u2 = 1 // Receive data channel N is enabled.

//--- Enumerated values for register RCR3, field CFR
  let I2S0_RCR3_CFR_No_0 $u2 = 0 // No effect.
  let I2S0_RCR3_CFR_Receive_1 $u2 = 1 // Receive data channel N FIFO is reset.

//--- Enumerated values for register RCR4, field FSD
  let I2S0_RCR4_FSD_Frame_0 $bool = no // Frame Sync is generated externally in Slave mode.
  let I2S0_RCR4_FSD_Frame_1 $bool = yes // Frame Sync is generated internally in Master mode.

//--- Enumerated values for register RCR4, field FSP
  let I2S0_RCR4_FSP_Frame_0 $bool = no // Frame sync is active high.
  let I2S0_RCR4_FSP_Frame_1 $bool = yes // Frame sync is active low.

//--- Enumerated values for register RCR4, field ONDEM
  let I2S0_RCR4_ONDEM_Internal_0 $bool = no // Internal frame sync is generated continuously.
  let I2S0_RCR4_ONDEM_Internal_1 $bool = yes // Internal frame sync is generated when the FIFO warning flag is clear.

//--- Enumerated values for register RCR4, field FSE
  let I2S0_RCR4_FSE_Frame_0 $bool = no // Frame sync asserts with the first bit of the frame.
  let I2S0_RCR4_FSE_Frame_1 $bool = yes // Frame sync asserts one bit before the first bit of the frame.

//--- Enumerated values for register RCR4, field MF
  let I2S0_RCR4_MF_LSB_0 $bool = no // LSB is received first.
  let I2S0_RCR4_MF_MSB_1 $bool = yes // MSB is received first.

//--- Enumerated values for register RCR4, field FPACK
  let I2S0_RCR4_FPACK_FIFO_00 $u2 = 0 // FIFO packing is disabled
  let I2S0_RCR4_FPACK_8_bit_10 $u2 = 2 // 8-bit FIFO packing is enabled
  let I2S0_RCR4_FPACK_16_bit_11 $u2 = 3 // 16-bit FIFO packing is enabled

//--- Enumerated values for register RCR4, field FCOMB
  let I2S0_RCR4_FCOMB_FIFO_00 $u2 = 0 // FIFO combine mode disabled.
  let I2S0_RCR4_FCOMB_FIFO_01 $u2 = 1 // FIFO combine mode enabled on FIFO writes (from receive shift registers).
  let I2S0_RCR4_FCOMB_FIFO_10 $u2 = 2 // FIFO combine mode enabled on FIFO reads (by software).
  let I2S0_RCR4_FCOMB_FIFO_11 $u2 = 3 // FIFO combine mode enabled on FIFO writes (from receive shift registers) and reads (by software).

//--- Enumerated values for register RCR4, field FCONT
  let I2S0_RCR4_FCONT_On_0 $bool = no // On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
  let I2S0_RCR4_FCONT_On_1 $bool = yes // On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.

//--- Enumerated values for register RFR%s, field RCP
  let I2S0_RFR_RCP_No_0 $bool = no // No effect.
  let I2S0_RFR_RCP_FIFO_1 $bool = yes // FIFO combine is enabled for FIFO reads and this FIFO will be read on the next FIFO read.

//--- Enumerated values for register RMR, field RWM
  let I2S0_RMR_RWM_Word_0 $u32 = 0 // Word N is enabled.
  let I2S0_RMR_RWM_Word_1 $u32 = 1 // Word N is masked.

//--- Enumerated values for register MCR, field MICS
  let I2S0_MCR_MICS_MCLK_00 $u2 = 0 // MCLK divider input clock 0 is selected.
  let I2S0_MCR_MICS_MCLK_01 $u2 = 1 // MCLK divider input clock 1 is selected.
  let I2S0_MCR_MICS_MCLK_10 $u2 = 2 // MCLK divider input clock 2 is selected.
  let I2S0_MCR_MICS_MCLK_11 $u2 = 3 // MCLK divider input clock 3 is selected.

//--- Enumerated values for register MCR, field MOE
  let I2S0_MCR_MOE_MCLK_0 $bool = no // MCLK signal pin is configured as an input that bypasses the MCLK divider.
  let I2S0_MCR_MOE_MCLK_1 $bool = yes // MCLK signal pin is configured as an output from the MCLK divider and the MCLK divider is enabled.

//--- Enumerated values for register MCR, field DUF
  let I2S0_MCR_DUF_MCLK_0 $bool = no // MCLK divider ratio is not being updated currently.
  let I2S0_MCR_DUF_MCLK_1 $bool = yes // MCLK divider ratio is updating on-the-fly. Further updates to the MCLK divider ratio are blocked while this flag remains set.

//------------------------------------------------------------------------------
// Peripheral LLWU: Low leakage wakeup unit
//------------------------------------------------------------------------------

registers ©LLWU @at 0x4007c000 {
//---  Register PE1: LLWU Pin Enable 1 register
  PE1 @offset 0x0 $u8 {
    WUPE3:2 // at 6: Wakeup Pin Enable For LLWU_P3
    WUPE2:2 // at 4: Wakeup Pin Enable For LLWU_P2
    WUPE1:2 // at 2: Wakeup Pin Enable For LLWU_P1
    WUPE0:2 // at 0: Wakeup Pin Enable For LLWU_P0
  }

//---  Register PE2: LLWU Pin Enable 2 register
  PE2 @offset 0x1 $u8 {
    WUPE7:2 // at 6: Wakeup Pin Enable For LLWU_P7
    WUPE6:2 // at 4: Wakeup Pin Enable For LLWU_P6
    WUPE5:2 // at 2: Wakeup Pin Enable For LLWU_P5
    WUPE4:2 // at 0: Wakeup Pin Enable For LLWU_P4
  }

//---  Register PE3: LLWU Pin Enable 3 register
  PE3 @offset 0x2 $u8 {
    WUPE11:2 // at 6: Wakeup Pin Enable For LLWU_P11
    WUPE10:2 // at 4: Wakeup Pin Enable For LLWU_P10
    WUPE9:2 // at 2: Wakeup Pin Enable For LLWU_P9
    WUPE8:2 // at 0: Wakeup Pin Enable For LLWU_P8
  }

//---  Register PE4: LLWU Pin Enable 4 register
  PE4 @offset 0x3 $u8 {
    WUPE15:2 // at 6: Wakeup Pin Enable For LLWU_P15
    WUPE14:2 // at 4: Wakeup Pin Enable For LLWU_P14
    WUPE13:2 // at 2: Wakeup Pin Enable For LLWU_P13
    WUPE12:2 // at 0: Wakeup Pin Enable For LLWU_P12
  }

//---  Register PE5: LLWU Pin Enable 5 register
  PE5 @offset 0x4 $u8 {
    WUPE19:2 // at 6: Wakeup Pin Enable For LLWU_P19
    WUPE18:2 // at 4: Wakeup Pin Enable For LLWU_P18
    WUPE17:2 // at 2: Wakeup Pin Enable For LLWU_P17
    WUPE16:2 // at 0: Wakeup Pin Enable For LLWU_P16
  }

//---  Register PE6: LLWU Pin Enable 6 register
  PE6 @offset 0x5 $u8 {
    WUPE23:2 // at 6: Wakeup Pin Enable For LLWU_P23
    WUPE22:2 // at 4: Wakeup Pin Enable For LLWU_P22
    WUPE21:2 // at 2: Wakeup Pin Enable For LLWU_P21
    WUPE20:2 // at 0: Wakeup Pin Enable For LLWU_P20
  }

//---  Register PE7: LLWU Pin Enable 7 register
  PE7 @offset 0x6 $u8 {
    WUPE27:2 // at 6: Wakeup Pin Enable For LLWU_P27
    WUPE26:2 // at 4: Wakeup Pin Enable For LLWU_P26
    WUPE25:2 // at 2: Wakeup Pin Enable For LLWU_P25
    WUPE24:2 // at 0: Wakeup Pin Enable For LLWU_P24
  }

//---  Register PE8: LLWU Pin Enable 8 register
  PE8 @offset 0x7 $u8 {
    WUPE31:2 // at 6: Wakeup Pin Enable For LLWU_P31
    WUPE30:2 // at 4: Wakeup Pin Enable For LLWU_P30
    WUPE29:2 // at 2: Wakeup Pin Enable For LLWU_P29
    WUPE28:2 // at 0: Wakeup Pin Enable For LLWU_P28
  }

//---  Register ME: LLWU Module Enable register
  ME @offset 0x8 $u8 {
    WUME7 // at 7: Wakeup Module Enable For Module 7
    WUME6 // at 6: Wakeup Module Enable For Module 6
    WUME5 // at 5: Wakeup Module Enable For Module 5
    WUME4 // at 4: Wakeup Module Enable For Module 4
    WUME3 // at 3: Wakeup Module Enable For Module 3
    WUME2 // at 2: Wakeup Module Enable For Module 2
    WUME1 // at 1: Wakeup Module Enable for Module 1
    WUME0 // at 0: Wakeup Module Enable For Module 0
  }

//---  Register PF1: LLWU Pin Flag 1 register
  PF1 @offset 0x9 $u8 {
    WUF7 // at 7: Wakeup Flag For LLWU_P7
    WUF6 // at 6: Wakeup Flag For LLWU_P6
    WUF5 // at 5: Wakeup Flag For LLWU_P5
    WUF4 // at 4: Wakeup Flag For LLWU_P4
    WUF3 // at 3: Wakeup Flag For LLWU_P3
    WUF2 // at 2: Wakeup Flag For LLWU_P2
    WUF1 // at 1: Wakeup Flag For LLWU_P1
    WUF0 // at 0: Wakeup Flag For LLWU_P0
  }

//---  Register PF2: LLWU Pin Flag 2 register
  PF2 @offset 0xa $u8 {
    WUF15 // at 7: Wakeup Flag For LLWU_P15
    WUF14 // at 6: Wakeup Flag For LLWU_P14
    WUF13 // at 5: Wakeup Flag For LLWU_P13
    WUF12 // at 4: Wakeup Flag For LLWU_P12
    WUF11 // at 3: Wakeup Flag For LLWU_P11
    WUF10 // at 2: Wakeup Flag For LLWU_P10
    WUF9 // at 1: Wakeup Flag For LLWU_P9
    WUF8 // at 0: Wakeup Flag For LLWU_P8
  }

//---  Register PF3: LLWU Pin Flag 3 register
  PF3 @offset 0xb $u8 {
    WUF23 // at 7: Wakeup Flag For LLWU_P23
    WUF22 // at 6: Wakeup Flag For LLWU_P22
    WUF21 // at 5: Wakeup Flag For LLWU_P21
    WUF20 // at 4: Wakeup Flag For LLWU_P20
    WUF19 // at 3: Wakeup Flag For LLWU_P19
    WUF18 // at 2: Wakeup Flag For LLWU_P18
    WUF17 // at 1: Wakeup Flag For LLWU_P17
    WUF16 // at 0: Wakeup Flag For LLWU_P16
  }

//---  Register PF4: LLWU Pin Flag 4 register
  PF4 @offset 0xc $u8 {
    WUF31 // at 7: Wakeup Flag For LLWU_P31
    WUF30 // at 6: Wakeup Flag For LLWU_P30
    WUF29 // at 5: Wakeup Flag For LLWU_P29
    WUF28 // at 4: Wakeup Flag For LLWU_P28
    WUF27 // at 3: Wakeup Flag For LLWU_P27
    WUF26 // at 2: Wakeup Flag For LLWU_P26
    WUF25 // at 1: Wakeup Flag For LLWU_P25
    WUF24 // at 0: Wakeup Flag For LLWU_P24
  }

//---  Register MF5: LLWU Module Flag 5 register
  MF5 @offset 0xd @ro $u8 {
    MWUF7 // at 7: Wakeup flag For module 7
    MWUF6 // at 6: Wakeup flag For module 6
    MWUF5 // at 5: Wakeup flag For module 5
    MWUF4 // at 4: Wakeup flag For module 4
    MWUF3 // at 3: Wakeup flag For module 3
    MWUF2 // at 2: Wakeup flag For module 2
    MWUF1 // at 1: Wakeup flag For module 1
    MWUF0 // at 0: Wakeup flag For module 0
  }

//---  Register FILT1: LLWU Pin Filter 1 register
  FILT1 @offset 0xe $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

//---  Register FILT2: LLWU Pin Filter 2 register
  FILT2 @offset 0xf $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

//---  Register FILT3: LLWU Pin Filter 3 register
  FILT3 @offset 0x10 $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

//---  Register FILT4: LLWU Pin Filter 4 register
  FILT4 @offset 0x11 $u8 {
    FILTF // at 7: Filter Detect Flag
    FILTE:2 // at 5: Digital Filter On External Pin
    FILTSEL:5 // at 0: Filter Pin Select
  }

}

//--- Enumerated values for register PE1, field WUPE0
  let LLWU_PE1_WUPE0_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE1_WUPE0_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE1_WUPE0_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE1_WUPE0_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE1, field WUPE1
  let LLWU_PE1_WUPE1_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE1_WUPE1_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE1_WUPE1_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE1_WUPE1_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE1, field WUPE2
  let LLWU_PE1_WUPE2_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE1_WUPE2_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE1_WUPE2_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE1_WUPE2_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE1, field WUPE3
  let LLWU_PE1_WUPE3_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE1_WUPE3_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE1_WUPE3_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE1_WUPE3_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE2, field WUPE4
  let LLWU_PE2_WUPE4_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE2_WUPE4_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE2_WUPE4_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE2_WUPE4_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE2, field WUPE5
  let LLWU_PE2_WUPE5_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE2_WUPE5_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE2_WUPE5_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE2_WUPE5_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE2, field WUPE6
  let LLWU_PE2_WUPE6_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE2_WUPE6_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE2_WUPE6_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE2_WUPE6_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE2, field WUPE7
  let LLWU_PE2_WUPE7_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE2_WUPE7_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE2_WUPE7_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE2_WUPE7_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE3, field WUPE8
  let LLWU_PE3_WUPE8_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE3_WUPE8_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE3_WUPE8_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE3_WUPE8_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE3, field WUPE9
  let LLWU_PE3_WUPE9_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE3_WUPE9_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE3_WUPE9_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE3_WUPE9_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE3, field WUPE10
  let LLWU_PE3_WUPE10_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE3_WUPE10_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE3_WUPE10_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE3_WUPE10_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE3, field WUPE11
  let LLWU_PE3_WUPE11_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE3_WUPE11_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE3_WUPE11_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE3_WUPE11_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE4, field WUPE12
  let LLWU_PE4_WUPE12_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE4_WUPE12_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE4_WUPE12_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE4_WUPE12_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE4, field WUPE13
  let LLWU_PE4_WUPE13_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE4_WUPE13_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE4_WUPE13_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE4_WUPE13_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE4, field WUPE14
  let LLWU_PE4_WUPE14_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE4_WUPE14_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE4_WUPE14_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE4_WUPE14_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE4, field WUPE15
  let LLWU_PE4_WUPE15_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE4_WUPE15_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE4_WUPE15_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE4_WUPE15_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE5, field WUPE16
  let LLWU_PE5_WUPE16_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE5_WUPE16_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE5_WUPE16_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE5_WUPE16_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE5, field WUPE17
  let LLWU_PE5_WUPE17_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE5_WUPE17_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE5_WUPE17_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE5_WUPE17_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE5, field WUPE18
  let LLWU_PE5_WUPE18_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE5_WUPE18_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE5_WUPE18_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE5_WUPE18_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE5, field WUPE19
  let LLWU_PE5_WUPE19_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE5_WUPE19_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE5_WUPE19_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE5_WUPE19_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE6, field WUPE20
  let LLWU_PE6_WUPE20_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE6_WUPE20_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE6_WUPE20_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE6_WUPE20_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE6, field WUPE21
  let LLWU_PE6_WUPE21_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE6_WUPE21_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE6_WUPE21_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE6_WUPE21_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE6, field WUPE22
  let LLWU_PE6_WUPE22_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE6_WUPE22_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE6_WUPE22_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE6_WUPE22_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE6, field WUPE23
  let LLWU_PE6_WUPE23_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE6_WUPE23_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE6_WUPE23_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE6_WUPE23_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE7, field WUPE24
  let LLWU_PE7_WUPE24_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE7_WUPE24_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE7_WUPE24_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE7_WUPE24_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE7, field WUPE25
  let LLWU_PE7_WUPE25_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE7_WUPE25_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE7_WUPE25_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE7_WUPE25_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE7, field WUPE26
  let LLWU_PE7_WUPE26_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE7_WUPE26_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE7_WUPE26_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE7_WUPE26_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE7, field WUPE27
  let LLWU_PE7_WUPE27_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE7_WUPE27_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE7_WUPE27_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE7_WUPE27_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE8, field WUPE28
  let LLWU_PE8_WUPE28_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE8_WUPE28_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE8_WUPE28_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE8_WUPE28_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE8, field WUPE29
  let LLWU_PE8_WUPE29_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE8_WUPE29_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE8_WUPE29_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE8_WUPE29_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE8, field WUPE30
  let LLWU_PE8_WUPE30_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE8_WUPE30_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE8_WUPE30_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE8_WUPE30_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register PE8, field WUPE31
  let LLWU_PE8_WUPE31_External_00 $u2 = 0 // External input pin disabled as wakeup input
  let LLWU_PE8_WUPE31_External_01 $u2 = 1 // External input pin enabled with rising edge detection
  let LLWU_PE8_WUPE31_External_10 $u2 = 2 // External input pin enabled with falling edge detection
  let LLWU_PE8_WUPE31_External_11 $u2 = 3 // External input pin enabled with any change detection

//--- Enumerated values for register ME, field WUME0
  let LLWU_ME_WUME0_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME0_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME1
  let LLWU_ME_WUME1_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME1_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME2
  let LLWU_ME_WUME2_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME2_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME3
  let LLWU_ME_WUME3_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME3_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME4
  let LLWU_ME_WUME4_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME4_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME5
  let LLWU_ME_WUME5_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME5_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME6
  let LLWU_ME_WUME6_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME6_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register ME, field WUME7
  let LLWU_ME_WUME7_Internal_0 $bool = no // Internal module flag not used as wakeup source
  let LLWU_ME_WUME7_Internal_1 $bool = yes // Internal module flag used as wakeup source

//--- Enumerated values for register PF1, field WUF0
  let LLWU_PF1_WUF0_LLWU_P0_0 $bool = no // LLWU_P0 input was not a wakeup source
  let LLWU_PF1_WUF0_LLWU_P0_1 $bool = yes // LLWU_P0 input was a wakeup source

//--- Enumerated values for register PF1, field WUF1
  let LLWU_PF1_WUF1_LLWU_P1_0 $bool = no // LLWU_P1 input was not a wakeup source
  let LLWU_PF1_WUF1_LLWU_P1_1 $bool = yes // LLWU_P1 input was a wakeup source

//--- Enumerated values for register PF1, field WUF2
  let LLWU_PF1_WUF2_LLWU_P2_0 $bool = no // LLWU_P2 input was not a wakeup source
  let LLWU_PF1_WUF2_LLWU_P2_1 $bool = yes // LLWU_P2 input was a wakeup source

//--- Enumerated values for register PF1, field WUF3
  let LLWU_PF1_WUF3_LLWU_P3_0 $bool = no // LLWU_P3 input was not a wakeup source
  let LLWU_PF1_WUF3_LLWU_P3_1 $bool = yes // LLWU_P3 input was a wakeup source

//--- Enumerated values for register PF1, field WUF4
  let LLWU_PF1_WUF4_LLWU_P4_0 $bool = no // LLWU_P4 input was not a wakeup source
  let LLWU_PF1_WUF4_LLWU_P4_1 $bool = yes // LLWU_P4 input was a wakeup source

//--- Enumerated values for register PF1, field WUF5
  let LLWU_PF1_WUF5_LLWU_P5_0 $bool = no // LLWU_P5 input was not a wakeup source
  let LLWU_PF1_WUF5_LLWU_P5_1 $bool = yes // LLWU_P5 input was a wakeup source

//--- Enumerated values for register PF1, field WUF6
  let LLWU_PF1_WUF6_LLWU_P6_0 $bool = no // LLWU_P6 input was not a wakeup source
  let LLWU_PF1_WUF6_LLWU_P6_1 $bool = yes // LLWU_P6 input was a wakeup source

//--- Enumerated values for register PF1, field WUF7
  let LLWU_PF1_WUF7_LLWU_P7_0 $bool = no // LLWU_P7 input was not a wakeup source
  let LLWU_PF1_WUF7_LLWU_P7_1 $bool = yes // LLWU_P7 input was a wakeup source

//--- Enumerated values for register PF2, field WUF8
  let LLWU_PF2_WUF8_LLWU_P8_0 $bool = no // LLWU_P8 input was not a wakeup source
  let LLWU_PF2_WUF8_LLWU_P8_1 $bool = yes // LLWU_P8 input was a wakeup source

//--- Enumerated values for register PF2, field WUF9
  let LLWU_PF2_WUF9_LLWU_P9_0 $bool = no // LLWU_P9 input was not a wakeup source
  let LLWU_PF2_WUF9_LLWU_P9_1 $bool = yes // LLWU_P9 input was a wakeup source

//--- Enumerated values for register PF2, field WUF10
  let LLWU_PF2_WUF10_LLWU_P10_0 $bool = no // LLWU_P10 input was not a wakeup source
  let LLWU_PF2_WUF10_LLWU_P10_1 $bool = yes // LLWU_P10 input was a wakeup source

//--- Enumerated values for register PF2, field WUF11
  let LLWU_PF2_WUF11_LLWU_P11_0 $bool = no // LLWU_P11 input was not a wakeup source
  let LLWU_PF2_WUF11_LLWU_P11_1 $bool = yes // LLWU_P11 input was a wakeup source

//--- Enumerated values for register PF2, field WUF12
  let LLWU_PF2_WUF12_LLWU_P12_0 $bool = no // LLWU_P12 input was not a wakeup source
  let LLWU_PF2_WUF12_LLWU_P12_1 $bool = yes // LLWU_P12 input was a wakeup source

//--- Enumerated values for register PF2, field WUF13
  let LLWU_PF2_WUF13_LLWU_P13_0 $bool = no // LLWU_P13 input was not a wakeup source
  let LLWU_PF2_WUF13_LLWU_P13_1 $bool = yes // LLWU_P13 input was a wakeup source

//--- Enumerated values for register PF2, field WUF14
  let LLWU_PF2_WUF14_LLWU_P14_0 $bool = no // LLWU_P14 input was not a wakeup source
  let LLWU_PF2_WUF14_LLWU_P14_1 $bool = yes // LLWU_P14 input was a wakeup source

//--- Enumerated values for register PF2, field WUF15
  let LLWU_PF2_WUF15_LLWU_P15_0 $bool = no // LLWU_P15 input was not a wakeup source
  let LLWU_PF2_WUF15_LLWU_P15_1 $bool = yes // LLWU_P15 input was a wakeup source

//--- Enumerated values for register PF3, field WUF16
  let LLWU_PF3_WUF16_LLWU_P16_0 $bool = no // LLWU_P16 input was not a wakeup source
  let LLWU_PF3_WUF16_LLWU_P16_1 $bool = yes // LLWU_P16 input was a wakeup source

//--- Enumerated values for register PF3, field WUF17
  let LLWU_PF3_WUF17_LLWU_P17_0 $bool = no // LLWU_P17 input was not a wakeup source
  let LLWU_PF3_WUF17_LLWU_P17_1 $bool = yes // LLWU_P17 input was a wakeup source

//--- Enumerated values for register PF3, field WUF18
  let LLWU_PF3_WUF18_LLWU_P18_0 $bool = no // LLWU_P18 input was not a wakeup source
  let LLWU_PF3_WUF18_LLWU_P18_1 $bool = yes // LLWU_P18 input was a wakeup source

//--- Enumerated values for register PF3, field WUF19
  let LLWU_PF3_WUF19_LLWU_P19_0 $bool = no // LLWU_P19 input was not a wakeup source
  let LLWU_PF3_WUF19_LLWU_P19_1 $bool = yes // LLWU_P19 input was a wakeup source

//--- Enumerated values for register PF3, field WUF20
  let LLWU_PF3_WUF20_LLWU_P20_0 $bool = no // LLWU_P20 input was not a wakeup source
  let LLWU_PF3_WUF20_LLWU_P20_1 $bool = yes // LLWU_P20 input was a wakeup source

//--- Enumerated values for register PF3, field WUF21
  let LLWU_PF3_WUF21_LLWU_P21_0 $bool = no // LLWU_P21 input was not a wakeup source
  let LLWU_PF3_WUF21_LLWU_P21_1 $bool = yes // LLWU_P21 input was a wakeup source

//--- Enumerated values for register PF3, field WUF22
  let LLWU_PF3_WUF22_LLWU_P22_0 $bool = no // LLWU_P22 input was not a wakeup source
  let LLWU_PF3_WUF22_LLWU_P22_1 $bool = yes // LLWU_P22 input was a wakeup source

//--- Enumerated values for register PF3, field WUF23
  let LLWU_PF3_WUF23_LLWU_P23_0 $bool = no // LLWU_P23 input was not a wakeup source
  let LLWU_PF3_WUF23_LLWU_P23_1 $bool = yes // LLWU_P23 input was a wakeup source

//--- Enumerated values for register PF4, field WUF24
  let LLWU_PF4_WUF24_LLWU_P24_0 $bool = no // LLWU_P24 input was not a wakeup source
  let LLWU_PF4_WUF24_LLWU_P24_1 $bool = yes // LLWU_P24 input was a wakeup source

//--- Enumerated values for register PF4, field WUF25
  let LLWU_PF4_WUF25_LLWU_P25_0 $bool = no // LLWU_P25 input was not a wakeup source
  let LLWU_PF4_WUF25_LLWU_P25_1 $bool = yes // LLWU_P25 input was a wakeup source

//--- Enumerated values for register PF4, field WUF26
  let LLWU_PF4_WUF26_LLWU_P26_0 $bool = no // LLWU_P26 input was not a wakeup source
  let LLWU_PF4_WUF26_LLWU_P26_1 $bool = yes // LLWU_P26 input was a wakeup source

//--- Enumerated values for register PF4, field WUF27
  let LLWU_PF4_WUF27_LLWU_P27_0 $bool = no // LLWU_P27 input was not a wakeup source
  let LLWU_PF4_WUF27_LLWU_P27_1 $bool = yes // LLWU_P27 input was a wakeup source

//--- Enumerated values for register PF4, field WUF28
  let LLWU_PF4_WUF28_LLWU_P28_0 $bool = no // LLWU_P28 input was not a wakeup source
  let LLWU_PF4_WUF28_LLWU_P28_1 $bool = yes // LLWU_P28 input was a wakeup source

//--- Enumerated values for register PF4, field WUF29
  let LLWU_PF4_WUF29_LLWU_P29_0 $bool = no // LLWU_P29 input was not a wakeup source
  let LLWU_PF4_WUF29_LLWU_P29_1 $bool = yes // LLWU_P29 input was a wakeup source

//--- Enumerated values for register PF4, field WUF30
  let LLWU_PF4_WUF30_LLWU_P30_0 $bool = no // LLWU_P30 input was not a wakeup source
  let LLWU_PF4_WUF30_LLWU_P30_1 $bool = yes // LLWU_P30 input was a wakeup source

//--- Enumerated values for register PF4, field WUF31
  let LLWU_PF4_WUF31_LLWU_P31_0 $bool = no // LLWU_P31 input was not a wakeup source
  let LLWU_PF4_WUF31_LLWU_P31_1 $bool = yes // LLWU_P31 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF0
  let LLWU_MF5_MWUF0_Module_0 $bool = no // Module 0 input was not a wakeup source
  let LLWU_MF5_MWUF0_Module_1 $bool = yes // Module 0 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF1
  let LLWU_MF5_MWUF1_Module_0 $bool = no // Module 1 input was not a wakeup source
  let LLWU_MF5_MWUF1_Module_1 $bool = yes // Module 1 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF2
  let LLWU_MF5_MWUF2_Module_0 $bool = no // Module 2 input was not a wakeup source
  let LLWU_MF5_MWUF2_Module_1 $bool = yes // Module 2 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF3
  let LLWU_MF5_MWUF3_Module_0 $bool = no // Module 3 input was not a wakeup source
  let LLWU_MF5_MWUF3_Module_1 $bool = yes // Module 3 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF4
  let LLWU_MF5_MWUF4_Module_0 $bool = no // Module 4 input was not a wakeup source
  let LLWU_MF5_MWUF4_Module_1 $bool = yes // Module 4 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF5
  let LLWU_MF5_MWUF5_Module_0 $bool = no // Module 5 input was not a wakeup source
  let LLWU_MF5_MWUF5_Module_1 $bool = yes // Module 5 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF6
  let LLWU_MF5_MWUF6_Module_0 $bool = no // Module 6 input was not a wakeup source
  let LLWU_MF5_MWUF6_Module_1 $bool = yes // Module 6 input was a wakeup source

//--- Enumerated values for register MF5, field MWUF7
  let LLWU_MF5_MWUF7_Module_0 $bool = no // Module 7 input was not a wakeup source
  let LLWU_MF5_MWUF7_Module_1 $bool = yes // Module 7 input was a wakeup source

//--- Enumerated values for register FILT1, field FILTSEL
  let LLWU_FILT1_FILTSEL_Select_00000 $u5 = 0 // Select LLWU_P0 for filter
  let LLWU_FILT1_FILTSEL_Select_11111 $u5 = 31 // Select LLWU_P31 for filter

//--- Enumerated values for register FILT1, field FILTE
  let LLWU_FILT1_FILTE_Filter_00 $u2 = 0 // Filter disabled
  let LLWU_FILT1_FILTE_Filter_01 $u2 = 1 // Filter posedge detect enabled
  let LLWU_FILT1_FILTE_Filter_10 $u2 = 2 // Filter negedge detect enabled
  let LLWU_FILT1_FILTE_Filter_11 $u2 = 3 // Filter any edge detect enabled

//--- Enumerated values for register FILT1, field FILTF
  let LLWU_FILT1_FILTF_Pin_0 $bool = no // Pin Filter 1 was not a wakeup source
  let LLWU_FILT1_FILTF_Pin_1 $bool = yes // Pin Filter 1 was a wakeup source

//--- Enumerated values for register FILT2, field FILTSEL
  let LLWU_FILT2_FILTSEL_Select_00000 $u5 = 0 // Select LLWU_P0 for filter
  let LLWU_FILT2_FILTSEL_Select_11111 $u5 = 31 // Select LLWU_P31 for filter

//--- Enumerated values for register FILT2, field FILTE
  let LLWU_FILT2_FILTE_Filter_00 $u2 = 0 // Filter disabled
  let LLWU_FILT2_FILTE_Filter_01 $u2 = 1 // Filter posedge detect enabled
  let LLWU_FILT2_FILTE_Filter_10 $u2 = 2 // Filter negedge detect enabled
  let LLWU_FILT2_FILTE_Filter_11 $u2 = 3 // Filter any edge detect enabled

//--- Enumerated values for register FILT2, field FILTF
  let LLWU_FILT2_FILTF_Pin_0 $bool = no // Pin Filter 2 was not a wakeup source
  let LLWU_FILT2_FILTF_Pin_1 $bool = yes // Pin Filter 2 was a wakeup source

//--- Enumerated values for register FILT3, field FILTSEL
  let LLWU_FILT3_FILTSEL_Select_00000 $u5 = 0 // Select LLWU_P0 for filter
  let LLWU_FILT3_FILTSEL_Select_11111 $u5 = 31 // Select LLWU_P31 for filter

//--- Enumerated values for register FILT3, field FILTE
  let LLWU_FILT3_FILTE_Filter_00 $u2 = 0 // Filter disabled
  let LLWU_FILT3_FILTE_Filter_01 $u2 = 1 // Filter posedge detect enabled
  let LLWU_FILT3_FILTE_Filter_10 $u2 = 2 // Filter negedge detect enabled
  let LLWU_FILT3_FILTE_Filter_11 $u2 = 3 // Filter any edge detect enabled

//--- Enumerated values for register FILT3, field FILTF
  let LLWU_FILT3_FILTF_Pin_0 $bool = no // Pin Filter 3 was not a wakeup source
  let LLWU_FILT3_FILTF_Pin_1 $bool = yes // Pin Filter 3 was a wakeup source

//--- Enumerated values for register FILT4, field FILTSEL
  let LLWU_FILT4_FILTSEL_Select_00000 $u5 = 0 // Select LLWU_P0 for filter
  let LLWU_FILT4_FILTSEL_Select_11111 $u5 = 31 // Select LLWU_P31 for filter

//--- Enumerated values for register FILT4, field FILTE
  let LLWU_FILT4_FILTE_Filter_00 $u2 = 0 // Filter disabled
  let LLWU_FILT4_FILTE_Filter_01 $u2 = 1 // Filter posedge detect enabled
  let LLWU_FILT4_FILTE_Filter_10 $u2 = 2 // Filter negedge detect enabled
  let LLWU_FILT4_FILTE_Filter_11 $u2 = 3 // Filter any edge detect enabled

//--- Enumerated values for register FILT4, field FILTF
  let LLWU_FILT4_FILTF_Pin_0 $bool = no // Pin Filter 4 was not a wakeup source
  let LLWU_FILT4_FILTF_Pin_1 $bool = yes // Pin Filter 4 was a wakeup source

//------------------------------------------------------------------------------
// Peripheral LMEM: Local Memory Controller
//------------------------------------------------------------------------------

registers ©LMEM @at 0xe0082000 {
//---  Register PCCCR: Cache control register
  PCCCR @offset 0x0 $u32 {
    GO // at 31: Initiate Cache Command
    3
    PUSHW1 // at 27: Push Way 1
    INVW1 // at 26: Invalidate Way 1
    PUSHW0 // at 25: Push Way 0
    INVW0 // at 24: Invalidate Way 0
    20
    PCCR3 // at 3: Forces no allocation on cache misses (must also have PCCR2 asserted)
    PCCR2 // at 2: Forces all cacheable spaces to write through
    ENWRBUF // at 1: Enable Write Buffer
    ENCACHE // at 0: Cache enable
  }

//---  Register PCCLCR: Cache line control register
  PCCLCR @offset 0x4 $u32 {
    4
    LACC // at 27: Line access type
    LADSEL // at 26: Line Address Select
    LCMD:2 // at 24: Line Command
    1
    LCWAY // at 22: Line Command Way
    LCIMB // at 21: Line Command Initial Modified Bit
    LCIVB // at 20: Line Command Initial Valid Bit
    3
    TDSEL // at 16: Tag/Data Select
    1
    WSEL // at 14: Way select
    2
    CACHEADDR:10 // at 2: Cache address
    1
    LGO // at 0: Initiate Cache Line Command
  }

//---  Register PCCSAR: Cache search address register
  PCCSAR @offset 0x8 $u32 {
    PHYADDR:30 // at 2: Physical Address
    1
    LGO // at 0: Initiate Cache Line Command
  }

//---  Register PCCCVR: Cache read/write value register
  PCCCVR @offset 0xc $u32 {
    DATA:32 // at 0: Cache read/write Data
  }

//---  Register PCCRMR: Cache regions mode register
  PCCRMR @offset 0x20 $u32 {
    R0:2 // at 30: Region 0 mode
    R1:2 // at 28: Region 1 mode
    R2:2 // at 26: Region 2 mode
    R3:2 // at 24: Region 3 mode
    R4:2 // at 22: Region 4 mode
    R5:2 // at 20: Region 5 mode
    R6:2 // at 18: Region 6 mode
    R7:2 // at 16: Region 7 mode
    R8:2 // at 14: Region 8 mode
    R9:2 // at 12: Region 9 mode
    R10:2 // at 10: Region 10 mode
    R11:2 // at 8: Region 11 mode
    R12:2 // at 6: Region 12 mode
    R13:2 // at 4: Region 13 mode
    R14:2 // at 2: Region 14 mode
    R15:2 // at 0: Region 15 mode
  }

}

//--- Enumerated values for register PCCCR, field ENCACHE
  let LMEM_PCCCR_ENCACHE_Cache_0 $bool = no // Cache disabled
  let LMEM_PCCCR_ENCACHE_Cache_1 $bool = yes // Cache enabled

//--- Enumerated values for register PCCCR, field ENWRBUF
  let LMEM_PCCCR_ENWRBUF_Write_0 $bool = no // Write buffer disabled
  let LMEM_PCCCR_ENWRBUF_Write_1 $bool = yes // Write buffer enabled

//--- Enumerated values for register PCCCR, field INVW0
  let LMEM_PCCCR_INVW0_No_0 $bool = no // No operation
  let LMEM_PCCCR_INVW0_When_1 $bool = yes // When setting the GO bit, invalidate all lines in way 0.

//--- Enumerated values for register PCCCR, field PUSHW0
  let LMEM_PCCCR_PUSHW0_No_0 $bool = no // No operation
  let LMEM_PCCCR_PUSHW0_When_1 $bool = yes // When setting the GO bit, push all modified lines in way 0

//--- Enumerated values for register PCCCR, field INVW1
  let LMEM_PCCCR_INVW1_No_0 $bool = no // No operation
  let LMEM_PCCCR_INVW1_When_1 $bool = yes // When setting the GO bit, invalidate all lines in way 1

//--- Enumerated values for register PCCCR, field PUSHW1
  let LMEM_PCCCR_PUSHW1_No_0 $bool = no // No operation
  let LMEM_PCCCR_PUSHW1_When_1 $bool = yes // When setting the GO bit, push all modified lines in way 1

//--- Enumerated values for register PCCCR, field GO
  let LMEM_PCCCR_GO_Write__0 $bool = no // Write: no effect. Read: no cache command active.
  let LMEM_PCCCR_GO_Write__1 $bool = yes // Write: initiate command indicated by bits 27-24. Read: cache command active.

//--- Enumerated values for register PCCLCR, field LGO
  let LMEM_PCCLCR_LGO_Write__0 $bool = no // Write: no effect. Read: no line command active.
  let LMEM_PCCLCR_LGO_Write__1 $bool = yes // Write: initiate line command indicated by bits 27-24. Read: line command active.

//--- Enumerated values for register PCCLCR, field WSEL
  let LMEM_PCCLCR_WSEL_Way_0 $bool = no // Way 0
  let LMEM_PCCLCR_WSEL_Way_1 $bool = yes // Way 1

//--- Enumerated values for register PCCLCR, field TDSEL
  let LMEM_PCCLCR_TDSEL_Data_0 $bool = no // Data
  let LMEM_PCCLCR_TDSEL_Tag_1 $bool = yes // Tag

//--- Enumerated values for register PCCLCR, field LCMD
  let LMEM_PCCLCR_LCMD_Search_00 $u2 = 0 // Search and read or write
  let LMEM_PCCLCR_LCMD_Invalidate_01 $u2 = 1 // Invalidate
  let LMEM_PCCLCR_LCMD_Push_10 $u2 = 2 // Push
  let LMEM_PCCLCR_LCMD_Clear_11 $u2 = 3 // Clear

//--- Enumerated values for register PCCLCR, field LADSEL
  let LMEM_PCCLCR_LADSEL_Cache_0 $bool = no // Cache address
  let LMEM_PCCLCR_LADSEL_Physical_1 $bool = yes // Physical address

//--- Enumerated values for register PCCLCR, field LACC
  let LMEM_PCCLCR_LACC_Read_0 $bool = no // Read
  let LMEM_PCCLCR_LACC_Write_1 $bool = yes // Write

//--- Enumerated values for register PCCSAR, field LGO
  let LMEM_PCCSAR_LGO_Write__0 $bool = no // Write: no effect. Read: no line command active.
  let LMEM_PCCSAR_LGO_Write__1 $bool = yes // Write: initiate line command indicated by bits CLCR[27:24]. Read: line command active.

//--- Enumerated values for register PCCRMR, field R15
  let LMEM_PCCRMR_R15_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R15_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R15_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R15_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R14
  let LMEM_PCCRMR_R14_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R14_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R14_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R14_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R13
  let LMEM_PCCRMR_R13_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R13_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R13_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R13_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R12
  let LMEM_PCCRMR_R12_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R12_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R12_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R12_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R11
  let LMEM_PCCRMR_R11_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R11_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R11_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R11_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R10
  let LMEM_PCCRMR_R10_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R10_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R10_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R10_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R9
  let LMEM_PCCRMR_R9_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R9_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R9_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R9_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R8
  let LMEM_PCCRMR_R8_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R8_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R8_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R8_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R7
  let LMEM_PCCRMR_R7_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R7_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R7_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R7_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R6
  let LMEM_PCCRMR_R6_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R6_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R6_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R6_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R5
  let LMEM_PCCRMR_R5_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R5_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R5_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R5_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R4
  let LMEM_PCCRMR_R4_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R4_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R4_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R4_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R3
  let LMEM_PCCRMR_R3_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R3_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R3_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R3_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R2
  let LMEM_PCCRMR_R2_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R2_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R2_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R2_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R1
  let LMEM_PCCRMR_R1_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R1_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R1_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R1_Write_back_11 $u2 = 3 // Write-back

//--- Enumerated values for register PCCRMR, field R0
  let LMEM_PCCRMR_R0_Non_cacheable_00 $u2 = 0 // Non-cacheable
  let LMEM_PCCRMR_R0_Non_cacheable_01 $u2 = 1 // Non-cacheable
  let LMEM_PCCRMR_R0_Write_through_10 $u2 = 2 // Write-through
  let LMEM_PCCRMR_R0_Write_back_11 $u2 = 3 // Write-back

//------------------------------------------------------------------------------
// Peripheral LPTMR0: Low Power Timer
//------------------------------------------------------------------------------

registers ©LPTMR0 @at 0x40040000 {
//---  Register CSR: Low Power Timer Control Status Register
  CSR @offset 0x0 $u32 {
    24
    TCF // at 7: Timer Compare Flag
    TIE // at 6: Timer Interrupt Enable
    TPS:2 // at 4: Timer Pin Select
    TPP // at 3: Timer Pin Polarity
    TFC // at 2: Timer Free-Running Counter
    TMS // at 1: Timer Mode Select
    TEN // at 0: Timer Enable
  }

//---  Register PSR: Low Power Timer Prescale Register
  PSR @offset 0x4 $u32 {
    25
    PRESCALE:4 // at 3: Prescale Value
    PBYP // at 2: Prescaler Bypass
    PCS:2 // at 0: Prescaler Clock Select
  }

//---  Register CMR: Low Power Timer Compare Register
  CMR @offset 0x8 $u32 {
    16
    COMPARE:16 // at 0: Compare Value
  }

//---  Register CNR: Low Power Timer Counter Register
  CNR @offset 0xc $u32 {
    16
    COUNTER:16 // at 0: Counter Value
  }

}

//--- Enumerated values for register CSR, field TEN
  let LPTMR0_CSR_TEN_LPTMR_0 $bool = no // LPTMR is disabled and internal logic is reset.
  let LPTMR0_CSR_TEN_LPTMR_1 $bool = yes // LPTMR is enabled.

//--- Enumerated values for register CSR, field TMS
  let LPTMR0_CSR_TMS_Time_0 $bool = no // Time Counter mode.
  let LPTMR0_CSR_TMS_Pulse_1 $bool = yes // Pulse Counter mode.

//--- Enumerated values for register CSR, field TFC
  let LPTMR0_CSR_TFC_CNR_0 $bool = no // CNR is reset whenever TCF is set.
  let LPTMR0_CSR_TFC_CNR_1 $bool = yes // CNR is reset on overflow.

//--- Enumerated values for register CSR, field TPP
  let LPTMR0_CSR_TPP_Pulse_0 $bool = no // Pulse Counter input source is active-high, and the CNR will increment on the rising-edge.
  let LPTMR0_CSR_TPP_Pulse_1 $bool = yes // Pulse Counter input source is active-low, and the CNR will increment on the falling-edge.

//--- Enumerated values for register CSR, field TPS
  let LPTMR0_CSR_TPS_Pulse_00 $u2 = 0 // Pulse counter input 0 is selected.
  let LPTMR0_CSR_TPS_Pulse_01 $u2 = 1 // Pulse counter input 1 is selected.
  let LPTMR0_CSR_TPS_Pulse_10 $u2 = 2 // Pulse counter input 2 is selected.
  let LPTMR0_CSR_TPS_Pulse_11 $u2 = 3 // Pulse counter input 3 is selected.

//--- Enumerated values for register CSR, field TIE
  let LPTMR0_CSR_TIE_Timer_0 $bool = no // Timer interrupt disabled.
  let LPTMR0_CSR_TIE_Timer_1 $bool = yes // Timer interrupt enabled.

//--- Enumerated values for register CSR, field TCF
  let LPTMR0_CSR_TCF_The_0 $bool = no // The value of CNR is not equal to CMR and increments.
  let LPTMR0_CSR_TCF_The_1 $bool = yes // The value of CNR is equal to CMR and increments.

//--- Enumerated values for register PSR, field PCS
  let LPTMR0_PSR_PCS_Prescaler_glitch_00 $u2 = 0 // Prescaler/glitch filter clock 0 selected.
  let LPTMR0_PSR_PCS_Prescaler_glitch_01 $u2 = 1 // Prescaler/glitch filter clock 1 selected.
  let LPTMR0_PSR_PCS_Prescaler_glitch_10 $u2 = 2 // Prescaler/glitch filter clock 2 selected.
  let LPTMR0_PSR_PCS_Prescaler_glitch_11 $u2 = 3 // Prescaler/glitch filter clock 3 selected.

//--- Enumerated values for register PSR, field PBYP
  let LPTMR0_PSR_PBYP_Prescaler_glitch_0 $bool = no // Prescaler/glitch filter is enabled.
  let LPTMR0_PSR_PBYP_Prescaler_glitch_1 $bool = yes // Prescaler/glitch filter is bypassed.

//--- Enumerated values for register PSR, field PRESCALE
  let LPTMR0_PSR_PRESCALE_Prescaler_0000 $u4 = 0 // Prescaler divides the prescaler clock by 2; glitch filter does not support this configuration.
  let LPTMR0_PSR_PRESCALE_Prescaler_0001 $u4 = 1 // Prescaler divides the prescaler clock by 4; glitch filter recognizes change on input pin after 2 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_0010 $u4 = 2 // Prescaler divides the prescaler clock by 8; glitch filter recognizes change on input pin after 4 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_0011 $u4 = 3 // Prescaler divides the prescaler clock by 16; glitch filter recognizes change on input pin after 8 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_0100 $u4 = 4 // Prescaler divides the prescaler clock by 32; glitch filter recognizes change on input pin after 16 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_0101 $u4 = 5 // Prescaler divides the prescaler clock by 64; glitch filter recognizes change on input pin after 32 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_0110 $u4 = 6 // Prescaler divides the prescaler clock by 128; glitch filter recognizes change on input pin after 64 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_0111 $u4 = 7 // Prescaler divides the prescaler clock by 256; glitch filter recognizes change on input pin after 128 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1000 $u4 = 8 // Prescaler divides the prescaler clock by 512; glitch filter recognizes change on input pin after 256 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1001 $u4 = 9 // Prescaler divides the prescaler clock by 1024; glitch filter recognizes change on input pin after 512 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1010 $u4 = 10 // Prescaler divides the prescaler clock by 2048; glitch filter recognizes change on input pin after 1024 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1011 $u4 = 11 // Prescaler divides the prescaler clock by 4096; glitch filter recognizes change on input pin after 2048 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1100 $u4 = 12 // Prescaler divides the prescaler clock by 8192; glitch filter recognizes change on input pin after 4096 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1101 $u4 = 13 // Prescaler divides the prescaler clock by 16,384; glitch filter recognizes change on input pin after 8192 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1110 $u4 = 14 // Prescaler divides the prescaler clock by 32,768; glitch filter recognizes change on input pin after 16,384 rising clock edges.
  let LPTMR0_PSR_PRESCALE_Prescaler_1111 $u4 = 15 // Prescaler divides the prescaler clock by 65,536; glitch filter recognizes change on input pin after 32,768 rising clock edges.

//------------------------------------------------------------------------------
// Peripheral LPUART0: Universal Asynchronous Receiver/Transmitter
//------------------------------------------------------------------------------

registers ©LPUART0 @at 0x400c4000 {
//---  Register BAUD: LPUART Baud Rate Register
  BAUD @offset 0x0 $u32 {
    MAEN1 // at 31: Match Address Mode Enable 1
    MAEN2 // at 30: Match Address Mode Enable 2
    M10 // at 29: 10-bit Mode select
    OSR:5 // at 24: Over Sampling Ratio
    TDMAE // at 23: Transmitter DMA Enable
    1
    RDMAE // at 21: Receiver Full DMA Enable
    1
    MATCFG:2 // at 18: Match Configuration
    BOTHEDGE // at 17: Both Edge Sampling
    RESYNCDIS // at 16: Resynchronization Disable
    LBKDIE // at 15: LIN Break Detect Interrupt Enable
    RXEDGIE // at 14: RX Input Active Edge Interrupt Enable
    SBNS // at 13: Stop Bit Number Select
    SBR:13 // at 0: Baud Rate Modulo Divisor.
  }

//---  Register STAT: LPUART Status Register
  STAT @offset 0x4 $u32 {
    LBKDIF // at 31: LIN Break Detect Interrupt Flag
    RXEDGIF // at 30: LPUART_RX Pin Active Edge Interrupt Flag
    MSBF // at 29: MSB First
    RXINV // at 28: Receive Data Inversion
    RWUID // at 27: Receive Wake Up Idle Detect
    BRK13 // at 26: Break Character Generation Length
    LBKDE // at 25: LIN Break Detection Enable
    RAF // at 24: Receiver Active Flag
    TDRE // at 23: Transmit Data Register Empty Flag
    TC // at 22: Transmission Complete Flag
    RDRF // at 21: Receive Data Register Full Flag
    IDLE // at 20: Idle Line Flag
    OR // at 19: Receiver Overrun Flag
    NF // at 18: Noise Flag
    FE // at 17: Framing Error Flag
    PF // at 16: Parity Error Flag
    MA1F // at 15: Match 1 Flag
    MA2F // at 14: Match 2 Flag
    14
  }

//---  Register CTRL: LPUART Control Register
  CTRL @offset 0x8 $u32 {
    R8T9 // at 31: Receive Bit 8 / Transmit Bit 9
    R9T8 // at 30: Receive Bit 9 / Transmit Bit 8
    TXDIR // at 29: LPUART_TX Pin Direction in Single-Wire Mode
    TXINV // at 28: Transmit Data Inversion
    ORIE // at 27: Overrun Interrupt Enable
    NEIE // at 26: Noise Error Interrupt Enable
    FEIE // at 25: Framing Error Interrupt Enable
    PEIE // at 24: Parity Error Interrupt Enable
    TIE // at 23: Transmit Interrupt Enable
    TCIE // at 22: Transmission Complete Interrupt Enable for
    RIE // at 21: Receiver Interrupt Enable
    ILIE // at 20: Idle Line Interrupt Enable
    TE // at 19: Transmitter Enable
    RE // at 18: Receiver Enable
    RWU // at 17: Receiver Wakeup Control
    SBK // at 16: Send Break
    MA1IE // at 15: Match 1 Interrupt Enable
    MA2IE // at 14: Match 2 Interrupt Enable
    3
    IDLECFG:3 // at 8: Idle Configuration
    LOOPS // at 7: Loop Mode Select
    DOZEEN // at 6: Doze Enable
    RSRC // at 5: Receiver Source Select
    M // at 4: 9-Bit or 8-Bit Mode Select
    WAKE // at 3: Receiver Wakeup Method Select
    ILT // at 2: Idle Line Type Select
    PE // at 1: Parity Enable
    PT // at 0: Parity Type
  }

//---  Register DATA: LPUART Data Register
  DATA @offset 0xc $u32 {
    16
    NOISY // at 15: The current received dataword contained in DATA[R9:R0] was received with noise.
    PARITYE // at 14: The current received dataword contained in DATA[R9:R0] was received with a parity error.
    FRETSC // at 13: Frame Error / Transmit Special Character
    RXEMPT // at 12: Receive Buffer Empty
    IDLINE // at 11: Idle Line
    1
    R9T9 // at 9: Read receive data buffer 9 or write transmit data buffer 9.
    R8T8 // at 8: Read receive data buffer 8 or write transmit data buffer 8.
    R7T7 // at 7: Read receive data buffer 7 or write transmit data buffer 7.
    R6T6 // at 6: Read receive data buffer 6 or write transmit data buffer 6.
    R5T5 // at 5: Read receive data buffer 5 or write transmit data buffer 5.
    R4T4 // at 4: Read receive data buffer 4 or write transmit data buffer 4.
    R3T3 // at 3: Read receive data buffer 3 or write transmit data buffer 3.
    R2T2 // at 2: Read receive data buffer 2 or write transmit data buffer 2.
    R1T1 // at 1: Read receive data buffer 1 or write transmit data buffer 1.
    R0T0 // at 0: Read receive data buffer 0 or write transmit data buffer 0.
  }

//---  Register MATCH: LPUART Match Address Register
  MATCH @offset 0x10 $u32 {
    6
    MA2:10 // at 16: Match Address 2
    6
    MA1:10 // at 0: Match Address 1
  }

//---  Register MODIR: LPUART Modem IrDA Register
  MODIR @offset 0x14 $u32 {
    13
    IREN // at 18: Infrared enable
    TNP:2 // at 16: Transmitter narrow pulse
    10
    TXCTSSRC // at 5: Transmit CTS Source
    TXCTSC // at 4: Transmit CTS Configuration
    RXRTSE // at 3: Receiver request-to-send enable
    TXRTSPOL // at 2: Transmitter request-to-send polarity
    TXRTSE // at 1: Transmitter request-to-send enable
    TXCTSE // at 0: Transmitter clear-to-send enable
  }

}

//--- Enumerated values for register BAUD, field SBNS
  let LPUART0_BAUD_SBNS_One_0 $bool = no // One stop bit.
  let LPUART0_BAUD_SBNS_Two_1 $bool = yes // Two stop bits.

//--- Enumerated values for register BAUD, field RXEDGIE
  let LPUART0_BAUD_RXEDGIE_Hardware_0 $bool = no // Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
  let LPUART0_BAUD_RXEDGIE_Hardware_1 $bool = yes // Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.

//--- Enumerated values for register BAUD, field LBKDIE
  let LPUART0_BAUD_LBKDIE_Hardware_0 $bool = no // Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
  let LPUART0_BAUD_LBKDIE_Hardware_1 $bool = yes // Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.

//--- Enumerated values for register BAUD, field RESYNCDIS
  let LPUART0_BAUD_RESYNCDIS_Resynchronization_0 $bool = no // Resynchronization during received data word is supported
  let LPUART0_BAUD_RESYNCDIS_Resynchronization_1 $bool = yes // Resynchronization during received data word is disabled

//--- Enumerated values for register BAUD, field BOTHEDGE
  let LPUART0_BAUD_BOTHEDGE_Receiver_0 $bool = no // Receiver samples input data using the rising edge of the baud rate clock.
  let LPUART0_BAUD_BOTHEDGE_Receiver_1 $bool = yes // Receiver samples input data using the rising and falling edge of the baud rate clock.

//--- Enumerated values for register BAUD, field MATCFG
  let LPUART0_BAUD_MATCFG_Address_00 $u2 = 0 // Address Match Wakeup
  let LPUART0_BAUD_MATCFG_Idle_01 $u2 = 1 // Idle Match Wakeup
  let LPUART0_BAUD_MATCFG_Match_10 $u2 = 2 // Match On and Match Off
  let LPUART0_BAUD_MATCFG_Enables_11 $u2 = 3 // Enables RWU on Data Match and Match On/Off for transmitter CTS input

//--- Enumerated values for register BAUD, field RDMAE
  let LPUART0_BAUD_RDMAE_DMA_0 $bool = no // DMA request disabled.
  let LPUART0_BAUD_RDMAE_DMA_1 $bool = yes // DMA request enabled.

//--- Enumerated values for register BAUD, field TDMAE
  let LPUART0_BAUD_TDMAE_DMA_0 $bool = no // DMA request disabled.
  let LPUART0_BAUD_TDMAE_DMA_1 $bool = yes // DMA request enabled.

//--- Enumerated values for register BAUD, field M10
  let LPUART0_BAUD_M10_Receiver_0 $bool = no // Receiver and transmitter use 8-bit or 9-bit data characters.
  let LPUART0_BAUD_M10_Receiver_1 $bool = yes // Receiver and transmitter use 10-bit data characters.

//--- Enumerated values for register BAUD, field MAEN2
  let LPUART0_BAUD_MAEN2_Normal_0 $bool = no // Normal operation.
  let LPUART0_BAUD_MAEN2_Enables_1 $bool = yes // Enables automatic address matching or data matching mode for MATCH[MA2].

//--- Enumerated values for register BAUD, field MAEN1
  let LPUART0_BAUD_MAEN1_Normal_0 $bool = no // Normal operation.
  let LPUART0_BAUD_MAEN1_Enables_1 $bool = yes // Enables automatic address matching or data matching mode for MATCH[MA1].

//--- Enumerated values for register STAT, field MA2F
  let LPUART0_STAT_MA2F_Received_0 $bool = no // Received data is not equal to MA2
  let LPUART0_STAT_MA2F_Received_1 $bool = yes // Received data is equal to MA2

//--- Enumerated values for register STAT, field MA1F
  let LPUART0_STAT_MA1F_Received_0 $bool = no // Received data is not equal to MA1
  let LPUART0_STAT_MA1F_Received_1 $bool = yes // Received data is equal to MA1

//--- Enumerated values for register STAT, field PF
  let LPUART0_STAT_PF_No_0 $bool = no // No parity error.
  let LPUART0_STAT_PF_Parity_1 $bool = yes // Parity error.

//--- Enumerated values for register STAT, field FE
  let LPUART0_STAT_FE_No_0 $bool = no // No framing error detected. This does not guarantee the framing is correct.
  let LPUART0_STAT_FE_Framing_1 $bool = yes // Framing error.

//--- Enumerated values for register STAT, field NF
  let LPUART0_STAT_NF_No_0 $bool = no // No noise detected.
  let LPUART0_STAT_NF_Noise_1 $bool = yes // Noise detected in the received character in LPUART_DATA.

//--- Enumerated values for register STAT, field OR
  let LPUART0_STAT_OR_No_0 $bool = no // No overrun.
  let LPUART0_STAT_OR_Receive_1 $bool = yes // Receive overrun (new LPUART data lost).

//--- Enumerated values for register STAT, field IDLE
  let LPUART0_STAT_IDLE_No_0 $bool = no // No idle line detected.
  let LPUART0_STAT_IDLE_Idle_1 $bool = yes // Idle line was detected.

//--- Enumerated values for register STAT, field RDRF
  let LPUART0_STAT_RDRF_Receive_0 $bool = no // Receive data buffer empty.
  let LPUART0_STAT_RDRF_Receive_1 $bool = yes // Receive data buffer full.

//--- Enumerated values for register STAT, field TC
  let LPUART0_STAT_TC_Transmitter_0 $bool = no // Transmitter active (sending data, a preamble, or a break).
  let LPUART0_STAT_TC_Transmitter_1 $bool = yes // Transmitter idle (transmission activity complete).

//--- Enumerated values for register STAT, field TDRE
  let LPUART0_STAT_TDRE_Transmit_0 $bool = no // Transmit data buffer full.
  let LPUART0_STAT_TDRE_Transmit_1 $bool = yes // Transmit data buffer empty.

//--- Enumerated values for register STAT, field RAF
  let LPUART0_STAT_RAF_LPUART_0 $bool = no // LPUART receiver idle waiting for a start bit.
  let LPUART0_STAT_RAF_LPUART_1 $bool = yes // LPUART receiver active (LPUART_RX input not idle).

//--- Enumerated values for register STAT, field LBKDE
  let LPUART0_STAT_LBKDE_Break_0 $bool = no // Break character is detected at length 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
  let LPUART0_STAT_LBKDE_Break_1 $bool = yes // Break character is detected at length of 11 bit times (if M = 0, SBNS = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).

//--- Enumerated values for register STAT, field BRK13
  let LPUART0_STAT_BRK13_Break_0 $bool = no // Break character is transmitted with length of 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
  let LPUART0_STAT_BRK13_Break_1 $bool = yes // Break character is transmitted with length of 13 bit times (if M = 0, SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).

//--- Enumerated values for register STAT, field RWUID
  let LPUART0_STAT_RWUID_During_0 $bool = no // During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not get set when an address does not match.
  let LPUART0_STAT_RWUID_During_1 $bool = yes // During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does get set when an address does not match.

//--- Enumerated values for register STAT, field RXINV
  let LPUART0_STAT_RXINV_Receive_0 $bool = no // Receive data not inverted.
  let LPUART0_STAT_RXINV_Receive_1 $bool = yes // Receive data inverted.

//--- Enumerated values for register STAT, field MSBF
  let LPUART0_STAT_MSBF_LSB_0 $bool = no // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
  let LPUART0_STAT_MSBF_MSB_1 $bool = yes // MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].

//--- Enumerated values for register STAT, field RXEDGIF
  let LPUART0_STAT_RXEDGIF_No_0 $bool = no // No active edge on the receive pin has occurred.
  let LPUART0_STAT_RXEDGIF_An_1 $bool = yes // An active edge on the receive pin has occurred.

//--- Enumerated values for register STAT, field LBKDIF
  let LPUART0_STAT_LBKDIF_No_0 $bool = no // No LIN break character has been detected.
  let LPUART0_STAT_LBKDIF_LIN_1 $bool = yes // LIN break character has been detected.

//--- Enumerated values for register CTRL, field PT
  let LPUART0_CTRL_PT_Even_0 $bool = no // Even parity.
  let LPUART0_CTRL_PT_Odd_1 $bool = yes // Odd parity.

//--- Enumerated values for register CTRL, field PE
  let LPUART0_CTRL_PE_No_0 $bool = no // No hardware parity generation or checking.
  let LPUART0_CTRL_PE_Parity_1 $bool = yes // Parity enabled.

//--- Enumerated values for register CTRL, field ILT
  let LPUART0_CTRL_ILT_Idle_0 $bool = no // Idle character bit count starts after start bit.
  let LPUART0_CTRL_ILT_Idle_1 $bool = yes // Idle character bit count starts after stop bit.

//--- Enumerated values for register CTRL, field WAKE
  let LPUART0_CTRL_WAKE_Configures_0 $bool = no // Configures RWU for idle-line wakeup.
  let LPUART0_CTRL_WAKE_Configures_1 $bool = yes // Configures RWU with address-mark wakeup.

//--- Enumerated values for register CTRL, field M
  let LPUART0_CTRL_M_Receiver_0 $bool = no // Receiver and transmitter use 8-bit data characters.
  let LPUART0_CTRL_M_Receiver_1 $bool = yes // Receiver and transmitter use 9-bit data characters.

//--- Enumerated values for register CTRL, field RSRC
  let LPUART0_CTRL_RSRC_Provided_0 $bool = no // Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the LPUART_RX pin.
  let LPUART0_CTRL_RSRC_Single_wire_1 $bool = yes // Single-wire LPUART mode where the LPUART_TX pin is connected to the transmitter output and receiver input.

//--- Enumerated values for register CTRL, field DOZEEN
  let LPUART0_CTRL_DOZEEN_LPUART_0 $bool = no // LPUART is enabled in Doze mode.
  let LPUART0_CTRL_DOZEEN_LPUART_1 $bool = yes // LPUART is disabled in Doze mode.

//--- Enumerated values for register CTRL, field LOOPS
  let LPUART0_CTRL_LOOPS_Normal_0 $bool = no // Normal operation - LPUART_RX and LPUART_TX use separate pins.
  let LPUART0_CTRL_LOOPS_Loop_1 $bool = yes // Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).

//--- Enumerated values for register CTRL, field IDLECFG
  let LPUART0_CTRL_IDLECFG_1_000 $u3 = 0 // 1 idle character
  let LPUART0_CTRL_IDLECFG_2_001 $u3 = 1 // 2 idle characters
  let LPUART0_CTRL_IDLECFG_4_010 $u3 = 2 // 4 idle characters
  let LPUART0_CTRL_IDLECFG_8_011 $u3 = 3 // 8 idle characters
  let LPUART0_CTRL_IDLECFG_16_100 $u3 = 4 // 16 idle characters
  let LPUART0_CTRL_IDLECFG_32_101 $u3 = 5 // 32 idle characters
  let LPUART0_CTRL_IDLECFG_64_110 $u3 = 6 // 64 idle characters
  let LPUART0_CTRL_IDLECFG_128_111 $u3 = 7 // 128 idle characters

//--- Enumerated values for register CTRL, field MA2IE
  let LPUART0_CTRL_MA2IE_MA2F_0 $bool = no // MA2F interrupt disabled
  let LPUART0_CTRL_MA2IE_MA2F_1 $bool = yes // MA2F interrupt enabled

//--- Enumerated values for register CTRL, field MA1IE
  let LPUART0_CTRL_MA1IE_MA1F_0 $bool = no // MA1F interrupt disabled
  let LPUART0_CTRL_MA1IE_MA1F_1 $bool = yes // MA1F interrupt enabled

//--- Enumerated values for register CTRL, field SBK
  let LPUART0_CTRL_SBK_Normal_0 $bool = no // Normal transmitter operation.
  let LPUART0_CTRL_SBK_Queue_1 $bool = yes // Queue break character(s) to be sent.

//--- Enumerated values for register CTRL, field RWU
  let LPUART0_CTRL_RWU_Normal_0 $bool = no // Normal receiver operation.
  let LPUART0_CTRL_RWU_LPUART_1 $bool = yes // LPUART receiver in standby waiting for wakeup condition.

//--- Enumerated values for register CTRL, field RE
  let LPUART0_CTRL_RE_Receiver_0 $bool = no // Receiver disabled.
  let LPUART0_CTRL_RE_Receiver_1 $bool = yes // Receiver enabled.

//--- Enumerated values for register CTRL, field TE
  let LPUART0_CTRL_TE_Transmitter_0 $bool = no // Transmitter disabled.
  let LPUART0_CTRL_TE_Transmitter_1 $bool = yes // Transmitter enabled.

//--- Enumerated values for register CTRL, field ILIE
  let LPUART0_CTRL_ILIE_Hardware_0 $bool = no // Hardware interrupts from IDLE disabled; use polling.
  let LPUART0_CTRL_ILIE_Hardware_1 $bool = yes // Hardware interrupt requested when IDLE flag is 1.

//--- Enumerated values for register CTRL, field RIE
  let LPUART0_CTRL_RIE_Hardware_0 $bool = no // Hardware interrupts from RDRF disabled; use polling.
  let LPUART0_CTRL_RIE_Hardware_1 $bool = yes // Hardware interrupt requested when RDRF flag is 1.

//--- Enumerated values for register CTRL, field TCIE
  let LPUART0_CTRL_TCIE_Hardware_0 $bool = no // Hardware interrupts from TC disabled; use polling.
  let LPUART0_CTRL_TCIE_Hardware_1 $bool = yes // Hardware interrupt requested when TC flag is 1.

//--- Enumerated values for register CTRL, field TIE
  let LPUART0_CTRL_TIE_Hardware_0 $bool = no // Hardware interrupts from TDRE disabled; use polling.
  let LPUART0_CTRL_TIE_Hardware_1 $bool = yes // Hardware interrupt requested when TDRE flag is 1.

//--- Enumerated values for register CTRL, field PEIE
  let LPUART0_CTRL_PEIE_PF_0 $bool = no // PF interrupts disabled; use polling).
  let LPUART0_CTRL_PEIE_Hardware_1 $bool = yes // Hardware interrupt requested when PF is set.

//--- Enumerated values for register CTRL, field FEIE
  let LPUART0_CTRL_FEIE_FE_0 $bool = no // FE interrupts disabled; use polling.
  let LPUART0_CTRL_FEIE_Hardware_1 $bool = yes // Hardware interrupt requested when FE is set.

//--- Enumerated values for register CTRL, field NEIE
  let LPUART0_CTRL_NEIE_NF_0 $bool = no // NF interrupts disabled; use polling.
  let LPUART0_CTRL_NEIE_Hardware_1 $bool = yes // Hardware interrupt requested when NF is set.

//--- Enumerated values for register CTRL, field ORIE
  let LPUART0_CTRL_ORIE_OR_0 $bool = no // OR interrupts disabled; use polling.
  let LPUART0_CTRL_ORIE_Hardware_1 $bool = yes // Hardware interrupt requested when OR is set.

//--- Enumerated values for register CTRL, field TXINV
  let LPUART0_CTRL_TXINV_Transmit_0 $bool = no // Transmit data not inverted.
  let LPUART0_CTRL_TXINV_Transmit_1 $bool = yes // Transmit data inverted.

//--- Enumerated values for register CTRL, field TXDIR
  let LPUART0_CTRL_TXDIR_LPUART_TX_0 $bool = no // LPUART_TX pin is an input in single-wire mode.
  let LPUART0_CTRL_TXDIR_LPUART_TX_1 $bool = yes // LPUART_TX pin is an output in single-wire mode.

//--- Enumerated values for register DATA, field IDLINE
  let LPUART0_DATA_IDLINE_Receiver_0 $bool = no // Receiver was not idle before receiving this character.
  let LPUART0_DATA_IDLINE_Receiver_1 $bool = yes // Receiver was idle before receiving this character.

//--- Enumerated values for register DATA, field RXEMPT
  let LPUART0_DATA_RXEMPT_Receive_0 $bool = no // Receive buffer contains valid data.
  let LPUART0_DATA_RXEMPT_Receive_1 $bool = yes // Receive buffer is empty, data returned on read is not valid.

//--- Enumerated values for register DATA, field FRETSC
  let LPUART0_DATA_FRETSC_The_0 $bool = no // The dataword was received without a frame error on read, transmit a normal character on write.
  let LPUART0_DATA_FRETSC_The_1 $bool = yes // The dataword was received with a frame error, transmit an idle or break character on transmit.

//--- Enumerated values for register DATA, field PARITYE
  let LPUART0_DATA_PARITYE_The_0 $bool = no // The dataword was received without a parity error.
  let LPUART0_DATA_PARITYE_The_1 $bool = yes // The dataword was received with a parity error.

//--- Enumerated values for register DATA, field NOISY
  let LPUART0_DATA_NOISY_The_0 $bool = no // The dataword was received without noise.
  let LPUART0_DATA_NOISY_The_1 $bool = yes // The data was received with noise.

//--- Enumerated values for register MODIR, field TXCTSE
  let LPUART0_MODIR_TXCTSE_CTS_0 $bool = no // CTS has no effect on the transmitter.
  let LPUART0_MODIR_TXCTSE_Enables_1 $bool = yes // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.

//--- Enumerated values for register MODIR, field TXRTSE
  let LPUART0_MODIR_TXRTSE_The_0 $bool = no // The transmitter has no effect on RTS.
  let LPUART0_MODIR_TXRTSE_When_1 $bool = yes // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.

//--- Enumerated values for register MODIR, field TXRTSPOL
  let LPUART0_MODIR_TXRTSPOL_Transmitter_0 $bool = no // Transmitter RTS is active low.
  let LPUART0_MODIR_TXRTSPOL_Transmitter_1 $bool = yes // Transmitter RTS is active high.

//--- Enumerated values for register MODIR, field RXRTSE
  let LPUART0_MODIR_RXRTSE_The_0 $bool = no // The receiver has no effect on RTS.
  let LPUART0_MODIR_RXRTSE_RTS_1 $bool = yes // RTS is deasserted if the receiver data register is full or a start bit has been detected that would cause the receiver data register to become full. RTS is asserted if the receiver data register is not full and has not detected a start bit that would cause the receiver data register to become full.

//--- Enumerated values for register MODIR, field TXCTSC
  let LPUART0_MODIR_TXCTSC_CTS_0 $bool = no // CTS input is sampled at the start of each character.
  let LPUART0_MODIR_TXCTSC_CTS_1 $bool = yes // CTS input is sampled when the transmitter is idle.

//--- Enumerated values for register MODIR, field TXCTSSRC
  let LPUART0_MODIR_TXCTSSRC_CTS_0 $bool = no // CTS input is the LPUART_CTS pin.
  let LPUART0_MODIR_TXCTSSRC_CTS_1 $bool = yes // CTS input is the inverted Receiver Match result.

//--- Enumerated values for register MODIR, field TNP
  let LPUART0_MODIR_TNP_1_OSR__00 $u2 = 0 // 1/OSR.
  let LPUART0_MODIR_TNP_2_OSR__01 $u2 = 1 // 2/OSR.
  let LPUART0_MODIR_TNP_3_OSR__10 $u2 = 2 // 3/OSR.
  let LPUART0_MODIR_TNP_4_OSR__11 $u2 = 3 // 4/OSR.

//--- Enumerated values for register MODIR, field IREN
  let LPUART0_MODIR_IREN_IR_0 $bool = no // IR disabled.
  let LPUART0_MODIR_IREN_IR_1 $bool = yes // IR enabled.

//------------------------------------------------------------------------------
// Peripheral MCG: Multipurpose Clock Generator module
//------------------------------------------------------------------------------

registers ©MCG @at 0x40064000 {
//---  Register C1: MCG Control 1 Register
  C1 @offset 0x0 $u8 {
    CLKS:2 // at 6: Clock Source Select
    FRDIV:3 // at 3: FLL External Reference Divider
    IREFS // at 2: Internal Reference Select
    IRCLKEN // at 1: Internal Reference Clock Enable
    IREFSTEN // at 0: Internal Reference Stop Enable
  }

//---  Register C2: MCG Control 2 Register
  C2 @offset 0x1 $u8 {
    LOCRE0 // at 7: Loss of Clock Reset Enable
    FCFTRIM // at 6: Fast Internal Reference Clock Fine Trim
    RANGE:2 // at 4: Frequency Range Select
    HGO // at 3: High Gain Oscillator Select
    EREFS // at 2: External Reference Select
    LP // at 1: Low Power Select
    IRCS // at 0: Internal Reference Clock Select
  }

//---  Register C3: MCG Control 3 Register
  C3 @offset 0x2 $u8 {
    SCTRIM:8 // at 0: Slow Internal Reference Clock Trim Setting
  }

//---  Register C4: MCG Control 4 Register
  C4 @offset 0x3 $u8 {
    DMX32 // at 7: DCO Maximum Frequency with 32.768 kHz Reference
    DRST_DRS:2 // at 5: DCO Range Select
    FCTRIM:4 // at 1: Fast Internal Reference Clock Trim Setting
    SCFTRIM // at 0: Slow Internal Reference Clock Fine Trim
  }

//---  Register C5: MCG Control 5 Register
  C5 @offset 0x4 $u8 {
    1
    PLLCLKEN // at 6: PLL Clock Enable
    PLLSTEN // at 5: PLL Stop Enable
    2
    PRDIV:3 // at 0: PLL External Reference Divider
  }

//---  Register C6: MCG Control 6 Register
  C6 @offset 0x5 $u8 {
    LOLIE0 // at 7: Loss of Lock Interrrupt Enable
    PLLS // at 6: PLL Select
    CME0 // at 5: Clock Monitor Enable
    VDIV:5 // at 0: VCO Divider
  }

//---  Register S: MCG Status Register
  S @offset 0x6 $u8 {
    LOLS0 // at 7: Loss of Lock Status
    LOCK0 // at 6: Lock Status
    PLLST // at 5: PLL Select Status
    IREFST // at 4: Internal Reference Status
    CLKST:2 // at 2: Clock Mode Status
    OSCINIT0 // at 1: OSC Initialization
    IRCST // at 0: Internal Reference Clock Status
  }

//---  Register SC: MCG Status and Control Register
  SC @offset 0x8 $u8 {
    ATME // at 7: Automatic Trim Machine Enable
    ATMS // at 6: Automatic Trim Machine Select
    ATMF // at 5: Automatic Trim Machine Fail Flag
    FLTPRSRV // at 4: FLL Filter Preserve Enable
    FCRDIV:3 // at 1: Fast Clock Internal Reference Divider
    LOCS0 // at 0: OSC0 Loss of Clock Status
  }

//---  Register ATCVH: MCG Auto Trim Compare Value High Register
  ATCVH @offset 0xa $u8 {
    ATCVH:8 // at 0: ATM Compare Value High
  }

//---  Register ATCVL: MCG Auto Trim Compare Value Low Register
  ATCVL @offset 0xb $u8 {
    ATCVL:8 // at 0: ATM Compare Value Low
  }

//---  Register C7: MCG Control 7 Register
  C7 @offset 0xc $u8 {
    6
    OSCSEL:2 // at 0: MCG OSC Clock Select
  }

//---  Register C8: MCG Control 8 Register
  C8 @offset 0xd $u8 {
    LOCRE1 // at 7: Loss of Clock Reset Enable
    LOLRE // at 6: PLL Loss of Lock Reset Enable
    CME1 // at 5: Clock Monitor Enable1
    4
    LOCS1 // at 0: RTC Loss of Clock Status
  }

//---  Register C9: MCG Control 9 Register
  C9 @offset 0xe $u8 {
    2
    PLL_CME // at 5: MCG External PLL Clock Monitor Enable
    PLL_LOCRE // at 4: MCG External PLL Loss of Clock Reset Enable
    3
    EXT_PLL_LOCS // at 0: External PLL Loss of Clock Status
  }

//---  Register C11: MCG Control 11 Register
  C11 @offset 0x10 $u8 {
    3
    PLLCS // at 4: PLL Clock Select
    4
  }

//---  Register S2: MCG Status 2 Register
  S2 @offset 0x12 @ro $u8 {
    3
    PLLCST // at 4: PLL Clock Select Status
    4
  }

}

//--- Enumerated values for register C1, field IREFSTEN
  let MCG_C1_IREFSTEN_Internal_0 $bool = no // Internal reference clock is disabled in Stop mode.
  let MCG_C1_IREFSTEN_Internal_1 $bool = yes // Internal reference clock is enabled in Stop mode if IRCLKEN is set or if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.

//--- Enumerated values for register C1, field IRCLKEN
  let MCG_C1_IRCLKEN_MCGIRCLK_0 $bool = no // MCGIRCLK inactive.
  let MCG_C1_IRCLKEN_MCGIRCLK_1 $bool = yes // MCGIRCLK active.

//--- Enumerated values for register C1, field IREFS
  let MCG_C1_IREFS_External_0 $bool = no // External reference clock is selected.
  let MCG_C1_IREFS_The_1 $bool = yes // The slow internal reference clock is selected.

//--- Enumerated values for register C1, field FRDIV
  let MCG_C1_FRDIV_If_000 $u3 = 0 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE values, Divide Factor is 32.
  let MCG_C1_FRDIV_If_001 $u3 = 1 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE values, Divide Factor is 64.
  let MCG_C1_FRDIV_If_010 $u3 = 2 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE values, Divide Factor is 128.
  let MCG_C1_FRDIV_If_011 $u3 = 3 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE values, Divide Factor is 256.
  let MCG_C1_FRDIV_If_100 $u3 = 4 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE values, Divide Factor is 512.
  let MCG_C1_FRDIV_If_101 $u3 = 5 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE values, Divide Factor is 1024.
  let MCG_C1_FRDIV_If_110 $u3 = 6 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE values, Divide Factor is 1280 .
  let MCG_C1_FRDIV_If_111 $u3 = 7 // If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other RANGE values, Divide Factor is 1536 .

//--- Enumerated values for register C1, field CLKS
  let MCG_C1_CLKS_Encoding_00 $u2 = 0 // Encoding 0 - Output of FLL or PLLCS is selected (depends on PLLS control bit).
  let MCG_C1_CLKS_Encoding_01 $u2 = 1 // Encoding 1 - Internal reference clock is selected.
  let MCG_C1_CLKS_Encoding_10 $u2 = 2 // Encoding 2 - External reference clock is selected.
  let MCG_C1_CLKS_Encoding_11 $u2 = 3 // Encoding 3 - Reserved.

//--- Enumerated values for register C2, field IRCS
  let MCG_C2_IRCS_Slow_0 $bool = no // Slow internal reference clock selected.
  let MCG_C2_IRCS_Fast_1 $bool = yes // Fast internal reference clock selected.

//--- Enumerated values for register C2, field LP
  let MCG_C2_LP_FLL_0 $bool = no // FLL or PLL is not disabled in bypass modes.
  let MCG_C2_LP_FLL_1 $bool = yes // FLL or PLL is disabled in bypass modes (lower power)

//--- Enumerated values for register C2, field EREFS
  let MCG_C2_EREFS_External_0 $bool = no // External reference clock requested.
  let MCG_C2_EREFS_Oscillator_1 $bool = yes // Oscillator requested.

//--- Enumerated values for register C2, field HGO
  let MCG_C2_HGO_Configure_0 $bool = no // Configure crystal oscillator for low-power operation.
  let MCG_C2_HGO_Configure_1 $bool = yes // Configure crystal oscillator for high-gain operation.

//--- Enumerated values for register C2, field RANGE
  let MCG_C2_RANGE_Encoding_00 $u2 = 0 // Encoding 0 - Low frequency range selected for the crystal oscillator .
  let MCG_C2_RANGE_Encoding_01 $u2 = 1 // Encoding 1 - High frequency range selected for the crystal oscillator .
  let MCG_C2_RANGE_Encoding_1X $u2 = 2 // Encoding 2 - Very high frequency range selected for the crystal oscillator .

//--- Enumerated values for register C2, field LOCRE0
  let MCG_C2_LOCRE0_Interrupt_0 $bool = no // Interrupt request is generated on a loss of OSC0 external reference clock.
  let MCG_C2_LOCRE0_Generate_1 $bool = yes // Generate a reset request on a loss of OSC0 external reference clock.

//--- Enumerated values for register C4, field DRST_DRS
  let MCG_C4_DRST_DRS_Encoding_00 $u2 = 0 // Encoding 0 - Low range (reset default).
  let MCG_C4_DRST_DRS_Encoding_01 $u2 = 1 // Encoding 1 - Mid range.
  let MCG_C4_DRST_DRS_Encoding_10 $u2 = 2 // Encoding 2 - Mid-high range.
  let MCG_C4_DRST_DRS_Encoding_11 $u2 = 3 // Encoding 3 - High range.

//--- Enumerated values for register C4, field DMX32
  let MCG_C4_DMX32_DCO_0 $bool = no // DCO has a default range of 25%.
  let MCG_C4_DMX32_DCO_1 $bool = yes // DCO is fine-tuned for maximum frequency with 32.768 kHz reference.

//--- Enumerated values for register C5, field PRDIV
  let MCG_C5_PRDIV_Divide_0 $u3 = 0 // Divide Factor is 1
  let MCG_C5_PRDIV_Divide_1 $u3 = 1 // Divide Factor is 2
  let MCG_C5_PRDIV_Divide_2 $u3 = 2 // Divide Factor is 3
  let MCG_C5_PRDIV_Divide_3 $u3 = 3 // Divide Factor is 4
  let MCG_C5_PRDIV_Divide_4 $u3 = 4 // Divide Factor is 5
  let MCG_C5_PRDIV_Divide_5 $u3 = 5 // Divide Factor is 6
  let MCG_C5_PRDIV_Divide_6 $u3 = 6 // Divide Factor is 7
  let MCG_C5_PRDIV_Divide_7 $u3 = 7 // Divide Factor is 8

//--- Enumerated values for register C5, field PLLSTEN
  let MCG_C5_PLLSTEN_MCGPLLCLK_0 $bool = no // MCGPLLCLK and MCGPLLCLK2X are disabled in any of the Stop modes.
  let MCG_C5_PLLSTEN_MCGPLLCLK_1 $bool = yes // MCGPLLCLK and MCGPLLCLK2X are enabled if system is in Normal Stop mode.

//--- Enumerated values for register C5, field PLLCLKEN
  let MCG_C5_PLLCLKEN_MCGPLLCLK_0 $bool = no // MCGPLLCLK is inactive.
  let MCG_C5_PLLCLKEN_MCGPLLCLK_1 $bool = yes // MCGPLLCLK is active.

//--- Enumerated values for register C6, field VDIV
  let MCG_C6_VDIV_Multiply_0 $u5 = 0 // Multiply Factor is 16
  let MCG_C6_VDIV_Multiply_1 $u5 = 1 // Multiply Factor is 17
  let MCG_C6_VDIV_Multiply_2 $u5 = 2 // Multiply Factor is 18
  let MCG_C6_VDIV_Multiply_3 $u5 = 3 // Multiply Factor is 19
  let MCG_C6_VDIV_Multiply_4 $u5 = 4 // Multiply Factor is 20
  let MCG_C6_VDIV_Multiply_5 $u5 = 5 // Multiply Factor is 21
  let MCG_C6_VDIV_Multiply_6 $u5 = 6 // Multiply Factor is 22
  let MCG_C6_VDIV_Multiply_7 $u5 = 7 // Multiply Factor is 23
  let MCG_C6_VDIV_Multiply_8 $u5 = 8 // Multiply Factor is 24
  let MCG_C6_VDIV_Multiply_9 $u5 = 9 // Multiply Factor is 25
  let MCG_C6_VDIV_Multiply_10 $u5 = 10 // Multiply Factor is 26
  let MCG_C6_VDIV_Multiply_11 $u5 = 11 // Multiply Factor is 27
  let MCG_C6_VDIV_Multiply_12 $u5 = 12 // Multiply Factor is 28
  let MCG_C6_VDIV_Multiply_13 $u5 = 13 // Multiply Factor is 29
  let MCG_C6_VDIV_Multiply_14 $u5 = 14 // Multiply Factor is 30
  let MCG_C6_VDIV_Multiply_15 $u5 = 15 // Multiply Factor is 31
  let MCG_C6_VDIV_Multiply_16 $u5 = 16 // Multiply Factor is 32
  let MCG_C6_VDIV_Multiply_17 $u5 = 17 // Multiply Factor is 33
  let MCG_C6_VDIV_Multiply_18 $u5 = 18 // Multiply Factor is 34
  let MCG_C6_VDIV_Multiply_19 $u5 = 19 // Multiply Factor is 35
  let MCG_C6_VDIV_Multiply_20 $u5 = 20 // Multiply Factor is 36
  let MCG_C6_VDIV_Multiply_21 $u5 = 21 // Multiply Factor is 37
  let MCG_C6_VDIV_Multiply_22 $u5 = 22 // Multiply Factor is 38
  let MCG_C6_VDIV_Multiply_23 $u5 = 23 // Multiply Factor is 39
  let MCG_C6_VDIV_Multiply_24 $u5 = 24 // Multiply Factor is 40
  let MCG_C6_VDIV_Multiply_25 $u5 = 25 // Multiply Factor is 41
  let MCG_C6_VDIV_Multiply_26 $u5 = 26 // Multiply Factor is 42
  let MCG_C6_VDIV_Multiply_27 $u5 = 27 // Multiply Factor is 43
  let MCG_C6_VDIV_Multiply_28 $u5 = 28 // Multiply Factor is 44
  let MCG_C6_VDIV_Multiply_29 $u5 = 29 // Multiply Factor is 45
  let MCG_C6_VDIV_Multiply_30 $u5 = 30 // Multiply Factor is 46
  let MCG_C6_VDIV_Multiply_31 $u5 = 31 // Multiply Factor is 47

//--- Enumerated values for register C6, field CME0
  let MCG_C6_CME0_External_0 $bool = no // External clock monitor is disabled for OSC0.
  let MCG_C6_CME0_External_1 $bool = yes // External clock monitor is enabled for OSC0.

//--- Enumerated values for register C6, field PLLS
  let MCG_C6_PLLS_FLL_0 $bool = no // FLL is selected.
  let MCG_C6_PLLS_PLLCS_1 $bool = yes // PLLCS output clock is selected (PRDIV0 bits of PLL in the C5 register need to be programmed to the correct divider to generate a PLL reference clock in the range specified in the data sheet (fpll_ref) prior to setting the PLLS bit).

//--- Enumerated values for register C6, field LOLIE0
  let MCG_C6_LOLIE0_No_0 $bool = no // No interrupt request is generated on loss of lock.
  let MCG_C6_LOLIE0_Generate_1 $bool = yes // Generate an interrupt request on loss of lock.

//--- Enumerated values for register S, field IRCST
  let MCG_S_IRCST_Source_0 $bool = no // Source of internal reference clock is the slow clock (32 kHz IRC).
  let MCG_S_IRCST_Source_1 $bool = yes // Source of internal reference clock is the fast clock (4 MHz IRC).

//--- Enumerated values for register S, field CLKST
  let MCG_S_CLKST_Encoding_00 $u2 = 0 // Encoding 0 - Output of the FLL is selected (reset default).
  let MCG_S_CLKST_Encoding_01 $u2 = 1 // Encoding 1 - Internal reference clock is selected.
  let MCG_S_CLKST_Encoding_10 $u2 = 2 // Encoding 2 - External reference clock is selected.
  let MCG_S_CLKST_Encoding_11 $u2 = 3 // Encoding 3 - Output of the PLL is selected.

//--- Enumerated values for register S, field IREFST
  let MCG_S_IREFST_Source_0 $bool = no // Source of FLL reference clock is the external reference clock.
  let MCG_S_IREFST_Source_1 $bool = yes // Source of FLL reference clock is the internal reference clock.

//--- Enumerated values for register S, field PLLST
  let MCG_S_PLLST_Source_0 $bool = no // Source of PLLS clock is FLL clock.
  let MCG_S_PLLST_Source_1 $bool = yes // Source of PLLS clock is PLLCS output clock.

//--- Enumerated values for register S, field LOCK0
  let MCG_S_LOCK0_PLL_0 $bool = no // PLL is currently unlocked.
  let MCG_S_LOCK0_PLL_1 $bool = yes // PLL is currently locked.

//--- Enumerated values for register S, field LOLS0
  let MCG_S_LOLS0_PLL_0 $bool = no // PLL has not lost lock since LOLS 0 was last cleared.
  let MCG_S_LOLS0_PLL_1 $bool = yes // PLL has lost lock since LOLS 0 was last cleared.

//--- Enumerated values for register SC, field LOCS0
  let MCG_SC_LOCS0_Loss_0 $bool = no // Loss of OSC0 has not occurred.
  let MCG_SC_LOCS0_Loss_1 $bool = yes // Loss of OSC0 has occurred.

//--- Enumerated values for register SC, field FCRDIV
  let MCG_SC_FCRDIV_Divide_000 $u3 = 0 // Divide Factor is 1
  let MCG_SC_FCRDIV_Divide_001 $u3 = 1 // Divide Factor is 2.
  let MCG_SC_FCRDIV_Divide_010 $u3 = 2 // Divide Factor is 4.
  let MCG_SC_FCRDIV_Divide_011 $u3 = 3 // Divide Factor is 8.
  let MCG_SC_FCRDIV_Divide_100 $u3 = 4 // Divide Factor is 16
  let MCG_SC_FCRDIV_Divide_101 $u3 = 5 // Divide Factor is 32
  let MCG_SC_FCRDIV_Divide_110 $u3 = 6 // Divide Factor is 64
  let MCG_SC_FCRDIV_Divide_111 $u3 = 7 // Divide Factor is 128.

//--- Enumerated values for register SC, field FLTPRSRV
  let MCG_SC_FLTPRSRV_FLL_0 $bool = no // FLL filter and FLL frequency will reset on changes to currect clock mode.
  let MCG_SC_FLTPRSRV_Fll_1 $bool = yes // Fll filter and FLL frequency retain their previous values during new clock mode change.

//--- Enumerated values for register SC, field ATMF
  let MCG_SC_ATMF_Automatic_0 $bool = no // Automatic Trim Machine completed normally.
  let MCG_SC_ATMF_Automatic_1 $bool = yes // Automatic Trim Machine failed.

//--- Enumerated values for register SC, field ATMS
  let MCG_SC_ATMS_32_0 $bool = no // 32 kHz Internal Reference Clock selected.
  let MCG_SC_ATMS_4_1 $bool = yes // 4 MHz Internal Reference Clock selected.

//--- Enumerated values for register SC, field ATME
  let MCG_SC_ATME_Auto_0 $bool = no // Auto Trim Machine disabled.
  let MCG_SC_ATME_Auto_1 $bool = yes // Auto Trim Machine enabled.

//--- Enumerated values for register C7, field OSCSEL
  let MCG_C7_OSCSEL_Selects_00 $u2 = 0 // Selects Oscillator (OSCCLK0).
  let MCG_C7_OSCSEL_Selects_01 $u2 = 1 // Selects 32 kHz RTC Oscillator.
  let MCG_C7_OSCSEL_Selects_10 $u2 = 2 // Selects Oscillator (OSCCLK1).

//--- Enumerated values for register C8, field LOCS1
  let MCG_C8_LOCS1_Loss_0 $bool = no // Loss of RTC has not occur.
  let MCG_C8_LOCS1_Loss_1 $bool = yes // Loss of RTC has occur

//--- Enumerated values for register C8, field CME1
  let MCG_C8_CME1_External_0 $bool = no // External clock monitor is disabled for RTC clock.
  let MCG_C8_CME1_External_1 $bool = yes // External clock monitor is enabled for RTC clock.

//--- Enumerated values for register C8, field LOLRE
  let MCG_C8_LOLRE_Interrupt_0 $bool = no // Interrupt request is generated on a PLL loss of lock indication. The PLL loss of lock interrupt enable bit must also be set to generate the interrupt request.
  let MCG_C8_LOLRE_Generate_1 $bool = yes // Generate a reset request on a PLL loss of lock indication.

//--- Enumerated values for register C8, field LOCRE1
  let MCG_C8_LOCRE1_Interrupt_0 $bool = no // Interrupt request is generated on a loss of RTC external reference clock.
  let MCG_C8_LOCRE1_Generate_1 $bool = yes // Generate a reset request on a loss of RTC external reference clock

//--- Enumerated values for register C9, field EXT_PLL_LOCS
  let MCG_C9_EXT_PLL_LOCS_Loss_0 $bool = no // Loss of MCG EXT_PLL has not occurred.
  let MCG_C9_EXT_PLL_LOCS_Loss_1 $bool = yes // Loss of MCG EXT_PLL has occurred.

//--- Enumerated values for register C9, field PLL_LOCRE
  let MCG_C9_PLL_LOCRE_Interrupt_0 $bool = no // Interrupt request is generated on a invalid or loss of the MCG external PLL clock.
  let MCG_C9_PLL_LOCRE_Generates_1 $bool = yes // Generates a system reset request on a invalid or loss of the MCG external PLL clock.

//--- Enumerated values for register C9, field PLL_CME
  let MCG_C9_PLL_CME_External_0 $bool = no // External clock monitor is disabled for EXT_PLL clock.
  let MCG_C9_PLL_CME_External_1 $bool = yes // External clock monitor is enabled for EXT_PLL clock.

//--- Enumerated values for register C11, field PLLCS
  let MCG_C11_PLLCS_PLL0_0 $bool = no // PLL0 output clock is selected.
  let MCG_C11_PLLCS_External_1 $bool = yes // External PLL clock is selected.

//--- Enumerated values for register S2, field PLLCST
  let MCG_S2_PLLCST_Source_0 $bool = no // Source of PLLCS is PLL clock.
  let MCG_S2_PLLCST_Source_1 $bool = yes // Source of PLLCS is EXT_PLL clock.

//------------------------------------------------------------------------------
// Peripheral MCM: Core Platform Miscellaneous Control Module
//------------------------------------------------------------------------------

registers ©MCM @at 0xe0080000 {
//---  Register PLASC: Crossbar Switch (AXBS) Slave Configuration
  PLASC @offset 0x8 @ro $u16 {
    8
    ASC:8 // at 0: Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
  }

//---  Register PLAMC: Crossbar Switch (AXBS) Master Configuration
  PLAMC @offset 0xa @ro $u16 {
    8
    AMC:8 // at 0: Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
  }

//---  Register CR: Control Register
  CR @offset 0xc $u32 {
    1
    SRAMLWP // at 30: SRAM_L Write Protect
    SRAMLAP:2 // at 28: SRAM_L arbitration priority
    1
    SRAMUWP // at 26: SRAM_U write protect
    SRAMUAP:2 // at 24: SRAM_U arbitration priority
    24
  }

//---  Register ISCR: Interrupt Status Register
  ISCR @offset 0x10 $u32 {
    FIDCE // at 31: FPU input denormal interrupt enable
    2
    FIXCE // at 28: FPU inexact interrupt enable
    FUFCE // at 27: FPU underflow interrupt enable
    FOFCE // at 26: FPU overflow interrupt enable
    FDZCE // at 25: FPU divide-by-zero interrupt enable
    FIOCE // at 24: FPU invalid operation interrupt enable
    8
    FIDC // at 15: FPU input denormal interrupt status
    2
    FIXC // at 12: FPU inexact interrupt status
    FUFC // at 11: FPU underflow interrupt status
    FOFC // at 10: FPU overflow interrupt status
    FDZC // at 9: FPU divide-by-zero interrupt status
    FIOC // at 8: FPU invalid operation interrupt status
    4
    DHREQ // at 3: Debug Halt Request Indicator
    NMI // at 2: Non-maskable Interrupt Pending
    IRQ // at 1: Normal Interrupt Pending
    1
  }

//---  Register ETBCC: ETB Counter Control register
  ETBCC @offset 0x14 $u32 {
    26
    ITDIS // at 5: ITM-To-TPIU Disable
    ETDIS // at 4: ETM-To-TPIU Disable
    RLRQ // at 3: Reload Request
    RSPT:2 // at 1: Response Type
    CNTEN // at 0: Counter Enable
  }

//---  Register ETBRL: ETB Reload register
  ETBRL @offset 0x18 $u32 {
    21
    RELOAD:11 // at 0: Byte Count Reload Value
  }

//---  Register ETBCNT: ETB Counter Value register
  ETBCNT @offset 0x1c @ro $u32 {
    21
    COUNTER:11 // at 0: Byte Count Counter Value
  }

//---  Register FADR: Fault address register
  FADR @offset 0x20 @ro $u32 {
    ADDRESS:32 // at 0: Fault address
  }

//---  Register FATR: Fault attributes register
  FATR @offset 0x24 @ro $u32 {
    BEOVR // at 31: Bus error overrun
    19
    BEMN:4 // at 8: Bus error master number
    BEWT // at 7: Bus error write
    1
    BESZ:2 // at 4: Bus error size
    2
    BEMD // at 1: Bus error privilege level
    BEDA // at 0: Bus error access type
  }

//---  Register FDR: Fault data register
  FDR @offset 0x28 @ro $u32 {
    DATA:32 // at 0: Fault data
  }

//---  Register PID: Process ID register
  PID @offset 0x30 $u32 {
    24
    PID:8 // at 0: M0_PID And M1_PID For MPU
  }

//---  Register CPO: Compute Operation Control Register
  CPO @offset 0x40 $u32 {
    29
    CPOWOI // at 2: Compute Operation wakeup on interrupt
    CPOACK // at 1: Compute Operation acknowledge
    CPOREQ // at 0: Compute Operation request
  }

}

//--- Enumerated values for register PLASC, field ASC
  let MCM_PLASC_ASC_A_0 $u8 = 0 // A bus slave connection to AXBS input port n is absent
  let MCM_PLASC_ASC_A_1 $u8 = 1 // A bus slave connection to AXBS input port n is present

//--- Enumerated values for register PLAMC, field AMC
  let MCM_PLAMC_AMC_A_0 $u8 = 0 // A bus master connection to AXBS input port n is absent
  let MCM_PLAMC_AMC_A_1 $u8 = 1 // A bus master connection to AXBS input port n is present

//--- Enumerated values for register CR, field SRAMUAP
  let MCM_CR_SRAMUAP_Round_00 $u2 = 0 // Round robin
  let MCM_CR_SRAMUAP_Special_01 $u2 = 1 // Special round robin (favors SRAM backoor accesses over the processor)
  let MCM_CR_SRAMUAP_Fixed_10 $u2 = 2 // Fixed priority. Processor has highest, backdoor has lowest
  let MCM_CR_SRAMUAP_Fixed_11 $u2 = 3 // Fixed priority. Backdoor has highest, processor has lowest

//--- Enumerated values for register CR, field SRAMLAP
  let MCM_CR_SRAMLAP_Round_00 $u2 = 0 // Round robin
  let MCM_CR_SRAMLAP_Special_01 $u2 = 1 // Special round robin (favors SRAM backoor accesses over the processor)
  let MCM_CR_SRAMLAP_Fixed_10 $u2 = 2 // Fixed priority. Processor has highest, backdoor has lowest
  let MCM_CR_SRAMLAP_Fixed_11 $u2 = 3 // Fixed priority. Backdoor has highest, processor has lowest

//--- Enumerated values for register ISCR, field IRQ
  let MCM_ISCR_IRQ_No_0 $bool = no // No pending interrupt
  let MCM_ISCR_IRQ_Due_1 $bool = yes // Due to the ETB counter expiring, a normal interrupt is pending

//--- Enumerated values for register ISCR, field NMI
  let MCM_ISCR_NMI_No_0 $bool = no // No pending NMI
  let MCM_ISCR_NMI_Due_1 $bool = yes // Due to the ETB counter expiring, an NMI is pending

//--- Enumerated values for register ISCR, field DHREQ
  let MCM_ISCR_DHREQ_No_0 $bool = no // No debug halt request
  let MCM_ISCR_DHREQ_Debug_1 $bool = yes // Debug halt request initiated

//--- Enumerated values for register ISCR, field FIOC
  let MCM_ISCR_FIOC_No_0 $bool = no // No interrupt
  let MCM_ISCR_FIOC_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register ISCR, field FDZC
  let MCM_ISCR_FDZC_No_0 $bool = no // No interrupt
  let MCM_ISCR_FDZC_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register ISCR, field FOFC
  let MCM_ISCR_FOFC_No_0 $bool = no // No interrupt
  let MCM_ISCR_FOFC_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register ISCR, field FUFC
  let MCM_ISCR_FUFC_No_0 $bool = no // No interrupt
  let MCM_ISCR_FUFC_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register ISCR, field FIXC
  let MCM_ISCR_FIXC_No_0 $bool = no // No interrupt
  let MCM_ISCR_FIXC_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register ISCR, field FIDC
  let MCM_ISCR_FIDC_No_0 $bool = no // No interrupt
  let MCM_ISCR_FIDC_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register ISCR, field FIOCE
  let MCM_ISCR_FIOCE_Disable_0 $bool = no // Disable interrupt
  let MCM_ISCR_FIOCE_Enable_1 $bool = yes // Enable interrupt

//--- Enumerated values for register ISCR, field FDZCE
  let MCM_ISCR_FDZCE_Disable_0 $bool = no // Disable interrupt
  let MCM_ISCR_FDZCE_Enable_1 $bool = yes // Enable interrupt

//--- Enumerated values for register ISCR, field FOFCE
  let MCM_ISCR_FOFCE_Disable_0 $bool = no // Disable interrupt
  let MCM_ISCR_FOFCE_Enable_1 $bool = yes // Enable interrupt

//--- Enumerated values for register ISCR, field FUFCE
  let MCM_ISCR_FUFCE_Disable_0 $bool = no // Disable interrupt
  let MCM_ISCR_FUFCE_Enable_1 $bool = yes // Enable interrupt

//--- Enumerated values for register ISCR, field FIXCE
  let MCM_ISCR_FIXCE_Disable_0 $bool = no // Disable interrupt
  let MCM_ISCR_FIXCE_Enable_1 $bool = yes // Enable interrupt

//--- Enumerated values for register ISCR, field FIDCE
  let MCM_ISCR_FIDCE_Disable_0 $bool = no // Disable interrupt
  let MCM_ISCR_FIDCE_Enable_1 $bool = yes // Enable interrupt

//--- Enumerated values for register ETBCC, field CNTEN
  let MCM_ETBCC_CNTEN_ETB_0 $bool = no // ETB counter disabled
  let MCM_ETBCC_CNTEN_ETB_1 $bool = yes // ETB counter enabled

//--- Enumerated values for register ETBCC, field RSPT
  let MCM_ETBCC_RSPT_No_00 $u2 = 0 // No response when the ETB count expires
  let MCM_ETBCC_RSPT_Generate_01 $u2 = 1 // Generate a normal interrupt when the ETB count expires
  let MCM_ETBCC_RSPT_Generate_10 $u2 = 2 // Generate an NMI when the ETB count expires
  let MCM_ETBCC_RSPT_Generate_11 $u2 = 3 // Generate a debug halt when the ETB count expires

//--- Enumerated values for register ETBCC, field RLRQ
  let MCM_ETBCC_RLRQ_No_0 $bool = no // No effect
  let MCM_ETBCC_RLRQ_Clears_1 $bool = yes // Clears pending debug halt, NMI, or IRQ interrupt requests

//--- Enumerated values for register ETBCC, field ETDIS
  let MCM_ETBCC_ETDIS_ETM_to_TPIU_0 $bool = no // ETM-to-TPIU trace path enabled
  let MCM_ETBCC_ETDIS_ETM_to_TPIU_1 $bool = yes // ETM-to-TPIU trace path disabled

//--- Enumerated values for register ETBCC, field ITDIS
  let MCM_ETBCC_ITDIS_ITM_to_TPIU_0 $bool = no // ITM-to-TPIU trace path enabled
  let MCM_ETBCC_ITDIS_ITM_to_TPIU_1 $bool = yes // ITM-to-TPIU trace path disabled

//--- Enumerated values for register FATR, field BEDA
  let MCM_FATR_BEDA_Instruction_0 $bool = no // Instruction
  let MCM_FATR_BEDA_Data_1 $bool = yes // Data

//--- Enumerated values for register FATR, field BEMD
  let MCM_FATR_BEMD_User_0 $bool = no // User mode
  let MCM_FATR_BEMD_Supervisor_privileged_1 $bool = yes // Supervisor/privileged mode

//--- Enumerated values for register FATR, field BESZ
  let MCM_FATR_BESZ_8_bit_00 $u2 = 0 // 8-bit access
  let MCM_FATR_BESZ_16_bit_01 $u2 = 1 // 16-bit access
  let MCM_FATR_BESZ_32_bit_10 $u2 = 2 // 32-bit access

//--- Enumerated values for register FATR, field BEWT
  let MCM_FATR_BEWT_Read_0 $bool = no // Read access
  let MCM_FATR_BEWT_Write_1 $bool = yes // Write access

//--- Enumerated values for register FATR, field BEOVR
  let MCM_FATR_BEOVR_No_0 $bool = no // No bus error overrun
  let MCM_FATR_BEOVR_Bus_1 $bool = yes // Bus error overrun occurred. The FADR and FDR registers and the other FATR bits are not updated to reflect this new bus error.

//--- Enumerated values for register CPO, field CPOREQ
  let MCM_CPO_CPOREQ_Request_0 $bool = no // Request is cleared.
  let MCM_CPO_CPOREQ_Request_1 $bool = yes // Request Compute Operation.

//--- Enumerated values for register CPO, field CPOACK
  let MCM_CPO_CPOACK_Compute_0 $bool = no // Compute operation entry has not completed or compute operation exit has completed.
  let MCM_CPO_CPOACK_Compute_1 $bool = yes // Compute operation entry has completed or compute operation exit has not completed.

//--- Enumerated values for register CPO, field CPOWOI
  let MCM_CPO_CPOWOI_No_0 $bool = no // No effect.
  let MCM_CPO_CPOWOI_When_1 $bool = yes // When set, the CPOREQ is cleared on any interrupt or exception vector fetch.

//------------------------------------------------------------------------------
// Peripheral MPU: Memory protection unit
//------------------------------------------------------------------------------

registers ©MPU @at 0x4000d000 {
//---  Register CESR: Control/Error Status Register
  CESR @offset 0x0 $u32 {
    SPERR:5 // at 27: Slave Port n Error
    7
    HRL:4 // at 16: Hardware Revision Level
    NSP:4 // at 12: Number Of Slave Ports
    NRGD:4 // at 8: Number Of Region Descriptors
    7
    VLD // at 0: Valid
  }

//---  Registers EAR(0,1,2,3,4): Error Address Register, slave port n
  EAR [5 @offset 0x10 @inc 0x8]
  EAR0 @offset 0x10
  EAR1 @offset 0x18
  EAR2 @offset 0x20
  EAR3 @offset 0x28
  EAR4 @offset 0x30 @ro $u32 {
    EADDR:32 // at 0: Error Address
  }

//---  Registers EDR(0,1,2,3,4): Error Detail Register, slave port n
  EDR [5 @offset 0x14 @inc 0x8]
  EDR0 @offset 0x14
  EDR1 @offset 0x1c
  EDR2 @offset 0x24
  EDR3 @offset 0x2c
  EDR4 @offset 0x34 @ro $u32 {
    EACD:16 // at 16: Error Access Control Detail
    EPID:8 // at 8: Error Process Identification
    EMN:4 // at 4: Error Master Number
    EATTR:3 // at 1: Error Attributes
    ERW // at 0: Error Read/Write
  }

//---  Registers RGD_WORD0(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 0
  RGD_WORD0 [12 @offset 0x400 @inc 0x10]
  RGD0_WORD0 @offset 0x400
  RGD1_WORD0 @offset 0x410
  RGD2_WORD0 @offset 0x420
  RGD3_WORD0 @offset 0x430
  RGD4_WORD0 @offset 0x440
  RGD5_WORD0 @offset 0x450
  RGD6_WORD0 @offset 0x460
  RGD7_WORD0 @offset 0x470
  RGD8_WORD0 @offset 0x480
  RGD9_WORD0 @offset 0x490
  RGD10_WORD0 @offset 0x4a0
  RGD11_WORD0 @offset 0x4b0 $u32 {
    SRTADDR:27 // at 5: Start Address
    5
  }

//---  Registers RGD_WORD1(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 1
  RGD_WORD1 [12 @offset 0x404 @inc 0x10]
  RGD0_WORD1 @offset 0x404
  RGD1_WORD1 @offset 0x414
  RGD2_WORD1 @offset 0x424
  RGD3_WORD1 @offset 0x434
  RGD4_WORD1 @offset 0x444
  RGD5_WORD1 @offset 0x454
  RGD6_WORD1 @offset 0x464
  RGD7_WORD1 @offset 0x474
  RGD8_WORD1 @offset 0x484
  RGD9_WORD1 @offset 0x494
  RGD10_WORD1 @offset 0x4a4
  RGD11_WORD1 @offset 0x4b4 $u32 {
    ENDADDR:27 // at 5: End Address
    5
  }

//---  Registers RGD_WORD2(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 2
  RGD_WORD2 [12 @offset 0x408 @inc 0x10]
  RGD0_WORD2 @offset 0x408
  RGD1_WORD2 @offset 0x418
  RGD2_WORD2 @offset 0x428
  RGD3_WORD2 @offset 0x438
  RGD4_WORD2 @offset 0x448
  RGD5_WORD2 @offset 0x458
  RGD6_WORD2 @offset 0x468
  RGD7_WORD2 @offset 0x478
  RGD8_WORD2 @offset 0x488
  RGD9_WORD2 @offset 0x498
  RGD10_WORD2 @offset 0x4a8
  RGD11_WORD2 @offset 0x4b8 $u32 {
    M7RE // at 31: Bus Master 7 Read Enable
    M7WE // at 30: Bus Master 7 Write Enable
    M6RE // at 29: Bus Master 6 Read Enable
    M6WE // at 28: Bus Master 6 Write Enable
    M5RE // at 27: Bus Master 5 Read Enable
    M5WE // at 26: Bus Master 5 Write Enable
    M4RE // at 25: Bus Master 4 Read Enable
    M4WE // at 24: Bus Master 4 Write Enable
    M3PE // at 23: Bus Master 3 Process Identifier Enable
    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control
    M3UM:3 // at 18: Bus Master 3 User Mode Access Control
    M2PE // at 17: Bus Master 2 Process Identifier Enable
    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control
    M2UM:3 // at 12: Bus Master 2 User Mode Access control
    M1PE // at 11: Bus Master 1 Process Identifier enable
    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control
    M1UM:3 // at 6: Bus Master 1 User Mode Access Control
    M0PE // at 5: Bus Master 0 Process Identifier enable
    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control
    M0UM:3 // at 0: Bus Master 0 User Mode Access Control
  }

//---  Registers RGD_WORD3(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor n, Word 3
  RGD_WORD3 [12 @offset 0x40c @inc 0x10]
  RGD0_WORD3 @offset 0x40c
  RGD1_WORD3 @offset 0x41c
  RGD2_WORD3 @offset 0x42c
  RGD3_WORD3 @offset 0x43c
  RGD4_WORD3 @offset 0x44c
  RGD5_WORD3 @offset 0x45c
  RGD6_WORD3 @offset 0x46c
  RGD7_WORD3 @offset 0x47c
  RGD8_WORD3 @offset 0x48c
  RGD9_WORD3 @offset 0x49c
  RGD10_WORD3 @offset 0x4ac
  RGD11_WORD3 @offset 0x4bc $u32 {
    PID:8 // at 24: Process Identifier
    PIDMASK:8 // at 16: Process Identifier Mask
    15
    VLD // at 0: Valid
  }

//---  Registers RGDAAC(0,1,2,3,4,5,6,7,8,9,10,11): Region Descriptor Alternate Access Control n
  RGDAAC [12 @offset 0x800 @inc 0x4]
  RGDAAC0 @offset 0x800
  RGDAAC1 @offset 0x804
  RGDAAC2 @offset 0x808
  RGDAAC3 @offset 0x80c
  RGDAAC4 @offset 0x810
  RGDAAC5 @offset 0x814
  RGDAAC6 @offset 0x818
  RGDAAC7 @offset 0x81c
  RGDAAC8 @offset 0x820
  RGDAAC9 @offset 0x824
  RGDAAC10 @offset 0x828
  RGDAAC11 @offset 0x82c $u32 {
    M7RE // at 31: Bus Master 7 Read Enable
    M7WE // at 30: Bus Master 7 Write Enable
    M6RE // at 29: Bus Master 6 Read Enable
    M6WE // at 28: Bus Master 6 Write Enable
    M5RE // at 27: Bus Master 5 Read Enable
    M5WE // at 26: Bus Master 5 Write Enable
    M4RE // at 25: Bus Master 4 Read Enable
    M4WE // at 24: Bus Master 4 Write Enable
    M3PE // at 23: Bus Master 3 Process Identifier Enable
    M3SM:2 // at 21: Bus Master 3 Supervisor Mode Access Control
    M3UM:3 // at 18: Bus Master 3 User Mode Access Control
    M2PE // at 17: Bus Master 2 Process Identifier Enable
    M2SM:2 // at 15: Bus Master 2 Supervisor Mode Access Control
    M2UM:3 // at 12: Bus Master 2 User Mode Access Control
    M1PE // at 11: Bus Master 1 Process Identifier Enable
    M1SM:2 // at 9: Bus Master 1 Supervisor Mode Access Control
    M1UM:3 // at 6: Bus Master 1 User Mode Access Control
    M0PE // at 5: Bus Master 0 Process Identifier Enable
    M0SM:2 // at 3: Bus Master 0 Supervisor Mode Access Control
    M0UM:3 // at 0: Bus Master 0 User Mode Access Control
  }

}

//--- Enumerated values for register CESR, field VLD
  let MPU_CESR_VLD_MPU_0 $bool = no // MPU is disabled. All accesses from all bus masters are allowed.
  let MPU_CESR_VLD_MPU_1 $bool = yes // MPU is enabled

//--- Enumerated values for register CESR, field NRGD
  let MPU_CESR_NRGD_8_0000 $u4 = 0 // 8 region descriptors
  let MPU_CESR_NRGD_12_0001 $u4 = 1 // 12 region descriptors
  let MPU_CESR_NRGD_16_0010 $u4 = 2 // 16 region descriptors

//--- Enumerated values for register CESR, field SPERR
  let MPU_CESR_SPERR_No_0 $u5 = 0 // No error has occurred for slave port n.
  let MPU_CESR_SPERR_An_1 $u5 = 1 // An error has occurred for slave port n.

//--- Enumerated values for register EDR%s, field ERW
  let MPU_EDR_ERW_Read_0 $bool = no // Read
  let MPU_EDR_ERW_Write_1 $bool = yes // Write

//--- Enumerated values for register EDR%s, field EATTR
  let MPU_EDR_EATTR_User_000 $u3 = 0 // User mode, instruction access
  let MPU_EDR_EATTR_User_001 $u3 = 1 // User mode, data access
  let MPU_EDR_EATTR_Supervisor_010 $u3 = 2 // Supervisor mode, instruction access
  let MPU_EDR_EATTR_Supervisor_011 $u3 = 3 // Supervisor mode, data access

//--- Enumerated values for register RGD%s_WORD2, field M3UM
  let MPU_RGD_WORD2_M3UM_An_0 $u3 = 0 // An attempted access of that mode may be terminated with an access error (if not allowed by another descriptor) and the access not performed.
  let MPU_RGD_WORD2_M3UM_Allows_1 $u3 = 1 // Allows the given access type to occur

//--- Enumerated values for register RGD%s_WORD2, field M3SM
  let MPU_RGD_WORD2_M3SM_r_w_x__00 $u2 = 0 // r/w/x; read, write and execute allowed
  let MPU_RGD_WORD2_M3SM_r_x__01 $u2 = 1 // r/x; read and execute allowed, but no write
  let MPU_RGD_WORD2_M3SM_r_w__10 $u2 = 2 // r/w; read and write allowed, but no execute
  let MPU_RGD_WORD2_M3SM_Same_11 $u2 = 3 // Same as User mode defined in M3UM

//--- Enumerated values for register RGD%s_WORD2, field M3PE
  let MPU_RGD_WORD2_M3PE_Do_0 $bool = no // Do not include the process identifier in the evaluation
  let MPU_RGD_WORD2_M3PE_Include_1 $bool = yes // Include the process identifier and mask (RGDn_WORD3) in the region hit evaluation

//--- Enumerated values for register RGD%s_WORD2, field M4WE
  let MPU_RGD_WORD2_M4WE_Bus_0 $bool = no // Bus master 4 writes terminate with an access error and the write is not performed
  let MPU_RGD_WORD2_M4WE_Bus_1 $bool = yes // Bus master 4 writes allowed

//--- Enumerated values for register RGD%s_WORD2, field M4RE
  let MPU_RGD_WORD2_M4RE_Bus_0 $bool = no // Bus master 4 reads terminate with an access error and the read is not performed
  let MPU_RGD_WORD2_M4RE_Bus_1 $bool = yes // Bus master 4 reads allowed

//--- Enumerated values for register RGD%s_WORD2, field M5WE
  let MPU_RGD_WORD2_M5WE_Bus_0 $bool = no // Bus master 5 writes terminate with an access error and the write is not performed
  let MPU_RGD_WORD2_M5WE_Bus_1 $bool = yes // Bus master 5 writes allowed

//--- Enumerated values for register RGD%s_WORD2, field M5RE
  let MPU_RGD_WORD2_M5RE_Bus_0 $bool = no // Bus master 5 reads terminate with an access error and the read is not performed
  let MPU_RGD_WORD2_M5RE_Bus_1 $bool = yes // Bus master 5 reads allowed

//--- Enumerated values for register RGD%s_WORD2, field M6WE
  let MPU_RGD_WORD2_M6WE_Bus_0 $bool = no // Bus master 6 writes terminate with an access error and the write is not performed
  let MPU_RGD_WORD2_M6WE_Bus_1 $bool = yes // Bus master 6 writes allowed

//--- Enumerated values for register RGD%s_WORD2, field M6RE
  let MPU_RGD_WORD2_M6RE_Bus_0 $bool = no // Bus master 6 reads terminate with an access error and the read is not performed
  let MPU_RGD_WORD2_M6RE_Bus_1 $bool = yes // Bus master 6 reads allowed

//--- Enumerated values for register RGD%s_WORD2, field M7WE
  let MPU_RGD_WORD2_M7WE_Bus_0 $bool = no // Bus master 7 writes terminate with an access error and the write is not performed
  let MPU_RGD_WORD2_M7WE_Bus_1 $bool = yes // Bus master 7 writes allowed

//--- Enumerated values for register RGD%s_WORD2, field M7RE
  let MPU_RGD_WORD2_M7RE_Bus_0 $bool = no // Bus master 7 reads terminate with an access error and the read is not performed
  let MPU_RGD_WORD2_M7RE_Bus_1 $bool = yes // Bus master 7 reads allowed

//--- Enumerated values for register RGD%s_WORD3, field VLD
  let MPU_RGD_WORD3_VLD_Region_0 $bool = no // Region descriptor is invalid
  let MPU_RGD_WORD3_VLD_Region_1 $bool = yes // Region descriptor is valid

//--- Enumerated values for register RGDAAC%s, field M3UM
  let MPU_RGDAAC_M3UM_An_0 $u3 = 0 // An attempted access of that mode may be terminated with an access error (if not allowed by another descriptor) and the access not performed.
  let MPU_RGDAAC_M3UM_Allows_1 $u3 = 1 // Allows the given access type to occur

//--- Enumerated values for register RGDAAC%s, field M3SM
  let MPU_RGDAAC_M3SM_r_w_x__00 $u2 = 0 // r/w/x; read, write and execute allowed
  let MPU_RGDAAC_M3SM_r_x__01 $u2 = 1 // r/x; read and execute allowed, but no write
  let MPU_RGDAAC_M3SM_r_w__10 $u2 = 2 // r/w; read and write allowed, but no execute
  let MPU_RGDAAC_M3SM_Same_11 $u2 = 3 // Same as User mode defined in M3UM

//--- Enumerated values for register RGDAAC%s, field M3PE
  let MPU_RGDAAC_M3PE_Do_0 $bool = no // Do not include the process identifier in the evaluation
  let MPU_RGDAAC_M3PE_Include_1 $bool = yes // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation

//--- Enumerated values for register RGDAAC%s, field M4WE
  let MPU_RGDAAC_M4WE_Bus_0 $bool = no // Bus master 4 writes terminate with an access error and the write is not performed
  let MPU_RGDAAC_M4WE_Bus_1 $bool = yes // Bus master 4 writes allowed

//--- Enumerated values for register RGDAAC%s, field M4RE
  let MPU_RGDAAC_M4RE_Bus_0 $bool = no // Bus master 4 reads terminate with an access error and the read is not performed
  let MPU_RGDAAC_M4RE_Bus_1 $bool = yes // Bus master 4 reads allowed

//--- Enumerated values for register RGDAAC%s, field M5WE
  let MPU_RGDAAC_M5WE_Bus_0 $bool = no // Bus master 5 writes terminate with an access error and the write is not performed
  let MPU_RGDAAC_M5WE_Bus_1 $bool = yes // Bus master 5 writes allowed

//--- Enumerated values for register RGDAAC%s, field M5RE
  let MPU_RGDAAC_M5RE_Bus_0 $bool = no // Bus master 5 reads terminate with an access error and the read is not performed
  let MPU_RGDAAC_M5RE_Bus_1 $bool = yes // Bus master 5 reads allowed

//--- Enumerated values for register RGDAAC%s, field M6WE
  let MPU_RGDAAC_M6WE_Bus_0 $bool = no // Bus master 6 writes terminate with an access error and the write is not performed
  let MPU_RGDAAC_M6WE_Bus_1 $bool = yes // Bus master 6 writes allowed

//--- Enumerated values for register RGDAAC%s, field M6RE
  let MPU_RGDAAC_M6RE_Bus_0 $bool = no // Bus master 6 reads terminate with an access error and the read is not performed
  let MPU_RGDAAC_M6RE_Bus_1 $bool = yes // Bus master 6 reads allowed

//--- Enumerated values for register RGDAAC%s, field M7WE
  let MPU_RGDAAC_M7WE_Bus_0 $bool = no // Bus master 7 writes terminate with an access error and the write is not performed
  let MPU_RGDAAC_M7WE_Bus_1 $bool = yes // Bus master 7 writes allowed

//--- Enumerated values for register RGDAAC%s, field M7RE
  let MPU_RGDAAC_M7RE_Bus_0 $bool = no // Bus master 7 reads terminate with an access error and the read is not performed
  let MPU_RGDAAC_M7RE_Bus_1 $bool = yes // Bus master 7 reads allowed

//------------------------------------------------------------------------------
// Peripheral OSC: Oscillator
//------------------------------------------------------------------------------

registers ©OSC @at 0x40065000 {
//---  Register CR: OSC Control Register
  CR @offset 0x0 $u8 {
    ERCLKEN // at 7: External Reference Enable
    1
    EREFSTEN // at 5: External Reference Stop Enable
    1
    SC2P // at 3: Oscillator 2 pF Capacitor Load Configure
    SC4P // at 2: Oscillator 4 pF Capacitor Load Configure
    SC8P // at 1: Oscillator 8 pF Capacitor Load Configure
    SC16P // at 0: Oscillator 16 pF Capacitor Load Configure
  }

//---  Register DIV: OSC_DIV
  DIV @offset 0x2 $u8 {
    ERPS:2 // at 6: ERCLK prescaler
    6
  }

}

//--- Enumerated values for register CR, field SC16P
  let OSC_CR_SC16P_Disable_0 $bool = no // Disable the selection.
  let OSC_CR_SC16P_Add_1 $bool = yes // Add 16 pF capacitor to the oscillator load.

//--- Enumerated values for register CR, field SC8P
  let OSC_CR_SC8P_Disable_0 $bool = no // Disable the selection.
  let OSC_CR_SC8P_Add_1 $bool = yes // Add 8 pF capacitor to the oscillator load.

//--- Enumerated values for register CR, field SC4P
  let OSC_CR_SC4P_Disable_0 $bool = no // Disable the selection.
  let OSC_CR_SC4P_Add_1 $bool = yes // Add 4 pF capacitor to the oscillator load.

//--- Enumerated values for register CR, field SC2P
  let OSC_CR_SC2P_Disable_0 $bool = no // Disable the selection.
  let OSC_CR_SC2P_Add_1 $bool = yes // Add 2 pF capacitor to the oscillator load.

//--- Enumerated values for register CR, field EREFSTEN
  let OSC_CR_EREFSTEN_External_0 $bool = no // External reference clock is disabled in Stop mode.
  let OSC_CR_EREFSTEN_External_1 $bool = yes // External reference clock stays enabled in Stop mode if ERCLKEN is set before entering Stop mode.

//--- Enumerated values for register CR, field ERCLKEN
  let OSC_CR_ERCLKEN_External_0 $bool = no // External reference clock is inactive.
  let OSC_CR_ERCLKEN_External_1 $bool = yes // External reference clock is enabled.

//--- Enumerated values for register DIV, field ERPS
  let OSC_DIV_ERPS_The_00 $u2 = 0 // The divisor ratio is 1.
  let OSC_DIV_ERPS_The_01 $u2 = 1 // The divisor ratio is 2.
  let OSC_DIV_ERPS_The_10 $u2 = 2 // The divisor ratio is 4.
  let OSC_DIV_ERPS_The_11 $u2 = 3 // The divisor ratio is 8.

//------------------------------------------------------------------------------
// Peripheral PDB0: Programmable Delay Block
//------------------------------------------------------------------------------

registers ©PDB0 @at 0x40036000 {
//---  Register SC: Status and Control register
  SC @offset 0x0 $u32 {
    12
    LDMOD:2 // at 18: Load Mode Select
    PDBEIE // at 17: PDB Sequence Error Interrupt Enable
    SWTRIG // at 16: Software Trigger
    DMAEN // at 15: DMA Enable
    PRESCALER:3 // at 12: Prescaler Divider Select
    TRGSEL:4 // at 8: Trigger Input Source Select
    PDBEN // at 7: PDB Enable
    PDBIF // at 6: PDB Interrupt Flag
    PDBIE // at 5: PDB Interrupt Enable
    1
    MULT:2 // at 2: Multiplication Factor Select for Prescaler
    CONT // at 1: Continuous Mode Enable
    LDOK // at 0: Load OK
  }

//---  Register MOD: Modulus register
  MOD @offset 0x4 $u32 {
    16
    MOD:16 // at 0: PDB Modulus
  }

//---  Register CNT: Counter register
  CNT @offset 0x8 @ro $u32 {
    16
    CNT:16 // at 0: PDB Counter
  }

//---  Register IDLY: Interrupt Delay register
  IDLY @offset 0xc $u32 {
    16
    IDLY:16 // at 0: PDB Interrupt Delay
  }

//---  Registers CHC1(0,1): Channel n Control register 1
  CHC1 [2 @offset 0x10 @inc 0x28]
  CH0C1 @offset 0x10
  CH1C1 @offset 0x38 $u32 {
    8
    BB:8 // at 16: PDB Channel Pre-Trigger Back-to-Back Operation Enable
    TOS:8 // at 8: PDB Channel Pre-Trigger Output Select
    EN:8 // at 0: PDB Channel Pre-Trigger Enable
  }

//---  Registers CHS(0,1): Channel n Status register
  CHS [2 @offset 0x14 @inc 0x28]
  CH0S @offset 0x14
  CH1S @offset 0x3c $u32 {
    8
    CF:8 // at 16: PDB Channel Flags
    8
    ERR:8 // at 0: PDB Channel Sequence Error Flags
  }

//---  Registers CHDLY0(0,1): Channel n Delay 0 register
  CHDLY0 [2 @offset 0x18 @inc 0x28]
  CH0DLY0 @offset 0x18
  CH1DLY0 @offset 0x40 $u32 {
    16
    DLY:16 // at 0: PDB Channel Delay
  }

//---  Registers CHDLY1(0,1): Channel n Delay 1 register
  CHDLY1 [2 @offset 0x1c @inc 0x28]
  CH0DLY1 @offset 0x1c
  CH1DLY1 @offset 0x44 $u32 {
    16
    DLY:16 // at 0: PDB Channel Delay
  }

//---  Registers DACINTC(0,1): DAC Interval Trigger n Control register
  DACINTC [2 @offset 0x150 @inc 0x8]
  DACINTC0 @offset 0x150
  DACINTC1 @offset 0x158 $u32 {
    30
    EXT // at 1: DAC External Trigger Input Enable
    TOE // at 0: DAC Interval Trigger Enable
  }

//---  Registers DACINT(0,1): DAC Interval n register
  DACINT [2 @offset 0x154 @inc 0x8]
  DACINT0 @offset 0x154
  DACINT1 @offset 0x15c $u32 {
    16
    INT:16 // at 0: DAC Interval
  }

//---  Register POEN: Pulse-Out n Enable register
  POEN @offset 0x190 $u32 {
    24
    POEN:8 // at 0: PDB Pulse-Out Enable
  }

//---  Registers PODLY(0,1,2,3): Pulse-Out n Delay register
  PODLY [4 @offset 0x194 @inc 0x4]
  PO0DLY @offset 0x194
  PO1DLY @offset 0x198
  PO2DLY @offset 0x19c
  PO3DLY @offset 0x1a0 $u32 {
    DLY1:16 // at 16: PDB Pulse-Out Delay 1
    DLY2:16 // at 0: PDB Pulse-Out Delay 2
  }

}

//--- Enumerated values for register SC, field CONT
  let PDB0_SC_CONT_PDB_0 $bool = no // PDB operation in One-Shot mode
  let PDB0_SC_CONT_PDB_1 $bool = yes // PDB operation in Continuous mode

//--- Enumerated values for register SC, field MULT
  let PDB0_SC_MULT_Multiplication_00 $u2 = 0 // Multiplication factor is 1.
  let PDB0_SC_MULT_Multiplication_01 $u2 = 1 // Multiplication factor is 10.
  let PDB0_SC_MULT_Multiplication_10 $u2 = 2 // Multiplication factor is 20.
  let PDB0_SC_MULT_Multiplication_11 $u2 = 3 // Multiplication factor is 40.

//--- Enumerated values for register SC, field PDBIE
  let PDB0_SC_PDBIE_PDB_0 $bool = no // PDB interrupt disabled.
  let PDB0_SC_PDBIE_PDB_1 $bool = yes // PDB interrupt enabled.

//--- Enumerated values for register SC, field PDBEN
  let PDB0_SC_PDBEN_PDB_0 $bool = no // PDB disabled. Counter is off.
  let PDB0_SC_PDBEN_PDB_1 $bool = yes // PDB enabled.

//--- Enumerated values for register SC, field TRGSEL
  let PDB0_SC_TRGSEL_Trigger_In_0000 $u4 = 0 // Trigger-In 0 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0001 $u4 = 1 // Trigger-In 1 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0010 $u4 = 2 // Trigger-In 2 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0011 $u4 = 3 // Trigger-In 3 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0100 $u4 = 4 // Trigger-In 4 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0101 $u4 = 5 // Trigger-In 5 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0110 $u4 = 6 // Trigger-In 6 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_0111 $u4 = 7 // Trigger-In 7 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1000 $u4 = 8 // Trigger-In 8 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1001 $u4 = 9 // Trigger-In 9 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1010 $u4 = 10 // Trigger-In 10 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1011 $u4 = 11 // Trigger-In 11 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1100 $u4 = 12 // Trigger-In 12 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1101 $u4 = 13 // Trigger-In 13 is selected.
  let PDB0_SC_TRGSEL_Trigger_In_1110 $u4 = 14 // Trigger-In 14 is selected.
  let PDB0_SC_TRGSEL_Software_1111 $u4 = 15 // Software trigger is selected.

//--- Enumerated values for register SC, field PRESCALER
  let PDB0_SC_PRESCALER_Counting_000 $u3 = 0 // Counting uses the peripheral clock divided by multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_001 $u3 = 1 // Counting uses the peripheral clock divided by twice of the multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_010 $u3 = 2 // Counting uses the peripheral clock divided by four times of the multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_011 $u3 = 3 // Counting uses the peripheral clock divided by eight times of the multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_100 $u3 = 4 // Counting uses the peripheral clock divided by 16 times of the multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_101 $u3 = 5 // Counting uses the peripheral clock divided by 32 times of the multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_110 $u3 = 6 // Counting uses the peripheral clock divided by 64 times of the multiplication factor selected by MULT.
  let PDB0_SC_PRESCALER_Counting_111 $u3 = 7 // Counting uses the peripheral clock divided by 128 times of the multiplication factor selected by MULT.

//--- Enumerated values for register SC, field DMAEN
  let PDB0_SC_DMAEN_DMA_0 $bool = no // DMA disabled.
  let PDB0_SC_DMAEN_DMA_1 $bool = yes // DMA enabled.

//--- Enumerated values for register SC, field PDBEIE
  let PDB0_SC_PDBEIE_PDB_0 $bool = no // PDB sequence error interrupt disabled.
  let PDB0_SC_PDBEIE_PDB_1 $bool = yes // PDB sequence error interrupt enabled.

//--- Enumerated values for register SC, field LDMOD
  let PDB0_SC_LDMOD_The_00 $u2 = 0 // The internal registers are loaded with the values from their buffers immediately after 1 is written to LDOK.
  let PDB0_SC_LDMOD_The_01 $u2 = 1 // The internal registers are loaded with the values from their buffers when the PDB counter reaches the MOD register value after 1 is written to LDOK.
  let PDB0_SC_LDMOD_The_10 $u2 = 2 // The internal registers are loaded with the values from their buffers when a trigger input event is detected after 1 is written to LDOK.
  let PDB0_SC_LDMOD_The_11 $u2 = 3 // The internal registers are loaded with the values from their buffers when either the PDB counter reaches the MOD register value or a trigger input event is detected, after 1 is written to LDOK.

//--- Enumerated values for register CH%sC1, field EN
  let PDB0_CHC1_EN_PDB_0 $u8 = 0 // PDB channel's corresponding pre-trigger disabled.
  let PDB0_CHC1_EN_PDB_1 $u8 = 1 // PDB channel's corresponding pre-trigger enabled.

//--- Enumerated values for register CH%sC1, field TOS
  let PDB0_CHC1_TOS_PDB_0 $u8 = 0 // PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
  let PDB0_CHC1_TOS_PDB_1 $u8 = 1 // PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.

//--- Enumerated values for register CH%sC1, field BB
  let PDB0_CHC1_BB_PDB_0 $u8 = 0 // PDB channel's corresponding pre-trigger back-to-back operation disabled.
  let PDB0_CHC1_BB_PDB_1 $u8 = 1 // PDB channel's corresponding pre-trigger back-to-back operation enabled.

//--- Enumerated values for register CH%sS, field ERR
  let PDB0_CHS_ERR_Sequence_0 $u8 = 0 // Sequence error not detected on PDB channel's corresponding pre-trigger.
  let PDB0_CHS_ERR_Sequence_1 $u8 = 1 // Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.

//--- Enumerated values for register DACINTC%s, field TOE
  let PDB0_DACINTC_TOE_DAC_0 $bool = no // DAC interval trigger disabled.
  let PDB0_DACINTC_TOE_DAC_1 $bool = yes // DAC interval trigger enabled.

//--- Enumerated values for register DACINTC%s, field EXT
  let PDB0_DACINTC_EXT_DAC_0 $bool = no // DAC external trigger input disabled. DAC interval counter is reset and counting starts when a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
  let PDB0_DACINTC_EXT_DAC_1 $bool = yes // DAC external trigger input enabled. DAC interval counter is bypassed and DAC external trigger input triggers the DAC interval trigger.

//--- Enumerated values for register POEN, field POEN
  let PDB0_POEN_POEN_PDB_0 $u8 = 0 // PDB Pulse-Out disabled
  let PDB0_POEN_POEN_PDB_1 $u8 = 1 // PDB Pulse-Out enabled

//------------------------------------------------------------------------------
// Peripheral PIT: Periodic Interrupt Timer
//------------------------------------------------------------------------------

registers ©PIT @at 0x40037000 {
//---  Register MCR: PIT Module Control Register
  MCR @offset 0x0 $u32 {
    30
    MDIS // at 1: Module Disable - (PIT section)
    FRZ // at 0: Freeze
  }

//---  Register LTMR64H: PIT Upper Lifetime Timer Register
  LTMR64H @offset 0xe0 @ro $u32 {
    LTH:32 // at 0: Life Timer value
  }

//---  Register LTMR64L: PIT Lower Lifetime Timer Register
  LTMR64L @offset 0xe4 @ro $u32 {
    LTL:32 // at 0: Life Timer value
  }

//---  Registers LDVAL(0,1,2,3): Timer Load Value Register
  LDVAL [4 @offset 0x100 @inc 0x10]
  LDVAL0 @offset 0x100
  LDVAL1 @offset 0x110
  LDVAL2 @offset 0x120
  LDVAL3 @offset 0x130 $u32 {
    TSV:32 // at 0: Timer Start Value
  }

//---  Registers CVAL(0,1,2,3): Current Timer Value Register
  CVAL [4 @offset 0x104 @inc 0x10]
  CVAL0 @offset 0x104
  CVAL1 @offset 0x114
  CVAL2 @offset 0x124
  CVAL3 @offset 0x134 @ro $u32 {
    TVL:32 // at 0: Current Timer Value
  }

//---  Registers TCTRL(0,1,2,3): Timer Control Register
  TCTRL [4 @offset 0x108 @inc 0x10]
  TCTRL0 @offset 0x108
  TCTRL1 @offset 0x118
  TCTRL2 @offset 0x128
  TCTRL3 @offset 0x138 $u32 {
    29
    CHN // at 2: Chain Mode
    TIE // at 1: Timer Interrupt Enable
    TEN // at 0: Timer Enable
  }

//---  Registers TFLG(0,1,2,3): Timer Flag Register
  TFLG [4 @offset 0x10c @inc 0x10]
  TFLG0 @offset 0x10c
  TFLG1 @offset 0x11c
  TFLG2 @offset 0x12c
  TFLG3 @offset 0x13c $u32 {
    31
    TIF // at 0: Timer Interrupt Flag
  }

}

//--- Enumerated values for register MCR, field FRZ
  let PIT_MCR_FRZ_Timers_0 $bool = no // Timers continue to run in Debug mode.
  let PIT_MCR_FRZ_Timers_1 $bool = yes // Timers are stopped in Debug mode.

//--- Enumerated values for register MCR, field MDIS
  let PIT_MCR_MDIS_Clock_0 $bool = no // Clock for standard PIT timers is enabled.
  let PIT_MCR_MDIS_Clock_1 $bool = yes // Clock for standard PIT timers is disabled.

//--- Enumerated values for register TCTRL%s, field TEN
  let PIT_TCTRL_TEN_Timer_0 $bool = no // Timer n is disabled.
  let PIT_TCTRL_TEN_Timer_1 $bool = yes // Timer n is enabled.

//--- Enumerated values for register TCTRL%s, field TIE
  let PIT_TCTRL_TIE_Interrupt_0 $bool = no // Interrupt requests from Timer n are disabled.
  let PIT_TCTRL_TIE_Interrupt_1 $bool = yes // Interrupt will be requested whenever TIF is set.

//--- Enumerated values for register TCTRL%s, field CHN
  let PIT_TCTRL_CHN_Timer_0 $bool = no // Timer is not chained.
  let PIT_TCTRL_CHN_Timer_1 $bool = yes // Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is chained to Timer 1.

//--- Enumerated values for register TFLG%s, field TIF
  let PIT_TFLG_TIF_Timeout_0 $bool = no // Timeout has not yet occurred.
  let PIT_TFLG_TIF_Timeout_1 $bool = yes // Timeout has occurred.

//------------------------------------------------------------------------------
// Peripheral PMC: Power Management Controller
//------------------------------------------------------------------------------

registers ©PMC @at 0x4007d000 {
//---  Register LVDSC1: Low Voltage Detect Status And Control 1 register
  LVDSC1 @offset 0x0 $u8 {
    LVDF // at 7: Low-Voltage Detect Flag
    LVDACK // at 6: Low-Voltage Detect Acknowledge
    LVDIE // at 5: Low-Voltage Detect Interrupt Enable
    LVDRE // at 4: Low-Voltage Detect Reset Enable
    2
    LVDV:2 // at 0: Low-Voltage Detect Voltage Select
  }

//---  Register LVDSC2: Low Voltage Detect Status And Control 2 register
  LVDSC2 @offset 0x1 $u8 {
    LVWF // at 7: Low-Voltage Warning Flag
    LVWACK // at 6: Low-Voltage Warning Acknowledge
    LVWIE // at 5: Low-Voltage Warning Interrupt Enable
    3
    LVWV:2 // at 0: Low-Voltage Warning Voltage Select
  }

//---  Register REGSC: Regulator Status And Control register
  REGSC @offset 0x2 $u8 {
    3
    BGEN // at 4: Bandgap Enable In VLPx Operation
    ACKISO // at 3: Acknowledge Isolation
    REGONS // at 2: Regulator In Run Regulation Status
    1
    BGBE // at 0: Bandgap Buffer Enable
  }

}

//--- Enumerated values for register LVDSC1, field LVDV
  let PMC_LVDSC1_LVDV_Low_00 $u2 = 0 // Low trip point selected (V LVD = V LVDL )
  let PMC_LVDSC1_LVDV_High_01 $u2 = 1 // High trip point selected (V LVD = V LVDH )

//--- Enumerated values for register LVDSC1, field LVDRE
  let PMC_LVDSC1_LVDRE_LVDF_0 $bool = no // LVDF does not generate hardware resets
  let PMC_LVDSC1_LVDRE_Force_1 $bool = yes // Force an MCU reset when LVDF = 1

//--- Enumerated values for register LVDSC1, field LVDIE
  let PMC_LVDSC1_LVDIE_Hardware_0 $bool = no // Hardware interrupt disabled (use polling)
  let PMC_LVDSC1_LVDIE_Request_1 $bool = yes // Request a hardware interrupt when LVDF = 1

//--- Enumerated values for register LVDSC1, field LVDF
  let PMC_LVDSC1_LVDF_Low_voltage_0 $bool = no // Low-voltage event not detected
  let PMC_LVDSC1_LVDF_Low_voltage_1 $bool = yes // Low-voltage event detected

//--- Enumerated values for register LVDSC2, field LVWV
  let PMC_LVDSC2_LVWV_Low_00 $u2 = 0 // Low trip point selected (VLVW = VLVW1)
  let PMC_LVDSC2_LVWV_Mid_01 $u2 = 1 // Mid 1 trip point selected (VLVW = VLVW2)
  let PMC_LVDSC2_LVWV_Mid_10 $u2 = 2 // Mid 2 trip point selected (VLVW = VLVW3)
  let PMC_LVDSC2_LVWV_High_11 $u2 = 3 // High trip point selected (VLVW = VLVW4)

//--- Enumerated values for register LVDSC2, field LVWIE
  let PMC_LVDSC2_LVWIE_Hardware_0 $bool = no // Hardware interrupt disabled (use polling)
  let PMC_LVDSC2_LVWIE_Request_1 $bool = yes // Request a hardware interrupt when LVWF = 1

//--- Enumerated values for register LVDSC2, field LVWF
  let PMC_LVDSC2_LVWF_Low_voltage_0 $bool = no // Low-voltage warning event not detected
  let PMC_LVDSC2_LVWF_Low_voltage_1 $bool = yes // Low-voltage warning event detected

//--- Enumerated values for register REGSC, field BGBE
  let PMC_REGSC_BGBE_Bandgap_0 $bool = no // Bandgap buffer not enabled
  let PMC_REGSC_BGBE_Bandgap_1 $bool = yes // Bandgap buffer enabled

//--- Enumerated values for register REGSC, field REGONS
  let PMC_REGSC_REGONS_Regulator_0 $bool = no // Regulator is in stop regulation or in transition to/from it
  let PMC_REGSC_REGONS_Regulator_1 $bool = yes // Regulator is in run regulation

//--- Enumerated values for register REGSC, field ACKISO
  let PMC_REGSC_ACKISO_Peripherals_0 $bool = no // Peripherals and I/O pads are in normal run state.
  let PMC_REGSC_ACKISO_Certain_1 $bool = yes // Certain peripherals and I/O pads are in an isolated and latched state.

//--- Enumerated values for register REGSC, field BGEN
  let PMC_REGSC_BGEN_Bandgap_0 $bool = no // Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
  let PMC_REGSC_BGEN_Bandgap_1 $bool = yes // Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©PORT [5]
//        PORTA at 0x40049000
//        PORTB at 0x4004a000
//        PORTC at 0x4004b000
//        PORTD at 0x4004c000
//        PORTE at 0x4004d000
//------------------------------------------------------------------------------

registers ©PORT [5 @at 0x40049000 0x4004a000 0x4004b000 0x4004c000 0x4004d000]
          ©PORTA @at 0x40049000
          ©PORTB @at 0x4004a000
          ©PORTC @at 0x4004b000
          ©PORTD @at 0x4004c000
          ©PORTE @at 0x4004d000 {
//---  Registers PCR(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31): Pin Control Register n
  PCR [32 @offset 0x0 @inc 0x4]
  PCR0 @offset 0x0
  PCR1 @offset 0x4
  PCR2 @offset 0x8
  PCR3 @offset 0xc
  PCR4 @offset 0x10
  PCR5 @offset 0x14
  PCR6 @offset 0x18
  PCR7 @offset 0x1c
  PCR8 @offset 0x20
  PCR9 @offset 0x24
  PCR10 @offset 0x28
  PCR11 @offset 0x2c
  PCR12 @offset 0x30
  PCR13 @offset 0x34
  PCR14 @offset 0x38
  PCR15 @offset 0x3c
  PCR16 @offset 0x40
  PCR17 @offset 0x44
  PCR18 @offset 0x48
  PCR19 @offset 0x4c
  PCR20 @offset 0x50
  PCR21 @offset 0x54
  PCR22 @offset 0x58
  PCR23 @offset 0x5c
  PCR24 @offset 0x60
  PCR25 @offset 0x64
  PCR26 @offset 0x68
  PCR27 @offset 0x6c
  PCR28 @offset 0x70
  PCR29 @offset 0x74
  PCR30 @offset 0x78
  PCR31 @offset 0x7c $u32 {
    7
    ISF // at 24: Interrupt Status Flag
    4
    IRQC:4 // at 16: Interrupt Configuration
    LK // at 15: Lock Register
    4
    MUX:3 // at 8: Pin Mux Control
    1
    DSE // at 6: Drive Strength Enable
    ODE // at 5: Open Drain Enable
    PFE // at 4: Passive Filter Enable
    1
    SRE // at 2: Slew Rate Enable
    PE // at 1: Pull Enable
    PS // at 0: Pull Select
  }

//---  Register GPCLR: Global Pin Control Low Register
  GPCLR @offset 0x80 $u32 {
    GPWE:16 // at 16: Global Pin Write Enable
    GPWD:16 // at 0: Global Pin Write Data
  }

//---  Register GPCHR: Global Pin Control High Register
  GPCHR @offset 0x84 $u32 {
    GPWE:16 // at 16: Global Pin Write Enable
    GPWD:16 // at 0: Global Pin Write Data
  }

//---  Register ISFR: Interrupt Status Flag Register
  ISFR @offset 0xa0 $u32 {
    ISF:32 // at 0: Interrupt Status Flag
  }

//---  Register DFER: Digital Filter Enable Register
  DFER @offset 0xc0 $u32 {
    DFE:32 // at 0: Digital Filter Enable
  }

//---  Register DFCR: Digital Filter Clock Register
  DFCR @offset 0xc4 $u32 {
    31
    CS // at 0: Clock Source
  }

//---  Register DFWR: Digital Filter Width Register
  DFWR @offset 0xc8 $u32 {
    27
    FILT:5 // at 0: Filter Length
  }

}

//--- Enumerated values for register PCR%s, field PS
  let PORTA_PCR_PS_Internal_0 $bool = no // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
  let PORTA_PCR_PS_Internal_1 $bool = yes // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.

//--- Enumerated values for register PCR%s, field PE
  let PORTA_PCR_PE_Internal_0 $bool = no // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
  let PORTA_PCR_PE_Internal_1 $bool = yes // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register PCR%s, field SRE
  let PORTA_PCR_SRE_Fast_0 $bool = no // Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
  let PORTA_PCR_SRE_Slow_1 $bool = yes // Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field PFE
  let PORTA_PCR_PFE_Passive_0 $bool = no // Passive input filter is disabled on the corresponding pin.
  let PORTA_PCR_PFE_Passive_1 $bool = yes // Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.

//--- Enumerated values for register PCR%s, field ODE
  let PORTA_PCR_ODE_Open_0 $bool = no // Open drain output is disabled on the corresponding pin.
  let PORTA_PCR_ODE_Open_1 $bool = yes // Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field DSE
  let PORTA_PCR_DSE_Low_0 $bool = no // Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
  let PORTA_PCR_DSE_High_1 $bool = yes // High drive strength is configured on the corresponding pin, if pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field MUX
  let PORTA_PCR_MUX_Pin_000 $u3 = 0 // Pin disabled (analog).
  let PORTA_PCR_MUX_Alternative_001 $u3 = 1 // Alternative 1 (GPIO).
  let PORTA_PCR_MUX_Alternative_010 $u3 = 2 // Alternative 2 (chip-specific).
  let PORTA_PCR_MUX_Alternative_011 $u3 = 3 // Alternative 3 (chip-specific).
  let PORTA_PCR_MUX_Alternative_100 $u3 = 4 // Alternative 4 (chip-specific).
  let PORTA_PCR_MUX_Alternative_101 $u3 = 5 // Alternative 5 (chip-specific).
  let PORTA_PCR_MUX_Alternative_110 $u3 = 6 // Alternative 6 (chip-specific).
  let PORTA_PCR_MUX_Alternative_111 $u3 = 7 // Alternative 7 (chip-specific).

//--- Enumerated values for register PCR%s, field LK
  let PORTA_PCR_LK_Pin_0 $bool = no // Pin Control Register fields [15:0] are not locked.
  let PORTA_PCR_LK_Pin_1 $bool = yes // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.

//--- Enumerated values for register PCR%s, field IRQC
  let PORTA_PCR_IRQC_Interrupt_0000 $u4 = 0 // Interrupt Status Flag (ISF) is disabled.
  let PORTA_PCR_IRQC_ISF_0001 $u4 = 1 // ISF flag and DMA request on rising edge.
  let PORTA_PCR_IRQC_ISF_0010 $u4 = 2 // ISF flag and DMA request on falling edge.
  let PORTA_PCR_IRQC_ISF_0011 $u4 = 3 // ISF flag and DMA request on either edge.
  let PORTA_PCR_IRQC_ISF_1000 $u4 = 8 // ISF flag and Interrupt when logic 0.
  let PORTA_PCR_IRQC_ISF_1001 $u4 = 9 // ISF flag and Interrupt on rising-edge.
  let PORTA_PCR_IRQC_ISF_1010 $u4 = 10 // ISF flag and Interrupt on falling-edge.
  let PORTA_PCR_IRQC_ISF_1011 $u4 = 11 // ISF flag and Interrupt on either edge.
  let PORTA_PCR_IRQC_ISF_1100 $u4 = 12 // ISF flag and Interrupt when logic 1.

//--- Enumerated values for register PCR%s, field ISF
  let PORTA_PCR_ISF_Configured_0 $bool = no // Configured interrupt is not detected.
  let PORTA_PCR_ISF_Configured_1 $bool = yes // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register GPCLR, field GPWE
  let PORTA_GPCLR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTA_GPCLR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register GPCHR, field GPWE
  let PORTA_GPCHR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTA_GPCHR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register ISFR, field ISF
  let PORTA_ISFR_ISF_Configured_0 $u32 = 0 // Configured interrupt is not detected.
  let PORTA_ISFR_ISF_Configured_1 $u32 = 1 // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register DFER, field DFE
  let PORTA_DFER_DFE_Digital_0 $u32 = 0 // Digital filter is disabled on the corresponding pin and output of the digital filter is reset to zero.
  let PORTA_DFER_DFE_Digital_1 $u32 = 1 // Digital filter is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register DFCR, field CS
  let PORTA_DFCR_CS_Digital_0 $bool = no // Digital filters are clocked by the bus clock.
  let PORTA_DFCR_CS_Digital_1 $bool = yes // Digital filters are clocked by the LPO clock.

//--- Enumerated values for register PCR%s, field PS
  let PORTB_PCR_PS_Internal_0 $bool = no // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
  let PORTB_PCR_PS_Internal_1 $bool = yes // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.

//--- Enumerated values for register PCR%s, field PE
  let PORTB_PCR_PE_Internal_0 $bool = no // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
  let PORTB_PCR_PE_Internal_1 $bool = yes // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register PCR%s, field SRE
  let PORTB_PCR_SRE_Fast_0 $bool = no // Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
  let PORTB_PCR_SRE_Slow_1 $bool = yes // Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field PFE
  let PORTB_PCR_PFE_Passive_0 $bool = no // Passive input filter is disabled on the corresponding pin.
  let PORTB_PCR_PFE_Passive_1 $bool = yes // Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.

//--- Enumerated values for register PCR%s, field ODE
  let PORTB_PCR_ODE_Open_0 $bool = no // Open drain output is disabled on the corresponding pin.
  let PORTB_PCR_ODE_Open_1 $bool = yes // Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field DSE
  let PORTB_PCR_DSE_Low_0 $bool = no // Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
  let PORTB_PCR_DSE_High_1 $bool = yes // High drive strength is configured on the corresponding pin, if pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field MUX
  let PORTB_PCR_MUX_Pin_000 $u3 = 0 // Pin disabled (analog).
  let PORTB_PCR_MUX_Alternative_001 $u3 = 1 // Alternative 1 (GPIO).
  let PORTB_PCR_MUX_Alternative_010 $u3 = 2 // Alternative 2 (chip-specific).
  let PORTB_PCR_MUX_Alternative_011 $u3 = 3 // Alternative 3 (chip-specific).
  let PORTB_PCR_MUX_Alternative_100 $u3 = 4 // Alternative 4 (chip-specific).
  let PORTB_PCR_MUX_Alternative_101 $u3 = 5 // Alternative 5 (chip-specific).
  let PORTB_PCR_MUX_Alternative_110 $u3 = 6 // Alternative 6 (chip-specific).
  let PORTB_PCR_MUX_Alternative_111 $u3 = 7 // Alternative 7 (chip-specific).

//--- Enumerated values for register PCR%s, field LK
  let PORTB_PCR_LK_Pin_0 $bool = no // Pin Control Register fields [15:0] are not locked.
  let PORTB_PCR_LK_Pin_1 $bool = yes // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.

//--- Enumerated values for register PCR%s, field IRQC
  let PORTB_PCR_IRQC_Interrupt_0000 $u4 = 0 // Interrupt Status Flag (ISF) is disabled.
  let PORTB_PCR_IRQC_ISF_0001 $u4 = 1 // ISF flag and DMA request on rising edge.
  let PORTB_PCR_IRQC_ISF_0010 $u4 = 2 // ISF flag and DMA request on falling edge.
  let PORTB_PCR_IRQC_ISF_0011 $u4 = 3 // ISF flag and DMA request on either edge.
  let PORTB_PCR_IRQC_ISF_1000 $u4 = 8 // ISF flag and Interrupt when logic 0.
  let PORTB_PCR_IRQC_ISF_1001 $u4 = 9 // ISF flag and Interrupt on rising-edge.
  let PORTB_PCR_IRQC_ISF_1010 $u4 = 10 // ISF flag and Interrupt on falling-edge.
  let PORTB_PCR_IRQC_ISF_1011 $u4 = 11 // ISF flag and Interrupt on either edge.
  let PORTB_PCR_IRQC_ISF_1100 $u4 = 12 // ISF flag and Interrupt when logic 1.

//--- Enumerated values for register PCR%s, field ISF
  let PORTB_PCR_ISF_Configured_0 $bool = no // Configured interrupt is not detected.
  let PORTB_PCR_ISF_Configured_1 $bool = yes // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register GPCLR, field GPWE
  let PORTB_GPCLR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTB_GPCLR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register GPCHR, field GPWE
  let PORTB_GPCHR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTB_GPCHR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register ISFR, field ISF
  let PORTB_ISFR_ISF_Configured_0 $u32 = 0 // Configured interrupt is not detected.
  let PORTB_ISFR_ISF_Configured_1 $u32 = 1 // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register DFER, field DFE
  let PORTB_DFER_DFE_Digital_0 $u32 = 0 // Digital filter is disabled on the corresponding pin and output of the digital filter is reset to zero.
  let PORTB_DFER_DFE_Digital_1 $u32 = 1 // Digital filter is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register DFCR, field CS
  let PORTB_DFCR_CS_Digital_0 $bool = no // Digital filters are clocked by the bus clock.
  let PORTB_DFCR_CS_Digital_1 $bool = yes // Digital filters are clocked by the LPO clock.

//--- Enumerated values for register PCR%s, field PS
  let PORTC_PCR_PS_Internal_0 $bool = no // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
  let PORTC_PCR_PS_Internal_1 $bool = yes // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.

//--- Enumerated values for register PCR%s, field PE
  let PORTC_PCR_PE_Internal_0 $bool = no // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
  let PORTC_PCR_PE_Internal_1 $bool = yes // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register PCR%s, field SRE
  let PORTC_PCR_SRE_Fast_0 $bool = no // Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
  let PORTC_PCR_SRE_Slow_1 $bool = yes // Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field PFE
  let PORTC_PCR_PFE_Passive_0 $bool = no // Passive input filter is disabled on the corresponding pin.
  let PORTC_PCR_PFE_Passive_1 $bool = yes // Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.

//--- Enumerated values for register PCR%s, field ODE
  let PORTC_PCR_ODE_Open_0 $bool = no // Open drain output is disabled on the corresponding pin.
  let PORTC_PCR_ODE_Open_1 $bool = yes // Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field DSE
  let PORTC_PCR_DSE_Low_0 $bool = no // Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
  let PORTC_PCR_DSE_High_1 $bool = yes // High drive strength is configured on the corresponding pin, if pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field MUX
  let PORTC_PCR_MUX_Pin_000 $u3 = 0 // Pin disabled (analog).
  let PORTC_PCR_MUX_Alternative_001 $u3 = 1 // Alternative 1 (GPIO).
  let PORTC_PCR_MUX_Alternative_010 $u3 = 2 // Alternative 2 (chip-specific).
  let PORTC_PCR_MUX_Alternative_011 $u3 = 3 // Alternative 3 (chip-specific).
  let PORTC_PCR_MUX_Alternative_100 $u3 = 4 // Alternative 4 (chip-specific).
  let PORTC_PCR_MUX_Alternative_101 $u3 = 5 // Alternative 5 (chip-specific).
  let PORTC_PCR_MUX_Alternative_110 $u3 = 6 // Alternative 6 (chip-specific).
  let PORTC_PCR_MUX_Alternative_111 $u3 = 7 // Alternative 7 (chip-specific).

//--- Enumerated values for register PCR%s, field LK
  let PORTC_PCR_LK_Pin_0 $bool = no // Pin Control Register fields [15:0] are not locked.
  let PORTC_PCR_LK_Pin_1 $bool = yes // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.

//--- Enumerated values for register PCR%s, field IRQC
  let PORTC_PCR_IRQC_Interrupt_0000 $u4 = 0 // Interrupt Status Flag (ISF) is disabled.
  let PORTC_PCR_IRQC_ISF_0001 $u4 = 1 // ISF flag and DMA request on rising edge.
  let PORTC_PCR_IRQC_ISF_0010 $u4 = 2 // ISF flag and DMA request on falling edge.
  let PORTC_PCR_IRQC_ISF_0011 $u4 = 3 // ISF flag and DMA request on either edge.
  let PORTC_PCR_IRQC_ISF_1000 $u4 = 8 // ISF flag and Interrupt when logic 0.
  let PORTC_PCR_IRQC_ISF_1001 $u4 = 9 // ISF flag and Interrupt on rising-edge.
  let PORTC_PCR_IRQC_ISF_1010 $u4 = 10 // ISF flag and Interrupt on falling-edge.
  let PORTC_PCR_IRQC_ISF_1011 $u4 = 11 // ISF flag and Interrupt on either edge.
  let PORTC_PCR_IRQC_ISF_1100 $u4 = 12 // ISF flag and Interrupt when logic 1.

//--- Enumerated values for register PCR%s, field ISF
  let PORTC_PCR_ISF_Configured_0 $bool = no // Configured interrupt is not detected.
  let PORTC_PCR_ISF_Configured_1 $bool = yes // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register GPCLR, field GPWE
  let PORTC_GPCLR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTC_GPCLR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register GPCHR, field GPWE
  let PORTC_GPCHR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTC_GPCHR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register ISFR, field ISF
  let PORTC_ISFR_ISF_Configured_0 $u32 = 0 // Configured interrupt is not detected.
  let PORTC_ISFR_ISF_Configured_1 $u32 = 1 // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register DFER, field DFE
  let PORTC_DFER_DFE_Digital_0 $u32 = 0 // Digital filter is disabled on the corresponding pin and output of the digital filter is reset to zero.
  let PORTC_DFER_DFE_Digital_1 $u32 = 1 // Digital filter is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register DFCR, field CS
  let PORTC_DFCR_CS_Digital_0 $bool = no // Digital filters are clocked by the bus clock.
  let PORTC_DFCR_CS_Digital_1 $bool = yes // Digital filters are clocked by the LPO clock.

//--- Enumerated values for register PCR%s, field PS
  let PORTD_PCR_PS_Internal_0 $bool = no // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
  let PORTD_PCR_PS_Internal_1 $bool = yes // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.

//--- Enumerated values for register PCR%s, field PE
  let PORTD_PCR_PE_Internal_0 $bool = no // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
  let PORTD_PCR_PE_Internal_1 $bool = yes // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register PCR%s, field SRE
  let PORTD_PCR_SRE_Fast_0 $bool = no // Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
  let PORTD_PCR_SRE_Slow_1 $bool = yes // Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field PFE
  let PORTD_PCR_PFE_Passive_0 $bool = no // Passive input filter is disabled on the corresponding pin.
  let PORTD_PCR_PFE_Passive_1 $bool = yes // Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.

//--- Enumerated values for register PCR%s, field ODE
  let PORTD_PCR_ODE_Open_0 $bool = no // Open drain output is disabled on the corresponding pin.
  let PORTD_PCR_ODE_Open_1 $bool = yes // Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field DSE
  let PORTD_PCR_DSE_Low_0 $bool = no // Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
  let PORTD_PCR_DSE_High_1 $bool = yes // High drive strength is configured on the corresponding pin, if pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field MUX
  let PORTD_PCR_MUX_Pin_000 $u3 = 0 // Pin disabled (analog).
  let PORTD_PCR_MUX_Alternative_001 $u3 = 1 // Alternative 1 (GPIO).
  let PORTD_PCR_MUX_Alternative_010 $u3 = 2 // Alternative 2 (chip-specific).
  let PORTD_PCR_MUX_Alternative_011 $u3 = 3 // Alternative 3 (chip-specific).
  let PORTD_PCR_MUX_Alternative_100 $u3 = 4 // Alternative 4 (chip-specific).
  let PORTD_PCR_MUX_Alternative_101 $u3 = 5 // Alternative 5 (chip-specific).
  let PORTD_PCR_MUX_Alternative_110 $u3 = 6 // Alternative 6 (chip-specific).
  let PORTD_PCR_MUX_Alternative_111 $u3 = 7 // Alternative 7 (chip-specific).

//--- Enumerated values for register PCR%s, field LK
  let PORTD_PCR_LK_Pin_0 $bool = no // Pin Control Register fields [15:0] are not locked.
  let PORTD_PCR_LK_Pin_1 $bool = yes // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.

//--- Enumerated values for register PCR%s, field IRQC
  let PORTD_PCR_IRQC_Interrupt_0000 $u4 = 0 // Interrupt Status Flag (ISF) is disabled.
  let PORTD_PCR_IRQC_ISF_0001 $u4 = 1 // ISF flag and DMA request on rising edge.
  let PORTD_PCR_IRQC_ISF_0010 $u4 = 2 // ISF flag and DMA request on falling edge.
  let PORTD_PCR_IRQC_ISF_0011 $u4 = 3 // ISF flag and DMA request on either edge.
  let PORTD_PCR_IRQC_ISF_1000 $u4 = 8 // ISF flag and Interrupt when logic 0.
  let PORTD_PCR_IRQC_ISF_1001 $u4 = 9 // ISF flag and Interrupt on rising-edge.
  let PORTD_PCR_IRQC_ISF_1010 $u4 = 10 // ISF flag and Interrupt on falling-edge.
  let PORTD_PCR_IRQC_ISF_1011 $u4 = 11 // ISF flag and Interrupt on either edge.
  let PORTD_PCR_IRQC_ISF_1100 $u4 = 12 // ISF flag and Interrupt when logic 1.

//--- Enumerated values for register PCR%s, field ISF
  let PORTD_PCR_ISF_Configured_0 $bool = no // Configured interrupt is not detected.
  let PORTD_PCR_ISF_Configured_1 $bool = yes // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register GPCLR, field GPWE
  let PORTD_GPCLR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTD_GPCLR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register GPCHR, field GPWE
  let PORTD_GPCHR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTD_GPCHR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register ISFR, field ISF
  let PORTD_ISFR_ISF_Configured_0 $u32 = 0 // Configured interrupt is not detected.
  let PORTD_ISFR_ISF_Configured_1 $u32 = 1 // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register DFER, field DFE
  let PORTD_DFER_DFE_Digital_0 $u32 = 0 // Digital filter is disabled on the corresponding pin and output of the digital filter is reset to zero.
  let PORTD_DFER_DFE_Digital_1 $u32 = 1 // Digital filter is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register DFCR, field CS
  let PORTD_DFCR_CS_Digital_0 $bool = no // Digital filters are clocked by the bus clock.
  let PORTD_DFCR_CS_Digital_1 $bool = yes // Digital filters are clocked by the LPO clock.

//--- Enumerated values for register PCR%s, field PS
  let PORTE_PCR_PS_Internal_0 $bool = no // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
  let PORTE_PCR_PS_Internal_1 $bool = yes // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.

//--- Enumerated values for register PCR%s, field PE
  let PORTE_PCR_PE_Internal_0 $bool = no // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
  let PORTE_PCR_PE_Internal_1 $bool = yes // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register PCR%s, field SRE
  let PORTE_PCR_SRE_Fast_0 $bool = no // Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
  let PORTE_PCR_SRE_Slow_1 $bool = yes // Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field PFE
  let PORTE_PCR_PFE_Passive_0 $bool = no // Passive input filter is disabled on the corresponding pin.
  let PORTE_PCR_PFE_Passive_1 $bool = yes // Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.

//--- Enumerated values for register PCR%s, field ODE
  let PORTE_PCR_ODE_Open_0 $bool = no // Open drain output is disabled on the corresponding pin.
  let PORTE_PCR_ODE_Open_1 $bool = yes // Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field DSE
  let PORTE_PCR_DSE_Low_0 $bool = no // Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
  let PORTE_PCR_DSE_High_1 $bool = yes // High drive strength is configured on the corresponding pin, if pin is configured as a digital output.

//--- Enumerated values for register PCR%s, field MUX
  let PORTE_PCR_MUX_Pin_000 $u3 = 0 // Pin disabled (analog).
  let PORTE_PCR_MUX_Alternative_001 $u3 = 1 // Alternative 1 (GPIO).
  let PORTE_PCR_MUX_Alternative_010 $u3 = 2 // Alternative 2 (chip-specific).
  let PORTE_PCR_MUX_Alternative_011 $u3 = 3 // Alternative 3 (chip-specific).
  let PORTE_PCR_MUX_Alternative_100 $u3 = 4 // Alternative 4 (chip-specific).
  let PORTE_PCR_MUX_Alternative_101 $u3 = 5 // Alternative 5 (chip-specific).
  let PORTE_PCR_MUX_Alternative_110 $u3 = 6 // Alternative 6 (chip-specific).
  let PORTE_PCR_MUX_Alternative_111 $u3 = 7 // Alternative 7 (chip-specific).

//--- Enumerated values for register PCR%s, field LK
  let PORTE_PCR_LK_Pin_0 $bool = no // Pin Control Register fields [15:0] are not locked.
  let PORTE_PCR_LK_Pin_1 $bool = yes // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.

//--- Enumerated values for register PCR%s, field IRQC
  let PORTE_PCR_IRQC_Interrupt_0000 $u4 = 0 // Interrupt Status Flag (ISF) is disabled.
  let PORTE_PCR_IRQC_ISF_0001 $u4 = 1 // ISF flag and DMA request on rising edge.
  let PORTE_PCR_IRQC_ISF_0010 $u4 = 2 // ISF flag and DMA request on falling edge.
  let PORTE_PCR_IRQC_ISF_0011 $u4 = 3 // ISF flag and DMA request on either edge.
  let PORTE_PCR_IRQC_ISF_1000 $u4 = 8 // ISF flag and Interrupt when logic 0.
  let PORTE_PCR_IRQC_ISF_1001 $u4 = 9 // ISF flag and Interrupt on rising-edge.
  let PORTE_PCR_IRQC_ISF_1010 $u4 = 10 // ISF flag and Interrupt on falling-edge.
  let PORTE_PCR_IRQC_ISF_1011 $u4 = 11 // ISF flag and Interrupt on either edge.
  let PORTE_PCR_IRQC_ISF_1100 $u4 = 12 // ISF flag and Interrupt when logic 1.

//--- Enumerated values for register PCR%s, field ISF
  let PORTE_PCR_ISF_Configured_0 $bool = no // Configured interrupt is not detected.
  let PORTE_PCR_ISF_Configured_1 $bool = yes // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register GPCLR, field GPWE
  let PORTE_GPCLR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTE_GPCLR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register GPCHR, field GPWE
  let PORTE_GPCHR_GPWE_Corresponding_0 $u16 = 0 // Corresponding Pin Control Register is not updated with the value in GPWD.
  let PORTE_GPCHR_GPWE_Corresponding_1 $u16 = 1 // Corresponding Pin Control Register is updated with the value in GPWD.

//--- Enumerated values for register ISFR, field ISF
  let PORTE_ISFR_ISF_Configured_0 $u32 = 0 // Configured interrupt is not detected.
  let PORTE_ISFR_ISF_Configured_1 $u32 = 1 // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

//--- Enumerated values for register DFER, field DFE
  let PORTE_DFER_DFE_Digital_0 $u32 = 0 // Digital filter is disabled on the corresponding pin and output of the digital filter is reset to zero.
  let PORTE_DFER_DFE_Digital_1 $u32 = 1 // Digital filter is enabled on the corresponding pin, if the pin is configured as a digital input.

//--- Enumerated values for register DFCR, field CS
  let PORTE_DFCR_CS_Digital_0 $bool = no // Digital filters are clocked by the bus clock.
  let PORTE_DFCR_CS_Digital_1 $bool = yes // Digital filters are clocked by the LPO clock.

//------------------------------------------------------------------------------
// Peripheral RCM: Reset Control Module
//------------------------------------------------------------------------------

registers ©RCM @at 0x4007f000 {
//---  Register SRS0: System Reset Status Register 0
  SRS0 @offset 0x0 @ro $u8 {
    POR // at 7: Power-On Reset
    PIN // at 6: External Reset Pin
    WDOG // at 5: Watchdog
    1
    LOL // at 3: Loss-of-Lock Reset
    LOC // at 2: Loss-of-Clock Reset
    LVD // at 1: Low-Voltage Detect Reset
    WAKEUP // at 0: Low Leakage Wakeup Reset
  }

//---  Register SRS1: System Reset Status Register 1
  SRS1 @offset 0x1 @ro $u8 {
    2
    SACKERR // at 5: Stop Mode Acknowledge Error Reset
    EZPT // at 4: EzPort Reset
    MDM_AP // at 3: MDM-AP System Reset Request
    SW // at 2: Software
    LOCKUP // at 1: Core Lockup
    JTAG // at 0: JTAG Generated Reset
  }

//---  Register RPFC: Reset Pin Filter Control register
  RPFC @offset 0x4 $u8 {
    5
    RSTFLTSS // at 2: Reset Pin Filter Select in Stop Mode
    RSTFLTSRW:2 // at 0: Reset Pin Filter Select in Run and Wait Modes
  }

//---  Register RPFW: Reset Pin Filter Width register
  RPFW @offset 0x5 $u8 {
    3
    RSTFLTSEL:5 // at 0: Reset Pin Filter Bus Clock Select
  }

//---  Register MR: Mode Register
  MR @offset 0x7 @ro $u8 {
    6
    EZP_MS // at 1: EZP_MS_B pin state
    1
  }

//---  Register SSRS0: Sticky System Reset Status Register 0
  SSRS0 @offset 0x8 $u8 {
    SPOR // at 7: Sticky Power-On Reset
    SPIN // at 6: Sticky External Reset Pin
    SWDOG // at 5: Sticky Watchdog
    1
    SLOL // at 3: Sticky Loss-of-Lock Reset
    SLOC // at 2: Sticky Loss-of-Clock Reset
    SLVD // at 1: Sticky Low-Voltage Detect Reset
    SWAKEUP // at 0: Sticky Low Leakage Wakeup Reset
  }

//---  Register SSRS1: Sticky System Reset Status Register 1
  SSRS1 @offset 0x9 $u8 {
    2
    SSACKERR // at 5: Sticky Stop Mode Acknowledge Error Reset
    SEZPT // at 4: Sticky EzPort Reset
    SMDM_AP // at 3: Sticky MDM-AP System Reset Request
    SSW // at 2: Sticky Software
    SLOCKUP // at 1: Sticky Core Lockup
    SJTAG // at 0: Sticky JTAG Generated Reset
  }

}

//--- Enumerated values for register SRS0, field WAKEUP
  let RCM_SRS0_WAKEUP_Reset_0 $bool = no // Reset not caused by LLWU module wakeup source
  let RCM_SRS0_WAKEUP_Reset_1 $bool = yes // Reset caused by LLWU module wakeup source

//--- Enumerated values for register SRS0, field LVD
  let RCM_SRS0_LVD_Reset_0 $bool = no // Reset not caused by LVD trip or POR
  let RCM_SRS0_LVD_Reset_1 $bool = yes // Reset caused by LVD trip or POR

//--- Enumerated values for register SRS0, field LOC
  let RCM_SRS0_LOC_Reset_0 $bool = no // Reset not caused by a loss of external clock.
  let RCM_SRS0_LOC_Reset_1 $bool = yes // Reset caused by a loss of external clock.

//--- Enumerated values for register SRS0, field LOL
  let RCM_SRS0_LOL_Reset_0 $bool = no // Reset not caused by a loss of lock in the PLL
  let RCM_SRS0_LOL_Reset_1 $bool = yes // Reset caused by a loss of lock in the PLL

//--- Enumerated values for register SRS0, field WDOG
  let RCM_SRS0_WDOG_Reset_0 $bool = no // Reset not caused by watchdog timeout
  let RCM_SRS0_WDOG_Reset_1 $bool = yes // Reset caused by watchdog timeout

//--- Enumerated values for register SRS0, field PIN
  let RCM_SRS0_PIN_Reset_0 $bool = no // Reset not caused by external reset pin
  let RCM_SRS0_PIN_Reset_1 $bool = yes // Reset caused by external reset pin

//--- Enumerated values for register SRS0, field POR
  let RCM_SRS0_POR_Reset_0 $bool = no // Reset not caused by POR
  let RCM_SRS0_POR_Reset_1 $bool = yes // Reset caused by POR

//--- Enumerated values for register SRS1, field JTAG
  let RCM_SRS1_JTAG_Reset_0 $bool = no // Reset not caused by JTAG
  let RCM_SRS1_JTAG_Reset_1 $bool = yes // Reset caused by JTAG

//--- Enumerated values for register SRS1, field LOCKUP
  let RCM_SRS1_LOCKUP_Reset_0 $bool = no // Reset not caused by core LOCKUP event
  let RCM_SRS1_LOCKUP_Reset_1 $bool = yes // Reset caused by core LOCKUP event

//--- Enumerated values for register SRS1, field SW
  let RCM_SRS1_SW_Reset_0 $bool = no // Reset not caused by software setting of SYSRESETREQ bit
  let RCM_SRS1_SW_Reset_1 $bool = yes // Reset caused by software setting of SYSRESETREQ bit

//--- Enumerated values for register SRS1, field MDM_AP
  let RCM_SRS1_MDM_AP_Reset_0 $bool = no // Reset not caused by host debugger system setting of the System Reset Request bit
  let RCM_SRS1_MDM_AP_Reset_1 $bool = yes // Reset caused by host debugger system setting of the System Reset Request bit

//--- Enumerated values for register SRS1, field EZPT
  let RCM_SRS1_EZPT_Reset_0 $bool = no // Reset not caused by EzPort receiving the RESET command while the device is in EzPort mode
  let RCM_SRS1_EZPT_Reset_1 $bool = yes // Reset caused by EzPort receiving the RESET command while the device is in EzPort mode

//--- Enumerated values for register SRS1, field SACKERR
  let RCM_SRS1_SACKERR_Reset_0 $bool = no // Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
  let RCM_SRS1_SACKERR_Reset_1 $bool = yes // Reset caused by peripheral failure to acknowledge attempt to enter stop mode

//--- Enumerated values for register RPFC, field RSTFLTSRW
  let RCM_RPFC_RSTFLTSRW_All_00 $u2 = 0 // All filtering disabled
  let RCM_RPFC_RSTFLTSRW_Bus_01 $u2 = 1 // Bus clock filter enabled for normal operation
  let RCM_RPFC_RSTFLTSRW_LPO_10 $u2 = 2 // LPO clock filter enabled for normal operation

//--- Enumerated values for register RPFC, field RSTFLTSS
  let RCM_RPFC_RSTFLTSS_All_0 $bool = no // All filtering disabled
  let RCM_RPFC_RSTFLTSS_LPO_1 $bool = yes // LPO clock filter enabled

//--- Enumerated values for register RPFW, field RSTFLTSEL
  let RCM_RPFW_RSTFLTSEL_Bus_00000 $u5 = 0 // Bus clock filter count is 1
  let RCM_RPFW_RSTFLTSEL_Bus_00001 $u5 = 1 // Bus clock filter count is 2
  let RCM_RPFW_RSTFLTSEL_Bus_00010 $u5 = 2 // Bus clock filter count is 3
  let RCM_RPFW_RSTFLTSEL_Bus_00011 $u5 = 3 // Bus clock filter count is 4
  let RCM_RPFW_RSTFLTSEL_Bus_00100 $u5 = 4 // Bus clock filter count is 5
  let RCM_RPFW_RSTFLTSEL_Bus_00101 $u5 = 5 // Bus clock filter count is 6
  let RCM_RPFW_RSTFLTSEL_Bus_00110 $u5 = 6 // Bus clock filter count is 7
  let RCM_RPFW_RSTFLTSEL_Bus_00111 $u5 = 7 // Bus clock filter count is 8
  let RCM_RPFW_RSTFLTSEL_Bus_01000 $u5 = 8 // Bus clock filter count is 9
  let RCM_RPFW_RSTFLTSEL_Bus_01001 $u5 = 9 // Bus clock filter count is 10
  let RCM_RPFW_RSTFLTSEL_Bus_01010 $u5 = 10 // Bus clock filter count is 11
  let RCM_RPFW_RSTFLTSEL_Bus_01011 $u5 = 11 // Bus clock filter count is 12
  let RCM_RPFW_RSTFLTSEL_Bus_01100 $u5 = 12 // Bus clock filter count is 13
  let RCM_RPFW_RSTFLTSEL_Bus_01101 $u5 = 13 // Bus clock filter count is 14
  let RCM_RPFW_RSTFLTSEL_Bus_01110 $u5 = 14 // Bus clock filter count is 15
  let RCM_RPFW_RSTFLTSEL_Bus_01111 $u5 = 15 // Bus clock filter count is 16
  let RCM_RPFW_RSTFLTSEL_Bus_10000 $u5 = 16 // Bus clock filter count is 17
  let RCM_RPFW_RSTFLTSEL_Bus_10001 $u5 = 17 // Bus clock filter count is 18
  let RCM_RPFW_RSTFLTSEL_Bus_10010 $u5 = 18 // Bus clock filter count is 19
  let RCM_RPFW_RSTFLTSEL_Bus_10011 $u5 = 19 // Bus clock filter count is 20
  let RCM_RPFW_RSTFLTSEL_Bus_10100 $u5 = 20 // Bus clock filter count is 21
  let RCM_RPFW_RSTFLTSEL_Bus_10101 $u5 = 21 // Bus clock filter count is 22
  let RCM_RPFW_RSTFLTSEL_Bus_10110 $u5 = 22 // Bus clock filter count is 23
  let RCM_RPFW_RSTFLTSEL_Bus_10111 $u5 = 23 // Bus clock filter count is 24
  let RCM_RPFW_RSTFLTSEL_Bus_11000 $u5 = 24 // Bus clock filter count is 25
  let RCM_RPFW_RSTFLTSEL_Bus_11001 $u5 = 25 // Bus clock filter count is 26
  let RCM_RPFW_RSTFLTSEL_Bus_11010 $u5 = 26 // Bus clock filter count is 27
  let RCM_RPFW_RSTFLTSEL_Bus_11011 $u5 = 27 // Bus clock filter count is 28
  let RCM_RPFW_RSTFLTSEL_Bus_11100 $u5 = 28 // Bus clock filter count is 29
  let RCM_RPFW_RSTFLTSEL_Bus_11101 $u5 = 29 // Bus clock filter count is 30
  let RCM_RPFW_RSTFLTSEL_Bus_11110 $u5 = 30 // Bus clock filter count is 31
  let RCM_RPFW_RSTFLTSEL_Bus_11111 $u5 = 31 // Bus clock filter count is 32

//--- Enumerated values for register MR, field EZP_MS
  let RCM_MR_EZP_MS_Pin_0 $bool = no // Pin deasserted (logic 1)
  let RCM_MR_EZP_MS_Pin_1 $bool = yes // Pin asserted (logic 0)

//--- Enumerated values for register SSRS0, field SWAKEUP
  let RCM_SSRS0_SWAKEUP_Reset_0 $bool = no // Reset not caused by LLWU module wakeup source
  let RCM_SSRS0_SWAKEUP_Reset_1 $bool = yes // Reset caused by LLWU module wakeup source

//--- Enumerated values for register SSRS0, field SLVD
  let RCM_SSRS0_SLVD_Reset_0 $bool = no // Reset not caused by LVD trip or POR
  let RCM_SSRS0_SLVD_Reset_1 $bool = yes // Reset caused by LVD trip or POR

//--- Enumerated values for register SSRS0, field SLOC
  let RCM_SSRS0_SLOC_Reset_0 $bool = no // Reset not caused by a loss of external clock.
  let RCM_SSRS0_SLOC_Reset_1 $bool = yes // Reset caused by a loss of external clock.

//--- Enumerated values for register SSRS0, field SLOL
  let RCM_SSRS0_SLOL_Reset_0 $bool = no // Reset not caused by a loss of lock in the PLL
  let RCM_SSRS0_SLOL_Reset_1 $bool = yes // Reset caused by a loss of lock in the PLL

//--- Enumerated values for register SSRS0, field SWDOG
  let RCM_SSRS0_SWDOG_Reset_0 $bool = no // Reset not caused by watchdog timeout
  let RCM_SSRS0_SWDOG_Reset_1 $bool = yes // Reset caused by watchdog timeout

//--- Enumerated values for register SSRS0, field SPIN
  let RCM_SSRS0_SPIN_Reset_0 $bool = no // Reset not caused by external reset pin
  let RCM_SSRS0_SPIN_Reset_1 $bool = yes // Reset caused by external reset pin

//--- Enumerated values for register SSRS0, field SPOR
  let RCM_SSRS0_SPOR_Reset_0 $bool = no // Reset not caused by POR
  let RCM_SSRS0_SPOR_Reset_1 $bool = yes // Reset caused by POR

//--- Enumerated values for register SSRS1, field SJTAG
  let RCM_SSRS1_SJTAG_Reset_0 $bool = no // Reset not caused by JTAG
  let RCM_SSRS1_SJTAG_Reset_1 $bool = yes // Reset caused by JTAG

//--- Enumerated values for register SSRS1, field SLOCKUP
  let RCM_SSRS1_SLOCKUP_Reset_0 $bool = no // Reset not caused by core LOCKUP event
  let RCM_SSRS1_SLOCKUP_Reset_1 $bool = yes // Reset caused by core LOCKUP event

//--- Enumerated values for register SSRS1, field SSW
  let RCM_SSRS1_SSW_Reset_0 $bool = no // Reset not caused by software setting of SYSRESETREQ bit
  let RCM_SSRS1_SSW_Reset_1 $bool = yes // Reset caused by software setting of SYSRESETREQ bit

//--- Enumerated values for register SSRS1, field SMDM_AP
  let RCM_SSRS1_SMDM_AP_Reset_0 $bool = no // Reset not caused by host debugger system setting of the System Reset Request bit
  let RCM_SSRS1_SMDM_AP_Reset_1 $bool = yes // Reset caused by host debugger system setting of the System Reset Request bit

//--- Enumerated values for register SSRS1, field SEZPT
  let RCM_SSRS1_SEZPT_Reset_0 $bool = no // Reset not caused by EzPort receiving the RESET command while the device is in EzPort mode
  let RCM_SSRS1_SEZPT_Reset_1 $bool = yes // Reset caused by EzPort receiving the RESET command while the device is in EzPort mode

//--- Enumerated values for register SSRS1, field SSACKERR
  let RCM_SSRS1_SSACKERR_Reset_0 $bool = no // Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
  let RCM_SSRS1_SSACKERR_Reset_1 $bool = yes // Reset caused by peripheral failure to acknowledge attempt to enter stop mode

//------------------------------------------------------------------------------
// Peripheral RFSYS: System register file
//------------------------------------------------------------------------------

registers ©RFSYS @at 0x40041000 {
//---  Registers REG(0,1,2,3,4,5,6,7): Register file register
  REG [8 @offset 0x0 @inc 0x4]
  REG0 @offset 0x0
  REG1 @offset 0x4
  REG2 @offset 0x8
  REG3 @offset 0xc
  REG4 @offset 0x10
  REG5 @offset 0x14
  REG6 @offset 0x18
  REG7 @offset 0x1c $u32 {
    HH:8 // at 24: High higher byte
    HL:8 // at 16: High lower byte
    LH:8 // at 8: Low higher byte
    LL:8 // at 0: Low lower byte
  }

}

//------------------------------------------------------------------------------
// Peripheral RFVBAT: VBAT register file
//------------------------------------------------------------------------------

registers ©RFVBAT @at 0x4003e000 {
//---  Registers REG(0,1,2,3,4,5,6,7): VBAT register file register
  REG [8 @offset 0x0 @inc 0x4]
  REG0 @offset 0x0
  REG1 @offset 0x4
  REG2 @offset 0x8
  REG3 @offset 0xc
  REG4 @offset 0x10
  REG5 @offset 0x14
  REG6 @offset 0x18
  REG7 @offset 0x1c $u32 {
    HH:8 // at 24: High higher byte
    HL:8 // at 16: High lower byte
    LH:8 // at 8: Low higher byte
    LL:8 // at 0: Low lower byte
  }

}

//------------------------------------------------------------------------------
// Peripheral RNG: Random Number Generator Accelerator
//------------------------------------------------------------------------------

registers ©RNG @at 0x400a0000 {
//---  Register CR: RNGA Control Register
  CR @offset 0x0 $u32 {
    27
    SLP // at 4: Sleep
    CLRI // at 3: Clear Interrupt
    INTM // at 2: Interrupt Mask
    HA // at 1: High Assurance
    GO // at 0: Go
  }

//---  Register SR: RNGA Status Register
  SR @offset 0x4 @ro $u32 {
    8
    OREG_SIZE:8 // at 16: Output Register Size
    OREG_LVL:8 // at 8: Output Register Level
    3
    SLP // at 4: Sleep
    ERRI // at 3: Error Interrupt
    ORU // at 2: Output Register Underflow
    LRS // at 1: Last Read Status
    SECV // at 0: Security Violation
  }

//---  Register ER: RNGA Entropy Register
  ER @offset 0x8 $u32 {
    EXT_ENT:32 // at 0: External Entropy
  }

//---  Register OR: RNGA Output Register
  OR @offset 0xc @ro $u32 {
    RANDOUT:32 // at 0: Random Output
  }

}

//--- Enumerated values for register CR, field GO
  let RNG_CR_GO_Disabled_0 $bool = no // Disabled
  let RNG_CR_GO_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register CR, field HA
  let RNG_CR_HA_Disabled_0 $bool = no // Disabled
  let RNG_CR_HA_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register CR, field INTM
  let RNG_CR_INTM_Not_0 $bool = no // Not masked
  let RNG_CR_INTM_Masked_1 $bool = yes // Masked

//--- Enumerated values for register CR, field CLRI
  let RNG_CR_CLRI_Do_0 $bool = no // Do not clear the interrupt.
  let RNG_CR_CLRI_Clear_1 $bool = yes // Clear the interrupt. When you write 1 to this field, RNGA then resets the error-interrupt indicator (SR[ERRI]). This bit always reads as 0.

//--- Enumerated values for register CR, field SLP
  let RNG_CR_SLP_Normal_0 $bool = no // Normal mode
  let RNG_CR_SLP_Sleep_1 $bool = yes // Sleep (low-power) mode

//--- Enumerated values for register SR, field SECV
  let RNG_SR_SECV_No_0 $bool = no // No security violation
  let RNG_SR_SECV_Security_1 $bool = yes // Security violation

//--- Enumerated values for register SR, field LRS
  let RNG_SR_LRS_No_0 $bool = no // No underflow
  let RNG_SR_LRS_Underflow_1 $bool = yes // Underflow

//--- Enumerated values for register SR, field ORU
  let RNG_SR_ORU_No_0 $bool = no // No underflow
  let RNG_SR_ORU_Underflow_1 $bool = yes // Underflow

//--- Enumerated values for register SR, field ERRI
  let RNG_SR_ERRI_No_0 $bool = no // No underflow
  let RNG_SR_ERRI_Underflow_1 $bool = yes // Underflow

//--- Enumerated values for register SR, field SLP
  let RNG_SR_SLP_Normal_0 $bool = no // Normal mode
  let RNG_SR_SLP_Sleep_1 $bool = yes // Sleep (low-power) mode

//--- Enumerated values for register SR, field OREG_LVL
  let RNG_SR_OREG_LVL_No_0 $u8 = 0 // No words (empty)
  let RNG_SR_OREG_LVL_One_1 $u8 = 1 // One word (valid)

//--- Enumerated values for register SR, field OREG_SIZE
  let RNG_SR_OREG_SIZE_One_1 $u8 = 1 // One word (this value is fixed)

//--- Enumerated values for register OR, field RANDOUT
  let RNG_OR_RANDOUT_Invalid_0 $u32 = 0 // Invalid data (if you read this field when it is 0 and SR[OREG_LVL] is 0, RNGA then writes 1 to SR[ERRI], SR[ORU], and SR[LRS]; when the error interrupt is not masked (CR[INTM]=0), RNGA also asserts an error interrupt request to the interrupt controller).

//------------------------------------------------------------------------------
// Peripheral RTC: Secure Real Time Clock
//------------------------------------------------------------------------------

registers ©RTC @at 0x4003d000 {
//---  Register TSR: RTC Time Seconds Register
  TSR @offset 0x0 $u32 {
    TSR:32 // at 0: Time Seconds Register
  }

//---  Register TPR: RTC Time Prescaler Register
  TPR @offset 0x4 $u32 {
    16
    TPR:16 // at 0: Time Prescaler Register
  }

//---  Register TAR: RTC Time Alarm Register
  TAR @offset 0x8 $u32 {
    TAR:32 // at 0: Time Alarm Register
  }

//---  Register TCR: RTC Time Compensation Register
  TCR @offset 0xc $u32 {
    CIC:8 // at 24: Compensation Interval Counter
    TCV:8 // at 16: Time Compensation Value
    CIR:8 // at 8: Compensation Interval Register
    TCR:8 // at 0: Time Compensation Register
  }

//---  Register CR: RTC Control Register
  CR @offset 0x10 $u32 {
    18
    SC2P // at 13: Oscillator 2pF Load Configure
    SC4P // at 12: Oscillator 4pF Load Configure
    SC8P // at 11: Oscillator 8pF Load Configure
    SC16P // at 10: Oscillator 16pF Load Configure
    CLKO // at 9: Clock Output
    OSCE // at 8: Oscillator Enable
    3
    WPS // at 4: Wakeup Pin Select
    UM // at 3: Update Mode
    SUP // at 2: Supervisor Access
    WPE // at 1: Wakeup Pin Enable
    SWR // at 0: Software Reset
  }

//---  Register SR: RTC Status Register
  SR @offset 0x14 $u32 {
    27
    TCE // at 4: Time Counter Enable
    MOF // at 3: Monotonic Overflow Flag
    TAF // at 2: Time Alarm Flag
    TOF // at 1: Time Overflow Flag
    TIF // at 0: Time Invalid Flag
  }

//---  Register LR: RTC Lock Register
  LR @offset 0x18 $u32 {
    20
    MCHL // at 11: Monotonic Counter High Lock
    MCLL // at 10: Monotonic Counter Low Lock
    MEL // at 9: Monotonic Enable Lock
    TTSL // at 8: Tamper Time Seconds Lock
    1
    LRL // at 6: Lock Register Lock
    SRL // at 5: Status Register Lock
    CRL // at 4: Control Register Lock
    TCL // at 3: Time Compensation Lock
    3
  }

//---  Register IER: RTC Interrupt Enable Register
  IER @offset 0x1c $u32 {
    24
    WPON // at 7: Wakeup Pin On
    2
    TSIE // at 4: Time Seconds Interrupt Enable
    MOIE // at 3: Monotonic Overflow Interrupt Enable
    TAIE // at 2: Time Alarm Interrupt Enable
    TOIE // at 1: Time Overflow Interrupt Enable
    TIIE // at 0: Time Invalid Interrupt Enable
  }

//---  Register TTSR: RTC Tamper Time Seconds Register
  TTSR @offset 0x20 @ro $u32 {
    TTS:32 // at 0: Tamper Time Seconds
  }

//---  Register MER: RTC Monotonic Enable Register
  MER @offset 0x24 $u32 {
    27
    MCE // at 4: Monotonic Counter Enable
    4
  }

//---  Register MCLR: RTC Monotonic Counter Low Register
  MCLR @offset 0x28 $u32 {
    MCL:32 // at 0: Monotonic Counter Low
  }

//---  Register MCHR: RTC Monotonic Counter High Register
  MCHR @offset 0x2c $u32 {
    MCH:32 // at 0: Monotonic Counter High
  }

//---  Register WAR: RTC Write Access Register
  WAR @offset 0x800 $u32 {
    20
    MCHW // at 11: Monotonic Counter High Write
    MCLW // at 10: Monotonic Counter Low Write
    MERW // at 9: Monotonic Enable Register Write
    TTSW // at 8: Tamper Time Seconds Write
    IERW // at 7: Interrupt Enable Register Write
    LRW // at 6: Lock Register Write
    SRW // at 5: Status Register Write
    CRW // at 4: Control Register Write
    TCRW // at 3: Time Compensation Register Write
    TARW // at 2: Time Alarm Register Write
    TPRW // at 1: Time Prescaler Register Write
    TSRW // at 0: Time Seconds Register Write
  }

//---  Register RAR: RTC Read Access Register
  RAR @offset 0x804 $u32 {
    20
    MCHR // at 11: Monotonic Counter High Read
    MCLR // at 10: Monotonic Counter Low Read
    MERR // at 9: Monotonic Enable Register Read
    TTSR // at 8: Tamper Time Seconds Read
    IERR // at 7: Interrupt Enable Register Read
    LRR // at 6: Lock Register Read
    SRR // at 5: Status Register Read
    CRR // at 4: Control Register Read
    TCRR // at 3: Time Compensation Register Read
    TARR // at 2: Time Alarm Register Read
    TPRR // at 1: Time Prescaler Register Read
    TSRR // at 0: Time Seconds Register Read
  }

}

//--- Enumerated values for register TCR, field TCR
  let RTC_TCR_TCR_Time_10000000 $u8 = 128 // Time Prescaler Register overflows every 32896 clock cycles.
  let RTC_TCR_TCR_Time_11111111 $u8 = 255 // Time Prescaler Register overflows every 32769 clock cycles.
  let RTC_TCR_TCR_Time_0 $u8 = 0 // Time Prescaler Register overflows every 32768 clock cycles.
  let RTC_TCR_TCR_Time_1 $u8 = 1 // Time Prescaler Register overflows every 32767 clock cycles.
  let RTC_TCR_TCR_Time_1111111 $u8 = 127 // Time Prescaler Register overflows every 32641 clock cycles.

//--- Enumerated values for register CR, field SWR
  let RTC_CR_SWR_No_0 $bool = no // No effect.
  let RTC_CR_SWR_Resets_1 $bool = yes // Resets all RTC registers except for the SWR bit and the RTC_WAR and RTC_RAR registers . The SWR bit is cleared by VBAT POR and by software explicitly clearing it.

//--- Enumerated values for register CR, field WPE
  let RTC_CR_WPE_Wakeup_0 $bool = no // Wakeup pin is disabled.
  let RTC_CR_WPE_Wakeup_1 $bool = yes // Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt asserts or the wakeup pin is turned on.

//--- Enumerated values for register CR, field SUP
  let RTC_CR_SUP_Non_supervisor_0 $bool = no // Non-supervisor mode write accesses are not supported and generate a bus error.
  let RTC_CR_SUP_Non_supervisor_1 $bool = yes // Non-supervisor mode write accesses are supported.

//--- Enumerated values for register CR, field UM
  let RTC_CR_UM_Registers_0 $bool = no // Registers cannot be written when locked.
  let RTC_CR_UM_Registers_1 $bool = yes // Registers can be written when locked under limited conditions.

//--- Enumerated values for register CR, field WPS
  let RTC_CR_WPS_Wakeup_0 $bool = no // Wakeup pin asserts (active low, open drain) if the RTC interrupt asserts or the wakeup pin is turned on.
  let RTC_CR_WPS_Wakeup_1 $bool = yes // Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup pin is turned on and the 32kHz clock is output to other peripherals.

//--- Enumerated values for register CR, field OSCE
  let RTC_CR_OSCE_32_768_0 $bool = no // 32.768 kHz oscillator is disabled.
  let RTC_CR_OSCE_32_768_1 $bool = yes // 32.768 kHz oscillator is enabled. After setting this bit, wait the oscillator startup time before enabling the time counter to allow the 32.768 kHz clock time to stabilize.

//--- Enumerated values for register CR, field CLKO
  let RTC_CR_CLKO_The_0 $bool = no // The 32 kHz clock is output to other peripherals.
  let RTC_CR_CLKO_The_1 $bool = yes // The 32 kHz clock is not output to other peripherals.

//--- Enumerated values for register CR, field SC16P
  let RTC_CR_SC16P_Disable_0 $bool = no // Disable the load.
  let RTC_CR_SC16P_Enable_1 $bool = yes // Enable the additional load.

//--- Enumerated values for register CR, field SC8P
  let RTC_CR_SC8P_Disable_0 $bool = no // Disable the load.
  let RTC_CR_SC8P_Enable_1 $bool = yes // Enable the additional load.

//--- Enumerated values for register CR, field SC4P
  let RTC_CR_SC4P_Disable_0 $bool = no // Disable the load.
  let RTC_CR_SC4P_Enable_1 $bool = yes // Enable the additional load.

//--- Enumerated values for register CR, field SC2P
  let RTC_CR_SC2P_Disable_0 $bool = no // Disable the load.
  let RTC_CR_SC2P_Enable_1 $bool = yes // Enable the additional load.

//--- Enumerated values for register SR, field TIF
  let RTC_SR_TIF_Time_0 $bool = no // Time is valid.
  let RTC_SR_TIF_Time_1 $bool = yes // Time is invalid and time counter is read as zero.

//--- Enumerated values for register SR, field TOF
  let RTC_SR_TOF_Time_0 $bool = no // Time overflow has not occurred.
  let RTC_SR_TOF_Time_1 $bool = yes // Time overflow has occurred and time counter is read as zero.

//--- Enumerated values for register SR, field TAF
  let RTC_SR_TAF_Time_0 $bool = no // Time alarm has not occurred.
  let RTC_SR_TAF_Time_1 $bool = yes // Time alarm has occurred.

//--- Enumerated values for register SR, field MOF
  let RTC_SR_MOF_Monotonic_0 $bool = no // Monotonic counter overflow has not occurred.
  let RTC_SR_MOF_Monotonic_1 $bool = yes // Monotonic counter overflow has occurred and monotonic counter is read as zero.

//--- Enumerated values for register SR, field TCE
  let RTC_SR_TCE_Time_0 $bool = no // Time counter is disabled.
  let RTC_SR_TCE_Time_1 $bool = yes // Time counter is enabled.

//--- Enumerated values for register LR, field TCL
  let RTC_LR_TCL_Time_0 $bool = no // Time Compensation Register is locked and writes are ignored.
  let RTC_LR_TCL_Time_1 $bool = yes // Time Compensation Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field CRL
  let RTC_LR_CRL_Control_0 $bool = no // Control Register is locked and writes are ignored.
  let RTC_LR_CRL_Control_1 $bool = yes // Control Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field SRL
  let RTC_LR_SRL_Status_0 $bool = no // Status Register is locked and writes are ignored.
  let RTC_LR_SRL_Status_1 $bool = yes // Status Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field LRL
  let RTC_LR_LRL_Lock_0 $bool = no // Lock Register is locked and writes are ignored.
  let RTC_LR_LRL_Lock_1 $bool = yes // Lock Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field TTSL
  let RTC_LR_TTSL_Tamper_0 $bool = no // Tamper Time Seconds Register is locked and writes are ignored.
  let RTC_LR_TTSL_Tamper_1 $bool = yes // Tamper Time Seconds Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field MEL
  let RTC_LR_MEL_Monotonic_0 $bool = no // Monotonic Enable Register is locked and writes are ignored.
  let RTC_LR_MEL_Monotonic_1 $bool = yes // Monotonic Enable Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field MCLL
  let RTC_LR_MCLL_Monotonic_0 $bool = no // Monotonic Counter Low Register is locked and writes are ignored.
  let RTC_LR_MCLL_Monotonic_1 $bool = yes // Monotonic Counter Low Register is not locked and writes complete as normal.

//--- Enumerated values for register LR, field MCHL
  let RTC_LR_MCHL_Monotonic_0 $bool = no // Monotonic Counter High Register is locked and writes are ignored.
  let RTC_LR_MCHL_Monotonic_1 $bool = yes // Monotonic Counter High Register is not locked and writes complete as normal.

//--- Enumerated values for register IER, field TIIE
  let RTC_IER_TIIE_Time_0 $bool = no // Time invalid flag does not generate an interrupt.
  let RTC_IER_TIIE_Time_1 $bool = yes // Time invalid flag does generate an interrupt.

//--- Enumerated values for register IER, field TOIE
  let RTC_IER_TOIE_Time_0 $bool = no // Time overflow flag does not generate an interrupt.
  let RTC_IER_TOIE_Time_1 $bool = yes // Time overflow flag does generate an interrupt.

//--- Enumerated values for register IER, field TAIE
  let RTC_IER_TAIE_Time_0 $bool = no // Time alarm flag does not generate an interrupt.
  let RTC_IER_TAIE_Time_1 $bool = yes // Time alarm flag does generate an interrupt.

//--- Enumerated values for register IER, field MOIE
  let RTC_IER_MOIE_Monotonic_0 $bool = no // Monotonic overflow flag does not generate an interrupt.
  let RTC_IER_MOIE_Monotonic_1 $bool = yes // Monotonic overflow flag does generate an interrupt.

//--- Enumerated values for register IER, field TSIE
  let RTC_IER_TSIE_Seconds_0 $bool = no // Seconds interrupt is disabled.
  let RTC_IER_TSIE_Seconds_1 $bool = yes // Seconds interrupt is enabled.

//--- Enumerated values for register IER, field WPON
  let RTC_IER_WPON_No_0 $bool = no // No effect.
  let RTC_IER_WPON_If_1 $bool = yes // If the wakeup pin is enabled, then the wakeup pin will assert.

//--- Enumerated values for register MER, field MCE
  let RTC_MER_MCE_Writes_0 $bool = no // Writes to the monotonic counter load the counter with the value written.
  let RTC_MER_MCE_Writes_1 $bool = yes // Writes to the monotonic counter increment the counter.

//--- Enumerated values for register WAR, field TSRW
  let RTC_WAR_TSRW_Writes_0 $bool = no // Writes to the Time Seconds Register are ignored.
  let RTC_WAR_TSRW_Writes_1 $bool = yes // Writes to the Time Seconds Register complete as normal.

//--- Enumerated values for register WAR, field TPRW
  let RTC_WAR_TPRW_Writes_0 $bool = no // Writes to the Time Prescaler Register are ignored.
  let RTC_WAR_TPRW_Writes_1 $bool = yes // Writes to the Time Prescaler Register complete as normal.

//--- Enumerated values for register WAR, field TARW
  let RTC_WAR_TARW_Writes_0 $bool = no // Writes to the Time Alarm Register are ignored.
  let RTC_WAR_TARW_Writes_1 $bool = yes // Writes to the Time Alarm Register complete as normal.

//--- Enumerated values for register WAR, field TCRW
  let RTC_WAR_TCRW_Writes_0 $bool = no // Writes to the Time Compensation Register are ignored.
  let RTC_WAR_TCRW_Writes_1 $bool = yes // Writes to the Time Compensation Register complete as normal.

//--- Enumerated values for register WAR, field CRW
  let RTC_WAR_CRW_Writes_0 $bool = no // Writes to the Control Register are ignored.
  let RTC_WAR_CRW_Writes_1 $bool = yes // Writes to the Control Register complete as normal.

//--- Enumerated values for register WAR, field SRW
  let RTC_WAR_SRW_Writes_0 $bool = no // Writes to the Status Register are ignored.
  let RTC_WAR_SRW_Writes_1 $bool = yes // Writes to the Status Register complete as normal.

//--- Enumerated values for register WAR, field LRW
  let RTC_WAR_LRW_Writes_0 $bool = no // Writes to the Lock Register are ignored.
  let RTC_WAR_LRW_Writes_1 $bool = yes // Writes to the Lock Register complete as normal.

//--- Enumerated values for register WAR, field IERW
  let RTC_WAR_IERW_Writes_0 $bool = no // Writes to the Interupt Enable Register are ignored.
  let RTC_WAR_IERW_Writes_1 $bool = yes // Writes to the Interrupt Enable Register complete as normal.

//--- Enumerated values for register WAR, field TTSW
  let RTC_WAR_TTSW_Writes_0 $bool = no // Writes to the Tamper Time Seconds Register are ignored.
  let RTC_WAR_TTSW_Writes_1 $bool = yes // Writes to the Tamper Time Seconds Register complete as normal.

//--- Enumerated values for register WAR, field MERW
  let RTC_WAR_MERW_Writes_0 $bool = no // Writes to the Monotonic Enable Register are ignored.
  let RTC_WAR_MERW_Writes_1 $bool = yes // Writes to the Monotonic Enable Register complete as normal.

//--- Enumerated values for register WAR, field MCLW
  let RTC_WAR_MCLW_Writes_0 $bool = no // Writes to the Monotonic Counter Low Register are ignored.
  let RTC_WAR_MCLW_Writes_1 $bool = yes // Writes to the Monotonic Counter Low Register complete as normal.

//--- Enumerated values for register WAR, field MCHW
  let RTC_WAR_MCHW_Writes_0 $bool = no // Writes to the Monotonic Counter High Register are ignored.
  let RTC_WAR_MCHW_Writes_1 $bool = yes // Writes to the Monotonic Counter High Register complete as normal.

//--- Enumerated values for register RAR, field TSRR
  let RTC_RAR_TSRR_Reads_0 $bool = no // Reads to the Time Seconds Register are ignored.
  let RTC_RAR_TSRR_Reads_1 $bool = yes // Reads to the Time Seconds Register complete as normal.

//--- Enumerated values for register RAR, field TPRR
  let RTC_RAR_TPRR_Reads_0 $bool = no // Reads to the Time Pprescaler Register are ignored.
  let RTC_RAR_TPRR_Reads_1 $bool = yes // Reads to the Time Prescaler Register complete as normal.

//--- Enumerated values for register RAR, field TARR
  let RTC_RAR_TARR_Reads_0 $bool = no // Reads to the Time Alarm Register are ignored.
  let RTC_RAR_TARR_Reads_1 $bool = yes // Reads to the Time Alarm Register complete as normal.

//--- Enumerated values for register RAR, field TCRR
  let RTC_RAR_TCRR_Reads_0 $bool = no // Reads to the Time Compensation Register are ignored.
  let RTC_RAR_TCRR_Reads_1 $bool = yes // Reads to the Time Compensation Register complete as normal.

//--- Enumerated values for register RAR, field CRR
  let RTC_RAR_CRR_Reads_0 $bool = no // Reads to the Control Register are ignored.
  let RTC_RAR_CRR_Reads_1 $bool = yes // Reads to the Control Register complete as normal.

//--- Enumerated values for register RAR, field SRR
  let RTC_RAR_SRR_Reads_0 $bool = no // Reads to the Status Register are ignored.
  let RTC_RAR_SRR_Reads_1 $bool = yes // Reads to the Status Register complete as normal.

//--- Enumerated values for register RAR, field LRR
  let RTC_RAR_LRR_Reads_0 $bool = no // Reads to the Lock Register are ignored.
  let RTC_RAR_LRR_Reads_1 $bool = yes // Reads to the Lock Register complete as normal.

//--- Enumerated values for register RAR, field IERR
  let RTC_RAR_IERR_Reads_0 $bool = no // Reads to the Interrupt Enable Register are ignored.
  let RTC_RAR_IERR_Reads_1 $bool = yes // Reads to the Interrupt Enable Register complete as normal.

//--- Enumerated values for register RAR, field TTSR
  let RTC_RAR_TTSR_Reads_0 $bool = no // Reads to the Tamper Time Seconds Register are ignored.
  let RTC_RAR_TTSR_Reads_1 $bool = yes // Reads to the Tamper Time Seconds Register complete as normal.

//--- Enumerated values for register RAR, field MERR
  let RTC_RAR_MERR_Reads_0 $bool = no // Reads to the Monotonic Enable Register are ignored.
  let RTC_RAR_MERR_Reads_1 $bool = yes // Reads to the Monotonic Enable Register complete as normal.

//--- Enumerated values for register RAR, field MCLR
  let RTC_RAR_MCLR_Reads_0 $bool = no // Reads to the Monotonic Counter Low Register are ignored.
  let RTC_RAR_MCLR_Reads_1 $bool = yes // Reads to the Monotonic Counter Low Register complete as normal.

//--- Enumerated values for register RAR, field MCHR
  let RTC_RAR_MCHR_Reads_0 $bool = no // Reads to the Monotonic Counter High Register are ignored.
  let RTC_RAR_MCHR_Reads_1 $bool = yes // Reads to the Monotonic Counter High Register complete as normal.

//------------------------------------------------------------------------------
// Peripheral SDHC: Secured Digital Host Controller
//------------------------------------------------------------------------------

registers ©SDHC @at 0x400b1000 {
//---  Register DSADDR: DMA System Address register
  DSADDR @offset 0x0 $u32 {
    DSADDR:30 // at 2: DMA System Address
    2
  }

//---  Register BLKATTR: Block Attributes register
  BLKATTR @offset 0x4 $u32 {
    BLKCNT:16 // at 16: Blocks Count For Current Transfer
    3
    BLKSIZE:13 // at 0: Transfer Block Size
  }

//---  Register CMDARG: Command Argument register
  CMDARG @offset 0x8 $u32 {
    CMDARG:32 // at 0: Command Argument
  }

//---  Register XFERTYP: Transfer Type register
  XFERTYP @offset 0xc $u32 {
    2
    CMDINX:6 // at 24: Command Index
    CMDTYP:2 // at 22: Command Type
    DPSEL // at 21: Data Present Select
    CICEN // at 20: Command Index Check Enable
    CCCEN // at 19: Command CRC Check Enable
    1
    RSPTYP:2 // at 16: Response Type Select
    10
    MSBSEL // at 5: Multi/Single Block Select
    DTDSEL // at 4: Data Transfer Direction Select
    1
    AC12EN // at 2: Auto CMD12 Enable
    BCEN // at 1: Block Count Enable
    DMAEN // at 0: DMA Enable
  }

//---  Register CMDRSP0: Command Response 0
  CMDRSP0 @offset 0x10 @ro $u32 {
    CMDRSP0:32 // at 0: Command Response 0
  }

//---  Register CMDRSP1: Command Response 1
  CMDRSP1 @offset 0x14 @ro $u32 {
    CMDRSP1:32 // at 0: Command Response 1
  }

//---  Register CMDRSP2: Command Response 2
  CMDRSP2 @offset 0x18 @ro $u32 {
    CMDRSP2:32 // at 0: Command Response 2
  }

//---  Register CMDRSP3: Command Response 3
  CMDRSP3 @offset 0x1c @ro $u32 {
    CMDRSP3:32 // at 0: Command Response 3
  }

//---  Register DATPORT: Buffer Data Port register
  DATPORT @offset 0x20 $u32 {
    DATCONT:32 // at 0: Data Content
  }

//---  Register PRSSTAT: Present State register
  PRSSTAT @offset 0x24 @ro $u32 {
    DLSL:8 // at 24: DAT Line Signal Level
    CLSL // at 23: CMD Line Signal Level
    6
    CINS // at 16: Card Inserted
    4
    BREN // at 11: Buffer Read Enable
    BWEN // at 10: Buffer Write Enable
    RTA // at 9: Read Transfer Active
    WTA // at 8: Write Transfer Active
    SDOFF // at 7: SD Clock Gated Off Internally
    PEROFF // at 6: SDHC clock Gated Off Internally
    HCKOFF // at 5: System Clock Gated Off Internally
    IPGOFF // at 4: Bus Clock Gated Off Internally
    SDSTB // at 3: SD Clock Stable
    DLA // at 2: Data Line Active
    CDIHB // at 1: Command Inhibit (DAT)
    CIHB // at 0: Command Inhibit (CMD)
  }

//---  Register PROCTL: Protocol Control register
  PROCTL @offset 0x28 $u32 {
    5
    WECRM // at 26: Wakeup Event Enable On SD Card Removal
    WECINS // at 25: Wakeup Event Enable On SD Card Insertion
    WECINT // at 24: Wakeup Event Enable On Card Interrupt
    4
    IABG // at 19: Interrupt At Block Gap
    RWCTL // at 18: Read Wait Control
    CREQ // at 17: Continue Request
    SABGREQ // at 16: Stop At Block Gap Request
    6
    DMAS:2 // at 8: DMA Select
    CDSS // at 7: Card Detect Signal Selection
    CDTL // at 6: Card Detect Test Level
    EMODE:2 // at 4: Endian Mode
    D3CD // at 3: DAT3 As Card Detection Pin
    DTW:2 // at 1: Data Transfer Width
    LCTL // at 0: LED Control
  }

//---  Register SYSCTL: System Control register
  SYSCTL @offset 0x2c $u32 {
    4
    INITA // at 27: Initialization Active
    RSTD // at 26: Software Reset For DAT Line
    RSTC // at 25: Software Reset For CMD Line
    RSTA // at 24: Software Reset For ALL
    4
    DTOCV:4 // at 16: Data Timeout Counter Value
    SDCLKFS:8 // at 8: SDCLK Frequency Select
    DVS:4 // at 4: Divisor
    SDCLKEN // at 3: SD Clock Enable
    PEREN // at 2: Peripheral Clock Enable
    HCKEN // at 1: System Clock Enable
    IPGEN // at 0: IPG Clock Enable
  }

//---  Register IRQSTAT: Interrupt Status register
  IRQSTAT @offset 0x30 $u32 {
    3
    DMAE // at 28: DMA Error
    3
    AC12E // at 24: Auto CMD12 Error
    1
    DEBE // at 22: Data End Bit Error
    DCE // at 21: Data CRC Error
    DTOE // at 20: Data Timeout Error
    CIE // at 19: Command Index Error
    CEBE // at 18: Command End Bit Error
    CCE // at 17: Command CRC Error
    CTOE // at 16: Command Timeout Error
    7
    CINT // at 8: Card Interrupt
    CRM // at 7: Card Removal
    CINS // at 6: Card Insertion
    BRR // at 5: Buffer Read Ready
    BWR // at 4: Buffer Write Ready
    DINT // at 3: DMA Interrupt
    BGE // at 2: Block Gap Event
    TC // at 1: Transfer Complete
    CC // at 0: Command Complete
  }

//---  Register IRQSTATEN: Interrupt Status Enable register
  IRQSTATEN @offset 0x34 $u32 {
    3
    DMAESEN // at 28: DMA Error Status Enable
    3
    AC12ESEN // at 24: Auto CMD12 Error Status Enable
    1
    DEBESEN // at 22: Data End Bit Error Status Enable
    DCESEN // at 21: Data CRC Error Status Enable
    DTOESEN // at 20: Data Timeout Error Status Enable
    CIESEN // at 19: Command Index Error Status Enable
    CEBESEN // at 18: Command End Bit Error Status Enable
    CCESEN // at 17: Command CRC Error Status Enable
    CTOESEN // at 16: Command Timeout Error Status Enable
    7
    CINTSEN // at 8: Card Interrupt Status Enable
    CRMSEN // at 7: Card Removal Status Enable
    CINSEN // at 6: Card Insertion Status Enable
    BRRSEN // at 5: Buffer Read Ready Status Enable
    BWRSEN // at 4: Buffer Write Ready Status Enable
    DINTSEN // at 3: DMA Interrupt Status Enable
    BGESEN // at 2: Block Gap Event Status Enable
    TCSEN // at 1: Transfer Complete Status Enable
    CCSEN // at 0: Command Complete Status Enable
  }

//---  Register IRQSIGEN: Interrupt Signal Enable register
  IRQSIGEN @offset 0x38 $u32 {
    3
    DMAEIEN // at 28: DMA Error Interrupt Enable
    3
    AC12EIEN // at 24: Auto CMD12 Error Interrupt Enable
    1
    DEBEIEN // at 22: Data End Bit Error Interrupt Enable
    DCEIEN // at 21: Data CRC Error Interrupt Enable
    DTOEIEN // at 20: Data Timeout Error Interrupt Enable
    CIEIEN // at 19: Command Index Error Interrupt Enable
    CEBEIEN // at 18: Command End Bit Error Interrupt Enable
    CCEIEN // at 17: Command CRC Error Interrupt Enable
    CTOEIEN // at 16: Command Timeout Error Interrupt Enable
    7
    CINTIEN // at 8: Card Interrupt Enable
    CRMIEN // at 7: Card Removal Interrupt Enable
    CINSIEN // at 6: Card Insertion Interrupt Enable
    BRRIEN // at 5: Buffer Read Ready Interrupt Enable
    BWRIEN // at 4: Buffer Write Ready Interrupt Enable
    DINTIEN // at 3: DMA Interrupt Enable
    BGEIEN // at 2: Block Gap Event Interrupt Enable
    TCIEN // at 1: Transfer Complete Interrupt Enable
    CCIEN // at 0: Command Complete Interrupt Enable
  }

//---  Register AC12ERR: Auto CMD12 Error Status Register
  AC12ERR @offset 0x3c @ro $u32 {
    24
    CNIBAC12E // at 7: Command Not Issued By Auto CMD12 Error
    2
    AC12IE // at 4: Auto CMD12 Index Error
    AC12CE // at 3: Auto CMD12 CRC Error
    AC12EBE // at 2: Auto CMD12 End Bit Error
    AC12TOE // at 1: Auto CMD12 Timeout Error
    AC12NE // at 0: Auto CMD12 Not Executed
  }

//---  Register HTCAPBLT: Host Controller Capabilities
  HTCAPBLT @offset 0x40 @ro $u32 {
    7
    VS33 // at 24: Voltage Support 3.3 V
    SRS // at 23: Suspend/Resume Support
    DMAS // at 22: DMA Support
    HSS // at 21: High Speed Support
    ADMAS // at 20: ADMA Support
    1
    MBL:3 // at 16: Max Block Length
    16
  }

//---  Register WML: Watermark Level Register
  WML @offset 0x44 $u32 {
    8
    WRWML:8 // at 16: Write Watermark Level
    8
    RDWML:8 // at 0: Read Watermark Level
  }

//---  Register FEVT: Force Event register
  FEVT @offset 0x50 $u32 {
    CINT // at 31: Force Event Card Interrupt
    2
    DMAE // at 28: Force Event DMA Error
    3
    AC12E // at 24: Force Event Auto Command 12 Error
    1
    DEBE // at 22: Force Event Data End Bit Error
    DCE // at 21: Force Event Data CRC Error
    DTOE // at 20: Force Event Data Time Out Error
    CIE // at 19: Force Event Command Index Error
    CEBE // at 18: Force Event Command End Bit Error
    CCE // at 17: Force Event Command CRC Error
    CTOE // at 16: Force Event Command Time Out Error
    8
    CNIBAC12E // at 7: Force Event Command Not Executed By Auto Command 12 Error
    2
    AC12IE // at 4: Force Event Auto Command 12 Index Error
    AC12EBE // at 3: Force Event Auto Command 12 End Bit Error
    AC12CE // at 2: Force Event Auto Command 12 CRC Error
    AC12TOE // at 1: Force Event Auto Command 12 Time Out Error
    AC12NE // at 0: Force Event Auto Command 12 Not Executed
  }

//---  Register ADMAES: ADMA Error Status register
  ADMAES @offset 0x54 @ro $u32 {
    28
    ADMADCE // at 3: ADMA Descriptor Error
    ADMALME // at 2: ADMA Length Mismatch Error
    ADMAES:2 // at 0: ADMA Error State (When ADMA Error Is Occurred.)
  }

//---  Register ADSADDR: ADMA System Addressregister
  ADSADDR @offset 0x58 $u32 {
    ADSADDR:30 // at 2: ADMA System Address
    2
  }

//---  Register VENDOR: Vendor Specific register
  VENDOR @offset 0xc0 $u32 {
    8
    INTSTVAL:8 // at 16: Internal State Value
    14
    EXBLKNU // at 1: Exact Block Number Block Read Enable For SDIO CMD53
    1
  }

//---  Register MMCBOOT: MMC Boot register
  MMCBOOT @offset 0xc4 $u32 {
    BOOTBLKCNT:16 // at 16: Defines the stop at block gap value of automatic mode
    8
    AUTOSABGEN // at 7: When boot, enable auto stop at block gap function
    BOOTEN // at 6: Boot Mode Enable
    BOOTMODE // at 5: Boot Mode Select
    BOOTACK // at 4: Boot Ack Mode Select
    DTOCVACK:4 // at 0: Boot ACK Time Out Counter Value
  }

//---  Register HOSTVER: Host Controller Version
  HOSTVER @offset 0xfc @ro $u32 {
    16
    VVN:8 // at 8: Vendor Version Number
    SVN:8 // at 0: Specification Version Number
  }

}

//--- Enumerated values for register BLKATTR, field BLKSIZE
  let SDHC_BLKATTR_BLKSIZE_No_0 $u13 = 0 // No data transfer.
  let SDHC_BLKATTR_BLKSIZE_1_1 $u13 = 1 // 1 Byte
  let SDHC_BLKATTR_BLKSIZE_2_10 $u13 = 2 // 2 Bytes
  let SDHC_BLKATTR_BLKSIZE_3_11 $u13 = 3 // 3 Bytes
  let SDHC_BLKATTR_BLKSIZE_4_100 $u13 = 4 // 4 Bytes
  let SDHC_BLKATTR_BLKSIZE_511_111111111 $u13 = 511 // 511 Bytes
  let SDHC_BLKATTR_BLKSIZE_512_1000000000 $u13 = 512 // 512 Bytes
  let SDHC_BLKATTR_BLKSIZE_2048_100000000000 $u13 = 2048 // 2048 Bytes
  let SDHC_BLKATTR_BLKSIZE_4096_1000000000000 $u13 = 4096 // 4096 Bytes

//--- Enumerated values for register BLKATTR, field BLKCNT
  let SDHC_BLKATTR_BLKCNT_Stop_0 $u16 = 0 // Stop count.
  let SDHC_BLKATTR_BLKCNT_1_1 $u16 = 1 // 1 block
  let SDHC_BLKATTR_BLKCNT_2_10 $u16 = 2 // 2 blocks
  let SDHC_BLKATTR_BLKCNT_65535_1111111111111111 $u16 = 65535 // 65535 blocks

//--- Enumerated values for register XFERTYP, field DMAEN
  let SDHC_XFERTYP_DMAEN_Disable_0 $bool = no // Disable
  let SDHC_XFERTYP_DMAEN_Enable_1 $bool = yes // Enable

//--- Enumerated values for register XFERTYP, field BCEN
  let SDHC_XFERTYP_BCEN_Disable_0 $bool = no // Disable
  let SDHC_XFERTYP_BCEN_Enable_1 $bool = yes // Enable

//--- Enumerated values for register XFERTYP, field AC12EN
  let SDHC_XFERTYP_AC12EN_Disable_0 $bool = no // Disable
  let SDHC_XFERTYP_AC12EN_Enable_1 $bool = yes // Enable

//--- Enumerated values for register XFERTYP, field DTDSEL
  let SDHC_XFERTYP_DTDSEL_Write_0 $bool = no // Write host to card.
  let SDHC_XFERTYP_DTDSEL_Read_1 $bool = yes // Read card to host.

//--- Enumerated values for register XFERTYP, field MSBSEL
  let SDHC_XFERTYP_MSBSEL_Single_0 $bool = no // Single block.
  let SDHC_XFERTYP_MSBSEL_Multiple_1 $bool = yes // Multiple blocks.

//--- Enumerated values for register XFERTYP, field RSPTYP
  let SDHC_XFERTYP_RSPTYP_No_00 $u2 = 0 // No response.
  let SDHC_XFERTYP_RSPTYP_Response_01 $u2 = 1 // Response length 136.
  let SDHC_XFERTYP_RSPTYP_Response_10 $u2 = 2 // Response length 48.
  let SDHC_XFERTYP_RSPTYP_Response_11 $u2 = 3 // Response length 48, check busy after response.

//--- Enumerated values for register XFERTYP, field CCCEN
  let SDHC_XFERTYP_CCCEN_Disable_0 $bool = no // Disable
  let SDHC_XFERTYP_CCCEN_Enable_1 $bool = yes // Enable

//--- Enumerated values for register XFERTYP, field CICEN
  let SDHC_XFERTYP_CICEN_Disable_0 $bool = no // Disable
  let SDHC_XFERTYP_CICEN_Enable_1 $bool = yes // Enable

//--- Enumerated values for register XFERTYP, field DPSEL
  let SDHC_XFERTYP_DPSEL_No_0 $bool = no // No data present.
  let SDHC_XFERTYP_DPSEL_Data_1 $bool = yes // Data present.

//--- Enumerated values for register XFERTYP, field CMDTYP
  let SDHC_XFERTYP_CMDTYP_Normal_00 $u2 = 0 // Normal other commands.
  let SDHC_XFERTYP_CMDTYP_Suspend_01 $u2 = 1 // Suspend CMD52 for writing bus suspend in CCCR.
  let SDHC_XFERTYP_CMDTYP_Resume_10 $u2 = 2 // Resume CMD52 for writing function select in CCCR.
  let SDHC_XFERTYP_CMDTYP_Abort_11 $u2 = 3 // Abort CMD12, CMD52 for writing I/O abort in CCCR.

//--- Enumerated values for register PRSSTAT, field CIHB
  let SDHC_PRSSTAT_CIHB_Can_0 $bool = no // Can issue command using only CMD line.
  let SDHC_PRSSTAT_CIHB_Cannot_1 $bool = yes // Cannot issue command.

//--- Enumerated values for register PRSSTAT, field CDIHB
  let SDHC_PRSSTAT_CDIHB_Can_0 $bool = no // Can issue command which uses the DAT line.
  let SDHC_PRSSTAT_CDIHB_Cannot_1 $bool = yes // Cannot issue command which uses the DAT line.

//--- Enumerated values for register PRSSTAT, field DLA
  let SDHC_PRSSTAT_DLA_DAT_0 $bool = no // DAT line inactive.
  let SDHC_PRSSTAT_DLA_DAT_1 $bool = yes // DAT line active.

//--- Enumerated values for register PRSSTAT, field SDSTB
  let SDHC_PRSSTAT_SDSTB_Clock_0 $bool = no // Clock is changing frequency and not stable.
  let SDHC_PRSSTAT_SDSTB_Clock_1 $bool = yes // Clock is stable.

//--- Enumerated values for register PRSSTAT, field IPGOFF
  let SDHC_PRSSTAT_IPGOFF_Bus_0 $bool = no // Bus clock is active.
  let SDHC_PRSSTAT_IPGOFF_Bus_1 $bool = yes // Bus clock is gated off.

//--- Enumerated values for register PRSSTAT, field HCKOFF
  let SDHC_PRSSTAT_HCKOFF_System_0 $bool = no // System clock is active.
  let SDHC_PRSSTAT_HCKOFF_System_1 $bool = yes // System clock is gated off.

//--- Enumerated values for register PRSSTAT, field PEROFF
  let SDHC_PRSSTAT_PEROFF_SDHC_0 $bool = no // SDHC clock is active.
  let SDHC_PRSSTAT_PEROFF_SDHC_1 $bool = yes // SDHC clock is gated off.

//--- Enumerated values for register PRSSTAT, field SDOFF
  let SDHC_PRSSTAT_SDOFF_SD_0 $bool = no // SD clock is active.
  let SDHC_PRSSTAT_SDOFF_SD_1 $bool = yes // SD clock is gated off.

//--- Enumerated values for register PRSSTAT, field WTA
  let SDHC_PRSSTAT_WTA_No_0 $bool = no // No valid data.
  let SDHC_PRSSTAT_WTA_Transferring_1 $bool = yes // Transferring data.

//--- Enumerated values for register PRSSTAT, field RTA
  let SDHC_PRSSTAT_RTA_No_0 $bool = no // No valid data.
  let SDHC_PRSSTAT_RTA_Transferring_1 $bool = yes // Transferring data.

//--- Enumerated values for register PRSSTAT, field BWEN
  let SDHC_PRSSTAT_BWEN_Write_0 $bool = no // Write disable, the buffer can hold valid data less than the write watermark level.
  let SDHC_PRSSTAT_BWEN_Write_1 $bool = yes // Write enable, the buffer can hold valid data greater than the write watermark level.

//--- Enumerated values for register PRSSTAT, field BREN
  let SDHC_PRSSTAT_BREN_Read_0 $bool = no // Read disable, valid data less than the watermark level exist in the buffer.
  let SDHC_PRSSTAT_BREN_Read_1 $bool = yes // Read enable, valid data greater than the watermark level exist in the buffer.

//--- Enumerated values for register PRSSTAT, field CINS
  let SDHC_PRSSTAT_CINS_Power_0 $bool = no // Power on reset or no card.
  let SDHC_PRSSTAT_CINS_Card_1 $bool = yes // Card inserted.

//--- Enumerated values for register PROCTL, field LCTL
  let SDHC_PROCTL_LCTL_LED_0 $bool = no // LED off.
  let SDHC_PROCTL_LCTL_LED_1 $bool = yes // LED on.

//--- Enumerated values for register PROCTL, field DTW
  let SDHC_PROCTL_DTW_1_bit_00 $u2 = 0 // 1-bit mode
  let SDHC_PROCTL_DTW_4_bit_01 $u2 = 1 // 4-bit mode
  let SDHC_PROCTL_DTW_8_bit_10 $u2 = 2 // 8-bit mode

//--- Enumerated values for register PROCTL, field D3CD
  let SDHC_PROCTL_D3CD_DAT3_0 $bool = no // DAT3 does not monitor card Insertion.
  let SDHC_PROCTL_D3CD_DAT3_1 $bool = yes // DAT3 as card detection pin.

//--- Enumerated values for register PROCTL, field EMODE
  let SDHC_PROCTL_EMODE_Big_00 $u2 = 0 // Big endian mode
  let SDHC_PROCTL_EMODE_Half_01 $u2 = 1 // Half word big endian mode
  let SDHC_PROCTL_EMODE_Little_10 $u2 = 2 // Little endian mode

//--- Enumerated values for register PROCTL, field CDTL
  let SDHC_PROCTL_CDTL_Card_0 $bool = no // Card detect test level is 0, no card inserted.
  let SDHC_PROCTL_CDTL_Card_1 $bool = yes // Card detect test level is 1, card inserted.

//--- Enumerated values for register PROCTL, field CDSS
  let SDHC_PROCTL_CDSS_Card_0 $bool = no // Card detection level is selected for normal purpose.
  let SDHC_PROCTL_CDSS_Card_1 $bool = yes // Card detection test level is selected for test purpose.

//--- Enumerated values for register PROCTL, field DMAS
  let SDHC_PROCTL_DMAS_No_00 $u2 = 0 // No DMA or simple DMA is selected.
  let SDHC_PROCTL_DMAS_ADMA1_01 $u2 = 1 // ADMA1 is selected.
  let SDHC_PROCTL_DMAS_ADMA2_10 $u2 = 2 // ADMA2 is selected.

//--- Enumerated values for register PROCTL, field SABGREQ
  let SDHC_PROCTL_SABGREQ_Transfer_0 $bool = no // Transfer
  let SDHC_PROCTL_SABGREQ_Stop_1 $bool = yes // Stop

//--- Enumerated values for register PROCTL, field CREQ
  let SDHC_PROCTL_CREQ_No_0 $bool = no // No effect.
  let SDHC_PROCTL_CREQ_Restart_1 $bool = yes // Restart

//--- Enumerated values for register PROCTL, field RWCTL
  let SDHC_PROCTL_RWCTL_Disable_0 $bool = no // Disable read wait control, and stop SD clock at block gap when SABGREQ is set.
  let SDHC_PROCTL_RWCTL_Enable_1 $bool = yes // Enable read wait control, and assert read wait without stopping SD clock at block gap when SABGREQ bit is set.

//--- Enumerated values for register PROCTL, field IABG
  let SDHC_PROCTL_IABG_Disabled_0 $bool = no // Disabled
  let SDHC_PROCTL_IABG_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register PROCTL, field WECINT
  let SDHC_PROCTL_WECINT_Disabled_0 $bool = no // Disabled
  let SDHC_PROCTL_WECINT_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register PROCTL, field WECINS
  let SDHC_PROCTL_WECINS_Disabled_0 $bool = no // Disabled
  let SDHC_PROCTL_WECINS_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register PROCTL, field WECRM
  let SDHC_PROCTL_WECRM_Disabled_0 $bool = no // Disabled
  let SDHC_PROCTL_WECRM_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register SYSCTL, field IPGEN
  let SDHC_SYSCTL_IPGEN_Bus_0 $bool = no // Bus clock will be internally gated off.
  let SDHC_SYSCTL_IPGEN_Bus_1 $bool = yes // Bus clock will not be automatically gated off.

//--- Enumerated values for register SYSCTL, field HCKEN
  let SDHC_SYSCTL_HCKEN_System_0 $bool = no // System clock will be internally gated off.
  let SDHC_SYSCTL_HCKEN_System_1 $bool = yes // System clock will not be automatically gated off.

//--- Enumerated values for register SYSCTL, field PEREN
  let SDHC_SYSCTL_PEREN_SDHC_0 $bool = no // SDHC clock will be internally gated off.
  let SDHC_SYSCTL_PEREN_SDHC_1 $bool = yes // SDHC clock will not be automatically gated off.

//--- Enumerated values for register SYSCTL, field DVS
  let SDHC_SYSCTL_DVS_Divisor_0 $u4 = 0 // Divisor by 1.
  let SDHC_SYSCTL_DVS_Divisor_1 $u4 = 1 // Divisor by 2.
  let SDHC_SYSCTL_DVS_Divisor_1110 $u4 = 14 // Divisor by 15.
  let SDHC_SYSCTL_DVS_Divisor_1111 $u4 = 15 // Divisor by 16.

//--- Enumerated values for register SYSCTL, field SDCLKFS
  let SDHC_SYSCTL_SDCLKFS_Base_1 $u8 = 1 // Base clock divided by 2.
  let SDHC_SYSCTL_SDCLKFS_Base_10 $u8 = 2 // Base clock divided by 4.
  let SDHC_SYSCTL_SDCLKFS_Base_100 $u8 = 4 // Base clock divided by 8.
  let SDHC_SYSCTL_SDCLKFS_Base_1000 $u8 = 8 // Base clock divided by 16.
  let SDHC_SYSCTL_SDCLKFS_Base_10000 $u8 = 16 // Base clock divided by 32.
  let SDHC_SYSCTL_SDCLKFS_Base_100000 $u8 = 32 // Base clock divided by 64.
  let SDHC_SYSCTL_SDCLKFS_Base_1000000 $u8 = 64 // Base clock divided by 128.
  let SDHC_SYSCTL_SDCLKFS_Base_10000000 $u8 = 128 // Base clock divided by 256.

//--- Enumerated values for register SYSCTL, field DTOCV
  let SDHC_SYSCTL_DTOCV_SDCLK_0000 $u4 = 0 // SDCLK x 2 13
  let SDHC_SYSCTL_DTOCV_SDCLK_0001 $u4 = 1 // SDCLK x 2 14
  let SDHC_SYSCTL_DTOCV_SDCLK_1110 $u4 = 14 // SDCLK x 2 27

//--- Enumerated values for register SYSCTL, field RSTA
  let SDHC_SYSCTL_RSTA_No_0 $bool = no // No reset.
  let SDHC_SYSCTL_RSTA_Reset__1 $bool = yes // Reset.

//--- Enumerated values for register SYSCTL, field RSTC
  let SDHC_SYSCTL_RSTC_No_0 $bool = no // No reset.
  let SDHC_SYSCTL_RSTC_Reset__1 $bool = yes // Reset.

//--- Enumerated values for register SYSCTL, field RSTD
  let SDHC_SYSCTL_RSTD_No_0 $bool = no // No reset.
  let SDHC_SYSCTL_RSTD_Reset__1 $bool = yes // Reset.

//--- Enumerated values for register IRQSTAT, field CC
  let SDHC_IRQSTAT_CC_Command_0 $bool = no // Command not complete.
  let SDHC_IRQSTAT_CC_Command_1 $bool = yes // Command complete.

//--- Enumerated values for register IRQSTAT, field TC
  let SDHC_IRQSTAT_TC_Transfer_0 $bool = no // Transfer not complete.
  let SDHC_IRQSTAT_TC_Transfer_1 $bool = yes // Transfer complete.

//--- Enumerated values for register IRQSTAT, field BGE
  let SDHC_IRQSTAT_BGE_No_0 $bool = no // No block gap event.
  let SDHC_IRQSTAT_BGE_Transaction_1 $bool = yes // Transaction stopped at block gap.

//--- Enumerated values for register IRQSTAT, field DINT
  let SDHC_IRQSTAT_DINT_No_0 $bool = no // No DMA Interrupt.
  let SDHC_IRQSTAT_DINT_DMA_1 $bool = yes // DMA Interrupt is generated.

//--- Enumerated values for register IRQSTAT, field BWR
  let SDHC_IRQSTAT_BWR_Not_0 $bool = no // Not ready to write buffer.
  let SDHC_IRQSTAT_BWR_Ready_1 $bool = yes // Ready to write buffer.

//--- Enumerated values for register IRQSTAT, field BRR
  let SDHC_IRQSTAT_BRR_Not_0 $bool = no // Not ready to read buffer.
  let SDHC_IRQSTAT_BRR_Ready_1 $bool = yes // Ready to read buffer.

//--- Enumerated values for register IRQSTAT, field CINS
  let SDHC_IRQSTAT_CINS_Card_0 $bool = no // Card state unstable or removed.
  let SDHC_IRQSTAT_CINS_Card_1 $bool = yes // Card inserted.

//--- Enumerated values for register IRQSTAT, field CRM
  let SDHC_IRQSTAT_CRM_Card_0 $bool = no // Card state unstable or inserted.
  let SDHC_IRQSTAT_CRM_Card_1 $bool = yes // Card removed.

//--- Enumerated values for register IRQSTAT, field CINT
  let SDHC_IRQSTAT_CINT_No_0 $bool = no // No Card Interrupt.
  let SDHC_IRQSTAT_CINT_Generate_1 $bool = yes // Generate Card Interrupt.

//--- Enumerated values for register IRQSTAT, field CTOE
  let SDHC_IRQSTAT_CTOE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_CTOE_Time_1 $bool = yes // Time out.

//--- Enumerated values for register IRQSTAT, field CCE
  let SDHC_IRQSTAT_CCE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_CCE_CRC_1 $bool = yes // CRC Error generated.

//--- Enumerated values for register IRQSTAT, field CEBE
  let SDHC_IRQSTAT_CEBE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_CEBE_End_1 $bool = yes // End Bit Error generated.

//--- Enumerated values for register IRQSTAT, field CIE
  let SDHC_IRQSTAT_CIE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_CIE_Error__1 $bool = yes // Error.

//--- Enumerated values for register IRQSTAT, field DTOE
  let SDHC_IRQSTAT_DTOE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_DTOE_Time_1 $bool = yes // Time out.

//--- Enumerated values for register IRQSTAT, field DCE
  let SDHC_IRQSTAT_DCE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_DCE_Error__1 $bool = yes // Error.

//--- Enumerated values for register IRQSTAT, field DEBE
  let SDHC_IRQSTAT_DEBE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_DEBE_Error__1 $bool = yes // Error.

//--- Enumerated values for register IRQSTAT, field AC12E
  let SDHC_IRQSTAT_AC12E_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_AC12E_Error__1 $bool = yes // Error.

//--- Enumerated values for register IRQSTAT, field DMAE
  let SDHC_IRQSTAT_DMAE_No_0 $bool = no // No error.
  let SDHC_IRQSTAT_DMAE_Error__1 $bool = yes // Error.

//--- Enumerated values for register IRQSTATEN, field CCSEN
  let SDHC_IRQSTATEN_CCSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CCSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field TCSEN
  let SDHC_IRQSTATEN_TCSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_TCSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field BGESEN
  let SDHC_IRQSTATEN_BGESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_BGESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field DINTSEN
  let SDHC_IRQSTATEN_DINTSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_DINTSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field BWRSEN
  let SDHC_IRQSTATEN_BWRSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_BWRSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field BRRSEN
  let SDHC_IRQSTATEN_BRRSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_BRRSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CINSEN
  let SDHC_IRQSTATEN_CINSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CINSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CRMSEN
  let SDHC_IRQSTATEN_CRMSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CRMSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CINTSEN
  let SDHC_IRQSTATEN_CINTSEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CINTSEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CTOESEN
  let SDHC_IRQSTATEN_CTOESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CTOESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CCESEN
  let SDHC_IRQSTATEN_CCESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CCESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CEBESEN
  let SDHC_IRQSTATEN_CEBESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CEBESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field CIESEN
  let SDHC_IRQSTATEN_CIESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_CIESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field DTOESEN
  let SDHC_IRQSTATEN_DTOESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_DTOESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field DCESEN
  let SDHC_IRQSTATEN_DCESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_DCESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field DEBESEN
  let SDHC_IRQSTATEN_DEBESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_DEBESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field AC12ESEN
  let SDHC_IRQSTATEN_AC12ESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_AC12ESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSTATEN, field DMAESEN
  let SDHC_IRQSTATEN_DMAESEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSTATEN_DMAESEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CCIEN
  let SDHC_IRQSIGEN_CCIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CCIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field TCIEN
  let SDHC_IRQSIGEN_TCIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_TCIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field BGEIEN
  let SDHC_IRQSIGEN_BGEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_BGEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field DINTIEN
  let SDHC_IRQSIGEN_DINTIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_DINTIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field BWRIEN
  let SDHC_IRQSIGEN_BWRIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_BWRIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field BRRIEN
  let SDHC_IRQSIGEN_BRRIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_BRRIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CINSIEN
  let SDHC_IRQSIGEN_CINSIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CINSIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CRMIEN
  let SDHC_IRQSIGEN_CRMIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CRMIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CINTIEN
  let SDHC_IRQSIGEN_CINTIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CINTIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CTOEIEN
  let SDHC_IRQSIGEN_CTOEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CTOEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CCEIEN
  let SDHC_IRQSIGEN_CCEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CCEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CEBEIEN
  let SDHC_IRQSIGEN_CEBEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CEBEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field CIEIEN
  let SDHC_IRQSIGEN_CIEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_CIEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field DTOEIEN
  let SDHC_IRQSIGEN_DTOEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_DTOEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field DCEIEN
  let SDHC_IRQSIGEN_DCEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_DCEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field DEBEIEN
  let SDHC_IRQSIGEN_DEBEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_DEBEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field AC12EIEN
  let SDHC_IRQSIGEN_AC12EIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_AC12EIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register IRQSIGEN, field DMAEIEN
  let SDHC_IRQSIGEN_DMAEIEN_Masked_0 $bool = no // Masked
  let SDHC_IRQSIGEN_DMAEIEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register AC12ERR, field AC12NE
  let SDHC_AC12ERR_AC12NE_Executed__0 $bool = no // Executed.
  let SDHC_AC12ERR_AC12NE_Not_1 $bool = yes // Not executed.

//--- Enumerated values for register AC12ERR, field AC12TOE
  let SDHC_AC12ERR_AC12TOE_No_0 $bool = no // No error.
  let SDHC_AC12ERR_AC12TOE_Time_1 $bool = yes // Time out.

//--- Enumerated values for register AC12ERR, field AC12EBE
  let SDHC_AC12ERR_AC12EBE_No_0 $bool = no // No error.
  let SDHC_AC12ERR_AC12EBE_End_1 $bool = yes // End bit error generated.

//--- Enumerated values for register AC12ERR, field AC12CE
  let SDHC_AC12ERR_AC12CE_No_0 $bool = no // No CRC error.
  let SDHC_AC12ERR_AC12CE_CRC_1 $bool = yes // CRC error met in Auto CMD12 response.

//--- Enumerated values for register AC12ERR, field AC12IE
  let SDHC_AC12ERR_AC12IE_No_0 $bool = no // No error.
  let SDHC_AC12ERR_AC12IE_Error__1 $bool = yes // Error, the CMD index in response is not CMD12.

//--- Enumerated values for register AC12ERR, field CNIBAC12E
  let SDHC_AC12ERR_CNIBAC12E_No_0 $bool = no // No error.
  let SDHC_AC12ERR_CNIBAC12E_Not_1 $bool = yes // Not issued.

//--- Enumerated values for register HTCAPBLT, field MBL
  let SDHC_HTCAPBLT_MBL_512_000 $u3 = 0 // 512 bytes
  let SDHC_HTCAPBLT_MBL_1024_001 $u3 = 1 // 1024 bytes
  let SDHC_HTCAPBLT_MBL_2048_010 $u3 = 2 // 2048 bytes
  let SDHC_HTCAPBLT_MBL_4096_011 $u3 = 3 // 4096 bytes

//--- Enumerated values for register HTCAPBLT, field ADMAS
  let SDHC_HTCAPBLT_ADMAS_Advanced_0 $bool = no // Advanced DMA not supported.
  let SDHC_HTCAPBLT_ADMAS_Advanced_1 $bool = yes // Advanced DMA supported.

//--- Enumerated values for register HTCAPBLT, field HSS
  let SDHC_HTCAPBLT_HSS_High_0 $bool = no // High speed not supported.
  let SDHC_HTCAPBLT_HSS_High_1 $bool = yes // High speed supported.

//--- Enumerated values for register HTCAPBLT, field DMAS
  let SDHC_HTCAPBLT_DMAS_DMA_0 $bool = no // DMA not supported.
  let SDHC_HTCAPBLT_DMAS_DMA_1 $bool = yes // DMA supported.

//--- Enumerated values for register HTCAPBLT, field SRS
  let SDHC_HTCAPBLT_SRS_Not_0 $bool = no // Not supported.
  let SDHC_HTCAPBLT_SRS_Supported__1 $bool = yes // Supported.

//--- Enumerated values for register HTCAPBLT, field VS33
  let SDHC_HTCAPBLT_VS33_3_3_0 $bool = no // 3.3 V not supported.
  let SDHC_HTCAPBLT_VS33_3_3_1 $bool = yes // 3.3 V supported.

//--- Enumerated values for register ADMAES, field ADMALME
  let SDHC_ADMAES_ADMALME_No_0 $bool = no // No error.
  let SDHC_ADMAES_ADMALME_Error__1 $bool = yes // Error.

//--- Enumerated values for register ADMAES, field ADMADCE
  let SDHC_ADMAES_ADMADCE_No_0 $bool = no // No error.
  let SDHC_ADMAES_ADMADCE_Error__1 $bool = yes // Error.

//--- Enumerated values for register VENDOR, field EXBLKNU
  let SDHC_VENDOR_EXBLKNU_None_0 $bool = no // None exact block read.
  let SDHC_VENDOR_EXBLKNU_Exact_1 $bool = yes // Exact block read for SDIO CMD53.

//--- Enumerated values for register MMCBOOT, field DTOCVACK
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0000 $u4 = 0 // SDCLK x 2^8
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0001 $u4 = 1 // SDCLK x 2^9
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0010 $u4 = 2 // SDCLK x 2^10
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0011 $u4 = 3 // SDCLK x 2^11
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0100 $u4 = 4 // SDCLK x 2^12
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0101 $u4 = 5 // SDCLK x 2^13
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0110 $u4 = 6 // SDCLK x 2^14
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_0111 $u4 = 7 // SDCLK x 2^15
  let SDHC_MMCBOOT_DTOCVACK_SDCLK_1110 $u4 = 14 // SDCLK x 2^22

//--- Enumerated values for register MMCBOOT, field BOOTACK
  let SDHC_MMCBOOT_BOOTACK_No_0 $bool = no // No ack.
  let SDHC_MMCBOOT_BOOTACK_Ack__1 $bool = yes // Ack.

//--- Enumerated values for register MMCBOOT, field BOOTMODE
  let SDHC_MMCBOOT_BOOTMODE_Normal_0 $bool = no // Normal boot.
  let SDHC_MMCBOOT_BOOTMODE_Alternative_1 $bool = yes // Alternative boot.

//--- Enumerated values for register MMCBOOT, field BOOTEN
  let SDHC_MMCBOOT_BOOTEN_Fast_0 $bool = no // Fast boot disable.
  let SDHC_MMCBOOT_BOOTEN_Fast_1 $bool = yes // Fast boot enable.

//--- Enumerated values for register HOSTVER, field SVN
  let SDHC_HOSTVER_SVN_SD_1 $u8 = 1 // SD host specification version 2.0, supports test event register and ADMA.

//--- Enumerated values for register HOSTVER, field VVN
  let SDHC_HOSTVER_VVN_Freescale_0 $u8 = 0 // Freescale SDHC version 1.0
  let SDHC_HOSTVER_VVN_Freescale_10000 $u8 = 16 // Freescale SDHC version 2.0
  let SDHC_HOSTVER_VVN_Freescale_10001 $u8 = 17 // Freescale SDHC version 2.1
  let SDHC_HOSTVER_VVN_Freescale_10010 $u8 = 18 // Freescale SDHC version 2.2

//------------------------------------------------------------------------------
// Peripheral SDRAM: Synchronous DRAM Controller
//------------------------------------------------------------------------------

registers ©SDRAM @at 0x4000f000 {
//---  Register CTRL: Control Register
  CTRL @offset 0x42 $u16 {
    4
    IS // at 11: Initiate self-refresh command.
    RTIM:2 // at 9: Refresh timing
    RC:9 // at 0: Refresh count
  }

//---  Registers AC(0,1): Address and Control Register
  AC [2 @offset 0x48 @inc 0x8]
  AC0 @offset 0x48
  AC1 @offset 0x50 $u32 {
    BA:14 // at 18: Base address register.
    2
    RE // at 15: Refresh enable
    1
    CASL:2 // at 12: CAS Latency
    1
    CBM:3 // at 8: Command bit location
    1
    IMRS // at 6: Initiate mode register set (mrs) command.
    PS:2 // at 4: Port size.
    IP // at 3: Initiate precharge all (pall) command.
    3
  }

//---  Registers CM(0,1): Control Mask
  CM [2 @offset 0x4c @inc 0x8]
  CM0 @offset 0x4c
  CM1 @offset 0x54 $u32 {
    BAM:14 // at 18: Base address mask.
    9
    WP // at 8: Write protect.
    7
    V // at 0: Valid.
  }

}

//--- Enumerated values for register CTRL, field RTIM
  let SDRAM_CTRL_RTIM_3_00 $u2 = 0 // 3 clocks
  let SDRAM_CTRL_RTIM_6_01 $u2 = 1 // 6 clocks
  let SDRAM_CTRL_RTIM_9_10 $u2 = 2 // 9 clocks
  let SDRAM_CTRL_RTIM_9_11 $u2 = 3 // 9 clocks

//--- Enumerated values for register CTRL, field IS
  let SDRAM_CTRL_IS_Take_0 $bool = no // Take no action or issue a selfx command to exit self refresh.
  let SDRAM_CTRL_IS_SDRAM_1 $bool = yes // SDRAM controller sends a self command to both SDRAM blocks to put them in low-power, self-refresh state where they remain until IS is cleared. When IS is cleared, the controller sends a selfx command for the SDRAMs to exit self-refresh. The refresh counter is suspended while the SDRAMs are in self-refresh; the SDRAM controls the refresh period.

//--- Enumerated values for register AC%s, field IP
  let SDRAM_AC_IP_Take_0 $bool = no // Take no action.
  let SDRAM_AC_IP_A_1 $bool = yes // A pall command is sent to the associated SDRAM block. During initialization, this command is executed after all DRAM controller registers are programmed. After IP is set, the next write to an appropriate SDRAM address generates the pall command to the SDRAM block.

//--- Enumerated values for register AC%s, field PS
  let SDRAM_AC_PS_32_bit_00 $u2 = 0 // 32-bit port
  let SDRAM_AC_PS_8_bit_01 $u2 = 1 // 8-bit port
  let SDRAM_AC_PS_16_bit_10 $u2 = 2 // 16-bit port
  let SDRAM_AC_PS_16_bit_11 $u2 = 3 // 16-bit port

//--- Enumerated values for register AC%s, field IMRS
  let SDRAM_AC_IMRS_Take_0 $bool = no // Take no action
  let SDRAM_AC_IMRS_Initiate_1 $bool = yes // Initiate mrs command

//--- Enumerated values for register AC%s, field RE
  let SDRAM_AC_RE_Do_0 $bool = no // Do not refresh associated DRAM block
  let SDRAM_AC_RE_Refresh_1 $bool = yes // Refresh associated DRAM block

//--- Enumerated values for register CM%s, field V
  let SDRAM_CM_V_Do_0 $bool = no // Do not decode DRAM accesses.
  let SDRAM_CM_V_Registers_1 $bool = yes // Registers controlling the DRAM block are initialized; DRAM accesses can be decoded

//--- Enumerated values for register CM%s, field WP
  let SDRAM_CM_WP_Allow_0 $bool = no // Allow write accesses
  let SDRAM_CM_WP_Ignore_1 $bool = yes // Ignore write accesses. The DRAM controller ignores write accesses to the memory block and an address exception occurs. Write accesses to a write-protected DRAM region are compared in the chip select module for a hit. If no hit occurs, an external bus cycle is generated. If this external bus cycle is not acknowledged, an access exception occurs.

//--- Enumerated values for register CM%s, field BAM
  let SDRAM_CM_BAM_The_0 $u14 = 0 // The associated address bit is used in decoding the DRAM hit to a memory block
  let SDRAM_CM_BAM_The_1 $u14 = 1 // The associated address bit is not used in the DRAM hit decode

//------------------------------------------------------------------------------
// Peripheral SIM: System Integration Module
//------------------------------------------------------------------------------

registers ©SIM @at 0x40047000 {
//---  Register SOPT1: System Options Register 1
  SOPT1 @offset 0x0 $u32 {
    USBREGEN // at 31: USB voltage regulator enable
    USBSSTBY // at 30: USB voltage regulator in standby mode during Stop, VLPS, LLS and VLLS modes.
    USBVSTBY // at 29: USB voltage regulator in standby mode during VLPR and VLPW modes
    9
    OSC32KSEL:2 // at 18: 32K oscillator clock select
    2
    RAMSIZE:4 // at 12: RAM size
    12
  }

//---  Register SOPT1CFG: SOPT1 Configuration Register
  SOPT1CFG @offset 0x4 $u32 {
    5
    USSWE // at 26: USB voltage regulator stop standby write enable
    UVSWE // at 25: USB voltage regulator VLP standby write enable
    URWE // at 24: USB voltage regulator enable write enable
    24
  }

//---  Register USBPHYCTL: USB PHY Control Register
  USBPHYCTL @offset 0x8 $u32 {
    8
    USBDISILIM // at 23: USB Disable Inrush Current Limit
    USB3VOUTTRG:3 // at 20: USB 3.3V Output Target
    10
    USBVREGPD // at 9: Enables the pulldown on the output of the USB Regulator.
    USBVREGSEL // at 8: Selects the default input voltage source to the USB Regulator in case both VREG_IN0 and VREG_IN1 are powered
    8
  }

//---  Register SOPT2: System Options Register 2
  SOPT2 @offset 0x1004 $u32 {
    2
    SDHCSRC:2 // at 28: SDHC clock source select
    LPUARTSRC:2 // at 26: LPUART clock source select
    TPMSRC:2 // at 24: TPM clock source select
    2
    TIMESRC:2 // at 20: IEEE 1588 timestamp clock source select
    RMIISRC // at 19: RMII clock source select
    USBSRC // at 18: USB clock source select
    PLLFLLSEL:2 // at 16: PLL/FLL clock select
    3
    TRACECLKSEL // at 12: Debug trace clock select
    2
    FBSL:2 // at 8: FlexBus security level
    CLKOUTSEL:3 // at 5: CLKOUT select
    RTCCLKOUTSEL // at 4: RTC clock out select
    2
    USBREGEN // at 1: USB PHY PLL Regulator Enable
    USBSLSRC // at 0: USB Slow Clock Source
  }

//---  Register SOPT4: System Options Register 4
  SOPT4 @offset 0x100c $u32 {
    FTM3TRG1SRC // at 31: FlexTimer 3 Hardware Trigger 1 Source Select
    FTM3TRG0SRC // at 30: FlexTimer 3 Hardware Trigger 0 Source Select
    FTM0TRG1SRC // at 29: FlexTimer 0 Hardware Trigger 1 Source Select
    FTM0TRG0SRC // at 28: FlexTimer 0 Hardware Trigger 0 Source Select
    FTM3CLKSEL // at 27: FlexTimer 3 External Clock Pin Select
    FTM2CLKSEL // at 26: FlexTimer 2 External Clock Pin Select
    FTM1CLKSEL // at 25: FTM1 External Clock Pin Select
    FTM0CLKSEL // at 24: FlexTimer 0 External Clock Pin Select
    1
    FTM2CH1SRC // at 22: FTM2 channel 1 input capture source select
    FTM2CH0SRC:2 // at 20: FTM2 channel 0 input capture source select
    FTM1CH0SRC:2 // at 18: FTM1 channel 0 input capture source select
    5
    FTM3FLT0 // at 12: FTM3 Fault 0 Select
    3
    FTM2FLT0 // at 8: FTM2 Fault 0 Select
    3
    FTM1FLT0 // at 4: FTM1 Fault 0 Select
    FTM0FLT3 // at 3: FTM0 Fault 3 Select
    FTM0FLT2 // at 2: FTM0 Fault 2 Select
    FTM0FLT1 // at 1: FTM0 Fault 1 Select
    FTM0FLT0 // at 0: FTM0 Fault 0 Select
  }

//---  Register SOPT5: System Options Register 5
  SOPT5 @offset 0x1010 $u32 {
    12
    LPUART0RXSRC:2 // at 18: LPUART0 receive data source select
    LPUART0TXSRC:2 // at 16: LPUART0 transmit data source select
    8
    UART1RXSRC:2 // at 6: UART 1 receive data source select
    UART1TXSRC:2 // at 4: UART 1 transmit data source select
    UART0RXSRC:2 // at 2: UART 0 receive data source select
    UART0TXSRC:2 // at 0: UART 0 transmit data source select
  }

//---  Register SOPT7: System Options Register 7
  SOPT7 @offset 0x1018 $u32 {
    16
    ADC1ALTTRGEN // at 15: ADC1 alternate trigger enable
    2
    ADC1PRETRGSEL // at 12: ADC1 pre-trigger select
    ADC1TRGSEL:4 // at 8: ADC1 trigger select
    ADC0ALTTRGEN // at 7: ADC0 alternate trigger enable
    2
    ADC0PRETRGSEL // at 4: ADC0 pretrigger select
    ADC0TRGSEL:4 // at 0: ADC0 trigger select
  }

//---  Register SOPT8: System Options Register 8
  SOPT8 @offset 0x101c $u32 {
    FTM3OCH7SRC // at 31: FTM3 channel 7 output source
    FTM3OCH6SRC // at 30: FTM3 channel 6 output source
    FTM3OCH5SRC // at 29: FTM3 channel 5 output source
    FTM3OCH4SRC // at 28: FTM3 channel 4 output source
    FTM3OCH3SRC // at 27: FTM3 channel 3 output source
    FTM3OCH2SRC // at 26: FTM3 channel 2 output source
    FTM3OCH1SRC // at 25: FTM3 channel 1 output source
    FTM3OCH0SRC // at 24: FTM3 channel 0 output source
    FTM0OCH7SRC // at 23: FTM0 channel 7 output source
    FTM0OCH6SRC // at 22: FTM0 channel 6 output source
    FTM0OCH5SRC // at 21: FTM0 channel 5 output source
    FTM0OCH4SRC // at 20: FTM0 channel 4 output source
    FTM0OCH3SRC // at 19: FTM0 channel 3 output source
    FTM0OCH2SRC // at 18: FTM0 channel 2 output source
    FTM0OCH1SRC // at 17: FTM0 channel 1 output source
    FTM0OCH0SRC // at 16: FTM0 channel 0 output source
    12
    FTM3SYNCBIT // at 3: FTM3 Hardware Trigger 0 Software Synchronization
    FTM2SYNCBIT // at 2: FTM2 Hardware Trigger 0 Software Synchronization
    FTM1SYNCBIT // at 1: FTM1 Hardware Trigger 0 Software Synchronization
    FTM0SYNCBIT // at 0: FTM0 Hardware Trigger 0 Software Synchronization
  }

//---  Register SOPT9: System Options Register 9
  SOPT9 @offset 0x1020 $u32 {
    5
    TPM2CLKSEL // at 26: TPM2 External Clock Pin Select
    TPM1CLKSEL // at 25: TPM1 External Clock Pin Select
    3
    TPM2CH0SRC:2 // at 20: TPM2 channel 0 input capture source select
    TPM1CH0SRC:2 // at 18: TPM1 channel 0 input capture source select
    18
  }

//---  Register SDID: System Device Identification Register
  SDID @offset 0x1024 @ro $u32 {
    FAMILYID:4 // at 28: Kinetis Family ID
    SUBFAMID:4 // at 24: Kinetis Sub-Family ID
    SERIESID:4 // at 20: Kinetis Series ID
    4
    REVID:4 // at 12: Device revision number
    DIEID:5 // at 7: Device Die ID
    FAMID:3 // at 4: Kinetis family identification
    PINID:4 // at 0: Pincount identification
  }

//---  Register SCGC1: System Clock Gating Control Register 1
  SCGC1 @offset 0x1028 $u32 {
    21
    UART4 // at 10: UART4 Clock Gate Control
    2
    I2C3 // at 7: I2C3 Clock Gate Control
    I2C2 // at 6: I2C2 Clock Gate Control
    6
  }

//---  Register SCGC2: System Clock Gating Control Register 2
  SCGC2 @offset 0x102c $u32 {
    18
    DAC1 // at 13: DAC1 Clock Gate Control
    DAC0 // at 12: DAC0 Clock Gate Control
    1
    TPM2 // at 10: TPM2 Clock Gate Control
    TPM1 // at 9: TPM1 Clock Gate Control
    4
    LPUART0 // at 4: LPUART0 Clock Gate Control
    3
    ENET // at 0: ENET Clock Gate Control
  }

//---  Register SCGC3: System Clock Gating Control Register 3
  SCGC3 @offset 0x1030 $u32 {
    4
    ADC1 // at 27: ADC1 Clock Gate Control
    1
    FTM3 // at 25: FTM3 Clock Gate Control
    FTM2 // at 24: FTM2 Clock Gate Control
    6
    SDHC // at 17: SDHC Clock Gate Control
    4
    SPI2 // at 12: SPI2 Clock Gate Control
    7
    FLEXCAN1 // at 4: FlexCAN1 Clock Gate Control
    USBHSDCD // at 3: USBHS DCD Clock Gate Control
    USBHSPHY // at 2: USBHS PHY Clock Gate Control
    USBHS // at 1: USBHS Clock Gate Control
    RNGA // at 0: RNGA Clock Gate Control
  }

//---  Register SCGC4: System Clock Gating Control Register 4
  SCGC4 @offset 0x1034 $u32 {
    11
    VREF // at 20: VREF Clock Gate Control
    CMP // at 19: Comparator Clock Gate Control
    USBOTG // at 18: USB Clock Gate Control
    4
    UART3 // at 13: UART3 Clock Gate Control
    UART2 // at 12: UART2 Clock Gate Control
    UART1 // at 11: UART1 Clock Gate Control
    UART0 // at 10: UART0 Clock Gate Control
    2
    I2C1 // at 7: I2C1 Clock Gate Control
    I2C0 // at 6: I2C0 Clock Gate Control
    3
    CMT // at 2: CMT Clock Gate Control
    EWM // at 1: EWM Clock Gate Control
    1
  }

//---  Register SCGC5: System Clock Gating Control Register 5
  SCGC5 @offset 0x1038 $u32 {
    18
    PORTE // at 13: Port E Clock Gate Control
    PORTD // at 12: Port D Clock Gate Control
    PORTC // at 11: Port C Clock Gate Control
    PORTB // at 10: Port B Clock Gate Control
    PORTA // at 9: Port A Clock Gate Control
    3
    TSI // at 5: TSI Clock Gate Control
    4
    LPTMR // at 0: Low Power Timer Access Control
  }

//---  Register SCGC6: System Clock Gating Control Register 6
  SCGC6 @offset 0x103c $u32 {
    DAC0 // at 31: DAC0 Clock Gate Control
    1
    RTC // at 29: RTC Access Control
    1
    ADC0 // at 27: ADC0 Clock Gate Control
    FTM2 // at 26: FTM2 Clock Gate Control
    FTM1 // at 25: FTM1 Clock Gate Control
    FTM0 // at 24: FTM0 Clock Gate Control
    PIT // at 23: PIT Clock Gate Control
    PDB // at 22: PDB Clock Gate Control
    USBDCD // at 21: USB DCD Clock Gate Control
    2
    CRC // at 18: CRC Clock Gate Control
    2
    I2S // at 15: I2S Clock Gate Control
    1
    SPI1 // at 13: SPI1 Clock Gate Control
    SPI0 // at 12: SPI0 Clock Gate Control
    2
    RNGA // at 9: RNGA Clock Gate Control
    4
    FLEXCAN0 // at 4: FlexCAN0 Clock Gate Control
    2
    DMAMUX // at 1: DMA Mux Clock Gate Control
    FTF // at 0: Flash Memory Clock Gate Control
  }

//---  Register SCGC7: System Clock Gating Control Register 7
  SCGC7 @offset 0x1040 $u32 {
    28
    SDRAMC // at 3: SDRAMC Clock Gate Control
    MPU // at 2: MPU Clock Gate Control
    DMA // at 1: DMA Clock Gate Control
    FLEXBUS // at 0: FlexBus Clock Gate Control
  }

//---  Register CLKDIV1: System Clock Divider Register 1
  CLKDIV1 @offset 0x1044 $u32 {
    OUTDIV1:4 // at 28: Clock 1 output divider value
    OUTDIV2:4 // at 24: Clock 2 output divider value
    OUTDIV3:4 // at 20: Clock 3 output divider value
    OUTDIV4:4 // at 16: Clock 4 output divider value
    16
  }

//---  Register CLKDIV2: System Clock Divider Register 2
  CLKDIV2 @offset 0x1048 $u32 {
    28
    USBDIV:3 // at 1: USB clock divider divisor
    USBFRAC // at 0: USB clock divider fraction
  }

//---  Register FCFG1: Flash Configuration Register 1
  FCFG1 @offset 0x104c $u32 {
    NVMSIZE:4 // at 28: FlexNVM size
    PFSIZE:4 // at 24: Program flash size
    4
    EESIZE:4 // at 16: EEPROM size
    4
    DEPART:4 // at 8: FlexNVM partition
    6
    FLASHDOZE // at 1: Flash Doze
    FLASHDIS // at 0: Flash Disable
  }

//---  Register FCFG2: Flash Configuration Register 2
  FCFG2 @offset 0x1050 @ro $u32 {
    SWAPPFLSH // at 31: Swap program flash
    MAXADDR0:7 // at 24: Max address block 0
    PFLSH // at 23: Program flash only
    MAXADDR1:7 // at 16: Max address block 1
    16
  }

//---  Register UIDH: Unique Identification Register High
  UIDH @offset 0x1054 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDMH: Unique Identification Register Mid-High
  UIDMH @offset 0x1058 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDML: Unique Identification Register Mid Low
  UIDML @offset 0x105c @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register UIDL: Unique Identification Register Low
  UIDL @offset 0x1060 @ro $u32 {
    UID:32 // at 0: Unique Identification
  }

//---  Register CLKDIV3: System Clock Divider Register 3
  CLKDIV3 @offset 0x1064 $u32 {
    28
    PLLFLLDIV:3 // at 1: PLLFLL clock divider divisor
    PLLFLLFRAC // at 0: PLLFLL clock divider fraction
  }

//---  Register CLKDIV4: System Clock Divider Register 4
  CLKDIV4 @offset 0x1068 $u32 {
    28
    TRACEDIV:3 // at 1: Trace clock divider divisor
    TRACEFRAC // at 0: Trace clock divider fraction
  }

}

//--- Enumerated values for register SOPT1, field RAMSIZE
  let SIM_SOPT1_RAMSIZE_8_0001 $u4 = 1 // 8 KB
  let SIM_SOPT1_RAMSIZE_16_0011 $u4 = 3 // 16 KB
  let SIM_SOPT1_RAMSIZE_24_0100 $u4 = 4 // 24 KB
  let SIM_SOPT1_RAMSIZE_32_0101 $u4 = 5 // 32 KB
  let SIM_SOPT1_RAMSIZE_48_0110 $u4 = 6 // 48 KB
  let SIM_SOPT1_RAMSIZE_64_0111 $u4 = 7 // 64 KB
  let SIM_SOPT1_RAMSIZE_96_1000 $u4 = 8 // 96 KB
  let SIM_SOPT1_RAMSIZE_128_1001 $u4 = 9 // 128 KB
  let SIM_SOPT1_RAMSIZE_256_1011 $u4 = 11 // 256 KB

//--- Enumerated values for register SOPT1, field OSC32KSEL
  let SIM_SOPT1_OSC32KSEL_System_00 $u2 = 0 // System oscillator (OSC32KCLK)
  let SIM_SOPT1_OSC32KSEL_RTC_10 $u2 = 2 // RTC 32.768kHz oscillator
  let SIM_SOPT1_OSC32KSEL_LPO_11 $u2 = 3 // LPO 1 kHz

//--- Enumerated values for register SOPT1, field USBVSTBY
  let SIM_SOPT1_USBVSTBY_USB_0 $bool = no // USB voltage regulator not in standby during VLPR and VLPW modes.
  let SIM_SOPT1_USBVSTBY_USB_1 $bool = yes // USB voltage regulator in standby during VLPR and VLPW modes.

//--- Enumerated values for register SOPT1, field USBSSTBY
  let SIM_SOPT1_USBSSTBY_USB_0 $bool = no // USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS modes.
  let SIM_SOPT1_USBSSTBY_USB_1 $bool = yes // USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.

//--- Enumerated values for register SOPT1, field USBREGEN
  let SIM_SOPT1_USBREGEN_USB_0 $bool = no // USB voltage regulator is disabled.
  let SIM_SOPT1_USBREGEN_USB_1 $bool = yes // USB voltage regulator is enabled.

//--- Enumerated values for register SOPT1CFG, field URWE
  let SIM_SOPT1CFG_URWE_SOPT1_0 $bool = no // SOPT1 USBREGEN cannot be written.
  let SIM_SOPT1CFG_URWE_SOPT1_1 $bool = yes // SOPT1 USBREGEN can be written.

//--- Enumerated values for register SOPT1CFG, field UVSWE
  let SIM_SOPT1CFG_UVSWE_SOPT1_0 $bool = no // SOPT1 USBVSTBY cannot be written.
  let SIM_SOPT1CFG_UVSWE_SOPT1_1 $bool = yes // SOPT1 USBVSTBY can be written.

//--- Enumerated values for register SOPT1CFG, field USSWE
  let SIM_SOPT1CFG_USSWE_SOPT1_0 $bool = no // SOPT1 USBSSTBY cannot be written.
  let SIM_SOPT1CFG_USSWE_SOPT1_1 $bool = yes // SOPT1 USBSSTBY can be written.

//--- Enumerated values for register USBPHYCTL, field USBVREGSEL
  let SIM_USBPHYCTL_USBVREGSEL_VREG_IN0_0 $bool = no // VREG_IN0 will be selected if both regulator inputs are powered
  let SIM_USBPHYCTL_USBVREGSEL_VREG_IN1_1 $bool = yes // VREG_IN1 will be selected if both regulator inputs are powered

//--- Enumerated values for register USBPHYCTL, field USBVREGPD
  let SIM_USBPHYCTL_USBVREGPD_Regulator_0 $bool = no // Regulator output pulldown resistor is not enabled
  let SIM_USBPHYCTL_USBVREGPD_Regulator_1 $bool = yes // Regulator output pulldown resistor is enabled

//--- Enumerated values for register USBPHYCTL, field USB3VOUTTRG
  let SIM_USBPHYCTL_USB3VOUTTRG_2_733V_000 $u3 = 0 // 2.733V
  let SIM_USBPHYCTL_USB3VOUTTRG_3_020V_001 $u3 = 1 // 3.020V
  let SIM_USBPHYCTL_USB3VOUTTRG_3_074V_010 $u3 = 2 // 3.074V
  let SIM_USBPHYCTL_USB3VOUTTRG_3_130V_011 $u3 = 3 // 3.130V
  let SIM_USBPHYCTL_USB3VOUTTRG_3_188V_100 $u3 = 4 // 3.188V
  let SIM_USBPHYCTL_USB3VOUTTRG_3_248V_101 $u3 = 5 // 3.248V
  let SIM_USBPHYCTL_USB3VOUTTRG_3_310V_110 $u3 = 6 // 3.310V (default)
  let SIM_USBPHYCTL_USB3VOUTTRG_3_662V_111 $u3 = 7 // 3.662V (For Freescale use only, not for customer use)

//--- Enumerated values for register USBPHYCTL, field USBDISILIM
  let SIM_USBPHYCTL_USBDISILIM_The_0 $bool = no // The current limiter for the USB Voltage Regulator is enabled
  let SIM_USBPHYCTL_USBDISILIM_The_1 $bool = yes // The current limiter for the USB Voltage Regulator is disabled

//--- Enumerated values for register SOPT2, field USBSLSRC
  let SIM_SOPT2_USBSLSRC_MCGIRCLK_0 $bool = no // MCGIRCLK
  let SIM_SOPT2_USBSLSRC_RTC_1 $bool = yes // RTC 32.768kHz clock

//--- Enumerated values for register SOPT2, field USBREGEN
  let SIM_SOPT2_USBREGEN_USB_0 $bool = no // USB PHY PLL Regulator disabled.
  let SIM_SOPT2_USBREGEN_USB_1 $bool = yes // USB PHY PLL Regulator enabled.

//--- Enumerated values for register SOPT2, field RTCCLKOUTSEL
  let SIM_SOPT2_RTCCLKOUTSEL_RTC_0 $bool = no // RTC 1 Hz clock is output on the RTC_CLKOUT pin.
  let SIM_SOPT2_RTCCLKOUTSEL_RTC_1 $bool = yes // RTC 32.768kHz clock is output on the RTC_CLKOUT pin.

//--- Enumerated values for register SOPT2, field CLKOUTSEL
  let SIM_SOPT2_CLKOUTSEL_FlexBus_000 $u3 = 0 // FlexBus CLKOUT
  let SIM_SOPT2_CLKOUTSEL_Flash_010 $u3 = 2 // Flash clock
  let SIM_SOPT2_CLKOUTSEL_LPO_011 $u3 = 3 // LPO clock (1 kHz)
  let SIM_SOPT2_CLKOUTSEL_MCGIRCLK_100 $u3 = 4 // MCGIRCLK
  let SIM_SOPT2_CLKOUTSEL_RTC_101 $u3 = 5 // RTC 32.768kHz clock
  let SIM_SOPT2_CLKOUTSEL_OSCERCLK0_110 $u3 = 6 // OSCERCLK0
  let SIM_SOPT2_CLKOUTSEL_IRC_111 $u3 = 7 // IRC 48 MHz clock

//--- Enumerated values for register SOPT2, field FBSL
  let SIM_SOPT2_FBSL_All_00 $u2 = 0 // All off-chip accesses (instruction and data) via the FlexBus or SDRAM are disallowed.
  let SIM_SOPT2_FBSL_All_01 $u2 = 1 // All off-chip accesses (instruction and data) via the FlexBus or SDRAM are disallowed.
  let SIM_SOPT2_FBSL_Off_chip_10 $u2 = 2 // Off-chip instruction accesses are disallowed. Data accesses are allowed.
  let SIM_SOPT2_FBSL_Off_chip_11 $u2 = 3 // Off-chip instruction accesses and data accesses are allowed.

//--- Enumerated values for register SOPT2, field TRACECLKSEL
  let SIM_SOPT2_TRACECLKSEL_MCGOUTCLK__0 $bool = no // MCGOUTCLK, divided by the TRACECLK fractional divider as configured by SIM_CLKDIV4[TRACEFRAC, TRACEDIV]
  let SIM_SOPT2_TRACECLKSEL_Core_system_1 $bool = yes // Core/system clock

//--- Enumerated values for register SOPT2, field PLLFLLSEL
  let SIM_SOPT2_PLLFLLSEL_MCGFLLCLK_00 $u2 = 0 // MCGFLLCLK clock
  let SIM_SOPT2_PLLFLLSEL_MCGPLLCLK_01 $u2 = 1 // MCGPLLCLK clock
  let SIM_SOPT2_PLLFLLSEL_USB1_10 $u2 = 2 // USB1 PFD clock
  let SIM_SOPT2_PLLFLLSEL_IRC48_11 $u2 = 3 // IRC48 MHz clock

//--- Enumerated values for register SOPT2, field USBSRC
  let SIM_SOPT2_USBSRC_External_0 $bool = no // External bypass clock (USB_CLKIN).
  let SIM_SOPT2_USBSRC_MCGFLLCLK__1 $bool = yes // MCGFLLCLK, or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL], and then divided by the USB fractional divider as configured by SIM_CLKDIV2[USBFRAC, USBDIV].

//--- Enumerated values for register SOPT2, field RMIISRC
  let SIM_SOPT2_RMIISRC_EXTAL_0 $bool = no // EXTAL clock
  let SIM_SOPT2_RMIISRC_External_1 $bool = yes // External bypass clock (ENET_1588_CLKIN).

//--- Enumerated values for register SOPT2, field TIMESRC
  let SIM_SOPT2_TIMESRC_Core_system_00 $u2 = 0 // Core/system clock.
  let SIM_SOPT2_TIMESRC_MCGFLLCLK_01 $u2 = 1 // MCGFLLCLK , or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL].
  let SIM_SOPT2_TIMESRC_OSCERCLK_10 $u2 = 2 // OSCERCLK clock
  let SIM_SOPT2_TIMESRC_External_11 $u2 = 3 // External bypass clock (ENET_1588_CLKIN).

//--- Enumerated values for register SOPT2, field TPMSRC
  let SIM_SOPT2_TPMSRC_Clock_00 $u2 = 0 // Clock disabled
  let SIM_SOPT2_TPMSRC_MCGFLLCLK_01 $u2 = 1 // MCGFLLCLK , or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL], and then divided by the PLLFLLCLK fractional divider as configured by SIM_CLKDIV3[PLLFLLFRAC, PLLFLLDIV].
  let SIM_SOPT2_TPMSRC_OSCERCLK_10 $u2 = 2 // OSCERCLK clock
  let SIM_SOPT2_TPMSRC_MCGIRCLK_11 $u2 = 3 // MCGIRCLK clock

//--- Enumerated values for register SOPT2, field LPUARTSRC
  let SIM_SOPT2_LPUARTSRC_Clock_00 $u2 = 0 // Clock disabled
  let SIM_SOPT2_LPUARTSRC_MCGFLLCLK_01 $u2 = 1 // MCGFLLCLK , or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL], and then divided by the PLLFLLCLK fractional divider as configured by SIM_CLKDIV3[PLLFLLFRAC, PLLFLLDIV].
  let SIM_SOPT2_LPUARTSRC_OSCERCLK_10 $u2 = 2 // OSCERCLK clock
  let SIM_SOPT2_LPUARTSRC_MCGIRCLK_11 $u2 = 3 // MCGIRCLK clock

//--- Enumerated values for register SOPT2, field SDHCSRC
  let SIM_SOPT2_SDHCSRC_Core_system_00 $u2 = 0 // Core/system clock.
  let SIM_SOPT2_SDHCSRC_MCGFLLCLK__01 $u2 = 1 // MCGFLLCLK, or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL].
  let SIM_SOPT2_SDHCSRC_OSCERCLK_10 $u2 = 2 // OSCERCLK clock
  let SIM_SOPT2_SDHCSRC_External_11 $u2 = 3 // External bypass clock (SDHC0_CLKIN)

//--- Enumerated values for register SOPT4, field FTM0FLT0
  let SIM_SOPT4_FTM0FLT0_FTM0_FLT0_0 $bool = no // FTM0_FLT0 pin
  let SIM_SOPT4_FTM0FLT0_CMP0_1 $bool = yes // CMP0 out

//--- Enumerated values for register SOPT4, field FTM0FLT1
  let SIM_SOPT4_FTM0FLT1_FTM0_FLT1_0 $bool = no // FTM0_FLT1 pin
  let SIM_SOPT4_FTM0FLT1_CMP1_1 $bool = yes // CMP1 out

//--- Enumerated values for register SOPT4, field FTM0FLT2
  let SIM_SOPT4_FTM0FLT2_FTM0_FLT2_0 $bool = no // FTM0_FLT2 pin
  let SIM_SOPT4_FTM0FLT2_CMP2_1 $bool = yes // CMP2 out

//--- Enumerated values for register SOPT4, field FTM0FLT3
  let SIM_SOPT4_FTM0FLT3_FTM0_FLT3_0 $bool = no // FTM0_FLT3 pin
  let SIM_SOPT4_FTM0FLT3_CMP3_1 $bool = yes // CMP3 out

//--- Enumerated values for register SOPT4, field FTM1FLT0
  let SIM_SOPT4_FTM1FLT0_FTM1_FLT0_0 $bool = no // FTM1_FLT0 pin
  let SIM_SOPT4_FTM1FLT0_CMP0_1 $bool = yes // CMP0 out

//--- Enumerated values for register SOPT4, field FTM2FLT0
  let SIM_SOPT4_FTM2FLT0_FTM2_FLT0_0 $bool = no // FTM2_FLT0 pin
  let SIM_SOPT4_FTM2FLT0_CMP0_1 $bool = yes // CMP0 out

//--- Enumerated values for register SOPT4, field FTM3FLT0
  let SIM_SOPT4_FTM3FLT0_FTM3_FLT0_0 $bool = no // FTM3_FLT0 pin
  let SIM_SOPT4_FTM3FLT0_CMP0_1 $bool = yes // CMP0 out

//--- Enumerated values for register SOPT4, field FTM1CH0SRC
  let SIM_SOPT4_FTM1CH0SRC_FTM1_CH0_00 $u2 = 0 // FTM1_CH0 signal
  let SIM_SOPT4_FTM1CH0SRC_CMP0_01 $u2 = 1 // CMP0 output
  let SIM_SOPT4_FTM1CH0SRC_CMP1_10 $u2 = 2 // CMP1 output
  let SIM_SOPT4_FTM1CH0SRC_USB_11 $u2 = 3 // USB start of frame pulse

//--- Enumerated values for register SOPT4, field FTM2CH0SRC
  let SIM_SOPT4_FTM2CH0SRC_FTM2_CH0_00 $u2 = 0 // FTM2_CH0 signal
  let SIM_SOPT4_FTM2CH0SRC_CMP0_01 $u2 = 1 // CMP0 output
  let SIM_SOPT4_FTM2CH0SRC_CMP1_10 $u2 = 2 // CMP1 output

//--- Enumerated values for register SOPT4, field FTM2CH1SRC
  let SIM_SOPT4_FTM2CH1SRC_FTM2_CH1_0 $bool = no // FTM2_CH1 signal
  let SIM_SOPT4_FTM2CH1SRC_Exclusive_1 $bool = yes // Exclusive OR of FTM2_CH1, FTM2_CH0 and FTM1_CH1.

//--- Enumerated values for register SOPT4, field FTM0CLKSEL
  let SIM_SOPT4_FTM0CLKSEL_FTM_CLK0_0 $bool = no // FTM_CLK0 pin
  let SIM_SOPT4_FTM0CLKSEL_FTM_CLK1_1 $bool = yes // FTM_CLK1 pin

//--- Enumerated values for register SOPT4, field FTM1CLKSEL
  let SIM_SOPT4_FTM1CLKSEL_FTM_CLK0_0 $bool = no // FTM_CLK0 pin
  let SIM_SOPT4_FTM1CLKSEL_FTM_CLK1_1 $bool = yes // FTM_CLK1 pin

//--- Enumerated values for register SOPT4, field FTM2CLKSEL
  let SIM_SOPT4_FTM2CLKSEL_FTM2_0 $bool = no // FTM2 external clock driven by FTM_CLK0 pin.
  let SIM_SOPT4_FTM2CLKSEL_FTM2_1 $bool = yes // FTM2 external clock driven by FTM_CLK1 pin.

//--- Enumerated values for register SOPT4, field FTM3CLKSEL
  let SIM_SOPT4_FTM3CLKSEL_FTM3_0 $bool = no // FTM3 external clock driven by FTM_CLK0 pin.
  let SIM_SOPT4_FTM3CLKSEL_FTM3_1 $bool = yes // FTM3 external clock driven by FTM_CLK1 pin.

//--- Enumerated values for register SOPT4, field FTM0TRG0SRC
  let SIM_SOPT4_FTM0TRG0SRC_HSCMP0_0 $bool = no // HSCMP0 output drives FTM0 hardware trigger 0
  let SIM_SOPT4_FTM0TRG0SRC_FTM1_1 $bool = yes // FTM1 channel match drives FTM0 hardware trigger 0

//--- Enumerated values for register SOPT4, field FTM0TRG1SRC
  let SIM_SOPT4_FTM0TRG1SRC_PDB_0 $bool = no // PDB output trigger 1 drives FTM0 hardware trigger 1
  let SIM_SOPT4_FTM0TRG1SRC_FTM2_1 $bool = yes // FTM2 channel match drives FTM0 hardware trigger 1

//--- Enumerated values for register SOPT4, field FTM3TRG0SRC
  let SIM_SOPT4_FTM3TRG0SRC_FTM1_1 $bool = yes // FTM1 channel match drives FTM3 hardware trigger 0

//--- Enumerated values for register SOPT4, field FTM3TRG1SRC
  let SIM_SOPT4_FTM3TRG1SRC_FTM2_1 $bool = yes // FTM2 channel match drives FTM3 hardware trigger 1

//--- Enumerated values for register SOPT5, field UART0TXSRC
  let SIM_SOPT5_UART0TXSRC_UART0_TX_00 $u2 = 0 // UART0_TX pin
  let SIM_SOPT5_UART0TXSRC_UART0_TX_01 $u2 = 1 // UART0_TX pin modulated with FTM1 channel 0 output
  let SIM_SOPT5_UART0TXSRC_UART0_TX_10 $u2 = 2 // UART0_TX pin modulated with FTM2 channel 0 output

//--- Enumerated values for register SOPT5, field UART0RXSRC
  let SIM_SOPT5_UART0RXSRC_UART0_RX_00 $u2 = 0 // UART0_RX pin
  let SIM_SOPT5_UART0RXSRC_CMP0_01 $u2 = 1 // CMP0
  let SIM_SOPT5_UART0RXSRC_CMP1_10 $u2 = 2 // CMP1

//--- Enumerated values for register SOPT5, field UART1TXSRC
  let SIM_SOPT5_UART1TXSRC_UART1_TX_00 $u2 = 0 // UART1_TX pin
  let SIM_SOPT5_UART1TXSRC_UART1_TX_01 $u2 = 1 // UART1_TX pin modulated with FTM1 channel 0 output
  let SIM_SOPT5_UART1TXSRC_UART1_TX_10 $u2 = 2 // UART1_TX pin modulated with FTM2 channel 0 output

//--- Enumerated values for register SOPT5, field UART1RXSRC
  let SIM_SOPT5_UART1RXSRC_UART1_RX_00 $u2 = 0 // UART1_RX pin
  let SIM_SOPT5_UART1RXSRC_CMP0_01 $u2 = 1 // CMP0
  let SIM_SOPT5_UART1RXSRC_CMP1_10 $u2 = 2 // CMP1

//--- Enumerated values for register SOPT5, field LPUART0TXSRC
  let SIM_SOPT5_LPUART0TXSRC_LPUART0_TX_00 $u2 = 0 // LPUART0_TX pin
  let SIM_SOPT5_LPUART0TXSRC_LPUART0_TX_01 $u2 = 1 // LPUART0_TX pin modulated with TPM1 channel 0 output
  let SIM_SOPT5_LPUART0TXSRC_LPUART0_TX_10 $u2 = 2 // LPUART0_TX pin modulated with TPM2 channel 0 output

//--- Enumerated values for register SOPT5, field LPUART0RXSRC
  let SIM_SOPT5_LPUART0RXSRC_LPUART0_RX_00 $u2 = 0 // LPUART0_RX pin
  let SIM_SOPT5_LPUART0RXSRC_CMP0_01 $u2 = 1 // CMP0 output
  let SIM_SOPT5_LPUART0RXSRC_CMP1_10 $u2 = 2 // CMP1 output

//--- Enumerated values for register SOPT7, field ADC0TRGSEL
  let SIM_SOPT7_ADC0TRGSEL_PDB_0000 $u4 = 0 // PDB external trigger pin input (PDB0_EXTRG)
  let SIM_SOPT7_ADC0TRGSEL_High_0001 $u4 = 1 // High speed comparator 0 output
  let SIM_SOPT7_ADC0TRGSEL_High_0010 $u4 = 2 // High speed comparator 1 output
  let SIM_SOPT7_ADC0TRGSEL_High_0011 $u4 = 3 // High speed comparator 2 output
  let SIM_SOPT7_ADC0TRGSEL_PIT_0100 $u4 = 4 // PIT trigger 0
  let SIM_SOPT7_ADC0TRGSEL_PIT_0101 $u4 = 5 // PIT trigger 1
  let SIM_SOPT7_ADC0TRGSEL_PIT_0110 $u4 = 6 // PIT trigger 2
  let SIM_SOPT7_ADC0TRGSEL_PIT_0111 $u4 = 7 // PIT trigger 3
  let SIM_SOPT7_ADC0TRGSEL_FTM0_1000 $u4 = 8 // FTM0 trigger
  let SIM_SOPT7_ADC0TRGSEL_FTM1_1001 $u4 = 9 // FTM1 trigger
  let SIM_SOPT7_ADC0TRGSEL_FTM2_1010 $u4 = 10 // FTM2 trigger
  let SIM_SOPT7_ADC0TRGSEL_FTM3_1011 $u4 = 11 // FTM3 trigger
  let SIM_SOPT7_ADC0TRGSEL_RTC_1100 $u4 = 12 // RTC alarm
  let SIM_SOPT7_ADC0TRGSEL_RTC_1101 $u4 = 13 // RTC seconds
  let SIM_SOPT7_ADC0TRGSEL_Low_power_1110 $u4 = 14 // Low-power timer (LPTMR) trigger
  let SIM_SOPT7_ADC0TRGSEL_TPM1_1111 $u4 = 15 // TPM1 channel 0 (A pretrigger) and channel 1 (B pretrigger)

//--- Enumerated values for register SOPT7, field ADC0PRETRGSEL
  let SIM_SOPT7_ADC0PRETRGSEL_Pre_trigger_0 $bool = no // Pre-trigger A
  let SIM_SOPT7_ADC0PRETRGSEL_Pre_trigger_1 $bool = yes // Pre-trigger B

//--- Enumerated values for register SOPT7, field ADC0ALTTRGEN
  let SIM_SOPT7_ADC0ALTTRGEN_PDB_0 $bool = no // PDB trigger selected for ADC0.
  let SIM_SOPT7_ADC0ALTTRGEN_Alternate_1 $bool = yes // Alternate trigger selected for ADC0.

//--- Enumerated values for register SOPT7, field ADC1TRGSEL
  let SIM_SOPT7_ADC1TRGSEL_PDB_0000 $u4 = 0 // PDB external trigger pin input (PDB0_EXTRG)
  let SIM_SOPT7_ADC1TRGSEL_High_0001 $u4 = 1 // High speed comparator 0 output
  let SIM_SOPT7_ADC1TRGSEL_High_0010 $u4 = 2 // High speed comparator 1 output
  let SIM_SOPT7_ADC1TRGSEL_High_0011 $u4 = 3 // High speed comparator 2 output
  let SIM_SOPT7_ADC1TRGSEL_PIT_0100 $u4 = 4 // PIT trigger 0
  let SIM_SOPT7_ADC1TRGSEL_PIT_0101 $u4 = 5 // PIT trigger 1
  let SIM_SOPT7_ADC1TRGSEL_PIT_0110 $u4 = 6 // PIT trigger 2
  let SIM_SOPT7_ADC1TRGSEL_PIT_0111 $u4 = 7 // PIT trigger 3
  let SIM_SOPT7_ADC1TRGSEL_FTM0_1000 $u4 = 8 // FTM0 trigger
  let SIM_SOPT7_ADC1TRGSEL_FTM1_1001 $u4 = 9 // FTM1 trigger
  let SIM_SOPT7_ADC1TRGSEL_FTM2_1010 $u4 = 10 // FTM2 trigger
  let SIM_SOPT7_ADC1TRGSEL_FTM3_1011 $u4 = 11 // FTM3 trigger
  let SIM_SOPT7_ADC1TRGSEL_RTC_1100 $u4 = 12 // RTC alarm
  let SIM_SOPT7_ADC1TRGSEL_RTC_1101 $u4 = 13 // RTC seconds
  let SIM_SOPT7_ADC1TRGSEL_Low_power_1110 $u4 = 14 // Low-power timer (LPTMR) trigger
  let SIM_SOPT7_ADC1TRGSEL_TPM2_1111 $u4 = 15 // TPM2 channel 0 (A pretrigger) and channel 1 (B pretrigger)

//--- Enumerated values for register SOPT7, field ADC1PRETRGSEL
  let SIM_SOPT7_ADC1PRETRGSEL_Pre_trigger_0 $bool = no // Pre-trigger A selected for ADC1.
  let SIM_SOPT7_ADC1PRETRGSEL_Pre_trigger_1 $bool = yes // Pre-trigger B selected for ADC1.

//--- Enumerated values for register SOPT7, field ADC1ALTTRGEN
  let SIM_SOPT7_ADC1ALTTRGEN_PDB_0 $bool = no // PDB trigger selected for ADC1
  let SIM_SOPT7_ADC1ALTTRGEN_Alternate_1 $bool = yes // Alternate trigger selected for ADC1 as defined by ADC1TRGSEL.

//--- Enumerated values for register SOPT8, field FTM0SYNCBIT
  let SIM_SOPT8_FTM0SYNCBIT_No_0 $bool = no // No effect
  let SIM_SOPT8_FTM0SYNCBIT_Write_1 $bool = yes // Write 1 to assert the TRIG0 input to FTM0, software must clear this bit to allow other trigger sources to assert.

//--- Enumerated values for register SOPT8, field FTM1SYNCBIT
  let SIM_SOPT8_FTM1SYNCBIT_No_0 $bool = no // No effect.
  let SIM_SOPT8_FTM1SYNCBIT_Write_1 $bool = yes // Write 1 to assert the TRIG0 input to FTM1, software must clear this bit to allow other trigger sources to assert.

//--- Enumerated values for register SOPT8, field FTM2SYNCBIT
  let SIM_SOPT8_FTM2SYNCBIT_No_0 $bool = no // No effect.
  let SIM_SOPT8_FTM2SYNCBIT_Write_1 $bool = yes // Write 1 to assert the TRIG0 input to FTM2, software must clear this bit to allow other trigger sources to assert.

//--- Enumerated values for register SOPT8, field FTM3SYNCBIT
  let SIM_SOPT8_FTM3SYNCBIT_No_0 $bool = no // No effect.
  let SIM_SOPT8_FTM3SYNCBIT_Write_1 $bool = yes // Write 1 to assert the TRIG0 input to FTM3, software must clear this bit to allow other trigger sources to assert.

//--- Enumerated values for register SOPT8, field FTM0OCH0SRC
  let SIM_SOPT8_FTM0OCH0SRC_FTM0_CH0_0 $bool = no // FTM0_CH0 pin is output of FTM0 channel 0 output
  let SIM_SOPT8_FTM0OCH0SRC_FTM0_CH0_1 $bool = yes // FTM0_CH0 pin is output of FTM0 channel 0 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH1SRC
  let SIM_SOPT8_FTM0OCH1SRC_FTM0_CH1_0 $bool = no // FTM0_CH1 pin is output of FTM0 channel 1 output
  let SIM_SOPT8_FTM0OCH1SRC_FTM0_CH1_1 $bool = yes // FTM0_CH1 pin is output of FTM0 channel 1 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH2SRC
  let SIM_SOPT8_FTM0OCH2SRC_FTM0_CH2_0 $bool = no // FTM0_CH2 pin is output of FTM0 channel 2 output
  let SIM_SOPT8_FTM0OCH2SRC_FTM0_CH2_1 $bool = yes // FTM0_CH2 pin is output of FTM0 channel 2 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH3SRC
  let SIM_SOPT8_FTM0OCH3SRC_FTM0_CH3_0 $bool = no // FTM0_CH3 pin is output of FTM0 channel 3 output
  let SIM_SOPT8_FTM0OCH3SRC_FTM0_CH3_1 $bool = yes // FTM0_CH3 pin is output of FTM0 channel 3 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH4SRC
  let SIM_SOPT8_FTM0OCH4SRC_FTM0_CH4_0 $bool = no // FTM0_CH4 pin is output of FTM0 channel 4 output
  let SIM_SOPT8_FTM0OCH4SRC_FTM0_CH4_1 $bool = yes // FTM0_CH4 pin is output of FTM0 channel 4 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH5SRC
  let SIM_SOPT8_FTM0OCH5SRC_FTM0_CH5_0 $bool = no // FTM0_CH5 pin is output of FTM0 channel 5 output
  let SIM_SOPT8_FTM0OCH5SRC_FTM0_CH5_1 $bool = yes // FTM0_CH5 pin is output of FTM0 channel 5 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH6SRC
  let SIM_SOPT8_FTM0OCH6SRC_FTM0_CH6_0 $bool = no // FTM0_CH6 pin is output of FTM0 channel 6 output
  let SIM_SOPT8_FTM0OCH6SRC_FTM0_CH6_1 $bool = yes // FTM0_CH6 pin is output of FTM0 channel 6 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM0OCH7SRC
  let SIM_SOPT8_FTM0OCH7SRC_FTM0_CH7_0 $bool = no // FTM0_CH7 pin is output of FTM0 channel 7 output
  let SIM_SOPT8_FTM0OCH7SRC_FTM0_CH7_1 $bool = yes // FTM0_CH7 pin is output of FTM0 channel 7 output, modulated by FTM1 channel 1 output

//--- Enumerated values for register SOPT8, field FTM3OCH0SRC
  let SIM_SOPT8_FTM3OCH0SRC_FTM3_CH0_0 $bool = no // FTM3_CH0 pin is output of FTM3 channel 0 output
  let SIM_SOPT8_FTM3OCH0SRC_FTM3_CH0_1 $bool = yes // FTM3_CH0 pin is output of FTM3 channel 0 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH1SRC
  let SIM_SOPT8_FTM3OCH1SRC_FTM3_CH1_0 $bool = no // FTM3_CH1 pin is output of FTM3 channel 1 output
  let SIM_SOPT8_FTM3OCH1SRC_FTM3_CH1_1 $bool = yes // FTM3_CH1 pin is output of FTM3 channel 1 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH2SRC
  let SIM_SOPT8_FTM3OCH2SRC_FTM3_CH2_0 $bool = no // FTM3_CH2 pin is output of FTM3 channel 2 output
  let SIM_SOPT8_FTM3OCH2SRC_FTM3_CH2_1 $bool = yes // FTM3_CH2 pin is output of FTM3 channel 2 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH3SRC
  let SIM_SOPT8_FTM3OCH3SRC_FTM3_CH3_0 $bool = no // FTM3_CH3 pin is output of FTM3 channel 3 output
  let SIM_SOPT8_FTM3OCH3SRC_FTM3_CH3_1 $bool = yes // FTM3_CH3 pin is output of FTM3 channel 3 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH4SRC
  let SIM_SOPT8_FTM3OCH4SRC_FTM3_CH4_0 $bool = no // FTM3_CH4 pin is output of FTM3 channel 4 output
  let SIM_SOPT8_FTM3OCH4SRC_FTM3_CH4_1 $bool = yes // FTM3_CH4 pin is output of FTM3 channel 4 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH5SRC
  let SIM_SOPT8_FTM3OCH5SRC_FTM3_CH5_0 $bool = no // FTM3_CH5 pin is output of FTM3 channel 5 output
  let SIM_SOPT8_FTM3OCH5SRC_FTM3_CH5_1 $bool = yes // FTM3_CH5 pin is output of FTM3 channel 5 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH6SRC
  let SIM_SOPT8_FTM3OCH6SRC_FTM3_CH6_0 $bool = no // FTM3_CH6 pin is output of FTM3 channel 6 output
  let SIM_SOPT8_FTM3OCH6SRC_FTM3_CH6_1 $bool = yes // FTM3_CH6 pin is output of FTM3 channel 6 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT8, field FTM3OCH7SRC
  let SIM_SOPT8_FTM3OCH7SRC_FTM3_CH7_0 $bool = no // FTM3_CH7 pin is output of FTM3 channel 7 output
  let SIM_SOPT8_FTM3OCH7SRC_FTM3_CH7_1 $bool = yes // FTM3_CH7 pin is output of FTM3 channel 7 output modulated by FTM2 channel 1 output.

//--- Enumerated values for register SOPT9, field TPM1CH0SRC
  let SIM_SOPT9_TPM1CH0SRC_TPM1_CH0_00 $u2 = 0 // TPM1_CH0 signal
  let SIM_SOPT9_TPM1CH0SRC_CMP0_01 $u2 = 1 // CMP0 output
  let SIM_SOPT9_TPM1CH0SRC_CMP1_10 $u2 = 2 // CMP1 output

//--- Enumerated values for register SOPT9, field TPM2CH0SRC
  let SIM_SOPT9_TPM2CH0SRC_TPM2_CH0_00 $u2 = 0 // TPM2_CH0 signal
  let SIM_SOPT9_TPM2CH0SRC_CMP0_01 $u2 = 1 // CMP0 output
  let SIM_SOPT9_TPM2CH0SRC_CMP1_10 $u2 = 2 // CMP1 output

//--- Enumerated values for register SOPT9, field TPM1CLKSEL
  let SIM_SOPT9_TPM1CLKSEL_TPM_CLKIN0_0 $bool = no // TPM_CLKIN0 pin
  let SIM_SOPT9_TPM1CLKSEL_TPM_CLKIN1_1 $bool = yes // TPM_CLKIN1 pin

//--- Enumerated values for register SOPT9, field TPM2CLKSEL
  let SIM_SOPT9_TPM2CLKSEL_TPM_CLKIN0_0 $bool = no // TPM_CLKIN0 pin
  let SIM_SOPT9_TPM2CLKSEL_TPM_CLKIN1_1 $bool = yes // TPM_CLKIN1 pin

//--- Enumerated values for register SDID, field PINID
  let SIM_SDID_PINID_32_pin_0010 $u4 = 2 // 32-pin
  let SIM_SDID_PINID_48_pin_0100 $u4 = 4 // 48-pin
  let SIM_SDID_PINID_64_pin_0101 $u4 = 5 // 64-pin
  let SIM_SDID_PINID_80_pin_0110 $u4 = 6 // 80-pin
  let SIM_SDID_PINID_81_pin_0111 $u4 = 7 // 81-pin or 121-pin
  let SIM_SDID_PINID_100_pin_1000 $u4 = 8 // 100-pin
  let SIM_SDID_PINID_121_pin_1001 $u4 = 9 // 121-pin
  let SIM_SDID_PINID_144_pin_1010 $u4 = 10 // 144-pin
  let SIM_SDID_PINID_Custom_1011 $u4 = 11 // Custom pinout (WLCSP)
  let SIM_SDID_PINID_169_pin_1100 $u4 = 12 // 169-pin
  let SIM_SDID_PINID_256_pin_1110 $u4 = 14 // 256-pin

//--- Enumerated values for register SDID, field FAMID
  let SIM_SDID_FAMID_K1x_000 $u3 = 0 // K1x Family (without tamper)
  let SIM_SDID_FAMID_K2x_001 $u3 = 1 // K2x Family (without tamper)
  let SIM_SDID_FAMID_K3x_010 $u3 = 2 // K3x Family or K1x/K6x Family (with tamper)
  let SIM_SDID_FAMID_K4x_011 $u3 = 3 // K4x Family or K2x Family (with tamper)
  let SIM_SDID_FAMID_K6x_100 $u3 = 4 // K6x Family (without tamper)
  let SIM_SDID_FAMID_K7x_101 $u3 = 5 // K7x Family

//--- Enumerated values for register SDID, field SERIESID
  let SIM_SDID_SERIESID_Kinetis_0000 $u4 = 0 // Kinetis K series
  let SIM_SDID_SERIESID_Kinetis_0001 $u4 = 1 // Kinetis L series
  let SIM_SDID_SERIESID_Kinetis_0101 $u4 = 5 // Kinetis W series
  let SIM_SDID_SERIESID_Kinetis_0110 $u4 = 6 // Kinetis V series

//--- Enumerated values for register SDID, field SUBFAMID
  let SIM_SDID_SUBFAMID_Kx0_0000 $u4 = 0 // Kx0 Subfamily
  let SIM_SDID_SUBFAMID_Kx1_0001 $u4 = 1 // Kx1 Subfamily (tamper detect)
  let SIM_SDID_SUBFAMID_Kx2_0010 $u4 = 2 // Kx2 Subfamily
  let SIM_SDID_SUBFAMID_Kx3_0011 $u4 = 3 // Kx3 Subfamily (tamper detect)
  let SIM_SDID_SUBFAMID_Kx4_0100 $u4 = 4 // Kx4 Subfamily
  let SIM_SDID_SUBFAMID_Kx5_0101 $u4 = 5 // Kx5 Subfamily (tamper detect)
  let SIM_SDID_SUBFAMID_Kx6_0110 $u4 = 6 // Kx6 Subfamily

//--- Enumerated values for register SDID, field FAMILYID
  let SIM_SDID_FAMILYID_K0x_0000 $u4 = 0 // K0x Family
  let SIM_SDID_FAMILYID_K1x_0001 $u4 = 1 // K1x Family
  let SIM_SDID_FAMILYID_K2x_0010 $u4 = 2 // K2x Family
  let SIM_SDID_FAMILYID_K3x_0011 $u4 = 3 // K3x Family
  let SIM_SDID_FAMILYID_K4x_0100 $u4 = 4 // K4x Family
  let SIM_SDID_FAMILYID_K6x_0110 $u4 = 6 // K6x Family
  let SIM_SDID_FAMILYID_K7x_0111 $u4 = 7 // K7x Family
  let SIM_SDID_FAMILYID_K8x_1000 $u4 = 8 // K8x Family

//--- Enumerated values for register SCGC1, field I2C2
  let SIM_SCGC1_I2C2_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC1_I2C2_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC1, field I2C3
  let SIM_SCGC1_I2C3_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC1_I2C3_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC1, field UART4
  let SIM_SCGC1_UART4_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC1_UART4_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC2, field ENET
  let SIM_SCGC2_ENET_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC2_ENET_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC2, field LPUART0
  let SIM_SCGC2_LPUART0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC2_LPUART0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC2, field TPM1
  let SIM_SCGC2_TPM1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC2_TPM1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC2, field TPM2
  let SIM_SCGC2_TPM2_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC2_TPM2_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC2, field DAC0
  let SIM_SCGC2_DAC0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC2_DAC0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC2, field DAC1
  let SIM_SCGC2_DAC1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC2_DAC1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field RNGA
  let SIM_SCGC3_RNGA_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_RNGA_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field USBHS
  let SIM_SCGC3_USBHS_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_USBHS_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field USBHSPHY
  let SIM_SCGC3_USBHSPHY_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_USBHSPHY_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field USBHSDCD
  let SIM_SCGC3_USBHSDCD_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_USBHSDCD_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field FLEXCAN1
  let SIM_SCGC3_FLEXCAN1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_FLEXCAN1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field SPI2
  let SIM_SCGC3_SPI2_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_SPI2_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field SDHC
  let SIM_SCGC3_SDHC_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_SDHC_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field FTM2
  let SIM_SCGC3_FTM2_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_FTM2_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field FTM3
  let SIM_SCGC3_FTM3_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_FTM3_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC3, field ADC1
  let SIM_SCGC3_ADC1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC3_ADC1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field EWM
  let SIM_SCGC4_EWM_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_EWM_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field CMT
  let SIM_SCGC4_CMT_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_CMT_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field I2C0
  let SIM_SCGC4_I2C0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_I2C0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field I2C1
  let SIM_SCGC4_I2C1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_I2C1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field UART0
  let SIM_SCGC4_UART0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_UART0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field UART1
  let SIM_SCGC4_UART1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_UART1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field UART2
  let SIM_SCGC4_UART2_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_UART2_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field UART3
  let SIM_SCGC4_UART3_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_UART3_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field USBOTG
  let SIM_SCGC4_USBOTG_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_USBOTG_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field CMP
  let SIM_SCGC4_CMP_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_CMP_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC4, field VREF
  let SIM_SCGC4_VREF_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC4_VREF_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC5, field LPTMR
  let SIM_SCGC5_LPTMR_Access_0 $bool = no // Access disabled
  let SIM_SCGC5_LPTMR_Access_1 $bool = yes // Access enabled

//--- Enumerated values for register SCGC5, field TSI
  let SIM_SCGC5_TSI_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC5_TSI_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC5, field PORTA
  let SIM_SCGC5_PORTA_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC5_PORTA_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC5, field PORTB
  let SIM_SCGC5_PORTB_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC5_PORTB_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC5, field PORTC
  let SIM_SCGC5_PORTC_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC5_PORTC_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC5, field PORTD
  let SIM_SCGC5_PORTD_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC5_PORTD_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC5, field PORTE
  let SIM_SCGC5_PORTE_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC5_PORTE_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field FTF
  let SIM_SCGC6_FTF_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_FTF_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field DMAMUX
  let SIM_SCGC6_DMAMUX_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_DMAMUX_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field FLEXCAN0
  let SIM_SCGC6_FLEXCAN0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_FLEXCAN0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field SPI0
  let SIM_SCGC6_SPI0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_SPI0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field SPI1
  let SIM_SCGC6_SPI1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_SPI1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field I2S
  let SIM_SCGC6_I2S_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_I2S_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field CRC
  let SIM_SCGC6_CRC_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_CRC_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field USBDCD
  let SIM_SCGC6_USBDCD_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_USBDCD_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field PDB
  let SIM_SCGC6_PDB_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_PDB_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field PIT
  let SIM_SCGC6_PIT_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_PIT_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field FTM0
  let SIM_SCGC6_FTM0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_FTM0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field FTM1
  let SIM_SCGC6_FTM1_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_FTM1_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field FTM2
  let SIM_SCGC6_FTM2_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_FTM2_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field ADC0
  let SIM_SCGC6_ADC0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_ADC0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC6, field RTC
  let SIM_SCGC6_RTC_Access_0 $bool = no // Access and interrupts disabled
  let SIM_SCGC6_RTC_Access_1 $bool = yes // Access and interrupts enabled

//--- Enumerated values for register SCGC6, field DAC0
  let SIM_SCGC6_DAC0_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC6_DAC0_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC7, field FLEXBUS
  let SIM_SCGC7_FLEXBUS_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC7_FLEXBUS_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC7, field DMA
  let SIM_SCGC7_DMA_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC7_DMA_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC7, field MPU
  let SIM_SCGC7_MPU_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC7_MPU_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register SCGC7, field SDRAMC
  let SIM_SCGC7_SDRAMC_Clock_0 $bool = no // Clock disabled
  let SIM_SCGC7_SDRAMC_Clock_1 $bool = yes // Clock enabled

//--- Enumerated values for register CLKDIV1, field OUTDIV4
  let SIM_CLKDIV1_OUTDIV4_Divide_by_1__0000 $u4 = 0 // Divide-by-1.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_2__0001 $u4 = 1 // Divide-by-2.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_3__0010 $u4 = 2 // Divide-by-3.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_4__0011 $u4 = 3 // Divide-by-4.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_5__0100 $u4 = 4 // Divide-by-5.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_6__0101 $u4 = 5 // Divide-by-6.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_7__0110 $u4 = 6 // Divide-by-7.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_8__0111 $u4 = 7 // Divide-by-8.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_9__1000 $u4 = 8 // Divide-by-9.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_10__1001 $u4 = 9 // Divide-by-10.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_11__1010 $u4 = 10 // Divide-by-11.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_12__1011 $u4 = 11 // Divide-by-12.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_13__1100 $u4 = 12 // Divide-by-13.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_14__1101 $u4 = 13 // Divide-by-14.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_15__1110 $u4 = 14 // Divide-by-15.
  let SIM_CLKDIV1_OUTDIV4_Divide_by_16__1111 $u4 = 15 // Divide-by-16.

//--- Enumerated values for register CLKDIV1, field OUTDIV3
  let SIM_CLKDIV1_OUTDIV3_Divide_by_1__0000 $u4 = 0 // Divide-by-1.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_2__0001 $u4 = 1 // Divide-by-2.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_3__0010 $u4 = 2 // Divide-by-3.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_4__0011 $u4 = 3 // Divide-by-4.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_5__0100 $u4 = 4 // Divide-by-5.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_6__0101 $u4 = 5 // Divide-by-6.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_7__0110 $u4 = 6 // Divide-by-7.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_8__0111 $u4 = 7 // Divide-by-8.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_9__1000 $u4 = 8 // Divide-by-9.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_10__1001 $u4 = 9 // Divide-by-10.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_11__1010 $u4 = 10 // Divide-by-11.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_12__1011 $u4 = 11 // Divide-by-12.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_13__1100 $u4 = 12 // Divide-by-13.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_14__1101 $u4 = 13 // Divide-by-14.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_15__1110 $u4 = 14 // Divide-by-15.
  let SIM_CLKDIV1_OUTDIV3_Divide_by_16__1111 $u4 = 15 // Divide-by-16.

//--- Enumerated values for register CLKDIV1, field OUTDIV2
  let SIM_CLKDIV1_OUTDIV2_Divide_by_1__0000 $u4 = 0 // Divide-by-1.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_2__0001 $u4 = 1 // Divide-by-2.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_3__0010 $u4 = 2 // Divide-by-3.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_4__0011 $u4 = 3 // Divide-by-4.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_5__0100 $u4 = 4 // Divide-by-5.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_6__0101 $u4 = 5 // Divide-by-6.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_7__0110 $u4 = 6 // Divide-by-7.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_8__0111 $u4 = 7 // Divide-by-8.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_9__1000 $u4 = 8 // Divide-by-9.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_10__1001 $u4 = 9 // Divide-by-10.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_11__1010 $u4 = 10 // Divide-by-11.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_12__1011 $u4 = 11 // Divide-by-12.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_13__1100 $u4 = 12 // Divide-by-13.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_14__1101 $u4 = 13 // Divide-by-14.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_15__1110 $u4 = 14 // Divide-by-15.
  let SIM_CLKDIV1_OUTDIV2_Divide_by_16__1111 $u4 = 15 // Divide-by-16.

//--- Enumerated values for register CLKDIV1, field OUTDIV1
  let SIM_CLKDIV1_OUTDIV1_Divide_by_1__0000 $u4 = 0 // Divide-by-1.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_2__0001 $u4 = 1 // Divide-by-2.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_3__0010 $u4 = 2 // Divide-by-3.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_4__0011 $u4 = 3 // Divide-by-4.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_5__0100 $u4 = 4 // Divide-by-5.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_6__0101 $u4 = 5 // Divide-by-6.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_7__0110 $u4 = 6 // Divide-by-7.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_8__0111 $u4 = 7 // Divide-by-8.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_9__1000 $u4 = 8 // Divide-by-9.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_10__1001 $u4 = 9 // Divide-by-10.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_11__1010 $u4 = 10 // Divide-by-11.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_12__1011 $u4 = 11 // Divide-by-12.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_13__1100 $u4 = 12 // Divide-by-13.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_14__1101 $u4 = 13 // Divide-by-14.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_15__1110 $u4 = 14 // Divide-by-15.
  let SIM_CLKDIV1_OUTDIV1_Divide_by_16__1111 $u4 = 15 // Divide-by-16.

//--- Enumerated values for register FCFG1, field FLASHDIS
  let SIM_FCFG1_FLASHDIS_Flash_0 $bool = no // Flash is enabled
  let SIM_FCFG1_FLASHDIS_Flash_1 $bool = yes // Flash is disabled

//--- Enumerated values for register FCFG1, field FLASHDOZE
  let SIM_FCFG1_FLASHDOZE_Flash_0 $bool = no // Flash remains enabled during Wait mode
  let SIM_FCFG1_FLASHDOZE_Flash_1 $bool = yes // Flash is disabled for the duration of Wait mode

//--- Enumerated values for register FCFG1, field EESIZE
  let SIM_FCFG1_EESIZE_16_0000 $u4 = 0 // 16 KB
  let SIM_FCFG1_EESIZE_8_0001 $u4 = 1 // 8 KB
  let SIM_FCFG1_EESIZE_4_0010 $u4 = 2 // 4 KB
  let SIM_FCFG1_EESIZE_2_0011 $u4 = 3 // 2 KB
  let SIM_FCFG1_EESIZE_1_0100 $u4 = 4 // 1 KB
  let SIM_FCFG1_EESIZE_512_0101 $u4 = 5 // 512 Bytes
  let SIM_FCFG1_EESIZE_256_0110 $u4 = 6 // 256 Bytes
  let SIM_FCFG1_EESIZE_128_0111 $u4 = 7 // 128 Bytes
  let SIM_FCFG1_EESIZE_64_1000 $u4 = 8 // 64 Bytes
  let SIM_FCFG1_EESIZE_32_1001 $u4 = 9 // 32 Bytes
  let SIM_FCFG1_EESIZE_0_1111 $u4 = 15 // 0 Bytes

//--- Enumerated values for register FCFG1, field PFSIZE
  let SIM_FCFG1_PFSIZE_32_0011 $u4 = 3 // 32 KB of program flash memory
  let SIM_FCFG1_PFSIZE_64_0101 $u4 = 5 // 64 KB of program flash memory
  let SIM_FCFG1_PFSIZE_128_0111 $u4 = 7 // 128 KB of program flash memory
  let SIM_FCFG1_PFSIZE_256_1001 $u4 = 9 // 256 KB of program flash memory
  let SIM_FCFG1_PFSIZE_512_1011 $u4 = 11 // 512 KB of program flash memory
  let SIM_FCFG1_PFSIZE_1024_1101 $u4 = 13 // 1024 KB of program flash memory
  let SIM_FCFG1_PFSIZE_2048_1111 $u4 = 15 // 2048 KB of program flash memory

//--- Enumerated values for register FCFG1, field NVMSIZE
  let SIM_FCFG1_NVMSIZE_0_0000 $u4 = 0 // 0 KB of FlexNVM
  let SIM_FCFG1_NVMSIZE_32_0011 $u4 = 3 // 32 KB of FlexNVM
  let SIM_FCFG1_NVMSIZE_64_0101 $u4 = 5 // 64 KB of FlexNVM
  let SIM_FCFG1_NVMSIZE_128_0111 $u4 = 7 // 128 KB of FlexNVM
  let SIM_FCFG1_NVMSIZE_256_1001 $u4 = 9 // 256 KB of FlexNVM
  let SIM_FCFG1_NVMSIZE_512_1011 $u4 = 11 // 512 KB of FlexNVM
  let SIM_FCFG1_NVMSIZE_256_1111 $u4 = 15 // 256 KB of FlexNVM

//--- Enumerated values for register FCFG2, field PFLSH
  let SIM_FCFG2_PFLSH_Device_0 $bool = no // Device supports FlexNVM
  let SIM_FCFG2_PFLSH_Program_1 $bool = yes // Program Flash only, device does not support FlexNVM

//--- Enumerated values for register FCFG2, field SWAPPFLSH
  let SIM_FCFG2_SWAPPFLSH_Swap_0 $bool = no // Swap is not active.
  let SIM_FCFG2_SWAPPFLSH_Swap_1 $bool = yes // Swap is active.

//------------------------------------------------------------------------------
// Peripheral SMC: System Mode Controller
//------------------------------------------------------------------------------

registers ©SMC @at 0x4007e000 {
//---  Register PMPROT: Power Mode Protection register
  PMPROT @offset 0x0 $u8 {
    AHSRUN // at 7: Allow High Speed Run mode
    1
    AVLP // at 5: Allow Very-Low-Power Modes
    1
    ALLS // at 3: Allow Low-Leakage Stop Mode
    1
    AVLLS // at 1: Allow Very-Low-Leakage Stop Mode
    1
  }

//---  Register PMCTRL: Power Mode Control register
  PMCTRL @offset 0x1 $u8 {
    1
    RUNM:2 // at 5: Run Mode Control
    1
    STOPA // at 3: Stop Aborted
    STOPM:3 // at 0: Stop Mode Control
  }

//---  Register STOPCTRL: Stop Control Register
  STOPCTRL @offset 0x2 $u8 {
    PSTOPO:2 // at 6: Partial Stop Option
    PORPO // at 5: POR Power Option
    RAM2PO // at 4: RAM2 Power Option
    1
    LLSM:3 // at 0: LLS or VLLS Mode Control
  }

//---  Register PMSTAT: Power Mode Status register
  PMSTAT @offset 0x3 @ro $u8 {
    PMSTAT:8 // at 0: Power Mode Status
  }

}

//--- Enumerated values for register PMPROT, field AVLLS
  let SMC_PMPROT_AVLLS_Any_0 $bool = no // Any VLLSx mode is not allowed
  let SMC_PMPROT_AVLLS_Any_1 $bool = yes // Any VLLSx mode is allowed

//--- Enumerated values for register PMPROT, field ALLS
  let SMC_PMPROT_ALLS_Any_0 $bool = no // Any LLSx mode is not allowed
  let SMC_PMPROT_ALLS_Any_1 $bool = yes // Any LLSx mode is allowed

//--- Enumerated values for register PMPROT, field AVLP
  let SMC_PMPROT_AVLP_VLPR__0 $bool = no // VLPR, VLPW, and VLPS are not allowed.
  let SMC_PMPROT_AVLP_VLPR__1 $bool = yes // VLPR, VLPW, and VLPS are allowed.

//--- Enumerated values for register PMPROT, field AHSRUN
  let SMC_PMPROT_AHSRUN_HSRUN_0 $bool = no // HSRUN is not allowed
  let SMC_PMPROT_AHSRUN_HSRUN_1 $bool = yes // HSRUN is allowed

//--- Enumerated values for register PMCTRL, field STOPM
  let SMC_PMCTRL_STOPM_Normal_000 $u3 = 0 // Normal Stop (STOP)
  let SMC_PMCTRL_STOPM_Very_Low_Power_010 $u3 = 2 // Very-Low-Power Stop (VLPS)
  let SMC_PMCTRL_STOPM_Low_Leakage_011 $u3 = 3 // Low-Leakage Stop (LLSx)
  let SMC_PMCTRL_STOPM_Very_Low_Leakage_100 $u3 = 4 // Very-Low-Leakage Stop (VLLSx)
  let SMC_PMCTRL_STOPM_Reseved_110 $u3 = 6 // Reseved

//--- Enumerated values for register PMCTRL, field STOPA
  let SMC_PMCTRL_STOPA_The_0 $bool = no // The previous stop mode entry was successsful.
  let SMC_PMCTRL_STOPA_The_1 $bool = yes // The previous stop mode entry was aborted.

//--- Enumerated values for register PMCTRL, field RUNM
  let SMC_PMCTRL_RUNM_Normal_00 $u2 = 0 // Normal Run mode (RUN)
  let SMC_PMCTRL_RUNM_Very_Low_Power_10 $u2 = 2 // Very-Low-Power Run mode (VLPR)
  let SMC_PMCTRL_RUNM_High_11 $u2 = 3 // High Speed Run mode (HSRUN)

//--- Enumerated values for register STOPCTRL, field LLSM
  let SMC_STOPCTRL_LLSM_VLLS0_000 $u3 = 0 // VLLS0 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
  let SMC_STOPCTRL_LLSM_VLLS1_001 $u3 = 1 // VLLS1 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
  let SMC_STOPCTRL_LLSM_VLLS2_010 $u3 = 2 // VLLS2 if PMCTRL[STOPM]=VLLSx, LLS2 if PMCTRL[STOPM]=LLSx
  let SMC_STOPCTRL_LLSM_VLLS3_011 $u3 = 3 // VLLS3 if PMCTRL[STOPM]=VLLSx, LLS3 if PMCTRL[STOPM]=LLSx

//--- Enumerated values for register STOPCTRL, field RAM2PO
  let SMC_STOPCTRL_RAM2PO_RAM2_0 $bool = no // RAM2 not powered in LLS2/VLLS2
  let SMC_STOPCTRL_RAM2PO_RAM2_1 $bool = yes // RAM2 powered in LLS2/VLLS2

//--- Enumerated values for register STOPCTRL, field PORPO
  let SMC_STOPCTRL_PORPO_POR_0 $bool = no // POR detect circuit is enabled in VLLS0
  let SMC_STOPCTRL_PORPO_POR_1 $bool = yes // POR detect circuit is disabled in VLLS0

//--- Enumerated values for register STOPCTRL, field PSTOPO
  let SMC_STOPCTRL_PSTOPO_STOP_00 $u2 = 0 // STOP - Normal Stop mode
  let SMC_STOPCTRL_PSTOPO_PSTOP1_01 $u2 = 1 // PSTOP1 - Partial Stop with both system and bus clocks disabled
  let SMC_STOPCTRL_PSTOPO_PSTOP2_10 $u2 = 2 // PSTOP2 - Partial Stop with system clock disabled and bus clock enabled

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©SPI [3]
//        SPI0 at 0x4002c000
//        SPI1 at 0x4002d000
//        SPI2 at 0x400ac000
//------------------------------------------------------------------------------

registers ©SPI [3 @at 0x4002c000 0x4002d000 0x400ac000]
          ©SPI0 @at 0x4002c000
          ©SPI1 @at 0x4002d000
          ©SPI2 @at 0x400ac000 {
//---  Register MCR: Module Configuration Register
  MCR @offset 0x0 $u32 {
    MSTR // at 31: Master/Slave Mode Select
    CONT_SCKE // at 30: Continuous SCK Enable
    DCONF:2 // at 28: SPI Configuration.
    FRZ // at 27: Freeze
    MTFE // at 26: Modified Transfer Format Enable
    PCSSE // at 25: Peripheral Chip Select Strobe Enable
    ROOE // at 24: Receive FIFO Overflow Overwrite Enable
    2
    PCSIS:6 // at 16: Peripheral Chip Select x Inactive State
    DOZE // at 15: Doze Enable
    MDIS // at 14: Module Disable
    DIS_TXF // at 13: Disable Transmit FIFO
    DIS_RXF // at 12: Disable Receive FIFO
    CLR_TXF // at 11: Clear TX FIFO
    CLR_RXF // at 10: CLR_RXF
    SMPL_PT:2 // at 8: Sample Point
    7
    HALT // at 0: Halt
  }

//---  Register TCR: Transfer Count Register
  TCR @offset 0x8 $u32 {
    SPI_TCNT:16 // at 16: SPI Transfer Counter
    16
  }

//---  Registers CTAR(0,1): Clock and Transfer Attributes Register (In Master Mode)
  CTAR [2 @offset 0xc @inc 0x4]
  CTAR0 @offset 0xc
  CTAR1 @offset 0x10 $u32 {
    DBR // at 31: Double Baud Rate
    FMSZ:4 // at 27: Frame Size
    CPOL // at 26: Clock Polarity
    CPHA // at 25: Clock Phase
    LSBFE // at 24: LSB First
    PCSSCK:2 // at 22: PCS to SCK Delay Prescaler
    PASC:2 // at 20: After SCK Delay Prescaler
    PDT:2 // at 18: Delay after Transfer Prescaler
    PBR:2 // at 16: Baud Rate Prescaler
    CSSCK:4 // at 12: PCS to SCK Delay Scaler
    ASC:4 // at 8: After SCK Delay Scaler
    DT:4 // at 4: Delay After Transfer Scaler
    BR:4 // at 0: Baud Rate Scaler
  }

//---  Register CTAR_SLAVE: Clock and Transfer Attributes Register (In Slave Mode)
  CTAR_SLAVE @offset 0xc $u32 {
    1
    FMSZ:4 // at 27: Frame Size
    CPOL // at 26: Clock Polarity
    CPHA // at 25: Clock Phase
    25
  }

//---  Register SR: Status Register
  SR @offset 0x2c $u32 {
    TCF // at 31: Transfer Complete Flag
    TXRXS // at 30: TX and RX Status
    1
    EOQF // at 28: End of Queue Flag
    TFUF // at 27: Transmit FIFO Underflow Flag
    1
    TFFF // at 25: Transmit FIFO Fill Flag
    5
    RFOF // at 19: Receive FIFO Overflow Flag
    1
    RFDF // at 17: Receive FIFO Drain Flag
    1
    TXCTR:4 // at 12: TX FIFO Counter
    TXNXTPTR:4 // at 8: Transmit Next Pointer
    RXCTR:4 // at 4: RX FIFO Counter
    POPNXTPTR:4 // at 0: Pop Next Pointer
  }

//---  Register RSER: DMA/Interrupt Request Select and Enable Register
  RSER @offset 0x30 $u32 {
    TCF_RE // at 31: Transmission Complete Request Enable
    2
    EOQF_RE // at 28: Finished Request Enable
    TFUF_RE // at 27: Transmit FIFO Underflow Request Enable
    1
    TFFF_RE // at 25: Transmit FIFO Fill Request Enable
    TFFF_DIRS // at 24: Transmit FIFO Fill DMA or Interrupt Request Select
    4
    RFOF_RE // at 19: Receive FIFO Overflow Request Enable
    1
    RFDF_RE // at 17: Receive FIFO Drain Request Enable
    RFDF_DIRS // at 16: Receive FIFO Drain DMA or Interrupt Request Select
    16
  }

//---  Register PUSHR: PUSH TX FIFO Register In Master Mode
  PUSHR @offset 0x34 $u32 {
    CONT // at 31: Continuous Peripheral Chip Select Enable
    CTAS:3 // at 28: Clock and Transfer Attributes Select
    EOQ // at 27: End Of Queue
    CTCNT // at 26: Clear Transfer Counter
    4
    PCS:6 // at 16: Select which PCS signals are to be asserted for the transfer
    TXDATA:16 // at 0: Transmit Data
  }

//---  Register PUSHR_SLAVE: PUSH TX FIFO Register In Slave Mode
  PUSHR_SLAVE @offset 0x34 $u32 {
    TXDATA:32 // at 0: Transmit Data
  }

//---  Register POPR: POP RX FIFO Register
  POPR @offset 0x38 @ro $u32 {
    RXDATA:32 // at 0: Received Data
  }

//---  Registers TXFR(0,1,2,3): Transmit FIFO Registers
  TXFR [4 @offset 0x3c @inc 0x4]
  TXFR0 @offset 0x3c @ro
  TXFR1 @offset 0x40 @ro
  TXFR2 @offset 0x44 @ro
  TXFR3 @offset 0x48 @ro $u32 {
    TXCMD_TXDATA:16 // at 16: Transmit Command or Transmit Data
    TXDATA:16 // at 0: Transmit Data
  }

//---  Registers RXFR(0,1,2,3): Receive FIFO Registers
  RXFR [4 @offset 0x7c @inc 0x4]
  RXFR0 @offset 0x7c @ro
  RXFR1 @offset 0x80 @ro
  RXFR2 @offset 0x84 @ro
  RXFR3 @offset 0x88 @ro $u32 {
    RXDATA:32 // at 0: Receive Data
  }

}

//--- Enumerated values for register MCR, field HALT
  let SPI0_MCR_HALT_Start_0 $bool = no // Start transfers.
  let SPI0_MCR_HALT_Stop_1 $bool = yes // Stop transfers.

//--- Enumerated values for register MCR, field SMPL_PT
  let SPI0_MCR_SMPL_PT_0_00 $u2 = 0 // 0 protocol clock cycles between SCK edge and SIN sample
  let SPI0_MCR_SMPL_PT_1_01 $u2 = 1 // 1 protocol clock cycle between SCK edge and SIN sample
  let SPI0_MCR_SMPL_PT_2_10 $u2 = 2 // 2 protocol clock cycles between SCK edge and SIN sample

//--- Enumerated values for register MCR, field CLR_RXF
  let SPI0_MCR_CLR_RXF_Do_0 $bool = no // Do not clear the RX FIFO counter.
  let SPI0_MCR_CLR_RXF_Clear_1 $bool = yes // Clear the RX FIFO counter.

//--- Enumerated values for register MCR, field CLR_TXF
  let SPI0_MCR_CLR_TXF_Do_0 $bool = no // Do not clear the TX FIFO counter.
  let SPI0_MCR_CLR_TXF_Clear_1 $bool = yes // Clear the TX FIFO counter.

//--- Enumerated values for register MCR, field DIS_RXF
  let SPI0_MCR_DIS_RXF_RX_0 $bool = no // RX FIFO is enabled.
  let SPI0_MCR_DIS_RXF_RX_1 $bool = yes // RX FIFO is disabled.

//--- Enumerated values for register MCR, field DIS_TXF
  let SPI0_MCR_DIS_TXF_TX_0 $bool = no // TX FIFO is enabled.
  let SPI0_MCR_DIS_TXF_TX_1 $bool = yes // TX FIFO is disabled.

//--- Enumerated values for register MCR, field MDIS
  let SPI0_MCR_MDIS_Enables_0 $bool = no // Enables the module clocks.
  let SPI0_MCR_MDIS_Allows_1 $bool = yes // Allows external logic to disable the module clocks.

//--- Enumerated values for register MCR, field DOZE
  let SPI0_MCR_DOZE_Doze_0 $bool = no // Doze mode has no effect on the module.
  let SPI0_MCR_DOZE_Doze_1 $bool = yes // Doze mode disables the module.

//--- Enumerated values for register MCR, field PCSIS
  let SPI0_MCR_PCSIS_The_0 $u6 = 0 // The inactive state of PCSx is low.
  let SPI0_MCR_PCSIS_The_1 $u6 = 1 // The inactive state of PCSx is high.

//--- Enumerated values for register MCR, field ROOE
  let SPI0_MCR_ROOE_Incoming_0 $bool = no // Incoming data is ignored.
  let SPI0_MCR_ROOE_Incoming_1 $bool = yes // Incoming data is shifted into the shift register.

//--- Enumerated values for register MCR, field PCSSE
  let SPI0_MCR_PCSSE_PCS5__0 $bool = no // PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
  let SPI0_MCR_PCSSE_PCS5__1 $bool = yes // PCS5/ PCSS is used as an active-low PCS Strobe signal.

//--- Enumerated values for register MCR, field MTFE
  let SPI0_MCR_MTFE_Modified_0 $bool = no // Modified SPI transfer format disabled.
  let SPI0_MCR_MTFE_Modified_1 $bool = yes // Modified SPI transfer format enabled.

//--- Enumerated values for register MCR, field FRZ
  let SPI0_MCR_FRZ_Do_0 $bool = no // Do not halt serial transfers in Debug mode.
  let SPI0_MCR_FRZ_Halt_1 $bool = yes // Halt serial transfers in Debug mode.

//--- Enumerated values for register MCR, field DCONF
  let SPI0_MCR_DCONF_SPI_00 $u2 = 0 // SPI

//--- Enumerated values for register MCR, field CONT_SCKE
  let SPI0_MCR_CONT_SCKE_Continuous_0 $bool = no // Continuous SCK disabled.
  let SPI0_MCR_CONT_SCKE_Continuous_1 $bool = yes // Continuous SCK enabled.

//--- Enumerated values for register MCR, field MSTR
  let SPI0_MCR_MSTR_Enables_0 $bool = no // Enables Slave mode
  let SPI0_MCR_MSTR_Enables_1 $bool = yes // Enables Master mode

//--- Enumerated values for register CTAR%s, field PBR
  let SPI0_CTAR_PBR_Baud_00 $u2 = 0 // Baud Rate Prescaler value is 2.
  let SPI0_CTAR_PBR_Baud_01 $u2 = 1 // Baud Rate Prescaler value is 3.
  let SPI0_CTAR_PBR_Baud_10 $u2 = 2 // Baud Rate Prescaler value is 5.
  let SPI0_CTAR_PBR_Baud_11 $u2 = 3 // Baud Rate Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PDT
  let SPI0_CTAR_PDT_Delay_00 $u2 = 0 // Delay after Transfer Prescaler value is 1.
  let SPI0_CTAR_PDT_Delay_01 $u2 = 1 // Delay after Transfer Prescaler value is 3.
  let SPI0_CTAR_PDT_Delay_10 $u2 = 2 // Delay after Transfer Prescaler value is 5.
  let SPI0_CTAR_PDT_Delay_11 $u2 = 3 // Delay after Transfer Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PASC
  let SPI0_CTAR_PASC_Delay_00 $u2 = 0 // Delay after Transfer Prescaler value is 1.
  let SPI0_CTAR_PASC_Delay_01 $u2 = 1 // Delay after Transfer Prescaler value is 3.
  let SPI0_CTAR_PASC_Delay_10 $u2 = 2 // Delay after Transfer Prescaler value is 5.
  let SPI0_CTAR_PASC_Delay_11 $u2 = 3 // Delay after Transfer Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PCSSCK
  let SPI0_CTAR_PCSSCK_PCS_00 $u2 = 0 // PCS to SCK Prescaler value is 1.
  let SPI0_CTAR_PCSSCK_PCS_01 $u2 = 1 // PCS to SCK Prescaler value is 3.
  let SPI0_CTAR_PCSSCK_PCS_10 $u2 = 2 // PCS to SCK Prescaler value is 5.
  let SPI0_CTAR_PCSSCK_PCS_11 $u2 = 3 // PCS to SCK Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field LSBFE
  let SPI0_CTAR_LSBFE_Data_0 $bool = no // Data is transferred MSB first.
  let SPI0_CTAR_LSBFE_Data_1 $bool = yes // Data is transferred LSB first.

//--- Enumerated values for register CTAR%s, field CPHA
  let SPI0_CTAR_CPHA_Data_0 $bool = no // Data is captured on the leading edge of SCK and changed on the following edge.
  let SPI0_CTAR_CPHA_Data_1 $bool = yes // Data is changed on the leading edge of SCK and captured on the following edge.

//--- Enumerated values for register CTAR%s, field CPOL
  let SPI0_CTAR_CPOL_The_0 $bool = no // The inactive state value of SCK is low.
  let SPI0_CTAR_CPOL_The_1 $bool = yes // The inactive state value of SCK is high.

//--- Enumerated values for register CTAR%s, field DBR
  let SPI0_CTAR_DBR_The_0 $bool = no // The baud rate is computed normally with a 50/50 duty cycle.
  let SPI0_CTAR_DBR_The_1 $bool = yes // The baud rate is doubled with the duty cycle depending on the Baud Rate Prescaler.

//--- Enumerated values for register CTAR_SLAVE, field CPHA
  let SPI0_CTAR_SLAVE_CPHA_Data_0 $bool = no // Data is captured on the leading edge of SCK and changed on the following edge.
  let SPI0_CTAR_SLAVE_CPHA_Data_1 $bool = yes // Data is changed on the leading edge of SCK and captured on the following edge.

//--- Enumerated values for register CTAR_SLAVE, field CPOL
  let SPI0_CTAR_SLAVE_CPOL_The_0 $bool = no // The inactive state value of SCK is low.
  let SPI0_CTAR_SLAVE_CPOL_The_1 $bool = yes // The inactive state value of SCK is high.

//--- Enumerated values for register SR, field RFDF
  let SPI0_SR_RFDF_RX_0 $bool = no // RX FIFO is empty.
  let SPI0_SR_RFDF_RX_1 $bool = yes // RX FIFO is not empty.

//--- Enumerated values for register SR, field RFOF
  let SPI0_SR_RFOF_No_0 $bool = no // No Rx FIFO overflow.
  let SPI0_SR_RFOF_Rx_1 $bool = yes // Rx FIFO overflow has occurred.

//--- Enumerated values for register SR, field TFFF
  let SPI0_SR_TFFF_TX_0 $bool = no // TX FIFO is full.
  let SPI0_SR_TFFF_TX_1 $bool = yes // TX FIFO is not full.

//--- Enumerated values for register SR, field TFUF
  let SPI0_SR_TFUF_No_0 $bool = no // No TX FIFO underflow.
  let SPI0_SR_TFUF_TX_1 $bool = yes // TX FIFO underflow has occurred.

//--- Enumerated values for register SR, field EOQF
  let SPI0_SR_EOQF_EOQ_0 $bool = no // EOQ is not set in the executing command.
  let SPI0_SR_EOQF_EOQ_1 $bool = yes // EOQ is set in the executing SPI command.

//--- Enumerated values for register SR, field TXRXS
  let SPI0_SR_TXRXS_Transmit_0 $bool = no // Transmit and receive operations are disabled (The module is in Stopped state).
  let SPI0_SR_TXRXS_Transmit_1 $bool = yes // Transmit and receive operations are enabled (The module is in Running state).

//--- Enumerated values for register SR, field TCF
  let SPI0_SR_TCF_Transfer_0 $bool = no // Transfer not complete.
  let SPI0_SR_TCF_Transfer_1 $bool = yes // Transfer complete.

//--- Enumerated values for register RSER, field RFDF_DIRS
  let SPI0_RSER_RFDF_DIRS_Interrupt_0 $bool = no // Interrupt request.
  let SPI0_RSER_RFDF_DIRS_DMA_1 $bool = yes // DMA request.

//--- Enumerated values for register RSER, field RFDF_RE
  let SPI0_RSER_RFDF_RE_RFDF_0 $bool = no // RFDF interrupt or DMA requests are disabled.
  let SPI0_RSER_RFDF_RE_RFDF_1 $bool = yes // RFDF interrupt or DMA requests are enabled.

//--- Enumerated values for register RSER, field RFOF_RE
  let SPI0_RSER_RFOF_RE_RFOF_0 $bool = no // RFOF interrupt requests are disabled.
  let SPI0_RSER_RFOF_RE_RFOF_1 $bool = yes // RFOF interrupt requests are enabled.

//--- Enumerated values for register RSER, field TFFF_DIRS
  let SPI0_RSER_TFFF_DIRS_TFFF_0 $bool = no // TFFF flag generates interrupt requests.
  let SPI0_RSER_TFFF_DIRS_TFFF_1 $bool = yes // TFFF flag generates DMA requests.

//--- Enumerated values for register RSER, field TFFF_RE
  let SPI0_RSER_TFFF_RE_TFFF_0 $bool = no // TFFF interrupts or DMA requests are disabled.
  let SPI0_RSER_TFFF_RE_TFFF_1 $bool = yes // TFFF interrupts or DMA requests are enabled.

//--- Enumerated values for register RSER, field TFUF_RE
  let SPI0_RSER_TFUF_RE_TFUF_0 $bool = no // TFUF interrupt requests are disabled.
  let SPI0_RSER_TFUF_RE_TFUF_1 $bool = yes // TFUF interrupt requests are enabled.

//--- Enumerated values for register RSER, field EOQF_RE
  let SPI0_RSER_EOQF_RE_EOQF_0 $bool = no // EOQF interrupt requests are disabled.
  let SPI0_RSER_EOQF_RE_EOQF_1 $bool = yes // EOQF interrupt requests are enabled.

//--- Enumerated values for register RSER, field TCF_RE
  let SPI0_RSER_TCF_RE_TCF_0 $bool = no // TCF interrupt requests are disabled.
  let SPI0_RSER_TCF_RE_TCF_1 $bool = yes // TCF interrupt requests are enabled.

//--- Enumerated values for register PUSHR, field PCS
  let SPI0_PUSHR_PCS_Negate_0 $u6 = 0 // Negate the PCS[x] signal.
  let SPI0_PUSHR_PCS_Assert_1 $u6 = 1 // Assert the PCS[x] signal.

//--- Enumerated values for register PUSHR, field CTCNT
  let SPI0_PUSHR_CTCNT_Do_0 $bool = no // Do not clear the TCR[TCNT] field.
  let SPI0_PUSHR_CTCNT_Clear_1 $bool = yes // Clear the TCR[TCNT] field.

//--- Enumerated values for register PUSHR, field EOQ
  let SPI0_PUSHR_EOQ_The_0 $bool = no // The SPI data is not the last data to transfer.
  let SPI0_PUSHR_EOQ_The_1 $bool = yes // The SPI data is the last data to transfer.

//--- Enumerated values for register PUSHR, field CTAS
  let SPI0_PUSHR_CTAS_CTAR0_000 $u3 = 0 // CTAR0
  let SPI0_PUSHR_CTAS_CTAR1_001 $u3 = 1 // CTAR1

//--- Enumerated values for register PUSHR, field CONT
  let SPI0_PUSHR_CONT_Return_0 $bool = no // Return PCSn signals to their inactive state between transfers.
  let SPI0_PUSHR_CONT_Keep_1 $bool = yes // Keep PCSn signals asserted between transfers.

//--- Enumerated values for register MCR, field HALT
  let SPI1_MCR_HALT_Start_0 $bool = no // Start transfers.
  let SPI1_MCR_HALT_Stop_1 $bool = yes // Stop transfers.

//--- Enumerated values for register MCR, field SMPL_PT
  let SPI1_MCR_SMPL_PT_0_00 $u2 = 0 // 0 protocol clock cycles between SCK edge and SIN sample
  let SPI1_MCR_SMPL_PT_1_01 $u2 = 1 // 1 protocol clock cycle between SCK edge and SIN sample
  let SPI1_MCR_SMPL_PT_2_10 $u2 = 2 // 2 protocol clock cycles between SCK edge and SIN sample

//--- Enumerated values for register MCR, field CLR_RXF
  let SPI1_MCR_CLR_RXF_Do_0 $bool = no // Do not clear the RX FIFO counter.
  let SPI1_MCR_CLR_RXF_Clear_1 $bool = yes // Clear the RX FIFO counter.

//--- Enumerated values for register MCR, field CLR_TXF
  let SPI1_MCR_CLR_TXF_Do_0 $bool = no // Do not clear the TX FIFO counter.
  let SPI1_MCR_CLR_TXF_Clear_1 $bool = yes // Clear the TX FIFO counter.

//--- Enumerated values for register MCR, field DIS_RXF
  let SPI1_MCR_DIS_RXF_RX_0 $bool = no // RX FIFO is enabled.
  let SPI1_MCR_DIS_RXF_RX_1 $bool = yes // RX FIFO is disabled.

//--- Enumerated values for register MCR, field DIS_TXF
  let SPI1_MCR_DIS_TXF_TX_0 $bool = no // TX FIFO is enabled.
  let SPI1_MCR_DIS_TXF_TX_1 $bool = yes // TX FIFO is disabled.

//--- Enumerated values for register MCR, field MDIS
  let SPI1_MCR_MDIS_Enables_0 $bool = no // Enables the module clocks.
  let SPI1_MCR_MDIS_Allows_1 $bool = yes // Allows external logic to disable the module clocks.

//--- Enumerated values for register MCR, field DOZE
  let SPI1_MCR_DOZE_Doze_0 $bool = no // Doze mode has no effect on the module.
  let SPI1_MCR_DOZE_Doze_1 $bool = yes // Doze mode disables the module.

//--- Enumerated values for register MCR, field PCSIS
  let SPI1_MCR_PCSIS_The_0 $u6 = 0 // The inactive state of PCSx is low.
  let SPI1_MCR_PCSIS_The_1 $u6 = 1 // The inactive state of PCSx is high.

//--- Enumerated values for register MCR, field ROOE
  let SPI1_MCR_ROOE_Incoming_0 $bool = no // Incoming data is ignored.
  let SPI1_MCR_ROOE_Incoming_1 $bool = yes // Incoming data is shifted into the shift register.

//--- Enumerated values for register MCR, field PCSSE
  let SPI1_MCR_PCSSE_PCS5__0 $bool = no // PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
  let SPI1_MCR_PCSSE_PCS5__1 $bool = yes // PCS5/ PCSS is used as an active-low PCS Strobe signal.

//--- Enumerated values for register MCR, field MTFE
  let SPI1_MCR_MTFE_Modified_0 $bool = no // Modified SPI transfer format disabled.
  let SPI1_MCR_MTFE_Modified_1 $bool = yes // Modified SPI transfer format enabled.

//--- Enumerated values for register MCR, field FRZ
  let SPI1_MCR_FRZ_Do_0 $bool = no // Do not halt serial transfers in Debug mode.
  let SPI1_MCR_FRZ_Halt_1 $bool = yes // Halt serial transfers in Debug mode.

//--- Enumerated values for register MCR, field DCONF
  let SPI1_MCR_DCONF_SPI_00 $u2 = 0 // SPI

//--- Enumerated values for register MCR, field CONT_SCKE
  let SPI1_MCR_CONT_SCKE_Continuous_0 $bool = no // Continuous SCK disabled.
  let SPI1_MCR_CONT_SCKE_Continuous_1 $bool = yes // Continuous SCK enabled.

//--- Enumerated values for register MCR, field MSTR
  let SPI1_MCR_MSTR_Enables_0 $bool = no // Enables Slave mode
  let SPI1_MCR_MSTR_Enables_1 $bool = yes // Enables Master mode

//--- Enumerated values for register CTAR%s, field PBR
  let SPI1_CTAR_PBR_Baud_00 $u2 = 0 // Baud Rate Prescaler value is 2.
  let SPI1_CTAR_PBR_Baud_01 $u2 = 1 // Baud Rate Prescaler value is 3.
  let SPI1_CTAR_PBR_Baud_10 $u2 = 2 // Baud Rate Prescaler value is 5.
  let SPI1_CTAR_PBR_Baud_11 $u2 = 3 // Baud Rate Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PDT
  let SPI1_CTAR_PDT_Delay_00 $u2 = 0 // Delay after Transfer Prescaler value is 1.
  let SPI1_CTAR_PDT_Delay_01 $u2 = 1 // Delay after Transfer Prescaler value is 3.
  let SPI1_CTAR_PDT_Delay_10 $u2 = 2 // Delay after Transfer Prescaler value is 5.
  let SPI1_CTAR_PDT_Delay_11 $u2 = 3 // Delay after Transfer Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PASC
  let SPI1_CTAR_PASC_Delay_00 $u2 = 0 // Delay after Transfer Prescaler value is 1.
  let SPI1_CTAR_PASC_Delay_01 $u2 = 1 // Delay after Transfer Prescaler value is 3.
  let SPI1_CTAR_PASC_Delay_10 $u2 = 2 // Delay after Transfer Prescaler value is 5.
  let SPI1_CTAR_PASC_Delay_11 $u2 = 3 // Delay after Transfer Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PCSSCK
  let SPI1_CTAR_PCSSCK_PCS_00 $u2 = 0 // PCS to SCK Prescaler value is 1.
  let SPI1_CTAR_PCSSCK_PCS_01 $u2 = 1 // PCS to SCK Prescaler value is 3.
  let SPI1_CTAR_PCSSCK_PCS_10 $u2 = 2 // PCS to SCK Prescaler value is 5.
  let SPI1_CTAR_PCSSCK_PCS_11 $u2 = 3 // PCS to SCK Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field LSBFE
  let SPI1_CTAR_LSBFE_Data_0 $bool = no // Data is transferred MSB first.
  let SPI1_CTAR_LSBFE_Data_1 $bool = yes // Data is transferred LSB first.

//--- Enumerated values for register CTAR%s, field CPHA
  let SPI1_CTAR_CPHA_Data_0 $bool = no // Data is captured on the leading edge of SCK and changed on the following edge.
  let SPI1_CTAR_CPHA_Data_1 $bool = yes // Data is changed on the leading edge of SCK and captured on the following edge.

//--- Enumerated values for register CTAR%s, field CPOL
  let SPI1_CTAR_CPOL_The_0 $bool = no // The inactive state value of SCK is low.
  let SPI1_CTAR_CPOL_The_1 $bool = yes // The inactive state value of SCK is high.

//--- Enumerated values for register CTAR%s, field DBR
  let SPI1_CTAR_DBR_The_0 $bool = no // The baud rate is computed normally with a 50/50 duty cycle.
  let SPI1_CTAR_DBR_The_1 $bool = yes // The baud rate is doubled with the duty cycle depending on the Baud Rate Prescaler.

//--- Enumerated values for register CTAR_SLAVE, field CPHA
  let SPI1_CTAR_SLAVE_CPHA_Data_0 $bool = no // Data is captured on the leading edge of SCK and changed on the following edge.
  let SPI1_CTAR_SLAVE_CPHA_Data_1 $bool = yes // Data is changed on the leading edge of SCK and captured on the following edge.

//--- Enumerated values for register CTAR_SLAVE, field CPOL
  let SPI1_CTAR_SLAVE_CPOL_The_0 $bool = no // The inactive state value of SCK is low.
  let SPI1_CTAR_SLAVE_CPOL_The_1 $bool = yes // The inactive state value of SCK is high.

//--- Enumerated values for register SR, field RFDF
  let SPI1_SR_RFDF_RX_0 $bool = no // RX FIFO is empty.
  let SPI1_SR_RFDF_RX_1 $bool = yes // RX FIFO is not empty.

//--- Enumerated values for register SR, field RFOF
  let SPI1_SR_RFOF_No_0 $bool = no // No Rx FIFO overflow.
  let SPI1_SR_RFOF_Rx_1 $bool = yes // Rx FIFO overflow has occurred.

//--- Enumerated values for register SR, field TFFF
  let SPI1_SR_TFFF_TX_0 $bool = no // TX FIFO is full.
  let SPI1_SR_TFFF_TX_1 $bool = yes // TX FIFO is not full.

//--- Enumerated values for register SR, field TFUF
  let SPI1_SR_TFUF_No_0 $bool = no // No TX FIFO underflow.
  let SPI1_SR_TFUF_TX_1 $bool = yes // TX FIFO underflow has occurred.

//--- Enumerated values for register SR, field EOQF
  let SPI1_SR_EOQF_EOQ_0 $bool = no // EOQ is not set in the executing command.
  let SPI1_SR_EOQF_EOQ_1 $bool = yes // EOQ is set in the executing SPI command.

//--- Enumerated values for register SR, field TXRXS
  let SPI1_SR_TXRXS_Transmit_0 $bool = no // Transmit and receive operations are disabled (The module is in Stopped state).
  let SPI1_SR_TXRXS_Transmit_1 $bool = yes // Transmit and receive operations are enabled (The module is in Running state).

//--- Enumerated values for register SR, field TCF
  let SPI1_SR_TCF_Transfer_0 $bool = no // Transfer not complete.
  let SPI1_SR_TCF_Transfer_1 $bool = yes // Transfer complete.

//--- Enumerated values for register RSER, field RFDF_DIRS
  let SPI1_RSER_RFDF_DIRS_Interrupt_0 $bool = no // Interrupt request.
  let SPI1_RSER_RFDF_DIRS_DMA_1 $bool = yes // DMA request.

//--- Enumerated values for register RSER, field RFDF_RE
  let SPI1_RSER_RFDF_RE_RFDF_0 $bool = no // RFDF interrupt or DMA requests are disabled.
  let SPI1_RSER_RFDF_RE_RFDF_1 $bool = yes // RFDF interrupt or DMA requests are enabled.

//--- Enumerated values for register RSER, field RFOF_RE
  let SPI1_RSER_RFOF_RE_RFOF_0 $bool = no // RFOF interrupt requests are disabled.
  let SPI1_RSER_RFOF_RE_RFOF_1 $bool = yes // RFOF interrupt requests are enabled.

//--- Enumerated values for register RSER, field TFFF_DIRS
  let SPI1_RSER_TFFF_DIRS_TFFF_0 $bool = no // TFFF flag generates interrupt requests.
  let SPI1_RSER_TFFF_DIRS_TFFF_1 $bool = yes // TFFF flag generates DMA requests.

//--- Enumerated values for register RSER, field TFFF_RE
  let SPI1_RSER_TFFF_RE_TFFF_0 $bool = no // TFFF interrupts or DMA requests are disabled.
  let SPI1_RSER_TFFF_RE_TFFF_1 $bool = yes // TFFF interrupts or DMA requests are enabled.

//--- Enumerated values for register RSER, field TFUF_RE
  let SPI1_RSER_TFUF_RE_TFUF_0 $bool = no // TFUF interrupt requests are disabled.
  let SPI1_RSER_TFUF_RE_TFUF_1 $bool = yes // TFUF interrupt requests are enabled.

//--- Enumerated values for register RSER, field EOQF_RE
  let SPI1_RSER_EOQF_RE_EOQF_0 $bool = no // EOQF interrupt requests are disabled.
  let SPI1_RSER_EOQF_RE_EOQF_1 $bool = yes // EOQF interrupt requests are enabled.

//--- Enumerated values for register RSER, field TCF_RE
  let SPI1_RSER_TCF_RE_TCF_0 $bool = no // TCF interrupt requests are disabled.
  let SPI1_RSER_TCF_RE_TCF_1 $bool = yes // TCF interrupt requests are enabled.

//--- Enumerated values for register PUSHR, field PCS
  let SPI1_PUSHR_PCS_Negate_0 $u6 = 0 // Negate the PCS[x] signal.
  let SPI1_PUSHR_PCS_Assert_1 $u6 = 1 // Assert the PCS[x] signal.

//--- Enumerated values for register PUSHR, field CTCNT
  let SPI1_PUSHR_CTCNT_Do_0 $bool = no // Do not clear the TCR[TCNT] field.
  let SPI1_PUSHR_CTCNT_Clear_1 $bool = yes // Clear the TCR[TCNT] field.

//--- Enumerated values for register PUSHR, field EOQ
  let SPI1_PUSHR_EOQ_The_0 $bool = no // The SPI data is not the last data to transfer.
  let SPI1_PUSHR_EOQ_The_1 $bool = yes // The SPI data is the last data to transfer.

//--- Enumerated values for register PUSHR, field CTAS
  let SPI1_PUSHR_CTAS_CTAR0_000 $u3 = 0 // CTAR0
  let SPI1_PUSHR_CTAS_CTAR1_001 $u3 = 1 // CTAR1

//--- Enumerated values for register PUSHR, field CONT
  let SPI1_PUSHR_CONT_Return_0 $bool = no // Return PCSn signals to their inactive state between transfers.
  let SPI1_PUSHR_CONT_Keep_1 $bool = yes // Keep PCSn signals asserted between transfers.

//--- Enumerated values for register MCR, field HALT
  let SPI2_MCR_HALT_Start_0 $bool = no // Start transfers.
  let SPI2_MCR_HALT_Stop_1 $bool = yes // Stop transfers.

//--- Enumerated values for register MCR, field SMPL_PT
  let SPI2_MCR_SMPL_PT_0_00 $u2 = 0 // 0 protocol clock cycles between SCK edge and SIN sample
  let SPI2_MCR_SMPL_PT_1_01 $u2 = 1 // 1 protocol clock cycle between SCK edge and SIN sample
  let SPI2_MCR_SMPL_PT_2_10 $u2 = 2 // 2 protocol clock cycles between SCK edge and SIN sample

//--- Enumerated values for register MCR, field CLR_RXF
  let SPI2_MCR_CLR_RXF_Do_0 $bool = no // Do not clear the RX FIFO counter.
  let SPI2_MCR_CLR_RXF_Clear_1 $bool = yes // Clear the RX FIFO counter.

//--- Enumerated values for register MCR, field CLR_TXF
  let SPI2_MCR_CLR_TXF_Do_0 $bool = no // Do not clear the TX FIFO counter.
  let SPI2_MCR_CLR_TXF_Clear_1 $bool = yes // Clear the TX FIFO counter.

//--- Enumerated values for register MCR, field DIS_RXF
  let SPI2_MCR_DIS_RXF_RX_0 $bool = no // RX FIFO is enabled.
  let SPI2_MCR_DIS_RXF_RX_1 $bool = yes // RX FIFO is disabled.

//--- Enumerated values for register MCR, field DIS_TXF
  let SPI2_MCR_DIS_TXF_TX_0 $bool = no // TX FIFO is enabled.
  let SPI2_MCR_DIS_TXF_TX_1 $bool = yes // TX FIFO is disabled.

//--- Enumerated values for register MCR, field MDIS
  let SPI2_MCR_MDIS_Enables_0 $bool = no // Enables the module clocks.
  let SPI2_MCR_MDIS_Allows_1 $bool = yes // Allows external logic to disable the module clocks.

//--- Enumerated values for register MCR, field DOZE
  let SPI2_MCR_DOZE_Doze_0 $bool = no // Doze mode has no effect on the module.
  let SPI2_MCR_DOZE_Doze_1 $bool = yes // Doze mode disables the module.

//--- Enumerated values for register MCR, field PCSIS
  let SPI2_MCR_PCSIS_The_0 $u6 = 0 // The inactive state of PCSx is low.
  let SPI2_MCR_PCSIS_The_1 $u6 = 1 // The inactive state of PCSx is high.

//--- Enumerated values for register MCR, field ROOE
  let SPI2_MCR_ROOE_Incoming_0 $bool = no // Incoming data is ignored.
  let SPI2_MCR_ROOE_Incoming_1 $bool = yes // Incoming data is shifted into the shift register.

//--- Enumerated values for register MCR, field PCSSE
  let SPI2_MCR_PCSSE_PCS5__0 $bool = no // PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
  let SPI2_MCR_PCSSE_PCS5__1 $bool = yes // PCS5/ PCSS is used as an active-low PCS Strobe signal.

//--- Enumerated values for register MCR, field MTFE
  let SPI2_MCR_MTFE_Modified_0 $bool = no // Modified SPI transfer format disabled.
  let SPI2_MCR_MTFE_Modified_1 $bool = yes // Modified SPI transfer format enabled.

//--- Enumerated values for register MCR, field FRZ
  let SPI2_MCR_FRZ_Do_0 $bool = no // Do not halt serial transfers in Debug mode.
  let SPI2_MCR_FRZ_Halt_1 $bool = yes // Halt serial transfers in Debug mode.

//--- Enumerated values for register MCR, field DCONF
  let SPI2_MCR_DCONF_SPI_00 $u2 = 0 // SPI

//--- Enumerated values for register MCR, field CONT_SCKE
  let SPI2_MCR_CONT_SCKE_Continuous_0 $bool = no // Continuous SCK disabled.
  let SPI2_MCR_CONT_SCKE_Continuous_1 $bool = yes // Continuous SCK enabled.

//--- Enumerated values for register MCR, field MSTR
  let SPI2_MCR_MSTR_Enables_0 $bool = no // Enables Slave mode
  let SPI2_MCR_MSTR_Enables_1 $bool = yes // Enables Master mode

//--- Enumerated values for register CTAR%s, field PBR
  let SPI2_CTAR_PBR_Baud_00 $u2 = 0 // Baud Rate Prescaler value is 2.
  let SPI2_CTAR_PBR_Baud_01 $u2 = 1 // Baud Rate Prescaler value is 3.
  let SPI2_CTAR_PBR_Baud_10 $u2 = 2 // Baud Rate Prescaler value is 5.
  let SPI2_CTAR_PBR_Baud_11 $u2 = 3 // Baud Rate Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PDT
  let SPI2_CTAR_PDT_Delay_00 $u2 = 0 // Delay after Transfer Prescaler value is 1.
  let SPI2_CTAR_PDT_Delay_01 $u2 = 1 // Delay after Transfer Prescaler value is 3.
  let SPI2_CTAR_PDT_Delay_10 $u2 = 2 // Delay after Transfer Prescaler value is 5.
  let SPI2_CTAR_PDT_Delay_11 $u2 = 3 // Delay after Transfer Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PASC
  let SPI2_CTAR_PASC_Delay_00 $u2 = 0 // Delay after Transfer Prescaler value is 1.
  let SPI2_CTAR_PASC_Delay_01 $u2 = 1 // Delay after Transfer Prescaler value is 3.
  let SPI2_CTAR_PASC_Delay_10 $u2 = 2 // Delay after Transfer Prescaler value is 5.
  let SPI2_CTAR_PASC_Delay_11 $u2 = 3 // Delay after Transfer Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field PCSSCK
  let SPI2_CTAR_PCSSCK_PCS_00 $u2 = 0 // PCS to SCK Prescaler value is 1.
  let SPI2_CTAR_PCSSCK_PCS_01 $u2 = 1 // PCS to SCK Prescaler value is 3.
  let SPI2_CTAR_PCSSCK_PCS_10 $u2 = 2 // PCS to SCK Prescaler value is 5.
  let SPI2_CTAR_PCSSCK_PCS_11 $u2 = 3 // PCS to SCK Prescaler value is 7.

//--- Enumerated values for register CTAR%s, field LSBFE
  let SPI2_CTAR_LSBFE_Data_0 $bool = no // Data is transferred MSB first.
  let SPI2_CTAR_LSBFE_Data_1 $bool = yes // Data is transferred LSB first.

//--- Enumerated values for register CTAR%s, field CPHA
  let SPI2_CTAR_CPHA_Data_0 $bool = no // Data is captured on the leading edge of SCK and changed on the following edge.
  let SPI2_CTAR_CPHA_Data_1 $bool = yes // Data is changed on the leading edge of SCK and captured on the following edge.

//--- Enumerated values for register CTAR%s, field CPOL
  let SPI2_CTAR_CPOL_The_0 $bool = no // The inactive state value of SCK is low.
  let SPI2_CTAR_CPOL_The_1 $bool = yes // The inactive state value of SCK is high.

//--- Enumerated values for register CTAR%s, field DBR
  let SPI2_CTAR_DBR_The_0 $bool = no // The baud rate is computed normally with a 50/50 duty cycle.
  let SPI2_CTAR_DBR_The_1 $bool = yes // The baud rate is doubled with the duty cycle depending on the Baud Rate Prescaler.

//--- Enumerated values for register CTAR_SLAVE, field CPHA
  let SPI2_CTAR_SLAVE_CPHA_Data_0 $bool = no // Data is captured on the leading edge of SCK and changed on the following edge.
  let SPI2_CTAR_SLAVE_CPHA_Data_1 $bool = yes // Data is changed on the leading edge of SCK and captured on the following edge.

//--- Enumerated values for register CTAR_SLAVE, field CPOL
  let SPI2_CTAR_SLAVE_CPOL_The_0 $bool = no // The inactive state value of SCK is low.
  let SPI2_CTAR_SLAVE_CPOL_The_1 $bool = yes // The inactive state value of SCK is high.

//--- Enumerated values for register SR, field RFDF
  let SPI2_SR_RFDF_RX_0 $bool = no // RX FIFO is empty.
  let SPI2_SR_RFDF_RX_1 $bool = yes // RX FIFO is not empty.

//--- Enumerated values for register SR, field RFOF
  let SPI2_SR_RFOF_No_0 $bool = no // No Rx FIFO overflow.
  let SPI2_SR_RFOF_Rx_1 $bool = yes // Rx FIFO overflow has occurred.

//--- Enumerated values for register SR, field TFFF
  let SPI2_SR_TFFF_TX_0 $bool = no // TX FIFO is full.
  let SPI2_SR_TFFF_TX_1 $bool = yes // TX FIFO is not full.

//--- Enumerated values for register SR, field TFUF
  let SPI2_SR_TFUF_No_0 $bool = no // No TX FIFO underflow.
  let SPI2_SR_TFUF_TX_1 $bool = yes // TX FIFO underflow has occurred.

//--- Enumerated values for register SR, field EOQF
  let SPI2_SR_EOQF_EOQ_0 $bool = no // EOQ is not set in the executing command.
  let SPI2_SR_EOQF_EOQ_1 $bool = yes // EOQ is set in the executing SPI command.

//--- Enumerated values for register SR, field TXRXS
  let SPI2_SR_TXRXS_Transmit_0 $bool = no // Transmit and receive operations are disabled (The module is in Stopped state).
  let SPI2_SR_TXRXS_Transmit_1 $bool = yes // Transmit and receive operations are enabled (The module is in Running state).

//--- Enumerated values for register SR, field TCF
  let SPI2_SR_TCF_Transfer_0 $bool = no // Transfer not complete.
  let SPI2_SR_TCF_Transfer_1 $bool = yes // Transfer complete.

//--- Enumerated values for register RSER, field RFDF_DIRS
  let SPI2_RSER_RFDF_DIRS_Interrupt_0 $bool = no // Interrupt request.
  let SPI2_RSER_RFDF_DIRS_DMA_1 $bool = yes // DMA request.

//--- Enumerated values for register RSER, field RFDF_RE
  let SPI2_RSER_RFDF_RE_RFDF_0 $bool = no // RFDF interrupt or DMA requests are disabled.
  let SPI2_RSER_RFDF_RE_RFDF_1 $bool = yes // RFDF interrupt or DMA requests are enabled.

//--- Enumerated values for register RSER, field RFOF_RE
  let SPI2_RSER_RFOF_RE_RFOF_0 $bool = no // RFOF interrupt requests are disabled.
  let SPI2_RSER_RFOF_RE_RFOF_1 $bool = yes // RFOF interrupt requests are enabled.

//--- Enumerated values for register RSER, field TFFF_DIRS
  let SPI2_RSER_TFFF_DIRS_TFFF_0 $bool = no // TFFF flag generates interrupt requests.
  let SPI2_RSER_TFFF_DIRS_TFFF_1 $bool = yes // TFFF flag generates DMA requests.

//--- Enumerated values for register RSER, field TFFF_RE
  let SPI2_RSER_TFFF_RE_TFFF_0 $bool = no // TFFF interrupts or DMA requests are disabled.
  let SPI2_RSER_TFFF_RE_TFFF_1 $bool = yes // TFFF interrupts or DMA requests are enabled.

//--- Enumerated values for register RSER, field TFUF_RE
  let SPI2_RSER_TFUF_RE_TFUF_0 $bool = no // TFUF interrupt requests are disabled.
  let SPI2_RSER_TFUF_RE_TFUF_1 $bool = yes // TFUF interrupt requests are enabled.

//--- Enumerated values for register RSER, field EOQF_RE
  let SPI2_RSER_EOQF_RE_EOQF_0 $bool = no // EOQF interrupt requests are disabled.
  let SPI2_RSER_EOQF_RE_EOQF_1 $bool = yes // EOQF interrupt requests are enabled.

//--- Enumerated values for register RSER, field TCF_RE
  let SPI2_RSER_TCF_RE_TCF_0 $bool = no // TCF interrupt requests are disabled.
  let SPI2_RSER_TCF_RE_TCF_1 $bool = yes // TCF interrupt requests are enabled.

//--- Enumerated values for register PUSHR, field PCS
  let SPI2_PUSHR_PCS_Negate_0 $u6 = 0 // Negate the PCS[x] signal.
  let SPI2_PUSHR_PCS_Assert_1 $u6 = 1 // Assert the PCS[x] signal.

//--- Enumerated values for register PUSHR, field CTCNT
  let SPI2_PUSHR_CTCNT_Do_0 $bool = no // Do not clear the TCR[TCNT] field.
  let SPI2_PUSHR_CTCNT_Clear_1 $bool = yes // Clear the TCR[TCNT] field.

//--- Enumerated values for register PUSHR, field EOQ
  let SPI2_PUSHR_EOQ_The_0 $bool = no // The SPI data is not the last data to transfer.
  let SPI2_PUSHR_EOQ_The_1 $bool = yes // The SPI data is the last data to transfer.

//--- Enumerated values for register PUSHR, field CTAS
  let SPI2_PUSHR_CTAS_CTAR0_000 $u3 = 0 // CTAR0
  let SPI2_PUSHR_CTAS_CTAR1_001 $u3 = 1 // CTAR1

//--- Enumerated values for register PUSHR, field CONT
  let SPI2_PUSHR_CONT_Return_0 $bool = no // Return PCSn signals to their inactive state between transfers.
  let SPI2_PUSHR_CONT_Keep_1 $bool = yes // Keep PCSn signals asserted between transfers.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©TPM [2]
//        TPM1 at 0x400c9000
//        TPM2 at 0x400ca000
//------------------------------------------------------------------------------

registers ©TPM [2 @at 0x400c9000 0x400ca000]
          ©TPM1 @at 0x400c9000
          ©TPM2 @at 0x400ca000 {
//---  Register SC: Status and Control
  SC @offset 0x0 $u32 {
    23
    DMA // at 8: DMA Enable
    TOF // at 7: Timer Overflow Flag
    TOIE // at 6: Timer Overflow Interrupt Enable
    CPWMS // at 5: Center-Aligned PWM Select
    CMOD:2 // at 3: Clock Mode Selection
    PS:3 // at 0: Prescale Factor Selection
  }

//---  Register CNT: Counter
  CNT @offset 0x4 $u32 {
    16
    COUNT:16 // at 0: Counter value
  }

//---  Register MOD: Modulo
  MOD @offset 0x8 $u32 {
    16
    MOD:16 // at 0: Modulo value
  }

//---  Registers CSC(0,1,2,3,4,5,6,7): Channel (n) Status and Control
  CSC [8 @offset 0xc @inc 0x8]
  C0SC @offset 0xc
  C1SC @offset 0x14
  C2SC @offset 0x1c
  C3SC @offset 0x24
  C4SC @offset 0x2c
  C5SC @offset 0x34
  C6SC @offset 0x3c
  C7SC @offset 0x44 $u32 {
    24
    CHF // at 7: Channel Flag
    CHIE // at 6: Channel Interrupt Enable
    MSB // at 5: Channel Mode Select
    MSA // at 4: Channel Mode Select
    ELSB // at 3: Edge or Level Select
    ELSA // at 2: Edge or Level Select
    1
    DMA // at 0: DMA Enable
  }

//---  Registers CV(0,1): Channel (n) Value
  CV [2 @offset 0x10 @inc 0x8]
  C0V @offset 0x10
  C1V @offset 0x18 $u32 {
    16
    VAL:16 // at 0: Channel Value
  }

//---  Register STATUS: Capture and Compare Status
  STATUS @offset 0x50 $u32 {
    23
    TOF // at 8: Timer Overflow Flag
    6
    CH1F // at 1: Channel 1 Flag
    CH0F // at 0: Channel 0 Flag
  }

//---  Register COMBINE: Combine Channel Register
  COMBINE @offset 0x64 $u32 {
    30
    COMSWAP0 // at 1: Combine Channel 0 and 1 Swap
    COMBINE0 // at 0: Combine Channels 0 and 1
  }

//---  Register POL: Channel Polarity
  POL @offset 0x70 $u32 {
    30
    POL1 // at 1: Channel 1 Polarity
    POL0 // at 0: Channel 0 Polarity
  }

//---  Register FILTER: Filter Control
  FILTER @offset 0x78 $u32 {
    24
    CH1FVAL:4 // at 4: Channel 1 Filter Value
    CH0FVAL:4 // at 0: Channel 0 Filter Value
  }

//---  Register QDCTRL: Quadrature Decoder Control and Status
  QDCTRL @offset 0x80 $u32 {
    28
    QUADMODE // at 3: Quadrature Decoder Mode
    QUADIR // at 2: Counter Direction in Quadrature Decode Mode
    TOFDIR // at 1: Indicates if the TOF bit was set on the top or the bottom of counting.
    QUADEN // at 0: Enables the quadrature decoder mode
  }

//---  Register CONF: Configuration
  CONF @offset 0x84 $u32 {
    4
    TRGSEL:4 // at 24: Trigger Select
    TRGSRC // at 23: Trigger Source
    TRGPOL // at 22: Trigger Polarity
    2
    CPOT // at 19: Counter Pause On Trigger
    CROT // at 18: Counter Reload On Trigger
    CSOO // at 17: Counter Stop On Overflow
    CSOT // at 16: Counter Start on Trigger
    6
    GTBEEN // at 9: Global time base enable
    GTBSYNC // at 8: Global Time Base Synchronization
    DBGMODE:2 // at 6: Debug Mode
    DOZEEN // at 5: Doze Enable
    5
  }

}

//--- Enumerated values for register SC, field PS
  let TPM1_SC_PS_Divide_000 $u3 = 0 // Divide by 1
  let TPM1_SC_PS_Divide_001 $u3 = 1 // Divide by 2
  let TPM1_SC_PS_Divide_010 $u3 = 2 // Divide by 4
  let TPM1_SC_PS_Divide_011 $u3 = 3 // Divide by 8
  let TPM1_SC_PS_Divide_100 $u3 = 4 // Divide by 16
  let TPM1_SC_PS_Divide_101 $u3 = 5 // Divide by 32
  let TPM1_SC_PS_Divide_110 $u3 = 6 // Divide by 64
  let TPM1_SC_PS_Divide_111 $u3 = 7 // Divide by 128

//--- Enumerated values for register SC, field CMOD
  let TPM1_SC_CMOD_TPM_00 $u2 = 0 // TPM counter is disabled
  let TPM1_SC_CMOD_TPM_01 $u2 = 1 // TPM counter increments on every TPM counter clock
  let TPM1_SC_CMOD_TPM_10 $u2 = 2 // TPM counter increments on rising edge of TPM_EXTCLK synchronized to the TPM counter clock

//--- Enumerated values for register SC, field CPWMS
  let TPM1_SC_CPWMS_TPM_0 $bool = no // TPM counter operates in up counting mode.
  let TPM1_SC_CPWMS_TPM_1 $bool = yes // TPM counter operates in up-down counting mode.

//--- Enumerated values for register SC, field TOIE
  let TPM1_SC_TOIE_Disable_0 $bool = no // Disable TOF interrupts. Use software polling or DMA request.
  let TPM1_SC_TOIE_Enable_1 $bool = yes // Enable TOF interrupts. An interrupt is generated when TOF equals one.

//--- Enumerated values for register SC, field TOF
  let TPM1_SC_TOF_TPM_0 $bool = no // TPM counter has not overflowed.
  let TPM1_SC_TOF_TPM_1 $bool = yes // TPM counter has overflowed.

//--- Enumerated values for register SC, field DMA
  let TPM1_SC_DMA_Disables_0 $bool = no // Disables DMA transfers.
  let TPM1_SC_DMA_Enables_1 $bool = yes // Enables DMA transfers.

//--- Enumerated values for register C%sSC, field DMA
  let TPM1_CSC_DMA_Disable_0 $bool = no // Disable DMA transfers.
  let TPM1_CSC_DMA_Enable_1 $bool = yes // Enable DMA transfers.

//--- Enumerated values for register C%sSC, field CHIE
  let TPM1_CSC_CHIE_Disable_0 $bool = no // Disable channel interrupts.
  let TPM1_CSC_CHIE_Enable_1 $bool = yes // Enable channel interrupts.

//--- Enumerated values for register C%sSC, field CHF
  let TPM1_CSC_CHF_No_0 $bool = no // No channel event has occurred.
  let TPM1_CSC_CHF_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH0F
  let TPM1_STATUS_CH0F_No_0 $bool = no // No channel event has occurred.
  let TPM1_STATUS_CH0F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH1F
  let TPM1_STATUS_CH1F_No_0 $bool = no // No channel event has occurred.
  let TPM1_STATUS_CH1F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field TOF
  let TPM1_STATUS_TOF_TPM_0 $bool = no // TPM counter has not overflowed.
  let TPM1_STATUS_TOF_TPM_1 $bool = yes // TPM counter has overflowed.

//--- Enumerated values for register COMBINE, field COMBINE0
  let TPM1_COMBINE_COMBINE0_Channels_0 $bool = no // Channels 0 and 1 are independent.
  let TPM1_COMBINE_COMBINE0_Channels_1 $bool = yes // Channels 0 and 1 are combined.

//--- Enumerated values for register COMBINE, field COMSWAP0
  let TPM1_COMBINE_COMSWAP0_Even_0 $bool = no // Even channel is used for input capture and 1st compare.
  let TPM1_COMBINE_COMSWAP0_Odd_1 $bool = yes // Odd channel is used for input capture and 1st compare.

//--- Enumerated values for register POL, field POL0
  let TPM1_POL_POL0_The_0 $bool = no // The channel polarity is active high.
  let TPM1_POL_POL0_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL1
  let TPM1_POL_POL1_The_0 $bool = no // The channel polarity is active high.
  let TPM1_POL_POL1_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register QDCTRL, field QUADEN
  let TPM1_QDCTRL_QUADEN_Quadrature_0 $bool = no // Quadrature decoder mode is disabled.
  let TPM1_QDCTRL_QUADEN_Quadrature_1 $bool = yes // Quadrature decoder mode is enabled.

//--- Enumerated values for register QDCTRL, field TOFDIR
  let TPM1_QDCTRL_TOFDIR_TOF_0 $bool = no // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (zero) to its maximum value (MOD register).
  let TPM1_QDCTRL_TOFDIR_TOF_1 $bool = yes // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (zero).

//--- Enumerated values for register QDCTRL, field QUADIR
  let TPM1_QDCTRL_QUADIR_Counter_0 $bool = no // Counter direction is decreasing (counter decrement).
  let TPM1_QDCTRL_QUADIR_Counter_1 $bool = yes // Counter direction is increasing (counter increment).

//--- Enumerated values for register QDCTRL, field QUADMODE
  let TPM1_QDCTRL_QUADMODE_Phase_0 $bool = no // Phase encoding mode.
  let TPM1_QDCTRL_QUADMODE_Count_1 $bool = yes // Count and direction encoding mode.

//--- Enumerated values for register CONF, field DOZEEN
  let TPM1_CONF_DOZEEN_Internal_0 $bool = no // Internal TPM counter continues in Doze mode.
  let TPM1_CONF_DOZEEN_Internal_1 $bool = yes // Internal TPM counter is paused and does not increment during Doze mode. Trigger inputs and input capture events are also ignored.

//--- Enumerated values for register CONF, field DBGMODE
  let TPM1_CONF_DBGMODE_TPM_00 $u2 = 0 // TPM counter is paused and does not increment during debug mode. Trigger inputs and input capture events are also ignored.
  let TPM1_CONF_DBGMODE_TPM_11 $u2 = 3 // TPM counter continues in debug mode.

//--- Enumerated values for register CONF, field GTBSYNC
  let TPM1_CONF_GTBSYNC_Global_0 $bool = no // Global timebase synchronization disabled.
  let TPM1_CONF_GTBSYNC_Global_1 $bool = yes // Global timebase synchronization enabled.

//--- Enumerated values for register CONF, field GTBEEN
  let TPM1_CONF_GTBEEN_All_0 $bool = no // All channels use the internally generated TPM counter as their timebase
  let TPM1_CONF_GTBEEN_All_1 $bool = yes // All channels use an externally generated global timebase as their timebase

//--- Enumerated values for register CONF, field CSOT
  let TPM1_CONF_CSOT_TPM_0 $bool = no // TPM counter starts to increment immediately, once it is enabled.
  let TPM1_CONF_CSOT_TPM_1 $bool = yes // TPM counter only starts to increment when it a rising edge on the selected input trigger is detected, after it has been enabled or after it has stopped due to overflow.

//--- Enumerated values for register CONF, field CSOO
  let TPM1_CONF_CSOO_TPM_0 $bool = no // TPM counter continues incrementing or decrementing after overflow
  let TPM1_CONF_CSOO_TPM_1 $bool = yes // TPM counter stops incrementing or decrementing after overflow.

//--- Enumerated values for register CONF, field CROT
  let TPM1_CONF_CROT_Counter_0 $bool = no // Counter is not reloaded due to a rising edge on the selected input trigger
  let TPM1_CONF_CROT_Counter_1 $bool = yes // Counter is reloaded when a rising edge is detected on the selected input trigger

//--- Enumerated values for register CONF, field TRGPOL
  let TPM1_CONF_TRGPOL_Trigger_0 $bool = no // Trigger is active high.
  let TPM1_CONF_TRGPOL_Trigger_1 $bool = yes // Trigger is active low.

//--- Enumerated values for register CONF, field TRGSRC
  let TPM1_CONF_TRGSRC_Trigger_0 $bool = no // Trigger source selected by TRGSEL is external.
  let TPM1_CONF_TRGSRC_Trigger_1 $bool = yes // Trigger source selected by TRGSEL is internal (channel pin input capture).

//--- Enumerated values for register CONF, field TRGSEL
  let TPM1_CONF_TRGSEL_Channel_0001 $u4 = 1 // Channel 0 pin input capture
  let TPM1_CONF_TRGSEL_Channel_0010 $u4 = 2 // Channel 1 pin input capture
  let TPM1_CONF_TRGSEL_Channel_0011 $u4 = 3 // Channel 0 or Channel 1 pin input capture

//--- Enumerated values for register SC, field PS
  let TPM2_SC_PS_Divide_000 $u3 = 0 // Divide by 1
  let TPM2_SC_PS_Divide_001 $u3 = 1 // Divide by 2
  let TPM2_SC_PS_Divide_010 $u3 = 2 // Divide by 4
  let TPM2_SC_PS_Divide_011 $u3 = 3 // Divide by 8
  let TPM2_SC_PS_Divide_100 $u3 = 4 // Divide by 16
  let TPM2_SC_PS_Divide_101 $u3 = 5 // Divide by 32
  let TPM2_SC_PS_Divide_110 $u3 = 6 // Divide by 64
  let TPM2_SC_PS_Divide_111 $u3 = 7 // Divide by 128

//--- Enumerated values for register SC, field CMOD
  let TPM2_SC_CMOD_TPM_00 $u2 = 0 // TPM counter is disabled
  let TPM2_SC_CMOD_TPM_01 $u2 = 1 // TPM counter increments on every TPM counter clock
  let TPM2_SC_CMOD_TPM_10 $u2 = 2 // TPM counter increments on rising edge of TPM_EXTCLK synchronized to the TPM counter clock

//--- Enumerated values for register SC, field CPWMS
  let TPM2_SC_CPWMS_TPM_0 $bool = no // TPM counter operates in up counting mode.
  let TPM2_SC_CPWMS_TPM_1 $bool = yes // TPM counter operates in up-down counting mode.

//--- Enumerated values for register SC, field TOIE
  let TPM2_SC_TOIE_Disable_0 $bool = no // Disable TOF interrupts. Use software polling or DMA request.
  let TPM2_SC_TOIE_Enable_1 $bool = yes // Enable TOF interrupts. An interrupt is generated when TOF equals one.

//--- Enumerated values for register SC, field TOF
  let TPM2_SC_TOF_TPM_0 $bool = no // TPM counter has not overflowed.
  let TPM2_SC_TOF_TPM_1 $bool = yes // TPM counter has overflowed.

//--- Enumerated values for register SC, field DMA
  let TPM2_SC_DMA_Disables_0 $bool = no // Disables DMA transfers.
  let TPM2_SC_DMA_Enables_1 $bool = yes // Enables DMA transfers.

//--- Enumerated values for register C%sSC, field DMA
  let TPM2_CSC_DMA_Disable_0 $bool = no // Disable DMA transfers.
  let TPM2_CSC_DMA_Enable_1 $bool = yes // Enable DMA transfers.

//--- Enumerated values for register C%sSC, field CHIE
  let TPM2_CSC_CHIE_Disable_0 $bool = no // Disable channel interrupts.
  let TPM2_CSC_CHIE_Enable_1 $bool = yes // Enable channel interrupts.

//--- Enumerated values for register C%sSC, field CHF
  let TPM2_CSC_CHF_No_0 $bool = no // No channel event has occurred.
  let TPM2_CSC_CHF_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH0F
  let TPM2_STATUS_CH0F_No_0 $bool = no // No channel event has occurred.
  let TPM2_STATUS_CH0F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field CH1F
  let TPM2_STATUS_CH1F_No_0 $bool = no // No channel event has occurred.
  let TPM2_STATUS_CH1F_A_1 $bool = yes // A channel event has occurred.

//--- Enumerated values for register STATUS, field TOF
  let TPM2_STATUS_TOF_TPM_0 $bool = no // TPM counter has not overflowed.
  let TPM2_STATUS_TOF_TPM_1 $bool = yes // TPM counter has overflowed.

//--- Enumerated values for register COMBINE, field COMBINE0
  let TPM2_COMBINE_COMBINE0_Channels_0 $bool = no // Channels 0 and 1 are independent.
  let TPM2_COMBINE_COMBINE0_Channels_1 $bool = yes // Channels 0 and 1 are combined.

//--- Enumerated values for register COMBINE, field COMSWAP0
  let TPM2_COMBINE_COMSWAP0_Even_0 $bool = no // Even channel is used for input capture and 1st compare.
  let TPM2_COMBINE_COMSWAP0_Odd_1 $bool = yes // Odd channel is used for input capture and 1st compare.

//--- Enumerated values for register POL, field POL0
  let TPM2_POL_POL0_The_0 $bool = no // The channel polarity is active high.
  let TPM2_POL_POL0_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register POL, field POL1
  let TPM2_POL_POL1_The_0 $bool = no // The channel polarity is active high.
  let TPM2_POL_POL1_The_1 $bool = yes // The channel polarity is active low.

//--- Enumerated values for register QDCTRL, field QUADEN
  let TPM2_QDCTRL_QUADEN_Quadrature_0 $bool = no // Quadrature decoder mode is disabled.
  let TPM2_QDCTRL_QUADEN_Quadrature_1 $bool = yes // Quadrature decoder mode is enabled.

//--- Enumerated values for register QDCTRL, field TOFDIR
  let TPM2_QDCTRL_TOFDIR_TOF_0 $bool = no // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (zero) to its maximum value (MOD register).
  let TPM2_QDCTRL_TOFDIR_TOF_1 $bool = yes // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (zero).

//--- Enumerated values for register QDCTRL, field QUADIR
  let TPM2_QDCTRL_QUADIR_Counter_0 $bool = no // Counter direction is decreasing (counter decrement).
  let TPM2_QDCTRL_QUADIR_Counter_1 $bool = yes // Counter direction is increasing (counter increment).

//--- Enumerated values for register QDCTRL, field QUADMODE
  let TPM2_QDCTRL_QUADMODE_Phase_0 $bool = no // Phase encoding mode.
  let TPM2_QDCTRL_QUADMODE_Count_1 $bool = yes // Count and direction encoding mode.

//--- Enumerated values for register CONF, field DOZEEN
  let TPM2_CONF_DOZEEN_Internal_0 $bool = no // Internal TPM counter continues in Doze mode.
  let TPM2_CONF_DOZEEN_Internal_1 $bool = yes // Internal TPM counter is paused and does not increment during Doze mode. Trigger inputs and input capture events are also ignored.

//--- Enumerated values for register CONF, field DBGMODE
  let TPM2_CONF_DBGMODE_TPM_00 $u2 = 0 // TPM counter is paused and does not increment during debug mode. Trigger inputs and input capture events are also ignored.
  let TPM2_CONF_DBGMODE_TPM_11 $u2 = 3 // TPM counter continues in debug mode.

//--- Enumerated values for register CONF, field GTBSYNC
  let TPM2_CONF_GTBSYNC_Global_0 $bool = no // Global timebase synchronization disabled.
  let TPM2_CONF_GTBSYNC_Global_1 $bool = yes // Global timebase synchronization enabled.

//--- Enumerated values for register CONF, field GTBEEN
  let TPM2_CONF_GTBEEN_All_0 $bool = no // All channels use the internally generated TPM counter as their timebase
  let TPM2_CONF_GTBEEN_All_1 $bool = yes // All channels use an externally generated global timebase as their timebase

//--- Enumerated values for register CONF, field CSOT
  let TPM2_CONF_CSOT_TPM_0 $bool = no // TPM counter starts to increment immediately, once it is enabled.
  let TPM2_CONF_CSOT_TPM_1 $bool = yes // TPM counter only starts to increment when it a rising edge on the selected input trigger is detected, after it has been enabled or after it has stopped due to overflow.

//--- Enumerated values for register CONF, field CSOO
  let TPM2_CONF_CSOO_TPM_0 $bool = no // TPM counter continues incrementing or decrementing after overflow
  let TPM2_CONF_CSOO_TPM_1 $bool = yes // TPM counter stops incrementing or decrementing after overflow.

//--- Enumerated values for register CONF, field CROT
  let TPM2_CONF_CROT_Counter_0 $bool = no // Counter is not reloaded due to a rising edge on the selected input trigger
  let TPM2_CONF_CROT_Counter_1 $bool = yes // Counter is reloaded when a rising edge is detected on the selected input trigger

//--- Enumerated values for register CONF, field TRGPOL
  let TPM2_CONF_TRGPOL_Trigger_0 $bool = no // Trigger is active high.
  let TPM2_CONF_TRGPOL_Trigger_1 $bool = yes // Trigger is active low.

//--- Enumerated values for register CONF, field TRGSRC
  let TPM2_CONF_TRGSRC_Trigger_0 $bool = no // Trigger source selected by TRGSEL is external.
  let TPM2_CONF_TRGSRC_Trigger_1 $bool = yes // Trigger source selected by TRGSEL is internal (channel pin input capture).

//--- Enumerated values for register CONF, field TRGSEL
  let TPM2_CONF_TRGSEL_Channel_0001 $u4 = 1 // Channel 0 pin input capture
  let TPM2_CONF_TRGSEL_Channel_0010 $u4 = 2 // Channel 1 pin input capture
  let TPM2_CONF_TRGSEL_Channel_0011 $u4 = 3 // Channel 0 or Channel 1 pin input capture

//------------------------------------------------------------------------------
// Peripheral TSI0: Touch sense input
//------------------------------------------------------------------------------

registers ©TSI0 @at 0x40045000 {
//---  Register GENCS: TSI General Control and Status Register
  GENCS @offset 0x0 $u32 {
    OUTRGF // at 31: Out of Range Flag.
    2
    ESOR // at 28: End-of-scan or Out-of-Range Interrupt Selection
    MODE:4 // at 24: TSI analog modes setup and status bits.
    REFCHRG:3 // at 21: REFCHRG
    DVOLT:2 // at 19: DVOLT
    EXTCHRG:3 // at 16: EXTCHRG
    PS:3 // at 13: PS
    NSCN:5 // at 8: NSCN
    TSIEN // at 7: Touch Sensing Input Module Enable
    TSIIEN // at 6: Touch Sensing Input Interrupt Enable
    STPE // at 5: TSI STOP Enable
    STM // at 4: Scan Trigger Mode
    SCNIP // at 3: Scan In Progress Status
    EOSF // at 2: End of Scan Flag
    CURSW // at 1: CURSW
    EOSDMEO // at 0: End-of-Scan DMA Transfer Request Enable Only
  }

//---  Register DATA: TSI DATA Register
  DATA @offset 0x4 $u32 {
    TSICH:4 // at 28: TSICH
    4
    DMAEN // at 23: DMA Transfer Enabled
    SWTS // at 22: Software Trigger Start
    6
    TSICNT:16 // at 0: TSI Conversion Counter Value
  }

//---  Register TSHD: TSI Threshold Register
  TSHD @offset 0x8 $u32 {
    THRESH:16 // at 16: TSI Wakeup Channel High-threshold
    THRESL:16 // at 0: TSI Wakeup Channel Low-threshold
  }

}

//--- Enumerated values for register GENCS, field EOSDMEO
  let TSI0_GENCS_EOSDMEO_Do_0 $bool = no // Do not enable the End-of-Scan DMA transfer request only. Depending on ESOR state, either Out-of-Range or End-of-Scan can trigger a DMA transfer request and interrupt.
  let TSI0_GENCS_EOSDMEO_Only_1 $bool = yes // Only the End-of-Scan event can trigger a DMA transfer request. The Out-of-Range event only and always triggers an interrupt if TSIIE is set.

//--- Enumerated values for register GENCS, field CURSW
  let TSI0_GENCS_CURSW_The_0 $bool = no // The current source pair are not swapped.
  let TSI0_GENCS_CURSW_The_1 $bool = yes // The current source pair are swapped.

//--- Enumerated values for register GENCS, field EOSF
  let TSI0_GENCS_EOSF_Scan_0 $bool = no // Scan not complete.
  let TSI0_GENCS_EOSF_Scan_1 $bool = yes // Scan complete.

//--- Enumerated values for register GENCS, field SCNIP
  let TSI0_GENCS_SCNIP_No_0 $bool = no // No scan in progress.
  let TSI0_GENCS_SCNIP_Scan_1 $bool = yes // Scan in progress.

//--- Enumerated values for register GENCS, field STM
  let TSI0_GENCS_STM_Software_0 $bool = no // Software trigger scan.
  let TSI0_GENCS_STM_Hardware_1 $bool = yes // Hardware trigger scan.

//--- Enumerated values for register GENCS, field STPE
  let TSI0_GENCS_STPE_TSI_0 $bool = no // TSI is disabled when MCU goes into low power mode.
  let TSI0_GENCS_STPE_Allows_1 $bool = yes // Allows TSI to continue running in all low power modes.

//--- Enumerated values for register GENCS, field TSIIEN
  let TSI0_GENCS_TSIIEN_TSI_0 $bool = no // TSI interrupt is disabled.
  let TSI0_GENCS_TSIIEN_TSI_1 $bool = yes // TSI interrupt is enabled.

//--- Enumerated values for register GENCS, field TSIEN
  let TSI0_GENCS_TSIEN_TSI_0 $bool = no // TSI module disabled.
  let TSI0_GENCS_TSIEN_TSI_1 $bool = yes // TSI module enabled.

//--- Enumerated values for register GENCS, field NSCN
  let TSI0_GENCS_NSCN_Once_00000 $u5 = 0 // Once per electrode
  let TSI0_GENCS_NSCN_Twice_00001 $u5 = 1 // Twice per electrode
  let TSI0_GENCS_NSCN_3_00010 $u5 = 2 // 3 times per electrode
  let TSI0_GENCS_NSCN_4_00011 $u5 = 3 // 4 times per electrode
  let TSI0_GENCS_NSCN_5_00100 $u5 = 4 // 5 times per electrode
  let TSI0_GENCS_NSCN_6_00101 $u5 = 5 // 6 times per electrode
  let TSI0_GENCS_NSCN_7_00110 $u5 = 6 // 7 times per electrode
  let TSI0_GENCS_NSCN_8_00111 $u5 = 7 // 8 times per electrode
  let TSI0_GENCS_NSCN_9_01000 $u5 = 8 // 9 times per electrode
  let TSI0_GENCS_NSCN_10_01001 $u5 = 9 // 10 times per electrode
  let TSI0_GENCS_NSCN_11_01010 $u5 = 10 // 11 times per electrode
  let TSI0_GENCS_NSCN_12_01011 $u5 = 11 // 12 times per electrode
  let TSI0_GENCS_NSCN_13_01100 $u5 = 12 // 13 times per electrode
  let TSI0_GENCS_NSCN_14_01101 $u5 = 13 // 14 times per electrode
  let TSI0_GENCS_NSCN_15_01110 $u5 = 14 // 15 times per electrode
  let TSI0_GENCS_NSCN_16_01111 $u5 = 15 // 16 times per electrode
  let TSI0_GENCS_NSCN_17_10000 $u5 = 16 // 17 times per electrode
  let TSI0_GENCS_NSCN_18_10001 $u5 = 17 // 18 times per electrode
  let TSI0_GENCS_NSCN_19_10010 $u5 = 18 // 19 times per electrode
  let TSI0_GENCS_NSCN_20_10011 $u5 = 19 // 20 times per electrode
  let TSI0_GENCS_NSCN_21_10100 $u5 = 20 // 21 times per electrode
  let TSI0_GENCS_NSCN_22_10101 $u5 = 21 // 22 times per electrode
  let TSI0_GENCS_NSCN_23_10110 $u5 = 22 // 23 times per electrode
  let TSI0_GENCS_NSCN_24_10111 $u5 = 23 // 24 times per electrode
  let TSI0_GENCS_NSCN_25_11000 $u5 = 24 // 25 times per electrode
  let TSI0_GENCS_NSCN_26_11001 $u5 = 25 // 26 times per electrode
  let TSI0_GENCS_NSCN_27_11010 $u5 = 26 // 27 times per electrode
  let TSI0_GENCS_NSCN_28_11011 $u5 = 27 // 28 times per electrode
  let TSI0_GENCS_NSCN_29_11100 $u5 = 28 // 29 times per electrode
  let TSI0_GENCS_NSCN_30_11101 $u5 = 29 // 30 times per electrode
  let TSI0_GENCS_NSCN_31_11110 $u5 = 30 // 31 times per electrode
  let TSI0_GENCS_NSCN_32_11111 $u5 = 31 // 32 times per electrode

//--- Enumerated values for register GENCS, field PS
  let TSI0_GENCS_PS_Electrode_000 $u3 = 0 // Electrode Oscillator Frequency divided by 1
  let TSI0_GENCS_PS_Electrode_001 $u3 = 1 // Electrode Oscillator Frequency divided by 2
  let TSI0_GENCS_PS_Electrode_010 $u3 = 2 // Electrode Oscillator Frequency divided by 4
  let TSI0_GENCS_PS_Electrode_011 $u3 = 3 // Electrode Oscillator Frequency divided by 8
  let TSI0_GENCS_PS_Electrode_100 $u3 = 4 // Electrode Oscillator Frequency divided by 16
  let TSI0_GENCS_PS_Electrode_101 $u3 = 5 // Electrode Oscillator Frequency divided by 32
  let TSI0_GENCS_PS_Electrode_110 $u3 = 6 // Electrode Oscillator Frequency divided by 64
  let TSI0_GENCS_PS_Electrode_111 $u3 = 7 // Electrode Oscillator Frequency divided by 128

//--- Enumerated values for register GENCS, field EXTCHRG
  let TSI0_GENCS_EXTCHRG_500_000 $u3 = 0 // 500 nA.
  let TSI0_GENCS_EXTCHRG_1_001 $u3 = 1 // 1 uA.
  let TSI0_GENCS_EXTCHRG_2_010 $u3 = 2 // 2 uA.
  let TSI0_GENCS_EXTCHRG_4_011 $u3 = 3 // 4 uA.
  let TSI0_GENCS_EXTCHRG_8_100 $u3 = 4 // 8 uA.
  let TSI0_GENCS_EXTCHRG_16_101 $u3 = 5 // 16 uA.
  let TSI0_GENCS_EXTCHRG_32_110 $u3 = 6 // 32 uA.
  let TSI0_GENCS_EXTCHRG_64_111 $u3 = 7 // 64 uA.

//--- Enumerated values for register GENCS, field DVOLT
  let TSI0_GENCS_DVOLT_DV_00 $u2 = 0 // DV = 1.026 V; VP = 1.328 V; Vm = 0.302 V.
  let TSI0_GENCS_DVOLT_DV_01 $u2 = 1 // DV = 0.592 V; VP = 1.111 V; Vm = 0.519 V.
  let TSI0_GENCS_DVOLT_DV_10 $u2 = 2 // DV = 0.342 V; VP = 0.986 V; Vm = 0.644 V.
  let TSI0_GENCS_DVOLT_DV_11 $u2 = 3 // DV = 0.197 V; VP = 0.914 V; Vm = 0.716 V.

//--- Enumerated values for register GENCS, field REFCHRG
  let TSI0_GENCS_REFCHRG_500_000 $u3 = 0 // 500 nA.
  let TSI0_GENCS_REFCHRG_1_001 $u3 = 1 // 1 uA.
  let TSI0_GENCS_REFCHRG_2_010 $u3 = 2 // 2 uA.
  let TSI0_GENCS_REFCHRG_4_011 $u3 = 3 // 4 uA.
  let TSI0_GENCS_REFCHRG_8_100 $u3 = 4 // 8 uA.
  let TSI0_GENCS_REFCHRG_16_101 $u3 = 5 // 16 uA.
  let TSI0_GENCS_REFCHRG_32_110 $u3 = 6 // 32 uA.
  let TSI0_GENCS_REFCHRG_64_111 $u3 = 7 // 64 uA.

//--- Enumerated values for register GENCS, field MODE
  let TSI0_GENCS_MODE_Set_0000 $u4 = 0 // Set TSI in capacitive sensing(non-noise detection) mode.
  let TSI0_GENCS_MODE_Set_0100 $u4 = 4 // Set TSI analog to work in single threshold noise detection mode and the frequency limitation circuit is disabled.
  let TSI0_GENCS_MODE_Set_1000 $u4 = 8 // Set TSI analog to work in single threshold noise detection mode and the frequency limitation circuit is enabled to work in higher frequencies operations.
  let TSI0_GENCS_MODE_Set_1100 $u4 = 12 // Set TSI analog to work in automatic noise detection mode.

//--- Enumerated values for register GENCS, field ESOR
  let TSI0_GENCS_ESOR_Out_of_range_0 $bool = no // Out-of-range interrupt is allowed.
  let TSI0_GENCS_ESOR_End_of_scan_1 $bool = yes // End-of-scan interrupt is allowed.

//--- Enumerated values for register DATA, field SWTS
  let TSI0_DATA_SWTS_No_0 $bool = no // No effect.
  let TSI0_DATA_SWTS_Start_1 $bool = yes // Start a scan to determine which channel is specified by TSI_DATA[TSICH].

//--- Enumerated values for register DATA, field DMAEN
  let TSI0_DATA_DMAEN_Interrupt_0 $bool = no // Interrupt is selected when the interrupt enable bit is set and the corresponding TSI events assert.
  let TSI0_DATA_DMAEN_DMA_1 $bool = yes // DMA transfer request is selected when the interrupt enable bit is set and the corresponding TSI events assert.

//--- Enumerated values for register DATA, field TSICH
  let TSI0_DATA_TSICH_Channel_0000 $u4 = 0 // Channel 0.
  let TSI0_DATA_TSICH_Channel_0001 $u4 = 1 // Channel 1.
  let TSI0_DATA_TSICH_Channel_0010 $u4 = 2 // Channel 2.
  let TSI0_DATA_TSICH_Channel_0011 $u4 = 3 // Channel 3.
  let TSI0_DATA_TSICH_Channel_0100 $u4 = 4 // Channel 4.
  let TSI0_DATA_TSICH_Channel_0101 $u4 = 5 // Channel 5.
  let TSI0_DATA_TSICH_Channel_0110 $u4 = 6 // Channel 6.
  let TSI0_DATA_TSICH_Channel_0111 $u4 = 7 // Channel 7.
  let TSI0_DATA_TSICH_Channel_1000 $u4 = 8 // Channel 8.
  let TSI0_DATA_TSICH_Channel_1001 $u4 = 9 // Channel 9.
  let TSI0_DATA_TSICH_Channel_1010 $u4 = 10 // Channel 10.
  let TSI0_DATA_TSICH_Channel_1011 $u4 = 11 // Channel 11.
  let TSI0_DATA_TSICH_Channel_1100 $u4 = 12 // Channel 12.
  let TSI0_DATA_TSICH_Channel_1101 $u4 = 13 // Channel 13.
  let TSI0_DATA_TSICH_Channel_1110 $u4 = 14 // Channel 14.
  let TSI0_DATA_TSICH_Channel_1111 $u4 = 15 // Channel 15.

//------------------------------------------------------------------------------
// PERIPHERAL GROUP: ©UART [5]
//        UART0 at 0x4006a000
//        UART1 at 0x4006b000
//        UART2 at 0x4006c000
//        UART3 at 0x4006d000
//        UART4 at 0x400ea000
//------------------------------------------------------------------------------

registers ©UART [5 @at 0x4006a000 0x4006b000 0x4006c000 0x4006d000 0x400ea000]
          ©UART0 @at 0x4006a000
          ©UART1 @at 0x4006b000
          ©UART2 @at 0x4006c000
          ©UART3 @at 0x4006d000
          ©UART4 @at 0x400ea000 {
//---  Register BDH: UART Baud Rate Registers: High
  BDH @offset 0x0 $u8 {
    LBKDIE // at 7: LIN Break Detect Interrupt Enable
    RXEDGIE // at 6: RxD Input Active Edge Interrupt Enable
    SBNS // at 5: Stop Bit Number Select
    SBR:5 // at 0: UART Baud Rate Bits
  }

//---  Register BDL: UART Baud Rate Registers: Low
  BDL @offset 0x1 $u8 {
    SBR:8 // at 0: UART Baud Rate Bits
  }

//---  Register C1: UART Control Register 1
  C1 @offset 0x2 $u8 {
    LOOPS // at 7: Loop Mode Select
    UARTSWAI // at 6: UART Stops in Wait Mode
    RSRC // at 5: Receiver Source Select
    M // at 4: 9-bit or 8-bit Mode Select
    WAKE // at 3: Receiver Wakeup Method Select
    ILT // at 2: Idle Line Type Select
    PE // at 1: Parity Enable
    PT // at 0: Parity Type
  }

//---  Register C2: UART Control Register 2
  C2 @offset 0x3 $u8 {
    TIE // at 7: Transmitter Interrupt or DMA Transfer Enable.
    TCIE // at 6: Transmission Complete Interrupt Enable
    RIE // at 5: Receiver Full Interrupt or DMA Transfer Enable
    ILIE // at 4: Idle Line Interrupt Enable
    TE // at 3: Transmitter Enable
    RE // at 2: Receiver Enable
    RWU // at 1: Receiver Wakeup Control
    SBK // at 0: Send Break
  }

//---  Register S1: UART Status Register 1
  S1 @offset 0x4 @ro $u8 {
    TDRE // at 7: Transmit Data Register Empty Flag
    TC // at 6: Transmit Complete Flag
    RDRF // at 5: Receive Data Register Full Flag
    IDLE // at 4: Idle Line Flag
    OR // at 3: Receiver Overrun Flag
    NF // at 2: Noise Flag
    FE // at 1: Framing Error Flag
    PF // at 0: Parity Error Flag
  }

//---  Register S2: UART Status Register 2
  S2 @offset 0x5 $u8 {
    LBKDIF // at 7: LIN Break Detect Interrupt Flag
    RXEDGIF // at 6: RxD Pin Active Edge Interrupt Flag
    MSBF // at 5: Most Significant Bit First
    RXINV // at 4: Receive Data Inversion
    RWUID // at 3: Receive Wakeup Idle Detect
    BRK13 // at 2: Break Transmit Character Length
    LBKDE // at 1: LIN Break Detection Enable
    RAF // at 0: Receiver Active Flag
  }

//---  Register C3: UART Control Register 3
  C3 @offset 0x6 $u8 {
    R8 // at 7: Received Bit 8
    T8 // at 6: Transmit Bit 8
    TXDIR // at 5: Transmitter Pin Data Direction in Single-Wire mode
    TXINV // at 4: Transmit Data Inversion.
    ORIE // at 3: Overrun Error Interrupt Enable
    NEIE // at 2: Noise Error Interrupt Enable
    FEIE // at 1: Framing Error Interrupt Enable
    PEIE // at 0: Parity Error Interrupt Enable
  }

//---  Register D: UART Data Register
  D @offset 0x7 $u8 {
    RT:8 // at 0: Reads return the contents of the read-only receive data register and writes go to the write-only transmit data register
  }

//---  Register MA1: UART Match Address Registers 1
  MA1 @offset 0x8 $u8 {
    MA:8 // at 0: Match Address
  }

//---  Register MA2: UART Match Address Registers 2
  MA2 @offset 0x9 $u8 {
    MA:8 // at 0: Match Address
  }

//---  Register C4: UART Control Register 4
  C4 @offset 0xa $u8 {
    MAEN1 // at 7: Match Address Mode Enable 1
    MAEN2 // at 6: Match Address Mode Enable 2
    M10 // at 5: 10-bit Mode select
    BRFA:5 // at 0: Baud Rate Fine Adjust
  }

//---  Register C5: UART Control Register 5
  C5 @offset 0xb $u8 {
    TDMAS // at 7: Transmitter DMA Select
    1
    RDMAS // at 5: Receiver Full DMA Select
    5
  }

//---  Register ED: UART Extended Data Register
  ED @offset 0xc @ro $u8 {
    NOISY // at 7: The current received dataword contained in D and C3[R8] was received with noise.
    PARITYE // at 6: The current received dataword contained in D and C3[R8] was received with a parity error.
    6
  }

//---  Register MODEM: UART Modem Register
  MODEM @offset 0xd $u8 {
    4
    RXRTSE // at 3: Receiver request-to-send enable
    TXRTSPOL // at 2: Transmitter request-to-send polarity
    TXRTSE // at 1: Transmitter request-to-send enable
    TXCTSE // at 0: Transmitter clear-to-send enable
  }

//---  Register IR: UART Infrared Register
  IR @offset 0xe $u8 {
    5
    IREN // at 2: Infrared enable
    TNP:2 // at 0: Transmitter narrow pulse
  }

//---  Register PFIFO: UART FIFO Parameters
  PFIFO @offset 0x10 $u8 {
    TXFE // at 7: Transmit FIFO Enable
    TXFIFOSIZE:3 // at 4: Transmit FIFO. Buffer Depth
    RXFE // at 3: Receive FIFO Enable
    RXFIFOSIZE:3 // at 0: Receive FIFO. Buffer Depth
  }

//---  Register CFIFO: UART FIFO Control Register
  CFIFO @offset 0x11 $u8 {
    TXFLUSH // at 7: Transmit FIFO/Buffer Flush
    RXFLUSH // at 6: Receive FIFO/Buffer Flush
    3
    RXOFE // at 2: Receive FIFO Overflow Interrupt Enable
    TXOFE // at 1: Transmit FIFO Overflow Interrupt Enable
    RXUFE // at 0: Receive FIFO Underflow Interrupt Enable
  }

//---  Register SFIFO: UART FIFO Status Register
  SFIFO @offset 0x12 $u8 {
    TXEMPT // at 7: Transmit Buffer/FIFO Empty
    RXEMPT // at 6: Receive Buffer/FIFO Empty
    3
    RXOF // at 2: Receiver Buffer Overflow Flag
    TXOF // at 1: Transmitter Buffer Overflow Flag
    RXUF // at 0: Receiver Buffer Underflow Flag
  }

//---  Register TWFIFO: UART FIFO Transmit Watermark
  TWFIFO @offset 0x13 $u8 {
    TXWATER:8 // at 0: Transmit Watermark
  }

//---  Register TCFIFO: UART FIFO Transmit Count
  TCFIFO @offset 0x14 @ro $u8 {
    TXCOUNT:8 // at 0: Transmit Counter
  }

//---  Register RWFIFO: UART FIFO Receive Watermark
  RWFIFO @offset 0x15 $u8 {
    RXWATER:8 // at 0: Receive Watermark
  }

//---  Register RCFIFO: UART FIFO Receive Count
  RCFIFO @offset 0x16 @ro $u8 {
    RXCOUNT:8 // at 0: Receive Counter
  }

//---  Register C7816: UART 7816 Control Register
  C7816 @offset 0x18 $u8 {
    3
    ONACK // at 4: Generate NACK on Overflow
    ANACK // at 3: Generate NACK on Error
    INIT // at 2: Detect Initial Character
    TTYPE // at 1: Transfer Type
    ISO_7816E // at 0: ISO-7816 Functionality Enabled
  }

//---  Register IE7816: UART 7816 Interrupt Enable Register
  IE7816 @offset 0x19 $u8 {
    WTE // at 7: Wait Timer Interrupt Enable
    CWTE // at 6: Character Wait Timer Interrupt Enable
    BWTE // at 5: Block Wait Timer Interrupt Enable
    INITDE // at 4: Initial Character Detected Interrupt Enable
    ADTE // at 3: ATR Duration Timer Interrupt Enable
    GTVE // at 2: Guard Timer Violated Interrupt Enable
    TXTE // at 1: Transmit Threshold Exceeded Interrupt Enable
    RXTE // at 0: Receive Threshold Exceeded Interrupt Enable
  }

//---  Register IS7816: UART 7816 Interrupt Status Register
  IS7816 @offset 0x1a $u8 {
    WT // at 7: Wait Timer Interrupt
    CWT // at 6: Character Wait Timer Interrupt
    BWT // at 5: Block Wait Timer Interrupt
    INITD // at 4: Initial Character Detected Interrupt
    ADT // at 3: ATR Duration Time Interrupt
    GTV // at 2: Guard Timer Violated Interrupt
    TXT // at 1: Transmit Threshold Exceeded Interrupt
    RXT // at 0: Receive Threshold Exceeded Interrupt
  }

//---  Register WP7816: UART 7816 Wait Parameter Register
  WP7816 @offset 0x1b $u8 {
    WTX:8 // at 0: Wait Time Multiplier (C7816[TTYPE] = 1)
  }

//---  Register WN7816: UART 7816 Wait N Register
  WN7816 @offset 0x1c $u8 {
    GTN:8 // at 0: Guard Band N
  }

//---  Register WF7816: UART 7816 Wait FD Register
  WF7816 @offset 0x1d $u8 {
    GTFD:8 // at 0: FD Multiplier
  }

//---  Register ET7816: UART 7816 Error Threshold Register
  ET7816 @offset 0x1e $u8 {
    TXTHRESHOLD:4 // at 4: Transmit NACK Threshold
    RXTHRESHOLD:4 // at 0: Receive NACK Threshold
  }

//---  Register TL7816: UART 7816 Transmit Length Register
  TL7816 @offset 0x1f $u8 {
    TLEN:8 // at 0: Transmit Length
  }

//---  Register AP7816A_T0: UART 7816 ATR Duration Timer Register A
  AP7816A_T0 @offset 0x3a $u8 {
    ADTI_H:8 // at 0: ATR Duration Time Integer High (C7816[TTYPE] = 0)
  }

//---  Register AP7816B_T0: UART 7816 ATR Duration Timer Register B
  AP7816B_T0 @offset 0x3b $u8 {
    ADTI_L:8 // at 0: ATR Duration Time Integer Low (C7816[TTYPE] = 0)
  }

//---  Register WP7816A_T0: UART 7816 Wait Parameter Register A
  WP7816A_T0 @offset 0x3c $u8 {
    WI_H:8 // at 0: Wait Time Integer High (C7816[TTYPE] = 0)
  }

//---  Register WP7816A_T1: UART 7816 Wait Parameter Register A
  WP7816A_T1 @offset 0x3c $u8 {
    BWI_H:8 // at 0: Block Wait Time Integer High (C7816[TTYPE] = 1)
  }

//---  Register WP7816B_T0: UART 7816 Wait Parameter Register B
  WP7816B_T0 @offset 0x3d $u8 {
    WI_L:8 // at 0: Wait Time Integer Low (C7816[TTYPE] = 0)
  }

//---  Register WP7816B_T1: UART 7816 Wait Parameter Register B
  WP7816B_T1 @offset 0x3d $u8 {
    BWI_L:8 // at 0: Block Wait Time Integer Low (C7816[TTYPE] = 1)
  }

//---  Register WGP7816_T1: UART 7816 Wait and Guard Parameter Register
  WGP7816_T1 @offset 0x3e $u8 {
    CWI1:4 // at 4: Character Wait Time Integer 1 (C7816[TTYPE] = 1)
    BGI:4 // at 0: Block Guard Time Integer (C7816[TTYPE] = 1)
  }

//---  Register WP7816C_T1: UART 7816 Wait Parameter Register C
  WP7816C_T1 @offset 0x3f $u8 {
    3
    CWI2:5 // at 0: Character Wait Time Integer 2 (C7816[TTYPE] = 1)
  }

}

//--- Enumerated values for register BDH, field SBNS
  let UART0_BDH_SBNS_Data_0 $bool = no // Data frame consists of a single stop bit.
  let UART0_BDH_SBNS_Data_1 $bool = yes // Data frame consists of two stop bits.

//--- Enumerated values for register BDH, field RXEDGIE
  let UART0_BDH_RXEDGIE_Hardware_0 $bool = no // Hardware interrupts from RXEDGIF disabled using polling.
  let UART0_BDH_RXEDGIE_RXEDGIF_1 $bool = yes // RXEDGIF interrupt request enabled.

//--- Enumerated values for register BDH, field LBKDIE
  let UART0_BDH_LBKDIE_LBKDIF_0 $bool = no // LBKDIF interrupt requests disabled.
  let UART0_BDH_LBKDIE_LBKDIF_1 $bool = yes // LBKDIF interrupt requests enabled.

//--- Enumerated values for register C1, field PT
  let UART0_C1_PT_Even_0 $bool = no // Even parity.
  let UART0_C1_PT_Odd_1 $bool = yes // Odd parity.

//--- Enumerated values for register C1, field PE
  let UART0_C1_PE_Parity_0 $bool = no // Parity function disabled.
  let UART0_C1_PE_Parity_1 $bool = yes // Parity function enabled.

//--- Enumerated values for register C1, field ILT
  let UART0_C1_ILT_Idle_0 $bool = no // Idle character bit count starts after start bit.
  let UART0_C1_ILT_Idle_1 $bool = yes // Idle character bit count starts after stop bit.

//--- Enumerated values for register C1, field WAKE
  let UART0_C1_WAKE_Idle_0 $bool = no // Idle line wakeup.
  let UART0_C1_WAKE_Address_1 $bool = yes // Address mark wakeup.

//--- Enumerated values for register C1, field M
  let UART0_C1_M_Normal_start_0 $bool = no // Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
  let UART0_C1_M_Use_start_1 $bool = yes // Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.

//--- Enumerated values for register C1, field RSRC
  let UART0_C1_RSRC_Selects_0 $bool = no // Selects internal loop back mode. The receiver input is internally connected to transmitter output.
  let UART0_C1_RSRC_Single_1 $bool = yes // Single wire UART mode where the receiver input is connected to the transmit pin input signal.

//--- Enumerated values for register C1, field UARTSWAI
  let UART0_C1_UARTSWAI_UART_0 $bool = no // UART clock continues to run in Wait mode.
  let UART0_C1_UARTSWAI_UART_1 $bool = yes // UART clock freezes while CPU is in Wait mode.

//--- Enumerated values for register C1, field LOOPS
  let UART0_C1_LOOPS_Normal_0 $bool = no // Normal operation.
  let UART0_C1_LOOPS_Loop_1 $bool = yes // Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.

//--- Enumerated values for register C2, field SBK
  let UART0_C2_SBK_Normal_0 $bool = no // Normal transmitter operation.
  let UART0_C2_SBK_Queue_1 $bool = yes // Queue break characters to be sent.

//--- Enumerated values for register C2, field RWU
  let UART0_C2_RWU_Normal_0 $bool = no // Normal operation.
  let UART0_C2_RWU_RWU_1 $bool = yes // RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.

//--- Enumerated values for register C2, field RE
  let UART0_C2_RE_Receiver_0 $bool = no // Receiver off.
  let UART0_C2_RE_Receiver_1 $bool = yes // Receiver on.

//--- Enumerated values for register C2, field TE
  let UART0_C2_TE_Transmitter_0 $bool = no // Transmitter off.
  let UART0_C2_TE_Transmitter_1 $bool = yes // Transmitter on.

//--- Enumerated values for register C2, field ILIE
  let UART0_C2_ILIE_IDLE_0 $bool = no // IDLE interrupt requests disabled.
  let UART0_C2_ILIE_IDLE_1 $bool = yes // IDLE interrupt requests enabled.

//--- Enumerated values for register C2, field RIE
  let UART0_C2_RIE_RDRF_0 $bool = no // RDRF interrupt and DMA transfer requests disabled.
  let UART0_C2_RIE_RDRF_1 $bool = yes // RDRF interrupt or DMA transfer requests enabled.

//--- Enumerated values for register C2, field TCIE
  let UART0_C2_TCIE_TC_0 $bool = no // TC interrupt requests disabled.
  let UART0_C2_TCIE_TC_1 $bool = yes // TC interrupt requests enabled.

//--- Enumerated values for register C2, field TIE
  let UART0_C2_TIE_TDRE_0 $bool = no // TDRE interrupt and DMA transfer requests disabled.
  let UART0_C2_TIE_TDRE_1 $bool = yes // TDRE interrupt or DMA transfer requests enabled.

//--- Enumerated values for register S1, field PF
  let UART0_S1_PF_No_0 $bool = no // No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
  let UART0_S1_PF_At_1 $bool = yes // At least one dataword was received with a parity error since the last time this flag was cleared.

//--- Enumerated values for register S1, field FE
  let UART0_S1_FE_No_0 $bool = no // No framing error detected.
  let UART0_S1_FE_Framing_1 $bool = yes // Framing error.

//--- Enumerated values for register S1, field NF
  let UART0_S1_NF_No_0 $bool = no // No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
  let UART0_S1_NF_At_1 $bool = yes // At least one dataword was received with noise detected since the last time the flag was cleared.

//--- Enumerated values for register S1, field OR
  let UART0_S1_OR_No_0 $bool = no // No overrun has occurred since the last time the flag was cleared.
  let UART0_S1_OR_Overrun_1 $bool = yes // Overrun has occurred or the overrun flag has not been cleared since the last overrun occured.

//--- Enumerated values for register S1, field IDLE
  let UART0_S1_IDLE_Receiver_0 $bool = no // Receiver input is either active now or has never become active since the IDLE flag was last cleared.
  let UART0_S1_IDLE_Receiver_1 $bool = yes // Receiver input has become idle or the flag has not been cleared since it last asserted.

//--- Enumerated values for register S1, field RDRF
  let UART0_S1_RDRF_The_0 $bool = no // The number of datawords in the receive buffer is less than the number indicated by RXWATER.
  let UART0_S1_RDRF_The_1 $bool = yes // The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.

//--- Enumerated values for register S1, field TC
  let UART0_S1_TC_Transmitter_0 $bool = no // Transmitter active (sending data, a preamble, or a break).
  let UART0_S1_TC_Transmitter_1 $bool = yes // Transmitter idle (transmission activity complete).

//--- Enumerated values for register S1, field TDRE
  let UART0_S1_TDRE_The_0 $bool = no // The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
  let UART0_S1_TDRE_The_1 $bool = yes // The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.

//--- Enumerated values for register S2, field RAF
  let UART0_S2_RAF_UART_0 $bool = no // UART receiver idle/inactive waiting for a start bit.
  let UART0_S2_RAF_UART_1 $bool = yes // UART receiver active, RxD input not idle.

//--- Enumerated values for register S2, field LBKDE
  let UART0_S2_LBKDE_Break_0 $bool = no // Break character detection is disabled.
  let UART0_S2_LBKDE_Break_1 $bool = yes // Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.

//--- Enumerated values for register S2, field BRK13
  let UART0_S2_BRK13_Break_0 $bool = no // Break character is 10, 11, or 12 bits long.
  let UART0_S2_BRK13_Break_1 $bool = yes // Break character is 13 or 14 bits long.

//--- Enumerated values for register S2, field RWUID
  let UART0_S2_RWUID_S1_IDLE__0 $bool = no // S1[IDLE] is not set upon detection of an idle character.
  let UART0_S2_RWUID_S1_IDLE__1 $bool = yes // S1[IDLE] is set upon detection of an idle character.

//--- Enumerated values for register S2, field RXINV
  let UART0_S2_RXINV_Receive_0 $bool = no // Receive data is not inverted.
  let UART0_S2_RXINV_Receive_1 $bool = yes // Receive data is inverted.

//--- Enumerated values for register S2, field MSBF
  let UART0_S2_MSBF_LSB_0 $bool = no // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
  let UART0_S2_MSBF_MSB_1 $bool = yes // MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].

//--- Enumerated values for register S2, field RXEDGIF
  let UART0_S2_RXEDGIF_No_0 $bool = no // No active edge on the receive pin has occurred.
  let UART0_S2_RXEDGIF_An_1 $bool = yes // An active edge on the receive pin has occurred.

//--- Enumerated values for register S2, field LBKDIF
  let UART0_S2_LBKDIF_No_0 $bool = no // No LIN break character detected.
  let UART0_S2_LBKDIF_LIN_1 $bool = yes // LIN break character detected.

//--- Enumerated values for register C3, field PEIE
  let UART0_C3_PEIE_PF_0 $bool = no // PF interrupt requests are disabled.
  let UART0_C3_PEIE_PF_1 $bool = yes // PF interrupt requests are enabled.

//--- Enumerated values for register C3, field FEIE
  let UART0_C3_FEIE_FE_0 $bool = no // FE interrupt requests are disabled.
  let UART0_C3_FEIE_FE_1 $bool = yes // FE interrupt requests are enabled.

//--- Enumerated values for register C3, field NEIE
  let UART0_C3_NEIE_NF_0 $bool = no // NF interrupt requests are disabled.
  let UART0_C3_NEIE_NF_1 $bool = yes // NF interrupt requests are enabled.

//--- Enumerated values for register C3, field ORIE
  let UART0_C3_ORIE_OR_0 $bool = no // OR interrupts are disabled.
  let UART0_C3_ORIE_OR_1 $bool = yes // OR interrupt requests are enabled.

//--- Enumerated values for register C3, field TXINV
  let UART0_C3_TXINV_Transmit_0 $bool = no // Transmit data is not inverted.
  let UART0_C3_TXINV_Transmit_1 $bool = yes // Transmit data is inverted.

//--- Enumerated values for register C3, field TXDIR
  let UART0_C3_TXDIR_TXD_0 $bool = no // TXD pin is an input in single wire mode.
  let UART0_C3_TXDIR_TXD_1 $bool = yes // TXD pin is an output in single wire mode.

//--- Enumerated values for register C4, field M10
  let UART0_C4_M10_The_0 $bool = no // The parity bit is the ninth bit in the serial transmission.
  let UART0_C4_M10_The_1 $bool = yes // The parity bit is the tenth bit in the serial transmission.

//--- Enumerated values for register C4, field MAEN2
  let UART0_C4_MAEN2_All_0 $bool = no // All data received is transferred to the data buffer if MAEN1 is cleared.
  let UART0_C4_MAEN2_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C4, field MAEN1
  let UART0_C4_MAEN1_All_0 $bool = no // All data received is transferred to the data buffer if MAEN2 is cleared.
  let UART0_C4_MAEN1_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C5, field RDMAS
  let UART0_C5_RDMAS_If_0 $bool = no // If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
  let UART0_C5_RDMAS_If_1 $bool = yes // If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register C5, field TDMAS
  let UART0_C5_TDMAS_If_0 $bool = no // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
  let UART0_C5_TDMAS_If_1 $bool = yes // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register ED, field PARITYE
  let UART0_ED_PARITYE_The_0 $bool = no // The dataword was received without a parity error.
  let UART0_ED_PARITYE_The_1 $bool = yes // The dataword was received with a parity error.

//--- Enumerated values for register ED, field NOISY
  let UART0_ED_NOISY_The_0 $bool = no // The dataword was received without noise.
  let UART0_ED_NOISY_The_1 $bool = yes // The data was received with noise.

//--- Enumerated values for register MODEM, field TXCTSE
  let UART0_MODEM_TXCTSE_CTS_0 $bool = no // CTS has no effect on the transmitter.
  let UART0_MODEM_TXCTSE_Enables_1 $bool = yes // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.

//--- Enumerated values for register MODEM, field TXRTSE
  let UART0_MODEM_TXRTSE_The_0 $bool = no // The transmitter has no effect on RTS.
  let UART0_MODEM_TXRTSE_When_1 $bool = yes // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)

//--- Enumerated values for register MODEM, field TXRTSPOL
  let UART0_MODEM_TXRTSPOL_Transmitter_0 $bool = no // Transmitter RTS is active low.
  let UART0_MODEM_TXRTSPOL_Transmitter_1 $bool = yes // Transmitter RTS is active high.

//--- Enumerated values for register MODEM, field RXRTSE
  let UART0_MODEM_RXRTSE_The_0 $bool = no // The receiver has no effect on RTS.
  let UART0_MODEM_RXRTSE_RTS_1 $bool = yes // RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]. See Hardware flow control

//--- Enumerated values for register IR, field TNP
  let UART0_IR_TNP_3_16__00 $u2 = 0 // 3/16.
  let UART0_IR_TNP_1_16__01 $u2 = 1 // 1/16.
  let UART0_IR_TNP_1_32__10 $u2 = 2 // 1/32.
  let UART0_IR_TNP_1_4__11 $u2 = 3 // 1/4.

//--- Enumerated values for register IR, field IREN
  let UART0_IR_IREN_IR_0 $bool = no // IR disabled.
  let UART0_IR_IREN_IR_1 $bool = yes // IR enabled.

//--- Enumerated values for register PFIFO, field RXFIFOSIZE
  let UART0_PFIFO_RXFIFOSIZE_Receive_000 $u3 = 0 // Receive FIFO/Buffer depth = 1 dataword.
  let UART0_PFIFO_RXFIFOSIZE_Receive_001 $u3 = 1 // Receive FIFO/Buffer depth = 4 datawords.
  let UART0_PFIFO_RXFIFOSIZE_Receive_010 $u3 = 2 // Receive FIFO/Buffer depth = 8 datawords.
  let UART0_PFIFO_RXFIFOSIZE_Receive_011 $u3 = 3 // Receive FIFO/Buffer depth = 16 datawords.
  let UART0_PFIFO_RXFIFOSIZE_Receive_100 $u3 = 4 // Receive FIFO/Buffer depth = 32 datawords.
  let UART0_PFIFO_RXFIFOSIZE_Receive_101 $u3 = 5 // Receive FIFO/Buffer depth = 64 datawords.
  let UART0_PFIFO_RXFIFOSIZE_Receive_110 $u3 = 6 // Receive FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field RXFE
  let UART0_PFIFO_RXFE_Receive_0 $bool = no // Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
  let UART0_PFIFO_RXFE_Receive_1 $bool = yes // Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.

//--- Enumerated values for register PFIFO, field TXFIFOSIZE
  let UART0_PFIFO_TXFIFOSIZE_Transmit_000 $u3 = 0 // Transmit FIFO/Buffer depth = 1 dataword.
  let UART0_PFIFO_TXFIFOSIZE_Transmit_001 $u3 = 1 // Transmit FIFO/Buffer depth = 4 datawords.
  let UART0_PFIFO_TXFIFOSIZE_Transmit_010 $u3 = 2 // Transmit FIFO/Buffer depth = 8 datawords.
  let UART0_PFIFO_TXFIFOSIZE_Transmit_011 $u3 = 3 // Transmit FIFO/Buffer depth = 16 datawords.
  let UART0_PFIFO_TXFIFOSIZE_Transmit_100 $u3 = 4 // Transmit FIFO/Buffer depth = 32 datawords.
  let UART0_PFIFO_TXFIFOSIZE_Transmit_101 $u3 = 5 // Transmit FIFO/Buffer depth = 64 datawords.
  let UART0_PFIFO_TXFIFOSIZE_Transmit_110 $u3 = 6 // Transmit FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field TXFE
  let UART0_PFIFO_TXFE_Transmit_0 $bool = no // Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
  let UART0_PFIFO_TXFE_Transmit_1 $bool = yes // Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.

//--- Enumerated values for register CFIFO, field RXUFE
  let UART0_CFIFO_RXUFE_RXUF_0 $bool = no // RXUF flag does not generate an interrupt to the host.
  let UART0_CFIFO_RXUFE_RXUF_1 $bool = yes // RXUF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field TXOFE
  let UART0_CFIFO_TXOFE_TXOF_0 $bool = no // TXOF flag does not generate an interrupt to the host.
  let UART0_CFIFO_TXOFE_TXOF_1 $bool = yes // TXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXOFE
  let UART0_CFIFO_RXOFE_RXOF_0 $bool = no // RXOF flag does not generate an interrupt to the host.
  let UART0_CFIFO_RXOFE_RXOF_1 $bool = yes // RXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXFLUSH
  let UART0_CFIFO_RXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART0_CFIFO_RXFLUSH_All_1 $bool = yes // All data in the receive FIFO/buffer is cleared out.

//--- Enumerated values for register CFIFO, field TXFLUSH
  let UART0_CFIFO_TXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART0_CFIFO_TXFLUSH_All_1 $bool = yes // All data in the transmit FIFO/Buffer is cleared out.

//--- Enumerated values for register SFIFO, field RXUF
  let UART0_SFIFO_RXUF_No_0 $bool = no // No receive buffer underflow has occurred since the last time the flag was cleared.
  let UART0_SFIFO_RXUF_At_1 $bool = yes // At least one receive buffer underflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field TXOF
  let UART0_SFIFO_TXOF_No_0 $bool = no // No transmit buffer overflow has occurred since the last time the flag was cleared.
  let UART0_SFIFO_TXOF_At_1 $bool = yes // At least one transmit buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXOF
  let UART0_SFIFO_RXOF_No_0 $bool = no // No receive buffer overflow has occurred since the last time the flag was cleared.
  let UART0_SFIFO_RXOF_At_1 $bool = yes // At least one receive buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXEMPT
  let UART0_SFIFO_RXEMPT_Receive_0 $bool = no // Receive buffer is not empty.
  let UART0_SFIFO_RXEMPT_Receive_1 $bool = yes // Receive buffer is empty.

//--- Enumerated values for register SFIFO, field TXEMPT
  let UART0_SFIFO_TXEMPT_Transmit_0 $bool = no // Transmit buffer is not empty.
  let UART0_SFIFO_TXEMPT_Transmit_1 $bool = yes // Transmit buffer is empty.

//--- Enumerated values for register C7816, field ISO_7816E
  let UART0_C7816_ISO_7816E_ISO_7816_0 $bool = no // ISO-7816 functionality is turned off/not enabled.
  let UART0_C7816_ISO_7816E_ISO_7816_1 $bool = yes // ISO-7816 functionality is turned on/enabled.

//--- Enumerated values for register C7816, field TTYPE
  let UART0_C7816_TTYPE_T_0 $bool = no // T = 0 per the ISO-7816 specification.
  let UART0_C7816_TTYPE_T_1 $bool = yes // T = 1 per the ISO-7816 specification.

//--- Enumerated values for register C7816, field INIT
  let UART0_C7816_INIT_Normal_0 $bool = no // Normal operating mode. Receiver does not seek to identify initial character.
  let UART0_C7816_INIT_Receiver_1 $bool = yes // Receiver searches for initial character.

//--- Enumerated values for register C7816, field ANACK
  let UART0_C7816_ANACK_No_0 $bool = no // No NACK is automatically generated.
  let UART0_C7816_ANACK_A_1 $bool = yes // A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.

//--- Enumerated values for register C7816, field ONACK
  let UART0_C7816_ONACK_The_0 $bool = no // The received data does not generate a NACK when the receipt of the data results in an overflow event.
  let UART0_C7816_ONACK_If_1 $bool = yes // If the receiver buffer overflows, a NACK is automatically sent on a received character.

//--- Enumerated values for register IE7816, field RXTE
  let UART0_IE7816_RXTE_The_0 $bool = no // The assertion of IS7816[RXT] does not result in the generation of an interrupt.
  let UART0_IE7816_RXTE_The_1 $bool = yes // The assertion of IS7816[RXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field TXTE
  let UART0_IE7816_TXTE_The_0 $bool = no // The assertion of IS7816[TXT] does not result in the generation of an interrupt.
  let UART0_IE7816_TXTE_The_1 $bool = yes // The assertion of IS7816[TXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field GTVE
  let UART0_IE7816_GTVE_The_0 $bool = no // The assertion of IS7816[GTV] does not result in the generation of an interrupt.
  let UART0_IE7816_GTVE_The_1 $bool = yes // The assertion of IS7816[GTV] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field ADTE
  let UART0_IE7816_ADTE_The_0 $bool = no // The assertion of IS7816[ADT] does not result in the generation of an interrupt.
  let UART0_IE7816_ADTE_The_1 $bool = yes // The assertion of IS7816[ADT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field INITDE
  let UART0_IE7816_INITDE_The_0 $bool = no // The assertion of IS7816[INITD] does not result in the generation of an interrupt.
  let UART0_IE7816_INITDE_The_1 $bool = yes // The assertion of IS7816[INITD] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field BWTE
  let UART0_IE7816_BWTE_The_0 $bool = no // The assertion of IS7816[BWT] does not result in the generation of an interrupt.
  let UART0_IE7816_BWTE_The_1 $bool = yes // The assertion of IS7816[BWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field CWTE
  let UART0_IE7816_CWTE_The_0 $bool = no // The assertion of IS7816[CWT] does not result in the generation of an interrupt.
  let UART0_IE7816_CWTE_The_1 $bool = yes // The assertion of IS7816[CWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field WTE
  let UART0_IE7816_WTE_The_0 $bool = no // The assertion of IS7816[WT] does not result in the generation of an interrupt.
  let UART0_IE7816_WTE_The_1 $bool = yes // The assertion of IS7816[WT] results in the generation of an interrupt.

//--- Enumerated values for register IS7816, field RXT
  let UART0_IS7816_RXT_The_0 $bool = no // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
  let UART0_IS7816_RXT_The_1 $bool = yes // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].

//--- Enumerated values for register IS7816, field TXT
  let UART0_IS7816_TXT_The_0 $bool = no // The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
  let UART0_IS7816_TXT_The_1 $bool = yes // The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].

//--- Enumerated values for register IS7816, field GTV
  let UART0_IS7816_GTV_A_0 $bool = no // A guard time (GT, CGT, or BGT) has not been violated.
  let UART0_IS7816_GTV_A_1 $bool = yes // A guard time (GT, CGT, or BGT) has been violated.

//--- Enumerated values for register IS7816, field ADT
  let UART0_IS7816_ADT_ATR_0 $bool = no // ATR Duration time (ADT) has not been violated.
  let UART0_IS7816_ADT_ATR_1 $bool = yes // ATR Duration time (ADT) has been violated.

//--- Enumerated values for register IS7816, field INITD
  let UART0_IS7816_INITD_A_0 $bool = no // A valid initial character has not been received.
  let UART0_IS7816_INITD_A_1 $bool = yes // A valid initial character has been received.

//--- Enumerated values for register IS7816, field BWT
  let UART0_IS7816_BWT_Block_0 $bool = no // Block wait time (BWT) has not been violated.
  let UART0_IS7816_BWT_Block_1 $bool = yes // Block wait time (BWT) has been violated.

//--- Enumerated values for register IS7816, field CWT
  let UART0_IS7816_CWT_Character_0 $bool = no // Character wait time (CWT) has not been violated.
  let UART0_IS7816_CWT_Character_1 $bool = yes // Character wait time (CWT) has been violated.

//--- Enumerated values for register IS7816, field WT
  let UART0_IS7816_WT_Wait_0 $bool = no // Wait time (WT) has not been violated.
  let UART0_IS7816_WT_Wait_1 $bool = yes // Wait time (WT) has been violated.

//--- Enumerated values for register ET7816, field TXTHRESHOLD
  let UART0_ET7816_TXTHRESHOLD_TXT_0 $u4 = 0 // TXT asserts on the first NACK that is received.
  let UART0_ET7816_TXTHRESHOLD_TXT_1 $u4 = 1 // TXT asserts on the second NACK that is received.

//--- Enumerated values for register BDH, field SBNS
  let UART1_BDH_SBNS_Data_0 $bool = no // Data frame consists of a single stop bit.
  let UART1_BDH_SBNS_Data_1 $bool = yes // Data frame consists of two stop bits.

//--- Enumerated values for register BDH, field RXEDGIE
  let UART1_BDH_RXEDGIE_Hardware_0 $bool = no // Hardware interrupts from RXEDGIF disabled using polling.
  let UART1_BDH_RXEDGIE_RXEDGIF_1 $bool = yes // RXEDGIF interrupt request enabled.

//--- Enumerated values for register BDH, field LBKDIE
  let UART1_BDH_LBKDIE_LBKDIF_0 $bool = no // LBKDIF interrupt requests disabled.
  let UART1_BDH_LBKDIE_LBKDIF_1 $bool = yes // LBKDIF interrupt requests enabled.

//--- Enumerated values for register C1, field PT
  let UART1_C1_PT_Even_0 $bool = no // Even parity.
  let UART1_C1_PT_Odd_1 $bool = yes // Odd parity.

//--- Enumerated values for register C1, field PE
  let UART1_C1_PE_Parity_0 $bool = no // Parity function disabled.
  let UART1_C1_PE_Parity_1 $bool = yes // Parity function enabled.

//--- Enumerated values for register C1, field ILT
  let UART1_C1_ILT_Idle_0 $bool = no // Idle character bit count starts after start bit.
  let UART1_C1_ILT_Idle_1 $bool = yes // Idle character bit count starts after stop bit.

//--- Enumerated values for register C1, field WAKE
  let UART1_C1_WAKE_Idle_0 $bool = no // Idle line wakeup.
  let UART1_C1_WAKE_Address_1 $bool = yes // Address mark wakeup.

//--- Enumerated values for register C1, field M
  let UART1_C1_M_Normal_start_0 $bool = no // Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
  let UART1_C1_M_Use_start_1 $bool = yes // Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.

//--- Enumerated values for register C1, field RSRC
  let UART1_C1_RSRC_Selects_0 $bool = no // Selects internal loop back mode. The receiver input is internally connected to transmitter output.
  let UART1_C1_RSRC_Single_1 $bool = yes // Single wire UART mode where the receiver input is connected to the transmit pin input signal.

//--- Enumerated values for register C1, field UARTSWAI
  let UART1_C1_UARTSWAI_UART_0 $bool = no // UART clock continues to run in Wait mode.
  let UART1_C1_UARTSWAI_UART_1 $bool = yes // UART clock freezes while CPU is in Wait mode.

//--- Enumerated values for register C1, field LOOPS
  let UART1_C1_LOOPS_Normal_0 $bool = no // Normal operation.
  let UART1_C1_LOOPS_Loop_1 $bool = yes // Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.

//--- Enumerated values for register C2, field SBK
  let UART1_C2_SBK_Normal_0 $bool = no // Normal transmitter operation.
  let UART1_C2_SBK_Queue_1 $bool = yes // Queue break characters to be sent.

//--- Enumerated values for register C2, field RWU
  let UART1_C2_RWU_Normal_0 $bool = no // Normal operation.
  let UART1_C2_RWU_RWU_1 $bool = yes // RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.

//--- Enumerated values for register C2, field RE
  let UART1_C2_RE_Receiver_0 $bool = no // Receiver off.
  let UART1_C2_RE_Receiver_1 $bool = yes // Receiver on.

//--- Enumerated values for register C2, field TE
  let UART1_C2_TE_Transmitter_0 $bool = no // Transmitter off.
  let UART1_C2_TE_Transmitter_1 $bool = yes // Transmitter on.

//--- Enumerated values for register C2, field ILIE
  let UART1_C2_ILIE_IDLE_0 $bool = no // IDLE interrupt requests disabled.
  let UART1_C2_ILIE_IDLE_1 $bool = yes // IDLE interrupt requests enabled.

//--- Enumerated values for register C2, field RIE
  let UART1_C2_RIE_RDRF_0 $bool = no // RDRF interrupt and DMA transfer requests disabled.
  let UART1_C2_RIE_RDRF_1 $bool = yes // RDRF interrupt or DMA transfer requests enabled.

//--- Enumerated values for register C2, field TCIE
  let UART1_C2_TCIE_TC_0 $bool = no // TC interrupt requests disabled.
  let UART1_C2_TCIE_TC_1 $bool = yes // TC interrupt requests enabled.

//--- Enumerated values for register C2, field TIE
  let UART1_C2_TIE_TDRE_0 $bool = no // TDRE interrupt and DMA transfer requests disabled.
  let UART1_C2_TIE_TDRE_1 $bool = yes // TDRE interrupt or DMA transfer requests enabled.

//--- Enumerated values for register S1, field PF
  let UART1_S1_PF_No_0 $bool = no // No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
  let UART1_S1_PF_At_1 $bool = yes // At least one dataword was received with a parity error since the last time this flag was cleared.

//--- Enumerated values for register S1, field FE
  let UART1_S1_FE_No_0 $bool = no // No framing error detected.
  let UART1_S1_FE_Framing_1 $bool = yes // Framing error.

//--- Enumerated values for register S1, field NF
  let UART1_S1_NF_No_0 $bool = no // No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
  let UART1_S1_NF_At_1 $bool = yes // At least one dataword was received with noise detected since the last time the flag was cleared.

//--- Enumerated values for register S1, field OR
  let UART1_S1_OR_No_0 $bool = no // No overrun has occurred since the last time the flag was cleared.
  let UART1_S1_OR_Overrun_1 $bool = yes // Overrun has occurred or the overrun flag has not been cleared since the last overrun occured.

//--- Enumerated values for register S1, field IDLE
  let UART1_S1_IDLE_Receiver_0 $bool = no // Receiver input is either active now or has never become active since the IDLE flag was last cleared.
  let UART1_S1_IDLE_Receiver_1 $bool = yes // Receiver input has become idle or the flag has not been cleared since it last asserted.

//--- Enumerated values for register S1, field RDRF
  let UART1_S1_RDRF_The_0 $bool = no // The number of datawords in the receive buffer is less than the number indicated by RXWATER.
  let UART1_S1_RDRF_The_1 $bool = yes // The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.

//--- Enumerated values for register S1, field TC
  let UART1_S1_TC_Transmitter_0 $bool = no // Transmitter active (sending data, a preamble, or a break).
  let UART1_S1_TC_Transmitter_1 $bool = yes // Transmitter idle (transmission activity complete).

//--- Enumerated values for register S1, field TDRE
  let UART1_S1_TDRE_The_0 $bool = no // The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
  let UART1_S1_TDRE_The_1 $bool = yes // The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.

//--- Enumerated values for register S2, field RAF
  let UART1_S2_RAF_UART_0 $bool = no // UART receiver idle/inactive waiting for a start bit.
  let UART1_S2_RAF_UART_1 $bool = yes // UART receiver active, RxD input not idle.

//--- Enumerated values for register S2, field LBKDE
  let UART1_S2_LBKDE_Break_0 $bool = no // Break character detection is disabled.
  let UART1_S2_LBKDE_Break_1 $bool = yes // Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.

//--- Enumerated values for register S2, field BRK13
  let UART1_S2_BRK13_Break_0 $bool = no // Break character is 10, 11, or 12 bits long.
  let UART1_S2_BRK13_Break_1 $bool = yes // Break character is 13 or 14 bits long.

//--- Enumerated values for register S2, field RWUID
  let UART1_S2_RWUID_S1_IDLE__0 $bool = no // S1[IDLE] is not set upon detection of an idle character.
  let UART1_S2_RWUID_S1_IDLE__1 $bool = yes // S1[IDLE] is set upon detection of an idle character.

//--- Enumerated values for register S2, field RXINV
  let UART1_S2_RXINV_Receive_0 $bool = no // Receive data is not inverted.
  let UART1_S2_RXINV_Receive_1 $bool = yes // Receive data is inverted.

//--- Enumerated values for register S2, field MSBF
  let UART1_S2_MSBF_LSB_0 $bool = no // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
  let UART1_S2_MSBF_MSB_1 $bool = yes // MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].

//--- Enumerated values for register S2, field RXEDGIF
  let UART1_S2_RXEDGIF_No_0 $bool = no // No active edge on the receive pin has occurred.
  let UART1_S2_RXEDGIF_An_1 $bool = yes // An active edge on the receive pin has occurred.

//--- Enumerated values for register S2, field LBKDIF
  let UART1_S2_LBKDIF_No_0 $bool = no // No LIN break character detected.
  let UART1_S2_LBKDIF_LIN_1 $bool = yes // LIN break character detected.

//--- Enumerated values for register C3, field PEIE
  let UART1_C3_PEIE_PF_0 $bool = no // PF interrupt requests are disabled.
  let UART1_C3_PEIE_PF_1 $bool = yes // PF interrupt requests are enabled.

//--- Enumerated values for register C3, field FEIE
  let UART1_C3_FEIE_FE_0 $bool = no // FE interrupt requests are disabled.
  let UART1_C3_FEIE_FE_1 $bool = yes // FE interrupt requests are enabled.

//--- Enumerated values for register C3, field NEIE
  let UART1_C3_NEIE_NF_0 $bool = no // NF interrupt requests are disabled.
  let UART1_C3_NEIE_NF_1 $bool = yes // NF interrupt requests are enabled.

//--- Enumerated values for register C3, field ORIE
  let UART1_C3_ORIE_OR_0 $bool = no // OR interrupts are disabled.
  let UART1_C3_ORIE_OR_1 $bool = yes // OR interrupt requests are enabled.

//--- Enumerated values for register C3, field TXINV
  let UART1_C3_TXINV_Transmit_0 $bool = no // Transmit data is not inverted.
  let UART1_C3_TXINV_Transmit_1 $bool = yes // Transmit data is inverted.

//--- Enumerated values for register C3, field TXDIR
  let UART1_C3_TXDIR_TXD_0 $bool = no // TXD pin is an input in single wire mode.
  let UART1_C3_TXDIR_TXD_1 $bool = yes // TXD pin is an output in single wire mode.

//--- Enumerated values for register C4, field M10
  let UART1_C4_M10_The_0 $bool = no // The parity bit is the ninth bit in the serial transmission.
  let UART1_C4_M10_The_1 $bool = yes // The parity bit is the tenth bit in the serial transmission.

//--- Enumerated values for register C4, field MAEN2
  let UART1_C4_MAEN2_All_0 $bool = no // All data received is transferred to the data buffer if MAEN1 is cleared.
  let UART1_C4_MAEN2_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C4, field MAEN1
  let UART1_C4_MAEN1_All_0 $bool = no // All data received is transferred to the data buffer if MAEN2 is cleared.
  let UART1_C4_MAEN1_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C5, field RDMAS
  let UART1_C5_RDMAS_If_0 $bool = no // If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
  let UART1_C5_RDMAS_If_1 $bool = yes // If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register C5, field TDMAS
  let UART1_C5_TDMAS_If_0 $bool = no // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
  let UART1_C5_TDMAS_If_1 $bool = yes // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register ED, field PARITYE
  let UART1_ED_PARITYE_The_0 $bool = no // The dataword was received without a parity error.
  let UART1_ED_PARITYE_The_1 $bool = yes // The dataword was received with a parity error.

//--- Enumerated values for register ED, field NOISY
  let UART1_ED_NOISY_The_0 $bool = no // The dataword was received without noise.
  let UART1_ED_NOISY_The_1 $bool = yes // The data was received with noise.

//--- Enumerated values for register MODEM, field TXCTSE
  let UART1_MODEM_TXCTSE_CTS_0 $bool = no // CTS has no effect on the transmitter.
  let UART1_MODEM_TXCTSE_Enables_1 $bool = yes // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.

//--- Enumerated values for register MODEM, field TXRTSE
  let UART1_MODEM_TXRTSE_The_0 $bool = no // The transmitter has no effect on RTS.
  let UART1_MODEM_TXRTSE_When_1 $bool = yes // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)

//--- Enumerated values for register MODEM, field TXRTSPOL
  let UART1_MODEM_TXRTSPOL_Transmitter_0 $bool = no // Transmitter RTS is active low.
  let UART1_MODEM_TXRTSPOL_Transmitter_1 $bool = yes // Transmitter RTS is active high.

//--- Enumerated values for register MODEM, field RXRTSE
  let UART1_MODEM_RXRTSE_The_0 $bool = no // The receiver has no effect on RTS.
  let UART1_MODEM_RXRTSE_RTS_1 $bool = yes // RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]. See Hardware flow control

//--- Enumerated values for register IR, field TNP
  let UART1_IR_TNP_3_16__00 $u2 = 0 // 3/16.
  let UART1_IR_TNP_1_16__01 $u2 = 1 // 1/16.
  let UART1_IR_TNP_1_32__10 $u2 = 2 // 1/32.
  let UART1_IR_TNP_1_4__11 $u2 = 3 // 1/4.

//--- Enumerated values for register IR, field IREN
  let UART1_IR_IREN_IR_0 $bool = no // IR disabled.
  let UART1_IR_IREN_IR_1 $bool = yes // IR enabled.

//--- Enumerated values for register PFIFO, field RXFIFOSIZE
  let UART1_PFIFO_RXFIFOSIZE_Receive_000 $u3 = 0 // Receive FIFO/Buffer depth = 1 dataword.
  let UART1_PFIFO_RXFIFOSIZE_Receive_001 $u3 = 1 // Receive FIFO/Buffer depth = 4 datawords.
  let UART1_PFIFO_RXFIFOSIZE_Receive_010 $u3 = 2 // Receive FIFO/Buffer depth = 8 datawords.
  let UART1_PFIFO_RXFIFOSIZE_Receive_011 $u3 = 3 // Receive FIFO/Buffer depth = 16 datawords.
  let UART1_PFIFO_RXFIFOSIZE_Receive_100 $u3 = 4 // Receive FIFO/Buffer depth = 32 datawords.
  let UART1_PFIFO_RXFIFOSIZE_Receive_101 $u3 = 5 // Receive FIFO/Buffer depth = 64 datawords.
  let UART1_PFIFO_RXFIFOSIZE_Receive_110 $u3 = 6 // Receive FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field RXFE
  let UART1_PFIFO_RXFE_Receive_0 $bool = no // Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
  let UART1_PFIFO_RXFE_Receive_1 $bool = yes // Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.

//--- Enumerated values for register PFIFO, field TXFIFOSIZE
  let UART1_PFIFO_TXFIFOSIZE_Transmit_000 $u3 = 0 // Transmit FIFO/Buffer depth = 1 dataword.
  let UART1_PFIFO_TXFIFOSIZE_Transmit_001 $u3 = 1 // Transmit FIFO/Buffer depth = 4 datawords.
  let UART1_PFIFO_TXFIFOSIZE_Transmit_010 $u3 = 2 // Transmit FIFO/Buffer depth = 8 datawords.
  let UART1_PFIFO_TXFIFOSIZE_Transmit_011 $u3 = 3 // Transmit FIFO/Buffer depth = 16 datawords.
  let UART1_PFIFO_TXFIFOSIZE_Transmit_100 $u3 = 4 // Transmit FIFO/Buffer depth = 32 datawords.
  let UART1_PFIFO_TXFIFOSIZE_Transmit_101 $u3 = 5 // Transmit FIFO/Buffer depth = 64 datawords.
  let UART1_PFIFO_TXFIFOSIZE_Transmit_110 $u3 = 6 // Transmit FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field TXFE
  let UART1_PFIFO_TXFE_Transmit_0 $bool = no // Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
  let UART1_PFIFO_TXFE_Transmit_1 $bool = yes // Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.

//--- Enumerated values for register CFIFO, field RXUFE
  let UART1_CFIFO_RXUFE_RXUF_0 $bool = no // RXUF flag does not generate an interrupt to the host.
  let UART1_CFIFO_RXUFE_RXUF_1 $bool = yes // RXUF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field TXOFE
  let UART1_CFIFO_TXOFE_TXOF_0 $bool = no // TXOF flag does not generate an interrupt to the host.
  let UART1_CFIFO_TXOFE_TXOF_1 $bool = yes // TXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXOFE
  let UART1_CFIFO_RXOFE_RXOF_0 $bool = no // RXOF flag does not generate an interrupt to the host.
  let UART1_CFIFO_RXOFE_RXOF_1 $bool = yes // RXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXFLUSH
  let UART1_CFIFO_RXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART1_CFIFO_RXFLUSH_All_1 $bool = yes // All data in the receive FIFO/buffer is cleared out.

//--- Enumerated values for register CFIFO, field TXFLUSH
  let UART1_CFIFO_TXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART1_CFIFO_TXFLUSH_All_1 $bool = yes // All data in the transmit FIFO/Buffer is cleared out.

//--- Enumerated values for register SFIFO, field RXUF
  let UART1_SFIFO_RXUF_No_0 $bool = no // No receive buffer underflow has occurred since the last time the flag was cleared.
  let UART1_SFIFO_RXUF_At_1 $bool = yes // At least one receive buffer underflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field TXOF
  let UART1_SFIFO_TXOF_No_0 $bool = no // No transmit buffer overflow has occurred since the last time the flag was cleared.
  let UART1_SFIFO_TXOF_At_1 $bool = yes // At least one transmit buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXOF
  let UART1_SFIFO_RXOF_No_0 $bool = no // No receive buffer overflow has occurred since the last time the flag was cleared.
  let UART1_SFIFO_RXOF_At_1 $bool = yes // At least one receive buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXEMPT
  let UART1_SFIFO_RXEMPT_Receive_0 $bool = no // Receive buffer is not empty.
  let UART1_SFIFO_RXEMPT_Receive_1 $bool = yes // Receive buffer is empty.

//--- Enumerated values for register SFIFO, field TXEMPT
  let UART1_SFIFO_TXEMPT_Transmit_0 $bool = no // Transmit buffer is not empty.
  let UART1_SFIFO_TXEMPT_Transmit_1 $bool = yes // Transmit buffer is empty.

//--- Enumerated values for register C7816, field ISO_7816E
  let UART1_C7816_ISO_7816E_ISO_7816_0 $bool = no // ISO-7816 functionality is turned off/not enabled.
  let UART1_C7816_ISO_7816E_ISO_7816_1 $bool = yes // ISO-7816 functionality is turned on/enabled.

//--- Enumerated values for register C7816, field TTYPE
  let UART1_C7816_TTYPE_T_0 $bool = no // T = 0 per the ISO-7816 specification.
  let UART1_C7816_TTYPE_T_1 $bool = yes // T = 1 per the ISO-7816 specification.

//--- Enumerated values for register C7816, field INIT
  let UART1_C7816_INIT_Normal_0 $bool = no // Normal operating mode. Receiver does not seek to identify initial character.
  let UART1_C7816_INIT_Receiver_1 $bool = yes // Receiver searches for initial character.

//--- Enumerated values for register C7816, field ANACK
  let UART1_C7816_ANACK_No_0 $bool = no // No NACK is automatically generated.
  let UART1_C7816_ANACK_A_1 $bool = yes // A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.

//--- Enumerated values for register C7816, field ONACK
  let UART1_C7816_ONACK_The_0 $bool = no // The received data does not generate a NACK when the receipt of the data results in an overflow event.
  let UART1_C7816_ONACK_If_1 $bool = yes // If the receiver buffer overflows, a NACK is automatically sent on a received character.

//--- Enumerated values for register IE7816, field RXTE
  let UART1_IE7816_RXTE_The_0 $bool = no // The assertion of IS7816[RXT] does not result in the generation of an interrupt.
  let UART1_IE7816_RXTE_The_1 $bool = yes // The assertion of IS7816[RXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field TXTE
  let UART1_IE7816_TXTE_The_0 $bool = no // The assertion of IS7816[TXT] does not result in the generation of an interrupt.
  let UART1_IE7816_TXTE_The_1 $bool = yes // The assertion of IS7816[TXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field GTVE
  let UART1_IE7816_GTVE_The_0 $bool = no // The assertion of IS7816[GTV] does not result in the generation of an interrupt.
  let UART1_IE7816_GTVE_The_1 $bool = yes // The assertion of IS7816[GTV] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field ADTE
  let UART1_IE7816_ADTE_The_0 $bool = no // The assertion of IS7816[ADT] does not result in the generation of an interrupt.
  let UART1_IE7816_ADTE_The_1 $bool = yes // The assertion of IS7816[ADT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field INITDE
  let UART1_IE7816_INITDE_The_0 $bool = no // The assertion of IS7816[INITD] does not result in the generation of an interrupt.
  let UART1_IE7816_INITDE_The_1 $bool = yes // The assertion of IS7816[INITD] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field BWTE
  let UART1_IE7816_BWTE_The_0 $bool = no // The assertion of IS7816[BWT] does not result in the generation of an interrupt.
  let UART1_IE7816_BWTE_The_1 $bool = yes // The assertion of IS7816[BWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field CWTE
  let UART1_IE7816_CWTE_The_0 $bool = no // The assertion of IS7816[CWT] does not result in the generation of an interrupt.
  let UART1_IE7816_CWTE_The_1 $bool = yes // The assertion of IS7816[CWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field WTE
  let UART1_IE7816_WTE_The_0 $bool = no // The assertion of IS7816[WT] does not result in the generation of an interrupt.
  let UART1_IE7816_WTE_The_1 $bool = yes // The assertion of IS7816[WT] results in the generation of an interrupt.

//--- Enumerated values for register IS7816, field RXT
  let UART1_IS7816_RXT_The_0 $bool = no // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
  let UART1_IS7816_RXT_The_1 $bool = yes // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].

//--- Enumerated values for register IS7816, field TXT
  let UART1_IS7816_TXT_The_0 $bool = no // The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
  let UART1_IS7816_TXT_The_1 $bool = yes // The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].

//--- Enumerated values for register IS7816, field GTV
  let UART1_IS7816_GTV_A_0 $bool = no // A guard time (GT, CGT, or BGT) has not been violated.
  let UART1_IS7816_GTV_A_1 $bool = yes // A guard time (GT, CGT, or BGT) has been violated.

//--- Enumerated values for register IS7816, field ADT
  let UART1_IS7816_ADT_ATR_0 $bool = no // ATR Duration time (ADT) has not been violated.
  let UART1_IS7816_ADT_ATR_1 $bool = yes // ATR Duration time (ADT) has been violated.

//--- Enumerated values for register IS7816, field INITD
  let UART1_IS7816_INITD_A_0 $bool = no // A valid initial character has not been received.
  let UART1_IS7816_INITD_A_1 $bool = yes // A valid initial character has been received.

//--- Enumerated values for register IS7816, field BWT
  let UART1_IS7816_BWT_Block_0 $bool = no // Block wait time (BWT) has not been violated.
  let UART1_IS7816_BWT_Block_1 $bool = yes // Block wait time (BWT) has been violated.

//--- Enumerated values for register IS7816, field CWT
  let UART1_IS7816_CWT_Character_0 $bool = no // Character wait time (CWT) has not been violated.
  let UART1_IS7816_CWT_Character_1 $bool = yes // Character wait time (CWT) has been violated.

//--- Enumerated values for register IS7816, field WT
  let UART1_IS7816_WT_Wait_0 $bool = no // Wait time (WT) has not been violated.
  let UART1_IS7816_WT_Wait_1 $bool = yes // Wait time (WT) has been violated.

//--- Enumerated values for register ET7816, field TXTHRESHOLD
  let UART1_ET7816_TXTHRESHOLD_TXT_0 $u4 = 0 // TXT asserts on the first NACK that is received.
  let UART1_ET7816_TXTHRESHOLD_TXT_1 $u4 = 1 // TXT asserts on the second NACK that is received.

//--- Enumerated values for register BDH, field SBNS
  let UART2_BDH_SBNS_Data_0 $bool = no // Data frame consists of a single stop bit.
  let UART2_BDH_SBNS_Data_1 $bool = yes // Data frame consists of two stop bits.

//--- Enumerated values for register BDH, field RXEDGIE
  let UART2_BDH_RXEDGIE_Hardware_0 $bool = no // Hardware interrupts from RXEDGIF disabled using polling.
  let UART2_BDH_RXEDGIE_RXEDGIF_1 $bool = yes // RXEDGIF interrupt request enabled.

//--- Enumerated values for register BDH, field LBKDIE
  let UART2_BDH_LBKDIE_LBKDIF_0 $bool = no // LBKDIF interrupt requests disabled.
  let UART2_BDH_LBKDIE_LBKDIF_1 $bool = yes // LBKDIF interrupt requests enabled.

//--- Enumerated values for register C1, field PT
  let UART2_C1_PT_Even_0 $bool = no // Even parity.
  let UART2_C1_PT_Odd_1 $bool = yes // Odd parity.

//--- Enumerated values for register C1, field PE
  let UART2_C1_PE_Parity_0 $bool = no // Parity function disabled.
  let UART2_C1_PE_Parity_1 $bool = yes // Parity function enabled.

//--- Enumerated values for register C1, field ILT
  let UART2_C1_ILT_Idle_0 $bool = no // Idle character bit count starts after start bit.
  let UART2_C1_ILT_Idle_1 $bool = yes // Idle character bit count starts after stop bit.

//--- Enumerated values for register C1, field WAKE
  let UART2_C1_WAKE_Idle_0 $bool = no // Idle line wakeup.
  let UART2_C1_WAKE_Address_1 $bool = yes // Address mark wakeup.

//--- Enumerated values for register C1, field M
  let UART2_C1_M_Normal_start_0 $bool = no // Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
  let UART2_C1_M_Use_start_1 $bool = yes // Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.

//--- Enumerated values for register C1, field RSRC
  let UART2_C1_RSRC_Selects_0 $bool = no // Selects internal loop back mode. The receiver input is internally connected to transmitter output.
  let UART2_C1_RSRC_Single_1 $bool = yes // Single wire UART mode where the receiver input is connected to the transmit pin input signal.

//--- Enumerated values for register C1, field UARTSWAI
  let UART2_C1_UARTSWAI_UART_0 $bool = no // UART clock continues to run in Wait mode.
  let UART2_C1_UARTSWAI_UART_1 $bool = yes // UART clock freezes while CPU is in Wait mode.

//--- Enumerated values for register C1, field LOOPS
  let UART2_C1_LOOPS_Normal_0 $bool = no // Normal operation.
  let UART2_C1_LOOPS_Loop_1 $bool = yes // Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.

//--- Enumerated values for register C2, field SBK
  let UART2_C2_SBK_Normal_0 $bool = no // Normal transmitter operation.
  let UART2_C2_SBK_Queue_1 $bool = yes // Queue break characters to be sent.

//--- Enumerated values for register C2, field RWU
  let UART2_C2_RWU_Normal_0 $bool = no // Normal operation.
  let UART2_C2_RWU_RWU_1 $bool = yes // RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.

//--- Enumerated values for register C2, field RE
  let UART2_C2_RE_Receiver_0 $bool = no // Receiver off.
  let UART2_C2_RE_Receiver_1 $bool = yes // Receiver on.

//--- Enumerated values for register C2, field TE
  let UART2_C2_TE_Transmitter_0 $bool = no // Transmitter off.
  let UART2_C2_TE_Transmitter_1 $bool = yes // Transmitter on.

//--- Enumerated values for register C2, field ILIE
  let UART2_C2_ILIE_IDLE_0 $bool = no // IDLE interrupt requests disabled.
  let UART2_C2_ILIE_IDLE_1 $bool = yes // IDLE interrupt requests enabled.

//--- Enumerated values for register C2, field RIE
  let UART2_C2_RIE_RDRF_0 $bool = no // RDRF interrupt and DMA transfer requests disabled.
  let UART2_C2_RIE_RDRF_1 $bool = yes // RDRF interrupt or DMA transfer requests enabled.

//--- Enumerated values for register C2, field TCIE
  let UART2_C2_TCIE_TC_0 $bool = no // TC interrupt requests disabled.
  let UART2_C2_TCIE_TC_1 $bool = yes // TC interrupt requests enabled.

//--- Enumerated values for register C2, field TIE
  let UART2_C2_TIE_TDRE_0 $bool = no // TDRE interrupt and DMA transfer requests disabled.
  let UART2_C2_TIE_TDRE_1 $bool = yes // TDRE interrupt or DMA transfer requests enabled.

//--- Enumerated values for register S1, field PF
  let UART2_S1_PF_No_0 $bool = no // No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
  let UART2_S1_PF_At_1 $bool = yes // At least one dataword was received with a parity error since the last time this flag was cleared.

//--- Enumerated values for register S1, field FE
  let UART2_S1_FE_No_0 $bool = no // No framing error detected.
  let UART2_S1_FE_Framing_1 $bool = yes // Framing error.

//--- Enumerated values for register S1, field NF
  let UART2_S1_NF_No_0 $bool = no // No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
  let UART2_S1_NF_At_1 $bool = yes // At least one dataword was received with noise detected since the last time the flag was cleared.

//--- Enumerated values for register S1, field OR
  let UART2_S1_OR_No_0 $bool = no // No overrun has occurred since the last time the flag was cleared.
  let UART2_S1_OR_Overrun_1 $bool = yes // Overrun has occurred or the overrun flag has not been cleared since the last overrun occured.

//--- Enumerated values for register S1, field IDLE
  let UART2_S1_IDLE_Receiver_0 $bool = no // Receiver input is either active now or has never become active since the IDLE flag was last cleared.
  let UART2_S1_IDLE_Receiver_1 $bool = yes // Receiver input has become idle or the flag has not been cleared since it last asserted.

//--- Enumerated values for register S1, field RDRF
  let UART2_S1_RDRF_The_0 $bool = no // The number of datawords in the receive buffer is less than the number indicated by RXWATER.
  let UART2_S1_RDRF_The_1 $bool = yes // The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.

//--- Enumerated values for register S1, field TC
  let UART2_S1_TC_Transmitter_0 $bool = no // Transmitter active (sending data, a preamble, or a break).
  let UART2_S1_TC_Transmitter_1 $bool = yes // Transmitter idle (transmission activity complete).

//--- Enumerated values for register S1, field TDRE
  let UART2_S1_TDRE_The_0 $bool = no // The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
  let UART2_S1_TDRE_The_1 $bool = yes // The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.

//--- Enumerated values for register S2, field RAF
  let UART2_S2_RAF_UART_0 $bool = no // UART receiver idle/inactive waiting for a start bit.
  let UART2_S2_RAF_UART_1 $bool = yes // UART receiver active, RxD input not idle.

//--- Enumerated values for register S2, field LBKDE
  let UART2_S2_LBKDE_Break_0 $bool = no // Break character detection is disabled.
  let UART2_S2_LBKDE_Break_1 $bool = yes // Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.

//--- Enumerated values for register S2, field BRK13
  let UART2_S2_BRK13_Break_0 $bool = no // Break character is 10, 11, or 12 bits long.
  let UART2_S2_BRK13_Break_1 $bool = yes // Break character is 13 or 14 bits long.

//--- Enumerated values for register S2, field RWUID
  let UART2_S2_RWUID_S1_IDLE__0 $bool = no // S1[IDLE] is not set upon detection of an idle character.
  let UART2_S2_RWUID_S1_IDLE__1 $bool = yes // S1[IDLE] is set upon detection of an idle character.

//--- Enumerated values for register S2, field RXINV
  let UART2_S2_RXINV_Receive_0 $bool = no // Receive data is not inverted.
  let UART2_S2_RXINV_Receive_1 $bool = yes // Receive data is inverted.

//--- Enumerated values for register S2, field MSBF
  let UART2_S2_MSBF_LSB_0 $bool = no // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
  let UART2_S2_MSBF_MSB_1 $bool = yes // MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].

//--- Enumerated values for register S2, field RXEDGIF
  let UART2_S2_RXEDGIF_No_0 $bool = no // No active edge on the receive pin has occurred.
  let UART2_S2_RXEDGIF_An_1 $bool = yes // An active edge on the receive pin has occurred.

//--- Enumerated values for register S2, field LBKDIF
  let UART2_S2_LBKDIF_No_0 $bool = no // No LIN break character detected.
  let UART2_S2_LBKDIF_LIN_1 $bool = yes // LIN break character detected.

//--- Enumerated values for register C3, field PEIE
  let UART2_C3_PEIE_PF_0 $bool = no // PF interrupt requests are disabled.
  let UART2_C3_PEIE_PF_1 $bool = yes // PF interrupt requests are enabled.

//--- Enumerated values for register C3, field FEIE
  let UART2_C3_FEIE_FE_0 $bool = no // FE interrupt requests are disabled.
  let UART2_C3_FEIE_FE_1 $bool = yes // FE interrupt requests are enabled.

//--- Enumerated values for register C3, field NEIE
  let UART2_C3_NEIE_NF_0 $bool = no // NF interrupt requests are disabled.
  let UART2_C3_NEIE_NF_1 $bool = yes // NF interrupt requests are enabled.

//--- Enumerated values for register C3, field ORIE
  let UART2_C3_ORIE_OR_0 $bool = no // OR interrupts are disabled.
  let UART2_C3_ORIE_OR_1 $bool = yes // OR interrupt requests are enabled.

//--- Enumerated values for register C3, field TXINV
  let UART2_C3_TXINV_Transmit_0 $bool = no // Transmit data is not inverted.
  let UART2_C3_TXINV_Transmit_1 $bool = yes // Transmit data is inverted.

//--- Enumerated values for register C3, field TXDIR
  let UART2_C3_TXDIR_TXD_0 $bool = no // TXD pin is an input in single wire mode.
  let UART2_C3_TXDIR_TXD_1 $bool = yes // TXD pin is an output in single wire mode.

//--- Enumerated values for register C4, field M10
  let UART2_C4_M10_The_0 $bool = no // The parity bit is the ninth bit in the serial transmission.
  let UART2_C4_M10_The_1 $bool = yes // The parity bit is the tenth bit in the serial transmission.

//--- Enumerated values for register C4, field MAEN2
  let UART2_C4_MAEN2_All_0 $bool = no // All data received is transferred to the data buffer if MAEN1 is cleared.
  let UART2_C4_MAEN2_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C4, field MAEN1
  let UART2_C4_MAEN1_All_0 $bool = no // All data received is transferred to the data buffer if MAEN2 is cleared.
  let UART2_C4_MAEN1_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C5, field RDMAS
  let UART2_C5_RDMAS_If_0 $bool = no // If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
  let UART2_C5_RDMAS_If_1 $bool = yes // If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register C5, field TDMAS
  let UART2_C5_TDMAS_If_0 $bool = no // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
  let UART2_C5_TDMAS_If_1 $bool = yes // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register ED, field PARITYE
  let UART2_ED_PARITYE_The_0 $bool = no // The dataword was received without a parity error.
  let UART2_ED_PARITYE_The_1 $bool = yes // The dataword was received with a parity error.

//--- Enumerated values for register ED, field NOISY
  let UART2_ED_NOISY_The_0 $bool = no // The dataword was received without noise.
  let UART2_ED_NOISY_The_1 $bool = yes // The data was received with noise.

//--- Enumerated values for register MODEM, field TXCTSE
  let UART2_MODEM_TXCTSE_CTS_0 $bool = no // CTS has no effect on the transmitter.
  let UART2_MODEM_TXCTSE_Enables_1 $bool = yes // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.

//--- Enumerated values for register MODEM, field TXRTSE
  let UART2_MODEM_TXRTSE_The_0 $bool = no // The transmitter has no effect on RTS.
  let UART2_MODEM_TXRTSE_When_1 $bool = yes // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)

//--- Enumerated values for register MODEM, field TXRTSPOL
  let UART2_MODEM_TXRTSPOL_Transmitter_0 $bool = no // Transmitter RTS is active low.
  let UART2_MODEM_TXRTSPOL_Transmitter_1 $bool = yes // Transmitter RTS is active high.

//--- Enumerated values for register MODEM, field RXRTSE
  let UART2_MODEM_RXRTSE_The_0 $bool = no // The receiver has no effect on RTS.
  let UART2_MODEM_RXRTSE_RTS_1 $bool = yes // RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]. See Hardware flow control

//--- Enumerated values for register IR, field TNP
  let UART2_IR_TNP_3_16__00 $u2 = 0 // 3/16.
  let UART2_IR_TNP_1_16__01 $u2 = 1 // 1/16.
  let UART2_IR_TNP_1_32__10 $u2 = 2 // 1/32.
  let UART2_IR_TNP_1_4__11 $u2 = 3 // 1/4.

//--- Enumerated values for register IR, field IREN
  let UART2_IR_IREN_IR_0 $bool = no // IR disabled.
  let UART2_IR_IREN_IR_1 $bool = yes // IR enabled.

//--- Enumerated values for register PFIFO, field RXFIFOSIZE
  let UART2_PFIFO_RXFIFOSIZE_Receive_000 $u3 = 0 // Receive FIFO/Buffer depth = 1 dataword.
  let UART2_PFIFO_RXFIFOSIZE_Receive_001 $u3 = 1 // Receive FIFO/Buffer depth = 4 datawords.
  let UART2_PFIFO_RXFIFOSIZE_Receive_010 $u3 = 2 // Receive FIFO/Buffer depth = 8 datawords.
  let UART2_PFIFO_RXFIFOSIZE_Receive_011 $u3 = 3 // Receive FIFO/Buffer depth = 16 datawords.
  let UART2_PFIFO_RXFIFOSIZE_Receive_100 $u3 = 4 // Receive FIFO/Buffer depth = 32 datawords.
  let UART2_PFIFO_RXFIFOSIZE_Receive_101 $u3 = 5 // Receive FIFO/Buffer depth = 64 datawords.
  let UART2_PFIFO_RXFIFOSIZE_Receive_110 $u3 = 6 // Receive FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field RXFE
  let UART2_PFIFO_RXFE_Receive_0 $bool = no // Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
  let UART2_PFIFO_RXFE_Receive_1 $bool = yes // Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.

//--- Enumerated values for register PFIFO, field TXFIFOSIZE
  let UART2_PFIFO_TXFIFOSIZE_Transmit_000 $u3 = 0 // Transmit FIFO/Buffer depth = 1 dataword.
  let UART2_PFIFO_TXFIFOSIZE_Transmit_001 $u3 = 1 // Transmit FIFO/Buffer depth = 4 datawords.
  let UART2_PFIFO_TXFIFOSIZE_Transmit_010 $u3 = 2 // Transmit FIFO/Buffer depth = 8 datawords.
  let UART2_PFIFO_TXFIFOSIZE_Transmit_011 $u3 = 3 // Transmit FIFO/Buffer depth = 16 datawords.
  let UART2_PFIFO_TXFIFOSIZE_Transmit_100 $u3 = 4 // Transmit FIFO/Buffer depth = 32 datawords.
  let UART2_PFIFO_TXFIFOSIZE_Transmit_101 $u3 = 5 // Transmit FIFO/Buffer depth = 64 datawords.
  let UART2_PFIFO_TXFIFOSIZE_Transmit_110 $u3 = 6 // Transmit FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field TXFE
  let UART2_PFIFO_TXFE_Transmit_0 $bool = no // Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
  let UART2_PFIFO_TXFE_Transmit_1 $bool = yes // Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.

//--- Enumerated values for register CFIFO, field RXUFE
  let UART2_CFIFO_RXUFE_RXUF_0 $bool = no // RXUF flag does not generate an interrupt to the host.
  let UART2_CFIFO_RXUFE_RXUF_1 $bool = yes // RXUF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field TXOFE
  let UART2_CFIFO_TXOFE_TXOF_0 $bool = no // TXOF flag does not generate an interrupt to the host.
  let UART2_CFIFO_TXOFE_TXOF_1 $bool = yes // TXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXOFE
  let UART2_CFIFO_RXOFE_RXOF_0 $bool = no // RXOF flag does not generate an interrupt to the host.
  let UART2_CFIFO_RXOFE_RXOF_1 $bool = yes // RXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXFLUSH
  let UART2_CFIFO_RXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART2_CFIFO_RXFLUSH_All_1 $bool = yes // All data in the receive FIFO/buffer is cleared out.

//--- Enumerated values for register CFIFO, field TXFLUSH
  let UART2_CFIFO_TXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART2_CFIFO_TXFLUSH_All_1 $bool = yes // All data in the transmit FIFO/Buffer is cleared out.

//--- Enumerated values for register SFIFO, field RXUF
  let UART2_SFIFO_RXUF_No_0 $bool = no // No receive buffer underflow has occurred since the last time the flag was cleared.
  let UART2_SFIFO_RXUF_At_1 $bool = yes // At least one receive buffer underflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field TXOF
  let UART2_SFIFO_TXOF_No_0 $bool = no // No transmit buffer overflow has occurred since the last time the flag was cleared.
  let UART2_SFIFO_TXOF_At_1 $bool = yes // At least one transmit buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXOF
  let UART2_SFIFO_RXOF_No_0 $bool = no // No receive buffer overflow has occurred since the last time the flag was cleared.
  let UART2_SFIFO_RXOF_At_1 $bool = yes // At least one receive buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXEMPT
  let UART2_SFIFO_RXEMPT_Receive_0 $bool = no // Receive buffer is not empty.
  let UART2_SFIFO_RXEMPT_Receive_1 $bool = yes // Receive buffer is empty.

//--- Enumerated values for register SFIFO, field TXEMPT
  let UART2_SFIFO_TXEMPT_Transmit_0 $bool = no // Transmit buffer is not empty.
  let UART2_SFIFO_TXEMPT_Transmit_1 $bool = yes // Transmit buffer is empty.

//--- Enumerated values for register C7816, field ISO_7816E
  let UART2_C7816_ISO_7816E_ISO_7816_0 $bool = no // ISO-7816 functionality is turned off/not enabled.
  let UART2_C7816_ISO_7816E_ISO_7816_1 $bool = yes // ISO-7816 functionality is turned on/enabled.

//--- Enumerated values for register C7816, field TTYPE
  let UART2_C7816_TTYPE_T_0 $bool = no // T = 0 per the ISO-7816 specification.
  let UART2_C7816_TTYPE_T_1 $bool = yes // T = 1 per the ISO-7816 specification.

//--- Enumerated values for register C7816, field INIT
  let UART2_C7816_INIT_Normal_0 $bool = no // Normal operating mode. Receiver does not seek to identify initial character.
  let UART2_C7816_INIT_Receiver_1 $bool = yes // Receiver searches for initial character.

//--- Enumerated values for register C7816, field ANACK
  let UART2_C7816_ANACK_No_0 $bool = no // No NACK is automatically generated.
  let UART2_C7816_ANACK_A_1 $bool = yes // A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.

//--- Enumerated values for register C7816, field ONACK
  let UART2_C7816_ONACK_The_0 $bool = no // The received data does not generate a NACK when the receipt of the data results in an overflow event.
  let UART2_C7816_ONACK_If_1 $bool = yes // If the receiver buffer overflows, a NACK is automatically sent on a received character.

//--- Enumerated values for register IE7816, field RXTE
  let UART2_IE7816_RXTE_The_0 $bool = no // The assertion of IS7816[RXT] does not result in the generation of an interrupt.
  let UART2_IE7816_RXTE_The_1 $bool = yes // The assertion of IS7816[RXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field TXTE
  let UART2_IE7816_TXTE_The_0 $bool = no // The assertion of IS7816[TXT] does not result in the generation of an interrupt.
  let UART2_IE7816_TXTE_The_1 $bool = yes // The assertion of IS7816[TXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field GTVE
  let UART2_IE7816_GTVE_The_0 $bool = no // The assertion of IS7816[GTV] does not result in the generation of an interrupt.
  let UART2_IE7816_GTVE_The_1 $bool = yes // The assertion of IS7816[GTV] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field ADTE
  let UART2_IE7816_ADTE_The_0 $bool = no // The assertion of IS7816[ADT] does not result in the generation of an interrupt.
  let UART2_IE7816_ADTE_The_1 $bool = yes // The assertion of IS7816[ADT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field INITDE
  let UART2_IE7816_INITDE_The_0 $bool = no // The assertion of IS7816[INITD] does not result in the generation of an interrupt.
  let UART2_IE7816_INITDE_The_1 $bool = yes // The assertion of IS7816[INITD] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field BWTE
  let UART2_IE7816_BWTE_The_0 $bool = no // The assertion of IS7816[BWT] does not result in the generation of an interrupt.
  let UART2_IE7816_BWTE_The_1 $bool = yes // The assertion of IS7816[BWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field CWTE
  let UART2_IE7816_CWTE_The_0 $bool = no // The assertion of IS7816[CWT] does not result in the generation of an interrupt.
  let UART2_IE7816_CWTE_The_1 $bool = yes // The assertion of IS7816[CWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field WTE
  let UART2_IE7816_WTE_The_0 $bool = no // The assertion of IS7816[WT] does not result in the generation of an interrupt.
  let UART2_IE7816_WTE_The_1 $bool = yes // The assertion of IS7816[WT] results in the generation of an interrupt.

//--- Enumerated values for register IS7816, field RXT
  let UART2_IS7816_RXT_The_0 $bool = no // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
  let UART2_IS7816_RXT_The_1 $bool = yes // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].

//--- Enumerated values for register IS7816, field TXT
  let UART2_IS7816_TXT_The_0 $bool = no // The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
  let UART2_IS7816_TXT_The_1 $bool = yes // The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].

//--- Enumerated values for register IS7816, field GTV
  let UART2_IS7816_GTV_A_0 $bool = no // A guard time (GT, CGT, or BGT) has not been violated.
  let UART2_IS7816_GTV_A_1 $bool = yes // A guard time (GT, CGT, or BGT) has been violated.

//--- Enumerated values for register IS7816, field ADT
  let UART2_IS7816_ADT_ATR_0 $bool = no // ATR Duration time (ADT) has not been violated.
  let UART2_IS7816_ADT_ATR_1 $bool = yes // ATR Duration time (ADT) has been violated.

//--- Enumerated values for register IS7816, field INITD
  let UART2_IS7816_INITD_A_0 $bool = no // A valid initial character has not been received.
  let UART2_IS7816_INITD_A_1 $bool = yes // A valid initial character has been received.

//--- Enumerated values for register IS7816, field BWT
  let UART2_IS7816_BWT_Block_0 $bool = no // Block wait time (BWT) has not been violated.
  let UART2_IS7816_BWT_Block_1 $bool = yes // Block wait time (BWT) has been violated.

//--- Enumerated values for register IS7816, field CWT
  let UART2_IS7816_CWT_Character_0 $bool = no // Character wait time (CWT) has not been violated.
  let UART2_IS7816_CWT_Character_1 $bool = yes // Character wait time (CWT) has been violated.

//--- Enumerated values for register IS7816, field WT
  let UART2_IS7816_WT_Wait_0 $bool = no // Wait time (WT) has not been violated.
  let UART2_IS7816_WT_Wait_1 $bool = yes // Wait time (WT) has been violated.

//--- Enumerated values for register ET7816, field TXTHRESHOLD
  let UART2_ET7816_TXTHRESHOLD_TXT_0 $u4 = 0 // TXT asserts on the first NACK that is received.
  let UART2_ET7816_TXTHRESHOLD_TXT_1 $u4 = 1 // TXT asserts on the second NACK that is received.

//--- Enumerated values for register BDH, field SBNS
  let UART3_BDH_SBNS_Data_0 $bool = no // Data frame consists of a single stop bit.
  let UART3_BDH_SBNS_Data_1 $bool = yes // Data frame consists of two stop bits.

//--- Enumerated values for register BDH, field RXEDGIE
  let UART3_BDH_RXEDGIE_Hardware_0 $bool = no // Hardware interrupts from RXEDGIF disabled using polling.
  let UART3_BDH_RXEDGIE_RXEDGIF_1 $bool = yes // RXEDGIF interrupt request enabled.

//--- Enumerated values for register BDH, field LBKDIE
  let UART3_BDH_LBKDIE_LBKDIF_0 $bool = no // LBKDIF interrupt requests disabled.
  let UART3_BDH_LBKDIE_LBKDIF_1 $bool = yes // LBKDIF interrupt requests enabled.

//--- Enumerated values for register C1, field PT
  let UART3_C1_PT_Even_0 $bool = no // Even parity.
  let UART3_C1_PT_Odd_1 $bool = yes // Odd parity.

//--- Enumerated values for register C1, field PE
  let UART3_C1_PE_Parity_0 $bool = no // Parity function disabled.
  let UART3_C1_PE_Parity_1 $bool = yes // Parity function enabled.

//--- Enumerated values for register C1, field ILT
  let UART3_C1_ILT_Idle_0 $bool = no // Idle character bit count starts after start bit.
  let UART3_C1_ILT_Idle_1 $bool = yes // Idle character bit count starts after stop bit.

//--- Enumerated values for register C1, field WAKE
  let UART3_C1_WAKE_Idle_0 $bool = no // Idle line wakeup.
  let UART3_C1_WAKE_Address_1 $bool = yes // Address mark wakeup.

//--- Enumerated values for register C1, field M
  let UART3_C1_M_Normal_start_0 $bool = no // Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
  let UART3_C1_M_Use_start_1 $bool = yes // Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.

//--- Enumerated values for register C1, field RSRC
  let UART3_C1_RSRC_Selects_0 $bool = no // Selects internal loop back mode. The receiver input is internally connected to transmitter output.
  let UART3_C1_RSRC_Single_1 $bool = yes // Single wire UART mode where the receiver input is connected to the transmit pin input signal.

//--- Enumerated values for register C1, field UARTSWAI
  let UART3_C1_UARTSWAI_UART_0 $bool = no // UART clock continues to run in Wait mode.
  let UART3_C1_UARTSWAI_UART_1 $bool = yes // UART clock freezes while CPU is in Wait mode.

//--- Enumerated values for register C1, field LOOPS
  let UART3_C1_LOOPS_Normal_0 $bool = no // Normal operation.
  let UART3_C1_LOOPS_Loop_1 $bool = yes // Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.

//--- Enumerated values for register C2, field SBK
  let UART3_C2_SBK_Normal_0 $bool = no // Normal transmitter operation.
  let UART3_C2_SBK_Queue_1 $bool = yes // Queue break characters to be sent.

//--- Enumerated values for register C2, field RWU
  let UART3_C2_RWU_Normal_0 $bool = no // Normal operation.
  let UART3_C2_RWU_RWU_1 $bool = yes // RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.

//--- Enumerated values for register C2, field RE
  let UART3_C2_RE_Receiver_0 $bool = no // Receiver off.
  let UART3_C2_RE_Receiver_1 $bool = yes // Receiver on.

//--- Enumerated values for register C2, field TE
  let UART3_C2_TE_Transmitter_0 $bool = no // Transmitter off.
  let UART3_C2_TE_Transmitter_1 $bool = yes // Transmitter on.

//--- Enumerated values for register C2, field ILIE
  let UART3_C2_ILIE_IDLE_0 $bool = no // IDLE interrupt requests disabled.
  let UART3_C2_ILIE_IDLE_1 $bool = yes // IDLE interrupt requests enabled.

//--- Enumerated values for register C2, field RIE
  let UART3_C2_RIE_RDRF_0 $bool = no // RDRF interrupt and DMA transfer requests disabled.
  let UART3_C2_RIE_RDRF_1 $bool = yes // RDRF interrupt or DMA transfer requests enabled.

//--- Enumerated values for register C2, field TCIE
  let UART3_C2_TCIE_TC_0 $bool = no // TC interrupt requests disabled.
  let UART3_C2_TCIE_TC_1 $bool = yes // TC interrupt requests enabled.

//--- Enumerated values for register C2, field TIE
  let UART3_C2_TIE_TDRE_0 $bool = no // TDRE interrupt and DMA transfer requests disabled.
  let UART3_C2_TIE_TDRE_1 $bool = yes // TDRE interrupt or DMA transfer requests enabled.

//--- Enumerated values for register S1, field PF
  let UART3_S1_PF_No_0 $bool = no // No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
  let UART3_S1_PF_At_1 $bool = yes // At least one dataword was received with a parity error since the last time this flag was cleared.

//--- Enumerated values for register S1, field FE
  let UART3_S1_FE_No_0 $bool = no // No framing error detected.
  let UART3_S1_FE_Framing_1 $bool = yes // Framing error.

//--- Enumerated values for register S1, field NF
  let UART3_S1_NF_No_0 $bool = no // No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
  let UART3_S1_NF_At_1 $bool = yes // At least one dataword was received with noise detected since the last time the flag was cleared.

//--- Enumerated values for register S1, field OR
  let UART3_S1_OR_No_0 $bool = no // No overrun has occurred since the last time the flag was cleared.
  let UART3_S1_OR_Overrun_1 $bool = yes // Overrun has occurred or the overrun flag has not been cleared since the last overrun occured.

//--- Enumerated values for register S1, field IDLE
  let UART3_S1_IDLE_Receiver_0 $bool = no // Receiver input is either active now or has never become active since the IDLE flag was last cleared.
  let UART3_S1_IDLE_Receiver_1 $bool = yes // Receiver input has become idle or the flag has not been cleared since it last asserted.

//--- Enumerated values for register S1, field RDRF
  let UART3_S1_RDRF_The_0 $bool = no // The number of datawords in the receive buffer is less than the number indicated by RXWATER.
  let UART3_S1_RDRF_The_1 $bool = yes // The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.

//--- Enumerated values for register S1, field TC
  let UART3_S1_TC_Transmitter_0 $bool = no // Transmitter active (sending data, a preamble, or a break).
  let UART3_S1_TC_Transmitter_1 $bool = yes // Transmitter idle (transmission activity complete).

//--- Enumerated values for register S1, field TDRE
  let UART3_S1_TDRE_The_0 $bool = no // The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
  let UART3_S1_TDRE_The_1 $bool = yes // The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.

//--- Enumerated values for register S2, field RAF
  let UART3_S2_RAF_UART_0 $bool = no // UART receiver idle/inactive waiting for a start bit.
  let UART3_S2_RAF_UART_1 $bool = yes // UART receiver active, RxD input not idle.

//--- Enumerated values for register S2, field LBKDE
  let UART3_S2_LBKDE_Break_0 $bool = no // Break character detection is disabled.
  let UART3_S2_LBKDE_Break_1 $bool = yes // Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.

//--- Enumerated values for register S2, field BRK13
  let UART3_S2_BRK13_Break_0 $bool = no // Break character is 10, 11, or 12 bits long.
  let UART3_S2_BRK13_Break_1 $bool = yes // Break character is 13 or 14 bits long.

//--- Enumerated values for register S2, field RWUID
  let UART3_S2_RWUID_S1_IDLE__0 $bool = no // S1[IDLE] is not set upon detection of an idle character.
  let UART3_S2_RWUID_S1_IDLE__1 $bool = yes // S1[IDLE] is set upon detection of an idle character.

//--- Enumerated values for register S2, field RXINV
  let UART3_S2_RXINV_Receive_0 $bool = no // Receive data is not inverted.
  let UART3_S2_RXINV_Receive_1 $bool = yes // Receive data is inverted.

//--- Enumerated values for register S2, field MSBF
  let UART3_S2_MSBF_LSB_0 $bool = no // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
  let UART3_S2_MSBF_MSB_1 $bool = yes // MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].

//--- Enumerated values for register S2, field RXEDGIF
  let UART3_S2_RXEDGIF_No_0 $bool = no // No active edge on the receive pin has occurred.
  let UART3_S2_RXEDGIF_An_1 $bool = yes // An active edge on the receive pin has occurred.

//--- Enumerated values for register S2, field LBKDIF
  let UART3_S2_LBKDIF_No_0 $bool = no // No LIN break character detected.
  let UART3_S2_LBKDIF_LIN_1 $bool = yes // LIN break character detected.

//--- Enumerated values for register C3, field PEIE
  let UART3_C3_PEIE_PF_0 $bool = no // PF interrupt requests are disabled.
  let UART3_C3_PEIE_PF_1 $bool = yes // PF interrupt requests are enabled.

//--- Enumerated values for register C3, field FEIE
  let UART3_C3_FEIE_FE_0 $bool = no // FE interrupt requests are disabled.
  let UART3_C3_FEIE_FE_1 $bool = yes // FE interrupt requests are enabled.

//--- Enumerated values for register C3, field NEIE
  let UART3_C3_NEIE_NF_0 $bool = no // NF interrupt requests are disabled.
  let UART3_C3_NEIE_NF_1 $bool = yes // NF interrupt requests are enabled.

//--- Enumerated values for register C3, field ORIE
  let UART3_C3_ORIE_OR_0 $bool = no // OR interrupts are disabled.
  let UART3_C3_ORIE_OR_1 $bool = yes // OR interrupt requests are enabled.

//--- Enumerated values for register C3, field TXINV
  let UART3_C3_TXINV_Transmit_0 $bool = no // Transmit data is not inverted.
  let UART3_C3_TXINV_Transmit_1 $bool = yes // Transmit data is inverted.

//--- Enumerated values for register C3, field TXDIR
  let UART3_C3_TXDIR_TXD_0 $bool = no // TXD pin is an input in single wire mode.
  let UART3_C3_TXDIR_TXD_1 $bool = yes // TXD pin is an output in single wire mode.

//--- Enumerated values for register C4, field M10
  let UART3_C4_M10_The_0 $bool = no // The parity bit is the ninth bit in the serial transmission.
  let UART3_C4_M10_The_1 $bool = yes // The parity bit is the tenth bit in the serial transmission.

//--- Enumerated values for register C4, field MAEN2
  let UART3_C4_MAEN2_All_0 $bool = no // All data received is transferred to the data buffer if MAEN1 is cleared.
  let UART3_C4_MAEN2_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C4, field MAEN1
  let UART3_C4_MAEN1_All_0 $bool = no // All data received is transferred to the data buffer if MAEN2 is cleared.
  let UART3_C4_MAEN1_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C5, field RDMAS
  let UART3_C5_RDMAS_If_0 $bool = no // If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
  let UART3_C5_RDMAS_If_1 $bool = yes // If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register C5, field TDMAS
  let UART3_C5_TDMAS_If_0 $bool = no // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
  let UART3_C5_TDMAS_If_1 $bool = yes // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register ED, field PARITYE
  let UART3_ED_PARITYE_The_0 $bool = no // The dataword was received without a parity error.
  let UART3_ED_PARITYE_The_1 $bool = yes // The dataword was received with a parity error.

//--- Enumerated values for register ED, field NOISY
  let UART3_ED_NOISY_The_0 $bool = no // The dataword was received without noise.
  let UART3_ED_NOISY_The_1 $bool = yes // The data was received with noise.

//--- Enumerated values for register MODEM, field TXCTSE
  let UART3_MODEM_TXCTSE_CTS_0 $bool = no // CTS has no effect on the transmitter.
  let UART3_MODEM_TXCTSE_Enables_1 $bool = yes // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.

//--- Enumerated values for register MODEM, field TXRTSE
  let UART3_MODEM_TXRTSE_The_0 $bool = no // The transmitter has no effect on RTS.
  let UART3_MODEM_TXRTSE_When_1 $bool = yes // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)

//--- Enumerated values for register MODEM, field TXRTSPOL
  let UART3_MODEM_TXRTSPOL_Transmitter_0 $bool = no // Transmitter RTS is active low.
  let UART3_MODEM_TXRTSPOL_Transmitter_1 $bool = yes // Transmitter RTS is active high.

//--- Enumerated values for register MODEM, field RXRTSE
  let UART3_MODEM_RXRTSE_The_0 $bool = no // The receiver has no effect on RTS.
  let UART3_MODEM_RXRTSE_RTS_1 $bool = yes // RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]. See Hardware flow control

//--- Enumerated values for register IR, field TNP
  let UART3_IR_TNP_3_16__00 $u2 = 0 // 3/16.
  let UART3_IR_TNP_1_16__01 $u2 = 1 // 1/16.
  let UART3_IR_TNP_1_32__10 $u2 = 2 // 1/32.
  let UART3_IR_TNP_1_4__11 $u2 = 3 // 1/4.

//--- Enumerated values for register IR, field IREN
  let UART3_IR_IREN_IR_0 $bool = no // IR disabled.
  let UART3_IR_IREN_IR_1 $bool = yes // IR enabled.

//--- Enumerated values for register PFIFO, field RXFIFOSIZE
  let UART3_PFIFO_RXFIFOSIZE_Receive_000 $u3 = 0 // Receive FIFO/Buffer depth = 1 dataword.
  let UART3_PFIFO_RXFIFOSIZE_Receive_001 $u3 = 1 // Receive FIFO/Buffer depth = 4 datawords.
  let UART3_PFIFO_RXFIFOSIZE_Receive_010 $u3 = 2 // Receive FIFO/Buffer depth = 8 datawords.
  let UART3_PFIFO_RXFIFOSIZE_Receive_011 $u3 = 3 // Receive FIFO/Buffer depth = 16 datawords.
  let UART3_PFIFO_RXFIFOSIZE_Receive_100 $u3 = 4 // Receive FIFO/Buffer depth = 32 datawords.
  let UART3_PFIFO_RXFIFOSIZE_Receive_101 $u3 = 5 // Receive FIFO/Buffer depth = 64 datawords.
  let UART3_PFIFO_RXFIFOSIZE_Receive_110 $u3 = 6 // Receive FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field RXFE
  let UART3_PFIFO_RXFE_Receive_0 $bool = no // Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
  let UART3_PFIFO_RXFE_Receive_1 $bool = yes // Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.

//--- Enumerated values for register PFIFO, field TXFIFOSIZE
  let UART3_PFIFO_TXFIFOSIZE_Transmit_000 $u3 = 0 // Transmit FIFO/Buffer depth = 1 dataword.
  let UART3_PFIFO_TXFIFOSIZE_Transmit_001 $u3 = 1 // Transmit FIFO/Buffer depth = 4 datawords.
  let UART3_PFIFO_TXFIFOSIZE_Transmit_010 $u3 = 2 // Transmit FIFO/Buffer depth = 8 datawords.
  let UART3_PFIFO_TXFIFOSIZE_Transmit_011 $u3 = 3 // Transmit FIFO/Buffer depth = 16 datawords.
  let UART3_PFIFO_TXFIFOSIZE_Transmit_100 $u3 = 4 // Transmit FIFO/Buffer depth = 32 datawords.
  let UART3_PFIFO_TXFIFOSIZE_Transmit_101 $u3 = 5 // Transmit FIFO/Buffer depth = 64 datawords.
  let UART3_PFIFO_TXFIFOSIZE_Transmit_110 $u3 = 6 // Transmit FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field TXFE
  let UART3_PFIFO_TXFE_Transmit_0 $bool = no // Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
  let UART3_PFIFO_TXFE_Transmit_1 $bool = yes // Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.

//--- Enumerated values for register CFIFO, field RXUFE
  let UART3_CFIFO_RXUFE_RXUF_0 $bool = no // RXUF flag does not generate an interrupt to the host.
  let UART3_CFIFO_RXUFE_RXUF_1 $bool = yes // RXUF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field TXOFE
  let UART3_CFIFO_TXOFE_TXOF_0 $bool = no // TXOF flag does not generate an interrupt to the host.
  let UART3_CFIFO_TXOFE_TXOF_1 $bool = yes // TXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXOFE
  let UART3_CFIFO_RXOFE_RXOF_0 $bool = no // RXOF flag does not generate an interrupt to the host.
  let UART3_CFIFO_RXOFE_RXOF_1 $bool = yes // RXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXFLUSH
  let UART3_CFIFO_RXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART3_CFIFO_RXFLUSH_All_1 $bool = yes // All data in the receive FIFO/buffer is cleared out.

//--- Enumerated values for register CFIFO, field TXFLUSH
  let UART3_CFIFO_TXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART3_CFIFO_TXFLUSH_All_1 $bool = yes // All data in the transmit FIFO/Buffer is cleared out.

//--- Enumerated values for register SFIFO, field RXUF
  let UART3_SFIFO_RXUF_No_0 $bool = no // No receive buffer underflow has occurred since the last time the flag was cleared.
  let UART3_SFIFO_RXUF_At_1 $bool = yes // At least one receive buffer underflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field TXOF
  let UART3_SFIFO_TXOF_No_0 $bool = no // No transmit buffer overflow has occurred since the last time the flag was cleared.
  let UART3_SFIFO_TXOF_At_1 $bool = yes // At least one transmit buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXOF
  let UART3_SFIFO_RXOF_No_0 $bool = no // No receive buffer overflow has occurred since the last time the flag was cleared.
  let UART3_SFIFO_RXOF_At_1 $bool = yes // At least one receive buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXEMPT
  let UART3_SFIFO_RXEMPT_Receive_0 $bool = no // Receive buffer is not empty.
  let UART3_SFIFO_RXEMPT_Receive_1 $bool = yes // Receive buffer is empty.

//--- Enumerated values for register SFIFO, field TXEMPT
  let UART3_SFIFO_TXEMPT_Transmit_0 $bool = no // Transmit buffer is not empty.
  let UART3_SFIFO_TXEMPT_Transmit_1 $bool = yes // Transmit buffer is empty.

//--- Enumerated values for register C7816, field ISO_7816E
  let UART3_C7816_ISO_7816E_ISO_7816_0 $bool = no // ISO-7816 functionality is turned off/not enabled.
  let UART3_C7816_ISO_7816E_ISO_7816_1 $bool = yes // ISO-7816 functionality is turned on/enabled.

//--- Enumerated values for register C7816, field TTYPE
  let UART3_C7816_TTYPE_T_0 $bool = no // T = 0 per the ISO-7816 specification.
  let UART3_C7816_TTYPE_T_1 $bool = yes // T = 1 per the ISO-7816 specification.

//--- Enumerated values for register C7816, field INIT
  let UART3_C7816_INIT_Normal_0 $bool = no // Normal operating mode. Receiver does not seek to identify initial character.
  let UART3_C7816_INIT_Receiver_1 $bool = yes // Receiver searches for initial character.

//--- Enumerated values for register C7816, field ANACK
  let UART3_C7816_ANACK_No_0 $bool = no // No NACK is automatically generated.
  let UART3_C7816_ANACK_A_1 $bool = yes // A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.

//--- Enumerated values for register C7816, field ONACK
  let UART3_C7816_ONACK_The_0 $bool = no // The received data does not generate a NACK when the receipt of the data results in an overflow event.
  let UART3_C7816_ONACK_If_1 $bool = yes // If the receiver buffer overflows, a NACK is automatically sent on a received character.

//--- Enumerated values for register IE7816, field RXTE
  let UART3_IE7816_RXTE_The_0 $bool = no // The assertion of IS7816[RXT] does not result in the generation of an interrupt.
  let UART3_IE7816_RXTE_The_1 $bool = yes // The assertion of IS7816[RXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field TXTE
  let UART3_IE7816_TXTE_The_0 $bool = no // The assertion of IS7816[TXT] does not result in the generation of an interrupt.
  let UART3_IE7816_TXTE_The_1 $bool = yes // The assertion of IS7816[TXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field GTVE
  let UART3_IE7816_GTVE_The_0 $bool = no // The assertion of IS7816[GTV] does not result in the generation of an interrupt.
  let UART3_IE7816_GTVE_The_1 $bool = yes // The assertion of IS7816[GTV] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field ADTE
  let UART3_IE7816_ADTE_The_0 $bool = no // The assertion of IS7816[ADT] does not result in the generation of an interrupt.
  let UART3_IE7816_ADTE_The_1 $bool = yes // The assertion of IS7816[ADT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field INITDE
  let UART3_IE7816_INITDE_The_0 $bool = no // The assertion of IS7816[INITD] does not result in the generation of an interrupt.
  let UART3_IE7816_INITDE_The_1 $bool = yes // The assertion of IS7816[INITD] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field BWTE
  let UART3_IE7816_BWTE_The_0 $bool = no // The assertion of IS7816[BWT] does not result in the generation of an interrupt.
  let UART3_IE7816_BWTE_The_1 $bool = yes // The assertion of IS7816[BWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field CWTE
  let UART3_IE7816_CWTE_The_0 $bool = no // The assertion of IS7816[CWT] does not result in the generation of an interrupt.
  let UART3_IE7816_CWTE_The_1 $bool = yes // The assertion of IS7816[CWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field WTE
  let UART3_IE7816_WTE_The_0 $bool = no // The assertion of IS7816[WT] does not result in the generation of an interrupt.
  let UART3_IE7816_WTE_The_1 $bool = yes // The assertion of IS7816[WT] results in the generation of an interrupt.

//--- Enumerated values for register IS7816, field RXT
  let UART3_IS7816_RXT_The_0 $bool = no // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
  let UART3_IS7816_RXT_The_1 $bool = yes // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].

//--- Enumerated values for register IS7816, field TXT
  let UART3_IS7816_TXT_The_0 $bool = no // The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
  let UART3_IS7816_TXT_The_1 $bool = yes // The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].

//--- Enumerated values for register IS7816, field GTV
  let UART3_IS7816_GTV_A_0 $bool = no // A guard time (GT, CGT, or BGT) has not been violated.
  let UART3_IS7816_GTV_A_1 $bool = yes // A guard time (GT, CGT, or BGT) has been violated.

//--- Enumerated values for register IS7816, field ADT
  let UART3_IS7816_ADT_ATR_0 $bool = no // ATR Duration time (ADT) has not been violated.
  let UART3_IS7816_ADT_ATR_1 $bool = yes // ATR Duration time (ADT) has been violated.

//--- Enumerated values for register IS7816, field INITD
  let UART3_IS7816_INITD_A_0 $bool = no // A valid initial character has not been received.
  let UART3_IS7816_INITD_A_1 $bool = yes // A valid initial character has been received.

//--- Enumerated values for register IS7816, field BWT
  let UART3_IS7816_BWT_Block_0 $bool = no // Block wait time (BWT) has not been violated.
  let UART3_IS7816_BWT_Block_1 $bool = yes // Block wait time (BWT) has been violated.

//--- Enumerated values for register IS7816, field CWT
  let UART3_IS7816_CWT_Character_0 $bool = no // Character wait time (CWT) has not been violated.
  let UART3_IS7816_CWT_Character_1 $bool = yes // Character wait time (CWT) has been violated.

//--- Enumerated values for register IS7816, field WT
  let UART3_IS7816_WT_Wait_0 $bool = no // Wait time (WT) has not been violated.
  let UART3_IS7816_WT_Wait_1 $bool = yes // Wait time (WT) has been violated.

//--- Enumerated values for register ET7816, field TXTHRESHOLD
  let UART3_ET7816_TXTHRESHOLD_TXT_0 $u4 = 0 // TXT asserts on the first NACK that is received.
  let UART3_ET7816_TXTHRESHOLD_TXT_1 $u4 = 1 // TXT asserts on the second NACK that is received.

//--- Enumerated values for register BDH, field SBNS
  let UART4_BDH_SBNS_Data_0 $bool = no // Data frame consists of a single stop bit.
  let UART4_BDH_SBNS_Data_1 $bool = yes // Data frame consists of two stop bits.

//--- Enumerated values for register BDH, field RXEDGIE
  let UART4_BDH_RXEDGIE_Hardware_0 $bool = no // Hardware interrupts from RXEDGIF disabled using polling.
  let UART4_BDH_RXEDGIE_RXEDGIF_1 $bool = yes // RXEDGIF interrupt request enabled.

//--- Enumerated values for register BDH, field LBKDIE
  let UART4_BDH_LBKDIE_LBKDIF_0 $bool = no // LBKDIF interrupt requests disabled.
  let UART4_BDH_LBKDIE_LBKDIF_1 $bool = yes // LBKDIF interrupt requests enabled.

//--- Enumerated values for register C1, field PT
  let UART4_C1_PT_Even_0 $bool = no // Even parity.
  let UART4_C1_PT_Odd_1 $bool = yes // Odd parity.

//--- Enumerated values for register C1, field PE
  let UART4_C1_PE_Parity_0 $bool = no // Parity function disabled.
  let UART4_C1_PE_Parity_1 $bool = yes // Parity function enabled.

//--- Enumerated values for register C1, field ILT
  let UART4_C1_ILT_Idle_0 $bool = no // Idle character bit count starts after start bit.
  let UART4_C1_ILT_Idle_1 $bool = yes // Idle character bit count starts after stop bit.

//--- Enumerated values for register C1, field WAKE
  let UART4_C1_WAKE_Idle_0 $bool = no // Idle line wakeup.
  let UART4_C1_WAKE_Address_1 $bool = yes // Address mark wakeup.

//--- Enumerated values for register C1, field M
  let UART4_C1_M_Normal_start_0 $bool = no // Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
  let UART4_C1_M_Use_start_1 $bool = yes // Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.

//--- Enumerated values for register C1, field RSRC
  let UART4_C1_RSRC_Selects_0 $bool = no // Selects internal loop back mode. The receiver input is internally connected to transmitter output.
  let UART4_C1_RSRC_Single_1 $bool = yes // Single wire UART mode where the receiver input is connected to the transmit pin input signal.

//--- Enumerated values for register C1, field UARTSWAI
  let UART4_C1_UARTSWAI_UART_0 $bool = no // UART clock continues to run in Wait mode.
  let UART4_C1_UARTSWAI_UART_1 $bool = yes // UART clock freezes while CPU is in Wait mode.

//--- Enumerated values for register C1, field LOOPS
  let UART4_C1_LOOPS_Normal_0 $bool = no // Normal operation.
  let UART4_C1_LOOPS_Loop_1 $bool = yes // Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.

//--- Enumerated values for register C2, field SBK
  let UART4_C2_SBK_Normal_0 $bool = no // Normal transmitter operation.
  let UART4_C2_SBK_Queue_1 $bool = yes // Queue break characters to be sent.

//--- Enumerated values for register C2, field RWU
  let UART4_C2_RWU_Normal_0 $bool = no // Normal operation.
  let UART4_C2_RWU_RWU_1 $bool = yes // RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.

//--- Enumerated values for register C2, field RE
  let UART4_C2_RE_Receiver_0 $bool = no // Receiver off.
  let UART4_C2_RE_Receiver_1 $bool = yes // Receiver on.

//--- Enumerated values for register C2, field TE
  let UART4_C2_TE_Transmitter_0 $bool = no // Transmitter off.
  let UART4_C2_TE_Transmitter_1 $bool = yes // Transmitter on.

//--- Enumerated values for register C2, field ILIE
  let UART4_C2_ILIE_IDLE_0 $bool = no // IDLE interrupt requests disabled.
  let UART4_C2_ILIE_IDLE_1 $bool = yes // IDLE interrupt requests enabled.

//--- Enumerated values for register C2, field RIE
  let UART4_C2_RIE_RDRF_0 $bool = no // RDRF interrupt and DMA transfer requests disabled.
  let UART4_C2_RIE_RDRF_1 $bool = yes // RDRF interrupt or DMA transfer requests enabled.

//--- Enumerated values for register C2, field TCIE
  let UART4_C2_TCIE_TC_0 $bool = no // TC interrupt requests disabled.
  let UART4_C2_TCIE_TC_1 $bool = yes // TC interrupt requests enabled.

//--- Enumerated values for register C2, field TIE
  let UART4_C2_TIE_TDRE_0 $bool = no // TDRE interrupt and DMA transfer requests disabled.
  let UART4_C2_TIE_TDRE_1 $bool = yes // TDRE interrupt or DMA transfer requests enabled.

//--- Enumerated values for register S1, field PF
  let UART4_S1_PF_No_0 $bool = no // No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
  let UART4_S1_PF_At_1 $bool = yes // At least one dataword was received with a parity error since the last time this flag was cleared.

//--- Enumerated values for register S1, field FE
  let UART4_S1_FE_No_0 $bool = no // No framing error detected.
  let UART4_S1_FE_Framing_1 $bool = yes // Framing error.

//--- Enumerated values for register S1, field NF
  let UART4_S1_NF_No_0 $bool = no // No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
  let UART4_S1_NF_At_1 $bool = yes // At least one dataword was received with noise detected since the last time the flag was cleared.

//--- Enumerated values for register S1, field OR
  let UART4_S1_OR_No_0 $bool = no // No overrun has occurred since the last time the flag was cleared.
  let UART4_S1_OR_Overrun_1 $bool = yes // Overrun has occurred or the overrun flag has not been cleared since the last overrun occured.

//--- Enumerated values for register S1, field IDLE
  let UART4_S1_IDLE_Receiver_0 $bool = no // Receiver input is either active now or has never become active since the IDLE flag was last cleared.
  let UART4_S1_IDLE_Receiver_1 $bool = yes // Receiver input has become idle or the flag has not been cleared since it last asserted.

//--- Enumerated values for register S1, field RDRF
  let UART4_S1_RDRF_The_0 $bool = no // The number of datawords in the receive buffer is less than the number indicated by RXWATER.
  let UART4_S1_RDRF_The_1 $bool = yes // The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.

//--- Enumerated values for register S1, field TC
  let UART4_S1_TC_Transmitter_0 $bool = no // Transmitter active (sending data, a preamble, or a break).
  let UART4_S1_TC_Transmitter_1 $bool = yes // Transmitter idle (transmission activity complete).

//--- Enumerated values for register S1, field TDRE
  let UART4_S1_TDRE_The_0 $bool = no // The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
  let UART4_S1_TDRE_The_1 $bool = yes // The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.

//--- Enumerated values for register S2, field RAF
  let UART4_S2_RAF_UART_0 $bool = no // UART receiver idle/inactive waiting for a start bit.
  let UART4_S2_RAF_UART_1 $bool = yes // UART receiver active, RxD input not idle.

//--- Enumerated values for register S2, field LBKDE
  let UART4_S2_LBKDE_Break_0 $bool = no // Break character detection is disabled.
  let UART4_S2_LBKDE_Break_1 $bool = yes // Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.

//--- Enumerated values for register S2, field BRK13
  let UART4_S2_BRK13_Break_0 $bool = no // Break character is 10, 11, or 12 bits long.
  let UART4_S2_BRK13_Break_1 $bool = yes // Break character is 13 or 14 bits long.

//--- Enumerated values for register S2, field RWUID
  let UART4_S2_RWUID_S1_IDLE__0 $bool = no // S1[IDLE] is not set upon detection of an idle character.
  let UART4_S2_RWUID_S1_IDLE__1 $bool = yes // S1[IDLE] is set upon detection of an idle character.

//--- Enumerated values for register S2, field RXINV
  let UART4_S2_RXINV_Receive_0 $bool = no // Receive data is not inverted.
  let UART4_S2_RXINV_Receive_1 $bool = yes // Receive data is inverted.

//--- Enumerated values for register S2, field MSBF
  let UART4_S2_MSBF_LSB_0 $bool = no // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
  let UART4_S2_MSBF_MSB_1 $bool = yes // MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].

//--- Enumerated values for register S2, field RXEDGIF
  let UART4_S2_RXEDGIF_No_0 $bool = no // No active edge on the receive pin has occurred.
  let UART4_S2_RXEDGIF_An_1 $bool = yes // An active edge on the receive pin has occurred.

//--- Enumerated values for register S2, field LBKDIF
  let UART4_S2_LBKDIF_No_0 $bool = no // No LIN break character detected.
  let UART4_S2_LBKDIF_LIN_1 $bool = yes // LIN break character detected.

//--- Enumerated values for register C3, field PEIE
  let UART4_C3_PEIE_PF_0 $bool = no // PF interrupt requests are disabled.
  let UART4_C3_PEIE_PF_1 $bool = yes // PF interrupt requests are enabled.

//--- Enumerated values for register C3, field FEIE
  let UART4_C3_FEIE_FE_0 $bool = no // FE interrupt requests are disabled.
  let UART4_C3_FEIE_FE_1 $bool = yes // FE interrupt requests are enabled.

//--- Enumerated values for register C3, field NEIE
  let UART4_C3_NEIE_NF_0 $bool = no // NF interrupt requests are disabled.
  let UART4_C3_NEIE_NF_1 $bool = yes // NF interrupt requests are enabled.

//--- Enumerated values for register C3, field ORIE
  let UART4_C3_ORIE_OR_0 $bool = no // OR interrupts are disabled.
  let UART4_C3_ORIE_OR_1 $bool = yes // OR interrupt requests are enabled.

//--- Enumerated values for register C3, field TXINV
  let UART4_C3_TXINV_Transmit_0 $bool = no // Transmit data is not inverted.
  let UART4_C3_TXINV_Transmit_1 $bool = yes // Transmit data is inverted.

//--- Enumerated values for register C3, field TXDIR
  let UART4_C3_TXDIR_TXD_0 $bool = no // TXD pin is an input in single wire mode.
  let UART4_C3_TXDIR_TXD_1 $bool = yes // TXD pin is an output in single wire mode.

//--- Enumerated values for register C4, field M10
  let UART4_C4_M10_The_0 $bool = no // The parity bit is the ninth bit in the serial transmission.
  let UART4_C4_M10_The_1 $bool = yes // The parity bit is the tenth bit in the serial transmission.

//--- Enumerated values for register C4, field MAEN2
  let UART4_C4_MAEN2_All_0 $bool = no // All data received is transferred to the data buffer if MAEN1 is cleared.
  let UART4_C4_MAEN2_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C4, field MAEN1
  let UART4_C4_MAEN1_All_0 $bool = no // All data received is transferred to the data buffer if MAEN2 is cleared.
  let UART4_C4_MAEN1_All_1 $bool = yes // All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.

//--- Enumerated values for register C5, field RDMAS
  let UART4_C5_RDMAS_If_0 $bool = no // If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
  let UART4_C5_RDMAS_If_1 $bool = yes // If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register C5, field TDMAS
  let UART4_C5_TDMAS_If_0 $bool = no // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
  let UART4_C5_TDMAS_If_1 $bool = yes // If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.

//--- Enumerated values for register ED, field PARITYE
  let UART4_ED_PARITYE_The_0 $bool = no // The dataword was received without a parity error.
  let UART4_ED_PARITYE_The_1 $bool = yes // The dataword was received with a parity error.

//--- Enumerated values for register ED, field NOISY
  let UART4_ED_NOISY_The_0 $bool = no // The dataword was received without noise.
  let UART4_ED_NOISY_The_1 $bool = yes // The data was received with noise.

//--- Enumerated values for register MODEM, field TXCTSE
  let UART4_MODEM_TXCTSE_CTS_0 $bool = no // CTS has no effect on the transmitter.
  let UART4_MODEM_TXCTSE_Enables_1 $bool = yes // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.

//--- Enumerated values for register MODEM, field TXRTSE
  let UART4_MODEM_TXRTSE_The_0 $bool = no // The transmitter has no effect on RTS.
  let UART4_MODEM_TXRTSE_When_1 $bool = yes // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)

//--- Enumerated values for register MODEM, field TXRTSPOL
  let UART4_MODEM_TXRTSPOL_Transmitter_0 $bool = no // Transmitter RTS is active low.
  let UART4_MODEM_TXRTSPOL_Transmitter_1 $bool = yes // Transmitter RTS is active high.

//--- Enumerated values for register MODEM, field RXRTSE
  let UART4_MODEM_RXRTSE_The_0 $bool = no // The receiver has no effect on RTS.
  let UART4_MODEM_RXRTSE_RTS_1 $bool = yes // RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]. See Hardware flow control

//--- Enumerated values for register IR, field TNP
  let UART4_IR_TNP_3_16__00 $u2 = 0 // 3/16.
  let UART4_IR_TNP_1_16__01 $u2 = 1 // 1/16.
  let UART4_IR_TNP_1_32__10 $u2 = 2 // 1/32.
  let UART4_IR_TNP_1_4__11 $u2 = 3 // 1/4.

//--- Enumerated values for register IR, field IREN
  let UART4_IR_IREN_IR_0 $bool = no // IR disabled.
  let UART4_IR_IREN_IR_1 $bool = yes // IR enabled.

//--- Enumerated values for register PFIFO, field RXFIFOSIZE
  let UART4_PFIFO_RXFIFOSIZE_Receive_000 $u3 = 0 // Receive FIFO/Buffer depth = 1 dataword.
  let UART4_PFIFO_RXFIFOSIZE_Receive_001 $u3 = 1 // Receive FIFO/Buffer depth = 4 datawords.
  let UART4_PFIFO_RXFIFOSIZE_Receive_010 $u3 = 2 // Receive FIFO/Buffer depth = 8 datawords.
  let UART4_PFIFO_RXFIFOSIZE_Receive_011 $u3 = 3 // Receive FIFO/Buffer depth = 16 datawords.
  let UART4_PFIFO_RXFIFOSIZE_Receive_100 $u3 = 4 // Receive FIFO/Buffer depth = 32 datawords.
  let UART4_PFIFO_RXFIFOSIZE_Receive_101 $u3 = 5 // Receive FIFO/Buffer depth = 64 datawords.
  let UART4_PFIFO_RXFIFOSIZE_Receive_110 $u3 = 6 // Receive FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field RXFE
  let UART4_PFIFO_RXFE_Receive_0 $bool = no // Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
  let UART4_PFIFO_RXFE_Receive_1 $bool = yes // Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.

//--- Enumerated values for register PFIFO, field TXFIFOSIZE
  let UART4_PFIFO_TXFIFOSIZE_Transmit_000 $u3 = 0 // Transmit FIFO/Buffer depth = 1 dataword.
  let UART4_PFIFO_TXFIFOSIZE_Transmit_001 $u3 = 1 // Transmit FIFO/Buffer depth = 4 datawords.
  let UART4_PFIFO_TXFIFOSIZE_Transmit_010 $u3 = 2 // Transmit FIFO/Buffer depth = 8 datawords.
  let UART4_PFIFO_TXFIFOSIZE_Transmit_011 $u3 = 3 // Transmit FIFO/Buffer depth = 16 datawords.
  let UART4_PFIFO_TXFIFOSIZE_Transmit_100 $u3 = 4 // Transmit FIFO/Buffer depth = 32 datawords.
  let UART4_PFIFO_TXFIFOSIZE_Transmit_101 $u3 = 5 // Transmit FIFO/Buffer depth = 64 datawords.
  let UART4_PFIFO_TXFIFOSIZE_Transmit_110 $u3 = 6 // Transmit FIFO/Buffer depth = 128 datawords.

//--- Enumerated values for register PFIFO, field TXFE
  let UART4_PFIFO_TXFE_Transmit_0 $bool = no // Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
  let UART4_PFIFO_TXFE_Transmit_1 $bool = yes // Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.

//--- Enumerated values for register CFIFO, field RXUFE
  let UART4_CFIFO_RXUFE_RXUF_0 $bool = no // RXUF flag does not generate an interrupt to the host.
  let UART4_CFIFO_RXUFE_RXUF_1 $bool = yes // RXUF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field TXOFE
  let UART4_CFIFO_TXOFE_TXOF_0 $bool = no // TXOF flag does not generate an interrupt to the host.
  let UART4_CFIFO_TXOFE_TXOF_1 $bool = yes // TXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXOFE
  let UART4_CFIFO_RXOFE_RXOF_0 $bool = no // RXOF flag does not generate an interrupt to the host.
  let UART4_CFIFO_RXOFE_RXOF_1 $bool = yes // RXOF flag generates an interrupt to the host.

//--- Enumerated values for register CFIFO, field RXFLUSH
  let UART4_CFIFO_RXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART4_CFIFO_RXFLUSH_All_1 $bool = yes // All data in the receive FIFO/buffer is cleared out.

//--- Enumerated values for register CFIFO, field TXFLUSH
  let UART4_CFIFO_TXFLUSH_No_0 $bool = no // No flush operation occurs.
  let UART4_CFIFO_TXFLUSH_All_1 $bool = yes // All data in the transmit FIFO/Buffer is cleared out.

//--- Enumerated values for register SFIFO, field RXUF
  let UART4_SFIFO_RXUF_No_0 $bool = no // No receive buffer underflow has occurred since the last time the flag was cleared.
  let UART4_SFIFO_RXUF_At_1 $bool = yes // At least one receive buffer underflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field TXOF
  let UART4_SFIFO_TXOF_No_0 $bool = no // No transmit buffer overflow has occurred since the last time the flag was cleared.
  let UART4_SFIFO_TXOF_At_1 $bool = yes // At least one transmit buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXOF
  let UART4_SFIFO_RXOF_No_0 $bool = no // No receive buffer overflow has occurred since the last time the flag was cleared.
  let UART4_SFIFO_RXOF_At_1 $bool = yes // At least one receive buffer overflow has occurred since the last time the flag was cleared.

//--- Enumerated values for register SFIFO, field RXEMPT
  let UART4_SFIFO_RXEMPT_Receive_0 $bool = no // Receive buffer is not empty.
  let UART4_SFIFO_RXEMPT_Receive_1 $bool = yes // Receive buffer is empty.

//--- Enumerated values for register SFIFO, field TXEMPT
  let UART4_SFIFO_TXEMPT_Transmit_0 $bool = no // Transmit buffer is not empty.
  let UART4_SFIFO_TXEMPT_Transmit_1 $bool = yes // Transmit buffer is empty.

//--- Enumerated values for register C7816, field ISO_7816E
  let UART4_C7816_ISO_7816E_ISO_7816_0 $bool = no // ISO-7816 functionality is turned off/not enabled.
  let UART4_C7816_ISO_7816E_ISO_7816_1 $bool = yes // ISO-7816 functionality is turned on/enabled.

//--- Enumerated values for register C7816, field TTYPE
  let UART4_C7816_TTYPE_T_0 $bool = no // T = 0 per the ISO-7816 specification.
  let UART4_C7816_TTYPE_T_1 $bool = yes // T = 1 per the ISO-7816 specification.

//--- Enumerated values for register C7816, field INIT
  let UART4_C7816_INIT_Normal_0 $bool = no // Normal operating mode. Receiver does not seek to identify initial character.
  let UART4_C7816_INIT_Receiver_1 $bool = yes // Receiver searches for initial character.

//--- Enumerated values for register C7816, field ANACK
  let UART4_C7816_ANACK_No_0 $bool = no // No NACK is automatically generated.
  let UART4_C7816_ANACK_A_1 $bool = yes // A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.

//--- Enumerated values for register C7816, field ONACK
  let UART4_C7816_ONACK_The_0 $bool = no // The received data does not generate a NACK when the receipt of the data results in an overflow event.
  let UART4_C7816_ONACK_If_1 $bool = yes // If the receiver buffer overflows, a NACK is automatically sent on a received character.

//--- Enumerated values for register IE7816, field RXTE
  let UART4_IE7816_RXTE_The_0 $bool = no // The assertion of IS7816[RXT] does not result in the generation of an interrupt.
  let UART4_IE7816_RXTE_The_1 $bool = yes // The assertion of IS7816[RXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field TXTE
  let UART4_IE7816_TXTE_The_0 $bool = no // The assertion of IS7816[TXT] does not result in the generation of an interrupt.
  let UART4_IE7816_TXTE_The_1 $bool = yes // The assertion of IS7816[TXT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field GTVE
  let UART4_IE7816_GTVE_The_0 $bool = no // The assertion of IS7816[GTV] does not result in the generation of an interrupt.
  let UART4_IE7816_GTVE_The_1 $bool = yes // The assertion of IS7816[GTV] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field ADTE
  let UART4_IE7816_ADTE_The_0 $bool = no // The assertion of IS7816[ADT] does not result in the generation of an interrupt.
  let UART4_IE7816_ADTE_The_1 $bool = yes // The assertion of IS7816[ADT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field INITDE
  let UART4_IE7816_INITDE_The_0 $bool = no // The assertion of IS7816[INITD] does not result in the generation of an interrupt.
  let UART4_IE7816_INITDE_The_1 $bool = yes // The assertion of IS7816[INITD] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field BWTE
  let UART4_IE7816_BWTE_The_0 $bool = no // The assertion of IS7816[BWT] does not result in the generation of an interrupt.
  let UART4_IE7816_BWTE_The_1 $bool = yes // The assertion of IS7816[BWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field CWTE
  let UART4_IE7816_CWTE_The_0 $bool = no // The assertion of IS7816[CWT] does not result in the generation of an interrupt.
  let UART4_IE7816_CWTE_The_1 $bool = yes // The assertion of IS7816[CWT] results in the generation of an interrupt.

//--- Enumerated values for register IE7816, field WTE
  let UART4_IE7816_WTE_The_0 $bool = no // The assertion of IS7816[WT] does not result in the generation of an interrupt.
  let UART4_IE7816_WTE_The_1 $bool = yes // The assertion of IS7816[WT] results in the generation of an interrupt.

//--- Enumerated values for register IS7816, field RXT
  let UART4_IS7816_RXT_The_0 $bool = no // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
  let UART4_IS7816_RXT_The_1 $bool = yes // The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].

//--- Enumerated values for register IS7816, field TXT
  let UART4_IS7816_TXT_The_0 $bool = no // The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
  let UART4_IS7816_TXT_The_1 $bool = yes // The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].

//--- Enumerated values for register IS7816, field GTV
  let UART4_IS7816_GTV_A_0 $bool = no // A guard time (GT, CGT, or BGT) has not been violated.
  let UART4_IS7816_GTV_A_1 $bool = yes // A guard time (GT, CGT, or BGT) has been violated.

//--- Enumerated values for register IS7816, field ADT
  let UART4_IS7816_ADT_ATR_0 $bool = no // ATR Duration time (ADT) has not been violated.
  let UART4_IS7816_ADT_ATR_1 $bool = yes // ATR Duration time (ADT) has been violated.

//--- Enumerated values for register IS7816, field INITD
  let UART4_IS7816_INITD_A_0 $bool = no // A valid initial character has not been received.
  let UART4_IS7816_INITD_A_1 $bool = yes // A valid initial character has been received.

//--- Enumerated values for register IS7816, field BWT
  let UART4_IS7816_BWT_Block_0 $bool = no // Block wait time (BWT) has not been violated.
  let UART4_IS7816_BWT_Block_1 $bool = yes // Block wait time (BWT) has been violated.

//--- Enumerated values for register IS7816, field CWT
  let UART4_IS7816_CWT_Character_0 $bool = no // Character wait time (CWT) has not been violated.
  let UART4_IS7816_CWT_Character_1 $bool = yes // Character wait time (CWT) has been violated.

//--- Enumerated values for register IS7816, field WT
  let UART4_IS7816_WT_Wait_0 $bool = no // Wait time (WT) has not been violated.
  let UART4_IS7816_WT_Wait_1 $bool = yes // Wait time (WT) has been violated.

//--- Enumerated values for register ET7816, field TXTHRESHOLD
  let UART4_ET7816_TXTHRESHOLD_TXT_0 $u4 = 0 // TXT asserts on the first NACK that is received.
  let UART4_ET7816_TXTHRESHOLD_TXT_1 $u4 = 1 // TXT asserts on the second NACK that is received.

//------------------------------------------------------------------------------
// Peripheral USB0: Universal Serial Bus, OTG Capable Controller
//------------------------------------------------------------------------------

registers ©USB0 @at 0x40072000 {
//---  Register PERID: Peripheral ID register
  PERID @offset 0x0 @ro $u8 {
    2
    ID:6 // at 0: Peripheral Identification
  }

//---  Register IDCOMP: Peripheral ID Complement register
  IDCOMP @offset 0x4 @ro $u8 {
    2
    NID:6 // at 0: Ones' complement of PERID[ID]. bits.
  }

//---  Register REV: Peripheral Revision register
  REV @offset 0x8 @ro $u8 {
    REV:8 // at 0: Revision
  }

//---  Register ADDINFO: Peripheral Additional Info register
  ADDINFO @offset 0xc @ro $u8 {
    7
    IEHOST // at 0: This bit is set if host mode is enabled.
  }

//---  Register OTGISTAT: OTG Interrupt Status register
  OTGISTAT @offset 0x10 $u8 {
    IDCHG // at 7: This bit is set when a change in the ID Signal from the USB connector is sensed.
    ONEMSEC // at 6: This bit is set when the 1 millisecond timer expires
    LINE_STATE_CHG // at 5: This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits) are stable without change for 1 millisecond, and the value of the line state is different from the last time when the line state was stable
    1
    SESSVLDCHG // at 3: This bit is set when a change in VBUS is detected indicating a session valid or a session no longer valid
    B_SESS_CHG // at 2: This bit is set when a change in VBUS is detected on a B device.
    1
    AVBUSCHG // at 0: This bit is set when a change in VBUS is detected on an A device.
  }

//---  Register OTGICR: OTG Interrupt Control register
  OTGICR @offset 0x14 $u8 {
    IDEN // at 7: ID Interrupt Enable
    ONEMSECEN // at 6: One Millisecond Interrupt Enable
    LINESTATEEN // at 5: Line State Change Interrupt Enable
    1
    SESSVLDEN // at 3: Session Valid Interrupt Enable
    BSESSEN // at 2: B Session END Interrupt Enable
    1
    AVBUSEN // at 0: A VBUS Valid Interrupt Enable
  }

//---  Register OTGSTAT: OTG Status register
  OTGSTAT @offset 0x18 $u8 {
    ID // at 7: Indicates the current state of the ID pin on the USB connector
    ONEMSECEN // at 6: This bit is reserved for the 1ms count, but it is not useful to software.
    LINESTATESTABLE // at 5: Indicates that the internal signals that control the LINE_STATE_CHG field of OTGISTAT are stable for at least 1 ms
    1
    SESS_VLD // at 3: Session Valid
    BSESSEND // at 2: B Session End
    1
    AVBUSVLD // at 0: A VBUS Valid
  }

//---  Register OTGCTL: OTG Control register
  OTGCTL @offset 0x1c $u8 {
    DPHIGH // at 7: D+ Data Line pullup resistor enable
    1
    DPLOW // at 5: D+ Data Line pull-down resistor enable
    DMLOW // at 4: D- Data Line pull-down resistor enable
    1
    OTGEN // at 2: On-The-Go pullup/pulldown resistor enable
    2
  }

//---  Register ISTAT: Interrupt Status register
  ISTAT @offset 0x80 $u8 {
    STALL // at 7: Stall Interrupt
    ATTACH // at 6: Attach Interrupt
    RESUME // at 5: This bit is set when a K-state is observed on the DP/DM signals for 2
    SLEEP // at 4: This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms
    TOKDNE // at 3: This bit is set when the current token being processed has completed
    SOFTOK // at 2: This bit is set when the USB Module receives a Start Of Frame (SOF) token
    ERROR // at 1: This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur
    USBRST // at 0: This bit is set when the USB Module has decoded a valid USB reset
  }

//---  Register INTEN: Interrupt Enable register
  INTEN @offset 0x84 $u8 {
    STALLEN // at 7: STALL Interrupt Enable
    ATTACHEN // at 6: ATTACH Interrupt Enable
    RESUMEEN // at 5: RESUME Interrupt Enable
    SLEEPEN // at 4: SLEEP Interrupt Enable
    TOKDNEEN // at 3: TOKDNE Interrupt Enable
    SOFTOKEN // at 2: SOFTOK Interrupt Enable
    ERROREN // at 1: ERROR Interrupt Enable
    USBRSTEN // at 0: USBRST Interrupt Enable
  }

//---  Register ERRSTAT: Error Interrupt Status register
  ERRSTAT @offset 0x88 $u8 {
    BTSERR // at 7: This bit is set when a bit stuff error is detected
    1
    DMAERR // at 5: This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data
    BTOERR // at 4: This bit is set when a bus turnaround timeout error occurs
    DFN8 // at 3: This bit is set if the data field received was not 8 bits in length
    CRC16 // at 2: This bit is set when a data packet is rejected due to a CRC16 error.
    CRC5EOF // at 1: This error interrupt has two functions
    PIDERR // at 0: This bit is set when the PID check field fails.
  }

//---  Register ERREN: Error Interrupt Enable register
  ERREN @offset 0x8c $u8 {
    BTSERREN // at 7: BTSERR Interrupt Enable
    1
    DMAERREN // at 5: DMAERR Interrupt Enable
    BTOERREN // at 4: BTOERR Interrupt Enable
    DFN8EN // at 3: DFN8 Interrupt Enable
    CRC16EN // at 2: CRC16 Interrupt Enable
    CRC5EOFEN // at 1: CRC5/EOF Interrupt Enable
    PIDERREN // at 0: PIDERR Interrupt Enable
  }

//---  Register STAT: Status register
  STAT @offset 0x90 @ro $u8 {
    ENDP:4 // at 4: This four-bit field encodes the endpoint address that received or transmitted the previous token
    TX // at 3: Transmit Indicator
    ODD // at 2: This bit is set if the last buffer descriptor updated was in the odd bank of the BDT.
    2
  }

//---  Register CTL: Control register
  CTL @offset 0x94 $u8 {
    JSTATE // at 7: Live USB differential receiver JSTATE signal
    SE0 // at 6: Live USB Single Ended Zero signal
    TXSUSPENDTOKENBUSY // at 5: In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token
    RESET // at 4: Setting this bit enables the USB Module to generate USB reset signaling
    HOSTMODEEN // at 3: When set to 1, this bit enables the USB Module to operate in Host mode
    RESUME // at 2: When set to 1 this bit enables the USB Module to execute resume signaling
    ODDRST // at 1: Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank
    USBENSOFEN // at 0: USB Enable
  }

//---  Register ADDR: Address register
  ADDR @offset 0x98 $u8 {
    LSEN // at 7: Low Speed Enable bit
    ADDR:7 // at 0: USB Address
  }

//---  Register BDTPAGE1: BDT Page register 1
  BDTPAGE1 @offset 0x9c $u8 {
    BDTBA:7 // at 1: Provides address bits 15 through 9 of the BDT base address.
    1
  }

//---  Register FRMNUML: Frame Number register Low
  FRMNUML @offset 0xa0 $u8 {
    FRM:8 // at 0: This 8-bit field and the 3-bit field in the Frame Number Register High are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
  }

//---  Register FRMNUMH: Frame Number register High
  FRMNUMH @offset 0xa4 $u8 {
    5
    FRM:3 // at 0: This 3-bit field and the 8-bit field in the Frame Number Register Low are used to compute the address where the current Buffer Descriptor Table (BDT) resides in system memory
  }

//---  Register TOKEN: Token register
  TOKEN @offset 0xa8 $u8 {
    TOKENPID:4 // at 4: Contains the token type executed by the USB module.
    TOKENENDPT:4 // at 0: Holds the Endpoint address for the token command
  }

//---  Register SOFTHLD: SOF Threshold register
  SOFTHLD @offset 0xac $u8 {
    CNT:8 // at 0: Represents the SOF count threshold in byte times.
  }

//---  Register BDTPAGE2: BDT Page Register 2
  BDTPAGE2 @offset 0xb0 $u8 {
    BDTBA:8 // at 0: Provides address bits 23 through 16 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
  }

//---  Register BDTPAGE3: BDT Page Register 3
  BDTPAGE3 @offset 0xb4 $u8 {
    BDTBA:8 // at 0: Provides address bits 31 through 24 of the BDT base address that defines the location of Buffer Descriptor Table resides in system memory
  }

//---  Registers ENDPT(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15): Endpoint Control register
  ENDPT [16 @offset 0xc0 @inc 0x4]
  ENDPT0 @offset 0xc0
  ENDPT1 @offset 0xc4
  ENDPT2 @offset 0xc8
  ENDPT3 @offset 0xcc
  ENDPT4 @offset 0xd0
  ENDPT5 @offset 0xd4
  ENDPT6 @offset 0xd8
  ENDPT7 @offset 0xdc
  ENDPT8 @offset 0xe0
  ENDPT9 @offset 0xe4
  ENDPT10 @offset 0xe8
  ENDPT11 @offset 0xec
  ENDPT12 @offset 0xf0
  ENDPT13 @offset 0xf4
  ENDPT14 @offset 0xf8
  ENDPT15 @offset 0xfc $u8 {
    HOSTWOHUB // at 7: Host without a hub This is a Host mode only field and is present in the control register for endpoint 0 (ENDPT0) only
    RETRYDIS // at 6: This is a Host mode only bit and is present in the control register for endpoint 0 (ENDPT0) only
    1
    EPCTLDIS // at 4: This bit, when set, disables control (SETUP) transfers
    EPRXEN // at 3: This bit, when set, enables the endpoint for RX transfers. See
    EPTXEN // at 2: This bit, when set, enables the endpoint for TX transfers. See
    EPSTALL // at 1: When set this bit indicates that the endpoint is called
    EPHSHK // at 0: When set this bit enables an endpoint to perform handshaking during a transaction to this endpoint
  }

//---  Register USBCTRL: USB Control register
  USBCTRL @offset 0x100 $u8 {
    SUSP // at 7: Places the USB transceiver into the suspend state.
    PDE // at 6: Enables the weak pulldowns on the USB transceiver.
    6
  }

//---  Register OBSERVE: USB OTG Observe register
  OBSERVE @offset 0x104 @ro $u8 {
    DPPU // at 7: Provides observability of the D+ Pullup enable at the USB transceiver.
    DPPD // at 6: Provides observability of the D+ Pulldown enable at the USB transceiver.
    1
    DMPD // at 4: Provides observability of the D- Pulldown enable at the USB transceiver.
    4
  }

//---  Register CONTROL: USB OTG Control register
  CONTROL @offset 0x108 $u8 {
    3
    DPPULLUPNONOTG // at 4: Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG device mode.
    4
  }

//---  Register USBTRC0: USB Transceiver Control register 0
  USBTRC0 @offset 0x10c $u8 {
    USBRESET // at 7: USB Reset
    1
    USBRESMEN // at 5: Asynchronous Resume Interrupt Enable
    2
    USB_CLK_RECOVERY_INT // at 2: Combined USB Clock Recovery interrupt status
    SYNC_DET // at 1: Synchronous USB Interrupt Detect
    USB_RESUME_INT // at 0: USB Asynchronous Interrupt
  }

//---  Register USBFRMADJUST: Frame Adjust Register
  USBFRMADJUST @offset 0x114 $u8 {
    ADJ:8 // at 0: Frame Adjustment
  }

//---  Register CLK_RECOVER_CTRL: USB Clock recovery control
  CLK_RECOVER_CTRL @offset 0x140 $u8 {
    CLOCK_RECOVER_EN // at 7: Crystal-less USB enable
    RESET_RESUME_ROUGH_EN // at 6: Reset/resume to rough phase enable
    RESTART_IFRTRIM_EN // at 5: Restart from IFR trim value
    5
  }

//---  Register CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
  CLK_RECOVER_IRC_EN @offset 0x144 $u8 {
    6
    IRC_EN // at 1: IRC48M enable
    REG_EN // at 0: IRC48M regulator enable
  }

//---  Register CLK_RECOVER_INT_EN: Clock recovery combined interrupt enable
  CLK_RECOVER_INT_EN @offset 0x154 $u8 {
    3
    OVF_ERROR_EN // at 4: Determines whether OVF_ERROR condition signal is used in generation of USB_CLK_RECOVERY_INT.
    4
  }

//---  Register CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
  CLK_RECOVER_INT_STATUS @offset 0x15c $u8 {
    3
    OVF_ERROR // at 4: Indicates that the USB clock recovery algorithm has detected that the frequency trim adjustment needed for the IRC48M output clock is outside the available TRIM_FINE adjustment range for the IRC48M module
    4
  }

}

//--- Enumerated values for register OTGICR, field AVBUSEN
  let USB0_OTGICR_AVBUSEN_Disables_0 $bool = no // Disables the AVBUSCHG interrupt.
  let USB0_OTGICR_AVBUSEN_Enables_1 $bool = yes // Enables the AVBUSCHG interrupt.

//--- Enumerated values for register OTGICR, field BSESSEN
  let USB0_OTGICR_BSESSEN_Disables_0 $bool = no // Disables the B_SESS_CHG interrupt.
  let USB0_OTGICR_BSESSEN_Enables_1 $bool = yes // Enables the B_SESS_CHG interrupt.

//--- Enumerated values for register OTGICR, field SESSVLDEN
  let USB0_OTGICR_SESSVLDEN_Disables_0 $bool = no // Disables the SESSVLDCHG interrupt.
  let USB0_OTGICR_SESSVLDEN_Enables_1 $bool = yes // Enables the SESSVLDCHG interrupt.

//--- Enumerated values for register OTGICR, field LINESTATEEN
  let USB0_OTGICR_LINESTATEEN_Disables_0 $bool = no // Disables the LINE_STAT_CHG interrupt.
  let USB0_OTGICR_LINESTATEEN_Enables_1 $bool = yes // Enables the LINE_STAT_CHG interrupt.

//--- Enumerated values for register OTGICR, field ONEMSECEN
  let USB0_OTGICR_ONEMSECEN_Diables_0 $bool = no // Diables the 1ms timer interrupt.
  let USB0_OTGICR_ONEMSECEN_Enables_1 $bool = yes // Enables the 1ms timer interrupt.

//--- Enumerated values for register OTGICR, field IDEN
  let USB0_OTGICR_IDEN_The_0 $bool = no // The ID interrupt is disabled
  let USB0_OTGICR_IDEN_The_1 $bool = yes // The ID interrupt is enabled

//--- Enumerated values for register OTGSTAT, field AVBUSVLD
  let USB0_OTGSTAT_AVBUSVLD_The_0 $bool = no // The VBUS voltage is below the A VBUS Valid threshold.
  let USB0_OTGSTAT_AVBUSVLD_The_1 $bool = yes // The VBUS voltage is above the A VBUS Valid threshold.

//--- Enumerated values for register OTGSTAT, field BSESSEND
  let USB0_OTGSTAT_BSESSEND_The_0 $bool = no // The VBUS voltage is above the B session end threshold.
  let USB0_OTGSTAT_BSESSEND_The_1 $bool = yes // The VBUS voltage is below the B session end threshold.

//--- Enumerated values for register OTGSTAT, field SESS_VLD
  let USB0_OTGSTAT_SESS_VLD_The_0 $bool = no // The VBUS voltage is below the B session valid threshold
  let USB0_OTGSTAT_SESS_VLD_The_1 $bool = yes // The VBUS voltage is above the B session valid threshold.

//--- Enumerated values for register OTGSTAT, field LINESTATESTABLE
  let USB0_OTGSTAT_LINESTATESTABLE_The_0 $bool = no // The LINE_STAT_CHG bit is not yet stable.
  let USB0_OTGSTAT_LINESTATESTABLE_The_1 $bool = yes // The LINE_STAT_CHG bit has been debounced and is stable.

//--- Enumerated values for register OTGSTAT, field ID
  let USB0_OTGSTAT_ID_Indicates_0 $bool = no // Indicates a Type A cable is plugged into the USB connector.
  let USB0_OTGSTAT_ID_Indicates_1 $bool = yes // Indicates no cable is attached or a Type B cable is plugged into the USB connector.

//--- Enumerated values for register OTGCTL, field OTGEN
  let USB0_OTGCTL_OTGEN_If_0 $bool = no // If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+ and D- Data Line pull-down resistors are engaged.
  let USB0_OTGCTL_OTGEN_The_1 $bool = yes // The pull-up and pull-down controls in this register are used.

//--- Enumerated values for register OTGCTL, field DMLOW
  let USB0_OTGCTL_DMLOW_D__0 $bool = no // D- pulldown resistor is not enabled.
  let USB0_OTGCTL_DMLOW_D__1 $bool = yes // D- pulldown resistor is enabled.

//--- Enumerated values for register OTGCTL, field DPLOW
  let USB0_OTGCTL_DPLOW_D__0 $bool = no // D+ pulldown resistor is not enabled.
  let USB0_OTGCTL_DPLOW_D__1 $bool = yes // D+ pulldown resistor is enabled.

//--- Enumerated values for register OTGCTL, field DPHIGH
  let USB0_OTGCTL_DPHIGH_D__0 $bool = no // D+ pullup resistor is not enabled
  let USB0_OTGCTL_DPHIGH_D__1 $bool = yes // D+ pullup resistor is enabled

//--- Enumerated values for register ISTAT, field ATTACH
  let USB0_ISTAT_ATTACH_No_0 $bool = no // No Attach is detected since the last time the ATTACH bit was cleared.
  let USB0_ISTAT_ATTACH_A_1 $bool = yes // A peripheral is now present and must be configured (a stable non-SE0 state is detected for more than 2.5 us).

//--- Enumerated values for register INTEN, field USBRSTEN
  let USB0_INTEN_USBRSTEN_Disables_0 $bool = no // Disables the USBRST interrupt.
  let USB0_INTEN_USBRSTEN_Enables_1 $bool = yes // Enables the USBRST interrupt.

//--- Enumerated values for register INTEN, field ERROREN
  let USB0_INTEN_ERROREN_Disables_0 $bool = no // Disables the ERROR interrupt.
  let USB0_INTEN_ERROREN_Enables_1 $bool = yes // Enables the ERROR interrupt.

//--- Enumerated values for register INTEN, field SOFTOKEN
  let USB0_INTEN_SOFTOKEN_Disbles_0 $bool = no // Disbles the SOFTOK interrupt.
  let USB0_INTEN_SOFTOKEN_Enables_1 $bool = yes // Enables the SOFTOK interrupt.

//--- Enumerated values for register INTEN, field TOKDNEEN
  let USB0_INTEN_TOKDNEEN_Disables_0 $bool = no // Disables the TOKDNE interrupt.
  let USB0_INTEN_TOKDNEEN_Enables_1 $bool = yes // Enables the TOKDNE interrupt.

//--- Enumerated values for register INTEN, field SLEEPEN
  let USB0_INTEN_SLEEPEN_Disables_0 $bool = no // Disables the SLEEP interrupt.
  let USB0_INTEN_SLEEPEN_Enables_1 $bool = yes // Enables the SLEEP interrupt.

//--- Enumerated values for register INTEN, field RESUMEEN
  let USB0_INTEN_RESUMEEN_Disables_0 $bool = no // Disables the RESUME interrupt.
  let USB0_INTEN_RESUMEEN_Enables_1 $bool = yes // Enables the RESUME interrupt.

//--- Enumerated values for register INTEN, field ATTACHEN
  let USB0_INTEN_ATTACHEN_Disables_0 $bool = no // Disables the ATTACH interrupt.
  let USB0_INTEN_ATTACHEN_Enables_1 $bool = yes // Enables the ATTACH interrupt.

//--- Enumerated values for register INTEN, field STALLEN
  let USB0_INTEN_STALLEN_Diasbles_0 $bool = no // Diasbles the STALL interrupt.
  let USB0_INTEN_STALLEN_Enables_1 $bool = yes // Enables the STALL interrupt.

//--- Enumerated values for register ERREN, field PIDERREN
  let USB0_ERREN_PIDERREN_Disables_0 $bool = no // Disables the PIDERR interrupt.
  let USB0_ERREN_PIDERREN_Enters_1 $bool = yes // Enters the PIDERR interrupt.

//--- Enumerated values for register ERREN, field CRC5EOFEN
  let USB0_ERREN_CRC5EOFEN_Disables_0 $bool = no // Disables the CRC5/EOF interrupt.
  let USB0_ERREN_CRC5EOFEN_Enables_1 $bool = yes // Enables the CRC5/EOF interrupt.

//--- Enumerated values for register ERREN, field CRC16EN
  let USB0_ERREN_CRC16EN_Disables_0 $bool = no // Disables the CRC16 interrupt.
  let USB0_ERREN_CRC16EN_Enables_1 $bool = yes // Enables the CRC16 interrupt.

//--- Enumerated values for register ERREN, field DFN8EN
  let USB0_ERREN_DFN8EN_Disables_0 $bool = no // Disables the DFN8 interrupt.
  let USB0_ERREN_DFN8EN_Enables_1 $bool = yes // Enables the DFN8 interrupt.

//--- Enumerated values for register ERREN, field BTOERREN
  let USB0_ERREN_BTOERREN_Disables_0 $bool = no // Disables the BTOERR interrupt.
  let USB0_ERREN_BTOERREN_Enables_1 $bool = yes // Enables the BTOERR interrupt.

//--- Enumerated values for register ERREN, field DMAERREN
  let USB0_ERREN_DMAERREN_Disables_0 $bool = no // Disables the DMAERR interrupt.
  let USB0_ERREN_DMAERREN_Enables_1 $bool = yes // Enables the DMAERR interrupt.

//--- Enumerated values for register ERREN, field BTSERREN
  let USB0_ERREN_BTSERREN_Disables_0 $bool = no // Disables the BTSERR interrupt.
  let USB0_ERREN_BTSERREN_Enables_1 $bool = yes // Enables the BTSERR interrupt.

//--- Enumerated values for register STAT, field TX
  let USB0_STAT_TX_The_0 $bool = no // The most recent transaction was a receive operation.
  let USB0_STAT_TX_The_1 $bool = yes // The most recent transaction was a transmit operation.

//--- Enumerated values for register CTL, field USBENSOFEN
  let USB0_CTL_USBENSOFEN_Disables_0 $bool = no // Disables the USB Module.
  let USB0_CTL_USBENSOFEN_Enables_1 $bool = yes // Enables the USB Module.

//--- Enumerated values for register TOKEN, field TOKENPID
  let USB0_TOKEN_TOKENPID_OUT_0001 $u4 = 1 // OUT Token. USB Module performs an OUT (TX) transaction.
  let USB0_TOKEN_TOKENPID_IN_1001 $u4 = 9 // IN Token. USB Module performs an In (RX) transaction.
  let USB0_TOKEN_TOKENPID_SETUP_1101 $u4 = 13 // SETUP Token. USB Module performs a SETUP (TX) transaction

//--- Enumerated values for register ENDPT%s, field HOSTWOHUB
  let USB0_ENDPT_HOSTWOHUB_Low_speed_0 $bool = no // Low-speed device connected to Host through a hub. PRE_PID will be generated as required.
  let USB0_ENDPT_HOSTWOHUB_Low_speed_1 $bool = yes // Low-speed device directly connected. No hub, or no low-speed device attached.

//--- Enumerated values for register USBCTRL, field PDE
  let USB0_USBCTRL_PDE_Weak_0 $bool = no // Weak pulldowns are disabled on D+ and D-.
  let USB0_USBCTRL_PDE_Weak_1 $bool = yes // Weak pulldowns are enabled on D+ and D-.

//--- Enumerated values for register USBCTRL, field SUSP
  let USB0_USBCTRL_SUSP_USB_0 $bool = no // USB transceiver is not in suspend state.
  let USB0_USBCTRL_SUSP_USB_1 $bool = yes // USB transceiver is in suspend state.

//--- Enumerated values for register OBSERVE, field DMPD
  let USB0_OBSERVE_DMPD_D__0 $bool = no // D- pulldown disabled.
  let USB0_OBSERVE_DMPD_D__1 $bool = yes // D- pulldown enabled.

//--- Enumerated values for register OBSERVE, field DPPD
  let USB0_OBSERVE_DPPD_D__0 $bool = no // D+ pulldown disabled.
  let USB0_OBSERVE_DPPD_D__1 $bool = yes // D+ pulldown enabled.

//--- Enumerated values for register OBSERVE, field DPPU
  let USB0_OBSERVE_DPPU_D__0 $bool = no // D+ pullup disabled.
  let USB0_OBSERVE_DPPU_D__1 $bool = yes // D+ pullup enabled.

//--- Enumerated values for register CONTROL, field DPPULLUPNONOTG
  let USB0_CONTROL_DPPULLUPNONOTG_DP_0 $bool = no // DP Pullup in non-OTG device mode is not enabled.
  let USB0_CONTROL_DPPULLUPNONOTG_DP_1 $bool = yes // DP Pullup in non-OTG device mode is enabled.

//--- Enumerated values for register USBTRC0, field USB_RESUME_INT
  let USB0_USBTRC0_USB_RESUME_INT_No_0 $bool = no // No interrupt was generated.
  let USB0_USBTRC0_USB_RESUME_INT_Interrupt_1 $bool = yes // Interrupt was generated because of the USB asynchronous interrupt.

//--- Enumerated values for register USBTRC0, field SYNC_DET
  let USB0_USBTRC0_SYNC_DET_Synchronous_0 $bool = no // Synchronous interrupt has not been detected.
  let USB0_USBTRC0_SYNC_DET_Synchronous_1 $bool = yes // Synchronous interrupt has been detected.

//--- Enumerated values for register USBTRC0, field USBRESMEN
  let USB0_USBTRC0_USBRESMEN_USB_0 $bool = no // USB asynchronous wakeup from suspend mode disabled.
  let USB0_USBTRC0_USBRESMEN_USB_1 $bool = yes // USB asynchronous wakeup from suspend mode enabled. The asynchronous resume interrupt differs from the synchronous resume interrupt in that it asynchronously detects K-state using the unfiltered state of the D+ and D- pins. This interrupt should only be enabled when the Transceiver is suspended.

//--- Enumerated values for register USBTRC0, field USBRESET
  let USB0_USBTRC0_USBRESET_Normal_0 $bool = no // Normal USB module operation.
  let USB0_USBTRC0_USBRESET_Returns_1 $bool = yes // Returns the USB module to its reset state.

//--- Enumerated values for register CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN
  let USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_Trim_0 $bool = no // Trim fine adjustment always works based on the previous updated trim fine value (default)
  let USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_Trim_1 $bool = yes // Trim fine restarts from the IFR trim value whenever bus_reset/bus_resume is detected or module enable is desasserted

//--- Enumerated values for register CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN
  let USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_Always_0 $bool = no // Always works in tracking phase after the 1st time rough to track transition (default)
  let USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_Go_1 $bool = yes // Go back to rough stage whenever bus reset or bus resume occurs

//--- Enumerated values for register CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN
  let USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_Disable_0 $bool = no // Disable clock recovery block (default)
  let USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_Enable_1 $bool = yes // Enable clock recovery block

//--- Enumerated values for register CLK_RECOVER_IRC_EN, field REG_EN
  let USB0_CLK_RECOVER_IRC_EN_REG_EN_IRC48M_0 $bool = no // IRC48M local regulator is disabled
  let USB0_CLK_RECOVER_IRC_EN_REG_EN_IRC48M_1 $bool = yes // IRC48M local regulator is enabled (default)

//--- Enumerated values for register CLK_RECOVER_IRC_EN, field IRC_EN
  let USB0_CLK_RECOVER_IRC_EN_IRC_EN_Disable_0 $bool = no // Disable the IRC48M module (default)
  let USB0_CLK_RECOVER_IRC_EN_IRC_EN_Enable_1 $bool = yes // Enable the IRC48M module

//--- Enumerated values for register CLK_RECOVER_INT_EN, field OVF_ERROR_EN
  let USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN_The_0 $bool = no // The interrupt will be masked
  let USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN_The_1 $bool = yes // The interrupt will be enabled (default)

//--- Enumerated values for register CLK_RECOVER_INT_STATUS, field OVF_ERROR
  let USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_No_0 $bool = no // No interrupt is reported
  let USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_Unmasked_1 $bool = yes // Unmasked interrupt has been generated

//------------------------------------------------------------------------------
// Peripheral USBDCD: USB Device Charger Detection module
//------------------------------------------------------------------------------

registers ©USBDCD @at 0x40035000 {
//---  Register CONTROL: Control register
  CONTROL @offset 0x0 $u32 {
    6
    SR // at 25: Software Reset
    START // at 24: Start Change Detection Sequence
    6
    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.
    IE // at 16: Interrupt Enable
    7
    IF // at 8: Interrupt Flag
    7
    IACK // at 0: Interrupt Acknowledge
  }

//---  Register CLOCK: Clock register
  CLOCK @offset 0x4 $u32 {
    20
    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary
    1
    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed
  }

//---  Register STATUS: Status register
  STATUS @offset 0x8 @ro $u32 {
    9
    ACTIVE // at 22: Active Status Indicator
    TO // at 21: Timeout Flag
    ERR // at 20: Error Flag
    SEQ_STAT:2 // at 18: Charger Detection Sequence Status
    SEQ_RES:2 // at 16: Charger Detection Sequence Results
    16
  }

//---  Register SIGNAL_OVERRIDE: Signal Override Register
  SIGNAL_OVERRIDE @offset 0xc $u32 {
    30
    PS:2 // at 0: Phase Selection
  }

//---  Register TIMER0: TIMER0 register
  TIMER0 @offset 0x10 $u32 {
    6
    TSEQ_INIT:10 // at 16: Sequence Initiation Time
    4
    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)
  }

//---  Register TIMER1: TIMER1 register
  TIMER1 @offset 0x14 $u32 {
    6
    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal
    6
    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled
  }

//---  Register TIMER2_BC11: TIMER2_BC11 register
  TIMER2_BC11 @offset 0x18 $u32 {
    6
    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup
    12
    CHECK_DM:4 // at 0: Time Before Check of D- Line
  }

//---  Register TIMER2_BC12: TIMER2_BC12 register
  TIMER2_BC12 @offset 0x18 $u32 {
    6
    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    6
    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
  }

}

//--- Enumerated values for register CONTROL, field IACK
  let USBDCD_CONTROL_IACK_Do_0 $bool = no // Do not clear the interrupt.
  let USBDCD_CONTROL_IACK_Clear_1 $bool = yes // Clear the IF bit (interrupt flag).

//--- Enumerated values for register CONTROL, field IF
  let USBDCD_CONTROL_IF_No_0 $bool = no // No interrupt is pending.
  let USBDCD_CONTROL_IF_An_1 $bool = yes // An interrupt is pending.

//--- Enumerated values for register CONTROL, field IE
  let USBDCD_CONTROL_IE_Disable_0 $bool = no // Disable interrupts to the system.
  let USBDCD_CONTROL_IE_Enable_1 $bool = yes // Enable interrupts to the system.

//--- Enumerated values for register CONTROL, field BC12
  let USBDCD_CONTROL_BC12_Compatible_0 $bool = no // Compatible with BC1.1 (default)
  let USBDCD_CONTROL_BC12_Compatible_1 $bool = yes // Compatible with BC1.2

//--- Enumerated values for register CONTROL, field START
  let USBDCD_CONTROL_START_Do_0 $bool = no // Do not start the sequence. Writes of this value have no effect.
  let USBDCD_CONTROL_START_Initiate_1 $bool = yes // Initiate the charger detection sequence. If the sequence is already running, writes of this value have no effect.

//--- Enumerated values for register CONTROL, field SR
  let USBDCD_CONTROL_SR_Do_0 $bool = no // Do not perform a software reset.
  let USBDCD_CONTROL_SR_Perform_1 $bool = yes // Perform a software reset.

//--- Enumerated values for register CLOCK, field CLOCK_UNIT
  let USBDCD_CLOCK_CLOCK_UNIT_kHz_0 $bool = no // kHz Speed (between 1 kHz and 1023 kHz)
  let USBDCD_CLOCK_CLOCK_UNIT_MHz_1 $bool = yes // MHz Speed (between 1 MHz and 1023 MHz)

//--- Enumerated values for register STATUS, field SEQ_RES
  let USBDCD_STATUS_SEQ_RES_No_00 $u2 = 0 // No results to report.
  let USBDCD_STATUS_SEQ_RES_Attached_01 $u2 = 1 // Attached to an SDP. Must comply with USB 2.0 by drawing only 2.5 mA (max) until connected.
  let USBDCD_STATUS_SEQ_RES_Attached_10 $u2 = 2 // Attached to a charging port. The exact meaning depends on bit 18: 0: Attached to either a CDP or a DCP. The charger type detection has not completed. 1: Attached to a CDP. The charger type detection has completed.
  let USBDCD_STATUS_SEQ_RES_Attached_11 $u2 = 3 // Attached to a DCP.

//--- Enumerated values for register STATUS, field SEQ_STAT
  let USBDCD_STATUS_SEQ_STAT_The_00 $u2 = 0 // The module is either not enabled, or the module is enabled but the data pins have not yet been detected.
  let USBDCD_STATUS_SEQ_STAT_Data_01 $u2 = 1 // Data pin contact detection is complete.
  let USBDCD_STATUS_SEQ_STAT_Charging_10 $u2 = 2 // Charging port detection is complete.
  let USBDCD_STATUS_SEQ_STAT_Charger_11 $u2 = 3 // Charger type detection is complete.

//--- Enumerated values for register STATUS, field ERR
  let USBDCD_STATUS_ERR_No_0 $bool = no // No sequence errors.
  let USBDCD_STATUS_ERR_Error_1 $bool = yes // Error in the detection sequence. See the SEQ_STAT field to determine the phase in which the error occurred.

//--- Enumerated values for register STATUS, field TO
  let USBDCD_STATUS_TO_The_0 $bool = no // The detection sequence has not been running for over 1 s.
  let USBDCD_STATUS_TO_It_1 $bool = yes // It has been over 1 s since the data pin contact was detected and debounced.

//--- Enumerated values for register STATUS, field ACTIVE
  let USBDCD_STATUS_ACTIVE_The_0 $bool = no // The sequence is not running.
  let USBDCD_STATUS_ACTIVE_The_1 $bool = yes // The sequence is running.

//--- Enumerated values for register SIGNAL_OVERRIDE, field PS
  let USBDCD_SIGNAL_OVERRIDE_PS_No_00 $u2 = 0 // No overrides. Bit field must remain at this value during normal USB data communication to prevent unexpected conditions on USB_DP and USB_DM pins. (Default)
  let USBDCD_SIGNAL_OVERRIDE_PS_Reserved__01 $u2 = 1 // Reserved, not for customer use.
  let USBDCD_SIGNAL_OVERRIDE_PS_Enables_10 $u2 = 2 // Enables VDP_SRC voltage source for the USB_DP pin and IDM_SINK current source for the USB_DM pin.
  let USBDCD_SIGNAL_OVERRIDE_PS_Reserved__11 $u2 = 3 // Reserved, not for customer use.

//------------------------------------------------------------------------------
// Peripheral USBHS: USB HS/FS/LS OTG Controller
//------------------------------------------------------------------------------

registers ©USBHS @at 0x400a1000 {
//---  Register ID: Identification Register
  ID @offset 0x0 @ro $u32 {
    VERSIONID:3 // at 29: Version ID
    VERSION:4 // at 25: Version
    REVISION:4 // at 21: Revision
    TAG:5 // at 16: Tag
    2
    NID:6 // at 8: Ones complement version of ID.
    2
    ID:6 // at 0: Configuration number
  }

//---  Register HWGENERAL: General Hardware Parameters Register
  HWGENERAL @offset 0x4 @ro $u32 {
    21
    SM:2 // at 9: Serial mode
    PHYM:3 // at 6: PHY Mode
    PHYW:2 // at 4: PHY Width
    4
  }

//---  Register HWHOST: Host Hardware Parameters Register
  HWHOST @offset 0x8 @ro $u32 {
    TTPER:8 // at 24: Transaction translator periodic contexts.
    TTASY:8 // at 16: Transaction translator contexts.
    12
    NPORT:3 // at 1: Number of Ports
    HC // at 0: Host Capable
  }

//---  Register HWDEVICE: Device Hardware Parameters Register
  HWDEVICE @offset 0xc @ro $u32 {
    26
    DEVEP:5 // at 1: Device endpoints.
    DC // at 0: Device Capable
  }

//---  Register HWTXBUF: Transmit Buffer Hardware Parameters Register
  HWTXBUF @offset 0x10 @ro $u32 {
    TXLC // at 31: Transmit local Context Registers
    7
    TXCHANADD:8 // at 16: Transmit Channel Address
    TXADD:8 // at 8: Transmit Address.
    TXBURST:8 // at 0: Transmit Burst.
  }

//---  Register HWRXBUF: Receive Buffer Hardware Parameters Register
  HWRXBUF @offset 0x14 @ro $u32 {
    16
    RXADD:8 // at 8: Receive Address.
    RXBURST:8 // at 0: Receive Burst.
  }

//---  Registers GPTIMERLD(0,1): General Purpose Timer n Load Register
  GPTIMERLD [2 @offset 0x80 @inc 0x8]
  GPTIMER0LD @offset 0x80
  GPTIMER1LD @offset 0x88 $u32 {
    8
    GPTLD:24 // at 0: Specifies the value to be loaded into the countdown timer on a reset
  }

//---  Registers GPTIMERCTL(0,1): General Purpose Timer n Control Register
  GPTIMERCTL [2 @offset 0x84 @inc 0x8]
  GPTIMER0CTL @offset 0x84
  GPTIMER1CTL @offset 0x8c $u32 {
    RUN // at 31: Timer Run
    RST // at 30: Timer Reset
    5
    MODE // at 24: Timer Mode
    GPTCNT:24 // at 0: Timer Count
  }

//---  Register USB_SBUSCFG: System Bus Interface Configuration Register
  USB_SBUSCFG @offset 0x90 $u32 {
    29
    BURSTMODE:3 // at 0: Burst mode
  }

//---  Register HCIVERSION: Host Controller Interface Version and Capability Registers Length Register
  HCIVERSION @offset 0x100 @ro $u32 {
    HCIVERSION:16 // at 16: EHCI revision number
    8
    CAPLENGTH:8 // at 0: Capability registers length
  }

//---  Register HCSPARAMS: Host Controller Structural Parameters Register
  HCSPARAMS @offset 0x104 @ro $u32 {
    4
    N_TT:4 // at 24: Number of Transaction Translators.
    N_PTT:4 // at 20: Ports per Transaction Translator
    3
    PI // at 16: Port Indicators
    N_CC:4 // at 12: Number of Companion Controllers
    N_PCC:4 // at 8: Number Ports per CC
    3
    PPC // at 4: Power Port Control
    N_PORTS:4 // at 0: Number of Ports
  }

//---  Register HCCPARAMS: Host Controller Capability Parameters Register
  HCCPARAMS @offset 0x108 @ro $u32 {
    16
    EECP:8 // at 8: EHCI Extended Capabilities Pointer
    IST:4 // at 4: Isochronous Scheduling Threshold
    1
    ASP // at 2: Asynchronous Schedule Park capability
    PFL // at 1: Programmable Frame List flag
    ADC // at 0: 64-bit addressing capability.
  }

//---  Register DCIVERSION: Device Controller Interface Version
  DCIVERSION @offset 0x122 @ro $u16 {
    DCIVERSION:16 // at 0: Device interface revision number.
  }

//---  Register DCCPARAMS: Device Controller Capability Parameters
  DCCPARAMS @offset 0x124 @ro $u32 {
    23
    HC // at 8: Host Capable
    DC // at 7: Device Capable
    2
    DEN:5 // at 0: Device Endpoint Number
  }

//---  Register USBCMD: USB Command Register
  USBCMD @offset 0x140 $u32 {
    8
    ITC:8 // at 16: Interrupt Threshold Control
    FS2 // at 15: Frame list Size 2
    ATDTW // at 14: Add dTD TripWire
    SUTW // at 13: Setup TripWire
    1
    ASPE // at 11: Asynchronous Schedule Park mode Enable
    1
    ASP:2 // at 8: Asynchronous Schedule Park mode count
    1
    IAA // at 6: Interrupt on Async Advance doorbell
    ASE // at 5: Asynchronous Schedule Enable
    PSE // at 4: Periodic Schedule Enable
    FS:2 // at 2: Frame list Size
    RST // at 1: Controller Reset
    RS // at 0: Run/Stop
  }

//---  Register USBSTS: USB Status Register
  USBSTS @offset 0x144 $u32 {
    6
    TI1 // at 25: General purpose Timer 1 Interrupt
    TI0 // at 24: General purpose Timer 0 Interrupt
    4
    UPI // at 19: USB host Periodic Interrupt
    UAI // at 18: USB host Asynchronous Interrupt
    1
    NAKI // at 16: NAK Interrupt
    AS // at 15: Asynchronous schedule Status
    PS // at 14: Periodic schedule Status
    RCL // at 13: Reclamation
    HCH // at 12: Host Controller Halted
    3
    SLI // at 8: Device-controller suspend
    SRI // at 7: SOF Received
    URI // at 6: USB Reset received
    AAI // at 5: Interrupt on Async Advance
    SEI // at 4: System Error
    FRI // at 3: Frame-list Rollover
    PCI // at 2: Port Change detect
    UEI // at 1: USB Error Interrupt
    UI // at 0: USB Interrupt (USBINT)
  }

//---  Register USBINTR: USB Interrupt Enable Register
  USBINTR @offset 0x148 $u32 {
    6
    TIE1 // at 25: General purpose Timer 1 Interrupt Enable
    TIE0 // at 24: General purpose Timer 0 Interrupt Enable
    4
    UPIE // at 19: USB host Periodic Interrupt Enable
    UAIE // at 18: USB host Asynchronous Interrupt Enable
    1
    NAKE // at 16: NAK Interrupt Enable
    7
    SLE // at 8: Sleep (DC suspend) Enable
    SRE // at 7: SOF-Received Enable
    URE // at 6: USB-Reset Enable
    AAE // at 5: Interrupt on Async advance Enable
    SEE // at 4: System Error Enable
    FRE // at 3: Frame list Rollover Enable
    PCE // at 2: Port Change detect Enable
    UEE // at 1: USB Error interrupt Enable
    UE // at 0: USB interrupt Enable
  }

//---  Register FRINDEX: Frame Index Register
  FRINDEX @offset 0x14c $u32 {
    Reerved:18 // at 14: Reserved
    FRINDEX:14 // at 0: Frame Index
  }

//---  Register DEVICEADDR: Device Address Register
  DEVICEADDR @offset 0x154 $u32 {
    USBADR:7 // at 25: Device Address
    USBADRA // at 24: Device Address Advance
    24
  }

//---  Register PERIODICLISTBASE: Periodic Frame List Base Address Register
  PERIODICLISTBASE @offset 0x154 $u32 {
    PERBASE:20 // at 12: Base address
    12
  }

//---  Register ASYNCLISTADDR: Current Asynchronous List Address Register
  ASYNCLISTADDR @offset 0x158 $u32 {
    ASYBASE:27 // at 5: Link pointer low (LPL)
    5
  }

//---  Register EPLISTADDR: Endpoint List Address Register
  EPLISTADDR @offset 0x158 $u32 {
    EPBASE:21 // at 11: Endpoint list address
    11
  }

//---  Register TTCTRL: Host TT Asynchronous Buffer Control
  TTCTRL @offset 0x15c @ro $u32 {
    Reerved // at 31: Reserved
    TTHA:7 // at 24: TT Hub Address
    24
  }

//---  Register BURSTSIZE: Master Interface Data Burst Size Register
  BURSTSIZE @offset 0x160 $u32 {
    16
    TXPBURST:8 // at 8: Programable TX Burst length
    RXPBURST:8 // at 0: Programable RX Burst length
  }

//---  Register TXFILLTUNING: Transmit FIFO Tuning Control Register
  TXFILLTUNING @offset 0x164 $u32 {
    10
    TXFIFOTHRES:6 // at 16: FIFO burst Threshold
    3
    TXSCHHEALTH:5 // at 8: Scheduler Health counter
    1
    TXSCHOH:7 // at 0: Scheduler Overhead
  }

//---  Register ENDPTNAK: Endpoint NAK Register
  ENDPTNAK @offset 0x178 $u32 {
    12
    EPTN:4 // at 16: TX Endpoint NAK
    12
    EPRN:4 // at 0: RX Endpoint NAK
  }

//---  Register ENDPTNAKEN: Endpoint NAK Enable Register
  ENDPTNAKEN @offset 0x17c $u32 {
    12
    EPTNE:4 // at 16: TX Endpoint NAK
    12
    EPRNE:4 // at 0: RX Endpoint NAK
  }

//---  Register CONFIGFLAG: Configure Flag Register
  CONFIGFLAG @offset 0x180 @ro $u32
//---  Register PORTSC1: Port Status and Control Registers
  PORTSC1 @offset 0x184 $u32 {
    PTS:2 // at 30: Port Transceiver Select [1:0]
    2
    PSPD:2 // at 26: Port Speed
    PTS2 // at 25: Port Transceiver Select [2]
    PFSC // at 24: Port force Full-Speed Connect
    PHCD // at 23: PHY low power suspend
    WKOC // at 22: Wake on Over-Current enable
    WKDS // at 21: Wake on Disconnect enable
    WKCN // at 20: Wake on Connect enable
    PTC:4 // at 16: Port Test Control
    PIC:2 // at 14: Port Indicator Control
    PO // at 13: Port Owner
    PP // at 12: Port Power
    LS:2 // at 10: Line Status
    HSP // at 9: High Speed Port.
    PR // at 8: Port Reset
    SUSP // at 7: Suspend
    FPR // at 6: Force Port Resume
    OCC // at 5: Over-Current Change
    OCA // at 4: Over-current active
    PEC // at 3: Port Enable/disable Change
    PE // at 2: Port Enabled/disabled
    CSC // at 1: Connect Change Status
    CCS // at 0: Current Connect Status
  }

//---  Register OTGSC: On-the-Go Status and Control Register
  OTGSC @offset 0x1a4 $u32 {
    1
    DPIE // at 30: Data Pulse Interrupt Enable
    MSE // at 29: 1 Milli-Second timer interrupt Enable
    BSEIE // at 28: B Session End Interrupt Enable
    BSVIE // at 27: B Session Valid Interrupt Enable
    ASVIE // at 26: A Session Valid Interrupt Enable
    AVVIE // at 25: A VBUS Valid Interrupt Enable
    IDIE // at 24: USB ID Interrupt Enable
    1
    DPIS // at 22: Data Pulse interrupt Status
    MSS // at 21: 1 Milli-Second timer interrupt Status
    BSEIS // at 20: B Session End Interrupt Status
    BSVIS // at 19: B Session Valid Interrupt Status
    ASVIS // at 18: A Session Valid Interrupt Status
    AVVIS // at 17: A VBUS Valid Interrupt Status
    IDIS // at 16: USB ID Interrupt Status
    1
    DPS // at 14: Data bus Pulsing Status
    MST // at 13: 1 Milli-Second timer Toggle
    BSE // at 12: B Session End
    BSV // at 11: B Session Valid
    ASV // at 10: A Session Valid
    AVV // at 9: A VBus Valid
    ID // at 8: USB ID
    HABA // at 7: Hardware Assist B-Disconnect to A-connect
    1
    IDPU // at 5: ID Pull-Up
    DP // at 4: Data Pulsing
    OT // at 3: OTG Termination
    HAAR // at 2: Hardware Assist Auto-Reset
    VC // at 1: VBUS Charge
    VD // at 0: VBUS Discharge
  }

//---  Register USBMODE: USB Mode Register
  USBMODE @offset 0x1a8 $u32 {
    17
    TXHSD:3 // at 12: Tx to Tx HS Delay
    7
    SDIS // at 4: Stream DISable
    SLOM // at 3: Setup Lock-Out Mode
    ES // at 2: Endian Select
    CM:2 // at 0: Controller Mode
  }

//---  Register EPSETUPSR: Endpoint Setup Status Register
  EPSETUPSR @offset 0x1ac $u32 {
    28
    EPSETUPSTAT:4 // at 0: Setup Endpoint Status
  }

//---  Register EPPRIME: Endpoint Initialization Register
  EPPRIME @offset 0x1b0 $u32 {
    12
    PETB:4 // at 16: Prime Endpoint tTansmit Buffer
    12
    PERB:4 // at 0: Prime Endpoint Receive Buffer
  }

//---  Register EPFLUSH: Endpoint Flush Register
  EPFLUSH @offset 0x1b4 $u32 {
    12
    FETB:4 // at 16: Flush Endpoint Transmit Buffer
    12
    FERB:4 // at 0: Flush Endpoint Receive Buffer
  }

//---  Register EPSR: Endpoint Status Register
  EPSR @offset 0x1b8 @ro $u32 {
    12
    ETBR:4 // at 16: Endpoint Transmit Buffer Ready
    12
    ERBR:4 // at 0: Endpoint Receive Buffer Ready
  }

//---  Register EPCOMPLETE: Endpoint Complete Register
  EPCOMPLETE @offset 0x1bc $u32 {
    12
    ETCE:4 // at 16: Endpoint Transmit Complete Event
    12
    ERCE:4 // at 0: Endpoint Receive Complete Event
  }

//---  Register EPCR0: Endpoint Control Register 0
  EPCR0 @offset 0x1c0 $u32 {
    8
    TXE // at 23: TX Endpoint Enable
    3
    TXT:2 // at 18: TX Endpoint Type
    1
    TXS // at 16: TX Endpoint Stall
    8
    RXE // at 7: RX endpoint Enable
    3
    RXT:2 // at 2: RX endpoint Type
    1
    RXS // at 0: RX endpoint Stall
  }

//---  Registers EPCR(1,2,3,4,5,6,7): Endpoint Control Register n
  EPCR [7 @offset 0x1c4 @inc 0x4]
  EPCR1 @offset 0x1c4
  EPCR2 @offset 0x1c8
  EPCR3 @offset 0x1cc
  EPCR4 @offset 0x1d0
  EPCR5 @offset 0x1d4
  EPCR6 @offset 0x1d8
  EPCR7 @offset 0x1dc $u32 {
    8
    TXE // at 23: TX endpoint Enable
    TXR // at 22: TX data toggle Reset
    TXI // at 21: TX data toggle Inhibit
    1
    TXT:2 // at 18: TX endpoint Type
    TXD // at 17: TX endpoint Data source
    TXS // at 16: TX endpoint Stall
    8
    RXE // at 7: RX endpoint Enable
    RXR // at 6: RX data toggle Reset
    RXI // at 5: RX data toggle Inhibit
    1
    RXT:2 // at 2: RX endpoint Type
    RXD // at 1: RX endpoint Data sink
    RXS // at 0: RX endpoint Stall
  }

//---  Register USBGENCTRL: USB General Control Register
  USBGENCTRL @offset 0x200 $u32 {
    26
    WU_INT_CLR // at 5: Wakeup Interrupt Clear
    4
    WU_IE // at 0: Wakeup Interrupt Enable
  }

}

//--- Enumerated values for register HWGENERAL, field PHYW
  let USBHS_HWGENERAL_PHYW_16_01 $u2 = 1 // 16 bit wide data bus

//--- Enumerated values for register HWGENERAL, field PHYM
  let USBHS_HWGENERAL_PHYM_Controller_000 $u3 = 0 // Controller configured for UTMI/UTMI+ interface.

//--- Enumerated values for register HWGENERAL, field SM
  let USBHS_HWGENERAL_SM_No_00 $u2 = 0 // No Serial Engine, always use parallel signaling.

//--- Enumerated values for register HWTXBUF, field TXLC
  let USBHS_HWTXBUF_TXLC_Store_0 $bool = no // Store device transmit contexts in the TX FIFO
  let USBHS_HWTXBUF_TXLC_Store_1 $bool = yes // Store device transmit contexts in a register file

//--- Enumerated values for register GPTIMER%sCTL, field MODE
  let USBHS_GPTIMERCTL_MODE_One_0 $bool = no // One shot
  let USBHS_GPTIMERCTL_MODE_Repeat_1 $bool = yes // Repeat

//--- Enumerated values for register GPTIMER%sCTL, field RST
  let USBHS_GPTIMERCTL_RST_No_0 $bool = no // No action
  let USBHS_GPTIMERCTL_RST_Load_1 $bool = yes // Load counter value

//--- Enumerated values for register GPTIMER%sCTL, field RUN
  let USBHS_GPTIMERCTL_RUN_Timer_0 $bool = no // Timer stop
  let USBHS_GPTIMERCTL_RUN_Timer_1 $bool = yes // Timer run

//--- Enumerated values for register USB_SBUSCFG, field BURSTMODE
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR_000 $u3 = 0 // INCR burst of unspecified length
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR4__001 $u3 = 1 // INCR4, non-multiple transfers of INCR4 is decomposed into singles.
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR8__010 $u3 = 2 // INCR8, non-multiple transfers of INCR8, is decomposed into INCR4 or singles.
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR16__011 $u3 = 3 // INCR16, non-multiple transfers of INCR16, is decomposed into INCR8, INCR4 or singles.
  let USBHS_USB_SBUSCFG_BURSTMODE_Reserved__100 $u3 = 4 // Reserved, do not use.
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR4__101 $u3 = 5 // INCR4, non-multiple transfers of INCR4 is decomposed into smaller unspecified length bursts.
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR8__110 $u3 = 6 // INCR8, non-multiple transfers of INCR8 is decomposed into smaller unspecified length bursts.
  let USBHS_USB_SBUSCFG_BURSTMODE_INCR16__111 $u3 = 7 // INCR16, non-multiple transfers of INCR16 is decomposed into smaller unspecified length bursts.

//--- Enumerated values for register HCSPARAMS, field PPC
  let USBHS_HCSPARAMS_PPC_Ports_1 $bool = yes // Ports have power port switches

//--- Enumerated values for register HCSPARAMS, field PI
  let USBHS_HCSPARAMS_PI_No_0 $bool = no // No port indicator fields
  let USBHS_HCSPARAMS_PI_The_1 $bool = yes // The port status and control registers include a R/W field for controlling the state of the port indicator

//--- Enumerated values for register HCCPARAMS, field ASP
  let USBHS_HCCPARAMS_ASP_Park_0 $bool = no // Park not supported.
  let USBHS_HCCPARAMS_ASP_Park_1 $bool = yes // Park supported.

//--- Enumerated values for register HCCPARAMS, field IST
  let USBHS_HCCPARAMS_IST_The_0 $u4 = 0 // The value of the least significant 3 bits indicates the number of microframes a host controller can hold a set of isochronous data structures (one or more) before flushing the state

//--- Enumerated values for register HCCPARAMS, field EECP
  let USBHS_HCCPARAMS_EECP_No_0 $u8 = 0 // No extended capabilities are implemented

//--- Enumerated values for register USBCMD, field FS
  let USBHS_USBCMD_FS_When_00 $u2 = 0 // When FS2 = 0, the size is 1024 elements (4096 bytes). When FS2 = 1, the size is 64 elements (256 bytes).
  let USBHS_USBCMD_FS_When_01 $u2 = 1 // When FS2 = 0, the size is 512 elements (2048 bytes). When FS2 = 1, the size is 32 elements (128 bytes).
  let USBHS_USBCMD_FS_When_10 $u2 = 2 // When FS2 = 0, the size is 256 elements (1024 bytes). When FS2 = 1, the size is 16 elements (64 bytes).
  let USBHS_USBCMD_FS_When_11 $u2 = 3 // When FS2 = 0, the size is 128 elements (512 bytes). When FS2 = 1, the size is 8 elements (32 bytes).

//--- Enumerated values for register USBCMD, field PSE
  let USBHS_USBCMD_PSE_Do_0 $bool = no // Do not process periodic schedule.
  let USBHS_USBCMD_PSE_Use_1 $bool = yes // Use the PERIODICLISTBASE register to access the periodic schedule.

//--- Enumerated values for register USBCMD, field ASE
  let USBHS_USBCMD_ASE_Do_0 $bool = no // Do not process asynchronous schedule.
  let USBHS_USBCMD_ASE_Use_1 $bool = yes // Use the ASYNCLISTADDR register to access asynchronous schedule.

//--- Enumerated values for register USBCMD, field ASPE
  let USBHS_USBCMD_ASPE_Park_0 $bool = no // Park mode disabled
  let USBHS_USBCMD_ASPE_Park_1 $bool = yes // Park mode enabled

//--- Enumerated values for register USBCMD, field ITC
  let USBHS_USBCMD_ITC_Immediate_0 $u8 = 0 // Immediate (no threshold)
  let USBHS_USBCMD_ITC_1_1 $u8 = 1 // 1 microframe
  let USBHS_USBCMD_ITC_2_10 $u8 = 2 // 2 microframes
  let USBHS_USBCMD_ITC_4_100 $u8 = 4 // 4 microframes
  let USBHS_USBCMD_ITC_8_1000 $u8 = 8 // 8 microframes
  let USBHS_USBCMD_ITC_16_10000 $u8 = 16 // 16 microframes
  let USBHS_USBCMD_ITC_32_100000 $u8 = 32 // 32 microframes
  let USBHS_USBCMD_ITC_64_1000000 $u8 = 64 // 64 microframes

//--- Enumerated values for register USBSTS, field UEI
  let USBHS_USBSTS_UEI_No_0 $bool = no // No error
  let USBHS_USBSTS_UEI_Error_1 $bool = yes // Error detected

//--- Enumerated values for register USBSTS, field SEI
  let USBHS_USBSTS_SEI_Normal_0 $bool = no // Normal operation
  let USBHS_USBSTS_SEI_Error_1 $bool = yes // Error

//--- Enumerated values for register USBSTS, field AAI
  let USBHS_USBSTS_AAI_No_0 $bool = no // No async advance interrupt
  let USBHS_USBSTS_AAI_Async_1 $bool = yes // Async advance interrupt

//--- Enumerated values for register USBSTS, field URI
  let USBHS_USBSTS_URI_No_0 $bool = no // No reset received
  let USBHS_USBSTS_URI_Reset_1 $bool = yes // Reset received

//--- Enumerated values for register USBSTS, field SLI
  let USBHS_USBSTS_SLI_Active_0 $bool = no // Active
  let USBHS_USBSTS_SLI_Suspended_1 $bool = yes // Suspended

//--- Enumerated values for register USBSTS, field HCH
  let USBHS_USBSTS_HCH_Running_0 $bool = no // Running
  let USBHS_USBSTS_HCH_Halted_1 $bool = yes // Halted

//--- Enumerated values for register USBSTS, field RCL
  let USBHS_USBSTS_RCL_Non_empty_0 $bool = no // Non-empty asynchronous schedule
  let USBHS_USBSTS_RCL_Empty_1 $bool = yes // Empty asynchronous schedule

//--- Enumerated values for register USBSTS, field PS
  let USBHS_USBSTS_PS_Disabled_0 $bool = no // Disabled
  let USBHS_USBSTS_PS_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBSTS, field AS
  let USBHS_USBSTS_AS_Disabled_0 $bool = no // Disabled
  let USBHS_USBSTS_AS_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBSTS, field TI0
  let USBHS_USBSTS_TI0_No_0 $bool = no // No interrupt
  let USBHS_USBSTS_TI0_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register USBSTS, field TI1
  let USBHS_USBSTS_TI1_No_0 $bool = no // No interrupt
  let USBHS_USBSTS_TI1_Interrupt_1 $bool = yes // Interrupt occurred

//--- Enumerated values for register USBINTR, field UE
  let USBHS_USBINTR_UE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_UE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field UEE
  let USBHS_USBINTR_UEE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_UEE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field PCE
  let USBHS_USBINTR_PCE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_PCE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field FRE
  let USBHS_USBINTR_FRE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_FRE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field SEE
  let USBHS_USBINTR_SEE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_SEE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field AAE
  let USBHS_USBINTR_AAE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_AAE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field URE
  let USBHS_USBINTR_URE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_URE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field SRE
  let USBHS_USBINTR_SRE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_SRE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field SLE
  let USBHS_USBINTR_SLE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_SLE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field NAKE
  let USBHS_USBINTR_NAKE_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_NAKE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field TIE0
  let USBHS_USBINTR_TIE0_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_TIE0_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBINTR, field TIE1
  let USBHS_USBINTR_TIE1_Disabled_0 $bool = no // Disabled
  let USBHS_USBINTR_TIE1_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register DEVICEADDR, field USBADRA
  let USBHS_DEVICEADDR_USBADRA_Writes_0 $bool = no // Writes to USBADR are instantaneous.
  let USBHS_DEVICEADDR_USBADRA_When_1 $bool = yes // When this bit is written to a 1 at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register. After an IN occurs on endpoint 0 and is ACKed, USBADR is loaded from the holding register.

//--- Enumerated values for register PORTSC1, field CCS
  let USBHS_PORTSC1_CCS_No_0 $bool = no // No device present (host mode) or attached (device mode)
  let USBHS_PORTSC1_CCS_Device_1 $bool = yes // Device is present (host mode) or attached (device mode)

//--- Enumerated values for register PORTSC1, field CSC
  let USBHS_PORTSC1_CSC_No_0 $bool = no // No change
  let USBHS_PORTSC1_CSC_Connect_1 $bool = yes // Connect status has changed

//--- Enumerated values for register PORTSC1, field PEC
  let USBHS_PORTSC1_PEC_No_0 $bool = no // No change
  let USBHS_PORTSC1_PEC_Port_1 $bool = yes // Port disabled

//--- Enumerated values for register PORTSC1, field OCA
  let USBHS_PORTSC1_OCA_Port_0 $bool = no // Port not in over-current condition
  let USBHS_PORTSC1_OCA_Port_1 $bool = yes // Port currently in over-current condition

//--- Enumerated values for register PORTSC1, field OCC
  let USBHS_PORTSC1_OCC_No_0 $bool = no // No over-current
  let USBHS_PORTSC1_OCC_Over_current_1 $bool = yes // Over-current detect

//--- Enumerated values for register PORTSC1, field FPR
  let USBHS_PORTSC1_FPR_No_0 $bool = no // No resume (K-state) detected/driven on port
  let USBHS_PORTSC1_FPR_Resume_1 $bool = yes // Resume detected/driven on port

//--- Enumerated values for register PORTSC1, field SUSP
  let USBHS_PORTSC1_SUSP_Port_0 $bool = no // Port not in suspend state
  let USBHS_PORTSC1_SUSP_Port_1 $bool = yes // Port in suspend state

//--- Enumerated values for register PORTSC1, field PR
  let USBHS_PORTSC1_PR_Port_0 $bool = no // Port is not in reset
  let USBHS_PORTSC1_PR_Port_1 $bool = yes // Port is in reset

//--- Enumerated values for register PORTSC1, field HSP
  let USBHS_PORTSC1_HSP_FS_0 $bool = no // FS or LS
  let USBHS_PORTSC1_HSP_HS_1 $bool = yes // HS

//--- Enumerated values for register PORTSC1, field LS
  let USBHS_PORTSC1_LS_SE0_00 $u2 = 0 // SE0
  let USBHS_PORTSC1_LS_J_state_01 $u2 = 1 // J-state
  let USBHS_PORTSC1_LS_K_state_10 $u2 = 2 // K-state
  let USBHS_PORTSC1_LS_Undefined_11 $u2 = 3 // Undefined

//--- Enumerated values for register PORTSC1, field PTC
  let USBHS_PORTSC1_PTC_Not_0000 $u4 = 0 // Not enabled
  let USBHS_PORTSC1_PTC_J_STATE_0001 $u4 = 1 // J_STATE
  let USBHS_PORTSC1_PTC_K_STATE_0010 $u4 = 2 // K_STATE
  let USBHS_PORTSC1_PTC_SE0_NAK_0011 $u4 = 3 // SE0_NAK
  let USBHS_PORTSC1_PTC_Packet_0100 $u4 = 4 // Packet
  let USBHS_PORTSC1_PTC_FORCE_ENABLE_HS_0101 $u4 = 5 // FORCE_ENABLE_HS
  let USBHS_PORTSC1_PTC_FORCE_ENABLE_FS_0110 $u4 = 6 // FORCE_ENABLE_FS
  let USBHS_PORTSC1_PTC_FORCE_ENABLE_LS_0111 $u4 = 7 // FORCE_ENABLE_LS

//--- Enumerated values for register PORTSC1, field PFSC
  let USBHS_PORTSC1_PFSC_Allow_0 $bool = no // Allow the port to identify itself as high speed
  let USBHS_PORTSC1_PFSC_Force_1 $bool = yes // Force the port to only connect at full speed

//--- Enumerated values for register PORTSC1, field PSPD
  let USBHS_PORTSC1_PSPD_Full_00 $u2 = 0 // Full speed
  let USBHS_PORTSC1_PSPD_Low_01 $u2 = 1 // Low speed
  let USBHS_PORTSC1_PSPD_High_10 $u2 = 2 // High speed
  let USBHS_PORTSC1_PSPD_Undefined_11 $u2 = 3 // Undefined

//--- Enumerated values for register PORTSC1, field PTS
  let USBHS_PORTSC1_PTS_Use_000 $u2 = 0 // Use UTMI transceiver interface.

//--- Enumerated values for register OTGSC, field HAAR
  let USBHS_OTGSC_HAAR_Disabled__0 $bool = no // Disabled.
  let USBHS_OTGSC_HAAR_Enable_1 $bool = yes // Enable automatic reset after connect on host port.

//--- Enumerated values for register OTGSC, field OT
  let USBHS_OTGSC_OT_Disable_0 $bool = no // Disable pull-down on DM
  let USBHS_OTGSC_OT_Enable_1 $bool = yes // Enable pull-down on DM

//--- Enumerated values for register OTGSC, field DP
  let USBHS_OTGSC_DP_The_0 $bool = no // The pull-up on DP is not asserted
  let USBHS_OTGSC_DP_The_1 $bool = yes // The pull-up on DP is asserted for data pulsing during SRP

//--- Enumerated values for register OTGSC, field IDPU
  let USBHS_OTGSC_IDPU_Disable_0 $bool = no // Disable pull-up. ID input not sampled.
  let USBHS_OTGSC_IDPU_Enable_1 $bool = yes // Enable pull-up

//--- Enumerated values for register OTGSC, field HABA
  let USBHS_OTGSC_HABA_Disabled__0 $bool = no // Disabled.
  let USBHS_OTGSC_HABA_Enable_1 $bool = yes // Enable automatic B-disconnect to A-connect sequence.

//--- Enumerated values for register OTGSC, field ID
  let USBHS_OTGSC_ID_A_0 $bool = no // A device
  let USBHS_OTGSC_ID_B_1 $bool = yes // B device

//--- Enumerated values for register OTGSC, field AVV
  let USBHS_OTGSC_AVV_VBus_0 $bool = no // VBus is below A VBus valid threshold
  let USBHS_OTGSC_AVV_VBus_1 $bool = yes // VBus is above A VBus valid threshold

//--- Enumerated values for register OTGSC, field ASV
  let USBHS_OTGSC_ASV_VBus_0 $bool = no // VBus is below A session valid threshold
  let USBHS_OTGSC_ASV_VBus_1 $bool = yes // VBus is above A session valid threshold

//--- Enumerated values for register OTGSC, field BSV
  let USBHS_OTGSC_BSV_VBus_0 $bool = no // VBus is below B session valid threshold
  let USBHS_OTGSC_BSV_VBus_1 $bool = yes // VBus is above B session valid threshold

//--- Enumerated values for register OTGSC, field BSE
  let USBHS_OTGSC_BSE_VBus_0 $bool = no // VBus is above B session end threshold
  let USBHS_OTGSC_BSE_VBus_1 $bool = yes // VBus is below B session end threshold

//--- Enumerated values for register OTGSC, field DPS
  let USBHS_OTGSC_DPS_No_0 $bool = no // No pulsing on port
  let USBHS_OTGSC_DPS_Pulsing_1 $bool = yes // Pulsing detected on port

//--- Enumerated values for register OTGSC, field IDIE
  let USBHS_OTGSC_IDIE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_IDIE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register OTGSC, field AVVIE
  let USBHS_OTGSC_AVVIE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_AVVIE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register OTGSC, field ASVIE
  let USBHS_OTGSC_ASVIE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_ASVIE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register OTGSC, field BSVIE
  let USBHS_OTGSC_BSVIE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_BSVIE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register OTGSC, field BSEIE
  let USBHS_OTGSC_BSEIE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_BSEIE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register OTGSC, field MSE
  let USBHS_OTGSC_MSE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_MSE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register OTGSC, field DPIE
  let USBHS_OTGSC_DPIE_Disable_0 $bool = no // Disable
  let USBHS_OTGSC_DPIE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register USBMODE, field CM
  let USBHS_USBMODE_CM_Idle_00 $u2 = 0 // Idle (default for the USBHS module)
  let USBHS_USBMODE_CM_Device_10 $u2 = 2 // Device controller
  let USBHS_USBMODE_CM_Host_11 $u2 = 3 // Host controller

//--- Enumerated values for register USBMODE, field ES
  let USBHS_USBMODE_ES_Little_0 $bool = no // Little endian. First byte referenced in least significant byte of 32-bit word.
  let USBHS_USBMODE_ES_Big_1 $bool = yes // Big endian. First byte referenced in most significant byte of 32-bit word.

//--- Enumerated values for register USBMODE, field SDIS
  let USBHS_USBMODE_SDIS_Inactive_0 $bool = no // Inactive
  let USBHS_USBMODE_SDIS_Active_1 $bool = yes // Active

//--- Enumerated values for register USBMODE, field TXHSD
  let USBHS_USBMODE_TXHSD_10_000 $u3 = 0 // 10
  let USBHS_USBMODE_TXHSD_11_001 $u3 = 1 // 11
  let USBHS_USBMODE_TXHSD_12_010 $u3 = 2 // 12
  let USBHS_USBMODE_TXHSD_13_011 $u3 = 3 // 13
  let USBHS_USBMODE_TXHSD_14_100 $u3 = 4 // 14
  let USBHS_USBMODE_TXHSD_15_101 $u3 = 5 // 15
  let USBHS_USBMODE_TXHSD_16_110 $u3 = 6 // 16
  let USBHS_USBMODE_TXHSD_17_111 $u3 = 7 // 17

//--- Enumerated values for register EPCR0, field RXS
  let USBHS_EPCR0_RXS_Endpoint_0 $bool = no // Endpoint OK
  let USBHS_EPCR0_RXS_Endpoint_1 $bool = yes // Endpoint stalled

//--- Enumerated values for register EPCR0, field RXT
  let USBHS_EPCR0_RXT_Control_00 $u2 = 0 // Control

//--- Enumerated values for register EPCR0, field RXE
  let USBHS_EPCR0_RXE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register EPCR0, field TXS
  let USBHS_EPCR0_TXS_Endpoint_0 $bool = no // Endpoint OK
  let USBHS_EPCR0_TXS_Endpoint_1 $bool = yes // Endpoint stalled

//--- Enumerated values for register EPCR0, field TXT
  let USBHS_EPCR0_TXT_Control_00 $u2 = 0 // Control

//--- Enumerated values for register EPCR0, field TXE
  let USBHS_EPCR0_TXE_Enable_1 $bool = yes // Enable

//--- Enumerated values for register EPCR%s, field RXS
  let USBHS_EPCR_RXS_Endpoint_0 $bool = no // Endpoint OK
  let USBHS_EPCR_RXS_Endpoint_1 $bool = yes // Endpoint stalled

//--- Enumerated values for register EPCR%s, field RXT
  let USBHS_EPCR_RXT_Control_00 $u2 = 0 // Control
  let USBHS_EPCR_RXT_Isochronous_01 $u2 = 1 // Isochronous
  let USBHS_EPCR_RXT_Bulk_10 $u2 = 2 // Bulk
  let USBHS_EPCR_RXT_Interrupt_11 $u2 = 3 // Interrupt

//--- Enumerated values for register EPCR%s, field RXI
  let USBHS_EPCR_RXI_PID_0 $bool = no // PID sequencing enabled
  let USBHS_EPCR_RXI_PID_1 $bool = yes // PID sequencing disabled

//--- Enumerated values for register EPCR%s, field RXE
  let USBHS_EPCR_RXE_Disabled_0 $bool = no // Disabled
  let USBHS_EPCR_RXE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register EPCR%s, field TXS
  let USBHS_EPCR_TXS_Endpoint_0 $bool = no // Endpoint OK
  let USBHS_EPCR_TXS_Endpoint_1 $bool = yes // Endpoint stalled

//--- Enumerated values for register EPCR%s, field TXT
  let USBHS_EPCR_TXT_Control_00 $u2 = 0 // Control
  let USBHS_EPCR_TXT_Isochronous_01 $u2 = 1 // Isochronous
  let USBHS_EPCR_TXT_Bulk_10 $u2 = 2 // Bulk
  let USBHS_EPCR_TXT_Interrupt_11 $u2 = 3 // Interrupt

//--- Enumerated values for register EPCR%s, field TXI
  let USBHS_EPCR_TXI_PID_0 $bool = no // PID sequencing enabled
  let USBHS_EPCR_TXI_PID_1 $bool = yes // PID sequencing disabled

//--- Enumerated values for register EPCR%s, field TXE
  let USBHS_EPCR_TXE_Disabled_0 $bool = no // Disabled
  let USBHS_EPCR_TXE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBGENCTRL, field WU_IE
  let USBHS_USBGENCTRL_WU_IE_Disabled_0 $bool = no // Disabled
  let USBHS_USBGENCTRL_WU_IE_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register USBGENCTRL, field WU_INT_CLR
  let USBHS_USBGENCTRL_WU_INT_CLR_Default__0 $bool = no // Default, no action.
  let USBHS_USBGENCTRL_WU_INT_CLR_Clear_1 $bool = yes // Clear the wake-up interrupt.

//------------------------------------------------------------------------------
// Peripheral USBHSDCD: USB Device Charger Detection module
//------------------------------------------------------------------------------

registers ©USBHSDCD @at 0x400a3000 {
//---  Register CONTROL: Control register
  CONTROL @offset 0x0 $u32 {
    6
    SR // at 25: Software Reset
    START // at 24: Start Change Detection Sequence
    6
    BC12 // at 17: BC1.2 compatibility. This bit cannot be changed after start detection.
    IE // at 16: Interrupt Enable
    7
    IF // at 8: Interrupt Flag
    7
    IACK // at 0: Interrupt Acknowledge
  }

//---  Register CLOCK: Clock register
  CLOCK @offset 0x4 $u32 {
    20
    CLOCK_SPEED:10 // at 2: Numerical Value of Clock Speed in Binary
    1
    CLOCK_UNIT // at 0: Unit of Measurement Encoding for Clock Speed
  }

//---  Register STATUS: Status register
  STATUS @offset 0x8 @ro $u32 {
    9
    ACTIVE // at 22: Active Status Indicator
    TO // at 21: Timeout Flag
    ERR // at 20: Error Flag
    SEQ_STAT:2 // at 18: Charger Detection Sequence Status
    SEQ_RES:2 // at 16: Charger Detection Sequence Results
    16
  }

//---  Register SIGNAL_OVERRIDE: Signal Override Register
  SIGNAL_OVERRIDE @offset 0xc $u32 {
    30
    PS:2 // at 0: Phase Selection
  }

//---  Register TIMER0: TIMER0 register
  TIMER0 @offset 0x10 $u32 {
    6
    TSEQ_INIT:10 // at 16: Sequence Initiation Time
    4
    TUNITCON:12 // at 0: Unit Connection Timer Elapse (in ms)
  }

//---  Register TIMER1: TIMER1 register
  TIMER1 @offset 0x14 $u32 {
    6
    TDCD_DBNC:10 // at 16: Time Period to Debounce D+ Signal
    6
    TVDPSRC_ON:10 // at 0: Time Period Comparator Enabled
  }

//---  Register TIMER2_BC11: TIMER2_BC11 register
  TIMER2_BC11 @offset 0x18 $u32 {
    6
    TVDPSRC_CON:10 // at 16: Time Period Before Enabling D+ Pullup
    12
    CHECK_DM:4 // at 0: Time Before Check of D- Line
  }

//---  Register TIMER2_BC12: TIMER2_BC12 register
  TIMER2_BC12 @offset 0x18 $u32 {
    6
    TWAIT_AFTER_PRD:10 // at 16: Sets the amount of time (in ms) that the module waits after primary detection before start to secondary detection
    6
    TVDMSRC_ON:10 // at 0: Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid values are 0-40ms.
  }

}

//--- Enumerated values for register CONTROL, field IACK
  let USBHSDCD_CONTROL_IACK_Do_0 $bool = no // Do not clear the interrupt.
  let USBHSDCD_CONTROL_IACK_Clear_1 $bool = yes // Clear the IF bit (interrupt flag).

//--- Enumerated values for register CONTROL, field IF
  let USBHSDCD_CONTROL_IF_No_0 $bool = no // No interrupt is pending.
  let USBHSDCD_CONTROL_IF_An_1 $bool = yes // An interrupt is pending.

//--- Enumerated values for register CONTROL, field IE
  let USBHSDCD_CONTROL_IE_Disable_0 $bool = no // Disable interrupts to the system.
  let USBHSDCD_CONTROL_IE_Enable_1 $bool = yes // Enable interrupts to the system.

//--- Enumerated values for register CONTROL, field BC12
  let USBHSDCD_CONTROL_BC12_Compatible_0 $bool = no // Compatible with BC1.1 (default)
  let USBHSDCD_CONTROL_BC12_Compatible_1 $bool = yes // Compatible with BC1.2

//--- Enumerated values for register CONTROL, field START
  let USBHSDCD_CONTROL_START_Do_0 $bool = no // Do not start the sequence. Writes of this value have no effect.
  let USBHSDCD_CONTROL_START_Initiate_1 $bool = yes // Initiate the charger detection sequence. If the sequence is already running, writes of this value have no effect.

//--- Enumerated values for register CONTROL, field SR
  let USBHSDCD_CONTROL_SR_Do_0 $bool = no // Do not perform a software reset.
  let USBHSDCD_CONTROL_SR_Perform_1 $bool = yes // Perform a software reset.

//--- Enumerated values for register CLOCK, field CLOCK_UNIT
  let USBHSDCD_CLOCK_CLOCK_UNIT_kHz_0 $bool = no // kHz Speed (between 1 kHz and 1023 kHz)
  let USBHSDCD_CLOCK_CLOCK_UNIT_MHz_1 $bool = yes // MHz Speed (between 1 MHz and 1023 MHz)

//--- Enumerated values for register STATUS, field SEQ_RES
  let USBHSDCD_STATUS_SEQ_RES_No_00 $u2 = 0 // No results to report.
  let USBHSDCD_STATUS_SEQ_RES_Attached_01 $u2 = 1 // Attached to an SDP. Must comply with USB 2.0 by drawing only 2.5 mA (max) until connected.
  let USBHSDCD_STATUS_SEQ_RES_Attached_10 $u2 = 2 // Attached to a charging port. The exact meaning depends on bit 18: 0: Attached to either a CDP or a DCP. The charger type detection has not completed. 1: Attached to a CDP. The charger type detection has completed.
  let USBHSDCD_STATUS_SEQ_RES_Attached_11 $u2 = 3 // Attached to a DCP.

//--- Enumerated values for register STATUS, field SEQ_STAT
  let USBHSDCD_STATUS_SEQ_STAT_The_00 $u2 = 0 // The module is either not enabled, or the module is enabled but the data pins have not yet been detected.
  let USBHSDCD_STATUS_SEQ_STAT_Data_01 $u2 = 1 // Data pin contact detection is complete.
  let USBHSDCD_STATUS_SEQ_STAT_Charging_10 $u2 = 2 // Charging port detection is complete.
  let USBHSDCD_STATUS_SEQ_STAT_Charger_11 $u2 = 3 // Charger type detection is complete.

//--- Enumerated values for register STATUS, field ERR
  let USBHSDCD_STATUS_ERR_No_0 $bool = no // No sequence errors.
  let USBHSDCD_STATUS_ERR_Error_1 $bool = yes // Error in the detection sequence. See the SEQ_STAT field to determine the phase in which the error occurred.

//--- Enumerated values for register STATUS, field TO
  let USBHSDCD_STATUS_TO_The_0 $bool = no // The detection sequence has not been running for over 1 s.
  let USBHSDCD_STATUS_TO_It_1 $bool = yes // It has been over 1 s since the data pin contact was detected and debounced.

//--- Enumerated values for register STATUS, field ACTIVE
  let USBHSDCD_STATUS_ACTIVE_The_0 $bool = no // The sequence is not running.
  let USBHSDCD_STATUS_ACTIVE_The_1 $bool = yes // The sequence is running.

//--- Enumerated values for register SIGNAL_OVERRIDE, field PS
  let USBHSDCD_SIGNAL_OVERRIDE_PS_No_00 $u2 = 0 // No overrides. Bit field must remain at this value during normal USB data communication to prevent unexpected conditions on USB_DP and USB_DM pins. (Default)
  let USBHSDCD_SIGNAL_OVERRIDE_PS_Reserved__01 $u2 = 1 // Reserved, not for customer use.
  let USBHSDCD_SIGNAL_OVERRIDE_PS_Enables_10 $u2 = 2 // Enables VDP_SRC voltage source for the USB_DP pin and IDM_SINK current source for the USB_DM pin.
  let USBHSDCD_SIGNAL_OVERRIDE_PS_Reserved__11 $u2 = 3 // Reserved, not for customer use.

//------------------------------------------------------------------------------
// Peripheral USBPHY: USBPHY Register Reference Index
//------------------------------------------------------------------------------

registers ©USBPHY @at 0x400a2000 {
//---  Register PWD: USB PHY Power-Down Register
  PWD @offset 0x0 $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register PWD_SET: USB PHY Power-Down Register
  PWD_SET @offset 0x4 $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register PWD_CLR: USB PHY Power-Down Register
  PWD_CLR @offset 0x8 $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register PWD_TOG: USB PHY Power-Down Register
  PWD_TOG @offset 0xc $u32 {
    11
    RXPWDRX // at 20: This bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDDIFF // at 19: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWD1PT1 // at 18: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    RXPWDENV // at 17: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    4
    TXPWDV2I // at 12: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDIBIAS // at 11: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    TXPWDFS // at 10: Note that this bit will be auto cleared if there is USB wakeup event while ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled
    10
  }

//---  Register TX: USB PHY Transmitter Control Register
  TX @offset 0x10 $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register TX_SET: USB PHY Transmitter Control Register
  TX_SET @offset 0x14 $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register TX_CLR: USB PHY Transmitter Control Register
  TX_CLR @offset 0x18 $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register TX_TOG: USB PHY Transmitter Control Register
  TX_TOG @offset 0x1c $u32 {
    3
    USBPHY_TX_EDGECTRL:3 // at 26: Controls the edge-rate of the current sensing transistors used in HS transmit
    6
    TXCAL45DP:4 // at 16: Decode to trim the nominal 45ohm series termination resistance to the USB_DP output pin
    4
    TXCAL45DM:4 // at 8: Decode to trim the nominal 45ohm series termination resistance to the USB_DM output pin
    4
    D_CAL:4 // at 0: Decode to trim the nominal 17
  }

//---  Register RX: USB PHY Receiver Control Register
  RX @offset 0x20 $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register RX_SET: USB PHY Receiver Control Register
  RX_SET @offset 0x24 $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register RX_CLR: USB PHY Receiver Control Register
  RX_CLR @offset 0x28 $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register RX_TOG: USB PHY Receiver Control Register
  RX_TOG @offset 0x2c $u32 {
    9
    RXDBYPASS // at 22: This test mode is intended for lab use only, replace FS differential receiver with DP single ended receiver
    15
    DISCONADJ:3 // at 4: The DISCONADJ field adjusts the trip point for the disconnect detector.
    1
    ENVADJ:3 // at 0: The ENVADJ field adjusts the trip point for the envelope detector
  }

//---  Register CTRL: USB PHY General Control Register
  CTRL @offset 0x30 $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register CTRL_SET: USB PHY General Control Register
  CTRL_SET @offset 0x34 $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register CTRL_CLR: USB PHY General Control Register
  CTRL_CLR @offset 0x38 $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register CTRL_TOG: USB PHY General Control Register
  CTRL_TOG @offset 0x3c $u32 {
    SFTRST // at 31: Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USBPHY_RX, and USBPHY_CTRL registers
    CLKGATE // at 30: Gate UTMI Clocks
    UTMI_SUSPENDM // at 29: Used by the PHY to indicate a powered-down state
    HOST_FORCE_LS_SE0 // at 28: Forces the next FS packet that is transmitted to have a EOP with low-speed timing
    OTG_ID_VALUE // at 27: Indicates the results of USB_ID pin while monitoring the cable plugged into the Micro- or Mini-AB receptacle
    2
    FSDLL_RST_EN // at 24: Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet.
    3
    ENAUTOCLR_PHY_PWD // at 20: Enables the feature to auto-clear the PWD register bits in USBPHY_PWD if there is wakeup event while USB is suspended
    ENAUTOCLR_CLKGATE // at 19: Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended
    AUTORESUME_EN // at 18: Enable the auto resume feature, when set, HW will use 32KHz clock to send Resume to respond to the device remote wakeup(for host mode only)
    2
    ENUTMILEVEL3 // at 15: Enables UTMI+ Level 3 operation for the USB HS PHY
    ENUTMILEVEL2 // at 14: Enables UTMI+ Level 2 operation for the USB HS PHY
    1
    DEVPLUGIN_IRQ // at 12: Indicates that the device is connected
    7
    ENDEVPLUGINDET // at 4: Enables non-standard resistive plugged-in detection
    HOSTDISCONDETECT_IRQ // at 3: Indicates that the device has disconnected in High-Speed mode
    1
    ENHOSTDISCONDETECT // at 1: For host mode, enables high-speed disconnect detector
    1
  }

//---  Register STATUS: USB PHY Status Register
  STATUS @offset 0x40 $u32 {
    21
    RESUME_STATUS // at 10: Indicates that the host is sending a wake-up after Suspend and has triggered an interrupt.
    1
    OTGID_STATUS // at 8: Indicates the results of USB_ID pin on the USB cable plugged into the local Micro- or Mini-AB receptacle
    1
    DEVPLUGIN_STATUS // at 6: Status indicator for non-standard resistive plugged-in detection
    2
    HOSTDISCONDETECT_STATUS // at 3: Indicates at the local host (downstream) port that the remote device has disconnected while in High-Speed mode
    3
  }

//---  Register DEBUG: USB PHY Debug Register
  DEBUG @offset 0x50 $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG_SET: USB PHY Debug Register
  DEBUG_SET @offset 0x54 $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG_CLR: USB PHY Debug Register
  DEBUG_CLR @offset 0x58 $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG_TOG: USB PHY Debug Register
  DEBUG_TOG @offset 0x5c $u32 {
    1
    CLKGATE // at 30: Gate Test Clocks
    HOST_RESUME_DEBUG // at 29: Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1.
    SQUELCHRESETLENGTH:4 // at 25: Duration of RESET in terms of the number of 480-MHz cycles.
    ENSQUELCHRESET // at 24: Set bit to allow squelch to reset high-speed receive.
    3
    SQUELCHRESETCOUNT:5 // at 16: Delay in between the detection of squelch to the reset of high-speed RX.
    3
    ENTX2RXCOUNT // at 12: Set this bit to allow a countdown to transition in between TX and RX.
    TX2RXCOUNT:4 // at 8: Delay in between the end of transmit to the beginning of receive
    2
    ENHSTPULLDOWN:2 // at 4: This bit field selects host pulldown overdrive mode
    HSTPULLDOWN:2 // at 2: This bit field selects whether to connect pulldown resistors on the USB_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabled through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15ohm pulldown on USB_DP line
    DEBUG_INTERFACE_HOLD // at 1: Use holding registers to assist in timing for external UTMI interface.
    OTGIDPIOLOCK // at 0: Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to hold the value
  }

//---  Register DEBUG0_STATUS: UTMI Debug Status Register 0
  DEBUG0_STATUS @offset 0x60 @ro $u32 {
    SQUELCH_COUNT:6 // at 26: Running count of the squelch reset instead of normal end for HS RX.
    UTMI_RXERROR_FAIL_COUNT:10 // at 16: Running count of the UTMI_RXERROR.
    LOOP_BACK_FAIL_COUNT:16 // at 0: Running count of the failed pseudo-random generator loopback
  }

//---  Register DEBUG1: UTMI Debug Status Register 1
  DEBUG1 @offset 0x70 $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register DEBUG1_SET: UTMI Debug Status Register 1
  DEBUG1_SET @offset 0x74 $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register DEBUG1_CLR: UTMI Debug Status Register 1
  DEBUG1_CLR @offset 0x78 $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register DEBUG1_TOG: UTMI Debug Status Register 1
  DEBUG1_TOG @offset 0x7c $u32 {
    17
    ENTAILADJVD:2 // at 13: Delay increment of the rise of squelch:
    13
  }

//---  Register VERSION: UTMI RTL Version
  VERSION @offset 0x80 @ro $u32 {
    MAJOR:8 // at 24: Fixed read-only value reflecting the MAJOR field of the RTL version.
    MINOR:8 // at 16: Fixed read-only value reflecting the MINOR field of the RTL version.
    STEP:16 // at 0: Fixed read-only value reflecting the stepping of the RTL version.
  }

//---  Register PLL_SIC: USB PHY PLL Control/Status Register
  PLL_SIC @offset 0xa0 $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register PLL_SIC_SET: USB PHY PLL Control/Status Register
  PLL_SIC_SET @offset 0xa4 $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register PLL_SIC_CLR: USB PHY PLL Control/Status Register
  PLL_SIC_CLR @offset 0xa8 $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register PLL_SIC_TOG: USB PHY PLL Control/Status Register
  PLL_SIC_TOG @offset 0xac $u32 {
    PLL_LOCK // at 31: USB PLL lock status indicator
    14
    PLL_BYPASS // at 16: Bypass the USB PLL.
    2
    PLL_ENABLE // at 13: Enable the clock output from the USB PLL.
    PLL_POWER // at 12: Power up the USB PLL.
    PLL_HOLD_RING_OFF // at 11: Analog debug bit
    4
    PLL_EN_USB_CLKS // at 6: Enable the USB clock output from the USB PHY PLL.
    4
    PLL_DIV_SEL:2 // at 0: This field controls the USB PLL feedback loop divider
  }

//---  Register USB1_VBUS_DETECT: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT @offset 0xc0 $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DETECT_SET: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT_SET @offset 0xc4 $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DETECT_CLR: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT_CLR @offset 0xc8 $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DETECT_TOG: USB PHY VBUS Detect Control Register
  USB1_VBUS_DETECT_TOG @offset 0xcc $u32 {
    EN_CHARGER_RESISTOR // at 31: Enables resistors used for an older method of resistive battery charger detection
    4
    DISCHARGE_VBUS // at 26: Controls VBUS discharge resistor
    5
    PWRUP_CMPS // at 20: Enables the VBUS_VALID comparator
    1
    VBUSVALID_TO_SESSVALID // at 18: Selects the comparator used for VBUS_VALID
    7
    VBUS_SOURCE_SEL:2 // at 9: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_SEL // at 8: Selects the source of the VBUS_VALID signal reported to the USB controller
    VBUSVALID_OVERRIDE // at 7: Override value for VBUS_VALID signal sent to USB controller
    AVALID_OVERRIDE // at 6: Override value for A-Device Session Valid
    BVALID_OVERRIDE // at 5: Override value for B-Device Session Valid
    SESSEND_OVERRIDE // at 4: Override value for SESSEND
    VBUS_OVERRIDE_EN // at 3: VBUS detect signal override enable
    VBUSVALID_THRESH:3 // at 0: Sets the threshold for the VBUSVALID comparator
  }

//---  Register USB1_VBUS_DET_STAT: USB PHY VBUS Detector Status Register
  USB1_VBUS_DET_STAT @offset 0xd0 @ro $u32 {
    27
    VBUS_VALID_3V // at 4: VBUS_VALID_3V detector status
    VBUS_VALID // at 3: VBUS voltage status
    AVALID // at 2: A-Device Session Valid status
    BVALID // at 1: B-Device Session Valid status
    SESSEND // at 0: Session End indicator
  }

//---  Register USB1_CHRG_DET_STAT: USB PHY Charger Detect Status Register
  USB1_CHRG_DET_STAT @offset 0xf0 @ro $u32 {
    27
    SECDET_DCP // at 4: Battery Charging Secondary Detection phase output
    DP_STATE // at 3: Single ended receiver output for the USB_DP pin, from charger detection circuits.
    DM_STATE // at 2: Single ended receiver output for the USB_DM pin, from charger detection circuits.
    CHRG_DETECTED // at 1: Battery Charging Primary Detection phase output
    PLUG_CONTACT // at 0: Battery Charging Data Contact Detection phase output
  }

//---  Register ANACTRL: USB PHY Analog Control Register
  ANACTRL @offset 0x100 $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register ANACTRL_SET: USB PHY Analog Control Register
  ANACTRL_SET @offset 0x104 $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register ANACTRL_CLR: USB PHY Analog Control Register
  ANACTRL_CLR @offset 0x108 $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register ANACTRL_TOG: USB PHY Analog Control Register
  ANACTRL_TOG @offset 0x10c $u32 {
    PFD_STABLE // at 31: PFD stable signal from the Phase Fractional Divider.
    15
    EMPH_CUR_CTRL:2 // at 14: Controls the amount of pre-emphasis current added for the High-Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    EMPH_EN // at 13: Enables pre-emphasis for the High-Speed TX drivers
    EMPH_PULSE_CTRL:2 // at 11: Controls pre-emphasis time duration for the High Speed TX drivers after each data transition when the USBPHY_ANACTRL[EMPH_EN] bit is set high to 1'b1
    DEV_PULLDOWN // at 10: Setting this field to 1'b1 will enable the 15kohm pulldown resistors on both USB_DP and USB_DM pins
    PFD_FRAC:6 // at 4: PFD fractional divider setting used to select the pfd_clk output frequency
    PFD_CLK_SEL:2 // at 2: This bit field for the PFD selects the frequency relationship between the local pfd_clk output and the exported USB1PFDCLK
    PFD_CLKGATE // at 1: This bit field controls clock gating (disabling) for the PFD pfd_clk output for power savings when the PFD is not used
    TESTCLK_SEL // at 0: Test clock selection to analog test
  }

//---  Register USB1_LOOPBACK: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK @offset 0x110 $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_SET: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK_SET @offset 0x114 $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_CLR: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK_CLR @offset 0x118 $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_TOG: USB PHY Loopback Control/Status Register
  USB1_LOOPBACK_TOG @offset 0x11c $u32 {
    8
    TSTPKT:8 // at 16: Selects the packet data byte used for USB loopback testing in Pulse mode
    TSTI_HSFS_MODE_EN // at 15: Setting this bit field to value 1'b1 will enable the loopback test to dynamically change the packet speed
    6
    UTMO_DIG_TST1 // at 8: This read-only bit is a status bit for USB loopback test
    UTMO_DIG_TST0 // at 7: This read-only bit is a status bit for USB loopback test results
    TSTI_TX_HIZ // at 6: Sets TX Hi-Z for USB loopback test.
    TSTI_TX_EN // at 5: Enable TX for USB loopback test.
    TSTI_TX_LS_MODE // at 4: Set to value 1'b1 to choose LS for USB loopback testing, set to value 1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS
    TSTI_TX_HS_MODE // at 3: Select HS or FS mode for USB loopback testing
    UTMI_DIG_TST1 // at 2: Mode control for USB loopback test
    UTMI_DIG_TST0 // at 1: Mode control for USB loopback test
    UTMI_TESTSTART // at 0: This bit enables the USB loopback test.
  }

//---  Register USB1_LOOPBACK_HSFSCNT: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT @offset 0x120 $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register USB1_LOOPBACK_HSFSCNT_SET: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT_SET @offset 0x124 $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register USB1_LOOPBACK_HSFSCNT_CLR: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT_CLR @offset 0x128 $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register USB1_LOOPBACK_HSFSCNT_TOG: USB PHY Loopback Packet Number Select Register
  USB1_LOOPBACK_HSFSCNT_TOG @offset 0x12c $u32 {
    TSTI_FS_NUMBER:16 // at 16: Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
    TSTI_HS_NUMBER:16 // at 0: High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MODE_EN] is set to value 1'b1.
  }

//---  Register TRIM_OVERRIDE_EN: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN @offset 0x130 $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

//---  Register TRIM_OVERRIDE_EN_SET: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN_SET @offset 0x134 $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

//---  Register TRIM_OVERRIDE_EN_CLR: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN_CLR @offset 0x138 $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

//---  Register TRIM_OVERRIDE_EN_TOG: USB PHY Trim Override Enable Register
  TRIM_OVERRIDE_EN_TOG @offset 0x13c $u32 {
    TRIM_USBPHY_TX_CAL45DM:4 // at 28: IFR value of TX_CAL45DM.
    TRIM_USBPHY_TX_CAL45DP:4 // at 24: IFR value of TX_CAL45DP.
    TRIM_USBPHY_TX_D_CAL:4 // at 20: IFR value of TX_D_CAL.
    TRIM_USB_REG_ENV_TAIL_ADJ_VD:2 // at 18: IFR value of ENV_TAIL_ADJ.
    TRIM_PLL_CTRL0_DIV_SEL:2 // at 16: IFR value of PLL_DIV_SEL.
    11
    TRIM_TX_CAL45DM_OVERRIDE // at 4: Override enable for TX_CAL45DM, when set, the register value in USBPHY_TX[11:8] will be used.
    TRIM_TX_CAL45DP_OVERRIDE // at 3: Override enable for TX_CAL45DP, when set, the register value in USBPHY_TX[19:16] will be used.
    TRIM_TX_D_CAL_OVERRIDE // at 2: Override enable for TX_D_CAL, when set, the register value in USBPHY_TX[3:0] will be used.
    TRIM_ENV_TAIL_ADJ_VD_OVERRIDE // at 1: Override enable for ENV_TAIL_ADJ, when set, the register value in USBPHY_DEBUG1[14:13] will be used
    TRIM_DIV_SEL_OVERRIDE // at 0: Override enable for PLL_DIV_SEL, when set, the register value in USBPHY_PLL_SIC[1:0] will be used.
  }

}

//--- Enumerated values for register PWD, field TXPWDFS
  let USBPHY_PWD_TXPWDFS_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_TXPWDFS_Power_down_1 $bool = yes // Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output

//--- Enumerated values for register PWD, field TXPWDIBIAS
  let USBPHY_PWD_TXPWDIBIAS_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_TXPWDIBIAS_Power_down_1 $bool = yes // Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path

//--- Enumerated values for register PWD, field TXPWDV2I
  let USBPHY_PWD_TXPWDV2I_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_TXPWDV2I_Power_down_1 $bool = yes // Power-down the USB PHY transmit V-to-I converter and the current mirror

//--- Enumerated values for register PWD, field RXPWDENV
  let USBPHY_PWD_RXPWDENV_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_RXPWDENV_Power_down_1 $bool = yes // Power-down the USB high-speed receiver envelope detector (squelch signal)

//--- Enumerated values for register PWD, field RXPWD1PT1
  let USBPHY_PWD_RXPWD1PT1_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_RXPWD1PT1_Power_down_1 $bool = yes // Power-down the USB full-speed differential receiver.

//--- Enumerated values for register PWD, field RXPWDDIFF
  let USBPHY_PWD_RXPWDDIFF_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_RXPWDDIFF_Power_down_1 $bool = yes // Power-down the USB high-speed differential receiver

//--- Enumerated values for register PWD, field RXPWDRX
  let USBPHY_PWD_RXPWDRX_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_RXPWDRX_Power_down_1 $bool = yes // Power-down the entire USB PHY receiver block except for the full-speed differential receiver

//--- Enumerated values for register PWD_SET, field TXPWDFS
  let USBPHY_PWD_SET_TXPWDFS_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_SET_TXPWDFS_Power_down_1 $bool = yes // Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output

//--- Enumerated values for register PWD_SET, field TXPWDIBIAS
  let USBPHY_PWD_SET_TXPWDIBIAS_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_SET_TXPWDIBIAS_Power_down_1 $bool = yes // Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path

//--- Enumerated values for register PWD_SET, field TXPWDV2I
  let USBPHY_PWD_SET_TXPWDV2I_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_SET_TXPWDV2I_Power_down_1 $bool = yes // Power-down the USB PHY transmit V-to-I converter and the current mirror

//--- Enumerated values for register PWD_SET, field RXPWDENV
  let USBPHY_PWD_SET_RXPWDENV_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_SET_RXPWDENV_Power_down_1 $bool = yes // Power-down the USB high-speed receiver envelope detector (squelch signal)

//--- Enumerated values for register PWD_SET, field RXPWD1PT1
  let USBPHY_PWD_SET_RXPWD1PT1_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_SET_RXPWD1PT1_Power_down_1 $bool = yes // Power-down the USB full-speed differential receiver.

//--- Enumerated values for register PWD_SET, field RXPWDDIFF
  let USBPHY_PWD_SET_RXPWDDIFF_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_SET_RXPWDDIFF_Power_down_1 $bool = yes // Power-down the USB high-speed differential receiver

//--- Enumerated values for register PWD_SET, field RXPWDRX
  let USBPHY_PWD_SET_RXPWDRX_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_SET_RXPWDRX_Power_down_1 $bool = yes // Power-down the entire USB PHY receiver block except for the full-speed differential receiver

//--- Enumerated values for register PWD_CLR, field TXPWDFS
  let USBPHY_PWD_CLR_TXPWDFS_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_CLR_TXPWDFS_Power_down_1 $bool = yes // Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output

//--- Enumerated values for register PWD_CLR, field TXPWDIBIAS
  let USBPHY_PWD_CLR_TXPWDIBIAS_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_CLR_TXPWDIBIAS_Power_down_1 $bool = yes // Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path

//--- Enumerated values for register PWD_CLR, field TXPWDV2I
  let USBPHY_PWD_CLR_TXPWDV2I_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_CLR_TXPWDV2I_Power_down_1 $bool = yes // Power-down the USB PHY transmit V-to-I converter and the current mirror

//--- Enumerated values for register PWD_CLR, field RXPWDENV
  let USBPHY_PWD_CLR_RXPWDENV_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_CLR_RXPWDENV_Power_down_1 $bool = yes // Power-down the USB high-speed receiver envelope detector (squelch signal)

//--- Enumerated values for register PWD_CLR, field RXPWD1PT1
  let USBPHY_PWD_CLR_RXPWD1PT1_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_CLR_RXPWD1PT1_Power_down_1 $bool = yes // Power-down the USB full-speed differential receiver.

//--- Enumerated values for register PWD_CLR, field RXPWDDIFF
  let USBPHY_PWD_CLR_RXPWDDIFF_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_CLR_RXPWDDIFF_Power_down_1 $bool = yes // Power-down the USB high-speed differential receiver

//--- Enumerated values for register PWD_CLR, field RXPWDRX
  let USBPHY_PWD_CLR_RXPWDRX_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_CLR_RXPWDRX_Power_down_1 $bool = yes // Power-down the entire USB PHY receiver block except for the full-speed differential receiver

//--- Enumerated values for register PWD_TOG, field TXPWDFS
  let USBPHY_PWD_TOG_TXPWDFS_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_TOG_TXPWDFS_Power_down_1 $bool = yes // Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output

//--- Enumerated values for register PWD_TOG, field TXPWDIBIAS
  let USBPHY_PWD_TOG_TXPWDIBIAS_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_TOG_TXPWDIBIAS_Power_down_1 $bool = yes // Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path

//--- Enumerated values for register PWD_TOG, field TXPWDV2I
  let USBPHY_PWD_TOG_TXPWDV2I_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_TOG_TXPWDV2I_Power_down_1 $bool = yes // Power-down the USB PHY transmit V-to-I converter and the current mirror

//--- Enumerated values for register PWD_TOG, field RXPWDENV
  let USBPHY_PWD_TOG_RXPWDENV_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_TOG_RXPWDENV_Power_down_1 $bool = yes // Power-down the USB high-speed receiver envelope detector (squelch signal)

//--- Enumerated values for register PWD_TOG, field RXPWD1PT1
  let USBPHY_PWD_TOG_RXPWD1PT1_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_TOG_RXPWD1PT1_Power_down_1 $bool = yes // Power-down the USB full-speed differential receiver.

//--- Enumerated values for register PWD_TOG, field RXPWDDIFF
  let USBPHY_PWD_TOG_RXPWDDIFF_Normal_0 $bool = no // Normal operation.
  let USBPHY_PWD_TOG_RXPWDDIFF_Power_down_1 $bool = yes // Power-down the USB high-speed differential receiver

//--- Enumerated values for register PWD_TOG, field RXPWDRX
  let USBPHY_PWD_TOG_RXPWDRX_Normal_0 $bool = no // Normal operation
  let USBPHY_PWD_TOG_RXPWDRX_Power_down_1 $bool = yes // Power-down the entire USB PHY receiver block except for the full-speed differential receiver

//--- Enumerated values for register TX, field D_CAL
  let USBPHY_TX_D_CAL_Maximum_0000 $u4 = 0 // Maximum current, approximately 19% above nominal.
  let USBPHY_TX_D_CAL_Nominal_0111 $u4 = 7 // Nominal
  let USBPHY_TX_D_CAL_Minimum_1111 $u4 = 15 // Minimum current, approximately 19% below nominal.

//--- Enumerated values for register TX_SET, field D_CAL
  let USBPHY_TX_SET_D_CAL_Maximum_0000 $u4 = 0 // Maximum current, approximately 19% above nominal.
  let USBPHY_TX_SET_D_CAL_Nominal_0111 $u4 = 7 // Nominal
  let USBPHY_TX_SET_D_CAL_Minimum_1111 $u4 = 15 // Minimum current, approximately 19% below nominal.

//--- Enumerated values for register TX_CLR, field D_CAL
  let USBPHY_TX_CLR_D_CAL_Maximum_0000 $u4 = 0 // Maximum current, approximately 19% above nominal.
  let USBPHY_TX_CLR_D_CAL_Nominal_0111 $u4 = 7 // Nominal
  let USBPHY_TX_CLR_D_CAL_Minimum_1111 $u4 = 15 // Minimum current, approximately 19% below nominal.

//--- Enumerated values for register TX_TOG, field D_CAL
  let USBPHY_TX_TOG_D_CAL_Maximum_0000 $u4 = 0 // Maximum current, approximately 19% above nominal.
  let USBPHY_TX_TOG_D_CAL_Nominal_0111 $u4 = 7 // Nominal
  let USBPHY_TX_TOG_D_CAL_Minimum_1111 $u4 = 15 // Minimum current, approximately 19% below nominal.

//--- Enumerated values for register RX, field ENVADJ
  let USBPHY_RX_ENVADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.1000 V
  let USBPHY_RX_ENVADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.1125 V
  let USBPHY_RX_ENVADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.1250 V
  let USBPHY_RX_ENVADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.0875 V

//--- Enumerated values for register RX, field DISCONADJ
  let USBPHY_RX_DISCONADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.56875 V
  let USBPHY_RX_DISCONADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.55000 V
  let USBPHY_RX_DISCONADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.58125 V
  let USBPHY_RX_DISCONADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.60000 V

//--- Enumerated values for register RX, field RXDBYPASS
  let USBPHY_RX_RXDBYPASS_Normal_0 $bool = no // Normal operation.
  let USBPHY_RX_RXDBYPASS_Use_1 $bool = yes // Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver

//--- Enumerated values for register RX_SET, field ENVADJ
  let USBPHY_RX_SET_ENVADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.1000 V
  let USBPHY_RX_SET_ENVADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.1125 V
  let USBPHY_RX_SET_ENVADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.1250 V
  let USBPHY_RX_SET_ENVADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.0875 V

//--- Enumerated values for register RX_SET, field DISCONADJ
  let USBPHY_RX_SET_DISCONADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.56875 V
  let USBPHY_RX_SET_DISCONADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.55000 V
  let USBPHY_RX_SET_DISCONADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.58125 V
  let USBPHY_RX_SET_DISCONADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.60000 V

//--- Enumerated values for register RX_SET, field RXDBYPASS
  let USBPHY_RX_SET_RXDBYPASS_Normal_0 $bool = no // Normal operation.
  let USBPHY_RX_SET_RXDBYPASS_Use_1 $bool = yes // Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver

//--- Enumerated values for register RX_CLR, field ENVADJ
  let USBPHY_RX_CLR_ENVADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.1000 V
  let USBPHY_RX_CLR_ENVADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.1125 V
  let USBPHY_RX_CLR_ENVADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.1250 V
  let USBPHY_RX_CLR_ENVADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.0875 V

//--- Enumerated values for register RX_CLR, field DISCONADJ
  let USBPHY_RX_CLR_DISCONADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.56875 V
  let USBPHY_RX_CLR_DISCONADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.55000 V
  let USBPHY_RX_CLR_DISCONADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.58125 V
  let USBPHY_RX_CLR_DISCONADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.60000 V

//--- Enumerated values for register RX_CLR, field RXDBYPASS
  let USBPHY_RX_CLR_RXDBYPASS_Normal_0 $bool = no // Normal operation.
  let USBPHY_RX_CLR_RXDBYPASS_Use_1 $bool = yes // Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver

//--- Enumerated values for register RX_TOG, field ENVADJ
  let USBPHY_RX_TOG_ENVADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.1000 V
  let USBPHY_RX_TOG_ENVADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.1125 V
  let USBPHY_RX_TOG_ENVADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.1250 V
  let USBPHY_RX_TOG_ENVADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.0875 V

//--- Enumerated values for register RX_TOG, field DISCONADJ
  let USBPHY_RX_TOG_DISCONADJ_Trip_Level_000 $u3 = 0 // Trip-Level Voltage is 0.56875 V
  let USBPHY_RX_TOG_DISCONADJ_Trip_Level_001 $u3 = 1 // Trip-Level Voltage is 0.55000 V
  let USBPHY_RX_TOG_DISCONADJ_Trip_Level_010 $u3 = 2 // Trip-Level Voltage is 0.58125 V
  let USBPHY_RX_TOG_DISCONADJ_Trip_Level_011 $u3 = 3 // Trip-Level Voltage is 0.60000 V

//--- Enumerated values for register RX_TOG, field RXDBYPASS
  let USBPHY_RX_TOG_RXDBYPASS_Normal_0 $bool = no // Normal operation.
  let USBPHY_RX_TOG_RXDBYPASS_Use_1 $bool = yes // Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver

//--- Enumerated values for register CTRL, field ENDEVPLUGINDET
  let USBPHY_CTRL_ENDEVPLUGINDET_Disables_0 $bool = no // Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
  let USBPHY_CTRL_ENDEVPLUGINDET_Enables_1 $bool = yes // Enables 200kohm pullup resistors on USB_DP and USB_DM pins

//--- Enumerated values for register CTRL_SET, field ENDEVPLUGINDET
  let USBPHY_CTRL_SET_ENDEVPLUGINDET_Disables_0 $bool = no // Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
  let USBPHY_CTRL_SET_ENDEVPLUGINDET_Enables_1 $bool = yes // Enables 200kohm pullup resistors on USB_DP and USB_DM pins

//--- Enumerated values for register CTRL_CLR, field ENDEVPLUGINDET
  let USBPHY_CTRL_CLR_ENDEVPLUGINDET_Disables_0 $bool = no // Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
  let USBPHY_CTRL_CLR_ENDEVPLUGINDET_Enables_1 $bool = yes // Enables 200kohm pullup resistors on USB_DP and USB_DM pins

//--- Enumerated values for register CTRL_TOG, field ENDEVPLUGINDET
  let USBPHY_CTRL_TOG_ENDEVPLUGINDET_Disables_0 $bool = no // Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
  let USBPHY_CTRL_TOG_ENDEVPLUGINDET_Enables_1 $bool = yes // Enables 200kohm pullup resistors on USB_DP and USB_DM pins

//--- Enumerated values for register STATUS, field HOSTDISCONDETECT_STATUS
  let USBPHY_STATUS_HOSTDISCONDETECT_STATUS_USB_0 $bool = no // USB cable disconnect has not been detected at the local host
  let USBPHY_STATUS_HOSTDISCONDETECT_STATUS_USB_1 $bool = yes // USB cable disconnect has been detected at the local host

//--- Enumerated values for register STATUS, field DEVPLUGIN_STATUS
  let USBPHY_STATUS_DEVPLUGIN_STATUS_No_0 $bool = no // No attachment to a USB host is detected
  let USBPHY_STATUS_DEVPLUGIN_STATUS_Cable_1 $bool = yes // Cable attachment to a USB host is detected

//--- Enumerated values for register DEBUG1, field ENTAILADJVD
  let USBPHY_DEBUG1_ENTAILADJVD_Delay_00 $u2 = 0 // Delay is nominal
  let USBPHY_DEBUG1_ENTAILADJVD_Delay_01 $u2 = 1 // Delay is +20%
  let USBPHY_DEBUG1_ENTAILADJVD_Delay_10 $u2 = 2 // Delay is -20%
  let USBPHY_DEBUG1_ENTAILADJVD_Delay_11 $u2 = 3 // Delay is -40%

//--- Enumerated values for register DEBUG1_SET, field ENTAILADJVD
  let USBPHY_DEBUG1_SET_ENTAILADJVD_Delay_00 $u2 = 0 // Delay is nominal
  let USBPHY_DEBUG1_SET_ENTAILADJVD_Delay_01 $u2 = 1 // Delay is +20%
  let USBPHY_DEBUG1_SET_ENTAILADJVD_Delay_10 $u2 = 2 // Delay is -20%
  let USBPHY_DEBUG1_SET_ENTAILADJVD_Delay_11 $u2 = 3 // Delay is -40%

//--- Enumerated values for register DEBUG1_CLR, field ENTAILADJVD
  let USBPHY_DEBUG1_CLR_ENTAILADJVD_Delay_00 $u2 = 0 // Delay is nominal
  let USBPHY_DEBUG1_CLR_ENTAILADJVD_Delay_01 $u2 = 1 // Delay is +20%
  let USBPHY_DEBUG1_CLR_ENTAILADJVD_Delay_10 $u2 = 2 // Delay is -20%
  let USBPHY_DEBUG1_CLR_ENTAILADJVD_Delay_11 $u2 = 3 // Delay is -40%

//--- Enumerated values for register DEBUG1_TOG, field ENTAILADJVD
  let USBPHY_DEBUG1_TOG_ENTAILADJVD_Delay_00 $u2 = 0 // Delay is nominal
  let USBPHY_DEBUG1_TOG_ENTAILADJVD_Delay_01 $u2 = 1 // Delay is +20%
  let USBPHY_DEBUG1_TOG_ENTAILADJVD_Delay_10 $u2 = 2 // Delay is -20%
  let USBPHY_DEBUG1_TOG_ENTAILADJVD_Delay_11 $u2 = 3 // Delay is -40%

//--- Enumerated values for register PLL_SIC, field PLL_DIV_SEL
  let USBPHY_PLL_SIC_PLL_DIV_SEL_PLL_00 $u2 = 0 // PLL reference frequency = 24MHz
  let USBPHY_PLL_SIC_PLL_DIV_SEL_PLL_01 $u2 = 1 // PLL reference frequency = 16MHz
  let USBPHY_PLL_SIC_PLL_DIV_SEL_PLL_1X $u2 = 2 // PLL reference frequency = 12MHz

//--- Enumerated values for register PLL_SIC, field PLL_LOCK
  let USBPHY_PLL_SIC_PLL_LOCK_PLL_0 $bool = no // PLL is not currently locked
  let USBPHY_PLL_SIC_PLL_LOCK_PLL_1 $bool = yes // PLL is currently locked

//--- Enumerated values for register PLL_SIC_SET, field PLL_DIV_SEL
  let USBPHY_PLL_SIC_SET_PLL_DIV_SEL_PLL_00 $u2 = 0 // PLL reference frequency = 24MHz
  let USBPHY_PLL_SIC_SET_PLL_DIV_SEL_PLL_01 $u2 = 1 // PLL reference frequency = 16MHz
  let USBPHY_PLL_SIC_SET_PLL_DIV_SEL_PLL_1X $u2 = 2 // PLL reference frequency = 12MHz

//--- Enumerated values for register PLL_SIC_SET, field PLL_LOCK
  let USBPHY_PLL_SIC_SET_PLL_LOCK_PLL_0 $bool = no // PLL is not currently locked
  let USBPHY_PLL_SIC_SET_PLL_LOCK_PLL_1 $bool = yes // PLL is currently locked

//--- Enumerated values for register PLL_SIC_CLR, field PLL_DIV_SEL
  let USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_PLL_00 $u2 = 0 // PLL reference frequency = 24MHz
  let USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_PLL_01 $u2 = 1 // PLL reference frequency = 16MHz
  let USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_PLL_1X $u2 = 2 // PLL reference frequency = 12MHz

//--- Enumerated values for register PLL_SIC_CLR, field PLL_LOCK
  let USBPHY_PLL_SIC_CLR_PLL_LOCK_PLL_0 $bool = no // PLL is not currently locked
  let USBPHY_PLL_SIC_CLR_PLL_LOCK_PLL_1 $bool = yes // PLL is currently locked

//--- Enumerated values for register PLL_SIC_TOG, field PLL_DIV_SEL
  let USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_PLL_00 $u2 = 0 // PLL reference frequency = 24MHz
  let USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_PLL_01 $u2 = 1 // PLL reference frequency = 16MHz
  let USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_PLL_1X $u2 = 2 // PLL reference frequency = 12MHz

//--- Enumerated values for register PLL_SIC_TOG, field PLL_LOCK
  let USBPHY_PLL_SIC_TOG_PLL_LOCK_PLL_0 $bool = no // PLL is not currently locked
  let USBPHY_PLL_SIC_TOG_PLL_LOCK_PLL_1 $bool = yes // PLL is currently locked

//--- Enumerated values for register USB1_VBUS_DETECT, field VBUSVALID_THRESH
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_0_000 $u3 = 0 // 4.0 V
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_1_001 $u3 = 1 // 4.1 V
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_2_010 $u3 = 2 // 4.2 V
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_3_011 $u3 = 3 // 4.3 V
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_4_100 $u3 = 4 // 4.4 V (Default)
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_5_101 $u3 = 5 // 4.5 V
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_6_110 $u3 = 6 // 4.6 V
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_4_7_111 $u3 = 7 // 4.7 V

//--- Enumerated values for register USB1_VBUS_DETECT, field VBUS_OVERRIDE_EN
  let USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN_Use_0 $bool = no // Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
  let USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN_Use_1 $bool = yes // Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND

//--- Enumerated values for register USB1_VBUS_DETECT, field VBUSVALID_SEL
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL_Use_0 $bool = no // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL_Use_1 $bool = yes // Use the VBUS_VALID_3V detector results for signal reported to the USB controller

//--- Enumerated values for register USB1_VBUS_DETECT, field VBUS_SOURCE_SEL
  let USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_Use_00 $u2 = 0 // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_Use_01 $u2 = 1 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_Use_10 $u2 = 2 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_Reserved__11 $u2 = 3 // Reserved, do not use

//--- Enumerated values for register USB1_VBUS_DETECT, field VBUSVALID_TO_SESSVALID
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID_Use_0 $bool = no // Use the VBUS_VALID comparator for VBUS_VALID results
  let USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID_Use_1 $bool = yes // Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.

//--- Enumerated values for register USB1_VBUS_DETECT, field PWRUP_CMPS
  let USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS_Powers_0 $bool = no // Powers down the VBUS_VALID comparator
  let USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS_Enables_1 $bool = yes // Enables the VBUS_VALID comparator (default)

//--- Enumerated values for register USB1_VBUS_DETECT, field DISCHARGE_VBUS
  let USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS_VBUS_0 $bool = no // VBUS discharge resistor is disabled (Default)
  let USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS_VBUS_1 $bool = yes // VBUS discharge resistor is enabled

//--- Enumerated values for register USB1_VBUS_DETECT, field EN_CHARGER_RESISTOR
  let USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR_Disable_0 $bool = no // Disable resistive charger detection resistors on USB_DP and USB_DP
  let USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR_Enable_1 $bool = yes // Enable resistive charger detection resistors on USB_DP and USB_DP

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field VBUSVALID_THRESH
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_0_000 $u3 = 0 // 4.0 V
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_1_001 $u3 = 1 // 4.1 V
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_2_010 $u3 = 2 // 4.2 V
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_3_011 $u3 = 3 // 4.3 V
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_4_100 $u3 = 4 // 4.4 V (Default)
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_5_101 $u3 = 5 // 4.5 V
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_6_110 $u3 = 6 // 4.6 V
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4_7_111 $u3 = 7 // 4.7 V

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field VBUS_OVERRIDE_EN
  let USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN_Use_0 $bool = no // Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
  let USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN_Use_1 $bool = yes // Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field VBUSVALID_SEL
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL_Use_0 $bool = no // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL_Use_1 $bool = yes // Use the VBUS_VALID_3V detector results for signal reported to the USB controller

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field VBUS_SOURCE_SEL
  let USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_Use_00 $u2 = 0 // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_Use_01 $u2 = 1 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_Use_10 $u2 = 2 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_Reserved__11 $u2 = 3 // Reserved, do not use

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field VBUSVALID_TO_SESSVALID
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID_Use_0 $bool = no // Use the VBUS_VALID comparator for VBUS_VALID results
  let USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID_Use_1 $bool = yes // Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field PWRUP_CMPS
  let USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS_Powers_0 $bool = no // Powers down the VBUS_VALID comparator
  let USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS_Enables_1 $bool = yes // Enables the VBUS_VALID comparator (default)

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field DISCHARGE_VBUS
  let USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_VBUS_0 $bool = no // VBUS discharge resistor is disabled (Default)
  let USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_VBUS_1 $bool = yes // VBUS discharge resistor is enabled

//--- Enumerated values for register USB1_VBUS_DETECT_SET, field EN_CHARGER_RESISTOR
  let USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR_Disable_0 $bool = no // Disable resistive charger detection resistors on USB_DP and USB_DP
  let USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR_Enable_1 $bool = yes // Enable resistive charger detection resistors on USB_DP and USB_DP

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field VBUSVALID_THRESH
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_0_000 $u3 = 0 // 4.0 V
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_1_001 $u3 = 1 // 4.1 V
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_2_010 $u3 = 2 // 4.2 V
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_3_011 $u3 = 3 // 4.3 V
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_4_100 $u3 = 4 // 4.4 V (Default)
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_5_101 $u3 = 5 // 4.5 V
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_6_110 $u3 = 6 // 4.6 V
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4_7_111 $u3 = 7 // 4.7 V

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field VBUS_OVERRIDE_EN
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN_Use_0 $bool = no // Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN_Use_1 $bool = yes // Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field VBUSVALID_SEL
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL_Use_0 $bool = no // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL_Use_1 $bool = yes // Use the VBUS_VALID_3V detector results for signal reported to the USB controller

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field VBUS_SOURCE_SEL
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_Use_00 $u2 = 0 // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_Use_01 $u2 = 1 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_Use_10 $u2 = 2 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_Reserved__11 $u2 = 3 // Reserved, do not use

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field VBUSVALID_TO_SESSVALID
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID_Use_0 $bool = no // Use the VBUS_VALID comparator for VBUS_VALID results
  let USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID_Use_1 $bool = yes // Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field PWRUP_CMPS
  let USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS_Powers_0 $bool = no // Powers down the VBUS_VALID comparator
  let USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS_Enables_1 $bool = yes // Enables the VBUS_VALID comparator (default)

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field DISCHARGE_VBUS
  let USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_VBUS_0 $bool = no // VBUS discharge resistor is disabled (Default)
  let USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_VBUS_1 $bool = yes // VBUS discharge resistor is enabled

//--- Enumerated values for register USB1_VBUS_DETECT_CLR, field EN_CHARGER_RESISTOR
  let USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR_Disable_0 $bool = no // Disable resistive charger detection resistors on USB_DP and USB_DP
  let USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR_Enable_1 $bool = yes // Enable resistive charger detection resistors on USB_DP and USB_DP

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field VBUSVALID_THRESH
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_0_000 $u3 = 0 // 4.0 V
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_1_001 $u3 = 1 // 4.1 V
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_2_010 $u3 = 2 // 4.2 V
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_3_011 $u3 = 3 // 4.3 V
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_4_100 $u3 = 4 // 4.4 V (Default)
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_5_101 $u3 = 5 // 4.5 V
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_6_110 $u3 = 6 // 4.6 V
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4_7_111 $u3 = 7 // 4.7 V

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field VBUS_OVERRIDE_EN
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN_Use_0 $bool = no // Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN_Use_1 $bool = yes // Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field VBUSVALID_SEL
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL_Use_0 $bool = no // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL_Use_1 $bool = yes // Use the VBUS_VALID_3V detector results for signal reported to the USB controller

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field VBUS_SOURCE_SEL
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_Use_00 $u2 = 0 // Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_Use_01 $u2 = 1 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_Use_10 $u2 = 2 // Use the Session Valid comparator results for signal reported to the USB controller
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_Reserved__11 $u2 = 3 // Reserved, do not use

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field VBUSVALID_TO_SESSVALID
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID_Use_0 $bool = no // Use the VBUS_VALID comparator for VBUS_VALID results
  let USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID_Use_1 $bool = yes // Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field PWRUP_CMPS
  let USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS_Powers_0 $bool = no // Powers down the VBUS_VALID comparator
  let USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS_Enables_1 $bool = yes // Enables the VBUS_VALID comparator (default)

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field DISCHARGE_VBUS
  let USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_VBUS_0 $bool = no // VBUS discharge resistor is disabled (Default)
  let USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_VBUS_1 $bool = yes // VBUS discharge resistor is enabled

//--- Enumerated values for register USB1_VBUS_DETECT_TOG, field EN_CHARGER_RESISTOR
  let USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR_Disable_0 $bool = no // Disable resistive charger detection resistors on USB_DP and USB_DP
  let USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR_Enable_1 $bool = yes // Enable resistive charger detection resistors on USB_DP and USB_DP

//--- Enumerated values for register USB1_VBUS_DET_STAT, field SESSEND
  let USBPHY_USB1_VBUS_DET_STAT_SESSEND_The_0 $bool = no // The VBUS voltage is above the Session Valid threshold
  let USBPHY_USB1_VBUS_DET_STAT_SESSEND_The_1 $bool = yes // The VBUS voltage is below the Session Valid threshold

//--- Enumerated values for register USB1_VBUS_DET_STAT, field BVALID
  let USBPHY_USB1_VBUS_DET_STAT_BVALID_The_0 $bool = no // The VBUS voltage is below the Session Valid threshold
  let USBPHY_USB1_VBUS_DET_STAT_BVALID_The_1 $bool = yes // The VBUS voltage is above the Session Valid threshold

//--- Enumerated values for register USB1_VBUS_DET_STAT, field AVALID
  let USBPHY_USB1_VBUS_DET_STAT_AVALID_The_0 $bool = no // The VBUS voltage is below the Session Valid threshold
  let USBPHY_USB1_VBUS_DET_STAT_AVALID_The_1 $bool = yes // The VBUS voltage is above the Session Valid threshold

//--- Enumerated values for register USB1_VBUS_DET_STAT, field VBUS_VALID
  let USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_VBUS_0 $bool = no // VBUS is below the comparator threshold
  let USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_VBUS_1 $bool = yes // VBUS is above the comparator threshold

//--- Enumerated values for register USB1_VBUS_DET_STAT, field VBUS_VALID_3V
  let USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V_VBUS_0 $bool = no // VBUS voltage is below VBUS_VALID_3V threshold
  let USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V_VBUS_1 $bool = yes // VBUS voltage is above VBUS_VALID_3V threshold

//--- Enumerated values for register USB1_CHRG_DET_STAT, field PLUG_CONTACT
  let USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT_No_0 $bool = no // No USB cable attachment has been detected
  let USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT_A_1 $bool = yes // A USB cable attachment between the device and host has been detected

//--- Enumerated values for register USB1_CHRG_DET_STAT, field CHRG_DETECTED
  let USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED_Standard_0 $bool = no // Standard Downstream Port (SDP) has been detected
  let USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED_Charging_1 $bool = yes // Charging Port has been detected

//--- Enumerated values for register USB1_CHRG_DET_STAT, field DM_STATE
  let USBPHY_USB1_CHRG_DET_STAT_DM_STATE_USB_DM_0 $bool = no // USB_DM pin voltage is < 0.8V
  let USBPHY_USB1_CHRG_DET_STAT_DM_STATE_USB_DM_1 $bool = yes // USB_DM pin voltage is > 2.0V

//--- Enumerated values for register USB1_CHRG_DET_STAT, field DP_STATE
  let USBPHY_USB1_CHRG_DET_STAT_DP_STATE_USB_DP_0 $bool = no // USB_DP pin voltage is < 0.8V
  let USBPHY_USB1_CHRG_DET_STAT_DP_STATE_USB_DP_1 $bool = yes // USB_DP pin voltage is > 2.0V

//--- Enumerated values for register USB1_CHRG_DET_STAT, field SECDET_DCP
  let USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP_Charging_0 $bool = no // Charging Downstream Port (CDP) has been detected
  let USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP_Downstream_1 $bool = yes // Downstream Charging Port (DCP) has been detected

//--- Enumerated values for register ANACTRL, field PFD_CLKGATE
  let USBPHY_ANACTRL_PFD_CLKGATE_PFD_0 $bool = no // PFD clock output is enabled
  let USBPHY_ANACTRL_PFD_CLKGATE_PFD_1 $bool = yes // PFD clock output is gated (Default)

//--- Enumerated values for register ANACTRL, field PFD_CLK_SEL
  let USBPHY_ANACTRL_PFD_CLK_SEL_USB1PFDCLK_00 $u2 = 0 // USB1PFDCLK is the same frequency as the xtal clock (Default)
  let USBPHY_ANACTRL_PFD_CLK_SEL_USB1PFDCLK_01 $u2 = 1 // USB1PFDCLK frequency is pfd_clk divided by 4
  let USBPHY_ANACTRL_PFD_CLK_SEL_USB1PFDCLK_10 $u2 = 2 // USB1PFDCLK frequency is pfd_clk divided by 2
  let USBPHY_ANACTRL_PFD_CLK_SEL_USB1PFDCLK_11 $u2 = 3 // USB1PFDCLK frequency is the same as pfd_clk frequency

//--- Enumerated values for register ANACTRL, field DEV_PULLDOWN
  let USBPHY_ANACTRL_DEV_PULLDOWN_The_0 $bool = no // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
  let USBPHY_ANACTRL_DEV_PULLDOWN_The_1 $bool = yes // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.

//--- Enumerated values for register ANACTRL, field EMPH_PULSE_CTRL
  let USBPHY_ANACTRL_EMPH_PULSE_CTRL_Minimum_00 $u2 = 0 // Minimum duration of pre-emphasis current after each data transition
  let USBPHY_ANACTRL_EMPH_PULSE_CTRL_Maximum_11 $u2 = 3 // Maximum duration of pre-emphasis current after each data transition

//--- Enumerated values for register ANACTRL, field EMPH_EN
  let USBPHY_ANACTRL_EMPH_EN_No_0 $bool = no // No pre-emphasis is used on HS TX output drivers
  let USBPHY_ANACTRL_EMPH_EN_Enables_1 $bool = yes // Enables pre-emphasis for HS TX output drivers

//--- Enumerated values for register ANACTRL, field EMPH_CUR_CTRL
  let USBPHY_ANACTRL_EMPH_CUR_CTRL_No_00 $u2 = 0 // No pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_EMPH_CUR_CTRL_One_01 $u2 = 1 // One unit of pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_EMPH_CUR_CTRL_Two_10 $u2 = 2 // Two units of pre-emphasis current are enabled for the HS TX drivers
  let USBPHY_ANACTRL_EMPH_CUR_CTRL_Three_11 $u2 = 3 // Three units of pre-emphasis current are enabled for the HS TX drivers

//--- Enumerated values for register ANACTRL_SET, field PFD_CLKGATE
  let USBPHY_ANACTRL_SET_PFD_CLKGATE_PFD_0 $bool = no // PFD clock output is enabled
  let USBPHY_ANACTRL_SET_PFD_CLKGATE_PFD_1 $bool = yes // PFD clock output is gated (Default)

//--- Enumerated values for register ANACTRL_SET, field PFD_CLK_SEL
  let USBPHY_ANACTRL_SET_PFD_CLK_SEL_USB1PFDCLK_00 $u2 = 0 // USB1PFDCLK is the same frequency as the xtal clock (Default)
  let USBPHY_ANACTRL_SET_PFD_CLK_SEL_USB1PFDCLK_01 $u2 = 1 // USB1PFDCLK frequency is pfd_clk divided by 4
  let USBPHY_ANACTRL_SET_PFD_CLK_SEL_USB1PFDCLK_10 $u2 = 2 // USB1PFDCLK frequency is pfd_clk divided by 2
  let USBPHY_ANACTRL_SET_PFD_CLK_SEL_USB1PFDCLK_11 $u2 = 3 // USB1PFDCLK frequency is the same as pfd_clk frequency

//--- Enumerated values for register ANACTRL_SET, field DEV_PULLDOWN
  let USBPHY_ANACTRL_SET_DEV_PULLDOWN_The_0 $bool = no // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
  let USBPHY_ANACTRL_SET_DEV_PULLDOWN_The_1 $bool = yes // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.

//--- Enumerated values for register ANACTRL_SET, field EMPH_PULSE_CTRL
  let USBPHY_ANACTRL_SET_EMPH_PULSE_CTRL_Minimum_00 $u2 = 0 // Minimum duration of pre-emphasis current after each data transition
  let USBPHY_ANACTRL_SET_EMPH_PULSE_CTRL_Maximum_11 $u2 = 3 // Maximum duration of pre-emphasis current after each data transition

//--- Enumerated values for register ANACTRL_SET, field EMPH_EN
  let USBPHY_ANACTRL_SET_EMPH_EN_No_0 $bool = no // No pre-emphasis is used on HS TX output drivers
  let USBPHY_ANACTRL_SET_EMPH_EN_Enables_1 $bool = yes // Enables pre-emphasis for HS TX output drivers

//--- Enumerated values for register ANACTRL_SET, field EMPH_CUR_CTRL
  let USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_No_00 $u2 = 0 // No pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_One_01 $u2 = 1 // One unit of pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_Two_10 $u2 = 2 // Two units of pre-emphasis current are enabled for the HS TX drivers
  let USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_Three_11 $u2 = 3 // Three units of pre-emphasis current are enabled for the HS TX drivers

//--- Enumerated values for register ANACTRL_CLR, field PFD_CLKGATE
  let USBPHY_ANACTRL_CLR_PFD_CLKGATE_PFD_0 $bool = no // PFD clock output is enabled
  let USBPHY_ANACTRL_CLR_PFD_CLKGATE_PFD_1 $bool = yes // PFD clock output is gated (Default)

//--- Enumerated values for register ANACTRL_CLR, field PFD_CLK_SEL
  let USBPHY_ANACTRL_CLR_PFD_CLK_SEL_USB1PFDCLK_00 $u2 = 0 // USB1PFDCLK is the same frequency as the xtal clock (Default)
  let USBPHY_ANACTRL_CLR_PFD_CLK_SEL_USB1PFDCLK_01 $u2 = 1 // USB1PFDCLK frequency is pfd_clk divided by 4
  let USBPHY_ANACTRL_CLR_PFD_CLK_SEL_USB1PFDCLK_10 $u2 = 2 // USB1PFDCLK frequency is pfd_clk divided by 2
  let USBPHY_ANACTRL_CLR_PFD_CLK_SEL_USB1PFDCLK_11 $u2 = 3 // USB1PFDCLK frequency is the same as pfd_clk frequency

//--- Enumerated values for register ANACTRL_CLR, field DEV_PULLDOWN
  let USBPHY_ANACTRL_CLR_DEV_PULLDOWN_The_0 $bool = no // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
  let USBPHY_ANACTRL_CLR_DEV_PULLDOWN_The_1 $bool = yes // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.

//--- Enumerated values for register ANACTRL_CLR, field EMPH_PULSE_CTRL
  let USBPHY_ANACTRL_CLR_EMPH_PULSE_CTRL_Minimum_00 $u2 = 0 // Minimum duration of pre-emphasis current after each data transition
  let USBPHY_ANACTRL_CLR_EMPH_PULSE_CTRL_Maximum_11 $u2 = 3 // Maximum duration of pre-emphasis current after each data transition

//--- Enumerated values for register ANACTRL_CLR, field EMPH_EN
  let USBPHY_ANACTRL_CLR_EMPH_EN_No_0 $bool = no // No pre-emphasis is used on HS TX output drivers
  let USBPHY_ANACTRL_CLR_EMPH_EN_Enables_1 $bool = yes // Enables pre-emphasis for HS TX output drivers

//--- Enumerated values for register ANACTRL_CLR, field EMPH_CUR_CTRL
  let USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_No_00 $u2 = 0 // No pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_One_01 $u2 = 1 // One unit of pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_Two_10 $u2 = 2 // Two units of pre-emphasis current are enabled for the HS TX drivers
  let USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_Three_11 $u2 = 3 // Three units of pre-emphasis current are enabled for the HS TX drivers

//--- Enumerated values for register ANACTRL_TOG, field PFD_CLKGATE
  let USBPHY_ANACTRL_TOG_PFD_CLKGATE_PFD_0 $bool = no // PFD clock output is enabled
  let USBPHY_ANACTRL_TOG_PFD_CLKGATE_PFD_1 $bool = yes // PFD clock output is gated (Default)

//--- Enumerated values for register ANACTRL_TOG, field PFD_CLK_SEL
  let USBPHY_ANACTRL_TOG_PFD_CLK_SEL_USB1PFDCLK_00 $u2 = 0 // USB1PFDCLK is the same frequency as the xtal clock (Default)
  let USBPHY_ANACTRL_TOG_PFD_CLK_SEL_USB1PFDCLK_01 $u2 = 1 // USB1PFDCLK frequency is pfd_clk divided by 4
  let USBPHY_ANACTRL_TOG_PFD_CLK_SEL_USB1PFDCLK_10 $u2 = 2 // USB1PFDCLK frequency is pfd_clk divided by 2
  let USBPHY_ANACTRL_TOG_PFD_CLK_SEL_USB1PFDCLK_11 $u2 = 3 // USB1PFDCLK frequency is the same as pfd_clk frequency

//--- Enumerated values for register ANACTRL_TOG, field DEV_PULLDOWN
  let USBPHY_ANACTRL_TOG_DEV_PULLDOWN_The_0 $bool = no // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
  let USBPHY_ANACTRL_TOG_DEV_PULLDOWN_The_1 $bool = yes // The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.

//--- Enumerated values for register ANACTRL_TOG, field EMPH_PULSE_CTRL
  let USBPHY_ANACTRL_TOG_EMPH_PULSE_CTRL_Minimum_00 $u2 = 0 // Minimum duration of pre-emphasis current after each data transition
  let USBPHY_ANACTRL_TOG_EMPH_PULSE_CTRL_Maximum_11 $u2 = 3 // Maximum duration of pre-emphasis current after each data transition

//--- Enumerated values for register ANACTRL_TOG, field EMPH_EN
  let USBPHY_ANACTRL_TOG_EMPH_EN_No_0 $bool = no // No pre-emphasis is used on HS TX output drivers
  let USBPHY_ANACTRL_TOG_EMPH_EN_Enables_1 $bool = yes // Enables pre-emphasis for HS TX output drivers

//--- Enumerated values for register ANACTRL_TOG, field EMPH_CUR_CTRL
  let USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_No_00 $u2 = 0 // No pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_One_01 $u2 = 1 // One unit of pre-emphasis current is enabled for the HS TX drivers
  let USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_Two_10 $u2 = 2 // Two units of pre-emphasis current are enabled for the HS TX drivers
  let USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_Three_11 $u2 = 3 // Three units of pre-emphasis current are enabled for the HS TX drivers

//------------------------------------------------------------------------------
// Peripheral VREF: Voltage Reference
//------------------------------------------------------------------------------

registers ©VREF @at 0x40074000 {
//---  Register TRM: VREF Trim Register
  TRM @offset 0x0 $u8 {
    1
    CHOPEN // at 6: Chop oscillator enable. When set, internal chopping operation is enabled and the internal analog offset will be minimized.
    TRIM:6 // at 0: Trim bits
  }

//---  Register SC: VREF Status and Control Register
  SC @offset 0x1 $u8 {
    VREFEN // at 7: Internal Voltage Reference enable
    REGEN // at 6: Regulator enable
    ICOMPEN // at 5: Second order curvature compensation enable
    2
    VREFST // at 2: Internal Voltage Reference stable
    MODE_LV:2 // at 0: Buffer Mode selection
  }

}

//--- Enumerated values for register TRM, field TRIM
  let VREF_TRM_TRIM_Min_000000 $u6 = 0 // Min
  let VREF_TRM_TRIM_Max_111111 $u6 = 63 // Max

//--- Enumerated values for register TRM, field CHOPEN
  let VREF_TRM_CHOPEN_Chop_0 $bool = no // Chop oscillator is disabled.
  let VREF_TRM_CHOPEN_Chop_1 $bool = yes // Chop oscillator is enabled.

//--- Enumerated values for register SC, field MODE_LV
  let VREF_SC_MODE_LV_Bandgap_00 $u2 = 0 // Bandgap on only, for stabilization and startup
  let VREF_SC_MODE_LV_High_01 $u2 = 1 // High power buffer mode enabled
  let VREF_SC_MODE_LV_Low_power_10 $u2 = 2 // Low-power buffer mode enabled

//--- Enumerated values for register SC, field VREFST
  let VREF_SC_VREFST_The_0 $bool = no // The module is disabled or not stable.
  let VREF_SC_VREFST_The_1 $bool = yes // The module is stable.

//--- Enumerated values for register SC, field ICOMPEN
  let VREF_SC_ICOMPEN_Disabled_0 $bool = no // Disabled
  let VREF_SC_ICOMPEN_Enabled_1 $bool = yes // Enabled

//--- Enumerated values for register SC, field REGEN
  let VREF_SC_REGEN_Internal_0 $bool = no // Internal 1.75 V regulator is disabled.
  let VREF_SC_REGEN_Internal_1 $bool = yes // Internal 1.75 V regulator is enabled.

//--- Enumerated values for register SC, field VREFEN
  let VREF_SC_VREFEN_The_0 $bool = no // The module is disabled.
  let VREF_SC_VREFEN_The_1 $bool = yes // The module is enabled.

//------------------------------------------------------------------------------
// Peripheral WDOG: Generation 2008 Watchdog Timer
//------------------------------------------------------------------------------

registers ©WDOG @at 0x40052000 {
//---  Register STCTRLH: Watchdog Status and Control Register High
  STCTRLH @offset 0x0 $u16 {
    1
    DISTESTWDOG // at 14: Allows the WDOG's functional test mode to be disabled permanently
    BYTESEL:2 // at 12: This 2-bit field selects the byte to be tested when the watchdog is in the byte test mode.
    TESTSEL // at 11: Effective only if TESTWDOG is set. Selects the test to be run on the watchdog timer.
    TESTWDOG // at 10: Puts the watchdog in the functional test mode
    2
    WAITEN // at 7: Enables or disables WDOG in Wait mode.
    STOPEN // at 6: Enables or disables WDOG in Stop mode.
    DBGEN // at 5: Enables or disables WDOG in Debug mode.
    ALLOWUPDATE // at 4: Enables updates to watchdog write-once registers, after the reset-triggered initial configuration window (WCT) closes, through unlock sequence
    WINEN // at 3: Enables Windowing mode.
    IRQRSTEN // at 2: Used to enable the debug breadcrumbs feature
    CLKSRC // at 1: Selects clock source for the WDOG timer and other internal timing operations.
    WDOGEN // at 0: Enables or disables the WDOG's operation
  }

//---  Register STCTRLL: Watchdog Status and Control Register Low
  STCTRLL @offset 0x2 $u16 {
    INTFLG // at 15: Interrupt flag
    15
  }

//---  Register TOVALH: Watchdog Time-out Value Register High
  TOVALH @offset 0x4 $u16 {
    TOVALHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit time-out value for the watchdog timer
  }

//---  Register TOVALL: Watchdog Time-out Value Register Low
  TOVALL @offset 0x6 $u16 {
    TOVALLOW:16 // at 0: Defines the lower 16 bits of the 32-bit time-out value for the watchdog timer
  }

//---  Register WINH: Watchdog Window Register High
  WINH @offset 0x8 $u16 {
    WINHIGH:16 // at 0: Defines the upper 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
  }

//---  Register WINL: Watchdog Window Register Low
  WINL @offset 0xa $u16 {
    WINLOW:16 // at 0: Defines the lower 16 bits of the 32-bit window for the windowed mode of operation of the watchdog
  }

//---  Register REFRESH: Watchdog Refresh register
  REFRESH @offset 0xc $u16 {
    WDOGREFRESH:16 // at 0: Watchdog refresh register
  }

//---  Register UNLOCK: Watchdog Unlock register
  UNLOCK @offset 0xe $u16 {
    WDOGUNLOCK:16 // at 0: Writing the unlock sequence values to this register to makes the watchdog write-once registers writable again
  }

//---  Register TMROUTH: Watchdog Timer Output Register High
  TMROUTH @offset 0x10 $u16 {
    TIMEROUTHIGH:16 // at 0: Shows the value of the upper 16 bits of the watchdog timer.
  }

//---  Register TMROUTL: Watchdog Timer Output Register Low
  TMROUTL @offset 0x12 $u16 {
    TIMEROUTLOW:16 // at 0: Shows the value of the lower 16 bits of the watchdog timer.
  }

//---  Register RSTCNT: Watchdog Reset Count register
  RSTCNT @offset 0x14 $u16 {
    RSTCNT:16 // at 0: Counts the number of times the watchdog resets the system
  }

//---  Register PRESC: Watchdog Prescaler register
  PRESC @offset 0x16 $u16 {
    5
    PRESCVAL:3 // at 8: 3-bit prescaler for the watchdog clock source
    8
  }

}

//--- Enumerated values for register STCTRLH, field WDOGEN
  let WDOG_STCTRLH_WDOGEN_WDOG_0 $bool = no // WDOG is disabled.
  let WDOG_STCTRLH_WDOGEN_WDOG_1 $bool = yes // WDOG is enabled.

//--- Enumerated values for register STCTRLH, field CLKSRC
  let WDOG_STCTRLH_CLKSRC_WDOG_0 $bool = no // WDOG clock sourced from LPO .
  let WDOG_STCTRLH_CLKSRC_WDOG_1 $bool = yes // WDOG clock sourced from alternate clock source.

//--- Enumerated values for register STCTRLH, field IRQRSTEN
  let WDOG_STCTRLH_IRQRSTEN_WDOG_0 $bool = no // WDOG time-out generates reset only.
  let WDOG_STCTRLH_IRQRSTEN_WDOG_1 $bool = yes // WDOG time-out initially generates an interrupt. After WCT, it generates a reset.

//--- Enumerated values for register STCTRLH, field WINEN
  let WDOG_STCTRLH_WINEN_Windowing_0 $bool = no // Windowing mode is disabled.
  let WDOG_STCTRLH_WINEN_Windowing_1 $bool = yes // Windowing mode is enabled.

//--- Enumerated values for register STCTRLH, field ALLOWUPDATE
  let WDOG_STCTRLH_ALLOWUPDATE_No_0 $bool = no // No further updates allowed to WDOG write-once registers.
  let WDOG_STCTRLH_ALLOWUPDATE_WDOG_1 $bool = yes // WDOG write-once registers can be unlocked for updating.

//--- Enumerated values for register STCTRLH, field DBGEN
  let WDOG_STCTRLH_DBGEN_WDOG_0 $bool = no // WDOG is disabled in CPU Debug mode.
  let WDOG_STCTRLH_DBGEN_WDOG_1 $bool = yes // WDOG is enabled in CPU Debug mode.

//--- Enumerated values for register STCTRLH, field STOPEN
  let WDOG_STCTRLH_STOPEN_WDOG_0 $bool = no // WDOG is disabled in CPU Stop mode.
  let WDOG_STCTRLH_STOPEN_WDOG_1 $bool = yes // WDOG is enabled in CPU Stop mode.

//--- Enumerated values for register STCTRLH, field WAITEN
  let WDOG_STCTRLH_WAITEN_WDOG_0 $bool = no // WDOG is disabled in CPU Wait mode.
  let WDOG_STCTRLH_WAITEN_WDOG_1 $bool = yes // WDOG is enabled in CPU Wait mode.

//--- Enumerated values for register STCTRLH, field TESTSEL
  let WDOG_STCTRLH_TESTSEL_Quick_0 $bool = no // Quick test. The timer runs in normal operation. You can load a small time-out value to do a quick test.
  let WDOG_STCTRLH_TESTSEL_Byte_1 $bool = yes // Byte test. Puts the timer in the byte test mode where individual bytes of the timer are enabled for operation and are compared for time-out against the corresponding byte of the programmed time-out value. Select the byte through BYTESEL[1:0] for testing.

//--- Enumerated values for register STCTRLH, field BYTESEL
  let WDOG_STCTRLH_BYTESEL_Byte_00 $u2 = 0 // Byte 0 selected
  let WDOG_STCTRLH_BYTESEL_Byte_01 $u2 = 1 // Byte 1 selected
  let WDOG_STCTRLH_BYTESEL_Byte_10 $u2 = 2 // Byte 2 selected
  let WDOG_STCTRLH_BYTESEL_Byte_11 $u2 = 3 // Byte 3 selected

//--- Enumerated values for register STCTRLH, field DISTESTWDOG
  let WDOG_STCTRLH_DISTESTWDOG_WDOG_0 $bool = no // WDOG functional test mode is not disabled.
  let WDOG_STCTRLH_DISTESTWDOG_WDOG_1 $bool = yes // WDOG functional test mode is disabled permanently until reset.

