
check target "teensy-3-6/unprivileged", "teensy-3-6/privileged"

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

boot 0 {
//--------------------------------------------------- Disable watchdog timer
// These two instructions are required for unlocking watchdog timer
  WDOG_UNLOCK = WDOG_UNLOCK_SEQ1
  WDOG_UNLOCK = WDOG_UNLOCK_SEQ2
//--- Disable watchdog timer
  WDOG_STCTRLH = 0
  nop
  nop
//--------------------------------------------------- Enable clocks to always-used peripherals
  SIM_SCGC3 = {SIM_SCGC3 !ADC1:1 !FTM2:1 !FTM3:1}
  SIM_SCGC5 = {SIM_SCGC5 !PORTA:1 !PORTB:1 !PORTC:1 !PORTD:1 !PORTE:1}    // clocks active to all GPIO
  SIM_SCGC6 = {SIM_SCGC6 !RTC:1 !FTM0:1 !FTM1:1 !ADC0:1 !FTF:1}
//  SCB_CPACR = 0x00F0_0000; // Enable floating point unit
  LMEM_PCCCR = {LMEM_PCCCR !GO:1 !INVW1:1 !INVW0:1 !ENWRBUF:1 !ENCACHE:1} // 0x8500_0003
//--- If the RTC oscillator isn't enabled, get it started early
  if not RTC_CR.OSCE.bool {
    RTC_SR = 0
    RTC_CR = {RTC_CR !SC16P:1 !SC4P:1 !OSCE:1}
  }
//--- Release I/O pins hold, if we woke up from VLLS mode
  if PMC_REGSC.ACKISO ≠ 0 {
    PMC_REGSC |= {PMC_REGSC !ACKISO:1}
  }
//--- Since this is a write once register, make it visible to all F_CPU's
//    so we can into other sleep modes in the future at any speed
  SMC_PMPROT = {SMC_PMPROT !AHSRUN:1 !AVLP:1 !ALLS:1 !AVLLS:1}
// TODO: do this while the PLL is waiting to lock....
  SCB_VTOR = 0  // use vector table in flash
//  // default all interrupts to medium priority level
////  for (int32_t i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
//---------2- Initialisation de la PLL
// start in FEI mode
//--- Enable capacitors for crystal
  OSC_CR = {OSC_CR !SC8P:1 !SC2P:1 !ERCLKEN:1}
//--- Enable osc, 8-32 MHz range, low power mode
  MCG_C2 = {MCG_C2 !RANGE0:2 !EREFS:1}
//--- Switch to crystal as clock source, FLL input = 16 MHz / 512
  MCG_C1 = {MCG_C1 !CLKS:2 !FRDIV:4}
//--- Wait for crystal oscillator to begin
  while MCG_S.OSCINIT0 == 0 {}
//--- Wait for FLL to use oscillator
  while MCG_S.IREFST ≠ 0 {}
//--- Wait for MCGOUT to use oscillator
  while MCG_S.CLKST ≠ {MCG_S !CLKST:2} {}
//--- Now we're in FBE mode
//--- If we need faster than crystal, turn on the PLL
  if @static F_CPU_MHZ > 120 {
    SMC_PMCTRL = {SMC_PMCTRL !RUNM:3} // enter HSRUN mode
    while SMC_PMSTAT ≠ {SMC_PMSTAT !RUN:1} {}
  }
  check (F_CPU_MHZ == 240) or (F_CPU_MHZ == 216) or (F_CPU_MHZ == 192) or (F_CPU_MHZ == 180) or (F_CPU_MHZ == 168)
    or (F_CPU_MHZ == 144) or (F_CPU_MHZ == 120) or (F_CPU_MHZ == 96) or (F_CPU_MHZ == 48) or (F_CPU_MHZ == 24)
    or (F_CPU_MHZ == 72)
//--- Configure CPU clock
  if @static F_CPU_MHZ == 240 {
    MCG_C5 = {MCG_C5 !PRDIV0:0}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:14}
  }else if @static F_CPU_MHZ == 216 {
    MCG_C5 = {MCG_C5 !PRDIV0:0}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:11}
  }else if @static F_CPU_MHZ == 192 {
    MCG_C5 = {MCG_C5 !PRDIV0:0}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:8}
  }else if @static F_CPU_MHZ == 180 {
    MCG_C5 = {MCG_C5 !PRDIV0:1}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:29}
  }else if @static F_CPU_MHZ == 168 {
    MCG_C5 = {MCG_C5 !PRDIV0:0}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:5}
  }else if @static F_CPU_MHZ == 144 {
    MCG_C5 = {MCG_C5 !PRDIV0:0}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:2}
  }else if @static F_CPU_MHZ == 120 {
    MCG_C5 = {MCG_C5 !PRDIV0:1}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:14}
  }else if @static (F_CPU_MHZ == 96) or (F_CPU_MHZ == 48) or (F_CPU_MHZ == 24) {
    MCG_C5 = {MCG_C5 !PRDIV0:1}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:8}
  }else if @static F_CPU_MHZ == 72 {
    MCG_C5 = {MCG_C5 !PRDIV0:1}
    MCG_C6 = {MCG_C6 !PLLS:1 !VDIV0:2}
  }
//--- Wait for PLL to start using xtal as its input
  while MCG_S.PLLST == 0 {}
//--- Wait for PLL to lock
  while MCG_S.LOCK0 == 0 {}
//------------------------------------ Now we're in PBE mode : now program the clock dividers
  if @static F_CPU_MHZ == 240 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:7} // Bus 60 MHz, Flash 30 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:4} // USB clock = 240 MHz / 5
  }else if @static F_CPU_MHZ == 216 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:7} // bus = 54 MHz, Flash 27 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:0} // USB clock = IRC48M
  }else if @static F_CPU_MHZ == 192 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:6} // bus = 48 MHz, Flash 27.4 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:3} // USB clock = 192 MHz / 4
  }else if @static F_CPU_MHZ == 180 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:6} // bus = 60 MHz, Flash 25.7 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:0} // USB clock = IRC48M
  }else if @static F_CPU_MHZ == 168 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:2 !OUTDIV4:5} // bus = 56 MHz, Flash 28 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:6 !USBFRAC:1} // USB clock = 168 MHz * 2 / 7
  }else if @static F_CPU_MHZ == 144 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:4} // bus = 48 MHz, Flash 28.8 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:2} // USB clock = 144 MHz / 3
  }else if @static F_CPU_MHZ == 120 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:0 !OUTDIV4:4} // bus = 60 MHz, Flash 24 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:4 !USBFRAC:1} // USB clock = 120 MHz * 2 / 5
  }else if @static F_CPU_MHZ == 96 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:1 !OUTDIV4:3} // bus = 48 MHz, Flash 24 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:2} // USB clock = 96 MHz / 2
  }else if @static F_CPU_MHZ == 72 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:0 !OUTDIV2:0 !OUTDIV4:2} // bus = 36 MHz, Flash 24 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:2 !USBFRAC:1} // USB clock = 72 MHz * 2 / 3
  }else if @static F_CPU_MHZ == 48 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:1 !OUTDIV2:1 !OUTDIV3:1 !OUTDIV4:3} // bus = 48 MHz, Flash 24 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:1} // USB clock = 72 MHz / 2
  }else if @static F_CPU_MHZ == 24 {
    SIM_CLKDIV1 = {SIM_CLKDIV1 !OUTDIV1:3 !OUTDIV2:3 !OUTDIV3:3 !OUTDIV4:3} // bus = 24 MHz, Flash 24 MHz
    SIM_CLKDIV2 = {SIM_CLKDIV2 !USBDIV:1} // USB clock = 72 MHz / 2
  }
//--- Switch to PLL as clock source
  MCG_C1 = {MCG_C1 !CLKS:0 !FRDIV:4}
//--- Wait for PLL clock to be used
  while MCG_S.CLKST ≠ {MCG_S !CLKST:3} {}
//--- USB clock
  if @static (F_CPU_MHZ == 240) or (F_CPU_MHZ == 180) {
    SIM_SOPT2 = {SIM_SOPT2 !USBSRC:1 !PLLFLLSEL:3 !TRACECLKSEL:1 !CLKOUTSEL:6} // PLLFLLSEL:3 --> IRC48SEL
  }else{
    SIM_SOPT2 = {SIM_SOPT2 !USBSRC:1 !PLLFLLSEL:1 !TRACECLKSEL:1 !CLKOUTSEL:6}
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// BUS FREQUENCY
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

let F_BUS_MHZ =
  if F_CPU_MHZ == 240 {
    60
  }else if F_CPU_MHZ == 216 {
    54
  }else if F_CPU_MHZ == 192 {
    48
  }else if F_CPU_MHZ == 180 {
    60
  }else if F_CPU_MHZ == 168 {
    56
  }else if F_CPU_MHZ == 144 {
    48
  }else if F_CPU_MHZ == 120 {
    60
  }else if F_CPU_MHZ == 96 {
    48
  }else if F_CPU_MHZ == 72 {
    36
  }else if F_CPU_MHZ == 48 {
    48
  }else if F_CPU_MHZ == 24 {
    24
  }else{
    0 // Any value, an error is raised in "check" instruction above
  }

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

