
let f_cpu $uint32 = 96_000_000
let f_bus $uint32 = 48_000_000
let f_mem $uint32 = 24_000_000

// chapter 11: Port control and interrupts (PORT) Pin Control registers n
registers PORTA {
  PCR @user [32] 0x4004_9000 : 4 $uint32 {
    7, ISF, 4, IRQC[4], LK, 4, MUX[3], 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  
  GPCLR @user  0x40049080 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x40049084 $uint32 // Global Pin Control High Register
  ISFR @user   0x400490A0 $uint32 // Interrupt Status Flag Register
}

registers PORTB {
  PCR @user [32] 0x4004_A000 : 4 $uint32 {
    7, ISF, 4, IRQC[4], LK, 4, MUX[3], 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  GPCLR @user  0x4004A080 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x4004A084 $uint32 // Global Pin Control High Register
  ISFR  @user  0x4004A0A0 $uint32 // Interrupt Status Flag Register
}

registers PORTC {
  PCR @user [32] 0x4004_B000 : 4 $uint32 {
    7, ISF, 4, IRQC[4], LK, 4, MUX[3], 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  GPCLR @user  0x4004B080 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x4004B084 $uint32 // Global Pin Control High Register
  ISFR  @user  0x4004B0A0 $uint32 // Interrupt Status Flag Register
}

registers PORTD {
  PCR @user [32] 0x4004_C000 : 4 $uint32 {
    7, ISF, 4, IRQC[4], LK, 4, MUX[3], 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  GPCLR @user  0x4004C080 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x4004C084 $uint32 // Global Pin Control High Register
  ISFR  @user  0x4004C0A0 $uint32 // Interrupt Status Flag Register
}

// Chapter 12: System Integration Module (SIM)
let SIM_SOPT2_USBSRC      $uint32 = 0x40000  // 0=USB_CLKIN, 1=FFL/PLL 
let SIM_SOPT2_PLLFLLSEL   $uint32 = 0x10000 // 0=FLL, 1=PLL
let SIM_SOPT2_TRACECLKSEL $uint32 = 0x1000  // 0=MCGOUTCLK, 1=CPU
let SIM_SOPT2_PTD7PAD     $uint32 = 0x800  // 0=normal, 1=double drive PTD7
let SIM_SOPT2_RTCCLKOUTSEL $uint32 = 0x00000010  // RTC clock out select

let SIM_SCGC2_DAC0  $uint32 =  0x00001000 // DAC0 Clock Gate Control

let SIM_SCGC3_ADC1 $uint32 =  0x08000000 // ADC1 Clock Gate Control
let SIM_SCGC3_FTM2 $uint32 =  0x01000000 // FTM2 Clock Gate Control

let SIM_SCGC4_VREF  $uint32 =  0x00100000  // VREF Clock Gate Control
let SIM_SCGC4_CMP   $uint32 = 0x00080000  // Comparator Clock Gate Control
let SIM_SCGC4_USBOTG  $uint32 = 0x00040000  // USB Clock Gate Control
let SIM_SCGC4_UART2  $uint32 =  0x00001000  // UART2 Clock Gate Control
let SIM_SCGC4_UART1  $uint32 =  0x00000800  // UART1 Clock Gate Control
let SIM_SCGC4_UART0  $uint32 =  0x00000400  // UART0 Clock Gate Control
let SIM_SCGC4_I2C1  $uint32 =  0x00000080  // I2C1 Clock Gate Control
let SIM_SCGC4_I2C0  $uint32 =  0x00000040  // I2C0 Clock Gate Control
let SIM_SCGC4_CMT  $uint32 =  0x00000004  // CMT Clock Gate Control
let SIM_SCGC4_EWM  $uint32 =  0x00000002  // EWM Clock Gate Control

let SIM_SCGC5_PORTE  $uint32 =  0x00002000  // Port E Clock Gate Control
let SIM_SCGC5_PORTD  $uint32 =  0x00001000  // Port D Clock Gate Control
let SIM_SCGC5_PORTC  $uint32 =  0x00000800  // Port C Clock Gate Control
let SIM_SCGC5_PORTB  $uint32 =  0x00000400  // Port B Clock Gate Control
let SIM_SCGC5_PORTA  $uint32 =  0x00000200  // Port A Clock Gate Control
let SIM_SCGC5_TSI  $uint32 =  0x00000020  // Touch Sense Input TSI Clock Gate Control
let SIM_SCGC5_LPTIMER  $uint32 =  0x00000001  // Low Power Timer Access Control

let SIM_SCGC6_RTC   $uint32 = 0x20000000  // RTC Access
let SIM_SCGC6_ADC0  $uint32 =   0x08000000  // ADC0 Clock Gate Control
let SIM_SCGC6_FTM1  $uint32 =   0x02000000  // FTM1 Clock Gate Control
let SIM_SCGC6_FTM0  $uint32 =   0x01000000  // FTM0 Clock Gate Control
let SIM_SCGC6_PIT  $uint32 =  0x00800000  // PIT Clock Gate Control
let SIM_SCGC6_PDB  $uint32 =  0x00400000  // PDB Clock Gate Control
let SIM_SCGC6_USBDCD  $uint32=  0x00200000  // USB DCD Clock Gate Control
let SIM_SCGC6_CRC  $uint32 =  0x00040000  // CRC Clock Gate Control
let SIM_SCGC6_I2S  $uint32 =  0x00008000  // I2S Clock Gate Control
let SIM_SCGC6_SPI1  $uint32=   0x00002000  // SPI1 Clock Gate Control
let SIM_SCGC6_SPI0  $uint32=   0x00001000  // SPI0 Clock Gate Control
let SIM_SCGC6_FLEXCAN0  $uint32 =  0x00000010  // FlexCAN0 Clock Gate Control
let SIM_SCGC6_DMAMUX $uint32 =  0x00000002  // DMA Mux Clock Gate Control
let SIM_SCGC6_FTFL  $uint32 =  0x00000001  // Flash Memory Clock Gate Control

let SIM_SCGC7_DMA  $uint32 =  0x00000002  // DMA Clock Gate Control

let SIM_CLKDIV2_USBFRAC  $uint32 =  0x01

registers SIM {
  SOPT1    0x40047000 $uint32 // System Options registers 1
  SOPT1CFG 0x40047004 $uint32 // SOPT1 Configuration Register
  SOPT2    0x40048004 $uint32 // System Options registers 2
  SOPT4   0x4004800C $uint32 // System Options registers 4
  SOPT5   0x40048010 $uint32 // System Options registers 5
  SOPT7   0x40048018 $uint32 // System Options registers 7
  SDID @ro 0x40048024 $uint32 // System Device Identification Register
  SCGC2  0x4004802C $uint32 // System Clock Gating Control registers 2
  SCGC3  0x40048030 $uint32 // System Clock Gating Control registers 3
  SCGC4 0x40048034 $uint32 // System Clock Gating Control registers 4
  SCGC5 0x40048038 $uint32 // System Clock Gating Control registers 5
  SCGC6 0x4004803C $uint32 // System Clock Gating Control registers 6
  SCGC7 0x40048040 $uint32 // System Clock Gating Control registers 7
  
  CLKDIV1 0x4004_8044 $uint32 {// System Clock Divider registers 1
    OUTDIV1[4], // Divide value for the core/system clock
    OUTDIV2[4], // Divide value for the peripheral clock
    4,
    OUTDIV4[4], // Divide value for the flash clock
    16
  }
  
  CLKDIV2 0x40048048 $uint32 // System Clock Divider registers 2

  FCFG1 @ro 0x4004804C $uint32 // Flash Configuration registers 1
  FCFG2 @ro 0x40048050 $uint32 // Flash Configuration registers 2
  UIDH  @ro 0x40048054 $uint32 // Unique Identification registers High
  UIDMH @ro 0x40048058 $uint32 // Unique Identification registers Mid-High
  UIDML @ro 0x4004805C $uint32 // Unique Identification registers Mid Low
  UIDL  @ro 0x40048060 $uint32 // Unique Identification registers Low
}

// Chapter 13: Reset Control Module (RCM)
registers RCM{
  SRS0 0x4007F000 $uint8 // System Reset Status registers 0
  SRS1 0x4007F001 $uint8 // System Reset Status registers 1
  RPFC 0x4007F004 $uint8 // Reset Pin Filter Control Register
  RPFW 0x4007F005 $uint8 // Reset Pin Filter Width Register
  MR   0x4007F007 $uint8 // Mode Register
}

// Chapter 14: System Mode Controller
let SMC_PMPROT_AVLP  $uint8 = 0x20   // Allow very low power modes
let SMC_PMPROT_ALLS $uint8  = 0x08   // Allow low leakage stop mode
let SMC_PMPROT_AVLLS $uint8 = 0x02   // Allow very low leakage stop mode

let SMC_PMCTRL_LPWUI $uint8  = 0x80   // Low Power Wake Up on Interrupt
let SMC_PMCTRL_STOPA $uint8  = 0x08   // Stop Aborted

let SMC_VLLSCTRL_PORPO $uint8 = 0x20   // POR Power Option

let SMC_PMSTAT_RUN  $uint8 = 0x01   // Current power mode is RUN
let SMC_PMSTAT_STOP $uint8 = 0x02   // Current power mode is STOP
let SMC_PMSTAT_VLPR $uint8 = 0x04   // Current power mode is VLPR
let SMC_PMSTAT_VLPW $uint8 = 0x08   // Current power mode is VLPW
let SMC_PMSTAT_VLPS $uint8 = 0x10   // Current power mode is VLPS
let SMC_PMSTAT_LLS  $uint8 = 0x20   // Current power mode is LLS
let SMC_PMSTAT_VLLS $uint8 = 0x40   // Current power mode is VLLS

registers SMC {
  PMPROT  0x4007E000 $uint8 // Power Mode Protection Register
  PMCTRL  0x4007E001 $uint8 // Power Mode Control Register
  VLLSCTRL 0x4007E002 $uint8 // VLLS Control Register
  PMST 0x4007E003 $uint8 // Power Mode Status Register
}

// Chapter 15: Power Management Controller
let PMC_LVDSC1_LVDF $uint8 = 0x80   // Low-Voltage Detect Flag
let PMC_LVDSC1_LVDACK $uint8 = 0x40   // Low-Voltage Detect Acknowledge
let PMC_LVDSC1_LVDIE $uint8 = 0x20   // Low-Voltage Detect Interrupt Enable
let PMC_LVDSC1_LVDRE $uint8 = 0x10   // Low-Voltage Detect Reset Enable

let PMC_LVDSC2_LVWF $uint8  = 0x80   // Low-Voltage Warning Flag
let PMC_LVDSC2_LVWACK $uint8 = 0x40   // Low-Voltage Warning Acknowledge
let PMC_LVDSC2_LVWIE $uint8 = 0x20   // Low-Voltage Warning Interrupt Enable

registers PMC {
  LVDSC1 0x4007D000 $uint8 // Low Voltage Detect Status And Control 1 register
  LVDSC2 0x4007D001 $uint8 // Low Voltage Detect Status And Control 2 register
  REGSC 0x4007D002 $uint8 { // Regulator Status And Control register
    3, BGEN, ACKISO, REGONS, BGBE, 1
  }
}

// Chapter 16: Low-Leakage Wakeup Unit (LLWU)
registers LLWU {
  PE1  0x4007C000 $uint8 // LLWU Pin Enable 1 register
  PE2  0x4007C001 $uint8 // LLWU Pin Enable 2 register
  PE3  0x4007C002 $uint8 // LLWU Pin Enable 3 register
  PE4  0x4007C003 $uint8 // LLWU Pin Enable 4 register
  ME   0x4007C004 $uint8 // LLWU Module Enable register
  F1   0x4007C005 $uint8 // LLWU Flag 1 register
  F2   0x4007C006 $uint8 // LLWU Flag 2 register
  F3   0x4007C007 $uint8 // LLWU Flag 3 register
  FILT1 0x4007C008 $uint8 // LLWU Pin Filter 1 register
  FILT2 0x4007C009 $uint8 // LLWU Pin Filter 2 register
  RST  0x4007C00A $uint8 // LLWU Reset Enable register
}

// Chapter 17: Miscellaneous Control Module (MCM)
let MCM_PLACR_ARG   $uint32 = 0x00000200  // Arbitration select, 0=fixed, 1=round-robin
let MCM_CR_SRAMLWP  $uint32 =  0x4000_0000  // SRAM_L write protect
//let $uint32 MCM_CR_SRAMLAP(n)   (((n) & 0x03) << 28) // SRAM_L priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA
let MCM_CR_SRAMUWP  $uint32 =  0x0400_0000  // SRAM_U write protect
//let $uint32 MCM_CR_SRAMUAP(n)   (((n) & 0x03) << 24) // SRAM_U priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA

registers MCM {
  PLASC 0xE0080008 $uint16 // Crossbar Switch (AXBS) Slave Configuration
  PLAMC 0xE008000A $uint16 // Crossbar Switch (AXBS) Master Configuration
  PLACR 0xE008000C $uint32 // Crossbar Switch (AXBS) Control registers (MK20DX128)
  CR 0xE008000C $uint32 // RAM arbitration control registers (MK20DX256)
}

// Crossbar Switch (AXBS) - only programmable on MK20DX256
let AXBS_CRS_READONLY  $uint32=  0x80000000
let AXBS_CRS_HALTLOWPRIORITY  $uint32 = 0x40000000
let AXBS_CRS_ARB_FIXED  $uint32 = 0x00000000
let AXBS_CRS_ARB_ROUNDROBIN  $uint32 = 0x00010000
let AXBS_CRS_PARK_FIXED  $uint32 =  0x00000000
let AXBS_CRS_PARK_PREVIOUS  $uint32 =  0x00000010
let AXBS_CRS_PARK_NONE  $uint32 =  0x00000020

registers AXBS {
  PRS0   0x40004000 $uint32 // Priority Registers Slave 0
  CRS0   0x40004010 $uint32 // Control registers 0
  PRS1   0x40004100 $uint32 // Priority Registers Slave 1
  CRS1   0x40004110 $uint32 // Control registers 1
  PRS2   0x40004200 $uint32 // Priority Registers Slave 2
  CRS2   0x40004210 $uint32 // Control registers 2
  PRS3   0x40004300 $uint32 // Priority Registers Slave 3
  CRS3   0x40004310 $uint32 // Control registers 3
  PRS4   0x40004400 $uint32 // Priority Registers Slave 4
  CRS4   0x40004410 $uint32 // Control registers 4
  PRS5   0x40004500 $uint32 // Priority Registers Slave 5
  CRS5   0x40004510 $uint32 // Control registers 5
  PRS6   0x40004600 $uint32 // Priority Registers Slave 6
  CRS6   0x40004610 $uint32 // Control registers 6
  PRS7   0x40004700 $uint32 // Priority Registers Slave 7
  CRS7   0x40004710 $uint32 // Control registers 7
  MGPCR0 0x40004800 $uint32 // Master 0 General Purpose Control Register
  MGPCR1 0x40004900 $uint32 // Master 1 General Purpose Control Register
  MGPCR2 0x40004A00 $uint32 // Master 2 General Purpose Control Register
  MGPCR3 0x40004B00 $uint32 // Master 3 General Purpose Control Register
  MGPCR4 0x40004C00 $uint32 // Master 4 General Purpose Control Register
  MGPCR5 0x40004D00 $uint32 // Master 5 General Purpose Control Register
  MGPCR6 0x40004E00 $uint32 // Master 6 General Purpose Control Register
  MGPCR7 0x40004F00 $uint32 // Master 7 General Purpose Control Register
}


// Chapter 20: Direct Memory Access Multiplexer (DMAMUX)
let DMA_CHANNEL_COUNT = 16

registers DMAMUX0 {
  CHCFG [DMA_CHANNEL_COUNT] 0x4002_1000 : 1 $uint8 {
    ENABLE, TRIG, SOURCE [6]
  }
}

let DMAMUX_SOURCE_UART0_RX $uint6 =  2
let DMAMUX_SOURCE_UART0_TX $uint6 =  3
let DMAMUX_SOURCE_UART1_RX $uint6 =  4
let DMAMUX_SOURCE_UART1_TX $uint6 =  5
let DMAMUX_SOURCE_UART2_RX $uint6 =  6
let DMAMUX_SOURCE_UART2_TX $uint6 =  7
let DMAMUX_SOURCE_I2S0_RX  $uint6 = 14
let DMAMUX_SOURCE_I2S0_TX  $uint6 = 15
let DMAMUX_SOURCE_SPI0_RX  $uint6 = 16
let DMAMUX_SOURCE_SPI0_TX  $uint6 = 17
let DMAMUX_SOURCE_I2C0     $uint6 = 22
let DMAMUX_SOURCE_I2C1     $uint6 = 23
let DMAMUX_SOURCE_FTM0_CH0 $uint6 = 24
let DMAMUX_SOURCE_FTM0_CH1 $uint6 = 25
let DMAMUX_SOURCE_FTM0_CH2 $uint6 = 26
let DMAMUX_SOURCE_FTM0_CH3 $uint6 = 27
let DMAMUX_SOURCE_FTM0_CH4 $uint6 = 28
let DMAMUX_SOURCE_FTM0_CH5 $uint6 = 29
let DMAMUX_SOURCE_FTM0_CH6 $uint6 = 30
let DMAMUX_SOURCE_FTM0_CH7 $uint6 = 31
let DMAMUX_SOURCE_FTM1_CH0 $uint6 = 32
let DMAMUX_SOURCE_FTM1_CH1 $uint6 = 33
let DMAMUX_SOURCE_FTM2_CH0 $uint6 = 34
let DMAMUX_SOURCE_FTM2_CH1 $uint6 = 35
let DMAMUX_SOURCE_ADC0     $uint6 = 40
let DMAMUX_SOURCE_ADC1     $uint6 = 41
let DMAMUX_SOURCE_CMP0     $uint6 = 42
let DMAMUX_SOURCE_CMP1     $uint6 = 43
let DMAMUX_SOURCE_CMP2     $uint6 = 44
let DMAMUX_SOURCE_DAC0     $uint6 = 45
let DMAMUX_SOURCE_CMT      $uint6 = 47
let DMAMUX_SOURCE_PDB      $uint6 = 48
let DMAMUX_SOURCE_PORTA    $uint6 = 49
let DMAMUX_SOURCE_PORTB    $uint6 = 50
let DMAMUX_SOURCE_PORTC    $uint6 = 51
let DMAMUX_SOURCE_PORTD    $uint6 = 52
let DMAMUX_SOURCE_PORTE    $uint6 = 53
let DMAMUX_SOURCE_ALWAYS0  $uint6 = 54
let DMAMUX_SOURCE_ALWAYS1  $uint6 = 55
let DMAMUX_SOURCE_ALWAYS2  $uint6 = 56
let DMAMUX_SOURCE_ALWAYS3  $uint6 = 57
let DMAMUX_SOURCE_ALWAYS4  $uint6 = 58
let DMAMUX_SOURCE_ALWAYS5  $uint6 = 59
let DMAMUX_SOURCE_ALWAYS6  $uint6 = 60
let DMAMUX_SOURCE_ALWAYS7  $uint6 = 61
let DMAMUX_SOURCE_ALWAYS8  $uint6 = 62
let DMAMUX_SOURCE_ALWAYS9  $uint6 = 63

// Chapter 21: Direct Memory Access Controller (eDMA)

// Control Register
let DMA_TCD_ATTR_SIZE_8BIT   $uint4 = 0
let DMA_TCD_ATTR_SIZE_16BIT  $uint4 = 1
let DMA_TCD_ATTR_SIZE_32BIT  $uint4 = 2
let DMA_TCD_ATTR_SIZE_16BYTE $uint4 = 4
let DMA_TCD_ATTR_SIZE_32BYTE $uint4 = 5

registers DMA {
  CR 0x4000_8000 $uint32 {
    14,
    CX, // Cancel Transfer
    ECX, // Error Cancel Transfer
    5,
    GRP1PRI,
    1,
    GRP0PRI,
    EMLM, // Enable Minor Loop Mapping
    CLM, // Continuous Link Mode
    HALT, // Halt DMA Operations
    HOE, // Halt On Error
    ERGA, // Enable Round Robin Group Arbitration
    ERCA, // Enable Round Robin Channel Arbitration 
    EDBG, // Enable Debug
    1
  }
  
  // Error Status Register
  ES  0x4000_8004 $uint32 {
    VLD, 14, ECX, 1, CPE, 2, ERRCHN [4], SAE, SOE, DAE, DOE, NCE, SGE, SBE, DBE
  }
  
  ERQ 0x4000_800C $uint32 { // Enable Request Register
   16, 
   ERQ15, ERQ14, ERQ13, ERQ12, ERQ11, ERQ10, ERQ9,  ERQ8,
   ERQ7,  ERQ6,  ERQ5,  ERQ4,  ERQ3,  ERQ2,  ERQ1,  ERQ0
  }
  
  EEI 0x4000_8014 $uint32 { // Enable Error Interrupt Register
   16, 
   EEI15, EEI14, EEI13, EEI12, EEI11, EEI10, EEI9,  EEI8,
   EEI7,  EEI6,  EEI5,  EEI4,  EEI3,  EEI2,  EEI1,  EEI0
  }
  
  CEEI 0x4000_8018 $uint8 { // Clear Enable Error Interrupt Register
   NOP, CAAE, 2, CEEI [4]
  }
  
  SEEI 0x4000_8019 $uint8 { // Set Enable Error Interrupt Register
   NOP, SAAE, 2, SEEI [4]
  }
  
  CERQ 0x4000_801A $uint8 { // Clear Enable Request Register
   NOP, CAER, 2, CERQ [4]
  }
  
  SERQ 0x4000_801B $uint8 { // Set Enable Request Register
   NOP, SAER, 2, SERQ [4]
  }
  
  CDNE 0x4000_801C $uint8 { // Clear DONE Status Bit Register
   NOP, CADN, 2, CDNE [4]
  }
  
  SSRT 0x4000_801D $uint8 { // Set START Bit Register
   NOP, SAST, 2, SSRT [4]
  }
  
  CERR 0x4000_801E $uint8 { // Clear Error Register
   NOP, CAEI, 2, CERR [4]
  }
  
  CINT 0x4000_801F $uint8 { // Clear Interrupt Request Register
   NOP, CAIR, 2, CINT [4]
  }
  
  INT 0x4000_8024 $uint32 { // Interrupt Request Register
   16, 
   INT15, INT14, INT13, INT12, INT11, INT10, INT9,  INT8,
   INT7,  INT6,  INT5,  INT4,  INT3,  INT2,  INT1,  INT0
  }
  
  ERR 0x4000_802C $uint32 { // Error Register
   16, 
   ERR15, ERR14, ERR13, ERR12, ERR11, ERR10, ERR9,  ERR8,
   ERR7,  ERR6,  ERR5,  ERR4,  ERR3,  ERR2,  ERR1,  ERR0
  }
  
  HRS 0x4000_8034 $uint32 { // Hardware Request Status Register
   16, 
   HRS15, HRS14, HRS13, HRS12, HRS11, HRS10, HRS9,  HRS8,
   HRS7,  HRS6,  HRS5,  HRS4,  HRS3,  HRS2,  HRS1,  HRS0
  }
  
  DCHPRI [DMA_CHANNEL_COUNT] 0x4000_8100 : 1 $uint8 { // Channel n Priority Register
   ECP, DPA, 2, CHPRI [4]
  }
  
  TCD_SADDR [DMA_CHANNEL_COUNT] 0x4000_9000 : 32 $uint32 // TCD Source Address
  
  TCD_SOFF [DMA_CHANNEL_COUNT] 0x4000_9004 : 32 $int16 // TCD Signed Source Address Offset
  
  TCD_ATTR [DMA_CHANNEL_COUNT] 0x4000_9006 : 32 $uint16 { // TCD Transfer Attributes
    SMOD [4], SSIZE [4], DMOD [4], DSIZE [4]
  }
  
  // TCD Minor Byte Count (Minor Loop Disabled)
  TCD_NBYTES_MLNO [DMA_CHANNEL_COUNT] 0x4000_9008 : 32 $uint32
  
  // TCD Last Source Address Adjustment
  TCD_SLAST [DMA_CHANNEL_COUNT] 0x4000_900C : 32 $int32
  
  // TCD Destination Address
  TCD_DADDR [DMA_CHANNEL_COUNT] 0x4000_9010 : 32 $uint32
  
  // TCD Signed Destination Address Offset
  TCD_DOFF [DMA_CHANNEL_COUNT] 0x4000_9014 : 32 $int16
  
  // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  TCD_CITER_ELINKNO [DMA_CHANNEL_COUNT] 0x4000_9016 : 32 $uint16 {
    ELINK, CITER [15]
  }
  
  // TCD Last Destination Address Adjustment/Scatter Gather Address
  TCD_DLASTSGA [DMA_CHANNEL_COUNT] 0x4000_9018 : 32 $int32
  
  // TCD Control and Status 
  TCD_CSR [DMA_CHANNEL_COUNT] 0x4000_901C : 32 $uint16 {
    BWC [2], 2, MAJORLINKCH [4],
    DONE, ACTIVE, MAJORLINK, ESG, DREQ, INTHALF, INTMAJOR, START
  }
  
  // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) 
  TCD_BITER_ELINKNO [DMA_CHANNEL_COUNT] 0x4000_901E : 32 $uint16 {
    ELINK, BITER [15]
  }
}

//// Chapter 22: External Watchdog Monitor (EWM)
//registers EWM_CTRL  *(volatile $uint8_t  *)0x40061000 // Control Register
//registers EWM_SERV  *(volatile $uint8_t  *)0x40061001 // Service Register
//registers EWM_CMPL  *(volatile $uint8_t  *)0x40061002 // Compare Low Register
//registers EWM_CMPH  *(volatile $uint8_t  *)0x40061003 // Compare High Register
//
//// Chapter 23: Watchdog Timer (WDOG)
let WDOG_STCTRLH_DISTESTWDOG $uint16 = 0x4000  // Allows the WDOG's functional test mode to be disabled permanently.

let WDOG_STCTRLH_TESTSEL  $uint16 = 0x0800
let WDOG_STCTRLH_TESTWDOG $uint16 = 0x0400
let WDOG_STCTRLH_WAITEN $uint16 = 0x0080
let WDOG_STCTRLH_STOPEN $uint16 = 0x0040
let WDOG_STCTRLH_DBGEN  $uint16 = 0x0020
let WDOG_STCTRLH_ALLOWUPDATE $uint16 = 0x0010
let WDOG_STCTRLH_WINEN $uint16 = 0x0008
let WDOG_STCTRLH_IRQRSTEN $uint16 = 0x0004
let WDOG_STCTRLH_CLKSRC $uint16 = 0x0002
let WDOG_STCTRLH_WDOGEN $uint16 = 0x0001

let WDOG_UNLOCK_SEQ1 $uint16   = 0xC520
let WDOG_UNLOCK_SEQ2 $uint16   = 0xD928

registers WDOG {
  STCTRLH 0x40052000 $uint16 // Watchdog Status and Control registers High
  STCTRLL  0x40052002 $uint16 // Watchdog Status and Control registers Low
  TOVALH   0x40052004 $uint16 // Watchdog Time-out Value registers High
  TOVALL   0x40052006 $uint16 // Watchdog Time-out Value registers Low
  WINH     0x40052008 $uint16 // Watchdog Window registers High
  WINL     0x4005200A $uint16 // Watchdog Window registers Low
  REFRESH  0x4005200C $uint16 // Watchdog Refresh register
  UNLOCK   0x4005200E $uint16 // Watchdog Unlock register
  TMROUTH  0x40052010 $uint16 // Watchdog Timer Output registers High
  TMROUTL  0x40052012 $uint16 // Watchdog Timer Output registers Low
  RSTCNT   0x40052014 $uint16 // Watchdog Reset Count register
  PRESC    0x40052016 $uint16 // Watchdog Prescaler register
}

// Chapter 24: Multipurpose Clock Generator (MCG)
let MCG_C4_SCFTRIM $uint8 = 0x01   // Slow Internal Reference Clock Fine Trim
let MCG_C4_DMX32 $uint8 = 0x80   // DCO Maximum Frequency with 32.768 kHz Reference, controls whether the DCO frequency range is narrowed
let MCG_SC_LOCS0 $uint8 = 0x01   // OSC0 Loss of Clock Status
//SC_FCRDIV(n)  ($uint8_t)(((n) & 0x07) << 1) // Fast Clock Internal Reference Divider
let MCG_SC_FLTPRSRV $uint8 = 0x10   // FLL Filter Preserve Enable
let MCG_SC_ATMF $uint8 = 0x20   // Automatic Trim Machine Fail Flag
let MCG_SC_ATMS $uint8 = 0x40   // Automatic Trim Machine Select
let MCG_SC_ATME $uint8 = 0x80   // Automatic Trim Machine Enable

registers MCG {
  C1 0x40064000 $uint8 { // MCG Control 1 Register
    CLKS [2], // Clock Source Select, Selects the clock source for MCGOUTCLK
    FRDIV [3], // FLL External Reference Divider, Selects the amount to divide down the external reference clock for the FLL
    IREFS, // Internal Reference Select, Selects the reference clock source for the FLL
    IRCLKEN, // Internal Reference Clock Enable, Enables the internal reference clock for use as MCGIRCLK
    IREFSTEN // Internal Reference Stop Enable, Controls whether or not the internal reference clock remains enabled when the MCG enters Stop mode
  }
  
  C2 0x4006_4001 $uint8 { // MCG Control 2 Register
    LOCRE0, // Loss of Clock Reset Enable, Determines whether an interrupt 
            // or a reset request is made following a loss of OSC0
    1,
    RANGE0[2], // Frequency Range Select, Selects the frequency range
               // for the crystal oscillator
    HGO0, // High Gain Oscillator Select, Controls the crystal oscillator mode of operation  
    EREFS, // External Reference Select, selects the source for the external reference clock
    LP, // Low Power Select, Controls whether the FLL or PLL is disabled in BLPI and BLPE modes.
    IRCS // Internal Reference Clock Select, Selects between the fast or slow internal reference clock source.
  }
  
  C3 0x4006_4002 $uint8 // MCG Control 3 Register
  //C3_SCTRIM(n)  ($uint8_t)(n)   // Slow Internal Reference Clock Trim Setting
  C4 0x40064003 $uint8 // MCG Control 4 Register
  //C4_FCTRIM(n)  ($uint8_t)(((n) & 0x0F) << 1) // Fast Internal Reference Clock Trim Setting
  //C4_DRST_DRS(n)  ($uint8_t)(((n) & 0x03) << 5) // DCO Range Select  
  
  C5 0x4006_4004 $uint8 { // MCG Control 5 Register
   1,
   PLLCLKEN0, // PLL Clock Enable
   PLLSTEN0,  // PLL Stop Enable
   PRDIV0 [5] // PLL External Reference Divider
  }
  
  C6 0x4006_4005 $uint8 { // MCG Control 6 Register
   LOLIE0, // Loss of Lock Interrrupt Enable
   PLLS, // PLL Select, Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00
   CME0,   // Clock Monitor Enable
   VDIV0[5] // VCO 0 Divider
  }
  
  S @ro 0x40064006 $uint8 { // MCG Status Register
   LOLS0, // Loss of Lock Status
   LOCK0, // Lock Status, 0=PLL Unlocked, 1=PLL Locked
   PLLST, // PLL Select Status
   IREFST, // Internal Reference Status
   CLKST [2], // Clock Mode Status, 0=FLL is selected, 1= Internal ref, 2=External ref, 3=PLL
   OSCINIT0, // OSC Initialization, resets to 0, is set to 1 after the initialization cycles of the crystal oscillator
   IRCST   // Internal Reference Clock Status
  }
  
  SC 0x40064008 $uint8 // MCG Status and Control Register
  
  ATCVH 0x4006400A $uint8 // MCG Auto Trim Compare Value High Register
  ATCVL 0x4006400B $uint8 // MCG Auto Trim Compare Value Low Register
  C7    0x4006400C $uint8 // MCG Control 7 Register
  C8    0x4006400D $uint8 // MCG Control 8 Register
}

//// Chapter 25: Oscillator (OSC)
let OSC_SC16P  $uint8 = 0x01   

registers OSC {
  CR 0x40065000 $uint8 {// OSC Control Register
    ERCLKEN, // External Reference Enable, Enables external reference clock (OSCERCLK)
    1,
    EREFSTEN, // External Reference Stop Enable, Controls whether or not 
              // the external reference clock (OSCERCLK) remains enabled when
              // MCU enters Stop mode.
    1,
    SC2P, // Oscillator 2 pF Capacitor Load Configure
    SC4P, // Oscillator 4 pF Capacitor Load Configure
    SC8P, // Oscillator 8 pF Capacitor Load Configure
    SC16P // Oscillator 16 pF Capacitor Load Configure
  }
}

//// Chapter 27: Flash Memory Controller (FMC)
registers FMC {
  PFAPR     0x4001F000 $uint32 // Flash Access Protection
  PFB0CR    0x4001F004 $uint32 // Flash Control
  TAGVDW0S0 0x4001F100 $uint32 // Cache Tag Storage
  TAGVDW0S1 0x4001F104 $uint32 // Cache Tag Storage
  TAGVDW1S0 0x4001F108 $uint32 // Cache Tag Storage
  TAGVDW1S1 0x4001F10C $uint32 // Cache Tag Storage
  TAGVDW2S0 0x4001F110 $uint32 // Cache Tag Storage
  TAGVDW2S1 0x4001F114 $uint32 // Cache Tag Storage
  TAGVDW3S0 0x4001F118 $uint32 // Cache Tag Storage
  TAGVDW3S1 0x4001F11C $uint32 // Cache Tag Storage
  DATAW0S0  0x4001F200 $uint32 // Cache Data Storage
  DATAW0S1  0x4001F204 $uint32 // Cache Data Storage
  DATAW1S0  0x4001F208 $uint32 // Cache Data Storage
  DATAW1S1  0x4001F20C $uint32 // Cache Data Storage
  DATAW2S0  0x4001F210 $uint32 // Cache Data Storage
  DATAW2S1  0x4001F214 $uint32 // Cache Data Storage
  DATAW3S0  0x4001F218 $uint32 // Cache Data Storage
  DATAW3S1  0x4001F21C $uint32 // Cache Data Storage
}


//// Chapter 28: Flash Memory Module (FTFL)
//registers FTFL_FST *(volatile $uint8_t  *)0x40020000      // Flash Status Register
//registers FTFL_FSTAT_CCIF   ($uint8_t)0x80   // Command Complete Interrupt Flag
//registers FTFL_FSTAT_RDCOLERR  ($uint8_t)0x40   // Flash Read Collision Error Flag
//registers FTFL_FSTAT_ACCERR  ($uint8_t)0x20   // Flash Access Error Flag
//registers FTFL_FSTAT_FPVIOL  ($uint8_t)0x10   // Flash Protection Violation Flag
//registers FTFL_FSTAT_MGSTAT0  ($uint8_t)0x01   // Memory Controller Command Completion Status Flag
//registers FTFL_FCNFG  *(volatile $uint8_t  *)0x40020001      // Flash Configuration Register
//registers FTFL_FCNFG_CCIE   ($uint8_t)0x80   // Command Complete Interrupt Enable
//registers FTFL_FCNFG_RDCOLLIE  ($uint8_t)0x40   // Read Collision Error Interrupt Enable
//registers FTFL_FCNFG_ERSAREQ  ($uint8_t)0x20   // Erase All Request
//registers FTFL_FCNFG_ERSSUSP  ($uint8_t)0x10   // Erase Suspend
//registers FTFL_FCNFG_PFLSH  ($uint8_t)0x04   // Flash memory configuration
//registers FTFL_FCNFG_RAMRDY  ($uint8_t)0x02   // RAM Ready
//registers FTFL_FCNFG_EEERDY  ($uint8_t)0x01   // EEPROM Ready
//registers FTFL_FSEC  *(const    $uint8_t  *)0x40020002      // Flash Security Register
//registers FTFL_FOPT  *(const    $uint8_t  *)0x40020003      // Flash Option Register
//registers FTFL_FCCOB3  *(volatile $uint8_t  *)0x40020004      // Flash Common Command Object Registers
//registers FTFL_FCCOB2  *(volatile $uint8_t  *)0x40020005
//registers FTFL_FCCOB1  *(volatile $uint8_t  *)0x40020006
//registers FTFL_FCCOB0  *(volatile $uint8_t  *)0x40020007
//registers FTFL_FCCOB7  *(volatile $uint8_t  *)0x40020008
//registers FTFL_FCCOB6  *(volatile $uint8_t  *)0x40020009
//registers FTFL_FCCOB5  *(volatile $uint8_t  *)0x4002000A
//registers FTFL_FCCOB4  *(volatile $uint8_t  *)0x4002000B
//registers FTFL_FCCOBB  *(volatile $uint8_t  *)0x4002000C
//registers FTFL_FCCOBA  *(volatile $uint8_t  *)0x4002000D
//registers FTFL_FCCOB9  *(volatile $uint8_t  *)0x4002000E
//registers FTFL_FCCOB8  *(volatile $uint8_t  *)0x4002000F
//registers FTFL_FPROT3  *(volatile $uint8_t  *)0x40020010      // Program Flash Protection Registers
//registers FTFL_FPROT2  *(volatile $uint8_t  *)0x40020011      // Program Flash Protection Registers
//registers FTFL_FPROT1  *(volatile $uint8_t  *)0x40020012      // Program Flash Protection Registers
//registers FTFL_FPROT0  *(volatile $uint8_t  *)0x40020013      // Program Flash Protection Registers
//registers FTFL_FEPROT  *(volatile $uint8_t  *)0x40020016      // EEPROM Protection Register
//registers FTFL_FDPROT  *(volatile $uint8_t  *)0x40020017      // Data Flash Protection Register

// Chapter 30: Cyclic Redundancy Check (CRC)
registers CRC {
  CRC   0x40032000 $uint32 // CRC Data register
  GPOLY 0x40032004 $uint32 // CRC Polynomial register
  CTRL  0x40032008 $uint32 // CRC Control register
}

// Chapter 31: Analog-to-Digital Converter (ADC)
let ADC_SC1_COCO  $uint32 = 0x80   // Conversion complete flag
let ADC_SC1_AIEN  $uint32 = 0x40   // Interrupt enable
let ADC_SC1_DIFF  $uint32 = 0x20   // Differential mode enable

let ADC_CFG1_ADLPC  $uint32 = 0x80   // Low-power configuration
let ADC_CFG1_ADLSMP  $uint32 = 0x10   // Sample time configuration, 0=Short, 1=Long

let ADC_CFG2_MUXSEL  $uint32 = 0x10   // 0=a channels, 1=b channels
let ADC_CFG2_ADACKEN  $uint32 = 0x08   // async clock enable
let ADC_CFG2_ADHSC   $uint32 = 0x04   // High speed configuration

let ADC_SC2_ADACT  $uint32 = 0x80   // Conversion active
let ADC_SC2_ADTRG  $uint32 = 0x40   // Conversion trigger select, 0=software, 1=hardware
let ADC_SC2_ACFE   $uint32 = 0x20   // Compare function enable
let ADC_SC2_ACFGT  $uint32 = 0x10   // Compare function greater than enable
let ADC_SC2_ACREN  $uint32 = 0x08   // Compare function range enable
let ADC_SC2_DMAEN  $uint32= 0x04   // DMA enable

let ADC_SC3_CAL  $uint32 = 0x80   // Calibration, 1=begin, stays set while cal in progress
let ADC_SC3_CALF  $uint32= 0x40   // Calibration failed flag
let ADC_SC3_ADCO  $uint32= 0x08   // Continuous conversion enable
let ADC_SC3_AVGE  $uint32= 0x04   // Hardware average enable

let ADC0_PGA_PGAEN  $uint32 = 0x00800000  // Enable
let ADC0_PGA_PGALPB  $uint32 = 0x00100000  // Low-Power Mode Control, 0=low power, 1=normal

registers ADC0 {
  SC1A   0x4003B000 $uint32 // ADC status and control registers 1
  SC1B   0x4003B004 $uint32 // ADC status and control registers 1
  CFG1   0x4003B008 $uint32 // ADC configuration registers 1
  CFG2  0x4003B00C $uint32 // Configuration registers 2
  RA    0x4003B010 $uint32 // ADC data result register
  RB    0x4003B014 $uint32 // ADC data result register
  CV1   0x4003B018 $uint32 // Compare value registers
  CV2   0x4003B01C $uint32 // Compare value registers
  SC2   0x4003B020 $uint32 // Status and control registers 2
  SC3   0x4003B024 $uint32 // Status and control registers 3
  OFS   0x4003B028 $uint32 // ADC offset correction register
  PG    0x4003B02C $uint32 // ADC plus-side gain register
  MG    0x4003B030 $uint32 // ADC minus-side gain register
  CLPD  0x4003B034 $uint32 // ADC plus-side general calibration value register
  CLPS  0x4003B038 $uint32 // ADC plus-side general calibration value register
  CLP4  0x4003B03C $uint32 // ADC plus-side general calibration value register
  CLP3  0x4003B040 $uint32 // ADC plus-side general calibration value register
  CLP2  0x4003B044 $uint32 // ADC plus-side general calibration value register
  CLP1  0x4003B048 $uint32 // ADC plus-side general calibration value register
  CLP0  0x4003B04C $uint32 // ADC plus-side general calibration value register
  PGA   0x4003B050 $uint32 // ADC Programmable Gain Amplifier
  CLMD   0x4003B054 $uint32 // ADC minus-side general calibration value register
  CLMS   0x4003B058 $uint32 // ADC minus-side general calibration value register
  CLM4   0x4003B05C $uint32 // ADC minus-side general calibration value register
  CLM3   0x4003B060 $uint32 // ADC minus-side general calibration value register
  CLM2   0x4003B064 $uint32 // ADC minus-side general calibration value register
  CLM1   0x4003B068 $uint32 // ADC minus-side general calibration value register
  CLM0   0x4003B06C $uint32 // ADC minus-side general calibration value register
}

registers ADC1 {
  SC1A   0x400BB000 $uint32 // ADC status and control registers 1
  SC1B   0x400BB004 $uint32 // ADC status and control registers 1
  CFG1   0x400BB008 $uint32 // ADC configuration registers 1
  CFG2   0x400BB00C $uint32 // Configuration registers 2
  RA     0x400BB010 $uint32 // ADC data result register
  RB     0x400BB014 $uint32 // ADC data result register
  CV1    0x400BB018 $uint32 // Compare value registers
  CV2    0x400BB01C $uint32 // Compare value registers
  SC2    0x400BB020 $uint32 // Status and control registers 2
  SC3    0x400BB024 $uint32 // Status and control registers 3
  OFS    0x400BB028 $uint32 // ADC offset correction register
  PG     0x400BB02C $uint32 // ADC plus-side gain register
  MG     0x400BB030 $uint32 // ADC minus-side gain register
  CLPD   0x400BB034 $uint32 // ADC plus-side general calibration value register
  CLPS   0x400BB038 $uint32 // ADC plus-side general calibration value register
  CLP4   0x400BB03C $uint32 // ADC plus-side general calibration value register
  CLP3   0x400BB040 $uint32 // ADC plus-side general calibration value register
  CLP2   0x400BB044 $uint32 // ADC plus-side general calibration value register
  CLP1   0x400BB048 $uint32 // ADC plus-side general calibration value register
  CLP0   0x400BB04C $uint32 // ADC plus-side general calibration value register
  PGA    0x400BB050 $uint32 // ADC Programmable Gain Amplifier
  CLMD   0x400BB054 $uint32 // ADC minus-side general calibration value register
  CLMS   0x400BB058 $uint32 // ADC minus-side general calibration value register
  CLM4   0x400BB05C $uint32 // ADC minus-side general calibration value register
  CLM3   0x400BB060 $uint32 // ADC minus-side general calibration value register
  CLM2   0x400BB064 $uint32 // ADC minus-side general calibration value register
  CLM1   0x400BB068 $uint32 // ADC minus-side general calibration value register
  CLM0   0x400BB06C $uint32 // ADC minus-side general calibration value register
}

let DAC_C1_DMAEN $uint8 = 0x80    // DMA Enable Select
let DAC_C1_DACBFEN $uint8 = 0x00    // DAC Buffer Enable

let DAC_C0_DACEN  $uint8 = 0x80    // DAC Enable
let DAC_C0_DACRFS $uint8 = 0x40    // DAC Reference Select
let DAC_C0_DACTRGSEL $uint8 = 0x20    // DAC Trigger Select
let DAC_C0_DACSWTRG  $uint8 = 0x10    // DAC Software Trigger
let DAC_C0_LPEN  $uint8 = 0x08    // DAC Low Power Control
let DAC_C0_DACBWIEN  $uint8 = 0x04    // DAC Buffer Watermark Interrupt Enable
let DAC_C0_DACBTIEN $uint8 = 0x02    // DAC Buffer Read Pointer Top Flag Interrupt Enable
let DAC_C0_DACBBIEN $uint8 = 0x01    // DAC Buffer Read Pointer Bottom Flag Interrupt Enable

registers DAC0 {
  DAT0L 0x400CC000 $uint8 // DAC Data Low registers 
  DATH  0x400CC001 $uint8 // DAC Data High registers 
  DAT1L 0x400CC002 $uint8 // DAC Data Low registers 
  DAT2L 0x400CC004 $uint8 // DAC Data Low registers 
  DAT3L 0x400CC006 $uint8 // DAC Data Low registers 
  DAT4L 0x400CC008 $uint8 // DAC Data Low registers 
  DAT5L 0x400CC00A $uint8 // DAC Data Low registers 
  DAT6L 0x400CC00C $uint8 // DAC Data Low registers 
  DAT7L 0x400CC00E $uint8 // DAC Data Low registers 
  DAT8L 0x400CC010 $uint8 // DAC Data Low registers 
  DAT9L 0x400CC012 $uint8 // DAC Data Low registers 
  DAT10L 0x400CC014 $uint8 // DAC Data Low registers 
  DAT11L 0x400CC016 $uint8 // DAC Data Low registers 
  DAT12L 0x400CC018 $uint8 // DAC Data Low registers 
  DAT13L 0x400CC01A $uint8 // DAC Data Low registers 
  DAT14L 0x400CC01C $uint8 // DAC Data Low registers 
  DAT15L 0x400CC01E $uint8 // DAC Data Low registers 
  SR     0x400CC020 $uint8 // DAC Status registers 
  C0     0x400CC021 $uint8 // DAC Control registers 
  C1  0x400CC022 $uint8 // DAC Control registers 1 
  C2  0x400CC023 $uint8 // DAC Control registers 2 
}
//// Chapter 32: Comparator (CMP)
registers CMP0 {
  CR0   0x40073000 $uint8 // CMP Control registers 0
  CR1   0x40073001 $uint8 // CMP Control registers 1
  FPR   0x40073002 $uint8 // CMP Filter Period Register
  SCR   0x40073003 $uint8 // CMP Status and Control Register
  DACCR 0x40073004 $uint8 // DAC Control Register
  MUXCR 0x40073005 $uint8 // MUX Control Register
}

registers CMP1 {
  CR0   0x40073008 $uint8 // CMP Control registers 0
  CR1   0x40073009 $uint8 // CMP Control registers 1
  FPR   0x4007300A $uint8 // CMP Filter Period Register
  SCR   0x4007300B $uint8 // CMP Status and Control Register
  DACCR 0x4007300C $uint8 // DAC Control Register
  MUXCR 0x4007300D $uint8 // MUX Control Register
}

//// Chapter 33: Voltage Reference (VREFV1)
registers VREF {
  TRM  0x40074000 $uint8 // VREF Trim Register
  SC   0x40074001 $uint8 // VREF Status and Control Register
}

// Chapter 34: Programmable Delay Block (PDB)
//registers PDB0_SC    0x40036000 // Status and Control Register
//registers PDB_SC_LDMOD(n)   (((n) & 3) << 18) // Load Mode Select
//registers PDB_SC_PDBEIE   0x00020000  // Sequence Error Interrupt Enable
//registers PDB_SC_SWTRIG   0x00010000  // Software Trigger
//registers PDB_SC_DMAEN   0x00008000  // DMA Enable
//registers PDB_SC_PRESCALER(n)  (((n) & 7) << 12) // Prescaler Divider Select
//registers PDB_SC_TRGSEL(n)  (((n) & 15) << 8) // Trigger Input Source Select
//registers PDB_SC_PDBEN   0x00000080  // PDB Enable
//registers PDB_SC_PDBIF   0x00000040  // PDB Interrupt Flag
//registers PDB_SC_PDBIE   0x00000020  // PDB Interrupt Enable.
//registers PDB_SC_MULT(n)   (((n) & 3) << 2) // Multiplication Factor
//registers PDB_SC_CONT   0x00000002  // Continuous Mode Enable
//registers PDB_SC_LDOK   0x00000001  // Load OK
//registers PDB0_MOD   0x40036004 // Modulus Register
//registers PDB0_CNT   0x40036008 // Counter Register
//registers PDB0_IDLY   0x4003600C // Interrupt Delay Register
//registers PDB0_CH0C1   0x40036010 // Channel n Control registers 1
//registers PDB0_CH0S   0x40036014 // Channel n Status Register
//registers PDB0_CH0DLY0   0x40036018 // Channel n Delay 0 Register
//registers PDB0_CH0DLY1   0x4003601C // Channel n Delay 1 Register
//registers PDB0_POEN   0x40036190 // Pulse-Out n Enable Register
//registers PDB0_PO0DLY   0x40036194 // Pulse-Out n Delay Register
//registers PDB0_PO1DLY   0x40036198 // Pulse-Out n Delay Register
//
//// Chapter 35: FlexTimer Module (FTM)
//registers FTM0_SC    0x40038000 // Status And Control
//registers FTM_SC_TOF   0x80    // Timer Overflow Flag
//registers FTM_SC_TOIE   0x40    // Timer Overflow Interrupt Enable
//registers FTM_SC_CPWMS   0x20    // Center-Aligned PWM Select
//registers FTM_SC_CLKS(n)   (((n) & 3) << 3)  // Clock Source Selection
//registers FTM_SC_PS(n)   (((n) & 7) << 0)  // Prescale Factor Selection
//registers FTM0_CNT   0x40038004 // Counter
//registers FTM0_MOD   0x40038008 // Modulo
//registers FTM0_C0SC   0x4003800C // Channel 0 Status And Control
//registers FTM0_C0V   0x40038010 // Channel 0 Value
//registers FTM0_C1SC   0x40038014 // Channel 1 Status And Control
//registers FTM0_C1V   0x40038018 // Channel 1 Value
//registers FTM0_C2SC   0x4003801C // Channel 2 Status And Control
//registers FTM0_C2V   0x40038020 // Channel 2 Value
//registers FTM0_C3SC   0x40038024 // Channel 3 Status And Control
//registers FTM0_C3V   0x40038028 // Channel 3 Value
//registers FTM0_C4SC   0x4003802C // Channel 4 Status And Control
//registers FTM0_C4V   0x40038030 // Channel 4 Value
//registers FTM0_C5SC   0x40038034 // Channel 5 Status And Control
//registers FTM0_C5V   0x40038038 // Channel 5 Value
//registers FTM0_C6SC   0x4003803C // Channel 6 Status And Control
//registers FTM0_C6V   0x40038040 // Channel 6 Value
//registers FTM0_C7SC   0x40038044 // Channel 7 Status And Control
//registers FTM0_C7V   0x40038048 // Channel 7 Value
//registers FTM0_CNTIN   0x4003804C // Counter Initial Value
//registers FTM0_STATUS   0x40038050 // Capture And Compare Status
//registers FTM0_MODE   0x40038054 // Features Mode Selection
//registers FTM_MODE_FAULTIE  0x80    // Fault Interrupt Enable
//registers FTM_MODE_FAULTM(n)  (((n) & 3) << 5)  // Fault Control Mode
//registers FTM_MODE_CAPTEST  0x10    // Capture Test Mode Enable
//registers FTM_MODE_PWMSYNC  0x08    // PWM Synchronization Mode
//registers FTM_MODE_WPDIS   0x04    // Write Protection Disable
//registers FTM_MODE_INIT   0x02    // Initialize The Channels Output
//registers FTM_MODE_FTMEN   0x01    // FTM Enable
//registers FTM0_SYNC   0x40038058 // Synchronization
//registers FTM_SYNC_SWSYNC   0x80    // 
//registers FTM_SYNC_TRIG2   0x40    // 
//registers FTM_SYNC_TRIG1   0x20    // 
//registers FTM_SYNC_TRIG0   0x10    // 
//registers FTM_SYNC_SYNCHOM  0x08    // 
//registers FTM_SYNC_REINIT   0x04    // 
//registers FTM_SYNC_CNTMAX   0x02    // 
//registers FTM_SYNC_CNTMIN   0x01    // 
//registers FTM0_OUTINIT   0x4003805C // Initial State For Channels Output
//registers FTM0_OUTMASK   0x40038060 // Output Mask
//registers FTM0_COMBINE   0x40038064 // Function For Linked Channels
//registers FTM0_DEADTIME   0x40038068 // Deadtime Insertion Control
//registers FTM0_EXTTRIG   0x4003806C // FTM External Trigger
//registers FTM0_POL   0x40038070 // Channels Polarity
//registers FTM0_FMS   0x40038074 // Fault Mode Status
//registers FTM0_FILTER   0x40038078 // Input Capture Filter Control
//registers FTM0_FLTCTRL   0x4003807C // Fault Control
//registers FTM0_QDCTRL   0x40038080 // Quadrature Decoder Control And Status
//registers FTM0_CONF   0x40038084 // Configuration
//registers FTM0_FLTPOL   0x40038088 // FTM Fault Input Polarity
//registers FTM0_SYNCONF   0x4003808C // Synchronization Configuration
//registers FTM0_INVCTRL   0x40038090 // FTM Inverting Control
//registers FTM0_SWOCTRL   0x40038094 // FTM Software Output Control
//registers FTM0_PWMLOAD   0x40038098 // FTM PWM Load
//registers FTM1_SC    0x40039000 // Status And Control
//registers FTM1_CNT   0x40039004 // Counter
//registers FTM1_MOD   0x40039008 // Modulo
//registers FTM1_C0SC   0x4003900C // Channel 0 Status And Control
//registers FTM1_C0V   0x40039010 // Channel 0 Value
//registers FTM1_C1SC   0x40039014 // Channel 1 Status And Control
//registers FTM1_C1V   0x40039018 // Channel 1 Value
//registers FTM1_CNTIN   0x4003904C // Counter Initial Value
//registers FTM1_STATUS   0x40039050 // Capture And Compare Status
//registers FTM1_MODE   0x40039054 // Features Mode Selection
//registers FTM1_SYNC   0x40039058 // Synchronization
//registers FTM1_OUTINIT   0x4003905C // Initial State For Channels Output
//registers FTM1_OUTMASK   0x40039060 // Output Mask
//registers FTM1_COMBINE   0x40039064 // Function For Linked Channels
//registers FTM1_DEADTIME   0x40039068 // Deadtime Insertion Control
//registers FTM1_EXTTRIG   0x4003906C // FTM External Trigger
//registers FTM1_POL   0x40039070 // Channels Polarity
//registers FTM1_FMS   0x40039074 // Fault Mode Status
//registers FTM1_FILTER   0x40039078 // Input Capture Filter Control
//registers FTM1_FLTCTRL   0x4003907C // Fault Control
//registers FTM1_QDCTRL   0x40039080 // Quadrature Decoder Control And Status
//registers FTM1_CONF   0x40039084 // Configuration
//registers FTM1_FLTPOL   0x40039088 // FTM Fault Input Polarity
//registers FTM1_SYNCONF   0x4003908C // Synchronization Configuration
//registers FTM1_INVCTRL   0x40039090 // FTM Inverting Control
//registers FTM1_SWOCTRL   0x40039094 // FTM Software Output Control
//registers FTM1_PWMLOAD   0x40039098 // FTM PWM Load
//registers FTM2_SC    0x400B8000 // Status And Control
//registers FTM2_CNT   0x400B8004 // Counter
//registers FTM2_MOD   0x400B8008 // Modulo
//registers FTM2_C0SC   0x400B800C // Channel 0 Status And Control
//registers FTM2_C0V   0x400B8010 // Channel 0 Value
//registers FTM2_C1SC   0x400B8014 // Channel 1 Status And Control
//registers FTM2_C1V   0x400B8018 // Channel 1 Value
//registers FTM2_CNTIN   0x400B804C // Counter Initial Value
//registers FTM2_STATUS   0x400B8050 // Capture And Compare Status
//registers FTM2_MODE   0x400B8054 // Features Mode Selection
//registers FTM2_SYNC   0x400B8058 // Synchronization
//registers FTM2_OUTINIT   0x400B805C // Initial State For Channels Output
//registers FTM2_OUTMASK   0x400B8060 // Output Mask
//registers FTM2_COMBINE   0x400B8064 // Function For Linked Channels
//registers FTM2_DEADTIME   0x400B8068 // Deadtime Insertion Control
//registers FTM2_EXTTRIG   0x400B806C // FTM External Trigger
//registers FTM2_POL   0x400B8070 // Channels Polarity
//registers FTM2_FMS   0x400B8074 // Fault Mode Status
//registers FTM2_FILTER   0x400B8078 // Input Capture Filter Control
//registers FTM2_FLTCTRL   0x400B807C // Fault Control
//registers FTM2_QDCTRL   0x400B8080 // Quadrature Decoder Control And Status
//registers FTM2_CONF   0x400B8084 // Configuration
//registers FTM2_FLTPOL   0x400B8088 // FTM Fault Input Polarity
//registers FTM2_SYNCONF   0x400B808C // Synchronization Configuration
//registers FTM2_INVCTRL   0x400B8090 // FTM Inverting Control
//registers FTM2_SWOCTRL   0x400B8094 // FTM Software Output Control
//registers FTM2_PWMLOAD   0x400B8098 // FTM PWM Load


// Chapter 36: Periodic Interrupt Timer (PIT)

// PIT Module Control Register
let PIT_COUNT = 4

registers PIT {
  MCR 0x4003_7000 $uint32 {
    30, MDIS, FRZ
  }
  
  // Timer Load Value Register
  LDVAL [PIT_COUNT] 0x4003_7100 : 16 $uint32
  
  // Current Timer Value Register
  LCVAL [PIT_COUNT] 0x4003_7104 : 16 $uint32
  
  // Timer Control Register
  TCTRL [PIT_COUNT] 0x4003_7108 : 16 $uint32 {
    29, CHN, TIE, TEN
  }
  
  // Timer Flag Register
  TFLG [PIT_COUNT] 0x4003_710C : 16 $uint32 {
    31, TIF
  }
}

//
//// Chapter 37: Low-Power Timer (LPTMR)
//registers LPTMR0_CSR   0x40040000 // Low Power Timer Control Status Register
//registers LPTMR0_PSR   0x40040004 // Low Power Timer Prescale Register
//registers LPTMR0_CMR   0x40040008 // Low Power Timer Compare Register
//registers LPTMR0_CNR   0x4004000C // Low Power Timer Counter Register
//
//// Chapter 38: Carrier Modulator Transmitter (CMT)
//registers CMT_CGH1  *(volatile $uint8_t  *)0x40062000 // CMT Carrier Generator High Data registers 1
//registers CMT_CGL1  *(volatile $uint8_t  *)0x40062001 // CMT Carrier Generator Low Data registers 1
//registers CMT_CGH2  *(volatile $uint8_t  *)0x40062002 // CMT Carrier Generator High Data registers 2
//registers CMT_CGL2  *(volatile $uint8_t  *)0x40062003 // CMT Carrier Generator Low Data registers 2
//registers CMT_OC   *(volatile $uint8_t  *)0x40062004 // CMT Output Control Register
//registers CMT_MSC   *(volatile $uint8_t  *)0x40062005 // CMT Modulator Status and Control Register
//registers CMT_CMD1  *(volatile $uint8_t  *)0x40062006 // CMT Modulator Data registers Mark High
//registers CMT_CMD2  *(volatile $uint8_t  *)0x40062007 // CMT Modulator Data registers Mark Low
//registers CMT_CMD3  *(volatile $uint8_t  *)0x40062008 // CMT Modulator Data registers Space High
//registers CMT_CMD4  *(volatile $uint8_t  *)0x40062009 // CMT Modulator Data registers Space Low
//registers CMT_PPS   *(volatile $uint8_t  *)0x4006200A // CMT Primary Prescaler Register
//registers CMT_DMA   *(volatile $uint8_t  *)0x4006200B // CMT Direct Memory Access Register
//
//// Chapter 39: Real Time Clock (RTC)
let RTC_SR_TCE $uint32 = 0x00000010  
let RTC_SR_TAF $uint32 = 0x00000004  // 
let RTC_SR_TOF $uint32 = 0x00000002  // 
let RTC_SR_TIF $uint32 = 0x00000001  // 

registers RTC {
  TSR  0x4003D000 $uint32 // RTC Time Seconds Register
  TPR  0x4003D004 $uint32 // RTC Time Prescaler Register
  TAR  0x4003D008 $uint32 // RTC Time Alarm Register
  TCR  0x4003D00C $uint32 // RTC Time Compensation Register
  CR   0x4003D010 $uint32 {// RTC Control Register
    18, SC2P, SC4P, SC8P, SC16P,CKLO, OSCE, 4, UM, SUP, WPE, SWR
  }
  SR  0x4003D014 $uint32 // RTC Status Register
  LR  0x4003D018 $uint32 // RTC Lock Register
  IER 0x4003D01C $uint32 // RTC Interrupt Enable Register
  WAR 0x4003D800 $uint32 // RTC Write Access Register
  RAR 0x4003D804 $uint32 // RTC Read Access Register
}

//// Chapter 40: Universal Serial Bus OTG Controller (USBOTG)
//registers USB0_PERID  *(const    $uint8_t  *)0x40072000 // Peripheral ID register
//registers USB0_IDCOMP  *(const    $uint8_t  *)0x40072004 // Peripheral ID Complement register
//registers USB0_REV  *(const    $uint8_t  *)0x40072008 // Peripheral Revision register
//registers USB0_ADDINFO  *(volatile $uint8_t  *)0x4007200C // Peripheral Additional Info register
//registers USB0_OTGIST *(volatile $uint8_t  *)0x40072010 // OTG Interrupt Status register
//registers USB_OTGISTAT_IDCHG  ($uint8_t)0x80   //
//registers USB_OTGISTAT_ONEMSEC  ($uint8_t)0x40   //
//registers USB_OTGISTAT_LINE_STATE_CHG ($uint8_t)0x20   //
//registers USB_OTGISTAT_SESSVLDCHG  ($uint8_t)0x08   //
//registers USB_OTGISTAT_B_SESS_CHG  ($uint8_t)0x04   //
//registers USB_OTGISTAT_AVBUSCHG  ($uint8_t)0x01   //
//registers USB0_OTGICR  *(volatile $uint8_t  *)0x40072014 // OTG Interrupt Control Register
//registers USB_OTGICR_IDEN   ($uint8_t)0x80   // 
//registers USB_OTGICR_ONEMSECEN  ($uint8_t)0x40   // 
//registers USB_OTGICR_LINESTATEEN  ($uint8_t)0x20   // 
//registers USB_OTGICR_SESSVLDEN  ($uint8_t)0x08   // 
//registers USB_OTGICR_BSESSEN  ($uint8_t)0x04   // 
//registers USB_OTGICR_AVBUSEN  ($uint8_t)0x01   // 
//registers USB0_OTGST *(volatile $uint8_t  *)0x40072018 // OTG Status register
//registers USB_OTGSTAT_ID   ($uint8_t)0x80   // 
//registers USB_OTGSTAT_ONEMSECEN  ($uint8_t)0x40   // 
//registers USB_OTGSTAT_LINESTATESTABLE ($uint8_t)0x20   // 
//registers USB_OTGSTAT_SESS_VLD  ($uint8_t)0x08   // 
//registers USB_OTGSTAT_BSESSEND  ($uint8_t)0x04   // 
//registers USB_OTGSTAT_AVBUSVLD  ($uint8_t)0x01   // 
//registers USB0_OTGCTL  *(volatile $uint8_t  *)0x4007201C // OTG Control Register
//registers USB_OTGCTL_DPHIGH  ($uint8_t)0x80   // 
//registers USB_OTGCTL_DPLOW  ($uint8_t)0x20   // 
//registers USB_OTGCTL_DMLOW  ($uint8_t)0x10   // 
//registers USB_OTGCTL_OTGEN  ($uint8_t)0x04   // 
//registers USB0_IST *(volatile $uint8_t  *)0x40072080 // Interrupt Status Register
//registers USB_ISTAT_STALL   ($uint8_t)0x80   // 
//registers USB_ISTAT_ATTACH  ($uint8_t)0x40   // 
//registers USB_ISTAT_RESUME  ($uint8_t)0x20   // 
//registers USB_ISTAT_SLEEP   ($uint8_t)0x10   // 
//registers USB_ISTAT_TOKDNE  ($uint8_t)0x08   // 
//registers USB_ISTAT_SOFTOK  ($uint8_t)0x04   // 
//registers USB_ISTAT_ERROR   ($uint8_t)0x02   // 
//registers USB_ISTAT_USBRST  ($uint8_t)0x01   // 
//registers USB0_INTEN  *(volatile $uint8_t  *)0x40072084 // Interrupt Enable Register
//registers USB_INTEN_STALLEN  ($uint8_t)0x80   // 
//registers USB_INTEN_ATTACHEN  ($uint8_t)0x40   // 
//registers USB_INTEN_RESUMEEN  ($uint8_t)0x20   // 
//registers USB_INTEN_SLEEPEN  ($uint8_t)0x10   // 
//registers USB_INTEN_TOKDNEEN  ($uint8_t)0x08   // 
//registers USB_INTEN_SOFTOKEN  ($uint8_t)0x04   // 
//registers USB_INTEN_ERROREN  ($uint8_t)0x02   // 
//registers USB_INTEN_USBRSTEN  ($uint8_t)0x01   // 
//registers USB0_ERRST *(volatile $uint8_t  *)0x40072088 // Error Interrupt Status Register
//registers USB_ERRSTAT_BTSERR  ($uint8_t)0x80   // 
//registers USB_ERRSTAT_DMAERR  ($uint8_t)0x20   // 
//registers USB_ERRSTAT_BTOERR  ($uint8_t)0x10   // 
//registers USB_ERRSTAT_DFN8  ($uint8_t)0x08   // 
//registers USB_ERRSTAT_CRC16  ($uint8_t)0x04   // 
//registers USB_ERRSTAT_CRC5EOF  ($uint8_t)0x02   // 
//registers USB_ERRSTAT_PIDERR  ($uint8_t)0x01   // 
//registers USB0_ERREN  *(volatile $uint8_t  *)0x4007208C // Error Interrupt Enable Register
//registers USB_ERREN_BTSERREN  ($uint8_t)0x80   // 
//registers USB_ERREN_DMAERREN  ($uint8_t)0x20   // 
//registers USB_ERREN_BTOERREN  ($uint8_t)0x10   // 
//registers USB_ERREN_DFN8EN  ($uint8_t)0x08   // 
//registers USB_ERREN_CRC16EN  ($uint8_t)0x04   // 
//registers USB_ERREN_CRC5EOFEN  ($uint8_t)0x02   // 
//registers USB_ERREN_PIDERREN  ($uint8_t)0x01   // 
//registers USB0_ST *(volatile $uint8_t  *)0x40072090 // Status Register
//registers USB_STAT_TX   ($uint8_t)0x08   // 
//registers USB_STAT_ODD   ($uint8_t)0x04   // 
//registers USB_STAT_ENDP(n)  ($uint8_t)((n) >> 4)  // 
//registers USB0_CTL  *(volatile $uint8_t  *)0x40072094 // Control Register
//registers USB_CTL_JSTATE   ($uint8_t)0x80   // 
//registers USB_CTL_SE0   ($uint8_t)0x40   // 
//registers USB_CTL_TXSUSPENDTOKENBUSY ($uint8_t)0x20   // 
//registers USB_CTL_RESET   ($uint8_t)0x10   // 
//registers USB_CTL_HOSTMODEEN  ($uint8_t)0x08   // 
//registers USB_CTL_RESUME   ($uint8_t)0x04   // 
//registers USB_CTL_ODDRST   ($uint8_t)0x02   // 
//registers USB_CTL_USBENSOFEN  ($uint8_t)0x01   // 
//registers USB0_ADDR  *(volatile $uint8_t  *)0x40072098 // Address Register
//registers USB0_BDTPAGE1  *(volatile $uint8_t  *)0x4007209C // BDT Page registers 1
//registers USB0_FRMNUML  *(volatile $uint8_t  *)0x400720A0 // Frame Number registers Low
//registers USB0_FRMNUMH  *(volatile $uint8_t  *)0x400720A4 // Frame Number registers High
//registers USB0_TOKEN  *(volatile $uint8_t  *)0x400720A8 // Token Register
//registers USB0_SOFTHLD  *(volatile $uint8_t  *)0x400720AC // SOF Threshold Register
//registers USB0_BDTPAGE2  *(volatile $uint8_t  *)0x400720B0 // BDT Page registers 2
//registers USB0_BDTPAGE3  *(volatile $uint8_t  *)0x400720B4 // BDT Page registers 3
//registers USB0_ENDPT0  *(volatile $uint8_t  *)0x400720C0 // Endpoint Control Register
//registers USB_ENDPT_HOSTWOHUB  ($uint8_t)0x80   // host only, enable low speed
//registers USB_ENDPT_RETRYDIS  ($uint8_t)0x40   // host only, set to disable NAK retry
//registers USB_ENDPT_EPCTLDIS  ($uint8_t)0x10   // 0=control, 1=bulk, interrupt, isync
//registers USB_ENDPT_EPRXEN  ($uint8_t)0x08   // enables the endpoint for RX transfers.
//registers USB_ENDPT_EPTXEN  ($uint8_t)0x04   // enables the endpoint for TX transfers.
//registers USB_ENDPT_EPSTALL  ($uint8_t)0x02   // set to stall endpoint
//registers USB_ENDPT_EPHSHK  ($uint8_t)0x01   // enable handshaking during a transaction, generally set unless Isochronous
//registers USB0_ENDPT1  *(volatile $uint8_t  *)0x400720C4 // Endpoint Control Register
//registers USB0_ENDPT2  *(volatile $uint8_t  *)0x400720C8 // Endpoint Control Register
//registers USB0_ENDPT3  *(volatile $uint8_t  *)0x400720CC // Endpoint Control Register
//registers USB0_ENDPT4  *(volatile $uint8_t  *)0x400720D0 // Endpoint Control Register
//registers USB0_ENDPT5  *(volatile $uint8_t  *)0x400720D4 // Endpoint Control Register
//registers USB0_ENDPT6  *(volatile $uint8_t  *)0x400720D8 // Endpoint Control Register
//registers USB0_ENDPT7  *(volatile $uint8_t  *)0x400720DC // Endpoint Control Register
//registers USB0_ENDPT8  *(volatile $uint8_t  *)0x400720E0 // Endpoint Control Register
//registers USB0_ENDPT9  *(volatile $uint8_t  *)0x400720E4 // Endpoint Control Register
//registers USB0_ENDPT10  *(volatile $uint8_t  *)0x400720E8 // Endpoint Control Register
//registers USB0_ENDPT11  *(volatile $uint8_t  *)0x400720EC // Endpoint Control Register
//registers USB0_ENDPT12  *(volatile $uint8_t  *)0x400720F0 // Endpoint Control Register
//registers USB0_ENDPT13  *(volatile $uint8_t  *)0x400720F4 // Endpoint Control Register
//registers USB0_ENDPT14  *(volatile $uint8_t  *)0x400720F8 // Endpoint Control Register
//registers USB0_ENDPT15  *(volatile $uint8_t  *)0x400720FC // Endpoint Control Register
//registers USB0_USBCTRL  *(volatile $uint8_t  *)0x40072100 // USB Control Register
//registers USB_USBCTRL_SUSP  ($uint8_t)0x80   // Places the USB transceiver into the suspend state.
//registers USB_USBCTRL_PDE   ($uint8_t)0x40   // Enables the weak pulldowns on the USB transceiver.
//registers USB0_OBSERVE  *(volatile $uint8_t  *)0x40072104 // USB OTG Observe Register
//registers USB_OBSERVE_DPPU  ($uint8_t)0x80   // 
//registers USB_OBSERVE_DPPD  ($uint8_t)0x40   // 
//registers USB_OBSERVE_DMPD  ($uint8_t)0x10   // 
//registers USB0_CONTROL  *(volatile $uint8_t  *)0x40072108 // USB OTG Control Register
//registers USB_CONTROL_DPPULLUPNONOTG ($uint8_t)0x10   //  Provides control of the DP PULLUP in the USB OTG module, if USB is configured in non-OTG device mode.
//registers USB0_USBTRC0  *(volatile $uint8_t  *)0x4007210C // USB Transceiver Control registers 0
//registers USB_USBTRC_USBRESET  ($uint8_t)0x80   //
//registers USB_USBTRC_USBRESMEN  ($uint8_t)0x20   //
//registers USB_USBTRC_SYNC_DET  ($uint8_t)0x02   //
//registers USB_USBTRC_USB_RESUME_INT ($uint8_t)0x01   //
//registers USB0_USBFRMADJUST *(volatile $uint8_t  *)0x40072114 // Frame Adjust Register
//
//// Chapter 41: USB Device Charger Detection Module (USBDCD)
//registers USBDCD_CONTROL   0x40035000 // Control register
//registers USBDCD_CLOCK   0x40035004 // Clock register
//registers USBDCD_STATUS   0x40035008 // Status register
//registers USBDCD_TIMER0   0x40035010 // TIMER0 register
//registers USBDCD_TIMER1   0x40035014 // TIMER1 register
//registers USBDCD_TIMER2   0x40035018 // TIMER2 register
//
//// Chapter 43: SPI (DSPI)
//registers SPI0_MCR   0x4002C000 // DSPI Module Configuration Register
//registers SPI_MCR_MSTR    0x80000000  // Master/Slave Mode Select
//registers SPI_MCR_CONT_SCKE   0x40000000  // 
//registers SPI_MCR_DCONF(n)  (((n) & 3) << 28)  // 
//registers SPI_MCR_FRZ    0x08000000  // 
//registers SPI_MCR_MTFE    0x04000000  // 
//registers SPI_MCR_ROOE    0x01000000  // 
//registers SPI_MCR_PCSIS(n)  (((n) & 0x1F) << 16)  //
//registers SPI_MCR_DOZE    0x00008000  // 
//registers SPI_MCR_MDIS    0x00004000  // 
//registers SPI_MCR_DIS_TXF    0x00002000  // 
//registers SPI_MCR_DIS_RXF    0x00001000  // 
//registers SPI_MCR_CLR_TXF    0x00000800  // 
//registers SPI_MCR_CLR_RXF    0x00000400  // 
//registers SPI_MCR_SMPL_PT(n)  (((n) & 3) << 8)  //
//registers SPI_MCR_HALT    0x00000001  // 
//registers SPI0_TCR   0x4002C008 // DSPI Transfer Count Register
//registers SPI0_CTAR0   0x4002C00C // DSPI Clock and Transfer Attributes Register, In Master Mode
//registers SPI_CTAR_DBR    0x80000000  // Double Baud Rate
//registers SPI_CTAR_FMSZ(n)  (((n) & 15) << 27)  // Frame Size (+1)
//registers SPI_CTAR_CPOL    0x04000000  // Clock Polarity
//registers SPI_CTAR_CPHA    0x02000000  // Clock Phase
//registers SPI_CTAR_LSBFE    0x01000000  // LSB First
//registers SPI_CTAR_PCSSCK(n)  (((n) & 3) << 22)  // PCS to SCK Delay Prescaler
//registers SPI_CTAR_PASC(n)  (((n) & 3) << 20)  // After SCK Delay Prescaler
//registers SPI_CTAR_PDT(n)   (((n) & 3) << 18)  // Delay after Transfer Prescaler
//registers SPI_CTAR_PBR(n)   (((n) & 3) << 16)  // Baud Rate Prescaler
//registers SPI_CTAR_CSSCK(n)  (((n) & 15) << 12)  // PCS to SCK Delay Scaler
//registers SPI_CTAR_ASC(n)   (((n) & 15) << 8)  // After SCK Delay Scaler
//registers SPI_CTAR_DT(n)   (((n) & 15) << 4)  // Delay After Transfer Scaler
//registers SPI_CTAR_BR(n)   (((n) & 15) << 0)  // Baud Rate Scaler
//registers SPI0_CTAR0_SLAVE  0x4002C00C // DSPI Clock and Transfer Attributes Register, In Slave Mode
//registers SPI0_CTAR1   0x4002C010 // DSPI Clock and Transfer Attributes Register, In Master Mode
//registers SPI0_SR    0x4002C02C // DSPI Status Register
//registers SPI_SR_TCF    0x80000000  // Transfer Complete Flag
//registers SPI_SR_TXRXS    0x40000000  // TX and RX Status
//registers SPI_SR_EOQF    0x10000000  // End of Queue Flag
//registers SPI_SR_TFUF    0x08000000  // Transmit FIFO Underflow Flag
//registers SPI_SR_TFFF    0x02000000  // Transmit FIFO Fill Flag
//registers SPI_SR_RFOF    0x00080000  // Receive FIFO Overflow Flag
//registers SPI_SR_RFDF    0x00020000  // Receive FIFO Drain Flag
//registers SPI0_RSER   0x4002C030 // DSPI DMA/Interrupt Request Select and Enable Register
//registers SPI_RSER_TCF_RE    0x80000000  // Transmission Complete Request Enable
//registers SPI_RSER_EOQF_RE   0x10000000  // DSPI Finished Request Request Enable
//registers SPI_RSER_TFUF_RE   0x08000000  // Transmit FIFO Underflow Request Enable
//registers SPI_RSER_TFFF_RE   0x02000000  // Transmit FIFO Fill Request Enable
//registers SPI_RSER_TFFF_DIRS   0x01000000  // Transmit FIFO FIll Dma or Interrupt Request Select
//registers SPI_RSER_RFOF_RE   0x00080000  // Receive FIFO Overflow Request Enable
//registers SPI_RSER_RFDF_RE   0x00020000  // Receive FIFO Drain Request Enable
//registers SPI_RSER_RFDF_DIRS   0x00010000  // Receive FIFO Drain DMA or Interrupt Request Select
//registers SPI0_PUSHR   0x4002C034 // DSPI PUSH TX FIFO registers In Master Mode
//registers SPI_PUSHR_CONT    0x80000000  // 
//registers SPI_PUSHR_CTAS(n)  (((n) & 7) << 28)  // 
//registers SPI_PUSHR_EOQ    0x08000000  // 
//registers SPI_PUSHR_CTCNT    0x04000000  // 
//registers SPI_PUSHR_PCS(n)  (((n) & 31) << 16)  //
//registers SPI0_PUSHR_SLAVE  0x4002C034 // DSPI PUSH TX FIFO registers In Slave Mode
//registers SPI0_POPR   0x4002C038 // DSPI POP RX FIFO Register
//registers SPI0_TXFR0   0x4002C03C // DSPI Transmit FIFO Registers
//registers SPI0_TXFR1   0x4002C040 // DSPI Transmit FIFO Registers
//registers SPI0_TXFR2   0x4002C044 // DSPI Transmit FIFO Registers
//registers SPI0_TXFR3   0x4002C048 // DSPI Transmit FIFO Registers
//registers SPI0_RXFR0   0x4002C07C // DSPI Receive FIFO Registers
//registers SPI0_RXFR1   0x4002C080 // DSPI Receive FIFO Registers
//registers SPI0_RXFR2   0x4002C084 // DSPI Receive FIFO Registers
//registers SPI0_RXFR3   0x4002C088 // DSPI Receive FIFO Registers
//typedef struct {
// volatile $uint32_t MCR; // 0
// volatile $uint32_t unused1;// 4
// volatile $uint32_t TCR; // 8
// volatile $uint32_t CTAR0; // c
// volatile $uint32_t CTAR1; // 10
// volatile $uint32_t CTAR2; // 14
// volatile $uint32_t CTAR3; // 18
// volatile $uint32_t CTAR4; // 1c
// volatile $uint32_t CTAR5; // 20
// volatile $uint32_t CTAR6; // 24
// volatile $uint32_t CTAR7; // 28
// volatile $uint32_t SR; // 2c
// volatile $uint32_t RSER; // 30
// volatile $uint32_t PUSHR; // 34
// volatile $uint32_t POPR; // 38
// volatile $uint32_t TXFR[16]; // 3c
// volatile $uint32_t RXFR[16]; // 7c
//} SPI_t;
//registers SPI0  (*(SPI_t *)0x4002C000)
//
//// Chapter 44: Inter-Integrated Circuit (I2C)
//registers I2C0_A1   *(volatile $uint8_t  *)0x40066000 // I2C Address registers 1
//registers I2C0_F   *(volatile $uint8_t  *)0x40066001 // I2C Frequency Divider register
//registers I2C0_C1   *(volatile $uint8_t  *)0x40066002 // I2C Control registers 1
//registers I2C_C1_IICEN   ($uint8_t)0x80   // I2C Enable
//registers I2C_C1_IICIE   ($uint8_t)0x40   // I2C Interrupt Enable
//registers I2C_C1_MST   ($uint8_t)0x20   // Master Mode Select
//registers I2C_C1_TX   ($uint8_t)0x10   // Transmit Mode Select
//registers I2C_C1_TXAK   ($uint8_t)0x08   // Transmit Acknowledge Enable
//registers I2C_C1_RSTA   ($uint8_t)0x04   // RepeSTART
//registers I2C_C1_WUEN   ($uint8_t)0x02   // Wakeup Enable
//registers I2C_C1_DMAEN   ($uint8_t)0x01   // DMA Enable
//registers I2C0_S   *(volatile $uint8_t  *)0x40066003 // I2C Status register
//registers I2C_S_TCF   ($uint8_t)0x80   // Transfer Complete Flag
//registers I2C_S_IAAS   ($uint8_t)0x40   // Addressed As A Slave
//registers I2C_S_BUSY   ($uint8_t)0x20   // Bus Busy
//registers I2C_S_ARBL   ($uint8_t)0x10   // Arbitration Lost
//registers I2C_S_RAM   ($uint8_t)0x08   // Range Address Match
//registers I2C_S_SRW   ($uint8_t)0x04   // Slave Read/Write
//registers I2C_S_IICIF   ($uint8_t)0x02   // Interrupt Flag
//registers I2C_S_RXAK   ($uint8_t)0x01   // Receive Acknowledge
//registers I2C0_D   *(volatile $uint8_t  *)0x40066004 // I2C Data I/O register
//registers I2C0_C2   *(volatile $uint8_t  *)0x40066005 // I2C Control registers 2
//registers I2C_C2_GCAEN   ($uint8_t)0x80   // General Call Address Enable
//registers I2C_C2_ADEXT   ($uint8_t)0x40   // Address Extension
//registers I2C_C2_HDRS   ($uint8_t)0x20   // High Drive Select
//registers I2C_C2_SBRC   ($uint8_t)0x10   // Slave Baud Rate Control
//registers I2C_C2_RMEN   ($uint8_t)0x08   // Range Address Matching Enable
//registers I2C_C2_AD(n)   ((n) & 7)   // Slave Address, upper 3 bits
//registers I2C0_FLT  *(volatile $uint8_t  *)0x40066006 // I2C Programmable Input Glitch Filter register
//registers I2C0_RA   *(volatile $uint8_t  *)0x40066007 // I2C Range Address register
//registers I2C0_SMB  *(volatile $uint8_t  *)0x40066008 // I2C SMBus Control and Status register
//registers I2C0_A2   *(volatile $uint8_t  *)0x40066009 // I2C Address registers 2
//registers I2C0_SLTH  *(volatile $uint8_t  *)0x4006600A // I2C SCL Low Timeout registers High
//registers I2C0_SLTL  *(volatile $uint8_t  *)0x4006600B // I2C SCL Low Timeout registers Low
//
//registers I2C1_A1   *(volatile $uint8_t  *)0x40067000 // I2C Address registers 1
//registers I2C1_F   *(volatile $uint8_t  *)0x40067001 // I2C Frequency Divider register
//registers I2C1_C1   *(volatile $uint8_t  *)0x40067002 // I2C Control registers 1
//registers I2C1_S   *(volatile $uint8_t  *)0x40067003 // I2C Status register
//registers I2C1_D   *(volatile $uint8_t  *)0x40067004 // I2C Data I/O register
//registers I2C1_C2   *(volatile $uint8_t  *)0x40067005 // I2C Control registers 2
//registers I2C1_FLT  *(volatile $uint8_t  *)0x40067006 // I2C Programmable Input Glitch Filter register
//registers I2C1_RA   *(volatile $uint8_t  *)0x40067007 // I2C Range Address register
//registers I2C1_SMB  *(volatile $uint8_t  *)0x40067008 // I2C SMBus Control and Status register
//registers I2C1_A2   *(volatile $uint8_t  *)0x40067009 // I2C Address registers 2
//registers I2C1_SLTH  *(volatile $uint8_t  *)0x4006700A // I2C SCL Low Timeout registers High
//registers I2C1_SLTL  *(volatile $uint8_t  *)0x4006700B // I2C SCL Low Timeout registers Low
//
//// Chapter 45: Universal Asynchronous Receiver/Transmitter (UART)
//registers UART0_BDH  *(volatile $uint8_t  *)0x4006A000 // UART Baud Rate Registers: High
//registers UART0_BDL  *(volatile $uint8_t  *)0x4006A001 // UART Baud Rate Registers: Low
//registers UART0_C1  *(volatile $uint8_t  *)0x4006A002 // UART Control registers 1
//registers UART_C1_LOOPS   ($uint8_t)0x80   // When LOOPS is set, the RxD pin is disconnected from the UART and the transmitter output is internally connected to the receiver input
//registers UART_C1_UARTSWAI  ($uint8_t)0x40   // UART Stops in Wait Mode
//registers UART_C1_RSRC   ($uint8_t)0x20   // When LOOPS is set, the RSRC field determines the source for the receiver shift registers input
//registers UART_C1_M   ($uint8_t)0x10   // 9-bit or 8-bit Mode Select
//registers UART_C1_WAKE   ($uint8_t)0x08   // Determines which condition wakes the UART
//registers UART_C1_ILT   ($uint8_t)0x04   // Idle Line Type Select
//registers UART_C1_PE   ($uint8_t)0x02   // Parity Enable
//registers UART_C1_PT   ($uint8_t)0x01   // Parity Type, 0=even, 1=odd
//registers UART0_C2  *(volatile $uint8_t  *)0x4006A003 // UART Control registers 2
//registers UART_C2_TIE   ($uint8_t)0x80   // Transmitter Interrupt or DMA Transfer Enable.
//registers UART_C2_TCIE   ($uint8_t)0x40   // Transmission Complete Interrupt Enable
//registers UART_C2_RIE   ($uint8_t)0x20   // Receiver Full Interrupt or DMA Transfer Enable
//registers UART_C2_ILIE   ($uint8_t)0x10   // Idle Line Interrupt Enable
//registers UART_C2_TE   ($uint8_t)0x08   // Transmitter Enable
//registers UART_C2_RE   ($uint8_t)0x04   // Receiver Enable
//registers UART_C2_RWU   ($uint8_t)0x02   // Receiver Wakeup Control
//registers UART_C2_SBK   ($uint8_t)0x01   // Send Break
//registers UART0_S1  *(volatile $uint8_t  *)0x4006A004 // UART Status registers 1
//registers UART_S1_TDRE   ($uint8_t)0x80   // Transmit Data registers Empty Flag
//registers UART_S1_TC   ($uint8_t)0x40   // Transmit Complete Flag
//registers UART_S1_RDRF   ($uint8_t)0x20   // Receive Data registers Full Flag
//registers UART_S1_IDLE   ($uint8_t)0x10   // Idle Line Flag
//registers UART_S1_OR   ($uint8_t)0x08   // Receiver Overrun Flag
//registers UART_S1_NF   ($uint8_t)0x04   // Noise Flag
//registers UART_S1_FE   ($uint8_t)0x02   // Framing Error Flag
//registers UART_S1_PF   ($uint8_t)0x01   // Parity Error Flag
//registers UART0_S2  *(volatile $uint8_t  *)0x4006A005 // UART Status registers 2
//registers UART0_C3  *(volatile $uint8_t  *)0x4006A006 // UART Control registers 3
//registers UART0_D   *(volatile $uint8_t  *)0x4006A007 // UART Data Register
//registers UART0_MA1  *(volatile $uint8_t  *)0x4006A008 // UART Match Address Registers 1
//registers UART0_MA2  *(volatile $uint8_t  *)0x4006A009 // UART Match Address Registers 2
//registers UART0_C4  *(volatile $uint8_t  *)0x4006A00A // UART Control registers 4
//registers UART0_C5  *(volatile $uint8_t  *)0x4006A00B // UART Control registers 5
//registers UART0_ED  *(volatile $uint8_t  *)0x4006A00C // UART Extended Data Register
//registers UART0_MODEM  *(volatile $uint8_t  *)0x4006A00D // UART Modem Register
//registers UART0_IR  *(volatile $uint8_t  *)0x4006A00E // UART Infrared Register
//registers UART0_PFIFO  *(volatile $uint8_t  *)0x4006A010 // UART FIFO Parameters
//registers UART_PFIFO_TXFE   ($uint8_t)0x80
//registers UART_PFIFO_RXFE   ($uint8_t)0x08
//registers UART0_CFIFO  *(volatile $uint8_t  *)0x4006A011 // UART FIFO Control Register
//registers UART_CFIFO_TXFLUSH  ($uint8_t)0x80   // 
//registers UART_CFIFO_RXFLUSH  ($uint8_t)0x40   // 
//registers UART_CFIFO_RXOFE  ($uint8_t)0x04   // 
//registers UART_CFIFO_TXOFE  ($uint8_t)0x02   // 
//registers UART_CFIFO_RXUFE  ($uint8_t)0x01   // 
//registers UART0_SFIFO  *(volatile $uint8_t  *)0x4006A012 // UART FIFO Status Register
//registers UART_SFIFO_TXEMPT  ($uint8_t)0x80
//registers UART_SFIFO_RXEMPT  ($uint8_t)0x40
//registers UART_SFIFO_RXOF   ($uint8_t)0x04
//registers UART_SFIFO_TXOF   ($uint8_t)0x02
//registers UART_SFIFO_RXUF   ($uint8_t)0x01
//registers UART0_TWFIFO  *(volatile $uint8_t  *)0x4006A013 // UART FIFO Transmit Watermark
//registers UART0_TCFIFO  *(volatile $uint8_t  *)0x4006A014 // UART FIFO Transmit Count
//registers UART0_RWFIFO  *(volatile $uint8_t  *)0x4006A015 // UART FIFO Receive Watermark
//registers UART0_RCFIFO  *(volatile $uint8_t  *)0x4006A016 // UART FIFO Receive Count
//registers UART0_C7816  *(volatile $uint8_t  *)0x4006A018 // UART 7816 Control Register
//registers UART0_IE7816  *(volatile $uint8_t  *)0x4006A019 // UART 7816 Interrupt Enable Register
//registers UART0_IS7816  *(volatile $uint8_t  *)0x4006A01A // UART 7816 Interrupt Status Register
//registers UART0_WP7816T0  *(volatile $uint8_t  *)0x4006A01B // UART 7816 Wait Parameter Register
//registers UART0_WP7816T1  *(volatile $uint8_t  *)0x4006A01B // UART 7816 Wait Parameter Register
//registers UART0_WN7816  *(volatile $uint8_t  *)0x4006A01C // UART 7816 Wait N Register
//registers UART0_WF7816  *(volatile $uint8_t  *)0x4006A01D // UART 7816 Wait FD Register
//registers UART0_ET7816  *(volatile $uint8_t  *)0x4006A01E // UART 7816 Error Threshold Register
//registers UART0_TL7816  *(volatile $uint8_t  *)0x4006A01F // UART 7816 Transmit Length Register
//registers UART0_C6  *(volatile $uint8_t  *)0x4006A021 // UART CEA709.1-B Control registers 6
//registers UART0_PCTH  *(volatile $uint8_t  *)0x4006A022 // UART CEA709.1-B Packet Cycle Time Counter High
//registers UART0_PCTL  *(volatile $uint8_t  *)0x4006A023 // UART CEA709.1-B Packet Cycle Time Counter Low
//registers UART0_B1T  *(volatile $uint8_t  *)0x4006A024 // UART CEA709.1-B Beta1 Timer
//registers UART0_SDTH  *(volatile $uint8_t  *)0x4006A025 // UART CEA709.1-B Secondary Delay Timer High
//registers UART0_SDTL  *(volatile $uint8_t  *)0x4006A026 // UART CEA709.1-B Secondary Delay Timer Low
//registers UART0_PRE  *(volatile $uint8_t  *)0x4006A027 // UART CEA709.1-B Preamble
//registers UART0_TPL  *(volatile $uint8_t  *)0x4006A028 // UART CEA709.1-B Transmit Packet Length
//registers UART0_IE  *(volatile $uint8_t  *)0x4006A029 // UART CEA709.1-B Interrupt Enable Register
//registers UART0_WB  *(volatile $uint8_t  *)0x4006A02A // UART CEA709.1-B WBASE
//registers UART0_S3  *(volatile $uint8_t  *)0x4006A02B // UART CEA709.1-B Status Register
//registers UART0_S4  *(volatile $uint8_t  *)0x4006A02C // UART CEA709.1-B Status Register
//registers UART0_RPL  *(volatile $uint8_t  *)0x4006A02D // UART CEA709.1-B Received Packet Length
//registers UART0_RPREL  *(volatile $uint8_t  *)0x4006A02E // UART CEA709.1-B Received Preamble Length
//registers UART0_CPW  *(volatile $uint8_t  *)0x4006A02F // UART CEA709.1-B Collision Pulse Width
//registers UART0_RIDT  *(volatile $uint8_t  *)0x4006A030 // UART CEA709.1-B Receive Indeterminate Time
//registers UART0_TIDT  *(volatile $uint8_t  *)0x4006A031 // UART CEA709.1-B Transmit Indeterminate Time
//registers UART1_BDH  *(volatile $uint8_t  *)0x4006B000 // UART Baud Rate Registers: High
//registers UART1_BDL  *(volatile $uint8_t  *)0x4006B001 // UART Baud Rate Registers: Low
//registers UART1_C1  *(volatile $uint8_t  *)0x4006B002 // UART Control registers 1
//registers UART1_C2  *(volatile $uint8_t  *)0x4006B003 // UART Control registers 2
//registers UART1_S1  *(volatile $uint8_t  *)0x4006B004 // UART Status registers 1
//registers UART1_S2  *(volatile $uint8_t  *)0x4006B005 // UART Status registers 2
//registers UART1_C3  *(volatile $uint8_t  *)0x4006B006 // UART Control registers 3
//registers UART1_D   *(volatile $uint8_t  *)0x4006B007 // UART Data Register
//registers UART1_MA1  *(volatile $uint8_t  *)0x4006B008 // UART Match Address Registers 1
//registers UART1_MA2  *(volatile $uint8_t  *)0x4006B009 // UART Match Address Registers 2
//registers UART1_C4  *(volatile $uint8_t  *)0x4006B00A // UART Control registers 4
//registers UART1_C5  *(volatile $uint8_t  *)0x4006B00B // UART Control registers 5
//registers UART1_ED  *(volatile $uint8_t  *)0x4006B00C // UART Extended Data Register
//registers UART1_MODEM  *(volatile $uint8_t  *)0x4006B00D // UART Modem Register
//registers UART1_IR  *(volatile $uint8_t  *)0x4006B00E // UART Infrared Register
//registers UART1_PFIFO  *(volatile $uint8_t  *)0x4006B010 // UART FIFO Parameters
//registers UART1_CFIFO  *(volatile $uint8_t  *)0x4006B011 // UART FIFO Control Register
//registers UART1_SFIFO  *(volatile $uint8_t  *)0x4006B012 // UART FIFO Status Register
//registers UART1_TWFIFO  *(volatile $uint8_t  *)0x4006B013 // UART FIFO Transmit Watermark
//registers UART1_TCFIFO  *(volatile $uint8_t  *)0x4006B014 // UART FIFO Transmit Count
//registers UART1_RWFIFO  *(volatile $uint8_t  *)0x4006B015 // UART FIFO Receive Watermark
//registers UART1_RCFIFO  *(volatile $uint8_t  *)0x4006B016 // UART FIFO Receive Count
//registers UART1_C7816  *(volatile $uint8_t  *)0x4006B018 // UART 7816 Control Register
//registers UART1_IE7816  *(volatile $uint8_t  *)0x4006B019 // UART 7816 Interrupt Enable Register
//registers UART1_IS7816  *(volatile $uint8_t  *)0x4006B01A // UART 7816 Interrupt Status Register
//registers UART1_WP7816T0  *(volatile $uint8_t  *)0x4006B01B // UART 7816 Wait Parameter Register
//registers UART1_WP7816T1  *(volatile $uint8_t  *)0x4006B01B // UART 7816 Wait Parameter Register
//registers UART1_WN7816  *(volatile $uint8_t  *)0x4006B01C // UART 7816 Wait N Register
//registers UART1_WF7816  *(volatile $uint8_t  *)0x4006B01D // UART 7816 Wait FD Register
//registers UART1_ET7816  *(volatile $uint8_t  *)0x4006B01E // UART 7816 Error Threshold Register
//registers UART1_TL7816  *(volatile $uint8_t  *)0x4006B01F // UART 7816 Transmit Length Register
//registers UART1_C6  *(volatile $uint8_t  *)0x4006B021 // UART CEA709.1-B Control registers 6
//registers UART1_PCTH  *(volatile $uint8_t  *)0x4006B022 // UART CEA709.1-B Packet Cycle Time Counter High
//registers UART1_PCTL  *(volatile $uint8_t  *)0x4006B023 // UART CEA709.1-B Packet Cycle Time Counter Low
//registers UART1_B1T  *(volatile $uint8_t  *)0x4006B024 // UART CEA709.1-B Beta1 Timer
//registers UART1_SDTH  *(volatile $uint8_t  *)0x4006B025 // UART CEA709.1-B Secondary Delay Timer High
//registers UART1_SDTL  *(volatile $uint8_t  *)0x4006B026 // UART CEA709.1-B Secondary Delay Timer Low
//registers UART1_PRE  *(volatile $uint8_t  *)0x4006B027 // UART CEA709.1-B Preamble
//registers UART1_TPL  *(volatile $uint8_t  *)0x4006B028 // UART CEA709.1-B Transmit Packet Length
//registers UART1_IE  *(volatile $uint8_t  *)0x4006B029 // UART CEA709.1-B Interrupt Enable Register
//registers UART1_WB  *(volatile $uint8_t  *)0x4006B02A // UART CEA709.1-B WBASE
//registers UART1_S3  *(volatile $uint8_t  *)0x4006B02B // UART CEA709.1-B Status Register
//registers UART1_S4  *(volatile $uint8_t  *)0x4006B02C // UART CEA709.1-B Status Register
//registers UART1_RPL  *(volatile $uint8_t  *)0x4006B02D // UART CEA709.1-B Received Packet Length
//registers UART1_RPREL  *(volatile $uint8_t  *)0x4006B02E // UART CEA709.1-B Received Preamble Length
//registers UART1_CPW  *(volatile $uint8_t  *)0x4006B02F // UART CEA709.1-B Collision Pulse Width
//registers UART1_RIDT  *(volatile $uint8_t  *)0x4006B030 // UART CEA709.1-B Receive Indeterminate Time
//registers UART1_TIDT  *(volatile $uint8_t  *)0x4006B031 // UART CEA709.1-B Transmit Indeterminate Time
//registers UART2_BDH  *(volatile $uint8_t  *)0x4006C000 // UART Baud Rate Registers: High
//registers UART2_BDL  *(volatile $uint8_t  *)0x4006C001 // UART Baud Rate Registers: Low
//registers UART2_C1  *(volatile $uint8_t  *)0x4006C002 // UART Control registers 1
//registers UART2_C2  *(volatile $uint8_t  *)0x4006C003 // UART Control registers 2
//registers UART2_S1  *(volatile $uint8_t  *)0x4006C004 // UART Status registers 1
//registers UART2_S2  *(volatile $uint8_t  *)0x4006C005 // UART Status registers 2
//registers UART2_C3  *(volatile $uint8_t  *)0x4006C006 // UART Control registers 3
//registers UART2_D   *(volatile $uint8_t  *)0x4006C007 // UART Data Register
//registers UART2_MA1  *(volatile $uint8_t  *)0x4006C008 // UART Match Address Registers 1
//registers UART2_MA2  *(volatile $uint8_t  *)0x4006C009 // UART Match Address Registers 2
//registers UART2_C4  *(volatile $uint8_t  *)0x4006C00A // UART Control registers 4
//registers UART2_C5  *(volatile $uint8_t  *)0x4006C00B // UART Control registers 5
//registers UART2_ED  *(volatile $uint8_t  *)0x4006C00C // UART Extended Data Register
//registers UART2_MODEM  *(volatile $uint8_t  *)0x4006C00D // UART Modem Register
//registers UART2_IR  *(volatile $uint8_t  *)0x4006C00E // UART Infrared Register
//registers UART2_PFIFO  *(volatile $uint8_t  *)0x4006C010 // UART FIFO Parameters
//registers UART2_CFIFO  *(volatile $uint8_t  *)0x4006C011 // UART FIFO Control Register
//registers UART2_SFIFO  *(volatile $uint8_t  *)0x4006C012 // UART FIFO Status Register
//registers UART2_TWFIFO  *(volatile $uint8_t  *)0x4006C013 // UART FIFO Transmit Watermark
//registers UART2_TCFIFO  *(volatile $uint8_t  *)0x4006C014 // UART FIFO Transmit Count
//registers UART2_RWFIFO  *(volatile $uint8_t  *)0x4006C015 // UART FIFO Receive Watermark
//registers UART2_RCFIFO  *(volatile $uint8_t  *)0x4006C016 // UART FIFO Receive Count
//registers UART2_C7816  *(volatile $uint8_t  *)0x4006C018 // UART 7816 Control Register
//registers UART2_IE7816  *(volatile $uint8_t  *)0x4006C019 // UART 7816 Interrupt Enable Register
//registers UART2_IS7816  *(volatile $uint8_t  *)0x4006C01A // UART 7816 Interrupt Status Register
//registers UART2_WP7816T0  *(volatile $uint8_t  *)0x4006C01B // UART 7816 Wait Parameter Register
//registers UART2_WP7816T1  *(volatile $uint8_t  *)0x4006C01B // UART 7816 Wait Parameter Register
//registers UART2_WN7816  *(volatile $uint8_t  *)0x4006C01C // UART 7816 Wait N Register
//registers UART2_WF7816  *(volatile $uint8_t  *)0x4006C01D // UART 7816 Wait FD Register
//registers UART2_ET7816  *(volatile $uint8_t  *)0x4006C01E // UART 7816 Error Threshold Register
//registers UART2_TL7816  *(volatile $uint8_t  *)0x4006C01F // UART 7816 Transmit Length Register
//registers UART2_C6  *(volatile $uint8_t  *)0x4006C021 // UART CEA709.1-B Control registers 6
//registers UART2_PCTH  *(volatile $uint8_t  *)0x4006C022 // UART CEA709.1-B Packet Cycle Time Counter High
//registers UART2_PCTL  *(volatile $uint8_t  *)0x4006C023 // UART CEA709.1-B Packet Cycle Time Counter Low
//registers UART2_B1T  *(volatile $uint8_t  *)0x4006C024 // UART CEA709.1-B Beta1 Timer
//registers UART2_SDTH  *(volatile $uint8_t  *)0x4006C025 // UART CEA709.1-B Secondary Delay Timer High
//registers UART2_SDTL  *(volatile $uint8_t  *)0x4006C026 // UART CEA709.1-B Secondary Delay Timer Low
//registers UART2_PRE  *(volatile $uint8_t  *)0x4006C027 // UART CEA709.1-B Preamble
//registers UART2_TPL  *(volatile $uint8_t  *)0x4006C028 // UART CEA709.1-B Transmit Packet Length
//registers UART2_IE  *(volatile $uint8_t  *)0x4006C029 // UART CEA709.1-B Interrupt Enable Register
//registers UART2_WB  *(volatile $uint8_t  *)0x4006C02A // UART CEA709.1-B WBASE
//registers UART2_S3  *(volatile $uint8_t  *)0x4006C02B // UART CEA709.1-B Status Register
//registers UART2_S4  *(volatile $uint8_t  *)0x4006C02C // UART CEA709.1-B Status Register
//registers UART2_RPL  *(volatile $uint8_t  *)0x4006C02D // UART CEA709.1-B Received Packet Length
//registers UART2_RPREL  *(volatile $uint8_t  *)0x4006C02E // UART CEA709.1-B Received Preamble Length
//registers UART2_CPW  *(volatile $uint8_t  *)0x4006C02F // UART CEA709.1-B Collision Pulse Width
//registers UART2_RIDT  *(volatile $uint8_t  *)0x4006C030 // UART CEA709.1-B Receive Indeterminate Time
//registers UART2_TIDT  *(volatile $uint8_t  *)0x4006C031 // UART CEA709.1-B Transmit Indeterminate Time
//
//// Chapter 46: Synchronous Audio Interface (SAI)
//registers I2S0_TCSR   0x4002F000 // SAI Transmit Control Register
//registers I2S_TCSR_TE    0x80000000 // Transmitter Enable
//registers I2S_TCSR_STOPE    0x40000000 // Transmitter Enable in Stop mode
//registers I2S_TCSR_DBGE    0x20000000 // Transmitter Enable in Debug mode
//registers I2S_TCSR_BCE    0x10000000 // Bit Clock Enable
//registers I2S_TCSR_FR    0x02000000 // FIFO Reset
//registers I2S_TCSR_SR    0x01000000 // Software Reset
//registers I2S_TCSR_WSF    0x00100000 // Word Start Flag
//registers I2S_TCSR_SEF    0x00080000 // Sync Error Flag
//registers I2S_TCSR_FEF    0x00040000 // FIFO Error Flag (underrun)
//registers I2S_TCSR_FWF    0x00020000 // FIFO Warning Flag (empty)
//registers I2S_TCSR_FRF    0x00010000 // FIFO Request Flag (Data Ready)
//registers I2S_TCSR_WSIE    0x00001000 // Word Start Interrupt Enable
//registers I2S_TCSR_SEIE    0x00000800 // Sync Error Interrupt Enable
//registers I2S_TCSR_FEIE    0x00000400 // FIFO Error Interrupt Enable
//registers I2S_TCSR_FWIE    0x00000200 // FIFO Warning Interrupt Enable
//registers I2S_TCSR_FRIE    0x00000100 // FIFO Request Interrupt Enable
//registers I2S_TCSR_FWDE    0x00000002 // FIFO Warning DMA Enable
//registers I2S_TCSR_FRDE    0x00000001 // FIFO Request DMA Enable
//registers I2S0_TCR1   0x4002F004 // SAI Transmit Configuration 1 Register
//registers I2S_TCR1_TFW(n)   ( n & 0x03)       // Transmit FIFO watermark
//registers I2S0_TCR2   0x4002F008 // SAI Transmit Configuration 2 Register
//registers I2S_TCR2_DIV(n)   ( n & 0xff)       // Bit clock divide by (DIV+1)*2
//registers I2S_TCR2_BCD   ( 1<<24)       // Bit clock direction
//registers I2S_TCR2_BCP   ( 1<<25)       // Bit clock polarity
//registers I2S_TCR2_MSEL(n)  ( (n & 3)<<26)       // MCLK select, 0=bus clock, 1=I2S0_MCLK
//registers I2S_TCR2_BCI   ( 1<<28)       // Bit clock input
//registers I2S_TCR2_BCS   ( 1<<29)       // Bit clock swap
//registers I2S_TCR2_SYNC(n)  ( (n & 3)<<30)       // 0=async 1=sync with receiver
//registers I2S0_TCR3   0x4002F00C // SAI Transmit Configuration 3 Register
//registers I2S_TCR3_WDFL(n)  ( n & 0x0f)       // word flag configuration
//registers I2S_TCR3_TCE   ( 0x10000)       // transmit channel enable
//registers I2S0_TCR4   0x4002F010 // SAI Transmit Configuration 4 Register
//registers I2S_TCR4_FSD   ( 1)        // Frame Sync Direction
//registers I2S_TCR4_FSP   ( 2)        // Frame Sync Polarity
//registers I2S_TCR4_FSE   ( 8)        // Frame Sync Early
//registers I2S_TCR4_MF   ( 0x10)       // MSB First
//registers I2S_TCR4_SYWD(n)  ( (n & 0x1f)<<8)     // Sync Width
//registers I2S_TCR4_FRSZ(n)  ( (n & 0x0f)<<16)    // Frame Size
//registers I2S0_TCR5   0x4002F014 // SAI Transmit Configuration 5 Register
//registers I2S_TCR5_FBT(n)   ( (n & 0x1f)<<8)     // First Bit Shifted
//registers I2S_TCR5_W0W(n)   ( (n & 0x1f)<<16)    // Word 0 Width
//registers I2S_TCR5_WNW(n)   ( (n & 0x1f)<<24)    // Word N Width
//registers I2S0_TDR0   0x4002F020 // SAI Transmit Data Register
//registers I2S0_TDR1   0x4002F024 // SAI Transmit Data Register
//registers I2S0_TFR0   0x4002F040 // SAI Transmit FIFO Register
//registers I2S0_TFR1   0x4002F044 // SAI Transmit FIFO Register
//registers I2S_TFR_RFP(n)   ( n & 7)       // read FIFO pointer
//registers I2S_TFR_WFP(n)   ( (n & 7)<<16)       // write FIFO pointer
//registers I2S0_TMR   0x4002F060 // SAI Transmit Mask Register
//registers I2S_TMR_TWM(n)   ( n & 0xFFFFFFFF)
//registers I2S0_RCSR   0x4002F080 // SAI Receive Control Register
//registers I2S_RCSR_RE    0x80000000 // Receiver Enable
//registers I2S_RCSR_STOPE    0x40000000 // Receiver Enable in Stop mode
//registers I2S_RCSR_DBGE    0x20000000 // Receiver Enable in Debug mode
//registers I2S_RCSR_BCE    0x10000000 // Bit Clock Enable
//registers I2S_RCSR_FR    0x02000000 // FIFO Reset
//registers I2S_RCSR_SR    0x01000000 // Software Reset
//registers I2S_RCSR_WSF    0x00100000 // Word Start Flag
//registers I2S_RCSR_SEF    0x00080000 // Sync Error Flag
//registers I2S_RCSR_FEF    0x00040000 // FIFO Error Flag (underrun)
//registers I2S_RCSR_FWF    0x00020000 // FIFO Warning Flag (empty)
//registers I2S_RCSR_FRF    0x00010000 // FIFO Request Flag (Data Ready)
//registers I2S_RCSR_WSIE    0x00001000 // Word Start Interrupt Enable
//registers I2S_RCSR_SEIE    0x00000800 // Sync Error Interrupt Enable
//registers I2S_RCSR_FEIE    0x00000400 // FIFO Error Interrupt Enable
//registers I2S_RCSR_FWIE    0x00000200 // FIFO Warning Interrupt Enable
//registers I2S_RCSR_FRIE    0x00000100 // FIFO Request Interrupt Enable
//registers I2S_RCSR_FWDE    0x00000002 // FIFO Warning DMA Enable
//registers I2S_RCSR_FRDE    0x00000001 // FIFO Request DMA Enable
//registers I2S0_RCR1   0x4002F084 // SAI Receive Configuration 1 Register
//registers I2S_RCR1_RFW(n)   ( n & 0x03)       // Receive FIFO watermark
//registers I2S0_RCR2   0x4002F088 // SAI Receive Configuration 2 Register
//registers I2S_RCR2_DIV(n)   ( n & 0xff)       // Bit clock divide by (DIV+1)*2
//registers I2S_RCR2_BCD   ( 1<<24)       // Bit clock direction
//registers I2S_RCR2_BCP   ( 1<<25)       // Bit clock polarity
//registers I2S_RCR2_MSEL(n)  ( (n & 3)<<26)       // MCLK select, 0=bus clock, 1=I2S0_MCLK
//registers I2S_RCR2_BCI   ( 1<<28)       // Bit clock input
//registers I2S_RCR2_BCS   ( 1<<29)       // Bit clock swap
//registers I2S_RCR2_SYNC(n)  ( (n & 3)<<30)       // 0=async 1=sync with receiver
//registers I2S0_RCR3   0x4002F08C // SAI Receive Configuration 3 Register
//registers I2S_RCR3_WDFL(n)  ( n & 0x0f)       // word flag configuration
//registers I2S_RCR3_RCE   ( 0x10000)       // receive channel enable
//registers I2S0_RCR4   0x4002F090 // SAI Receive Configuration 4 Register
//registers I2S_RCR4_FSD   ( 1)        // Frame Sync Direction
//registers I2S_RCR4_FSP   ( 2)        // Frame Sync Polarity
//registers I2S_RCR4_FSE   ( 8)        // Frame Sync Early
//registers I2S_RCR4_MF   ( 0x10)       // MSB First
//registers I2S_RCR4_SYWD(n)  ( (n & 0x1f)<<8)     // Sync Width
//registers I2S_RCR4_FRSZ(n)  ( (n & 0x0f)<<16)    // Frame Size
//registers I2S0_RCR5   0x4002F094 // SAI Receive Configuration 5 Register
//registers I2S_RCR5_FBT(n)   ( (n & 0x1f)<<8)     // First Bit Shifted
//registers I2S_RCR5_W0W(n)   ( (n & 0x1f)<<16)    // Word 0 Width
//registers I2S_RCR5_WNW(n)   ( (n & 0x1f)<<24)    // Word N Width
//registers I2S0_RDR0   0x4002F0A0 // SAI Receive Data Register
//registers I2S0_RDR1   0x4002F0A4 // SAI Receive Data Register
//registers I2S0_RFR0   0x4002F0C0 // SAI Receive FIFO Register
//registers I2S0_RFR1   0x4002F0C4 // SAI Receive FIFO Register
//registers I2S_RFR_RFP(n)   ( n & 7)       // read FIFO pointer
//registers I2S_RFR_WFP(n)   ( (n & 7)<<16)       // write FIFO pointer
//registers I2S0_RMR   0x4002F0E0 // SAI Receive Mask Register
//registers I2S_RMR_RWM(n)   ( n & 0xFFFFFFFF)
//registers I2S0_MCR   0x4002F100 // SAI MCLK Control Register
//registers I2S_MCR_DUF   ( 1<<31)       // Divider Update Flag
//registers I2S_MCR_MOE   ( 1<<30)       // MCLK Output Enable
//registers I2S_MCR_MICS(n)   ( (n & 3)<<24)       // MCLK Input Clock Select
//registers I2S0_MDR   0x4002F104 // SAI MCLK Divide Register
//registers I2S_MDR_FRACT(n)  ( (n & 0xff)<<12)    // MCLK Fraction
//registers I2S_MDR_DIVIDE(n)  ( (n & 0xfff))       // MCLK Divide

// Chapter 47: General-Purpose Input/Output (GPIO)
registers GPIOA {
  PDOR @user 0x400FF000 $uint32 // Port Data Output Register
  PSOR @user 0x400FF004 $uint32 // Port Set Output Register
  PCOR @user 0x400FF008 $uint32 // Port Clear Output Register
  PTOR @user 0x400FF00C $uint32 // Port Toggle Output Register
  PDIR @user 0x400FF010 $uint32 // Port Data Input Register
  PDDR @user 0x400FF014 $uint32 // Port Data Direction Register
}

registers GPIOB {
  PDOR @user 0x400FF040 $uint32 // Port Data Output Register
  PSOR @user 0x400FF044 $uint32 // Port Set Output Register
  PCOR @user 0x400FF048 $uint32 // Port Clear Output Register
  PTOR @user 0x400FF04C $uint32 // Port Toggle Output Register
  PDIR @user 0x400FF050 $uint32 // Port Data Input Register
  PDDR @user 0x400FF054 $uint32 // Port Data Direction Register
}

registers GPIOC {
  PDOR @user 0x400FF080 $uint32 // Port Data Output Register
  PSOR @user 0x400FF084 $uint32 // Port Set Output Register
  PCOR @user 0x400FF088 $uint32 // Port Clear Output Register
  PTOR @user 0x400FF08C $uint32 // Port Toggle Output Register
  PDIR @user 0x400FF090 $uint32 // Port Data Input Register
  PDDR @user 0x400FF094 $uint32 // Port Data Direction Register
}

registers GPIOD {
  PDOR @user 0x400FF0C0 $uint32 // Port Data Output Register
  PSOR @user 0x400FF0C4 $uint32 // Port Set Output Register
  PCOR @user 0x400FF0C8 $uint32 // Port Clear Output Register
  PTOR @user 0x400FF0CC $uint32 // Port Toggle Output Register
  PDIR @user 0x400FF0D0 $uint32 // Port Data Input Register
  PDDR @user 0x400FF0D4 $uint32 // Port Data Direction Register
}

//// Chapter 48: Touch sense input (TSI)
//registers TSI0_GENCS   0x40045000 // General Control and Status Register
//registers TSI_GENCS_LPCLKS   0x10000000  // 
//registers TSI_GENCS_LPSCNITV(n)  (((n) & 15) << 24)  // 
//registers TSI_GENCS_NSCN(n)  (((n) & 31) << 19)  // 
//registers TSI_GENCS_PS(n)   (((n) & 7) << 16)  // 
//registers TSI_GENCS_EOSF    0x00008000  // 
//registers TSI_GENCS_OUTRGF   0x00004000  // 
//registers TSI_GENCS_EXTERF   0x00002000  // 
//registers TSI_GENCS_OVRF    0x00001000  // 
//registers TSI_GENCS_SCNIP    0x00000200  // 
//registers TSI_GENCS_SWTS    0x00000100  // 
//registers TSI_GENCS_TSIEN    0x00000080  // 
//registers TSI_GENCS_TSIIE    0x00000040  // 
//registers TSI_GENCS_ERIE    0x00000020  // 
//registers TSI_GENCS_ESOR    0x00000010  // 
//registers TSI_GENCS_STM    0x00000002  // 
//registers TSI_GENCS_STPE    0x00000001  // 
//registers TSI0_SCANC   0x40045004 // SCAN Control Register
//registers TSI_SCANC_REFCHRG(n)  (((n) & 15) << 24)  // 
//registers TSI_SCANC_EXTCHRG(n)  (((n) & 7) << 16)  // 
//registers TSI_SCANC_SMOD(n)  (((n) & 255) << 8)  // 
//registers TSI_SCANC_AMCLKS(n)  (((n) & 3) << 3)  // 
//registers TSI_SCANC_AMPSC(n)  (((n) & 7) << 0)  // 
//registers TSI0_PEN   0x40045008 // Pin Enable Register
//registers TSI0_WUCNTR   0x4004500C // Wake-Up Channel Counter Register
//registers TSI0_CNTR1   0x40045100 // Counter Register
//registers TSI0_CNTR3   0x40045104 // Counter Register
//registers TSI0_CNTR5   0x40045108 // Counter Register
//registers TSI0_CNTR7   0x4004510C // Counter Register
//registers TSI0_CNTR9   0x40045110 // Counter Register
//registers TSI0_CNTR11   0x40045114 // Counter Register
//registers TSI0_CNTR13   0x40045118 // Counter Register
//registers TSI0_CNTR15   0x4004511C // Counter Register
//registers TSI0_THRESHOLD   0x40045120 // Low Power Channel Threshold Register
//
// Nested Vectored Interrupt Controller, Table 3-4 & ARMv7 ref, appendix B3.4 (page 750)
 
registers NVIC {
  ISER [4]  0xE000_E100 : 4 $uint32 // Interrupt Set-enable Registers
  ICER [4]  0xE000_E180 : 4 $uint32 //Interrupt Clear-enable Registers
  IPR [128] 0xE000_E400 : 1 $uint8 // Interrupt priority
  
  ICSR 0xE000_ED04 $uint32 { // Interrupt Control and State
    NMIPENDSET, 2, PENDSVSET, PENDSVCLR, PENDSTSET, PENDSTCLR, 1, ISRPREEMPT,
    ISRPENDING, 1, VECTPENDING[9], RETTOBASE, 2, VECTACTIVE[9]
  }
  
  VTOR 0xE000ED08 $uint32 // Vector Table Offset
  
  AIRCR 0xE000ED0C $uint32 { // Application Interrupt and Reset Control
    VECTKEY[16], ENDIANNESS, 4, PRIGROUP[3],
    5, SYSRESETREQ, VECTCLRACTIVE, VECTRESET 
  }
}

//registers SCB_SCR    0xE000ED10 // System Control Register
//registers SCB_CCR    0xE000ED14 // Configuration and Control
//registers SCB_SHPR1   0xE000ED18 // System Handler Priority registers 1
//registers SCB_SHPR2   0xE000ED1C // System Handler Priority registers 2
//registers SCB_SHPR3   0xE000ED20 // System Handler Priority registers 3
//registers SCB_SHCSR   0xE000ED24 // System Handler Control and State
//registers SCB_CFSR   0xE000ED28 // Configurable Fault Status Register
//registers SCB_HFSR   0xE000ED2C // HardFault Status
//registers SCB_DFSR   0xE000ED30 // Debug Fault Status
//registers SCB_MMFAR   0xE000ED34 // MemManage Fault Address

//--- SYSTICK
registers SYST {
  CSR 0xE000_E010 $uint32 { // SysTick Control and Status
    15, 
    COUNTFLAG,
    13,
    CLKSOURCE,
    TICKINT,
    ENABLE
  }
  RVR   0xE000_E014 $uint32 // SysTick Reload Value Register
  CVR   0xE000_E018 $uint32 // SysTick Current Value Register
  CALIB  @ro 0xE000_E01C $uint32 // SysTick Calibration Value
}
registers AIPS0 {
  MPRA 0x_4000_0000 $uint32
  
  //--- AICS0_PACR (§4.5.1 and §19.2, §19.2.2)
  // SPx: Determines whether the peripheral requires supervisor privilege level
  // for accesses. When this field is set, the master privilege level must indicate
  // the supervisor access attribute, and the MPR x [MPL n ] control field for the
  // master must be set. If not, access terminates with an error response and no
  // peripheral access initiates. 
  // 0  This peripheral does not require supervisor privilege level for accesses.    // 1  This peripheral requires supervisor privilege level for accesses.    // WPx: Determines whether the peripheral allows write accessses. When this field
  // is set and a write access is attempted, access terminates with an error
  // response and no peripheral access initiates
  // 0  This peripheral allows write accesses.    // 1  This peripheral is write protected.    // TPx : Determines whether the peripheral allows accesses from an untrusted master.
  // When this bit is set and an access is attempted by an untrusted master, the 
  // access terminates with an error response and no peripheral access initiates.
  // 0  Accesses from an untrusted master are allowed.    // 1  Accesses from an untrusted master are not allowed.    
  PACRA 0x_4000_0020
  PACRB 0x_4000_0024
  PACRC 0x_4000_0028
  PACRD 0x_4000_002C
  PACRE 0x_4000_0040
  PACRF 0x_4000_0044
  PACRG 0x_4000_0048
  PACRH 0x_4000_004C
  PACRI 0x_4000_0050
  PACRJ 0x_4000_0054
  PACRK 0x_4000_0058
  PACRL 0x_4000_005C
  PACRM 0x_4000_0060
  PACRN 0x_4000_0064
  PACRO 0x_4000_0068
  PACRP 0x_4000_006C
  $uint32 {
   1, SP0, WP0, TP0,
   1, SP1, WP1, TP1,
   1, SP2, WP2, TP2,
   1, SP3, WP3, TP3,
   1, SP4, WP4, TP4,
   1, SP5, WP5, TP5,
   1, SP6, WP6, TP6,
   1, SP7, WP7, TP7
  }
}
//registers ARM_DEMCR   0xE000EDFC // Debug Exception and Monitor Control
//registers ARM_DEMCR_TRCENA  (1 << 24)  // Enable debugging & monitoring blocks
//registers ARM_DWT_CTRL   0xE0001000 // DWT control register
//registers ARM_DWT_CTRL_CYCCNTENA  (1 << 0)  // Enable cycle count
//registers ARM_DWT_CYCCNT   0xE0001004 // Cycle count register
