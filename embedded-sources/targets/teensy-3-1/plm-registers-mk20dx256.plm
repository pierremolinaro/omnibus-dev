
let f_cpu $uint32 = 96_000_000
let f_bus $uint32 = 48_000_000
let f_mem $uint32 = 24_000_000

// chapter 11: Port control and interrupts (PORT) Pin Control registers n
registers #PORTA 0x4004_9000 {
  PCR @user [32] 0x00 @inc 4 $uint32 {
    7, ISF, 4, IRQC:4, LK, 4, MUX:3, 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  
  GPCLR @user  0x80 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x84 $uint32 // Global Pin Control High Register
  ISFR @user   0xA0 $uint32 // Interrupt Status Flag Register
}

registers #PORTB 0x4004_A000 {
  PCR @user [32] 0x00 @inc 4 $uint32 {
    7, ISF, 4, IRQC:4, LK, 4, MUX:3, 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  GPCLR @user  0x80 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x84 $uint32 // Global Pin Control High Register
  ISFR  @user  0xA0 $uint32 // Interrupt Status Flag Register
}

registers #PORTC 0x4004_B000 {
  PCR @user [32] 0x00 @inc 4 $uint32 {
    7, ISF, 4, IRQC:4, LK, 4, MUX:3, 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  GPCLR @user  0x80 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x84 $uint32 // Global Pin Control High Register
  ISFR  @user  0xA0 $uint32 // Interrupt Status Flag Register
}

registers #PORTD 0x4004_C000 {
  PCR @user [32] 0x00 @inc 4 $uint32 {
    7, ISF, 4, IRQC:4, LK, 4, MUX:3, 1, DSE, ODE, PFE, 1, SRE, PE, PS
  }
  GPCLR @user  0x80 $uint32 // Global Pin Control Low Register
  GPCHR @user  0x84 $uint32 // Global Pin Control High Register
  ISFR  @user  0xA0 $uint32 // Interrupt Status Flag Register
}

// Chapter 12: System Integration Module (SIM)
let SIM_SOPT2_USBSRC      $uint32 = 0x40000  // 0=USB_CLKIN, 1=FFL/PLL 
let SIM_SOPT2_PLLFLLSEL   $uint32 = 0x10000 // 0=FLL, 1=PLL
let SIM_SOPT2_TRACECLKSEL $uint32 = 0x1000  // 0=MCGOUTCLK, 1=CPU
let SIM_SOPT2_PTD7PAD     $uint32 = 0x800  // 0=normal, 1=double drive PTD7
let SIM_SOPT2_RTCCLKOUTSEL $uint32 = 0x00000010  // RTC clock out select

let SIM_SCGC2_DAC0  $uint32 =  0x00001000 // DAC0 Clock Gate Control

let SIM_SCGC3_ADC1 $uint32 =  0x08000000 // ADC1 Clock Gate Control
let SIM_SCGC3_FTM2 $uint32 =  0x01000000 // FTM2 Clock Gate Control

let SIM_SCGC4_VREF  $uint32 =  0x00100000  // VREF Clock Gate Control
let SIM_SCGC4_CMP   $uint32 = 0x00080000  // Comparator Clock Gate Control
let SIM_SCGC4_USBOTG  $uint32 = 0x00040000  // USB Clock Gate Control
let SIM_SCGC4_UART2  $uint32 =  0x00001000  // UART2 Clock Gate Control
let SIM_SCGC4_UART1  $uint32 =  0x00000800  // UART1 Clock Gate Control
let SIM_SCGC4_UART0  $uint32 =  0x00000400  // UART0 Clock Gate Control
let SIM_SCGC4_I2C1  $uint32 =  0x00000080  // I2C1 Clock Gate Control
let SIM_SCGC4_I2C0  $uint32 =  0x00000040  // I2C0 Clock Gate Control
let SIM_SCGC4_CMT  $uint32 =  0x00000004  // CMT Clock Gate Control
let SIM_SCGC4_EWM  $uint32 =  0x00000002  // EWM Clock Gate Control

let SIM_SCGC5_PORTE  $uint32 =  0x00002000  // Port E Clock Gate Control
let SIM_SCGC5_PORTD  $uint32 =  0x00001000  // Port D Clock Gate Control
let SIM_SCGC5_PORTC  $uint32 =  0x00000800  // Port C Clock Gate Control
let SIM_SCGC5_PORTB  $uint32 =  0x00000400  // Port B Clock Gate Control
let SIM_SCGC5_PORTA  $uint32 =  0x00000200  // Port A Clock Gate Control
let SIM_SCGC5_TSI  $uint32 =  0x00000020  // Touch Sense Input TSI Clock Gate Control
let SIM_SCGC5_LPTIMER  $uint32 =  0x00000001  // Low Power Timer Access Control

let SIM_SCGC6_RTC   $uint32 = 0x20000000  // RTC Access
let SIM_SCGC6_ADC0  $uint32 =   0x08000000  // ADC0 Clock Gate Control
let SIM_SCGC6_FTM1  $uint32 =   0x02000000  // FTM1 Clock Gate Control
let SIM_SCGC6_FTM0  $uint32 =   0x01000000  // FTM0 Clock Gate Control
let SIM_SCGC6_PIT  $uint32 =  0x00800000  // PIT Clock Gate Control
let SIM_SCGC6_PDB  $uint32 =  0x00400000  // PDB Clock Gate Control
let SIM_SCGC6_USBDCD  $uint32=  0x00200000  // USB DCD Clock Gate Control
let SIM_SCGC6_CRC  $uint32 =  0x00040000  // CRC Clock Gate Control
let SIM_SCGC6_I2S  $uint32 =  0x00008000  // I2S Clock Gate Control
let SIM_SCGC6_SPI1  $uint32=   0x00002000  // SPI1 Clock Gate Control
let SIM_SCGC6_SPI0  $uint32=   0x00001000  // SPI0 Clock Gate Control
let SIM_SCGC6_FLEXCAN0  $uint32 =  0x00000010  // FlexCAN0 Clock Gate Control
let SIM_SCGC6_DMAMUX $uint32 =  0x00000002  // DMA Mux Clock Gate Control
let SIM_SCGC6_FTFL  $uint32 =  0x00000001  // Flash Memory Clock Gate Control

let SIM_SCGC7_DMA  $uint32 =  0x00000002  // DMA Clock Gate Control

let SIM_CLKDIV2_USBFRAC  $uint32 =  0x01

registers #SIM 0x4004_7000 {
  SOPT1    0x00 $uint32 // System Options registers 1
  SOPT1CFG 0x04 $uint32 // SOPT1 Configuration Register

//--- System Options registers 2
   SOPT2 0x1004 $uint32 {
    13,
    USBSRC, // 0=USB_CLKIN, 1=FFL/PLL
    1,
    PLLFLLSEL, // 0=FLL, 1=PLL
    3,
    TRACECLKSEL, // 0=MCGOUTCLK, 1=CPU
    PTD7PAD,
    3,
    CLKOUTSEL:3, // Selects the clock to output on the CLKOUT pin.
    RTCCLKOUTSEL, // RTC clock out select
    4
  }

  SOPT4   0x100C $uint32 // System Options registers 4
  SOPT5   0x1010 $uint32 // System Options registers 5
  SOPT7   0x1018 $uint32 // System Options registers 7
  SDID @ro 0x1024 $uint32 // System Device Identification Register
  SCGC2  0x102C $uint32 // System Clock Gating Control registers 2
  SCGC3  0x1030 $uint32 // System Clock Gating Control registers 3

//--- System Clock Gating Control registers 4
  SCGC4 0x1034 $uint32 {
    11,
    VREF,
    CMP,
    USBOTG,
    5,
    UART2,
    UART1,
    UART0,
    2,
    I2C1,
    I2C0,
    3,
    CMT,
    EWM,
    1
  }

  SCGC5 0x1038 $uint32 // System Clock Gating Control registers 5
  SCGC6 0x103C $uint32 // System Clock Gating Control registers 6
  SCGC7 0x1040 $uint32 // System Clock Gating Control registers 7
  
  CLKDIV1 0x1044 $uint32 {// System Clock Divider registers 1
    OUTDIV1:4, // Divide value for the core/system clock
    OUTDIV2:4, // Divide value for the peripheral clock
    4,
    OUTDIV4:4, // Divide value for the flash clock
    16
  }
  
//--- System Clock Divider registers 2
   CLKDIV2 0x1048 $uint32 {
    28,
    USBDIV:3,
    USBFRAC
  }

  FCFG1 @ro 0x104C $uint32 // Flash Configuration registers 1
  FCFG2 @ro 0x1050 $uint32 // Flash Configuration registers 2
  UIDH  @ro 0x1054 $uint32 // Unique Identification registers High
  UIDMH @ro 0x1058 $uint32 // Unique Identification registers Mid-High
  UIDML @ro 0x105C $uint32 // Unique Identification registers Mid Low
  UIDL  @ro 0x1060 $uint32 // Unique Identification registers Low
}

// Chapter 13: Reset Control Module (RCM)
registers #RCM 0x4007F000 {
  SRS0 0x00 $uint8 // System Reset Status registers 0
  SRS1 0x01 $uint8 // System Reset Status registers 1
  RPFC 0x04 $uint8 // Reset Pin Filter Control Register
  RPFW 0x05 $uint8 // Reset Pin Filter Width Register
  MR   0x07 $uint8 // Mode Register
}

// Chapter 14: System Mode Controller
let SMC_PMPROT_AVLP  $uint8 = 0x20   // Allow very low power modes
let SMC_PMPROT_ALLS $uint8  = 0x08   // Allow low leakage stop mode
let SMC_PMPROT_AVLLS $uint8 = 0x02   // Allow very low leakage stop mode

let SMC_PMCTRL_LPWUI $uint8  = 0x80   // Low Power Wake Up on Interrupt
let SMC_PMCTRL_STOPA $uint8  = 0x08   // Stop Aborted

let SMC_VLLSCTRL_PORPO $uint8 = 0x20   // POR Power Option

let SMC_PMSTAT_RUN  $uint8 = 0x01   // Current power mode is RUN
let SMC_PMSTAT_STOP $uint8 = 0x02   // Current power mode is STOP
let SMC_PMSTAT_VLPR $uint8 = 0x04   // Current power mode is VLPR
let SMC_PMSTAT_VLPW $uint8 = 0x08   // Current power mode is VLPW
let SMC_PMSTAT_VLPS $uint8 = 0x10   // Current power mode is VLPS
let SMC_PMSTAT_LLS  $uint8 = 0x20   // Current power mode is LLS
let SMC_PMSTAT_VLLS $uint8 = 0x40   // Current power mode is VLLS

registers #SMC 0x4007_E000 {
  PMPROT  0x00 $uint8 // Power Mode Protection Register
  PMCTRL  0x01 $uint8 // Power Mode Control Register
  VLLSCTRL 0x02 $uint8 // VLLS Control Register
  PMST 0x03 $uint8 // Power Mode Status Register
}

// Chapter 15: Power Management Controller
let PMC_LVDSC1_LVDF $uint8 = 0x80   // Low-Voltage Detect Flag
let PMC_LVDSC1_LVDACK $uint8 = 0x40   // Low-Voltage Detect Acknowledge
let PMC_LVDSC1_LVDIE $uint8 = 0x20   // Low-Voltage Detect Interrupt Enable
let PMC_LVDSC1_LVDRE $uint8 = 0x10   // Low-Voltage Detect Reset Enable

let PMC_LVDSC2_LVWF $uint8  = 0x80   // Low-Voltage Warning Flag
let PMC_LVDSC2_LVWACK $uint8 = 0x40   // Low-Voltage Warning Acknowledge
let PMC_LVDSC2_LVWIE $uint8 = 0x20   // Low-Voltage Warning Interrupt Enable

registers #PMC 0x4007_D000 {
  LVDSC1 0x00 $uint8 // Low Voltage Detect Status And Control 1 register
  LVDSC2 0x01 $uint8 // Low Voltage Detect Status And Control 2 register
  REGSC  0x02 $uint8 { // Regulator Status And Control register
    3, BGEN, ACKISO, REGONS, BGBE, 1
  }
}

// Chapter 16: Low-Leakage Wakeup Unit (LLWU)
registers #LLWU 0x4007_C000 {
  PE1  0x00 $uint8 // LLWU Pin Enable 1 register
  PE2  0x01 $uint8 // LLWU Pin Enable 2 register
  PE3  0x02 $uint8 // LLWU Pin Enable 3 register
  PE4  0x03 $uint8 // LLWU Pin Enable 4 register
  ME   0x04 $uint8 // LLWU Module Enable register
  F1   0x05 $uint8 // LLWU Flag 1 register
  F2   0x06 $uint8 // LLWU Flag 2 register
  F3   0x07 $uint8 // LLWU Flag 3 register
  FILT1 0x08 $uint8 // LLWU Pin Filter 1 register
  FILT2 0x09 $uint8 // LLWU Pin Filter 2 register
  RST  0x0A $uint8 // LLWU Reset Enable register
}

// Chapter 17: Miscellaneous Control Module (MCM)
let MCM_PLACR_ARG   $uint32 = 0x00000200  // Arbitration select, 0=fixed, 1=round-robin
let MCM_CR_SRAMLWP  $uint32 =  0x4000_0000  // SRAM_L write protect
//let $uint32 MCM_CR_SRAMLAP(n)   (((n) & 0x03) << 28) // SRAM_L priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA
let MCM_CR_SRAMUWP  $uint32 =  0x0400_0000  // SRAM_U write protect
//let $uint32 MCM_CR_SRAMUAP(n)   (((n) & 0x03) << 24) // SRAM_U priority, 0=RR, 1=favor DMA, 2=CPU, 3=DMA

registers #MCM 0xE008_0000 {
  PLASC @ro 0x08 $uint16 // Crossbar Switch (AXBS) Slave Configuration
  PLAMC @ro 0x0A $uint16 // Crossbar Switch (AXBS) Master Configuration
  CR 0x0C $uint32 // RAM arbitration control registers (MK20DX256)
}

// Crossbar Switch (AXBS) - only programmable on MK20DX256
let AXBS_CRS_READONLY  $uint32=  0x80000000
let AXBS_CRS_HALTLOWPRIORITY  $uint32 = 0x40000000
let AXBS_CRS_ARB_FIXED  $uint32 = 0x00000000
let AXBS_CRS_ARB_ROUNDROBIN  $uint32 = 0x00010000
let AXBS_CRS_PARK_FIXED  $uint32 =  0x00000000
let AXBS_CRS_PARK_PREVIOUS  $uint32 =  0x00000010
let AXBS_CRS_PARK_NONE  $uint32 =  0x00000020

registers #AXBS 0x4000_4000 {
  PRS0   0x000 $uint32 // Priority Registers Slave 0
  CRS0   0x010 $uint32 // Control registers 0
  PRS1   0x100 $uint32 // Priority Registers Slave 1
  CRS1   0x110 $uint32 // Control registers 1
  PRS2   0x200 $uint32 // Priority Registers Slave 2
  CRS2   0x210 $uint32 // Control registers 2
  PRS3   0x300 $uint32 // Priority Registers Slave 3
  CRS3   0x310 $uint32 // Control registers 3
  PRS4   0x400 $uint32 // Priority Registers Slave 4
  CRS4   0x410 $uint32 // Control registers 4
  PRS5   0x500 $uint32 // Priority Registers Slave 5
  CRS5   0x510 $uint32 // Control registers 5
  PRS6   0x600 $uint32 // Priority Registers Slave 6
  CRS6   0x610 $uint32 // Control registers 6
  PRS7   0x700 $uint32 // Priority Registers Slave 7
  CRS7   0x710 $uint32 // Control registers 7
  MGPCR0 0x800 $uint32 // Master 0 General Purpose Control Register
  MGPCR1 0x900 $uint32 // Master 1 General Purpose Control Register
  MGPCR2 0xA00 $uint32 // Master 2 General Purpose Control Register
  MGPCR3 0xB00 $uint32 // Master 3 General Purpose Control Register
  MGPCR4 0xC00 $uint32 // Master 4 General Purpose Control Register
  MGPCR5 0xD00 $uint32 // Master 5 General Purpose Control Register
  MGPCR6 0xE00 $uint32 // Master 6 General Purpose Control Register
  MGPCR7 0xF00 $uint32 // Master 7 General Purpose Control Register
}


// Chapter 20: Direct Memory Access Multiplexer (DMAMUX)
let DMA_CHANNEL_COUNT = 16

registers #DMAMUX0 0x4002_1000 {
  CHCFG [DMA_CHANNEL_COUNT] 0x0 @inc 1 $uint8 {
    ENABLE, TRIG, SOURCE:6
  }
}

let DMAMUX_SOURCE_UART0_RX $uint6 =  2
let DMAMUX_SOURCE_UART0_TX $uint6 =  3
let DMAMUX_SOURCE_UART1_RX $uint6 =  4
let DMAMUX_SOURCE_UART1_TX $uint6 =  5
let DMAMUX_SOURCE_UART2_RX $uint6 =  6
let DMAMUX_SOURCE_UART2_TX $uint6 =  7
let DMAMUX_SOURCE_I2S0_RX  $uint6 = 14
let DMAMUX_SOURCE_I2S0_TX  $uint6 = 15
let DMAMUX_SOURCE_SPI0_RX  $uint6 = 16
let DMAMUX_SOURCE_SPI0_TX  $uint6 = 17
let DMAMUX_SOURCE_I2C0     $uint6 = 22
let DMAMUX_SOURCE_I2C1     $uint6 = 23
let DMAMUX_SOURCE_FTM0_CH0 $uint6 = 24
let DMAMUX_SOURCE_FTM0_CH1 $uint6 = 25
let DMAMUX_SOURCE_FTM0_CH2 $uint6 = 26
let DMAMUX_SOURCE_FTM0_CH3 $uint6 = 27
let DMAMUX_SOURCE_FTM0_CH4 $uint6 = 28
let DMAMUX_SOURCE_FTM0_CH5 $uint6 = 29
let DMAMUX_SOURCE_FTM0_CH6 $uint6 = 30
let DMAMUX_SOURCE_FTM0_CH7 $uint6 = 31
let DMAMUX_SOURCE_FTM1_CH0 $uint6 = 32
let DMAMUX_SOURCE_FTM1_CH1 $uint6 = 33
let DMAMUX_SOURCE_FTM2_CH0 $uint6 = 34
let DMAMUX_SOURCE_FTM2_CH1 $uint6 = 35
let DMAMUX_SOURCE_ADC0     $uint6 = 40
let DMAMUX_SOURCE_ADC1     $uint6 = 41
let DMAMUX_SOURCE_CMP0     $uint6 = 42
let DMAMUX_SOURCE_CMP1     $uint6 = 43
let DMAMUX_SOURCE_CMP2     $uint6 = 44
let DMAMUX_SOURCE_DAC0     $uint6 = 45
let DMAMUX_SOURCE_CMT      $uint6 = 47
let DMAMUX_SOURCE_PDB      $uint6 = 48
let DMAMUX_SOURCE_PORTA    $uint6 = 49
let DMAMUX_SOURCE_PORTB    $uint6 = 50
let DMAMUX_SOURCE_PORTC    $uint6 = 51
let DMAMUX_SOURCE_PORTD    $uint6 = 52
let DMAMUX_SOURCE_PORTE    $uint6 = 53
let DMAMUX_SOURCE_ALWAYS0  $uint6 = 54
let DMAMUX_SOURCE_ALWAYS1  $uint6 = 55
let DMAMUX_SOURCE_ALWAYS2  $uint6 = 56
let DMAMUX_SOURCE_ALWAYS3  $uint6 = 57
let DMAMUX_SOURCE_ALWAYS4  $uint6 = 58
let DMAMUX_SOURCE_ALWAYS5  $uint6 = 59
let DMAMUX_SOURCE_ALWAYS6  $uint6 = 60
let DMAMUX_SOURCE_ALWAYS7  $uint6 = 61
let DMAMUX_SOURCE_ALWAYS8  $uint6 = 62
let DMAMUX_SOURCE_ALWAYS9  $uint6 = 63

// Chapter 21: Direct Memory Access Controller (eDMA)

// Control Register
let DMA_TCD_ATTR_SIZE_8BIT   $uint4 = 0
let DMA_TCD_ATTR_SIZE_16BIT  $uint4 = 1
let DMA_TCD_ATTR_SIZE_32BIT  $uint4 = 2
let DMA_TCD_ATTR_SIZE_16BYTE $uint4 = 4
let DMA_TCD_ATTR_SIZE_32BYTE $uint4 = 5

registers #DMA 0x4000_8000 {
  CR 0x00 $uint32 {
    14,
    CX, // Cancel Transfer
    ECX, // Error Cancel Transfer
    5,
    GRP1PRI,
    1,
    GRP0PRI,
    EMLM, // Enable Minor Loop Mapping
    CLM, // Continuous Link Mode
    HALT, // Halt DMA Operations
    HOE, // Halt On Error
    ERGA, // Enable Round Robin Group Arbitration
    ERCA, // Enable Round Robin Channel Arbitration 
    EDBG, // Enable Debug
    1
  }
  
  // Error Status Register
  ES  0x04 $uint32 {
    VLD, 14, ECX, 1, CPE, 2, ERRCHN :4, SAE, SOE, DAE, DOE, NCE, SGE, SBE, DBE
  }
  
  ERQ 0x0C $uint32 { // Enable Request Register
   16, 
   ERQ15, ERQ14, ERQ13, ERQ12, ERQ11, ERQ10, ERQ9,  ERQ8,
   ERQ7,  ERQ6,  ERQ5,  ERQ4,  ERQ3,  ERQ2,  ERQ1,  ERQ0
  }
  
  EEI 0x14 $uint32 { // Enable Error Interrupt Register
   16, 
   EEI15, EEI14, EEI13, EEI12, EEI11, EEI10, EEI9,  EEI8,
   EEI7,  EEI6,  EEI5,  EEI4,  EEI3,  EEI2,  EEI1,  EEI0
  }
  
  CEEI 0x18 $uint8 { // Clear Enable Error Interrupt Register
   NOP, CAAE, 2, CEEI:4
  }
  
  SEEI 0x19 $uint8 { // Set Enable Error Interrupt Register
   NOP, SAAE, 2, SEEI:4
  }
  
  CERQ 0x1A $uint8 { // Clear Enable Request Register
   NOP, CAER, 2, CERQ:4
  }
  
  SERQ 0x1B $uint8 { // Set Enable Request Register
   NOP, SAER, 2, SERQ:4
  }
  
  CDNE 0x1C $uint8 { // Clear DONE Status Bit Register
   NOP, CADN, 2, CDNE:4
  }
  
  SSRT 0x1D $uint8 { // Set START Bit Register
   NOP, SAST, 2, SSRT:4
  }
  
  CERR 0x1E $uint8 { // Clear Error Register
   NOP, CAEI, 2, CERR:4
  }
  
  CINT 0x1F $uint8 { // Clear Interrupt Request Register
   NOP, CAIR, 2, CINT:4
  }
  
  INT 0x24 $uint32 { // Interrupt Request Register
   16, 
   INT15, INT14, INT13, INT12, INT11, INT10, INT9,  INT8,
   INT7,  INT6,  INT5,  INT4,  INT3,  INT2,  INT1,  INT0
  }
  
  ERR 0x2C $uint32 { // Error Register
   16, 
   ERR15, ERR14, ERR13, ERR12, ERR11, ERR10, ERR9,  ERR8,
   ERR7,  ERR6,  ERR5,  ERR4,  ERR3,  ERR2,  ERR1,  ERR0
  }
  
  HRS 0x34 $uint32 { // Hardware Request Status Register
   16, 
   HRS15, HRS14, HRS13, HRS12, HRS11, HRS10, HRS9,  HRS8,
   HRS7,  HRS6,  HRS5,  HRS4,  HRS3,  HRS2,  HRS1,  HRS0
  }
  
  DCHPRI [DMA_CHANNEL_COUNT] 0x100 @inc 1 $uint8 { // Channel n Priority Register
   ECP, DPA, 2, CHPRI:4
  }
  
  TCD_SADDR [DMA_CHANNEL_COUNT] 0x1000 @inc 32 $uint32 // TCD Source Address
  
  TCD_SOFF [DMA_CHANNEL_COUNT] 0x1004 @inc 32 $int16 // TCD Signed Source Address Offset
  
  TCD_ATTR [DMA_CHANNEL_COUNT] 0x1006 @inc 32 $uint16 { // TCD Transfer Attributes
    SMOD:4, SSIZE:4, DMOD:4, DSIZE:4
  }
  
  // TCD Minor Byte Count (Minor Loop Disabled)
  TCD_NBYTES_MLNO [DMA_CHANNEL_COUNT] 0x1008 @inc 32 $uint32
  
  // TCD Last Source Address Adjustment
  TCD_SLAST [DMA_CHANNEL_COUNT] 0x100C @inc 32 $int32
  
  // TCD Destination Address
  TCD_DADDR [DMA_CHANNEL_COUNT] 0x1010 @inc 32 $uint32
  
  // TCD Signed Destination Address Offset
  TCD_DOFF [DMA_CHANNEL_COUNT] 0x1014 @inc 32 $int16
  
  // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  TCD_CITER_ELINKNO [DMA_CHANNEL_COUNT] 0x1016 @inc 32 $uint16 {
    ELINK, CITER:15
  }
  
  // TCD Last Destination Address Adjustment/Scatter Gather Address
  TCD_DLASTSGA [DMA_CHANNEL_COUNT] 0x1018 @inc 32 $int32
  
  // TCD Control and Status 
  TCD_CSR [DMA_CHANNEL_COUNT] 0x101C @inc 32 $uint16 {
    BWC:2, 2, MAJORLINKCH:4,
    DONE, ACTIVE, MAJORLINK, ESG, DREQ, INTHALF, INTMAJOR, START
  }
  
  // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) 
  TCD_BITER_ELINKNO [DMA_CHANNEL_COUNT] 0x101E @inc 32 $uint16 {
    ELINK, BITER:15
  }
}

//// Chapter 22: External Watchdog Monitor (EWM)
//registers EWM_CTRL  *(volatile $uint8_t  *)0x40061000 // Control Register
//registers EWM_SERV  *(volatile $uint8_t  *)0x40061001 // Service Register
//registers EWM_CMPL  *(volatile $uint8_t  *)0x40061002 // Compare Low Register
//registers EWM_CMPH  *(volatile $uint8_t  *)0x40061003 // Compare High Register
//
//// Chapter 23: Watchdog Timer (WDOG)
let WDOG_STCTRLH_DISTESTWDOG $uint16 = 0x4000  // Allows the WDOG's functional test mode to be disabled permanently.

let WDOG_STCTRLH_TESTSEL  $uint16 = 0x0800
let WDOG_STCTRLH_TESTWDOG $uint16 = 0x0400
let WDOG_STCTRLH_WAITEN $uint16 = 0x0080
let WDOG_STCTRLH_STOPEN $uint16 = 0x0040
let WDOG_STCTRLH_DBGEN  $uint16 = 0x0020
let WDOG_STCTRLH_ALLOWUPDATE $uint16 = 0x0010
let WDOG_STCTRLH_WINEN $uint16 = 0x0008
let WDOG_STCTRLH_IRQRSTEN $uint16 = 0x0004
let WDOG_STCTRLH_CLKSRC $uint16 = 0x0002
let WDOG_STCTRLH_WDOGEN $uint16 = 0x0001

let WDOG_UNLOCK_SEQ1 $uint16   = 0xC520
let WDOG_UNLOCK_SEQ2 $uint16   = 0xD928

registers #WDOG 0x4005_2000 {
  STCTRLH  0x00 $uint16 // Watchdog Status and Control registers High
  STCTRLL  0x02 $uint16 // Watchdog Status and Control registers Low
  TOVALH   0x04 $uint16 // Watchdog Time-out Value registers High
  TOVALL   0x06 $uint16 // Watchdog Time-out Value registers Low
  WINH     0x08 $uint16 // Watchdog Window registers High
  WINL     0x0A $uint16 // Watchdog Window registers Low
  REFRESH  0x0C $uint16 // Watchdog Refresh register
  UNLOCK   0x0E $uint16 // Watchdog Unlock register
  TMROUTH  0x10 $uint16 // Watchdog Timer Output registers High
  TMROUTL  0x12 $uint16 // Watchdog Timer Output registers Low
  RSTCNT   0x14 $uint16 // Watchdog Reset Count register
  PRESC    0x16 $uint16 // Watchdog Prescaler register
}

// Chapter 24: Multipurpose Clock Generator (MCG)
let MCG_C4_SCFTRIM $uint8 = 0x01   // Slow Internal Reference Clock Fine Trim
let MCG_C4_DMX32 $uint8 = 0x80   // DCO Maximum Frequency with 32.768 kHz Reference, controls whether the DCO frequency range is narrowed
let MCG_SC_LOCS0 $uint8 = 0x01   // OSC0 Loss of Clock Status
//SC_FCRDIV(n)  ($uint8_t)(((n) & 0x07) << 1) // Fast Clock Internal Reference Divider
let MCG_SC_FLTPRSRV $uint8 = 0x10   // FLL Filter Preserve Enable
let MCG_SC_ATMF $uint8 = 0x20   // Automatic Trim Machine Fail Flag
let MCG_SC_ATMS $uint8 = 0x40   // Automatic Trim Machine Select
let MCG_SC_ATME $uint8 = 0x80   // Automatic Trim Machine Enable

registers #MCG 0x4006_4000 {
  C1 0x00 $uint8 { // MCG Control 1 Register
    CLKS:2, // Clock Source Select, Selects the clock source for MCGOUTCLK
    FRDIV:3, // FLL External Reference Divider, Selects the amount to divide down the external reference clock for the FLL
    IREFS, // Internal Reference Select, Selects the reference clock source for the FLL
    IRCLKEN, // Internal Reference Clock Enable, Enables the internal reference clock for use as MCGIRCLK
    IREFSTEN // Internal Reference Stop Enable, Controls whether or not the internal reference clock remains enabled when the MCG enters Stop mode
  }
  
  C2 0x01 $uint8 { // MCG Control 2 Register
    LOCRE0, // Loss of Clock Reset Enable, Determines whether an interrupt 
            // or a reset request is made following a loss of OSC0
    1,
    RANGE0:2, // Frequency Range Select, Selects the frequency range
               // for the crystal oscillator
    HGO0, // High Gain Oscillator Select, Controls the crystal oscillator mode of operation  
    EREFS, // External Reference Select, selects the source for the external reference clock
    LP, // Low Power Select, Controls whether the FLL or PLL is disabled in BLPI and BLPE modes.
    IRCS // Internal Reference Clock Select, Selects between the fast or slow internal reference clock source.
  }
  
  C3 0x02 $uint8 // MCG Control 3 Register
  //C3_SCTRIM(n)  ($uint8_t)(n)   // Slow Internal Reference Clock Trim Setting
  C4 0x03 $uint8 // MCG Control 4 Register
  //C4_FCTRIM(n)  ($uint8_t)(((n) & 0x0F) << 1) // Fast Internal Reference Clock Trim Setting
  //C4_DRST_DRS(n)  ($uint8_t)(((n) & 0x03) << 5) // DCO Range Select  
  
  C5 0x04 $uint8 { // MCG Control 5 Register
   1,
   PLLCLKEN0, // PLL Clock Enable
   PLLSTEN0,  // PLL Stop Enable
   PRDIV0:5 // PLL External Reference Divider
  }
  
  C6 0x05 $uint8 { // MCG Control 6 Register
   LOLIE0, // Loss of Lock Interrrupt Enable
   PLLS, // PLL Select, Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00
   CME0,   // Clock Monitor Enable
   VDIV0:5 // VCO 0 Divider
  }
  
  S @ro 0x06 $uint8 { // MCG Status Register
   LOLS0, // Loss of Lock Status
   LOCK0, // Lock Status, 0=PLL Unlocked, 1=PLL Locked
   PLLST, // PLL Select Status
   IREFST, // Internal Reference Status
   CLKST:2, // Clock Mode Status, 0=FLL is selected, 1= Internal ref, 2=External ref, 3=PLL
   OSCINIT0, // OSC Initialization, resets to 0, is set to 1 after the initialization cycles of the crystal oscillator
   IRCST   // Internal Reference Clock Status
  }
  
  SC 0x08 $uint8 // MCG Status and Control Register
  
  ATCVH 0x0A $uint8 // MCG Auto Trim Compare Value High Register
  ATCVL 0x0B $uint8 // MCG Auto Trim Compare Value Low Register
  C7    0x0C $uint8 // MCG Control 7 Register
  C8    0x0D $uint8 // MCG Control 8 Register
}

//// Chapter 25: Oscillator (OSC)
let OSC_SC16P  $uint8 = 0x01   

registers #OSC 0x4006_5000 {
  CR 0x00 $uint8 {// OSC Control Register
    ERCLKEN, // External Reference Enable, Enables external reference clock (OSCERCLK)
    1,
    EREFSTEN, // External Reference Stop Enable, Controls whether or not 
              // the external reference clock (OSCERCLK) remains enabled when
              // MCU enters Stop mode.
    1,
    SC2P, // Oscillator 2 pF Capacitor Load Configure
    SC4P, // Oscillator 4 pF Capacitor Load Configure
    SC8P, // Oscillator 8 pF Capacitor Load Configure
    SC16P // Oscillator 16 pF Capacitor Load Configure
  }
}

//// Chapter 27: Flash Memory Controller (FMC)
registers #FMC 0x4001_F000 {
  PFAPR     0x000 $uint32 // Flash Access Protection
  PFB0CR    0x004 $uint32 // Flash Control
  TAGVDW0S0 0x100 $uint32 // Cache Tag Storage
  TAGVDW0S1 0x104 $uint32 // Cache Tag Storage
  TAGVDW1S0 0x108 $uint32 // Cache Tag Storage
  TAGVDW1S1 0x10C $uint32 // Cache Tag Storage
  TAGVDW2S0 0x110 $uint32 // Cache Tag Storage
  TAGVDW2S1 0x114 $uint32 // Cache Tag Storage
  TAGVDW3S0 0x118 $uint32 // Cache Tag Storage
  TAGVDW3S1 0x11C $uint32 // Cache Tag Storage
  DATAW0S0  0x200 $uint32 // Cache Data Storage
  DATAW0S1  0x204 $uint32 // Cache Data Storage
  DATAW1S0  0x208 $uint32 // Cache Data Storage
  DATAW1S1  0x20C $uint32 // Cache Data Storage
  DATAW2S0  0x210 $uint32 // Cache Data Storage
  DATAW2S1  0x214 $uint32 // Cache Data Storage
  DATAW3S0  0x218 $uint32 // Cache Data Storage
  DATAW3S1  0x21C $uint32 // Cache Data Storage
}


//// Chapter 28: Flash Memory Module (FTFL)
//registers FTFL_FST *(volatile $uint8_t  *)0x40020000      // Flash Status Register
//registers FTFL_FSTAT_CCIF   ($uint8_t)0x80   // Command Complete Interrupt Flag
//registers FTFL_FSTAT_RDCOLERR  ($uint8_t)0x40   // Flash Read Collision Error Flag
//registers FTFL_FSTAT_ACCERR  ($uint8_t)0x20   // Flash Access Error Flag
//registers FTFL_FSTAT_FPVIOL  ($uint8_t)0x10   // Flash Protection Violation Flag
//registers FTFL_FSTAT_MGSTAT0  ($uint8_t)0x01   // Memory Controller Command Completion Status Flag
//registers FTFL_FCNFG  *(volatile $uint8_t  *)0x40020001      // Flash Configuration Register
//registers FTFL_FCNFG_CCIE   ($uint8_t)0x80   // Command Complete Interrupt Enable
//registers FTFL_FCNFG_RDCOLLIE  ($uint8_t)0x40   // Read Collision Error Interrupt Enable
//registers FTFL_FCNFG_ERSAREQ  ($uint8_t)0x20   // Erase All Request
//registers FTFL_FCNFG_ERSSUSP  ($uint8_t)0x10   // Erase Suspend
//registers FTFL_FCNFG_PFLSH  ($uint8_t)0x04   // Flash memory configuration
//registers FTFL_FCNFG_RAMRDY  ($uint8_t)0x02   // RAM Ready
//registers FTFL_FCNFG_EEERDY  ($uint8_t)0x01   // EEPROM Ready
//registers FTFL_FSEC  *(const    $uint8_t  *)0x40020002      // Flash Security Register
//registers FTFL_FOPT  *(const    $uint8_t  *)0x40020003      // Flash Option Register
//registers FTFL_FCCOB3  *(volatile $uint8_t  *)0x40020004      // Flash Common Command Object Registers
//registers FTFL_FCCOB2  *(volatile $uint8_t  *)0x40020005
//registers FTFL_FCCOB1  *(volatile $uint8_t  *)0x40020006
//registers FTFL_FCCOB0  *(volatile $uint8_t  *)0x40020007
//registers FTFL_FCCOB7  *(volatile $uint8_t  *)0x40020008
//registers FTFL_FCCOB6  *(volatile $uint8_t  *)0x40020009
//registers FTFL_FCCOB5  *(volatile $uint8_t  *)0x4002000A
//registers FTFL_FCCOB4  *(volatile $uint8_t  *)0x4002000B
//registers FTFL_FCCOBB  *(volatile $uint8_t  *)0x4002000C
//registers FTFL_FCCOBA  *(volatile $uint8_t  *)0x4002000D
//registers FTFL_FCCOB9  *(volatile $uint8_t  *)0x4002000E
//registers FTFL_FCCOB8  *(volatile $uint8_t  *)0x4002000F
//registers FTFL_FPROT3  *(volatile $uint8_t  *)0x40020010      // Program Flash Protection Registers
//registers FTFL_FPROT2  *(volatile $uint8_t  *)0x40020011      // Program Flash Protection Registers
//registers FTFL_FPROT1  *(volatile $uint8_t  *)0x40020012      // Program Flash Protection Registers
//registers FTFL_FPROT0  *(volatile $uint8_t  *)0x40020013      // Program Flash Protection Registers
//registers FTFL_FEPROT  *(volatile $uint8_t  *)0x40020016      // EEPROM Protection Register
//registers FTFL_FDPROT  *(volatile $uint8_t  *)0x40020017      // Data Flash Protection Register

// Chapter 30: Cyclic Redundancy Check (CRC)
registers #CRC 0x4003_2000 {
  CRC   0x00 $uint32 // CRC Data register
  GPOLY 0x04 $uint32 // CRC Polynomial register
  CTRL  0x08 $uint32 // CRC Control register
}

// Chapter 31: Analog-to-Digital Converter (ADC)
let ADC_SC1_COCO  $uint32 = 0x80   // Conversion complete flag
let ADC_SC1_AIEN  $uint32 = 0x40   // Interrupt enable
let ADC_SC1_DIFF  $uint32 = 0x20   // Differential mode enable

let ADC_CFG1_ADLPC  $uint32 = 0x80   // Low-power configuration
let ADC_CFG1_ADLSMP  $uint32 = 0x10   // Sample time configuration, 0=Short, 1=Long

let ADC_CFG2_MUXSEL  $uint32 = 0x10   // 0=a channels, 1=b channels
let ADC_CFG2_ADACKEN  $uint32 = 0x08   // async clock enable
let ADC_CFG2_ADHSC   $uint32 = 0x04   // High speed configuration

let ADC_SC2_ADACT  $uint32 = 0x80   // Conversion active
let ADC_SC2_ADTRG  $uint32 = 0x40   // Conversion trigger select, 0=software, 1=hardware
let ADC_SC2_ACFE   $uint32 = 0x20   // Compare function enable
let ADC_SC2_ACFGT  $uint32 = 0x10   // Compare function greater than enable
let ADC_SC2_ACREN  $uint32 = 0x08   // Compare function range enable
let ADC_SC2_DMAEN  $uint32= 0x04   // DMA enable

let ADC_SC3_CAL  $uint32 = 0x80   // Calibration, 1=begin, stays set while cal in progress
let ADC_SC3_CALF  $uint32= 0x40   // Calibration failed flag
let ADC_SC3_ADCO  $uint32= 0x08   // Continuous conversion enable
let ADC_SC3_AVGE  $uint32= 0x04   // Hardware average enable

let ADC0_PGA_PGAEN  $uint32 = 0x00800000  // Enable
let ADC0_PGA_PGALPB  $uint32 = 0x00100000  // Low-Power Mode Control, 0=low power, 1=normal

registers #ADC0 0x4003_B000 {
  SC1A   0x00 $uint32 // ADC status and control registers 1
  SC1B   0x04 $uint32 // ADC status and control registers 1
  CFG1   0x08 $uint32 // ADC configuration registers 1
  CFG2  0x0C $uint32 // Configuration registers 2
  RA    0x10 $uint32 // ADC data result register
  RB    0x14 $uint32 // ADC data result register
  CV1   0x18 $uint32 // Compare value registers
  CV2   0x1C $uint32 // Compare value registers
  SC2   0x20 $uint32 // Status and control registers 2
  SC3   0x24 $uint32 // Status and control registers 3
  OFS   0x28 $uint32 // ADC offset correction register
  PG    0x2C $uint32 // ADC plus-side gain register
  MG    0x30 $uint32 // ADC minus-side gain register
  CLPD  0x34 $uint32 // ADC plus-side general calibration value register
  CLPS  0x38 $uint32 // ADC plus-side general calibration value register
  CLP4  0x3C $uint32 // ADC plus-side general calibration value register
  CLP3  0x40 $uint32 // ADC plus-side general calibration value register
  CLP2  0x44 $uint32 // ADC plus-side general calibration value register
  CLP1  0x48 $uint32 // ADC plus-side general calibration value register
  CLP0  0x4C $uint32 // ADC plus-side general calibration value register
  PGA   0x50 $uint32 // ADC Programmable Gain Amplifier
  CLMD   0x54 $uint32 // ADC minus-side general calibration value register
  CLMS   0x58 $uint32 // ADC minus-side general calibration value register
  CLM4   0x5C $uint32 // ADC minus-side general calibration value register
  CLM3   0x60 $uint32 // ADC minus-side general calibration value register
  CLM2   0x64 $uint32 // ADC minus-side general calibration value register
  CLM1   0x68 $uint32 // ADC minus-side general calibration value register
  CLM0   0x6C $uint32 // ADC minus-side general calibration value register
}

registers #ADC1 0x400B_B000 {
  SC1A   0x00 $uint32 // ADC status and control registers 1
  SC1B   0x04 $uint32 // ADC status and control registers 1
  CFG1   0x08 $uint32 // ADC configuration registers 1
  CFG2   0x0C $uint32 // Configuration registers 2
  RA     0x10 $uint32 // ADC data result register
  RB     0x14 $uint32 // ADC data result register
  CV1    0x18 $uint32 // Compare value registers
  CV2    0x1C $uint32 // Compare value registers
  SC2    0x20 $uint32 // Status and control registers 2
  SC3    0x24 $uint32 // Status and control registers 3
  OFS    0x28 $uint32 // ADC offset correction register
  PG     0x2C $uint32 // ADC plus-side gain register
  MG     0x30 $uint32 // ADC minus-side gain register
  CLPD   0x34 $uint32 // ADC plus-side general calibration value register
  CLPS   0x38 $uint32 // ADC plus-side general calibration value register
  CLP4   0x3C $uint32 // ADC plus-side general calibration value register
  CLP3   0x40 $uint32 // ADC plus-side general calibration value register
  CLP2   0x44 $uint32 // ADC plus-side general calibration value register
  CLP1   0x48 $uint32 // ADC plus-side general calibration value register
  CLP0   0x4C $uint32 // ADC plus-side general calibration value register
  PGA    0x50 $uint32 // ADC Programmable Gain Amplifier
  CLMD   0x54 $uint32 // ADC minus-side general calibration value register
  CLMS   0x58 $uint32 // ADC minus-side general calibration value register
  CLM4   0x5C $uint32 // ADC minus-side general calibration value register
  CLM3   0x60 $uint32 // ADC minus-side general calibration value register
  CLM2   0x64 $uint32 // ADC minus-side general calibration value register
  CLM1   0x68 $uint32 // ADC minus-side general calibration value register
  CLM0   0x6C $uint32 // ADC minus-side general calibration value register
}

let DAC_C1_DMAEN $uint8 = 0x80    // DMA Enable Select
let DAC_C1_DACBFEN $uint8 = 0x00    // DAC Buffer Enable

let DAC_C0_DACEN  $uint8 = 0x80    // DAC Enable
let DAC_C0_DACRFS $uint8 = 0x40    // DAC Reference Select
let DAC_C0_DACTRGSEL $uint8 = 0x20    // DAC Trigger Select
let DAC_C0_DACSWTRG  $uint8 = 0x10    // DAC Software Trigger
let DAC_C0_LPEN  $uint8 = 0x08    // DAC Low Power Control
let DAC_C0_DACBWIEN  $uint8 = 0x04    // DAC Buffer Watermark Interrupt Enable
let DAC_C0_DACBTIEN $uint8 = 0x02    // DAC Buffer Read Pointer Top Flag Interrupt Enable
let DAC_C0_DACBBIEN $uint8 = 0x01    // DAC Buffer Read Pointer Bottom Flag Interrupt Enable

registers #DAC0 0x400C_C000 {
  DAT0L 0x00 $uint8 // DAC Data Low registers 
  DATH  0x01 $uint8 // DAC Data High registers 
  DAT1L 0x02 $uint8 // DAC Data Low registers 
  DAT2L 0x04 $uint8 // DAC Data Low registers 
  DAT3L 0x06 $uint8 // DAC Data Low registers 
  DAT4L 0x08 $uint8 // DAC Data Low registers 
  DAT5L 0x0A $uint8 // DAC Data Low registers 
  DAT6L 0x0C $uint8 // DAC Data Low registers 
  DAT7L 0x0E $uint8 // DAC Data Low registers 
  DAT8L 0x10 $uint8 // DAC Data Low registers 
  DAT9L 0x12 $uint8 // DAC Data Low registers 
  DAT10L 0x14 $uint8 // DAC Data Low registers 
  DAT11L 0x16 $uint8 // DAC Data Low registers 
  DAT12L 0x18 $uint8 // DAC Data Low registers 
  DAT13L 0x1A $uint8 // DAC Data Low registers 
  DAT14L 0x1C $uint8 // DAC Data Low registers 
  DAT15L 0x1E $uint8 // DAC Data Low registers 
  SR     0x20 $uint8 // DAC Status registers 
  C0     0x21 $uint8 // DAC Control registers 
  C1  0x22 $uint8 // DAC Control registers 1 
  C2  0x23 $uint8 // DAC Control registers 2 
}
//// Chapter 32: Comparator (CMP)
registers #CMP0 0x4007_3000 {
  CR0   0x00 $uint8 // CMP Control registers 0
  CR1   0x01 $uint8 // CMP Control registers 1
  FPR   0x02 $uint8 // CMP Filter Period Register
  SCR   0x03 $uint8 // CMP Status and Control Register
  DACCR 0x04 $uint8 // DAC Control Register
  MUXCR 0x05 $uint8 // MUX Control Register
}

registers #CMP1 0x4007_3000 {
  CR0   0x08 $uint8 // CMP Control registers 0
  CR1   0x09 $uint8 // CMP Control registers 1
  FPR   0x0A $uint8 // CMP Filter Period Register
  SCR   0x0B $uint8 // CMP Status and Control Register
  DACCR 0x0C $uint8 // DAC Control Register
  MUXCR 0x0D $uint8 // MUX Control Register
}

//// Chapter 33: Voltage Reference (VREFV1)
registers #VREF 0x4007_4000 {
  TRM  0x00 $uint8 // VREF Trim Register
  SC   0x01 $uint8 // VREF Status and Control Register
}

// Chapter 34: Programmable Delay Block (PDB)
//registers PDB0_SC    0x40036000 // Status and Control Register
//registers PDB_SC_LDMOD(n)   (((n) & 3) << 18) // Load Mode Select
//registers PDB_SC_PDBEIE   0x00020000  // Sequence Error Interrupt Enable
//registers PDB_SC_SWTRIG   0x00010000  // Software Trigger
//registers PDB_SC_DMAEN   0x00008000  // DMA Enable
//registers PDB_SC_PRESCALER(n)  (((n) & 7) << 12) // Prescaler Divider Select
//registers PDB_SC_TRGSEL(n)  (((n) & 15) << 8) // Trigger Input Source Select
//registers PDB_SC_PDBEN   0x00000080  // PDB Enable
//registers PDB_SC_PDBIF   0x00000040  // PDB Interrupt Flag
//registers PDB_SC_PDBIE   0x00000020  // PDB Interrupt Enable.
//registers PDB_SC_MULT(n)   (((n) & 3) << 2) // Multiplication Factor
//registers PDB_SC_CONT   0x00000002  // Continuous Mode Enable
//registers PDB_SC_LDOK   0x00000001  // Load OK
//registers PDB0_MOD   0x40036004 // Modulus Register
//registers PDB0_CNT   0x40036008 // Counter Register
//registers PDB0_IDLY   0x4003600C // Interrupt Delay Register
//registers PDB0_CH0C1   0x40036010 // Channel n Control registers 1
//registers PDB0_CH0S   0x40036014 // Channel n Status Register
//registers PDB0_CH0DLY0   0x40036018 // Channel n Delay 0 Register
//registers PDB0_CH0DLY1   0x4003601C // Channel n Delay 1 Register
//registers PDB0_POEN   0x40036190 // Pulse-Out n Enable Register
//registers PDB0_PO0DLY   0x40036194 // Pulse-Out n Delay Register
//registers PDB0_PO1DLY   0x40036198 // Pulse-Out n Delay Register
//
//// Chapter 35: FlexTimer Module (FTM)
//registers FTM0_SC    0x40038000 // Status And Control
//registers FTM_SC_TOF   0x80    // Timer Overflow Flag
//registers FTM_SC_TOIE   0x40    // Timer Overflow Interrupt Enable
//registers FTM_SC_CPWMS   0x20    // Center-Aligned PWM Select
//registers FTM_SC_CLKS(n)   (((n) & 3) << 3)  // Clock Source Selection
//registers FTM_SC_PS(n)   (((n) & 7) << 0)  // Prescale Factor Selection
//registers FTM0_CNT   0x40038004 // Counter
//registers FTM0_MOD   0x40038008 // Modulo
//registers FTM0_C0SC   0x4003800C // Channel 0 Status And Control
//registers FTM0_C0V   0x40038010 // Channel 0 Value
//registers FTM0_C1SC   0x40038014 // Channel 1 Status And Control
//registers FTM0_C1V   0x40038018 // Channel 1 Value
//registers FTM0_C2SC   0x4003801C // Channel 2 Status And Control
//registers FTM0_C2V   0x40038020 // Channel 2 Value
//registers FTM0_C3SC   0x40038024 // Channel 3 Status And Control
//registers FTM0_C3V   0x40038028 // Channel 3 Value
//registers FTM0_C4SC   0x4003802C // Channel 4 Status And Control
//registers FTM0_C4V   0x40038030 // Channel 4 Value
//registers FTM0_C5SC   0x40038034 // Channel 5 Status And Control
//registers FTM0_C5V   0x40038038 // Channel 5 Value
//registers FTM0_C6SC   0x4003803C // Channel 6 Status And Control
//registers FTM0_C6V   0x40038040 // Channel 6 Value
//registers FTM0_C7SC   0x40038044 // Channel 7 Status And Control
//registers FTM0_C7V   0x40038048 // Channel 7 Value
//registers FTM0_CNTIN   0x4003804C // Counter Initial Value
//registers FTM0_STATUS   0x40038050 // Capture And Compare Status
//registers FTM0_MODE   0x40038054 // Features Mode Selection
//registers FTM_MODE_FAULTIE  0x80    // Fault Interrupt Enable
//registers FTM_MODE_FAULTM(n)  (((n) & 3) << 5)  // Fault Control Mode
//registers FTM_MODE_CAPTEST  0x10    // Capture Test Mode Enable
//registers FTM_MODE_PWMSYNC  0x08    // PWM Synchronization Mode
//registers FTM_MODE_WPDIS   0x04    // Write Protection Disable
//registers FTM_MODE_INIT   0x02    // Initialize The Channels Output
//registers FTM_MODE_FTMEN   0x01    // FTM Enable
//registers FTM0_SYNC   0x40038058 // Synchronization
//registers FTM_SYNC_SWSYNC   0x80    // 
//registers FTM_SYNC_TRIG2   0x40    // 
//registers FTM_SYNC_TRIG1   0x20    // 
//registers FTM_SYNC_TRIG0   0x10    // 
//registers FTM_SYNC_SYNCHOM  0x08    // 
//registers FTM_SYNC_REINIT   0x04    // 
//registers FTM_SYNC_CNTMAX   0x02    // 
//registers FTM_SYNC_CNTMIN   0x01    // 
//registers FTM0_OUTINIT   0x4003805C // Initial State For Channels Output
//registers FTM0_OUTMASK   0x40038060 // Output Mask
//registers FTM0_COMBINE   0x40038064 // Function For Linked Channels
//registers FTM0_DEADTIME   0x40038068 // Deadtime Insertion Control
//registers FTM0_EXTTRIG   0x4003806C // FTM External Trigger
//registers FTM0_POL   0x40038070 // Channels Polarity
//registers FTM0_FMS   0x40038074 // Fault Mode Status
//registers FTM0_FILTER   0x40038078 // Input Capture Filter Control
//registers FTM0_FLTCTRL   0x4003807C // Fault Control
//registers FTM0_QDCTRL   0x40038080 // Quadrature Decoder Control And Status
//registers FTM0_CONF   0x40038084 // Configuration
//registers FTM0_FLTPOL   0x40038088 // FTM Fault Input Polarity
//registers FTM0_SYNCONF   0x4003808C // Synchronization Configuration
//registers FTM0_INVCTRL   0x40038090 // FTM Inverting Control
//registers FTM0_SWOCTRL   0x40038094 // FTM Software Output Control
//registers FTM0_PWMLOAD   0x40038098 // FTM PWM Load
//registers FTM1_SC    0x40039000 // Status And Control
//registers FTM1_CNT   0x40039004 // Counter
//registers FTM1_MOD   0x40039008 // Modulo
//registers FTM1_C0SC   0x4003900C // Channel 0 Status And Control
//registers FTM1_C0V   0x40039010 // Channel 0 Value
//registers FTM1_C1SC   0x40039014 // Channel 1 Status And Control
//registers FTM1_C1V   0x40039018 // Channel 1 Value
//registers FTM1_CNTIN   0x4003904C // Counter Initial Value
//registers FTM1_STATUS   0x40039050 // Capture And Compare Status
//registers FTM1_MODE   0x40039054 // Features Mode Selection
//registers FTM1_SYNC   0x40039058 // Synchronization
//registers FTM1_OUTINIT   0x4003905C // Initial State For Channels Output
//registers FTM1_OUTMASK   0x40039060 // Output Mask
//registers FTM1_COMBINE   0x40039064 // Function For Linked Channels
//registers FTM1_DEADTIME   0x40039068 // Deadtime Insertion Control
//registers FTM1_EXTTRIG   0x4003906C // FTM External Trigger
//registers FTM1_POL   0x40039070 // Channels Polarity
//registers FTM1_FMS   0x40039074 // Fault Mode Status
//registers FTM1_FILTER   0x40039078 // Input Capture Filter Control
//registers FTM1_FLTCTRL   0x4003907C // Fault Control
//registers FTM1_QDCTRL   0x40039080 // Quadrature Decoder Control And Status
//registers FTM1_CONF   0x40039084 // Configuration
//registers FTM1_FLTPOL   0x40039088 // FTM Fault Input Polarity
//registers FTM1_SYNCONF   0x4003908C // Synchronization Configuration
//registers FTM1_INVCTRL   0x40039090 // FTM Inverting Control
//registers FTM1_SWOCTRL   0x40039094 // FTM Software Output Control
//registers FTM1_PWMLOAD   0x40039098 // FTM PWM Load
//registers FTM2_SC    0x400B8000 // Status And Control
//registers FTM2_CNT   0x400B8004 // Counter
//registers FTM2_MOD   0x400B8008 // Modulo
//registers FTM2_C0SC   0x400B800C // Channel 0 Status And Control
//registers FTM2_C0V   0x400B8010 // Channel 0 Value
//registers FTM2_C1SC   0x400B8014 // Channel 1 Status And Control
//registers FTM2_C1V   0x400B8018 // Channel 1 Value
//registers FTM2_CNTIN   0x400B804C // Counter Initial Value
//registers FTM2_STATUS   0x400B8050 // Capture And Compare Status
//registers FTM2_MODE   0x400B8054 // Features Mode Selection
//registers FTM2_SYNC   0x400B8058 // Synchronization
//registers FTM2_OUTINIT   0x400B805C // Initial State For Channels Output
//registers FTM2_OUTMASK   0x400B8060 // Output Mask
//registers FTM2_COMBINE   0x400B8064 // Function For Linked Channels
//registers FTM2_DEADTIME   0x400B8068 // Deadtime Insertion Control
//registers FTM2_EXTTRIG   0x400B806C // FTM External Trigger
//registers FTM2_POL   0x400B8070 // Channels Polarity
//registers FTM2_FMS   0x400B8074 // Fault Mode Status
//registers FTM2_FILTER   0x400B8078 // Input Capture Filter Control
//registers FTM2_FLTCTRL   0x400B807C // Fault Control
//registers FTM2_QDCTRL   0x400B8080 // Quadrature Decoder Control And Status
//registers FTM2_CONF   0x400B8084 // Configuration
//registers FTM2_FLTPOL   0x400B8088 // FTM Fault Input Polarity
//registers FTM2_SYNCONF   0x400B808C // Synchronization Configuration
//registers FTM2_INVCTRL   0x400B8090 // FTM Inverting Control
//registers FTM2_SWOCTRL   0x400B8094 // FTM Software Output Control
//registers FTM2_PWMLOAD   0x400B8098 // FTM PWM Load


// Chapter 36: Periodic Interrupt Timer (PIT)

// PIT Module Control Register
let PIT_COUNT = 4

registers #PIT 0x4003_7000 {
  MCR 0x00 $uint32 {
    30, MDIS, FRZ
  }
  
  // Timer Load Value Register
  LDVAL [PIT_COUNT] 0x100 @inc 16 $uint32
  
  // Current Timer Value Register
  LCVAL [PIT_COUNT] 0x104 @inc 16 $uint32
  
  // Timer Control Register
  TCTRL [PIT_COUNT] 0x108 @inc 16 $uint32 {
    29, CHN, TIE, TEN
  }
  
  // Timer Flag Register
  TFLG [PIT_COUNT] 0x10C @inc 16 $uint32 {
    31, TIF
  }
}

//
//// Chapter 37: Low-Power Timer (LPTMR)
//registers LPTMR0_CSR   0x40040000 // Low Power Timer Control Status Register
//registers LPTMR0_PSR   0x40040004 // Low Power Timer Prescale Register
//registers LPTMR0_CMR   0x40040008 // Low Power Timer Compare Register
//registers LPTMR0_CNR   0x4004000C // Low Power Timer Counter Register
//
//// Chapter 38: Carrier Modulator Transmitter (CMT)
//registers CMT_CGH1  *(volatile $uint8_t  *)0x40062000 // CMT Carrier Generator High Data registers 1
//registers CMT_CGL1  *(volatile $uint8_t  *)0x40062001 // CMT Carrier Generator Low Data registers 1
//registers CMT_CGH2  *(volatile $uint8_t  *)0x40062002 // CMT Carrier Generator High Data registers 2
//registers CMT_CGL2  *(volatile $uint8_t  *)0x40062003 // CMT Carrier Generator Low Data registers 2
//registers CMT_OC   *(volatile $uint8_t  *)0x40062004 // CMT Output Control Register
//registers CMT_MSC   *(volatile $uint8_t  *)0x40062005 // CMT Modulator Status and Control Register
//registers CMT_CMD1  *(volatile $uint8_t  *)0x40062006 // CMT Modulator Data registers Mark High
//registers CMT_CMD2  *(volatile $uint8_t  *)0x40062007 // CMT Modulator Data registers Mark Low
//registers CMT_CMD3  *(volatile $uint8_t  *)0x40062008 // CMT Modulator Data registers Space High
//registers CMT_CMD4  *(volatile $uint8_t  *)0x40062009 // CMT Modulator Data registers Space Low
//registers CMT_PPS   *(volatile $uint8_t  *)0x4006200A // CMT Primary Prescaler Register
//registers CMT_DMA   *(volatile $uint8_t  *)0x4006200B // CMT Direct Memory Access Register
//
//// Chapter 39: Real Time Clock (RTC)
let RTC_SR_TCE $uint32 = 0x00000010  
let RTC_SR_TAF $uint32 = 0x00000004  // 
let RTC_SR_TOF $uint32 = 0x00000002  // 
let RTC_SR_TIF $uint32 = 0x00000001  // 

registers #RTC 0x4003_D000 {
  TSR  0x000 $uint32 // RTC Time Seconds Register
  TPR  0x004 $uint32 // RTC Time Prescaler Register
  TAR  0x008 $uint32 // RTC Time Alarm Register
  TCR  0x00C $uint32 // RTC Time Compensation Register
  CR   0x010 $uint32 {// RTC Control Register
    18, SC2P, SC4P, SC8P, SC16P,CKLO, OSCE, 4, UM, SUP, WPE, SWR
  }
  SR  0x014 $uint32 // RTC Status Register
  LR  0x018 $uint32 // RTC Lock Register
  IER 0x01C $uint32 // RTC Interrupt Enable Register
  WAR 0x800 $uint32 // RTC Write Access Register
  RAR 0x804 $uint32 // RTC Read Access Register
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// Chapter 40: Universal Serial Bus Full Speed OTG Controller (USBFSOTG)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

registers #USB0 0x4007_2000 {
//--- Peripheral ID Register
  PERID @ro 0x000 $uint8 {2, ID:6}

//--- Peripheral ID Complement Register
  IDCOMP @ro 0x004 $uint8 {2, NID:6}

//--- Peripheral Revision Register
  REV @ro 0x008 $uint8

//--- Peripheral Additional Info Register
  ADDINFO @ro 0x00C $uint8 {IRQNUM:5, 2, IEHOST}

//--- OTG Interrupt Status Register
  OTGISTAT 0x010 $uint8 {IDCHG, ONEMSEC, LINE_STAT_CHG, 1, SESSVLDCHG, B_SESS_CHG, 1, AVBUSHG}

//--- OTG Interrupt Control Register
  OTGICR 0x014 $uint8 {IDEN, ONEMSECEN, LINESTATEEN, 1, SESSVLDEN, BSESSEN, 1, AVBUSEN}

//--- OTG Status Register
  OTGSTAT 0x018 $uint8 {ID, ONEMSECEN, LINESTATESTABLE, 1, SESS_VLD, BSESSEND, 1, AVBUSVLD}

//--- OTG Control Register
  OTGCTL 0x01C $uint8 {DPHIGH, 1, DPLOW, DMLOW, 1, OTGEN, 2}

//--- Interrupt Status Register
  ISTAT 0x080 $uint8 {STALL, ATTACH, RESUME, SLEEP, TOKDNE, SOFTOK, ERROR, USBRST}

//--- Interrupt Enable Register
  INTEN 0x084 $uint8 {STALLEN, ATTACHEN, RESUMEEN, SLEEPEN, TOKDNEEN, SOFTOKEN, ERROREN, USBRSTEN}

//--- Interrupt Error Register
  ERRSTAT 0x088 $uint8 {BSTERR, 1, DMAERR, BTOERR, DFN8, CRC16, CRC5EOF, PIDERR}

//--- Error Interrupt Enable Register
  ERREN 0x08C $uint8 {BSTERREN, 1, DMAERREN, BTOERREN, DFN8EN, CRC16EN, CRC5EOFEN, PIDERREN}

//--- Status Register
  STAT 0x090 $uint8 {ENDP:4, TX, ODD, 2}

//--- Control Register
  CTL 0x094 $uint8 {JSTATE, SE0, TXSUSPENDTOKENBUSY, RESET, HOSTMODEEN, RESUME, ODDRST, USBENOFEN}

//--- Address Register
  ADDR 0x098 $uint8 {LSEN, ADDR:7}

//--- BDT Page Register 1
  BDTPAGE1 0x09C $uint8 {BDTBA:7, 1}

//--- Frame Number Register Low
  FRMNUML 0x0A0 $uint8

//--- Frame Number Register High
  FRMNUMH 0x0A4 $uint8 {5, FRM:3}

//--- Token Register
  TOKEN 0x0A8 $uint8 {TOKENPID:4, TOKENDPT:4}

//--- SOF Threshold Register
  SOFTHLD 0x0AC $uint8

//--- BDT Page Register 2
  BDTPAGE2 0x0B0 $uint8

//--- BDT Page Register 3
  BDTPAGE3 0x0B4 $uint8

//--- Endpoint Control
  ENDPT [16] 0x0C0 @inc 4 $uint8 {HOSTWCHUB, RETRYDIS, 1, EPCTLDIS, EPRXEN, EPTXEN, EPSTALL, EPHSHK}
  
//--- USB Control Register
  USBCTRL 0x100 $uint8 {SUSP, PDE, 6}
  
//--- USB OTG Observe Register
  OBSERVE @ro 0x104 $uint8 {DPPU, DPPD, 1, DMPD, 4}
  
//--- USB OTG Control Register
  CONTROL 0x108 $uint8 {3, DPPULLNONOTG, 4}

//--- USB Transceiver Control Register 0
  USBTRC0 0x10C $uint8 {USBRESET, 1, USBRESMEM, 3, SYNC_DET, USB_RESUME_INT}
  
//--- Frame Adjust Register
  USBFRMADJUST 0x114 $uint8
}


//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// Chapter 47: General-Purpose Input/Output (GPIO)
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

registers #GPIOA 0x400F_F000 {
  PDOR @user 0x00 $uint32 // Port Data Output Register
  PSOR @user 0x04 $uint32 // Port Set Output Register
  PCOR @user 0x08 $uint32 // Port Clear Output Register
  PTOR @user 0x0C $uint32 // Port Toggle Output Register
  PDIR @user 0x10 $uint32 // Port Data Input Register
  PDDR @user 0x14 $uint32 // Port Data Direction Register
}

registers #GPIOB 0x400F_F040 {
  PDOR @user 0x00 $uint32 // Port Data Output Register
  PSOR @user 0x04 $uint32 // Port Set Output Register
  PCOR @user 0x08 $uint32 // Port Clear Output Register
  PTOR @user 0x0C $uint32 // Port Toggle Output Register
  PDIR @user 0x10 $uint32 // Port Data Input Register
  PDDR @user 0x14 $uint32 // Port Data Direction Register
}

registers #GPIOC 0x400F_F080 {
  PDOR @user 0x00 $uint32 // Port Data Output Register
  PSOR @user 0x04 $uint32 // Port Set Output Register
  PCOR @user 0x08 $uint32 // Port Clear Output Register
  PTOR @user 0x0C $uint32 // Port Toggle Output Register
  PDIR @user 0x10 $uint32 // Port Data Input Register
  PDDR @user 0x14 $uint32 // Port Data Direction Register
}

registers #GPIOD 0x400F_F0C0 {
  PDOR @user 0x00 $uint32 // Port Data Output Register
  PSOR @user 0x04 $uint32 // Port Set Output Register
  PCOR @user 0x08 $uint32 // Port Clear Output Register
  PTOR @user 0x0C $uint32 // Port Toggle Output Register
  PDIR @user 0x10 $uint32 // Port Data Input Register
  PDDR @user 0x14 $uint32 // Port Data Direction Register
}

//// Chapter 48: Touch sense input (TSI)
//registers TSI0_GENCS   0x40045000 // General Control and Status Register
//registers TSI_GENCS_LPCLKS   0x10000000  // 
//registers TSI_GENCS_LPSCNITV(n)  (((n) & 15) << 24)  // 
//registers TSI_GENCS_NSCN(n)  (((n) & 31) << 19)  // 
//registers TSI_GENCS_PS(n)   (((n) & 7) << 16)  // 
//registers TSI_GENCS_EOSF    0x00008000  // 
//registers TSI_GENCS_OUTRGF   0x00004000  // 
//registers TSI_GENCS_EXTERF   0x00002000  // 
//registers TSI_GENCS_OVRF    0x00001000  // 
//registers TSI_GENCS_SCNIP    0x00000200  // 
//registers TSI_GENCS_SWTS    0x00000100  // 
//registers TSI_GENCS_TSIEN    0x00000080  // 
//registers TSI_GENCS_TSIIE    0x00000040  // 
//registers TSI_GENCS_ERIE    0x00000020  // 
//registers TSI_GENCS_ESOR    0x00000010  // 
//registers TSI_GENCS_STM    0x00000002  // 
//registers TSI_GENCS_STPE    0x00000001  // 
//registers TSI0_SCANC   0x40045004 // SCAN Control Register
//registers TSI_SCANC_REFCHRG(n)  (((n) & 15) << 24)  // 
//registers TSI_SCANC_EXTCHRG(n)  (((n) & 7) << 16)  // 
//registers TSI_SCANC_SMOD(n)  (((n) & 255) << 8)  // 
//registers TSI_SCANC_AMCLKS(n)  (((n) & 3) << 3)  // 
//registers TSI_SCANC_AMPSC(n)  (((n) & 7) << 0)  // 
//registers TSI0_PEN   0x40045008 // Pin Enable Register
//registers TSI0_WUCNTR   0x4004500C // Wake-Up Channel Counter Register
//registers TSI0_CNTR1   0x40045100 // Counter Register
//registers TSI0_CNTR3   0x40045104 // Counter Register
//registers TSI0_CNTR5   0x40045108 // Counter Register
//registers TSI0_CNTR7   0x4004510C // Counter Register
//registers TSI0_CNTR9   0x40045110 // Counter Register
//registers TSI0_CNTR11   0x40045114 // Counter Register
//registers TSI0_CNTR13   0x40045118 // Counter Register
//registers TSI0_CNTR15   0x4004511C // Counter Register
//registers TSI0_THRESHOLD   0x40045120 // Low Power Channel Threshold Register
//
// Nested Vectored Interrupt Controller, Table 3-4 & ARMv7 ref, appendix B3.4 (page 750)
 
registers #NVIC 0xE000_E000 {
  ISER [4]  0x100 @inc 4 $uint32 // Interrupt Set-enable Registers
  ICER [4]  0x180 @inc 4 $uint32 //Interrupt Clear-enable Registers
  IPR [128] 0x400 @inc 1 $uint8 // Interrupt priority
  
  ICSR 0xD04 $uint32 { // Interrupt Control and State
    NMIPENDSET, 2, PENDSVSET, PENDSVCLR, PENDSTSET, PENDSTCLR, 1, ISRPREEMPT,
    ISRPENDING, 1, VECTPENDING:9, RETTOBASE, 2, VECTACTIVE:9
  }
  
  VTOR 0xD08 $uint32 // Vector Table Offset
  
  AIRCR 0xD0C $uint32 { // Application Interrupt and Reset Control
    VECTKEY:16, ENDIANNESS, 4, PRIGROUP:3,
    5, SYSRESETREQ, VECTCLRACTIVE, VECTRESET 
  }
}

//registers SCB_SCR    0xE000ED10 // System Control Register
//registers SCB_CCR    0xE000ED14 // Configuration and Control
//registers SCB_SHPR1   0xE000ED18 // System Handler Priority registers 1
//registers SCB_SHPR2   0xE000ED1C // System Handler Priority registers 2
//registers SCB_SHPR3   0xE000ED20 // System Handler Priority registers 3
//registers SCB_SHCSR   0xE000ED24 // System Handler Control and State
//registers SCB_CFSR   0xE000ED28 // Configurable Fault Status Register
//registers SCB_HFSR   0xE000ED2C // HardFault Status
//registers SCB_DFSR   0xE000ED30 // Debug Fault Status
//registers SCB_MMFAR   0xE000ED34 // MemManage Fault Address

//--- SYSTICK
registers #SYST 0xE000_E000 {
  CSR 0x10 $uint32 { // SysTick Control and Status
    15, 
    COUNTFLAG,
    13,
    CLKSOURCE,
    TICKINT,
    ENABLE
  }
  RVR   0x14 $uint32 // SysTick Reload Value Register
  CVR   0x18 $uint32 // SysTick Current Value Register
  CALIB  @ro 0x1C $uint32 // SysTick Calibration Value
}
registers #AIPS0 0x_4000_0000 {
  MPRA 0x00 $uint32
  
  //--- AICS0_PACR (§4.5.1 and §19.2, §19.2.2)
  // SPx: Determines whether the peripheral requires supervisor privilege level
  // for accesses. When this field is set, the master privilege level must indicate
  // the supervisor access attribute, and the MPR x [MPL n ] control field for the
  // master must be set. If not, access terminates with an error response and no
  // peripheral access initiates. 
  // 0  This peripheral does not require supervisor privilege level for accesses.    // 1  This peripheral requires supervisor privilege level for accesses.    // WPx: Determines whether the peripheral allows write accessses. When this field
  // is set and a write access is attempted, access terminates with an error
  // response and no peripheral access initiates
  // 0  This peripheral allows write accesses.    // 1  This peripheral is write protected.    // TPx : Determines whether the peripheral allows accesses from an untrusted master.
  // When this bit is set and an access is attempted by an untrusted master, the 
  // access terminates with an error response and no peripheral access initiates.
  // 0  Accesses from an untrusted master are allowed.    // 1  Accesses from an untrusted master are not allowed.    
  PACRA 0x20,
  PACRB 0x24,
  PACRC 0x28,
  PACRD 0x2C,
  PACRE 0x40,
  PACRF 0x44,
  PACRG 0x48,
  PACRH 0x4C,
  PACRI 0x50,
  PACRJ 0x54,
  PACRK 0x58,
  PACRL 0x5C,
  PACRM 0x60,
  PACRN 0x64,
  PACRO 0x68,
  PACRP 0x6C
  $uint32 {
   1, SP0, WP0, TP0,
   1, SP1, WP1, TP1,
   1, SP2, WP2, TP2,
   1, SP3, WP3, TP3,
   1, SP4, WP4, TP4,
   1, SP5, WP5, TP5,
   1, SP6, WP6, TP6,
   1, SP7, WP7, TP7
  }
}
//registers ARM_DEMCR   0xE000EDFC // Debug Exception and Monitor Control
//registers ARM_DEMCR_TRCENA  (1 << 24)  // Enable debugging & monitoring blocks
//registers ARM_DWT_CTRL   0xE0001000 // DWT control register
//registers ARM_DWT_CTRL_CYCCNTENA  (1 << 0)  // Enable cycle count
//registers ARM_DWT_CYCCNT   0xE0001004 // Cycle count register
