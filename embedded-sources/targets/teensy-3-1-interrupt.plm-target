newUnsignedRepresentation @unsigned8  : "uint8_t"   8
newUnsignedRepresentation @unsigned16 : "uint16_t" 16
newUnsignedRepresentation @unsigned32 : "uint32_t" 32
newUnsignedRepresentation @unsigned64 : "uint64_t" 64

newSignedRepresentation @signed8  : "int8_t"   8
newSignedRepresentation @signed16 : "int16_t" 16
newSignedRepresentation @signed32 : "int32_t" 32
newSignedRepresentation @signed64 : "int64_t" 64

newUnsignedRepresentation @size : "uint32_t" 32

booleanType $bool : @unsigned8

newIntegerType $uint8  : @unsigned8
newIntegerType $uint16 : @unsigned16
newIntegerType $uint32 : @unsigned32
newIntegerType $uint64 : @unsigned64
newIntegerType $int8  : @signed8
newIntegerType $int16 : @signed16
newIntegerType $int32 : @signed32
newIntegerType $int64 : @signed64

exception : $int32 $uint32

mode `isr
mode `user

import "files/mk20dx256.plm"
import "files/lcd.plm"
import "files/leds.plm"
import "files/default-isr.plm"

required proc setup `user ()
required proc loop `user ()

boot 10 {
//---------1- Inhiber le chien de garde
  WDOG_UNLOCK = WDOG_UNLOCK_SEQ1
  WDOG_UNLOCK = WDOG_UNLOCK_SEQ2
  WDOG_STCTRLH = 0x0010
//--- Enable clocks to always-used peripherals
  SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2
  SIM_SCGC5 = 0x00043F82    // clocks active to all GPIO
  SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL
//--- If the RTC oscillator isn't enabled, get it started early
  if not RTC_CR.OSCE.bool then
    RTC_SR = 0
    RTC_CR = RTC_CR::SC16P | RTC_CR::SC4P | RTC_CR::OSCE
  end
//--- Release I/O pins hold, if we woke up from VLLS mode
  if PMC_REGSC.ACKISO != 0 then
    PMC_REGSC |= PMC_REGSC::ACKISO
  end
// TODO: do this while the PLL is waiting to lock....
  VTOR = 0  // use vector table in flash
//  // default all interrupts to medium priority level
////  for (int32_t i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
//---------2- Initialisation de la PLL
// start in FEI mode
//--- Enable capacitors for crystal
  OSC_CR = OSC_CR::SC8P | OSC_CR::SC2P
//--- Enable osc, 8-32 MHz range, low power mode
  MCG_C2 = MCG_C2::RANGE0(2) | MCG_C2::EREFS
//--- Switch to crystal as clock source, FLL input = 16 MHz / 512
  MCG_C1 = MCG_C1::CLKS(2) | MCG_C1::FRDIV(4)
//--- Wait for crystal oscillator to begin
  while MCG_S.OSCINIT0 == 0 do
  end
//--- Wait for FLL to use oscillator
  while MCG_S.IREFST != 0 do
  end
//--- Wait for MCGOUT to use oscillator
  while MCG_S.CLKST != MCG_S::CLKST(2) do
  end
//--- Now we're in FBE mode
//    Config PLL input for 16 MHz Crystal / 4 = 4 MHz
  MCG_C5 = MCG_C5::PRDIV0(3)
//--- Config PLL for 96 MHz output
  MCG_C6 = MCG_C6::PLLS | MCG_C6::VDIV0(0)
//--- Wait for PLL to start using xtal as its input
  while MCG_S.PLLST == 0 do
  end
//--- Wait for PLL to lock
  while MCG_S.LOCK0 == 0 do
  end
//--- Now we're in PBE mode
//    Config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash
  SIM_CLKDIV1 = SIM_CLKDIV1::OUTDIV1(0) | SIM_CLKDIV1::OUTDIV2(1) | SIM_CLKDIV1::OUTDIV4(3)
//--- Switch to PLL as clock source, FLL input = 16 MHz / 512
  MCG_C1 = MCG_C1::CLKS(0) | MCG_C1::FRDIV(4)
//--- Wait for PLL clock to be used
  while MCG_S.CLKST != MCG_S::CLKST(3) do
  end
}

