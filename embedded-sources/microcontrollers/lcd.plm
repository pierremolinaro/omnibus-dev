
// http://esd.cs.ucr.edu/labs/interface/interface.html

//-----------------------------------------------------------------------------*
//   PORT CONFIGURATION                                                        *
//-----------------------------------------------------------------------------*

//   D4 : PTB0
//   D5 : PTC0
//   D6 : PTD1
//   D7 : PTB2
//   RS : PTB3
//   E  : PTB1

//-----------------------------------------------------------------------------*

proc $init configurePorts () {
//--- D4 (PTB0) is a GPIO (input by default)
  PORTB_PCR0 = (1 << 8) ;
  GPIOB_PDDR |= (1 << 0) ; // Program D4 as output (PTB0)
//--- D5 (PTC0) is a GPIO (input by default)
  PORTC_PCR0 = (1 << 8) ;
  GPIOC_PDDR |= (1 << 0) ; // Program D5 as output (PTC0)
//--- D6 (PTD1) is a GPIO (input by default)
  PORTD_PCR1 = (1 << 8) ;
  GPIOD_PDDR |= (1 << 1) ; // Program D6 as output (PTD1)
//--- D7 (PTB2) is a GPIO (input by default)
  PORTB_PCR2 = (1 << 8) ;
  GPIOB_PDDR |= (1 << 2) ; // Program D7 as output (PTB2)
//--- RS (PTB3) is an output
  PORTB_PCR3 = (1 << 8) ;
  GPIOB_PDDR |= (1 << 3) ;
//--- E (PTB1) is an output
  PORTB_PCR1 = (1 << 8) ;
  GPIOB_PDDR |= (1 << 1) ;
}

//-----------------------------------------------------------------------------*

proc $init $exception $user driveHighE () {
  GPIOB_PSOR = 1 << 1 ; // E is PTB1
}

//-----------------------------------------------------------------------------*


proc $init $exception $user driveLowE () {
  GPIOB_PCOR = 1 << 1 ; // E is PTB1
}

//-----------------------------------------------------------------------------*


proc $init $exception $user driveHighRS () {
  GPIOB_PSOR = 1 << 3 ; // RS is PTB3
}

//-----------------------------------------------------------------------------*


proc $init $exception $user driveLowRS () {
  GPIOB_PCOR = 1 << 3 ; // RS is PTB3
}

//-----------------------------------------------------------------------------*

proc $init $exception $user setD4 (?inValue : Bool) { // PTB0
  if inValue then
    GPIOB_PSOR = 1 << 0 ;
  else
    GPIOB_PCOR = 1 << 0 ;
  end
}

//-----------------------------------------------------------------------------*

proc $init $exception $user setD5 (?inValue : Bool) { // PTC0
  if inValue then
    GPIOC_PSOR = 1 << 0 ;
  else
    GPIOC_PCOR = 1 << 0 ;
  end
}

//-----------------------------------------------------------------------------*

proc $init $exception $user setD6 (?inValue : Bool) { // PTD1
  if inValue then
    GPIOD_PSOR = 1 << 1 ;
  else
    GPIOD_PCOR = 1 << 1 ;
  end
}

//-----------------------------------------------------------------------------*

proc $init $exception $user setD7 (?inValue : Bool) { // PTB2
  if inValue then
    GPIOB_PSOR = 1 << 2 ;
  else
    GPIOB_PCOR = 1 << 2 ;
  end
}

//-----------------------------------------------------------------------------*
//   UTILITY ROUTINES                                                          *
//-----------------------------------------------------------------------------*

proc $init busyWaitingDuringMS (?inDuration : UInt32) {
  let deadline = gCompteur + inDuration
  while gCompteur < deadline do
  end
}

//-----------------------------------------------------------------------------*

proc $init programLcd4BitDataBusOutput (?inValue : UInt8) {
  setD4 (!(inValue & 0x01) != 0)
  setD5 (!(inValue & 0x02) != 0)
  setD6 (!(inValue & 0x04) != 0)
  setD7 (!(inValue & 0x08) != 0)
}

//-----------------------------------------------------------------------------*

proc $init write4BitCommand (?inValue : UInt8) {
  busyWaitingDuringMS (!1) ;
  driveLowRS () ;
  programLcd4BitDataBusOutput (!inValue) ;
  driveHighE () ;
  busyWaitingDuringMS (!1) ;
  driveLowE () ;
}

//-----------------------------------------------------------------------------*

proc $init write8bitCommand (?inCommand : UInt8) {
  busyWaitingDuringMS (!1) ;
  driveLowRS () ;
  programLcd4BitDataBusOutput (!inCommand >> 4) ;
  driveHighE () ;
  busyWaitingDuringMS (!1) ;
  driveLowE () ;
  busyWaitingDuringMS (!1) ;
  programLcd4BitDataBusOutput (!inCommand) ;
  driveHighE () ;
  busyWaitingDuringMS (!1) ;
  driveLowE () ;
}

//-----------------------------------------------------------------------------*
//   LCD INIT                                                                  *
//-----------------------------------------------------------------------------*

init {
  configurePorts () ;
//--- Étape 1 : attendre 15 ms
  busyWaitingDuringMS (!15) ;
//--- Étape 2 : écrire la commande 0x30
  write4BitCommand (!0x3) ;
//--- Étape 3 : attendre 4,1 ms (en fait 5 ms)
  busyWaitingDuringMS (!5) ;
//--- Étape 4 : écrire la commande 0x30 une 2e fois
  write4BitCommand (!0x3) ;
//--- Étape 5 : attendre 100 µs
  busyWaitingDuringMS (!1) ;
//--- Étape 6 : écrire la commande 0x30 une 3e fois
  write4BitCommand (!0x3) ;
//--- Étape 7 : écrire la commande 0x20 pour passer en 4 bits
  write4BitCommand (!0x2) ;
//--- Étape 8 : écrire la commande 'Set Interface Length' : 0 0 1 DL N F * *
//    DL : Data interface length : 0 (4 bits)
//    N : Number of Display lines : 1 (2 lignes)
//    F : Character Font : 0 (5x7)
  write8bitCommand (!0x28) ;
//--- Étape 9 : écrire la commande 'Display Off'
  write8bitCommand (!0x08) ;
//--- Étape 10 : écrire la commande 'Clear Display'
  write8bitCommand (!0x01) ;
//--- Étape 11 : écrire la commande 'Set Cursor Move Direction' : 0 0 0 0 0 1 ID S
//    ID : Increment Cursor after Each Byte Written to Display : 1 (oui)
//    S : Shift Display When Byte Written : 0 (non)
  write8bitCommand (!0x06) ;
//--- Étape 12 : écrire la commande 'Move Cursor / Shift Display' : 0 0 0 1 SC RL * *
//    SC : Display Shift On : 1 (oui)
//    RL : Direction of Shift : 1 (vers la droite)
  write8bitCommand (!0x1C) ;
//--- Étape 13 : écrire la commande 'Return Cursor and LCD to Home Position'
  write8bitCommand (!0x02) ;
//--- Étape 14 : écrire la commande 'Enable Display / Cursor' : 0 0 0 0 1 D C B
//    D : Turn Display On : 1 (oui)
//    C : Turn Cursor On : 0 (non)
//    B : Cursor Blink On : 0 (non)
  write8bitCommand (!0x0C) ;
}

//-----------------------------------------------------------------------------*
//   PRINT ROUTINES IN USER MODE                                               *
//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused programLcd4BitDataBusOutput_inUserMode (?inValue : UInt8) {
  setD4 (!(inValue & 0x01) != 0)
  setD5 (!(inValue & 0x02) != 0)
  setD6 (!(inValue & 0x04) != 0)
  setD7 (!(inValue & 0x08) != 0)
}

//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused write8bitCommand_inUserMode (?inCommand : UInt8) {
  waitMS (!1) ;
  driveLowRS () ;
  programLcd4BitDataBusOutput_inUserMode (!inCommand >> 4) ;
  driveHighE () ;
  waitMS (!1) ;
  driveLowE () ;
  waitMS (!1) ;
  programLcd4BitDataBusOutput_inUserMode (!inCommand) ;
  driveHighE () ;
  waitMS (!1) ;
  driveLowE () ;
}

//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused writeData_inUserMode (?inData : UInt8) {
  waitMS (!1) ;
  driveHighRS () ;
  programLcd4BitDataBusOutput_inUserMode (!inData >> 4) ;
  driveHighE () ;
  waitMS (!1) ;
  driveLowE () ;
  waitMS (!1) ;
  programLcd4BitDataBusOutput_inUserMode (!inData) ;
  driveHighE () ;
  waitMS (!1) ;
  driveLowE () ;
}

//-----------------------------------------------------------------------------*

// Line 0 : 00 -> 19
// Line 1 : 64 -> 83
// Line 2 : 20 -> 39
// Line 3 : 84 -> 103

proc $user @noWarningIfUnused goto (?line:inLine : UInt32 ?column:inColumn : UInt8) {
  if inColumn < 20 then
    if inLine == 0 then
      write8bitCommand_inUserMode (!0x80 + 0 + inColumn) ;
    elsif inLine == 1 then
      write8bitCommand_inUserMode (!0x80 + 64 + inColumn) ;
    elsif inLine == 2 then
      write8bitCommand_inUserMode (!0x80 + 20 + inColumn) ;
    elsif inLine == 3 then
      write8bitCommand_inUserMode (!0x80 + 84 + inColumn) ;
    end
  end
}

//-----------------------------------------------------------------------------*

//void printString (const char * inString) {
//  if (NULL != inString) {
//    while ('\0' != *inString) {
//      writeData (*inString) ;
//      inString ++ ;
//    }
//  }
//}

//-----------------------------------------------------------------------------*

//void printChar (const char inChar) {
//  writeData (inChar) ;
//}

//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused clearScreen () {
  write8bitCommand_inUserMode (!0x01)
}

//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused printSpaces (?inCount : UInt32) {
  var count = inCount
  while (count > 0) do
    writeData_inUserMode (!0x20)
    count -- ;
  end
}

//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused printUnsigned (?inValue : UInt32) {
  if inValue > 9 then
    printUnsigned (!inValue / 10)
  end
  writeData_inUserMode (!0x30 + ((inValue % 10) &\ UInt8))
}

//-----------------------------------------------------------------------------*

proc $user @noWarningIfUnused printSigned (?inValue : Int32) {
  if inValue >= 0 then
    printUnsigned (!inValue &\ UInt32)
  else
    writeData_inUserMode (!0x2D) // Signe -
    printUnsigned (!(- inValue) &\ UInt32)
  end
}

//-----------------------------------------------------------------------------*

//void printSigned (const int32_t inValue) {
//  if (inValue < 0) {
//    printChar ('-') ;
//    printUnsigned ((uint32_t) -inValue) ;
//  }else{
//    printUnsigned ((uint32_t) inValue) ;
//  }
//}

//-----------------------------------------------------------------------------*

//void printHex1 (const uint32_t inValue) {
//  const uint32_t v = inValue & 0xF ;
//  if (v < 10) {
//    printChar ('0' + v) ;
//  }else{
//    printChar ('A' + v - 10) ;
//  }  
//}

//-----------------------------------------------------------------------------*

//void printHex2 (const uint32_t inValue) {
//  printHex1 (inValue >> 4) ;
//  printHex1 (inValue) ;
//}

//-----------------------------------------------------------------------------*

//void printHex4 (const uint32_t inValue) {
//  printHex2 (inValue >> 8) ;
//  printHex2 (inValue) ;
//}

//-----------------------------------------------------------------------------*


//void printHex8 (const uint32_t inValue) {
//  printHex4 (inValue >> 16) ;
//  printHex4 (inValue) ;
//}

//-----------------------------------------------------------------------------*

//void printHex16 (const uint64_t inValue) {
//  printHex8 ((uint32_t) (inValue >> 32)) ;
//  printHex8 ((uint32_t) inValue) ;
//}

//-----------------------------------------------------------------------------*
//   EXCEPTION                                                                 *
//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused programLcd4BitDataBusOutput_inExceptionMode (?inValue : UInt8) {
  setD4 (!(inValue & 0x01) != 0)
  setD5 (!(inValue & 0x02) != 0)
  setD6 (!(inValue & 0x04) != 0)
  setD7 (!(inValue & 0x08) != 0)
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused waitOneMillisecondInExceptionMode () {
  while not SYST_CSR.COUNTFLAG.bool do
  end
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused waitMSInExceptionMode (?duration: inDuration : UInt32) {
  var duration = inDuration
  while duration > 0 do
    waitOneMillisecondInExceptionMode ()
    duration &--
  end
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused writeDataInExceptionMode (?inData : UInt8) {
  waitOneMillisecondInExceptionMode () ;
  driveHighRS () ;
  programLcd4BitDataBusOutput_inExceptionMode (!inData >> 4) ;
  driveHighE () ;
  waitOneMillisecondInExceptionMode () ;
  driveLowE () ;
  waitOneMillisecondInExceptionMode () ;
  programLcd4BitDataBusOutput_inExceptionMode (!inData) ;
  driveHighE () ;
  waitOneMillisecondInExceptionMode () ;
  driveLowE () ;
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused printUnsignedInExceptionMode (?inValue : UInt32) {
  if inValue > 9 then
    printUnsignedInExceptionMode (!inValue &/ 10)
  end
  writeDataInExceptionMode (!0x30 &+ ((inValue &% 10) &\ UInt8))
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused write8bitCommand_inExceptionMode (?inCommand : UInt8) {
  waitOneMillisecondInExceptionMode () ;
  driveLowRS () ;
  programLcd4BitDataBusOutput_inExceptionMode (!inCommand >> 4) ;
  driveHighE () ;
  waitOneMillisecondInExceptionMode () ;
  driveLowE () ;
  waitOneMillisecondInExceptionMode () ;
  programLcd4BitDataBusOutput_inExceptionMode (!inCommand) ;
  driveHighE () ;
  waitOneMillisecondInExceptionMode () ;
  driveLowE () ;
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused gotoInExceptionMode (?line:inLine : UInt32 ?column:inColumn : UInt8) {
  if inColumn < 20 then
    if inLine == 0 then
      write8bitCommand_inExceptionMode (!0x80 &+ 0 &+ inColumn) ;
    elsif inLine == 1 then
      write8bitCommand_inExceptionMode (!0x80 &+ 64 &+ inColumn) ;
    elsif inLine == 2 then
      write8bitCommand_inExceptionMode (!0x80 &+ 20 &+ inColumn) ;
    elsif inLine == 3 then
      write8bitCommand_inExceptionMode (!0x80 &+ 84 &+ inColumn) ;
    end
  end
}

//-----------------------------------------------------------------------------*

proc $exception @noWarningIfUnused clearScreenInExceptionMode () {
  write8bitCommand_inExceptionMode (!0x01)
}

//-----------------------------------------------------------------------------*

exception {
  clearScreenInExceptionMode ()
  waitMSInExceptionMode (!duration:4)
  gotoInExceptionMode (!line:0 !column:0)
  printUnsignedInExceptionMode (!CODE)
  gotoInExceptionMode (!line:1 !column:0)
  printUnsignedInExceptionMode (!LINE)
  forever
    waitMSInExceptionMode (!duration:50)
    ledOn (!LED_L0 | LED_L1 | LED_L2 | LED_L3 | LED_L4 | LED_TEENSY)
    waitMSInExceptionMode (!duration:50)
    ledOff (!LED_L0 | LED_L1 | LED_L2 | LED_L3 | LED_L4 | LED_TEENSY)
    SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ
  end
}

//-----------------------------------------------------------------------------*

