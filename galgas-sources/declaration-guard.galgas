#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardKind {
  case baseGuard
  case convenienceGuard (@callInstructionAST base)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @guardDeclarationListAST {
  @lstring mGuardName
  @bool mIsPublic
  @lstringlist mGuardAttributeList
  @routineFormalArgumentListAST mGuardFormalArgumentList
  @guardKind mGuardKind
  @instructionListAST mGuardInstructionList
  @location mEndOfGuardDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <guard> ?!@ast ioAST ?!@guardDeclarationListAST ioGuardList {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $guard$
    $identifier$ ?let guardName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?let guardFormalArgumentList
    @guardKind guardKind
    select
      guardKind = .baseGuard
    or
      $:$
      <procedure_call> !?ioAST ?let instruction
      guardKind = .convenienceGuard {!base:instruction}
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioGuardList +=
      !guardName
      !public
      !attributeList
      !guardFormalArgumentList
      !guardKind
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mGuardFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    [mGuardInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   UTILITIES                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmNameForGuardImplementation ?let @string inName -> @string {
  result = ["guard.implementation." + inName assemblerRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmNameForGuardCall ?let @string inName -> @string {
  result = ["guard.user." + inName assemblerRepresentation]
}

#·······················································································································

#func guardUserMangledNameFromAST ?let @string inReceiverTypeName
#                                 ?let @lstring inGuardName
#                                 ?let @routineFormalArgumentListAST inFormalArgumentList -> @lstring
#{
#  var s = "guard.call.func."
#  if inReceiverTypeName != "" then
#    s += inReceiverTypeName + "."
#  end
#  s += inGuardName.string
#  s += "("
#  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
#    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
#  end
#  s += ")"
#  result = .new {!s !inGuardName.location}
#}

#·······················································································································

#func guardUserMangledNameFromCall ?let @string inReceiverTypeName
#                                  ?let @lstring inGuardName
#                                  ?let @effectiveArgumentListAST inEffectiveParameterList-> @lstring
#{
#  var s = "guard.user.func."
#  if inReceiverTypeName != "" then
#    s += inReceiverTypeName + "."
#  end
#  s += inGuardName.string
#  s += "("
#  for (passingMode selector) in inEffectiveParameterList do
#    s += [passingMode matchingFormalArgument] + selector + ":"
#  end
#  s += ")"
#  result = .new {!s !inGuardName.location}
#}

#·······················································································································

#func guardImplementationMangledNameFromAST ?let @string inReceiverTypeName
#                                           ?let @lstring inGuardName
#                                           ?let @routineFormalArgumentListAST inFormalArgumentList -> @lstring
#{
#  var s = "guard."
#  if inReceiverTypeName != "" then
#    s += inReceiverTypeName + "."
#  end
#  s += inGuardName.string
#  s += "("
#  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
#    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
#  end
#  s += ")"
#  result = .new {!s !inGuardName.location}
#}

#·······················································································································

#func guardImplementationMangledNameFromCall ?let @string inReceiverTypeName
#                                            ?let @lstring inGuardName
#                                            ?let @effectiveArgumentListAST inEffectiveParameterList-> @lstring
#{
#  var s = "guard."
#  if inReceiverTypeName != "" then
#    s += inReceiverTypeName + "."
#  end
#  s += inGuardName.string
#  s += "("
#  for (passingMode selector) in inEffectiveParameterList do
#    s += [passingMode matchingFormalArgument] + selector + ":"
#  end
#  s += ")"
#  result = .new {!s !inGuardName.location}
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   CONTEXT                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for guard in self do
  #--- Guard mangled name
    let guardMangledName = routineMangledNameFromAST (
      !inReceiverTypeName 
      !guard.mGuardName
      !guard.mGuardFormalArgumentList
    )
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !guard.mGuardFormalArgumentList ?let signature)
  #--- Enter in context
    [!?ioContext.mGuardMapForContext insertKey
      !guardMangledName
      !guard.mIsPublic
      !signature
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST guardSemanticAnalysis
  ?receiverType:@PLMType inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for guard in self do
    var warnIfUnused = true
    for (attribute) in guard.mGuardAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicate @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      else
        error attribute : "unknown attribute; available attribute is @" + noUnusedWarningAttribute ()
      end
    end
    guardSemanticAnalysis (
      !receiverType:inReceiverType
      !guard.mGuardName
      !guard.mGuardFormalArgumentList
      !guard.mGuardKind
      !guard.mGuardInstructionList
      !guard.mEndOfGuardDeclaration
      !warnIfUnused:warnIfUnused
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc guardSemanticAnalysis
  ?receiverType:let @PLMType inSelfType
  ?let @lstring inRoutineName
  ?let @routineFormalArgumentListAST inRoutineFormalArgumentList
  ?let @guardKind inGuardKind
  ?let @instructionListAST inRoutineInstructionList
  ?let @location inEndOfRoutineDeclaration
  ?warnIfUnused:let @bool inWarnIfUnused
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Guard mangled name
  let guardMangledName = routineMangledNameFromAST (
    !if inSelfType.kind == .void then "" else inSelfType.plmTypeDescriptionName end
    !inRoutineName
    !inRoutineFormalArgumentList
  )
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
  @routineFormalArgumentListIR formalArguments = {}
  @guardKindGenerationIR convenienceGuardGenerationIR
  @allocaList allocaList = {}
  @instructionListIR instructionGenerationList = {}
  switch inGuardKind
  case baseGuard :
  #--- Add 'accept" output variable
    let resultVarName = @lstring.new {!acceptVariablePLMName() !inRoutineName.location}
    [inContext.mTypeMap searchKey !lkey:[boolTypeName () nowhere] ?type:let resultType ?2*]
    allocaList += !llvmNameForLocalVariable (!resultVarName.string) !resultType !false
    [!?universalMap insertLocalVariable
      !resultVarName
      !resultType
      !resultVarName
      !.noValue
      !true
    ]
  #--- Analyse formal arguments
    enterFormalArguments (
      !context:inContext
      !inRoutineFormalArgumentList
      !?universalMap
      !?formalArguments
    )
    convenienceGuardGenerationIR = .baseGuard
  #--- Analyze instruction list
    [inRoutineInstructionList analyzeRoutineInstructionList
      !self:inSelfType
      !routineAttributes:.mutating | .directPropertyAccess | .panicAllowed
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !mode:.guardMode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
      !?variableMap:universalMap
      !?alloca:allocaList
      !?generatedCode:instructionGenerationList
    ]
  case convenienceGuard (baseGuardInstruction):
  #--- Analyse formal arguments
    enterFormalArguments (
      !context:inContext
      !inRoutineFormalArgumentList
      !?universalMap
      !?formalArguments
    )
  #--- Analyze base guard
    [baseGuardInstruction baseGuardAnalyze 
      !self:inSelfType
      !routineAttributes:.mutating | .directPropertyAccess
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !mode:.serviceMode # Convenience guards instructions are executed in service mode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
      !?variableMap:universalMap
      ?convenienceGuardGenerationIR
    ]
  #--- Analyze instruction list
    [inRoutineInstructionList analyzeRoutineInstructionList
      !self:inSelfType
      !routineAttributes: .mutating | .directPropertyAccess | .panicAllowed
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !mode:.serviceMode # Convenience guards instructions are executed in service mode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
      !?variableMap:universalMap
      !?alloca:allocaList
      !?generatedCode:instructionGenerationList
    ]
  end 
#--- End of variableMap
  [universalMap checkLocalVariableFinalState !?instructionGenerationList]
  [!?universalMap closeBranch !inEndOfRoutineDeclaration]
  [!?universalMap closeOverride !inEndOfRoutineDeclaration]
#--- Code generation
  ioIntermediateCodeStruct.mGuardListIR +=
    !guardMangledName
    !formalArguments
    !inSelfType
    !convenienceGuardGenerationIR
    !allocaList
    !instructionGenerationList
    !inWarnIfUnused
  ioIntermediateCodeStruct.mRoutineListIR += !@guardUserRoutineIR.new {
    !.new {!llvmNameForGuardCall (!guardMangledName) !guardMangledName}
    !false # Is not root
    !inWarnIfUnused
    !llvmNameForGuardImplementation (!guardMangledName)
    !formalArguments
    !inSelfType
    !convenienceGuardGenerationIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @callInstructionAST baseGuardAnalyze
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standAloneProcedureCallInstructionAST baseGuardAnalyze
  ?self:let @PLMType unused inSelfType
  ?routineAttributes:let @routineAttributes unused inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring unused inCallerNameForInvocationGraph
  ?context:let @semanticContext unused inContext
  ?mode:let @mode unused inMode
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap unused ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
  error mSandAloneRoutineName : "NOT HANDLED YET" : outConvenienceGuardGenerationIR
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procedureCallInstructionAST baseGuardAnalyze
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
  @allocaList baseGuardAllocaList = {}
  @instructionListIR baseGuardInstructionGenerationList = {}
#--- Analyze header identifier : it a variable, as a standalone procedure call is handler otherwise
  @objectIR currentObject
  if mIdentifier.string == "" then # Receiver is self
    if inSelfType.kind == .void then
      error mIdentifier : "self is not available in this context" : currentObject
    else
      currentObject = .reference {!type:inSelfType !llvmName:llvmNameForSelf ()}
    end
  else
    [ioUniversalMap searchValuedObject
      !mIdentifier
      !inRoutineAttributes
      !ioTemporaries.mInitializedDriverSet
      ?currentObject
    ]
  end
  var currentErrorLocation = mIdentifier.location
#--- Insulate last access
  var accessList = mAccessList
  [!?accessList popLast ?let lastAccess]
#---- Loop on access list
  for (access) in accessList do
    let currentType = [currentObject type]
    switch access
    case property (@lstring propertyName) :
      let @propertyMap propertyMap = currentType.propertyMap
      [propertyMap searchKey !propertyName ?* ?let propertyAccess]
      switch propertyAccess
      case nonVirtualMethod (*) :
        error propertyName : "a method cannot be used in this context" : currentObject
      case constantProperty (*) :
        error propertyName: "a constant property not available in this context" : currentObject
      case singleton  (object *) :
        currentObject = object
      case indexed (@PLMType propertyType @uint propertyIndex) :
        [!?ioTemporaries newTempLLVMVar ?let property_llvmName]
        [!?baseGuardInstructionGenerationList appendGetUniversalPropertyReference
          !currentType
          ![currentObject llvmName]
          !property_llvmName
          !propertyIndex
          !propertyName
        ]
        currentObject = .reference {!type:propertyType !llvmName:property_llvmName}
      end
    case arrayAccess (@expressionAST unused indexExpression @location endOfIndex) :
      error endOfIndex : "not handled yet" : currentObject
    end
  end
#--- Handle last access
  switch lastAccess
  case property (@lstring methodName) :
    let currentType = [currentObject type]
    let @propertyMap propertyMap = currentType.propertyMap
    let key = routineMangledNameFromCall (!currentType.llvmBaseTypeName !methodName !mArguments)
    [propertyMap searchKey !key ?* ?let @propertyAccessKind propertyAccess]
    switch propertyAccess
    case singleton  (* errorLocation) :
      error errorLocation : "a property cannot be used as method" : outConvenienceGuardGenerationIR
    case constantProperty (*) :
      error methodName : "a constant cannot be used as method" : outConvenienceGuardGenerationIR
    case indexed (* *) :
      error methodName : "a property cannot be used as method" : outConvenienceGuardGenerationIR
    case nonVirtualMethod (@routineDescriptor routineDescriptor) :
    #--- Add receiver as first parameter
      @procCallEffectiveParameterListIR effectiveParameterListIR = {
        !.outputInput
        !.reference {!type:currentType !llvmName:[currentObject llvmName]}
      }
    #---
    #  let isPublic = routineDescriptor.mIsPublic
#      let routineKind = routineDescriptor.routineKind
#      let calleeMode = [routineKind executionMode]
      let formalSignature = routineDescriptor.signature
    #--- Check routine is actually a procedure (does not return any value)
      if routineDescriptor.returnTypeProxy != .null then
        error methodName : "not a procedure (returns a value)" : outConvenienceGuardGenerationIR
      else
      #--- Check modes
#        let calleeKind = checkMode (
#          !callerMode:inMode
#          !calleeMode:calleeMode
#          !kind:routineKind
#          !error:methodName.location
#        )
      #--- Analyze effective parameters
        analyzeEffectiveParameters (
          !self:inSelfType
          !routineAttributes:inRoutineAttributes
          !formal:formalSignature
          !effective:mArguments
          !errorLocation:methodName.location
          !callerForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !requiredMode:inMode
          !?temporary:ioTemporaries
          !?staticEntityMap:ioStaticEntityMap
          !?variableMap:ioUniversalMap
          !?alloca:baseGuardAllocaList
          !?instructionListIR:baseGuardInstructionGenerationList
          !?effectiveIR:effectiveParameterListIR
        )
      #--- Get function name and map containing the function definition
        let routineMangledName = routineMangledNameFromCall (!currentType.plmTypeDescriptionName !methodName !mArguments)
      #--- Generate guards
        outConvenienceGuardGenerationIR = .convenienceGuard {
          !baseGuardAllocaList:baseGuardAllocaList
          !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
          !baseGuardMangledName:routineMangledName.string
          !baseGuardEffectiveParameterList:effectiveParameterListIR
        }
      end
    end
  case arrayAccess (* @location endOfIndex) :
    error endOfIndex : "a property access is required here" : outConvenienceGuardGenerationIR
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardKindGenerationIR {
  case baseGuard
  case convenienceGuard (@allocaList baseGuardAllocaList
                         @instructionListIR baseGuardInstructionGenerationList
                         @string baseGuardMangledName
                         @procCallEffectiveParameterListIR baseGuardEffectiveParameterList)
}

#·······················································································································

class @guardUserRoutineIR : @abstractRoutineIR {
  @string mMangledImplementationGuardName
  @routineFormalArgumentListIR mFormalArgumentListForGeneration
  @PLMType mReceiverType
  @guardKindGenerationIR mGuardKindGenerationIR
}

#·······················································································································

override method @guardUserRoutineIR enterAccessibleEntities
   ?!@stringset ioInvokedRoutineSet
   ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioInvokedRoutineSet += !mMangledImplementationGuardName
#  for instruction in mInstructionGenerationList do
#    [instruction.mInstructionGeneration enterAccessibleEntities
#      !?ioInvokedRoutineSet
#      !?ioMaxBranchOfOnInstructions
#    ]
#  end
}

#·······················································································································

override method @guardUserRoutineIR svcDeclarationGeneration
  ?!@primitiveAndServiceIRlist ioPrimitiveAndServiceList
  ?!@sectionIRlist ioSectionList
  ?!@generationAdds unused ioGenerationAdds
{
  switch mGuardKindGenerationIR
  case convenienceGuard (* * * *) :
    ioPrimitiveAndServiceList += !mRoutineMangledName !mMangledImplementationGuardName !false
  case baseGuard :
    ioSectionList +=
      !mRoutineMangledName
      !mMangledImplementationGuardName
      !true # Only invocation from user mode
  end
}

#·······················································································································

override method @guardUserRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string unused ioAssemblerCode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!mRoutineMangledName)
  let prototype = llvmFunctionPrototype (
    !"i1" # Boolean
    !mRoutineMangledName
    !mReceiverType
    !mFormalArgumentListForGeneration
  )
  ioLLVMcode += "declare " + prototype + "\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @guardMapIR {
  @lstring lkey
  @routineFormalArgumentListIR mFormalArgumentListForGeneration
  @PLMType mReceiverType
  @guardKindGenerationIR mGuardKindGenerationIR
  @allocaList mAllocaList
  @instructionListIR mInstructionGenerationList
  @bool mWarnIfUnused
}

#·······················································································································

method @guardMapIR guardCodeGeneration
  ?!@string ioLLVMcode
  ?!@primitiveAndServiceIRlist unused ioPrimitiveAndServiceList
  ?!@sectionIRlist unused ioSectionList
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for guard in self do
    [guard llvmCodeGeneration !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  end
}

#·······················································································································

method @guardMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let guardRoutineName = llvmNameForGuardImplementation (!lkey.string)
  ioLLVMcode += llvmTitleComment (!guardRoutineName)
  ioLLVMcode += "define i1 @" + guardRoutineName + " ("
  let receiverLLVMTypeName = if mReceiverType.kind == .void then
    ""
  else
    [mReceiverType llvmTypeName]
  end
  var first = true
  if receiverLLVMTypeName != "" then
    ioLLVMcode += receiverLLVMTypeName + "* " + llvmNameForSelf ()
    first = false
  end
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
#--- Allocate local variables 
  var allocaList = mAllocaList
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      allocaList += !llvmNameForLocalVariable (!mFormalArgumentName) !mFormalArgumentType !true
    case output, inputOutput :
    end
  end
#--- Allocate local variables 
  [allocaList generateAllocaList !?ioLLVMcode]
#---
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", "
         + llvmType + " * " + llvmNameForLocalVariable (!mFormalArgumentName) + "\n"
    case output, inputOutput :
    end
  end
#--- Declare "accept" variable 
  let accepted_llvmName = llvmNameForLocalVariable (!acceptVariablePLMName ())
  let accepted_llvmName_loaded = llvmNameForLocalVariable (!acceptVariablePLMName () + ".loaded")
#--- Base guard or convenience guard ?
  switch mGuardKindGenerationIR
  case baseGuard :
    let accepted_label = acceptVariablePLMName () + ".guard.accepted"
    let rejected_label = acceptVariablePLMName () + ".guard.rejected"
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  " + accepted_llvmName_loaded + " = load i1, i1* " + accepted_llvmName + "\n"
    ioLLVMcode += "  br i1 " + accepted_llvmName_loaded + ", label %" + accepted_label + ", label %" + rejected_label + "\n\n"
    ioLLVMcode += accepted_label + ":\n"
    ioLLVMcode += "  call void @accept.guard ()\n"
    ioLLVMcode += "  ret i1 true\n\n"
    ioLLVMcode += rejected_label + ":\n"
    ioLLVMcode += "  ret i1 false\n"
    ioLLVMcode += "}\n\n"
  case convenienceGuard (baseGuardAllocaList baseGuardInstructionGenerationList baseGuardMangledName baseGuardEffectiveParameterList) :
    [baseGuardAllocaList generateAllocaList !?ioLLVMcode]
    [baseGuardInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  %invoked.guard.result = call i1 @" + llvmNameForGuardImplementation (!baseGuardMangledName)
    ioLLVMcode += " ("
    for () in baseGuardEffectiveParameterList do
      switch mEffectiveParameterPassingMode
      case input:
        ioLLVMcode += [mParameter llvmTypeName] + "* " + [mParameter llvmName]
      case output:
        ioLLVMcode += [mParameter llvmTypeName] + " " + [mParameter llvmName]
      case outputInput:
        ioLLVMcode += [mParameter llvmTypeName] + "* " + [mParameter llvmName]
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ")\n"
    ioLLVMcode += "  br i1 %invoked.guard.result, label %invoked.guard.acceptation, label %invoked.guard.rejection\n\n"
    ioLLVMcode += "invoked.guard.acceptation:\n"
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret i1 true\n\n"
    ioLLVMcode += "invoked.guard.rejection:\n"
    ioLLVMcode += "  ret i1 false\n"
    ioLLVMcode += "}\n\n"
  end
  ioGenerationAdds.mExternFunctionDeclarationSet += !"void @accept.guard ()"
  ioGenerationAdds.mExternFunctionDeclarationSet += !"i1 @xtr.user.result ()"
}

#·······················································································································

method @guardMapIR-element enterAccessibleEntities
  ?!@stringset ioInvokedRoutineSet
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionGenerationList enterAccessibleEntities !?ioInvokedRoutineSet !?ioMaxBranchOfOnInstructions]
  switch mGuardKindGenerationIR
  case baseGuard :
  case convenienceGuard (* baseGuardInstructionGenerationList * *) :
    [baseGuardInstructionGenerationList enterAccessibleEntities !?ioInvokedRoutineSet !?ioMaxBranchOfOnInstructions]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
