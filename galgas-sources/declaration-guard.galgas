#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardKind {
  case baseGuard
  case convenienceGuard (@callInstructionAST base)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @guardDeclarationListAST {
  @lstring mGuardName
  @bool mIsPublic
  @lstringlist mGuardAttributeList
  @routineFormalArgumentList mGuardFormalArgumentList
  @guardKind mGuardKind
  @instructionListAST mGuardInstructionList
  @location mEndOfGuardDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <guard> ?!@guardDeclarationListAST ioGuardListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $guard$
    $identifier$ ?let guardName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let guardFormalArgumentList
    @guardKind guardKind
    select
      guardKind = .baseGuard
    or
      $:$
      <procedure_call> ?let instruction
      guardKind = .convenienceGuard {!base:instruction}
    end
    ${$
    <instructionList> ?let instructionList
    $}$
    ioGuardListAST +=
      !guardName
      !public
      !attributeList
      !guardFormalArgumentList
      !guardKind
      !instructionList
      !.here
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <guard> !?ioAST.mGuardListAST
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mGuardFormalArgumentList do
      let typeName = llvmRegularTypeMangledNameFromName (!formalArgumentTypeName)
      [!?ioGraph noteNode !typeName]
    end
    [mGuardInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    CONTEXT                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for guard in self do
  #--- Guard mangled name
    let guardMangledName = routineMangledNameFromAST (
      !inReceiverTypeName 
      !guard.mGuardName
      !guard.mGuardFormalArgumentList
    )
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !guard.mGuardFormalArgumentList ?let signature)
  #--- Enter in context
    [!?ioContext.mGuardMapForContext insertKey
      !guardMangledName
      !guard.mIsPublic
      !signature
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST guardSemanticAnalysis
  ?receiverType:@PLMType inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for guard in self do
    var warnIfUnused = true
    for (attribute) in guard.mGuardAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicate @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      else
        error attribute : "unknown attribute; available attribute is @" + noUnusedWarningAttribute ()
      end
    end
    guardSemanticAnalysis (
      !receiverType:inReceiverType
      !guard.mGuardName
      !guard.mGuardFormalArgumentList
      !guard.mGuardKind
      !guard.mGuardInstructionList
      !guard.mEndOfGuardDeclaration
      !warnIfUnused:warnIfUnused
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc guardSemanticAnalysis
  ?receiverType:let @PLMType inSelfType
  ?let @lstring inRoutineName
  ?let @routineFormalArgumentList inRoutineFormalArgumentList
  ?let @guardKind inGuardKind
  ?let @instructionListAST inRoutineInstructionList
  ?let @location unused inEndOfRoutineDeclaration
  ?warnIfUnused:let @bool inWarnIfUnused
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Guard mangled name
  let guardMangledName = routineMangledNameFromAST (
    !if inSelfType == .void then "" else "$" + [inSelfType key] end
    !inRoutineName
    !inRoutineFormalArgumentList
  )
#--- Enter subprogram invocation graph
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !guardMangledName.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !guardMangledName
      !inRoutineName
    ]
  end
#--- Variable map
  initialVariableMap (
    !context:inContext
    !mode:.guardMode
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
#    ?*
    ?@universalPropertyAndRoutineMapForContext universalMap
  )
  @routineFormalArgumentListForGeneration formalArguments = {}
  @guardKindGenerationIR convenienceGuardGenerationIR
  @allocaList allocaList = {}
  @instructionListIR instructionGenerationList = {}
  switch inGuardKind
  case baseGuard :
  #--- Add 'accept" output variable
    let resultVarName = @lstring.new {!acceptVariableName() !inRoutineName.location}
    let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap ![boolTypeName () nowhere]} type]
    allocaList += !resultVarName.string ![resultType llvmTypeName]
    [!?universalMap insertLocalVariable
      !resultVarName
      !resultType
      !resultVarName
      !.noValue
      !true
    ]
  #--- Analyse formal arguments
    enterFormalArguments (
      !context:inContext
      !inRoutineFormalArgumentList
      !?universalMap
      !?formalArguments
    )
    convenienceGuardGenerationIR = .baseGuard
  #--- Analyze instruction list
    [inRoutineInstructionList analyzeRoutineInstructionList
      !self:inSelfType
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !mode:.guardMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
#      !?variableMap:variableMap
      !?variableMap:universalMap
      !?alloca:allocaList
      !?generatedCode:instructionGenerationList
    ]
  case convenienceGuard (baseGuardInstruction):
  #--- Analyse formal arguments
    enterFormalArguments (
      !context:inContext
      !inRoutineFormalArgumentList
#      !?variableMap
      !?universalMap
      !?formalArguments
    )
  #--- Analyze base guard
    [baseGuardInstruction baseGuardAnalyze 
      !self:inSelfType
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !mode:.userMode # Convenience guards instructions are executed in user mode
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
      !?variableMap:universalMap
      ?convenienceGuardGenerationIR
    ]
  #--- Analyze instruction list
    [inRoutineInstructionList analyzeRoutineInstructionList
      !self:inSelfType
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !mode:.userMode # Convenience guards instructions are executed in user mode
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
#      !?variableMap:variableMap
      !?variableMap:universalMap
      !?alloca:allocaList
      !?generatedCode:instructionGenerationList
    ]
  end 
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [universalMap checkLocalVariableFinalState]
#  [variableMap checkAutomatonStates !inEndOfRoutineDeclaration]
#  drop variableMap
#--- Code generation
  [!?ioIntermediateCodeStruct.mGuardMapIR insertKey
    !guardMangledName
    !formalArguments
    !inSelfType
    !convenienceGuardGenerationIR
    !allocaList
    !instructionGenerationList
    !inWarnIfUnused
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @callInstructionAST baseGuardAnalyze
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standAloneProcedureCallInstructionAST baseGuardAnalyze
  ?self:let @PLMType unused inSelfType
  ?routineNameForInvocationGraph:let @lstring unused inCallerNameForInvocationGraph
  ?context:let @semanticContext unused inContext
  ?mode:let @mode unused inMode
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext unused ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
  error mSandAloneRoutineName : "NOT HANDLED YET" : outConvenienceGuardGenerationIR
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallNoSelfInstructionAST baseGuardAnalyze
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
  @allocaList baseGuardAllocaList = {}
  @instructionListIR baseGuardInstructionGenerationList = {}
#--- Analyze header identifier : it a variable, as a standalone procedure call is handler otherwise
  [ioUniversalMap searchValuedObject !mAssignmentTargetAST.mIdentifier ?@objectIR currentObject]
  var currentErrorLocation = mAssignmentTargetAST.mIdentifier.location
  var currentMap = ioUniversalMap
#--- Insulate last access
  var accessList = mAssignmentTargetAST.mAccessList
  [!?accessList popLast ?let lastAccess]
#---- Loop on access list
  for (access) in accessList do
    let currentType = [currentObject type]
    switch access
    case property (@lstring propertyName) :
      if [currentType isStructure] then
        [currentType structure ?2* ?universalMap2:let universalMap ?3*]
        [universalMap searchValuedObject !propertyName ?let propertyObject]
        currentMap = universalMap
        currentErrorLocation = propertyName.location
        getNewTempVariable (![propertyObject type] !propertyName !?ioTemporaries ?let newObject)
        [!?baseGuardInstructionGenerationList appendGetPropertyReference
          !newObject
          !currentObject
          !propertyName
        ]
        currentObject = newObject
      else
        error currentErrorLocation : "this object has no property" :currentObject
      end
    case arrayAccess (@expressionAST unused indexExpression @location endOfIndex) :
      error endOfIndex : "not handled yet" : currentObject
    end
  end
#--- Handle last access
  @lstring methodName
  switch lastAccess
  case property (@lstring propertyName) :
    methodName = propertyName
    let currentType = [currentObject type]
    if [currentType isStructure] then
      [currentType structure ?2* ?universalMap2:let universalMap ?3*]
      currentMap = universalMap
      currentErrorLocation = propertyName.location
    else
      error currentErrorLocation : "this object has no property" : currentObject, methodName
    end
  case arrayAccess (* @location endOfIndex) :
    error endOfIndex : "a property access is required here" : currentObject, methodName
  end
#--- Get function name and map containing the function definition
  let routineMangledName = routineMangledNameFromCall (!"$" + [[currentObject type] key] !methodName !mArguments)
#--- Get called function signature
  let signature = [mArguments routineSignature !methodName.location]
#--- Search function in map
  [currentMap searchRoutine
    !methodName
    !signature
    ?* # let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
  ]
#--- Add receiver as first parameter
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  switch routineDescriptor.mRoutineCallingScheme
  case staticCall :
    effectiveParameterListIR += !.outputInput !currentObject # Add receiver as first argument
  case propertyIndirectCall (*) :
  end
#---
#  let isPublic = routineDescriptor.mIsPublic
#  let routineKind = routineDescriptor.mRoutineKind
#  let calleeMode = [routineKind executionMode]
  let formalSignature = routineDescriptor.mSignature
#--- Check routine is actually a function
  if routineDescriptor.mReturnTypeProxy != .null then
    error methodName : "not a procedure (returns a value)" : routineDescriptor, outConvenienceGuardGenerationIR
  else
  #--- Check modes
#    let calleeKind = checkMode (
#      !callerMode:inMode
#      !calleeMode:calleeMode
#      !kind:routineKind
#      !error:methodName.location
#    )
  #--- Analyze effective parameters
    analyzeEffectiveParametersNew (
      !self:inSelfType
      !formal:formalSignature
      !effective:mArguments
      !errorLocation:methodName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:baseGuardAllocaList
      !?instructionListIR:baseGuardInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- Generate call
    switch routineDescriptor.mRoutineCallingScheme
    case staticCall :
      outConvenienceGuardGenerationIR = .convenienceGuard {
        !baseGuardAllocaList:baseGuardAllocaList
        !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
        !baseGuardMangledName:routineMangledName.string
        !baseGuardEffectiveParameterList:effectiveParameterListIR
      }
    case propertyIndirectCall (*) :
      error .nowhere : "NOT HANDLED YET" : outConvenienceGuardGenerationIR
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallSelfInstructionAST baseGuardAnalyze
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
  @allocaList baseGuardAllocaList = {}
  @instructionListIR baseGuardInstructionGenerationList = {}
#---
  var currentErrorLocation = mAssignmentTargetAST.mSelfLocation
  @objectIR currentObject = .selfObject {!type:inSelfType}
  @universalPropertyAndRoutineMapForContext currentMap = .default
#--- Insulate last access
  var accessList = mAssignmentTargetAST.mAccessList
  [!?accessList insertAtIndex !.property {!name:mAssignmentTargetAST.mIdentifier} !0]
  [!?accessList popLast ?let lastAccess]
#---- Loop on access list
  for (access) in accessList do
    let currentType = [currentObject type]
    switch access
    case property (@lstring propertyName) :
      if [currentType isStructure] then
        [currentType structure ?2* ?universalMap2:let universalMap ?3*]
        [universalMap searchValuedObject !propertyName ?let propertyObject]
        currentMap = universalMap
        currentErrorLocation = propertyName.location
        getNewTempVariable (![propertyObject type] !propertyName !?ioTemporaries ?let newObject)
        [!?baseGuardInstructionGenerationList appendGetPropertyReference
          !newObject
          !currentObject
          !propertyName
        ]
        currentObject = newObject
      else
        error currentErrorLocation : "this object has no property" :currentObject
      end
    case arrayAccess (@expressionAST unused indexExpression @location endOfIndex) :
      error endOfIndex : "not handled yet" : currentObject
    end
  end
#--- Handle last access
  @lstring methodName
  switch lastAccess
  case property (@lstring propertyName) :
    methodName = propertyName
    let currentType = [currentObject type]
    if [currentType isStructure] then
      [currentType structure ?2* ?universalMap2:let universalMap ?3*]
      currentMap = universalMap
      currentErrorLocation = propertyName.location
    else
      error currentErrorLocation : "this object has no property" : currentObject, methodName
    end
  case arrayAccess (* @location endOfIndex) :
    error endOfIndex : "a property access is required here" : currentObject, methodName
  end
#--- Get function name and map containing the function definition
  let routineMangledName = routineMangledNameFromCall (!"$" + [[currentObject type] key] !methodName !mArguments)
#--- Get called function signature
  let signature = [mArguments routineSignature !methodName.location]
#--- Search function in map
  [currentMap searchRoutine
    !methodName
    !signature
    ?* #let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
  ]
#--- Add receiver as first parameter
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  switch routineDescriptor.mRoutineCallingScheme
  case staticCall :
    effectiveParameterListIR += !.outputInput !currentObject # Add receiver as first argument
  case propertyIndirectCall (*) :
  end
#---
#  let isPublic = routineDescriptor.mIsPublic
#  let routineKind = routineDescriptor.mRoutineKind
#  let calleeMode = [routineKind executionMode]
  let formalSignature = routineDescriptor.mSignature
#--- Check routine is actually a function
  if routineDescriptor.mReturnTypeProxy != .null then
    error methodName : "not a procedure (returns a value)" : routineDescriptor, outConvenienceGuardGenerationIR
  else
  #--- Check modes
#    let calleeKind = checkMode (
#      !callerMode:inCurrentMode
#      !calleeMode:calleeMode
#      !kind:routineKind
#      !error:methodName.location
#    )
  #--- Analyze effective parameters
    analyzeEffectiveParametersNew (
      !self:inSelfType
      !formal:formalSignature
      !effective:mArguments
      !errorLocation:methodName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:baseGuardAllocaList
      !?instructionListIR:baseGuardInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- Generate call
    switch routineDescriptor.mRoutineCallingScheme
    case staticCall :
      outConvenienceGuardGenerationIR = .convenienceGuard {
        !baseGuardAllocaList:baseGuardAllocaList
        !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
        !baseGuardMangledName:routineMangledName.string
        !baseGuardEffectiveParameterList:effectiveParameterListIR
      }
    case propertyIndirectCall (*) :
      error .nowhere : "NOT HANDLED YET" : outConvenienceGuardGenerationIR
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardKindGenerationIR {
  case baseGuard
  case convenienceGuard (@allocaList baseGuardAllocaList
                         @instructionListIR baseGuardInstructionGenerationList
                         @string baseGuardMangledName
                         @procCallEffectiveParameterListIR baseGuardEffectiveParameterList)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @guardMapIR {
  @routineFormalArgumentListForGeneration mFormalArgumentListForGeneration
  @PLMType mReceiverType
  @guardKindGenerationIR mGuardKindGenerationIR
  @allocaList mAllocaList
  @instructionListIR mInstructionGenerationList
  @bool mWarnIfUnused

  insert insertKey error message "guard '%K' is already defined"
  search searchKey error message "** internal error **"
  remove removeKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardMapIR guardCodeGeneration
  ?!@string ioLLVMcode
  ?!@2stringlist ioServiceList
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for guard in self do
    switch guard.mGuardKindGenerationIR
    case convenienceGuard (* * * *) :
    case baseGuard :
      let guardImplementationName = llvmNameForGuardImplementation (!guard.lkey.string)
      let guardCallName = llvmNameForGuardCall (!guard.lkey.string)
      ioServiceList += !guardCallName !guardImplementationName
      ioLLVMcode += llvmTitleComment (!guardImplementationName)
      ioLLVMcode += "declare i1 @" + guardCallName + " ("
      let typeName = if guard.mReceiverType == .void then "" else "$" + [guard.mReceiverType key] end
      var first = typeName == ""
      if not first then
        ioLLVMcode += "%" + [typeName assemblerRepresentation] + " * %self"  
      end
      for () in guard.mFormalArgumentListForGeneration do
        if first then first = false else ioLLVMcode += ", " end
        switch mFormalArgumentKind
        case input :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
        case output :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
       case inputOutput :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
        end
      end
      ioLLVMcode += ")" + llvmAttributeFunction () + "\n\n"
    end
    [guard llvmCodeGeneration !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  @string guardRoutineName
  switch mGuardKindGenerationIR
  case convenienceGuard (* * * *) :
    guardRoutineName = llvmNameForGuardCall (!lkey.string)
  case baseGuard :
    guardRoutineName = llvmNameForGuardImplementation (!lkey.string)
  end
  ioLLVMcode += llvmTitleComment (!guardRoutineName)
  ioLLVMcode += "define i1 @" + guardRoutineName + " ("
  let receiverTypeName = if mReceiverType == .void then "" else "$" + [mReceiverType key] end
  var first = true
  if receiverTypeName != "" then
    ioLLVMcode += "%" + [receiverTypeName assemblerRepresentation] + " * %self"
    first = false
  end
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
#--- Allocate local variables 
  for (variable llvmTypeName) in mAllocaList do
    ioLLVMcode += "  " + llvmNameForLocalVariable (!variable) + " = alloca " + llvmTypeName + "\n"
  end
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  " + llvmNameForLocalVariable (!mFormalArgumentName) + " = alloca " + llvmType + "\n"
    case output, inputOutput :
    end
  end
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", "
         + llvmType + " * " + llvmNameForLocalVariable (!mFormalArgumentName) + "\n"
    case output, inputOutput :
    end
  end
#--- Declare "accept" variable 
  let accepted_llvmName = llvmNameForLocalVariable (!acceptVariableName ())
  let accepted_llvmName_loaded = llvmNameForLocalVariable (!acceptVariableName () + ".loaded")
  let accepted_llvmName_true =  acceptVariableName () + ".true"
  let accepted_llvmName_false = acceptVariableName () + ".false"
#--- Base guard or convenience guard ?
  switch mGuardKindGenerationIR
  case baseGuard :
    ioLLVMcode += "  store i1 false, i1* " + accepted_llvmName + "\n"
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  " + accepted_llvmName_loaded + " = load i1, i1* " + accepted_llvmName + "\n"
    ioLLVMcode += "  br i1 " + accepted_llvmName_loaded + ", label %" + accepted_llvmName_true + ", label %" + accepted_llvmName_false + "\n\n"
    ioLLVMcode += accepted_llvmName_true + ":\n"
    ioLLVMcode += "  call void @noteGuardHasBeenAccepted ()\n"
    ioLLVMcode += "  ret i1 true\n\n"
    ioLLVMcode += accepted_llvmName_false + ":\n"
    ioLLVMcode += "  ret i1 false\n"
    ioLLVMcode += "}\n\n"
  case convenienceGuard (baseGuardAllocaList baseGuardInstructionGenerationList baseGuardMangledName baseGuardEffectiveParameterList) :
    for (variable  llvmTypeName) in baseGuardAllocaList do
      ioLLVMcode += "  " + llvmNameForLocalVariable (!variable) + " = alloca " + llvmTypeName + "\n"
    end
    [baseGuardInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  %baseGuard.result = call i1 @" + llvmNameForGuardCall (!baseGuardMangledName)
    ioLLVMcode += " ("
    for () in baseGuardEffectiveParameterList do
      switch mEffectiveParameterPassingMode
      case input:
        ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
      case output:
        ioLLVMcode += [mParameter llvmTypeName] + " " + [mParameter llvmName]
      case outputInput:
        ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ")\n"
    ioLLVMcode += "  br i1 %baseGuard.result, label %baseGuard.true, label %baseGuard.exit\n\n"
    ioLLVMcode += "baseGuard.true:\n"
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret i1 true\n\n"
    ioLLVMcode += "baseGuard.exit:\n"
    ioLLVMcode += "  ret i1 false\n"
    ioLLVMcode += "}\n\n"
  end
  ioGenerationAdds.mExternFunctionDeclarationSet += !"declare void @noteGuardHasBeenAccepted ()\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardMapIR-element enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
  switch mGuardKindGenerationIR
  case baseGuard :
  case convenienceGuard (* baseGuardInstructionGenerationList baseGuardMangledName *) :
    [baseGuardInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
    ioAccessibleEntities.mGuardSet += !baseGuardMangledName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

