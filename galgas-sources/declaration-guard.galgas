#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardKind {
  case baseGuard
  case convenienceGuard (@callInstructionAST base)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @guardDeclarationListAST {
  @lstring mGuardName
  @bool mIsPublic
  @lstringlist mGuardAttributeList
  @procFormalArgumentList mGuardFormalArgumentList
  @guardKind mGuardKind
  @instructionListAST mGuardInstructionList
  @location mEndOfGuardDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <guard> ?!@guardDeclarationListAST ioGuardListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $guard$
    $identifier$ ?let guardName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let guardFormalArgumentList
    @guardKind guardKind
    select
      guardKind = .baseGuard
    or
      $:$
      <procedure_call> ?let instruction
#      <routine_call> ?let unused instructionLocation ?let @abstractCallInstructionAST instruction
      guardKind = .convenienceGuard {!base:instruction}
    end
    ${$
    <instructionList> ?let instructionList !?*
    $}$
    ioGuardListAST +=
      !guardName
      !public
      !attributeList
      !guardFormalArgumentList
      !guardKind
      !instructionList
      !.here
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <guard> !?ioAST.mGuardListAST
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mGuardFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mGuardInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    CONTEXT                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for guard in self do
  #--- Signature
    var guardMangledName = if inReceiverTypeName == "" then
      guard.mGuardName
    else
      @lstring.new {!inReceiverTypeName + "." + guard.mGuardName !guard.mGuardName.location}
    end
    guardMangledName.string += "("
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in guard.mGuardFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
      guardMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
    end
    guardMangledName.string += ")"
  #--- Enter in context
    [!?ioContext.mGuardMapForContext insertKey
      !guardMangledName
      !guard.mIsPublic
      !signature
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardDeclarationListAST guardSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for guard in self do
    var warnIfUnused = true
    for (attribute) in guard.mGuardAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicate @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      else
        error attribute : "unknown attribute; available attribute is @" + noUnusedWarningAttribute ()
      end
    end
    guardSemanticAnalysis (
      !receiverType:inReceiverType
      !guard.mGuardName
      !guard.mGuardFormalArgumentList
      !guard.mGuardKind
      !guard.mGuardInstructionList
      !guard.mEndOfGuardDeclaration
      !warnIfUnused:warnIfUnused
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc guardSemanticAnalysis
  ?receiverType:let @unifiedTypeMap-proxy inSelfType
  ?let @lstring inRoutineName
  ?let @procFormalArgumentList inRoutineFormalArgumentList
  ?let @guardKind inGuardKind
  ?let @instructionListAST inRoutineInstructionList
  ?let @location inEndOfRoutineDeclaration
  ?warnIfUnused:let @bool inWarnIfUnused
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Guard mangled name
  var guardMangledName = if inSelfType == .null then
    inRoutineName
#    @lstring.new {!"." + inRoutineName !inRoutineName.location}
  else
    @lstring.new {!"$" + [inSelfType key] + "." + inRoutineName !inRoutineName.location}
  end
  guardMangledName.string += "("
  for (formalArgumentPassingMode selector * *) in inRoutineFormalArgumentList do
    guardMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  guardMangledName.string += ")"
#--- Enter subprogram invocation graph
#  let routineNameForInvocationGraph = guardNameForInvocationGraph (!inSelfType !inRoutineName)
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !guardMangledName.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !guardMangledName
      !inRoutineName
    ]
  end
#--- Variable map
  initialVariableMap (
    !routineNameForInvocation:guardMangledName.string
    !context:inContext
    !userMode:false
    !registerAccess:.noAccess
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
    ?@variableMap variableMap
    ?@namedObjectMap namedObjectMap
  )
  @procFormalArgumentListForGeneration formalArguments = {}
  @guardKindGenerationIR convenienceGuardGenerationIR
  @allocaList allocaList = {}
  @instructionListIR instructionGenerationList = {}
  switch inGuardKind
  case baseGuard :
  #--- Add 'accept" output variable
    let resultVarName = @lstring.new {!acceptVariableName() !inRoutineName.location}
    let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap ![boolTypeName () nowhere]}
    allocaList += !resultVarName.string !resultType
    [!?variableMap insertOutputFormalArgument
      !lkey:resultVarName
      !type:resultType
      !readAccessAllowed:true
      !variableKin:.localVariable {!type:resultType !name:resultVarName.string !volatile:false}
      !objectIR:.localVariableReference {!type:resultType !plmName:resultVarName.string}
      !copyable:true
      !canBeUsedAsInputParameter:true
    ]
    let resultVariable = @objectIR.localVariableReference {
      !type:resultType
      !plmName:resultVarName
    }
    [!?namedObjectMap insertKey !resultVarName !resultVariable]
  #--- Analyse formal arguments
    enterFormalArguments (
      !context:inContext
      !inRoutineFormalArgumentList
      !?variableMap
      !?namedObjectMap
      !?formalArguments
    )
    convenienceGuardGenerationIR = .baseGuard
  #--- Analyze instruction list
    [inRoutineInstructionList analyzeRoutineInstructionList
      !self:inSelfType
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !modes:{!guardModeName ()}
      !allowPanic:true
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
      !?variableMap:variableMap
      !?namedObjectMap: namedObjectMap
      !?alloca:allocaList
      !?generatedCode:instructionGenerationList
    ]
  case convenienceGuard (baseGuardInstruction):
  #--- Analyse formal arguments
    enterFormalArguments (
      !context:inContext
      !inRoutineFormalArgumentList
      !?variableMap
      !?namedObjectMap
      !?formalArguments
    )
  #--- Analyze base guard
    @instructionListIR baseGuardInstructionGenerationList = {}
    [baseGuardInstruction baseGuardAnalyze 
      !self:inSelfType
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !modes:{!userModeName ()} # Convenience guards instructions are executed in user mode
      !?alloca:allocaList
      !?instructionListIR:instructionGenerationList
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
      !?variableMap:variableMap
      !?namedObjectMap: namedObjectMap
      ?convenienceGuardGenerationIR
    ]
  #--- Analyze instruction list
    [inRoutineInstructionList analyzeRoutineInstructionList
      !self:inSelfType
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !routineNameForInvocationGraph:guardMangledName
      !context:inContext
      !modes:{!userModeName ()} # Convenience guards instructions are executed in user mode
      !allowPanic:true
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
      !?variableMap:variableMap
      !?namedObjectMap: namedObjectMap
      !?alloca:allocaList
      !?generatedCode:instructionGenerationList
    ]
  end 
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [variableMap checkAutomatonStates !inEndOfRoutineDeclaration]
  drop variableMap
#--- Code generation
#  let guardMangledName = if inSelfType == .null then
#    @lstring.new {!"." + inRoutineName !inRoutineName.location}
#  else
#    @lstring.new {!"$" + [inSelfType key] + "." + inRoutineName !inRoutineName.location}
#  end
  [!?ioIntermediateCodeStruct.mGuardMapIR insertKey
    !guardMangledName
    !formalArguments
    !convenienceGuardGenerationIR
    !allocaList
    !instructionGenerationList
    !inWarnIfUnused
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#abstract method @callInstructionAST baseGuardAnalyze
#  ?self:let @unifiedTypeMap-proxy inSelfType
#  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
#  ?context:let @semanticContext inContext
#  ?modes:let @stringset inModeSet
#  ?!alloca:@allocaList ioAllocaList
#  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
#  ?!temporary:@semanticTemporariesStruct ioTemporaries
#  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
#  ?!variableMap:@variableMap ioVariableMap
#  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
#  !@guardKindGenerationIR outConvenienceGuardGenerationIR

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc standaloneBaseGuardAnalyze
  ?routineName:let @lstring inRoutineName
  ?effectiveParameters:let @effectiveParameterListAST inEffectiveParameterList
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
#--- Guard mangled name
  var guardMangledName = inRoutineName
#  var guardMangledName = @lstring.new {!"." + inRoutineName !inRoutineName.location}
  guardMangledName.string += "("
  for (formalArgumentPassingMode selector) in inEffectiveParameterList do
    guardMangledName.string += [formalArgumentPassingMode matchingFormalArgument] + selector + ":"
  end
  guardMangledName.string += ")"
#  let routineMangledName = @lstring.new {!"." + inRoutineName !inRoutineName.location}
  [inContext.mGuardMapForContext searchKey
    !guardMangledName
    ?let isPublic
    ?let @procedureSignature formalSignature
  ]
#--- Check accessibility
  if not isPublic then
    let @string declarationFile = [[inContext.mGuardMapForContext locationForKey !guardMangledName.string] file]
    let invocationFile = [inRoutineName.location file]
    if invocationFile != declarationFile then
      error inRoutineName : "this guard is not public"
    end
  end  
#--- Enter in invocation graph
 # let routineNameForInvocationGraph = guardNameForInvocationGraph (!.null !inRoutineName)
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !guardMangledName]
#--- Analyze effective parameters
  @instructionListIR baseGuardInstructionGenerationList = {}
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  @allocaList baseGuardAllocaList = {}
  analyzeEffectiveParameters (
    !self:inSelfType
    !directAccessToPropertiesAllowed:true
    !propertiesAreMutable:true
    !formal:formalSignature
    !effective:inEffectiveParameterList
    !errorLocation:inRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:{!serviceModeName ()}
    !allowPanic:true
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:baseGuardAllocaList
    !?instructionListIR:baseGuardInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )
#--- Code generation
  outConvenienceGuardGenerationIR = .convenienceGuard {
    !baseGuardAllocaList:baseGuardAllocaList
    !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
    !baseGuardMangledName:guardMangledName.string
    !baseGuardEffectiveParameterList:effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @unifiedSelfCallInstructionAST baseGuardAnalyze
#  ?self:let @unifiedTypeMap-proxy inSelfType
#  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
#  ?context:let @semanticContext inContext
#  ?modes:let @stringset unused inModeSet
#  ?!alloca:@allocaList unused ioAllocaList
#  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
#  ?!temporary:@semanticTemporariesStruct ioTemporaries
#  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
#  ?!variableMap:@variableMap ioVariableMap
#  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
#  !@guardKindGenerationIR outConvenienceGuardGenerationIR
#{
#  if inSelfType == .null then
#    error mSelfLocation : "'self' is not available in this context" : outConvenienceGuardGenerationIR
#  else
#    @unifiedTypeMap-proxy currentType = inSelfType
#    @fieldList propertyList = mFieldList
#    [!?propertyList popLast ?let @lstring methodName ?*]
#    @elementPtrList elementPtrList = {}
#    var needsPublic = false
#    for (propertyName arrayAccess) in propertyList do
#      switch [currentType kind]
#      case opaque (*) :
#        error propertyName : "an opaque type does not handle field access" : currentType
#      case boolean :
#        error propertyName : "a boolean does not handle field access" : currentType
#      case staticInteger :
#        error propertyName : "an integer does not handle field access" : currentType
#      case literalString :
#        error propertyName : "a literal string does not handle field access" : currentType
#      case enumeration (*) :
#        error propertyName : "an enumeration does not handle field access" : currentType
#      case arrayType (* *) :
#        error propertyName : "an array does not handle field access" : currentType
#      case integer (* * * *) :
#        error propertyName : "an integer does not handle field access" : currentType
#      case structure (* @propertyMap unused propertyMap *) :
#        [propertyMap searchKey !propertyName ?let public ?let propertyType ?let idx]
#        elementPtrList += !.absolute {!index:idx} !propertyName.string
#        currentType = propertyType
#        if needsPublic && not public then
#          error propertyName : "this property is not public" : currentType
#        end
#        needsPublic = true
#      end
#    end
#    getLocalNameOfNewTempObjectInMemory (!currentType !?ioTemporaries ?let propertyAddressLLVMvar)
#    @instructionListIR baseGuardInstructionGenerationList = {}
#    [!?baseGuardInstructionGenerationList appendGetElementPtrFromSelf
#      !propertyAddressLLVMvar
#      !inSelfType
#      !elementPtrList
#    ]        
#    var routineMangledName = @lstring.new {!"$" + [currentType key] + "." + methodName !methodName.location}
#    routineMangledName.string += "("
#    for (formalArgumentPassingMode selector) in mEffectiveParameterList do
#      routineMangledName.string += [formalArgumentPassingMode matchingFormalArgument] + selector + ":"
#    end
#    routineMangledName.string += ")"
#    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
#    effectiveParameterListIR += !.outputInput ![propertyAddressLLVMvar address] #--- add "load receiver" as first argument
#    [inContext.mGuardMapForContext searchKey
#      !routineMangledName
#      ?let isPublic
#      ?let @procedureSignature formalSignature
#    ]
#  #--- Accessibility
#    if needsPublic && not isPublic then
#      error methodName : "this guard is not public"
#    end
#  #--- Enter in invocation graph
#    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
#  #--- Analyze effective parameters
#    @allocaList baseGuardAllocaList = {}
#    analyzeEffectiveParameters (
#      !self:inSelfType
#      !directAccessToPropertiesAllowed:true
#      !propertiesAreMutable:true
#      !formal:formalSignature
#      !effective:mEffectiveParameterList
#      !errorLocation:methodName.location
#      !callerForInvocationGraph:inCallerNameForInvocationGraph
#      !context:inContext
#      !requiredModeSet:{!serviceModeName ()}
#      !allowPanic:true
#      !?temporary:ioTemporaries
#      !?staticStringMap:ioGlobalLiteralStringMap
#      !?variableMap:ioVariableMap
#      !?namedObjectMap: ioNamedObjectMap
#      !?alloca:baseGuardAllocaList
#      !?instructionListIR:baseGuardInstructionGenerationList
#      !?effectiveIR:effectiveParameterListIR
#    )
#  #--- Code generation
#    outConvenienceGuardGenerationIR = .convenienceGuard {
#      !baseGuardAllocaList:baseGuardAllocaList
#      !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
#      !baseGuardMangledName:routineMangledName.string
#      !baseGuardEffectiveParameterList:effectiveParameterListIR
#    }
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @callInstructionAST baseGuardAnalyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  !@guardKindGenerationIR outConvenienceGuardGenerationIR
{
  [mAssignmentTargetAST analyzeAssignmentTarget
    !self: inSelfType
    !propertiesAreMutable: false
    !directAccessToPropertiesAllowed: false
    !routineNameForInvocationGraph: inCallerNameForInvocationGraph
    !context: inContext
    !modes: {!guardModeName ()}
    !allowPanic: true
    !?temporary: ioTemporaries
    !?staticStringMap: ioGlobalLiteralStringMap
    !?variableMap: ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?@objectIR currentObject
  ]
#--- Analyze arguments
  if not [currentObject isPossibleFunction] then
    error .nowhere : "object is not a function" : outConvenienceGuardGenerationIR
  else
    [currentObject possibleFunction ?receiver:let receiver ?functionName:let functionName]
    @allocaList baseGuardAllocaList = {}
    @instructionListIR baseGuardInstructionGenerationList = {}
    analyzeFunctionCallInExpression (
      !self:inSelfType
      !propertiesAreMutable:false
      !directAccessToPropertiesAllowed:true
      !receiver:receiver
      !routineName:functionName
      !effective:mArguments
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredModeSet:inModeSet
      !allowPanic:true
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca:baseGuardAllocaList
      !?instructionListIR:baseGuardInstructionGenerationList
      ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
      ?routineKind:let @routineKindIR routineKind
      ?routineMangledName:let @lstring functionMangledName
      ?routineNameForGeneration:let @lstring functionNameForGeneration
      ?returnType:let @unifiedTypeMap-proxy returnedType
      ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
    )
    if returnedType == .null then
      error functionName : "the function cannot be called in expression: no return value"
    end
  #--- New LLVM variable for function call result
#    getNewTempVariable (!returnedType !?ioTemporaries ?let functionResult)
  #--- Code generation
    outConvenienceGuardGenerationIR = .convenienceGuard {
      !baseGuardAllocaList:baseGuardAllocaList
      !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
      !baseGuardMangledName:functionMangledName.string
      !baseGuardEffectiveParameterList:effectiveParameterListIR
    }
#    ioInstructionGenerationList += !@functionCallIR.new {
#      !functionResult
#      !functionMangledName
#      !functionNameForGeneration
#      !routineKind
#      !effectiveParameterListIR
#      !appendFileAndLineArgumentForPanicLocation
#    }
  #---
#    ioObjectPtr = functionResult
  end

#  @accessList accessList = mAccessList
#  [!?accessList popLast ?let routineName ?let arrayElementAccess]
#  if arrayElementAccess != .noAccess then
#    error routineName : "array element access is not alowed here"
#  end
#  if [accessList length] == 0 then
#    standaloneBaseGuardAnalyze (
#      !routineName:routineName
#      !effectiveParameters:mEffectiveParameterList
#      !self:inSelfType
#      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#      !context: inContext
#      !?temporary:ioTemporaries
#      !?staticStringMap:ioGlobalLiteralStringMap
#      !?variableMap:ioVariableMap
#      !?namedObjectMap: ioNamedObjectMap
#      ?outConvenienceGuardGenerationIR
#    )
#  else
#    analyzeVariableAccess (
#      !fieldList:accessList
#      !self:inSelfType
#      !directAccessToPropertiesAllowed:true
#      !inGuard:false
#      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#      !context:inContext
#      !modes:inModeSet
#      !allowPanic:true
#      !?temporary:ioTemporaries
#      !?staticStringMap:ioGlobalLiteralStringMap
#      !?variableMap:ioVariableMap
#      !?namedObjectMap: ioNamedObjectMap
#      !?alloca:ioAllocaList
#      !?instructionListIR:ioInstructionGenerationList
#      ?resultPtr:let targetPtr
#    )
#  #--- Extract base variable and access
#    [accessList first ?let baseName ?*]
#  #--- Check target access
#    [!?ioVariableMap searchForMethodCall
#      !lkey:baseName
#      ?1*
#      ?readAccessAllowed:*
#      ?variableKin:*
#      ?objectIR:*
#      ?copyable:*
#      ?1*
#    ]
#    let receiverType = [targetPtr type]
#    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
#    effectiveParameterListIR += !.outputInput ![targetPtr address] #--- add "load receiver" as first argument
#    @instructionListIR baseGuardInstructionGenerationList = {}
#    var routineMangledName = @lstring.new {!"$" + [receiverType key] + "." + routineName !routineName.location}
#    routineMangledName.string += "("
#    for (formalArgumentPassingMode selector) in mEffectiveParameterList do
#      routineMangledName.string += [formalArgumentPassingMode matchingFormalArgument] + selector + ":"
#    end
#    routineMangledName.string += ")"
#    [inContext.mGuardMapForContext searchKey
#      !routineMangledName
#      ?let unused isPublic
#      ?let @procedureSignature formalSignature
#    ]
#  #--- Enter in invocation graph
#    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
#  #--- Analyze effective parameters
#    @allocaList baseGuardAllocaList = {}
#    analyzeEffectiveParameters (
#      !self:inSelfType
#      !directAccessToPropertiesAllowed:true
#      !propertiesAreMutable:true
#      !formal:formalSignature
#      !effective:mEffectiveParameterList
#      !errorLocation:routineName.location
#      !callerForInvocationGraph:inCallerNameForInvocationGraph
#      !context:inContext
#      !requiredModeSet:{!guardModeName ()}
#      !allowPanic:true
#      !?temporary:ioTemporaries
#      !?staticStringMap:ioGlobalLiteralStringMap
#      !?variableMap:ioVariableMap
#      !?namedObjectMap: ioNamedObjectMap
#      !?alloca:baseGuardAllocaList
#      !?instructionListIR:baseGuardInstructionGenerationList
#      !?effectiveIR:effectiveParameterListIR
#    )
#  #--- Code generation
#    outConvenienceGuardGenerationIR = .convenienceGuard {
#      !baseGuardAllocaList:baseGuardAllocaList
#      !baseGuardInstructionGenerationList:baseGuardInstructionGenerationList
#      !baseGuardMangledName:routineMangledName.string
#      !baseGuardEffectiveParameterList:effectiveParameterListIR
#    }
#  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardKindGenerationIR {
  case baseGuard
  case convenienceGuard (@allocaList baseGuardAllocaList
                         @instructionListIR baseGuardInstructionGenerationList
                         @string baseGuardMangledName
                         @procCallEffectiveParameterListIR baseGuardEffectiveParameterList)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @guardMapIR {
  @procFormalArgumentListForGeneration mFormalArgumentListForGeneration
  @guardKindGenerationIR mGuardKindGenerationIR
  @allocaList mAllocaList
  @instructionListIR mInstructionGenerationList
  @bool mWarnIfUnused

  insert insertKey error message "guard '%K' is already defined"
  search searchKey error message "** internal error **"
  remove removeKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardMapIR guardCodeGeneration
  ?!@string ioLLVMcode
  ?!@2stringlist ioServiceList
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for guard in self do
    switch guard.mGuardKindGenerationIR
    case convenienceGuard (* * * *) :
    case baseGuard :
      let guardImplementationName = llvmNameForGuardImplementation (!guard.lkey.string)
      let guardCallName = llvmNameForGuardCall (!guard.lkey.string)
      ioServiceList += !guardCallName !guardImplementationName
      ioLLVMcode += llvmTitleComment (!guardImplementationName)
      ioLLVMcode += "declare i1 @" + guardCallName + " ("
      let typeName = [guard.lkey.string stringByDeletingPathExtension]
      var first = typeName == ""
      if not first then
        ioLLVMcode += "%" + [typeName assemblerRepresentation] + " * %self"  
      end
      for () in guard.mFormalArgumentListForGeneration do
        if first then first = false else ioLLVMcode += ", " end
        switch mFormalArgumentKind
        case input :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
        case output :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
       case inputOutput :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
        end
      end
      ioLLVMcode += ")" + llvmAttributeFunction () + "\n\n"
    end
    [guard llvmCodeGeneration !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  @string guardRoutineName
  switch mGuardKindGenerationIR
  case convenienceGuard (* * * *) :
    guardRoutineName = llvmNameForGuardCall (!lkey.string)
  case baseGuard :
    guardRoutineName = llvmNameForGuardImplementation (!lkey.string)
  end
  ioLLVMcode += llvmTitleComment (!guardRoutineName)
  ioLLVMcode += "define i1 @" + guardRoutineName + " ("
  let receiverTypeName = [lkey.string stringByDeletingPathExtension]
  var first = true
  if receiverTypeName != "" then
    ioLLVMcode += "%" + [receiverTypeName assemblerRepresentation] + " * %self"
    first = false
  end
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
#--- Allocate local variables 
  for (variable type) in mAllocaList do
    ioLLVMcode += "  %" + llvmNameForLocalVariable (!variable) + " = alloca " + [type llvmTypeName] + "\n"
  end
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  %" + llvmNameForLocalVariable (!mFormalArgumentName) + " = alloca " + llvmType + "\n"
    case output, inputOutput :
    end
  end
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", "
         + llvmType + " * %" + llvmNameForLocalVariable (!mFormalArgumentName) + "\n"
    case output, inputOutput :
    end
  end
#--- Declare "accept" variable 
  let accepted_llvmName = llvmNameForLocalVariable (!acceptVariableName ())
  let accepted_llvmName_loaded = llvmNameForLocalVariable (!acceptVariableName () + ".loaded")
  let accepted_llvmName_true = llvmNameForLocalVariable (!acceptVariableName () + ".true")
  let accepted_llvmName_false = llvmNameForLocalVariable (!acceptVariableName () + ".false")
#--- Base guard or convenience guard ?
  switch mGuardKindGenerationIR
  case baseGuard :
    ioLLVMcode += "  store i1 false, i1* %" + accepted_llvmName + "\n"
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  %" + accepted_llvmName_loaded + " = load i1, i1* %" + accepted_llvmName + "\n"
    ioLLVMcode += "  br i1 %" + accepted_llvmName_loaded + ", label %" + accepted_llvmName_true + ", label %" + accepted_llvmName_false + "\n\n"
    ioLLVMcode += accepted_llvmName_true + ":\n"
    ioLLVMcode += "  call void @noteGuardHasBeenAccepted ()\n"
    ioLLVMcode += "  ret i1 true\n\n"
    ioLLVMcode += accepted_llvmName_false + ":\n"
    ioLLVMcode += "  ret i1 false\n"
    ioLLVMcode += "}\n\n"
  case convenienceGuard (baseGuardAllocaList baseGuardInstructionGenerationList baseGuardMangledName baseGuardEffectiveParameterList) :
    for (variable type) in baseGuardAllocaList do
      ioLLVMcode += "  %" + llvmNameForLocalVariable (!variable) + " = alloca " + [type llvmTypeName] + "\n"
    end
    [baseGuardInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  %baseGuard.result = call i1 @" + llvmNameForGuardCall (!baseGuardMangledName)
    ioLLVMcode += " ("
    for () in baseGuardEffectiveParameterList do
      switch mEffectiveParameterPassingMode
      case input:
        ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
      case output:
        ioLLVMcode += [mParameter llvmTypeName] + " " + [mParameter llvmName]
      case outputInput:
        ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ")\n"
    ioLLVMcode += "  br i1 %baseGuard.result, label %baseGuard.true, label %baseGuard.exit\n\n"
    ioLLVMcode += "baseGuard.true:\n"
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret i1 true\n\n"
    ioLLVMcode += "baseGuard.exit:\n"
    ioLLVMcode += "  ret i1 false\n"
    ioLLVMcode += "}\n\n"
  end
  ioGenerationAdds.mExternFunctionDeclarationSet += !"declare void @noteGuardHasBeenAccepted ()\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @guardMapIR-element enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
  switch mGuardKindGenerationIR
  case baseGuard :
  case convenienceGuard (* baseGuardInstructionGenerationList baseGuardMangledName *) :
    [baseGuardInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
    ioAccessibleEntities.mGuardSet += !baseGuardMangledName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

