#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @callInstructionAST : @instructionAST {
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexCallNoSelfInstructionAST : @callInstructionAST {
  @LValueWithoutSelfAST mAssignmentTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexCallSelfInstructionAST : @callInstructionAST {
  @LValueSelfAST mAssignmentTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standAloneProcedureCallInstructionAST : @callInstructionAST {
  @lstring mSandAloneRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    <procedure_call> ?let routineCallInstruction
    ioInstructionList += !routineCallInstruction
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue_without_self> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    if [[assignmentTargetAST mAccessList] length] == 0 then
      outInstruction = @standAloneProcedureCallInstructionAST.new {
        !instructionLocation
        !arguments
        !endOfArguments
        !assignmentTargetAST.mIdentifier
      }
    else
      outInstruction = @complexCallNoSelfInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
    end
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue_with_self> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    outInstruction = @complexCallSelfInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveArgumentPassingModeAST passingModeForActualSelector ?let @lstring inSelector -> @string outResult {
  switch self
  case input (*) : outResult = "?"
  case inputWithType (* * *) : outResult = "?"
  case output (* *) : outResult = "!"
  case outputInput (*) : outResult = "!?"
  case outputInputSelfVariable (*) : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procEffectiveParameterList {
  @effectiveArgumentPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @PLMType mParameterType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @objectIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @calleeKindIR {
  case function
  case primitiveFromProcessorUserMode
  case safeFromProcessorUserMode
  case sectionFromProcessorUserMode
  case serviceFromProcessorUserMode
  case primitiveFromProcessorPrivilegedMode
  case sectionFromProcessorPrivilegedMode
  case safeFromProcessorPrivilegedMode
  case serviceFromProcessorPrivilegedMode
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

