#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @callInstructionAST : @instructionAST {
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#·······················································································································

class @standAloneProcedureCallInstructionAST : @callInstructionAST {
  @lstring mSandAloneRoutineName
}

#·······················································································································

class @procedureCallInstructionAST : @callInstructionAST {
  @LValueAST mTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    <procedure_call> ?let routineCallInstruction
    ioInstructionList += !routineCallInstruction
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    if [[assignmentTargetAST mAccessList] length] == 0 then
      outInstruction = @standAloneProcedureCallInstructionAST.new {
        !instructionLocation
        !arguments
        !endOfArguments
        !assignmentTargetAST.mIdentifier
      }
    else
      outInstruction = @procedureCallInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procedureCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mTargetAST noteInstructionTypesInPrecedenceGraph !?ioGraph]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#·······················································································································

override method @standAloneProcedureCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveArgumentPassingModeAST passingModeForActualSelector ?let @lstring inSelector -> @string outResult {
  switch self
  case input (*) : outResult = "?"
  case inputWithType (* * *) : outResult = "?"
  case output (* *) : outResult = "!"
  case outputInput (*) : outResult = "!?"
  case outputInputSelfVariable (*) : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#·······················································································································

list @procEffectiveParameterList {
  @effectiveArgumentPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @PLMType mParameterType
}

#·······················································································································

override method @standAloneProcedureCallInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Called routine signature
  let calledRoutineSignature = [mArguments routineSignature !mSandAloneRoutineName.location]
#--- Search routine in map
  [inContext.mRoutineMapForContext searchKey
    !mSandAloneRoutineName
    !calledRoutineSignature
    ?let @lstring LLVMInvocationRoutineName
    ?let @routineDescriptor routineDescriptor
    ?let @location unused keyLocation
  ]
#--- Search routine in map
#  [ioUniversalMap searchRoutine
#    !mSandAloneRoutineName
#    !calledRoutineSignature
#    ?let @lstring LLVMInvocationRoutineName
#    ?let @routineDescriptor routineDescriptor
#  ]
#--- Routine name for invocation graph
  let routineMangledName = routineMangledNameFromCall (
    !""
    !mSandAloneRoutineName
    !mArguments
  )
#--- Enter in invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
#--- Check modes
  let routineKindIR = checkMode (
    !callerMode:inCurrentMode
    !calleeMode:[routineDescriptor.mRoutineKind executionMode]
    !kind:routineDescriptor.mRoutineKind
    !error:mSandAloneRoutineName.location
  )
#--- Analyze effective parameters
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  analyzeEffectiveParametersNew (
    !self:inSelfType
    !formal:routineDescriptor.mSignature
    !effective:mArguments
    !errorLocation:mSandAloneRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredMode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )

#--- Code generation
  ioInstructionGenerationList += !@staticRoutineCallIR.new {
    !""
    !.null
    !routineMangledName
    !LLVMInvocationRoutineName
    !routineKindIR
    !effectiveParameterListIR
  }
}

#·······················································································································

override method @procedureCallInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze header identifier : it is a variable, as a standalone procedure call is handled in an other place
#    If identifier is empty string, the receiver is "self"
  @objectIR currentObject
  if mTargetAST.mIdentifier.string == "" then # Receiver is self
    if inSelfType == .void then
      error mTargetAST.mIdentifier : "self is not available in this context" : currentObject
    else
      currentObject = .temporaryReference {!type:inSelfType !llvmName:.new {!"%self" !mTargetAST.mIdentifier.location}}
    end
  else
    [ioUniversalMap searchValuedObject !mTargetAST.mIdentifier ?currentObject]
  end
#--- Check current object in a structure instance
  if not [[currentObject type] isStructure] then
    error mTargetAST.mIdentifier : "receiver has no property"
  else
  #--- Get current object property map
    [[currentObject type] structure ?1* ?propertyMap:@propertyMap propertyMap ?5*]
  #--- Insulate last access (should be a "property", used as routine name
    var accessList = mTargetAST.mAccessList
    [!?accessList popLast ?let lastAccess]
  #--- loop on access list
    for (access) in accessList do
      switch access
      case property (@lstring propertyName) :
        [propertyMap searchKey
          !propertyName
          ?let @bool unused isPublic
          ?let @objectIR propertyObject
          ?let @PLMType type
          ?let@propertyAccessKind unused propertyAccess
        ]
        if not [type isStructure] then
          error mTargetAST.mIdentifier : "receiver has no property"
        else
          [type structure ?1* ?propertyMap:propertyMap ?5*]
          let newObject = @objectIR.temporaryReference {
             !type:[propertyObject type]
             !llvmName:.new {!"%temp." + ioTemporaries.mTemporaryIndex !propertyName}
          }
          ioTemporaries.mTemporaryIndex ++
          [!?ioInstructionGenerationList appendGetPropertyReference
            !newObject
            !currentObject
            !propertyName
          ]
          currentObject = newObject
        end
      case arrayAccess (@expressionAST unused indexExpression @location endOfIndex) :
        error endOfIndex : "not handled yet" : currentObject
      end
    end
  #--- Handle last access
    switch lastAccess
    case arrayAccess (* @location endOfIndex) :
      error endOfIndex : "a property access is required here"
    case property (@lstring methodName) :
    #--- Get function name and map containing the function definition
      let routineMangledName = routineMangledNameFromCall (!"$" + [[currentObject type] key] !methodName !mArguments)
    #--- Get called function signature
      let signature = [mArguments routineSignature !methodName.location]
    #--- Search function in map
      [inContext.mRoutineMapForContext searchKey
        !methodName
        !signature
        ?let @lstring LLVMInvocationRoutineName
        ?@routineDescriptor routineDescriptor
        ?let @location unused keyLocation
      ]
    #--- Add receiver as first parameter
      @procCallEffectiveParameterListIR effectiveParameterListIR = {}
#      switch routineDescriptor.mRoutineCallingScheme
#      case staticCall :
        effectiveParameterListIR += !.outputInput !currentObject # Add receiver as first argument
#      case propertyIndirectCall (*) :
#      end
    #---
    #  let isPublic = routineDescriptor.mIsPublic
      let routineKind = routineDescriptor.mRoutineKind
      let calleeMode = [routineKind executionMode]
      let formalSignature = routineDescriptor.mSignature
    #--- Check routine is actually a procedure (does not return any value)
      if routineDescriptor.mReturnTypeProxy != .null then
        error methodName : "not a procedure (returns a value)" : routineDescriptor
      else
      #--- Check modes
        let calleeKind = checkMode (
          !callerMode:inCurrentMode
          !calleeMode:calleeMode
          !kind:routineKind
          !error:methodName.location
        )
      #--- Analyze effective parameters
        analyzeEffectiveParametersNew (
          !self:inSelfType
          !formal:formalSignature
          !effective:mArguments
          !errorLocation:methodName.location
          !callerForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !requiredMode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !?instructionListIR:ioInstructionGenerationList
          !?effectiveIR:effectiveParameterListIR
        )
      #--- Generate call
        switch routineDescriptor.mRoutineCallingScheme
        case staticCall :
        #--- Code generation
          ioInstructionGenerationList += !@staticRoutineCallIR.new {
            !mTargetAST.mIdentifier
            !.null # No result
            !routineMangledName
            !LLVMInvocationRoutineName
            !calleeKind
            !effectiveParameterListIR
          }
        #--- Enter in invocation graph
          [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
        case propertyIndirectCall (type) :
          let propertyReference = @objectIR.temporaryReference {
             !type:type
             !llvmName:.new {!"%temp." + ioTemporaries.mTemporaryIndex !methodName}
          }
          ioTemporaries.mTemporaryIndex ++
          [!?ioInstructionGenerationList appendGetPropertyReference
            !propertyReference
            !currentObject
            !methodName
          ]
        #--- Code generation
          ioInstructionGenerationList += !@indirectRoutineCallIR.new {
            !propertyReference
            !type
            !.null # No result
            !effectiveParameterListIR
          }
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Code Generation
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @objectIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @calleeKindIR {
  case function
  case primitiveFromProcessorUserMode
  case safeFromProcessorUserMode
  case sectionFromProcessorUserMode
  case serviceFromProcessorUserMode
  case primitiveFromProcessorPrivilegedMode
  case sectionFromProcessorPrivilegedMode
  case safeFromProcessorPrivilegedMode
  case serviceFromProcessorPrivilegedMode
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
