#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @callInstructionAST : @instructionAST {
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#·······················································································································

class @standAloneProcedureCallInstructionAST : @callInstructionAST {
  @lstring mSandAloneRoutineName
}

#·······················································································································

class @procedureCallInstructionAST : @callInstructionAST {
  @lstring mIdentifier
  @accessInAssignmentListAST mAccessList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <instruction> ?!@ast ioAST ?!@instructionListAST ioInstructionList {
    <procedure_call> !?ioAST ?let routineCallInstruction
    ioInstructionList += !routineCallInstruction
  }

  #·····················································································································

  rule <procedure_call> ?!@ast ioAST !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue> !?ioAST ?let assignmentTargetAST
    <effective_parameters> !?ioAST ?let arguments ?let endOfArguments
    if (assignmentTargetAST.mOperand == .noOperand) & (assignmentTargetAST.mIdentifier.string != "") then
      outInstruction = @standAloneProcedureCallInstructionAST.new {
        !instructionLocation
        !arguments
        !endOfArguments
        !assignmentTargetAST.mIdentifier
      }
    else
      @accessInAssignmentListAST accessList = {}
      [assignmentTargetAST.mOperand buildProcedureCallAccessList !?accessList]
      outInstruction = @procedureCallInstructionAST.new {
        !instructionLocation
        !arguments
        !endOfArguments
        !assignmentTargetAST.mIdentifier
        !accessList
      }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueOperandAST buildProcedureCallAccessList ?!@accessInAssignmentListAST ioAccessList {
  switch self
  case noOperand :
  case property (@lstring name @LValueOperandAST next) :
    ioAccessList += !.property {!name:name}
    [next buildProcedureCallAccessList !?ioAccessList]
  case arrayAccess (@expressionAST index @location endOfIndex @bool checkIndexExpression @LValueOperandAST next) :
    ioAccessList += !.arrayAccess {!index:index !endOfIndex:endOfIndex !checkIndexExpression:checkIndexExpression}
    [next buildProcedureCallAccessList !?ioAccessList]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procedureCallInstructionAST noteInstructionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
#  [mOperand noteInstructionTypesInPrecedenceGraph !?ioGraph]
  for (access) in mAccessList do
    switch access
    case property (*) :
    case arrayAccess (@expressionAST indexExpression 2*) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#·······················································································································

override method @standAloneProcedureCallInstructionAST noteInstructionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveArgumentPassingModeAST passingModeForActualSelector ?let @lstring inSelector -> @string {
  switch self
  case input (*) : result = "?"
  case inputWithType (* * *) : result = "?"
  case output (* *) : result = "!"
  case outputInput (*) : result = "!?"
  case outputInputSelfVariable (*) : result = "!?"
  end
  if inSelector.string != "" then
    result += inSelector.string + ":"
  end
}

#·······················································································································

list @procEffectiveParameterList {
  @effectiveArgumentPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @omnibusType mParameterType
}

#·······················································································································

override method @standAloneProcedureCallInstructionAST instructionSemanticAnalysis
  ?self:let @omnibusType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Called routine signature
  let calledRoutineSignature = [mArguments routineSignature !mSandAloneRoutineName.location]
#--- Search routine in map
  let requiredFunctionMangledName = mSandAloneRoutineName.string + calledRoutineSignature
  [inContext.mRoutineMap searchKey
    !.new {!requiredFunctionMangledName !mSandAloneRoutineName}
    ?let unused implementedPublic
    ?let formalSignature
    ?let formalReturnTypeProxy # null if no returned value
    ?let implementedModeDictionary
    ?let unused implementedIsExported
    ?let unused implementedMode
  ]
#--- Check return type proxy is null
  if formalReturnTypeProxy != .null then
    error mSandAloneRoutineName : "this function returns a value, cannot be used as a procedure"
  end
#--- Check modes
    let functionLLVMName = checkModeAndReturnsRoutineLLVMName (!implementedModeDictionary !inMode !mSandAloneRoutineName)
#    @string functionLLVMName
#    if [implementedModeDictionary hasKey !inMode] then
#      [implementedModeDictionary searchKey !inMode ?functionLLVMName]
#    elsif [implementedModeDictionary hasKey !.anyMode] then
#      [implementedModeDictionary searchKey !.anyMode ?functionLLVMName]
#    else
#      error mSandAloneRoutineName : "this function cannot be invoked in " + inMode + " mode" : functionLLVMName
#    end
#--- Analyze effective parameters
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  analyzeEffectiveParameters (
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !formal:formalSignature
    !effective:mArguments
    !errorLocation:mSandAloneRoutineName.location
    !context:inContext
    !requiredMode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )

#--- Routine name for invocation graph
  let routineMangledName = routineMangledNameFromCall (
    !""
    !mSandAloneRoutineName
    !mArguments
  )
#--- Code generation
  ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
    !.void
    !routineMangledName
    !functionLLVMName
    !effectiveParameterListIR
  }
}

#·······················································································································

override method @procedureCallInstructionAST instructionSemanticAnalysis
  ?self:let @omnibusType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze header identifier : it is a variable, as a standalone procedure call is handled in an other place
#    If identifier is empty string, the receiver is "self"
  @omnibusType currentType
  @string currentLLVMAddressVar
  if mIdentifier.string == "" then # Receiver is self
    if inSelfType.kind == .void then
      error mIdentifier : "self is not available in this context" : currentType, currentLLVMAddressVar
    else
      currentType = inSelfType
      currentLLVMAddressVar = llvmNameForSelf ()
    end
  else
    [ioUniversalMap searchEntity !mIdentifier ?let @valuedObject entity]
    switch entity
    case task (@omnibusType type) :
      currentType = type
      currentLLVMAddressVar = llvmNameForGlobalVariable (!mIdentifier)
    case driver (@omnibusType type instancied) :
      if instancied then
        currentType = type
        currentLLVMAddressVar = llvmNameForGlobalVariable (!mIdentifier)
      else
        error mIdentifier : "the driver should be instancied" : currentType, currentLLVMAddressVar
      end
    case globalConstant (*) :
      error mIdentifier
        : "a global constant cannot be used in this context"
        : currentType, currentLLVMAddressVar
    case localConstant (@omnibusType type @lstring omnibusName *) :
      currentType = type
      currentLLVMAddressVar = llvmNameForLocalVariable (!omnibusName)
    case localVariable (@omnibusType type @lstring omnibusName) :
      currentType = type
      currentLLVMAddressVar = llvmNameForLocalVariable (!omnibusName)
    case globalSyncInstance (@omnibusType type @lstring omnibusName) :
      currentType = type
      currentLLVMAddressVar = llvmNameForGlobalSyncInstance (!omnibusName)
    end
  end
#--- Get current object property map
  @propertyGetterMap currentObjectPropertyMap = currentType.propertyGetterMap
#--- Insulate last access (should be a "property", used as routine name
  var accessList = mAccessList
  [!?accessList popLast ?let lastAccess]
#--- loop on access list
  for (access) in accessList do
    switch access
    case property (@lstring propertyName) :
      [currentObjectPropertyMap searchKey
        !propertyName
        ?let @bool unused isPublic
        ?let @propertyGetterKind propertyAccess
      ]
      switch propertyAccess
      case constantProperty (*) :
        error propertyName
          : "a context property cannot be used in this context"
          : currentType, currentLLVMAddressVar
      case storedProperty (@omnibusType propertyType @uint propertyIndex) :
        [!?ioTemporaries newTempLLVMVar ?let llvmPropertyName]
        [!?ioInstructionGenerationList appendGetUniversalPropertyReference
          !currentType
          !currentLLVMAddressVar
          !llvmPropertyName
          !propertyIndex
          !propertyName
        ]
        currentType = propertyType
        currentLLVMAddressVar = llvmPropertyName
        currentObjectPropertyMap = currentType.propertyGetterMap
      case computedProperty (propertyTypeProxy modeDictionary) :
        let routineLLVMName = checkModeAndReturnsRoutineLLVMName (!modeDictionary !inMode !propertyName)
        [!?ioInstructionGenerationList appendGetComputedPropertyValue
          !?ioTemporaries
          !.reference {!type:currentType !llvmName:currentLLVMAddressVar}
          !routineLLVMName
          ![propertyTypeProxy type]
          ?let resultValueIR
        ]
        currentType = [resultValueIR type]
        currentLLVMAddressVar = [resultValueIR llvmName]
        currentObjectPropertyMap = currentType.propertyGetterMap # ????
      end
    case arrayAccess (* @location endOfIndex *) :
      error endOfIndex : "not handled yet" : currentType, currentLLVMAddressVar
    end
  end
#--- Handle last access
  switch lastAccess
  case arrayAccess (* @location endOfIndex *) :
    error endOfIndex : "a property is required here"
  case property (@lstring methodName) :
    let @routineMapCTXT routineMap = [currentType routineMap]
    let methodMangledName = [mArguments mangledName !receiverTypeName: [currentType omnibusTypeDescriptionName] !functionName: methodName]
#    log routineMap
#    log methodMangledName
    [routineMap searchKey
      !methodMangledName
      ?let unused implementedPublic
      ?let formalSignature
      ?let formalReturnTypeProxy # null if no returned value
      ?let implementedModeDictionary
      ?let unused implementedIsExported
      ?let unused implementedMode
    ]
  #--- Check modes
    let functionLLVMName = checkModeAndReturnsRoutineLLVMName (!implementedModeDictionary !inMode !methodName)
  #--- Check routine does not return any value
    if formalReturnTypeProxy != .null then
      error methodName : "cannot be called in instruction, returns a value"
    end
  #--- Add receiver as first parameter
    @procCallEffectiveParameterListIR effectiveParameterListIR = {
      !.outputInput
      !.reference {!type:currentType !llvmName:currentLLVMAddressVar}
    }
  #--- Analyze effective parameters
    analyzeEffectiveParameters (
      !self:inSelfType
      !routineAttributes:inRoutineAttributes
      !formal:formalSignature
      !effective:mArguments
      !errorLocation:methodName.location
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- Generate call
    ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
      !.void
      !methodMangledName
      !functionLLVMName
      !effectiveParameterListIR
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#·······················································································································

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @objectIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
