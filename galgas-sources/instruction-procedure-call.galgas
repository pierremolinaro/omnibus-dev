#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @callInstructionAST : @instructionAST {
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexCallNoSelfInstructionAST : @callInstructionAST {
  @LValueNoSelfAST mAssignmentTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexCallSelfInstructionAST : @callInstructionAST {
  @LValueSelfAST mAssignmentTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @simpleCallInstructionAST : @callInstructionAST {
  @lstring mSandAloneRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    <procedure_call> ?let routineCallInstruction
    ioInstructionList += !routineCallInstruction
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue_without_self> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    if [[assignmentTargetAST mAccessList] length] == 0 then
      outInstruction = @simpleCallInstructionAST.new {!instructionLocation !arguments !endOfArguments ![assignmentTargetAST mIdentifier]}
    else
      outInstruction = @complexCallNoSelfInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
    end
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue_with_self> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    outInstruction = @complexCallSelfInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallNoSelfInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mAssignmentTargetAST noteInstructionTypesInPrecedenceGraph !?ioGraph]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#·······················································································································

override method @complexCallSelfInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mAssignmentTargetAST noteInstructionTypesInPrecedenceGraph !?ioGraph]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @simpleCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SOLVE ENTITIES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @simpleCallInstructionSE : @instructionSE {
  @lstring mSandAloneRoutineName
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#·······················································································································

override method @simpleCallInstructionAST solveEntities
  ?context:let @semanticContext inSemanticContext
  ?!@instructionListSE ioInstructionListSE
{
  let signature = [mArguments routineSignature !mSandAloneRoutineName.location]
  if [inSemanticContext.mRoutineMapForContext hasKey !mSandAloneRoutineName !signature] then
    ioInstructionListSE += !@simpleCallInstructionSE.new {!mInstructionLocation !mSandAloneRoutineName !mArguments !mEndOfArguments}
  else
    error mSandAloneRoutineName : "undefined function"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexSelfPropertyCallInstructionSE : @instructionSE {
  @lstring mPropertyName
  @accessInAssignmentListSE mAccessList
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#·······················································································································

class @complexCallInstructionSE : @instructionSE {
  @lstring mIdentifier
  @accessInAssignmentListSE mAccessList
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#·······················································································································

method @LValueSelfAST solveEntitiesForComplexCallInstruction
  ?context:let @semanticContext inSemanticContext
  ?let @location inInstructionLocation
  ?let @effectiveArgumentListAST inArguments
  ?let @location inEndOfArguments
  ?!@instructionListSE ioInstructionListSE
{
  @accessInAssignmentListSE accessList = {}
  for (access) in mAccessList do
    switch access
    case property (name) :
      accessList += !.property {!name:name}
    case arrayAccess (indexAST endOfIndex) :
      [indexAST solveEntities !context:inSemanticContext ?let index]
      accessList += !.arrayAccess {!index:index !endOfIndex:endOfIndex}
    end
  end
  ioInstructionListSE += !@complexSelfPropertyCallInstructionSE.new {
    !inInstructionLocation
    !mIdentifier
    !accessList
    !inArguments
    !inEndOfArguments
  }
}

#·······················································································································

override method @complexCallNoSelfInstructionAST solveEntities
  ?context:let @semanticContext inSemanticContext
  ?!@instructionListSE ioInstructionListSE
{
#  [mAssignmentTargetAST solveEntitiesForLValueNoSelf !context:inSemanticContext ?let @LValueWithoutSelfSE LValueSE]
#   switch LValueSE
#   case register (@lstring registerName) :
#     error registerName : "a control register cannot be called as a function"
#   case globalVariable (@lstring globalVariableName @accessInAssignmentListSE accessList) :
#   case localVariableOrStandAloneProcedure (@lstring identifier) :
#   case localVariable (@lstring localVariableName @accessInAssignmentListSE accessList) :
#   end
  [mAssignmentTargetAST solveEntitiesForComplexCallInstructionEX
    !context:inSemanticContext
    !mInstructionLocation
    !mArguments
    !mEndOfArguments
    !?ioInstructionListSE
  ]
}

#·······················································································································

method @LValueNoSelfAST solveEntitiesForComplexCallInstructionEX
  ?context:let @semanticContext inSemanticContext
  ?let @location inInstructionLocation
  ?let @effectiveArgumentListAST inArguments
  ?let @location inEndOfArguments
  ?!@instructionListSE ioInstructionListSE
{
  @accessInAssignmentListSE accessList = {}
  for (access) in mAccessList do
    switch access
    case property (name) :
      accessList += !.property {!name:name}
    case arrayAccess (indexAST endOfIndex) :
      [indexAST solveEntities !context:inSemanticContext ?let index]
      accessList += !.arrayAccess {!index:index !endOfIndex:endOfIndex}
    end
  end
  if [inSemanticContext.mControlRegisterMap hasKey !mIdentifier] then
    error mIdentifier : "control register is used as a function"
  elsif [inSemanticContext.mGlobalVariableMap hasKey !mIdentifier] then
    error mIdentifier : "global variable is used as a function"
  elsif [inSemanticContext.mGlobalConstantMap hasKey !mIdentifier] then
    error mIdentifier : "constant is used as a function"
  else # By default, access to local variable
    ioInstructionListSE += !@complexCallInstructionSE.new {
      !inInstructionLocation
      !mIdentifier
      !accessList
      !inArguments
      !inEndOfArguments
    }
  end
}

#·······················································································································

override method @complexCallSelfInstructionAST solveEntities
  ?context:let @semanticContext inSemanticContext
  ?!@instructionListSE ioInstructionListSE
{
  [mAssignmentTargetAST solveEntitiesForComplexCallInstruction
    !context:inSemanticContext
    !mInstructionLocation
    !mArguments
    !mEndOfArguments
    !?ioInstructionListSE
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveArgumentPassingModeAST passingModeForActualSelector ?let @lstring inSelector -> @string outResult {
  switch self
  case input (*) : outResult = "?"
  case inputWithType (* * *) : outResult = "?"
  case output (* *) : outResult = "!"
  case outputInput (*) : outResult = "!?"
  case outputInputSelfVariable (*) : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procEffectiveParameterList {
  @effectiveArgumentPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @PLMType mParameterType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueNoSelfAST analyzeTargetForRoutineCall
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
#    [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?let isPublic ?let currentObject]
  if [ioVariableMap hasKey !mIdentifier] then
    switch inSelfAccessKind
    case read :
      [!?ioVariableMap searchForReadAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case write :
      [!?ioVariableMap searchForWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case readWrite :
      [!?ioVariableMap searchForReadWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    end
    outGlobalVariableReceiverName = if [outCurrentObject isGlobalVariableReference] then mIdentifier.string else "" end
  else # Stand alone function call ?
    outCurrentObject = .possibleFunction {!receiver:.null !functionName:mIdentifier}
    outGlobalVariableReceiverName = ""
  end
#--- Analyze properties, subscripts
  if [mAccessList length] == 0 then # 
    [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?outCurrentObject]
  else
    for (access) in mAccessList do
      switch access
      case property (propertyName) :
        handlePropertyAccessInAssignment (
          !?outCurrentObject
          !propertyName
          !?ioTemporaries
          !?ioInstructionGenerationList
        )
      case arrayAccess (indexExpression endOfExpression) :
        handleSubscriptInAssignmentAndExpression (
          !self:inSelfType
          !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
          !inGuard:false
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioVariableMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !indexExpression
          !endOfExpression
          !?ioInstructionGenerationList
          !?outCurrentObject
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST analyzeTargetForRoutineCall
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind unused inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
  outGlobalVariableReceiverName = "" # Receiver is not a global variable
  if [inSelfType isStructure] then
    [inSelfType structure ?typeName:* ?propertyMap:let structureObjectMap ?universalMap:let unused universalMap ?3*]
 ##     [universalMap searchProperty !mIdentifier ?* ?let object]
    if [structureObjectMap hasKey !mIdentifier] then
      [structureObjectMap searchKey
        !mIdentifier
        ?*
        ?let object
      ]
      handleSelfAccessInAssignment (
        !inSelfType
        !object
        !?ioTemporaries
        !?ioInstructionGenerationList
        ?outCurrentObject
      )
    else # Function call ?
      outCurrentObject = .possibleFunction {!receiver:.selfObject {!type:inSelfType} !functionName:mIdentifier}
    end
  else
    error mIdentifier : "'self' should be a structure instance" : outCurrentObject, outGlobalVariableReceiverName
  end
#--- Analyze properties, subscripts
  for (access) in mAccessList do
    switch access
    case property (propertyName) :
      handlePropertyAccessInAssignment (
        !?outCurrentObject
        !propertyName
        !?ioTemporaries
        !?ioInstructionGenerationList
      )
    case arrayAccess (indexExpression endOfExpression) :
      handleSubscriptInAssignmentAndExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:false
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !indexExpression
        !endOfExpression
        !?ioInstructionGenerationList
        !?outCurrentObject
      )
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @simpleCallInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Called routine signature
  let calledRoutineSignature = [mArguments routineSignature !mSandAloneRoutineName.location]
#--- Search routine in map
  [ioUniversalMap searchRoutine
    !mSandAloneRoutineName
    !calledRoutineSignature
    ?let @lstring LLVMInvocationRoutineName
    ?let @routineDescriptor routineDescriptor
  ]
#--- Routine name for invocation graph
  let routineMangledName = routineMangledNameFromCall (
    !""
    !mSandAloneRoutineName
    !mArguments
  )
#--- Enter in invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
#--- Check modes
  let routineKindIR = checkMode (
    !callerMode:inCurrentMode
    !calleeMode:[routineDescriptor.mRoutineKind executionMode]
    !kind:routineDescriptor.mRoutineKind
    !error:mSandAloneRoutineName.location
  )
#--- Analyze effective parameters
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  analyzeEffectiveParameters (
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !propertiesAreMutable:inRoutineCanMutateProperties
    !formal:routineDescriptor.mSignature
    !effective:mArguments
    !errorLocation:mSandAloneRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredMode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )
#--- Code generation
  ioInstructionGenerationList += !@staticRoutineCallIR.new {
    !""
    !.null
    !routineMangledName
    !LLVMInvocationRoutineName
    !routineKindIR
    !effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallNoSelfInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  [mAssignmentTargetAST analyzeAssignmentTarget
    !self: inSelfType
    !targetAccessKind:.read # § .readWrite
    !propertiesAreMutable: inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed: inDirectAccessToPropertiesAllowed
    !routineNameForInvocationGraph: inCallerNameForInvocationGraph
    !context: inContext
    !mode: inCurrentMode
    !?temporary: ioTemporaries
    !?staticStringMap: ioGlobalLiteralStringMap
    !?variableMap: ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?@objectIR currentObject
    ?globalVariableReceiverName:let globalVariableReceiverName
  ]
#--- Analyze procedure call arguments
  handleFunctionCallInExpression (
    !self:inSelfType
    !globalVariableReceiverName:globalVariableReceiverName
    !propertiesAreMutable:inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !mArguments
    !mEndOfArguments
    !?ioInstructionGenerationList
    !?currentObject
    ?let returnedType
  )
  if returnedType != .void then
    error mEndOfArguments : "the function cannot be called in instruction: lost return value"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallSelfInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  [mAssignmentTargetAST analyzeAssignmentTarget
    !self: inSelfType
    !targetAccessKind:.read # § .readWrite
    !propertiesAreMutable: inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed: inDirectAccessToPropertiesAllowed
    !routineNameForInvocationGraph: inCallerNameForInvocationGraph
    !context: inContext
    !mode: inCurrentMode
    !?temporary: ioTemporaries
    !?staticStringMap: ioGlobalLiteralStringMap
    !?variableMap: ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?@objectIR currentObject
    ?globalVariableReceiverName:let globalVariableReceiverName
  ]
#--- Analyze procedure call arguments
  handleFunctionCallInExpression (
    !self:inSelfType
    !globalVariableReceiverName:globalVariableReceiverName
    !propertiesAreMutable:inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !mArguments
    !mEndOfArguments
    !?ioInstructionGenerationList
    !?currentObject
    ?let returnedType
  )
  if returnedType != .void then
    error mEndOfArguments : "the function cannot be called in instruction: lost return value"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @objectIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @calleeKindIR {
  case function
  case primitiveFromProcessorUserMode
  case safeFromProcessorUserMode
  case sectionFromProcessorUserMode
  case serviceFromProcessorUserMode
  case primitiveFromProcessorPrivilegedMode
  case sectionFromProcessorPrivilegedMode
  case safeFromProcessorPrivilegedMode
  case serviceFromProcessorPrivilegedMode
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

