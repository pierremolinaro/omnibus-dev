#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @callInstructionAST : @instructionAST {
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexCallNoSelfInstructionAST : @callInstructionAST {
  @LValueWithoutSelfAST mAssignmentTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @complexCallSelfInstructionAST : @callInstructionAST {
  @LValueSelfAST mAssignmentTargetAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @simpleCallInstructionAST : @callInstructionAST {
  @lstring mSandAloneRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    <procedure_call> ?let routineCallInstruction
    ioInstructionList += !routineCallInstruction
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue_without_self> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    if [[assignmentTargetAST mAccessList] length] == 0 then
      outInstruction = @simpleCallInstructionAST.new {!instructionLocation !arguments !endOfArguments ![assignmentTargetAST mIdentifier]}
    else
      outInstruction = @complexCallNoSelfInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
    end
  }

  #·····················································································································

  rule <procedure_call> !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue_with_self> ?let assignmentTargetAST
    <effective_parameters> ?let arguments ?let endOfArguments
    outInstruction = @complexCallSelfInstructionAST.new {!instructionLocation !arguments !endOfArguments !assignmentTargetAST}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallNoSelfInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mAssignmentTargetAST noteInstructionTypesInPrecedenceGraph !?ioGraph]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#·······················································································································

override method @complexCallSelfInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mAssignmentTargetAST noteInstructionTypesInPrecedenceGraph !?ioGraph]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @simpleCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveArgumentPassingModeAST passingModeForActualSelector ?let @lstring inSelector -> @string outResult {
  switch self
  case input (*) : outResult = "?"
  case inputWithType (* * *) : outResult = "?"
  case output (* *) : outResult = "!"
  case outputInput (*) : outResult = "!?"
  case outputInputSelfVariable (*) : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procEffectiveParameterList {
  @effectiveArgumentPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @PLMType mParameterType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueWithoutSelfAST analyzeTargetForRoutineCall
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
#    [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?let isPublic ?let currentObject]
  if [ioVariableMap hasKey !mIdentifier] then
    switch inSelfAccessKind
    case read :
      [!?ioVariableMap searchForReadAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case write :
      [!?ioVariableMap searchForWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case readWrite :
      [!?ioVariableMap searchForReadWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    end
    outGlobalVariableReceiverName = if [outCurrentObject isGlobalVariableReference] then mIdentifier.string else "" end
  else # Stand alone function call ?
    outCurrentObject = .possibleFunction {!receiver:.null !functionName:mIdentifier}
    outGlobalVariableReceiverName = ""
  end
#--- Analyze properties, subscripts
  if [mAccessList length] == 0 then # 
    [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?outCurrentObject]
  else
    for (access) in mAccessList do
      switch access
      case property (propertyName) :
        handlePropertyAccessInAssignment (
          !?outCurrentObject
          !propertyName
          !?ioTemporaries
          !?ioInstructionGenerationList
        )
      case arrayAccess (indexExpression endOfExpression) :
        handleSubscriptInAssignmentAndExpression (
          !self:inSelfType
          !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
          !inGuard:false
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioVariableMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !indexExpression
          !endOfExpression
          !?ioInstructionGenerationList
          !?outCurrentObject
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST analyzeTargetForRoutineCall
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind unused inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
  outGlobalVariableReceiverName = "" # Receiver is not a global variable
  if [inSelfType isStructure] then
    [inSelfType structure ?typeName:* ?propertyMap:let structureObjectMap ?universalMap:let unused universalMap ?3*]
 ##     [universalMap searchProperty !mIdentifier ?* ?let object]
    if [structureObjectMap hasKey !mIdentifier] then
      [structureObjectMap searchKey
        !mIdentifier
        ?*
        ?let object
      ]
      handleSelfAccessInAssignment (
        !inSelfType
        !object
        !?ioTemporaries
        !?ioInstructionGenerationList
        ?outCurrentObject
      )
    else # Function call ?
      outCurrentObject = .possibleFunction {!receiver:.selfObject {!type:inSelfType} !functionName:mIdentifier}
    end
  else
    error mIdentifier : "'self' should be a structure instance" : outCurrentObject, outGlobalVariableReceiverName
  end
#--- Analyze properties, subscripts
  for (access) in mAccessList do
    switch access
    case property (propertyName) :
      handlePropertyAccessInAssignment (
        !?outCurrentObject
        !propertyName
        !?ioTemporaries
        !?ioInstructionGenerationList
      )
    case arrayAccess (indexExpression endOfExpression) :
      handleSubscriptInAssignmentAndExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:false
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !indexExpression
        !endOfExpression
        !?ioInstructionGenerationList
        !?outCurrentObject
      )
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @simpleCallInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx unused ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Called routine signature
  let calledRoutineSignature = [mArguments routineSignature !mSandAloneRoutineName.location]
#--- Search routine in map
  [ioUniversalMap searchRoutine
    !mSandAloneRoutineName
    !calledRoutineSignature
    ?let @lstring LLVMInvocationRoutineName
    ?let @routineDescriptor routineDescriptor
  ]
#--- Routine name for invocation graph
  let routineMangledName = routineMangledNameFromCall (
    !""
    !mSandAloneRoutineName
    !mArguments
  )
#--- Enter in invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
#--- Check modes
  let routineKindIR = checkMode (
    !callerMode:inCurrentMode
    !calleeMode:[routineDescriptor.mRoutineKind executionMode]
    !kind:routineDescriptor.mRoutineKind
    !error:mSandAloneRoutineName.location
  )
#--- Analyze effective parameters
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
#  analyzeEffectiveParameters (
#    !self:inSelfType
#    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
#    !propertiesAreMutable:inRoutineCanMutateProperties
#    !formal:routineDescriptor.mSignature
#    !effective:mArguments
#    !errorLocation:mSandAloneRoutineName.location
#    !callerForInvocationGraph:inCallerNameForInvocationGraph
#    !context:inContext
#    !requiredMode:inCurrentMode
#    !?temporary:ioTemporaries
#    !?staticStringMap:ioGlobalLiteralStringMap
#    !?variableMap:ioUniversalMap
#    !?alloca:ioAllocaList
#    !?instructionListIR:ioInstructionGenerationList
#    !?effectiveIR:effectiveParameterListIR
#  )
  analyzeEffectiveParametersNew (
    !self:inSelfType
    !formal:routineDescriptor.mSignature
    !effective:mArguments
    !errorLocation:mSandAloneRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredMode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )

#--- Code generation
  ioInstructionGenerationList += !@staticRoutineCallIR.new {
    !""
    !.null
    !routineMangledName
    !LLVMInvocationRoutineName
    !routineKindIR
    !effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallNoSelfInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  [mAssignmentTargetAST analyzeLValueNoSelf
    !self: inSelfType
    !targetAccessKind:.read # § .readWrite
    !propertiesAreMutable: inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed: inDirectAccessToPropertiesAllowed
    !routineNameForInvocationGraph: inCallerNameForInvocationGraph
    !context: inContext
    !mode: inCurrentMode
    !?temporary: ioTemporaries
    !?staticStringMap: ioGlobalLiteralStringMap
    !?variableMap: ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?@objectIR currentObject
    ?@internalRepresentation internalRepresentation
    ?globalVariableReceiverName:let globalVariableReceiverName
  ]
#--- Analyze procedure call arguments
#  handleFunctionCallInExpression (
#    !self:inSelfType
#    !globalVariableReceiverName:globalVariableReceiverName
#    !propertiesAreMutable:inRoutineCanMutateProperties
#    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
#    !inGuard:false
#    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#    !context:inContext
#    !mode:inCurrentMode
#    !?temporary:ioTemporaries
#    !?staticStringMap:ioGlobalLiteralStringMap
#    !?variableMap:ioUniversalMap
#    !?alloca:ioAllocaList
#    !mArguments
#    !mEndOfArguments
#    !?ioInstructionGenerationList
#    !?currentObject
#    ?let returnedType
#  )
#  if returnedType != .void then
#    error mEndOfArguments : "the function cannot be called in instruction: lost return value"
#  end
  handleRoutineCallInInstruction (
    !internalRepresentation
    !self:inSelfType
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !mArguments
    !globalVariableReceiverName
    !?ioInstructionGenerationList
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleRoutineCallInInstruction
  ?let @internalRepresentation inInternalRepresentation
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments
  ?let @string inGlobalVariableReceiverName
  ?!@instructionListIR ioInstructionGenerationList
{
#--- Get function name and map containing the function definition
  switch inInternalRepresentation
  case bitField (* @objectIR valueIR) :
    error [valueIR location] : "this is not a function"
  case standAloneIdentifier (@lstring identifier) : # This a call idf (....)
    handleStandAloneRoutineCallInInstruction (
      !identifier
      !self:inSelfType
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !mode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !inArguments
      !?ioInstructionGenerationList
    )
  case structureMember (@lstring propertyName @objectIR currentPointerIR) :
    if [[currentPointerIR type] isStructure] then
      handleMethodCallInInstruction (
        !propertyName
        !currentPointerIR
        !self:inSelfType
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !inArguments 
        !inGlobalVariableReceiverName
        !?ioInstructionGenerationList
      )
    else
      error [currentPointerIR location] : "this object should be a structure"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleStandAloneRoutineCallInInstruction
  ?let @lstring inFunctionName
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments
  ?!@instructionListIR ioInstructionGenerationList
{
#--- Get function name and map containing the function definition
  let routineMangledName = routineMangledNameFromCall (!"" !inFunctionName !inArguments)
#--- Get called function signature
  let signature = [inArguments routineSignature !inFunctionName.location]
#--- Search function in map
  [ioUniversalMap searchRoutine
    !inFunctionName
    !signature
    ?let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
  ]
#  let isPublic = routineDescriptor.mIsPublic
  let routineKind = routineDescriptor.mRoutineKind
  let calleeMode = [routineKind executionMode]
  let formalSignature = routineDescriptor.mSignature
#--- Check routine is actually a function
  if routineDescriptor.mReturnTypeProxy != .null then
    error inFunctionName : "not a procedure (returns a value)" : routineDescriptor
  else
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:inMode
      !calleeMode:calleeMode
      !kind:routineKind
      !error:inFunctionName.location
    )
  #--- Analyze effective parameters
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    analyzeEffectiveParametersNew (
      !self:inSelfType
      !formal:formalSignature
      !effective:inArguments
      !errorLocation:inFunctionName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempVariable (![routineDescriptor.mReturnTypeProxy type] !routineMangledName !?ioTemporaries ?let functionResult)
  #--- Code generation
    ioInstructionGenerationList += !@staticRoutineCallIR.new {
      !"" # No global variable as receiver
      !functionResult
      !routineMangledName
      !LLVMInvocationRoutineName
      !calleeKind
      !effectiveParameterListIR
    }
  #--- Enter in invocation graph
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleMethodCallInInstruction
  ?let @lstring inMethodName
  ?let @objectIR inCurrentPointerIR
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments 
  ?let @string inGlobalVariableReceiverName
  ?!@instructionListIR ioInstructionGenerationList
{
  [[inCurrentPointerIR type] structure ?2* ?universalMap:var currentMap ?3*]
  let routineMangledName = routineMangledNameFromCall (!"$" + [[inCurrentPointerIR type] key] !inMethodName !inArguments)
#--- Get called function signature
  let signature = [inArguments routineSignature !inMethodName.location]
#--- Search function in map
  [currentMap searchRoutine
    !inMethodName
    !signature
    ?let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
  ]
#--- Check routine is actually a function
  if routineDescriptor.mReturnTypeProxy != .null then
    error inMethodName : "this method is a function (returns a value)"
  else
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:inMode
      !calleeMode:[routineDescriptor.mRoutineKind executionMode]
      !kind:routineDescriptor.mRoutineKind
      !error:inMethodName.location
    )
  #--- Add receiver as first parameter ?
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    switch routineDescriptor.mRoutineCallingScheme
    case staticCall :
      effectiveParameterListIR += !.outputInput !inCurrentPointerIR # Add receiver as first argument
    case propertyIndirectCall (*) :
    end
  #--- Analyze effective parameters
    analyzeEffectiveParametersNew (
      !self:inSelfType
      !formal:routineDescriptor.mSignature
      !effective:inArguments
      !errorLocation:inMethodName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- Generate call
    switch routineDescriptor.mRoutineCallingScheme
    case staticCall :
    #--- Code generation
      ioInstructionGenerationList += !@staticRoutineCallIR.new {
        !inGlobalVariableReceiverName
        !.null # No result
        !routineMangledName
        !LLVMInvocationRoutineName
        !calleeKind
        !effectiveParameterListIR
      }
    #--- Enter in invocation graph
      [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
    case propertyIndirectCall (type) :
      let propertyReference = @objectIR.temporaryReference {
         !type:type
         !llvmName:.new {!"temp." + ioTemporaries.mTemporaryIndex !inMethodName}
         !sliceMap:{}
         !volatile:false
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !propertyReference
        !inCurrentPointerIR
        !inMethodName
      ]
    #--- Code generation
      ioInstructionGenerationList += !@indirectRoutineCallIR.new {
        !propertyReference
        !type
        !.null # No result
        !effectiveParameterListIR
      }
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @complexCallSelfInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  [mAssignmentTargetAST analyzeAssignmentTarget
    !self: inSelfType
    !targetAccessKind:.read # § .readWrite
    !propertiesAreMutable: inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed: inDirectAccessToPropertiesAllowed
    !routineNameForInvocationGraph: inCallerNameForInvocationGraph
    !context: inContext
    !mode: inCurrentMode
    !?temporary: ioTemporaries
    !?staticStringMap: ioGlobalLiteralStringMap
    !?variableMap: ioVariableMap
    !?variableMap:ioUniversalMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?@objectIR currentObject
    ?globalVariableReceiverName:let globalVariableReceiverName
  ]
#--- Analyze procedure call arguments
  handleFunctionCallInExpression (
    !self:inSelfType
    !globalVariableReceiverName:globalVariableReceiverName
    !propertiesAreMutable:inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !mArguments
    !mEndOfArguments
    !?ioInstructionGenerationList
    !?currentObject
    ?let returnedType
  )
  if returnedType != .void then
    error mEndOfArguments : "the function cannot be called in instruction: lost return value"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @objectIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @calleeKindIR {
  case function
  case primitiveFromProcessorUserMode
  case safeFromProcessorUserMode
  case sectionFromProcessorUserMode
  case serviceFromProcessorUserMode
  case primitiveFromProcessorPrivilegedMode
  case sectionFromProcessorPrivilegedMode
  case safeFromProcessorPrivilegedMode
  case serviceFromProcessorPrivilegedMode
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

