#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @callInstructionAST : @instructionAST {
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#·······················································································································

class @standAloneProcedureCallInstructionAST : @callInstructionAST {
  @lstring mSandAloneRoutineName
}

#·······················································································································

class @procedureCallInstructionAST : @callInstructionAST {
  @lstring mIdentifier
  @accessInAssignmentListAST mAccessList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@ast ioAST ?!@instructionListAST ioInstructionList {
    <procedure_call> !?ioAST ?let routineCallInstruction
    ioInstructionList += !routineCallInstruction
  }

  #·····················································································································

  rule <procedure_call> ?!@ast ioAST !@callInstructionAST outInstruction {
    let instructionLocation = @location.here
    <lvalue> !?ioAST ?let assignmentTargetAST
    <effective_parameters> !?ioAST ?let arguments ?let endOfArguments
    if ([[assignmentTargetAST mAccessList] length] == 0) & (assignmentTargetAST.mIdentifier.string != "") then
      outInstruction = @standAloneProcedureCallInstructionAST.new {
        !instructionLocation
        !arguments
        !endOfArguments
        !assignmentTargetAST.mIdentifier
      }
    else
      outInstruction = @procedureCallInstructionAST.new {
        !instructionLocation
        !arguments
        !endOfArguments
        !assignmentTargetAST.mIdentifier
        !assignmentTargetAST.mAccessList
      }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procedureCallInstructionAST noteInstructionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (access) in mAccessList do
    switch access
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#·······················································································································

override method @standAloneProcedureCallInstructionAST noteInstructionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveArgumentPassingModeAST passingModeForActualSelector ?let @lstring inSelector -> @string {
  switch self
  case input (*) : result = "?"
  case inputWithType (* * *) : result = "?"
  case output (* *) : result = "!"
  case outputInput (*) : result = "!?"
  case outputInputSelfVariable (*) : result = "!?"
  end
  if inSelector.string != "" then
    result += inSelector.string + ":"
  end
}

#·······················································································································

list @procEffectiveParameterList {
  @effectiveArgumentPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @PLMType mParameterType
}

#·······················································································································

override method @standAloneProcedureCallInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Called routine signature
  let calledRoutineSignature = [mArguments routineSignature !mSandAloneRoutineName.location]
#--- Search routine in map
  [inContext.mRoutineMapForContext searchKey
    !""
    !mSandAloneRoutineName
    !calledRoutineSignature
    ?let @lstring LLVMInvocationRoutineName
    ?let @routineDescriptor routineDescriptor
    ?let @location unused keyLocation
  ]
#--- Routine name for invocation graph
  let routineMangledName = routineMangledNameFromCall (
    !""
    !mSandAloneRoutineName
    !mArguments
  )
#--- Enter in invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
#--- Check modes
  let routineKindIR = checkMode (
    !callerMode:inCurrentMode
    !calleeMode:[routineDescriptor.routineKind executionMode]
    !kind:routineDescriptor.routineKind
    !error:mSandAloneRoutineName.location
  )
#--- Analyze effective parameters
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  analyzeEffectiveParameters (
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !formal:routineDescriptor.signature
    !effective:mArguments
    !errorLocation:mSandAloneRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredMode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )

#--- Code generation
  ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
    !""
    !.null
    !routineMangledName
    !LLVMInvocationRoutineName
    !routineKindIR
    !effectiveParameterListIR
  }
}

#·······················································································································

override method @procedureCallInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze header identifier : it is a variable, as a standalone procedure call is handled in an other place
#    If identifier is empty string, the receiver is "self"
  @PLMType currentType
  @string currentLLVMAddressVar
  if mIdentifier.string == "" then # Receiver is self
    if inSelfType.kind == .void then
      error mIdentifier : "self is not available in this context" : currentType, currentLLVMAddressVar
    else
      currentType = inSelfType
      currentLLVMAddressVar = llvmNameForSelf ()
    end
  else
    [ioUniversalMap searchEntity !mIdentifier ?let @valuedObject entity]
    switch entity
    case task (@PLMType type) :
      currentType = type
      currentLLVMAddressVar = llvmNameForGlobalVariable (!mIdentifier)
    case driver (@PLMType type instancied) :
      if instancied then
        currentType = type
        currentLLVMAddressVar = llvmNameForGlobalVariable (!mIdentifier)
      else
        error mIdentifier : "the driver should be instancied" : currentType, currentLLVMAddressVar
      end
    case registerGroup (*) :
      error mIdentifier
        : "a control register constant cannot be used in this context"
        : currentType, currentLLVMAddressVar
    case globalConstant (*) :
      error mIdentifier
        : "a global constant cannot be used in this context"
        : currentType, currentLLVMAddressVar
    case localConstant (@PLMType type @lstring plmName *) :
      currentType = type
      currentLLVMAddressVar = llvmNameForLocalVariable (!plmName)
    case localVariable (@PLMType type @lstring plmName) :
      currentType = type
      currentLLVMAddressVar = llvmNameForLocalVariable (!plmName)
    case globalSyncInstance (@PLMType type @lstring plmName) :
      currentType = type
      currentLLVMAddressVar = llvmNameForGlobalSyncInstance (!plmName)
    end
  end
#--- Get current object property map
  @propertyMap currentObjectPropertyMap = currentType.propertyMap
#--- Insulate last access (should be a "property", used as routine name
  var accessList = mAccessList
  [!?accessList popLast ?let lastAccess]
#--- loop on access list
  for (access) in accessList do
    switch access
    case property (@lstring propertyName) :
      [currentObjectPropertyMap searchKey
        !propertyName
        ?let @bool unused isPublic
        ?let @propertyAccessKind propertyAccess
      ]
      switch propertyAccess
      case nonVirtualMethod (*) :
         error propertyName : "a method cannot be used in this context" : currentType, currentLLVMAddressVar
      case constantProperty (*) :
        error propertyName
          : "a context property cannot be used in this context"
          : currentType, currentLLVMAddressVar
      case indexed (@PLMType propertyType @uint propertyIndex) :
        [!?ioTemporaries newTempLLVMVar ?let llvmPropertyName]
        [!?ioInstructionGenerationList appendGetUniversalPropertyReference
          !currentType
          !currentLLVMAddressVar
          !llvmPropertyName
          !propertyIndex
          !propertyName
        ]
        currentType = propertyType
        currentLLVMAddressVar = llvmPropertyName
        currentObjectPropertyMap = currentType.propertyMap # ????
      end
    case arrayAccess (@expressionAST unused indexExpression @location endOfIndex) :
      error endOfIndex : "not handled yet" : currentType, currentLLVMAddressVar
    end
  end
#--- Handle last access
  switch lastAccess
  case arrayAccess (* @location endOfIndex) :
    error endOfIndex : "a property access is required here"
  case property (@lstring methodName) :
#    let propertyMap = currentType.propertyMap
    let propertyMap = currentObjectPropertyMap # ????
    let key = routineMangledNameFromCall (!"" !methodName !mArguments)
    [propertyMap searchKey !key ?* ?let @propertyAccessKind propertyAccess]
    switch propertyAccess
    case constantProperty (*) :
      error methodName : "a constant cannot be used as method"
    case nonVirtualMethod (@routineDescriptor routineDescriptor) :
    #--- Add receiver as first parameter
      @procCallEffectiveParameterListIR effectiveParameterListIR = {
        !.outputInput
        !.reference {!type:currentType !llvmName:currentLLVMAddressVar}
      }
    #---
    #  let isPublic = routineDescriptor.mIsPublic
      let routineKind = routineDescriptor.routineKind
      let calleeMode = [routineKind executionMode]
      let formalSignature = routineDescriptor.signature
    #--- If method mutates its properties, check it is allowed 
    #    note that mIdentifier.string is empty string if call instruction is self. ...
      if (mIdentifier.string == "") && routineDescriptor.canMutateProperties && not [inRoutineAttributes mutating] then
        error methodName
        : "cannot mutate properties, current method is not declared with @" + mutatingAttribute () + " attribute"
      end
    #--- Check routine is actually a procedure (does not return any value)
      if routineDescriptor.returnTypeProxy != .null then
        error methodName : "not a procedure (returns a value)"
      else
      #--- Check modes
        let calleeKind = checkMode (
          !callerMode:inCurrentMode
          !calleeMode:calleeMode
          !kind:routineKind
          !error:methodName.location
        )
      #--- Analyze effective parameters
        analyzeEffectiveParameters (
          !self:inSelfType
          !routineAttributes:inRoutineAttributes
          !formal:formalSignature
          !effective:mArguments
          !errorLocation:methodName.location
          !callerForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !requiredMode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !?instructionListIR:ioInstructionGenerationList
          !?effectiveIR:effectiveParameterListIR
        )
      #--- Get function name and map containing the function definition
        let routineMangledName = routineMangledNameFromCall (!llvmTypeStringFromPLMname (!currentType.plmOriginalTypeName) !methodName !mArguments)
      #--- Code generation
        ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
          !mIdentifier
          !.null # No result
          !routineMangledName
          !routineMangledName # LLVMInvocationRoutineName
          !calleeKind
          !effectiveParameterListIR
        }
      #--- Enter in invocation graph
        [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
      end
    case indexed  (@PLMType propertyType @uint propertyIndex) :
      if not [propertyType.kind isFunction] then
        error methodName : "an indexed property cannot be used as method"
      else
        [propertyType.kind function ?descriptor:let descriptor]
      #--- Check routine is actually a function
        if descriptor.returnTypeProxy != .null then
          error methodName : "a function returns a value and cannot be called as a procedure"
        else
        #--- Check modes
#          let calleeKind = checkMode (
#            !callerMode:inMode
#            !calleeMode:mode
#            !kind:routineDescriptor.mRoutineKind
#            !error:inMethodName.location
#          )
        #--- Analyze effective parameters
          @procCallEffectiveParameterListIR effectiveParameterListIR = {}
          analyzeEffectiveParameters (
            !self:inSelfType
            !routineAttributes:inRoutineAttributes
            !formal:descriptor.signature
            !effective:mArguments
            !errorLocation:methodName.location
            !callerForInvocationGraph:inCallerNameForInvocationGraph
            !context:inContext
            !requiredMode:inCurrentMode
            !?temporary:ioTemporaries
            !?staticStringMap:ioGlobalLiteralStringMap
            !?variableMap:ioUniversalMap
            !?alloca:ioAllocaList
            !?instructionListIR:ioInstructionGenerationList
            !?effectiveIR:effectiveParameterListIR
          )
        #--- Load routine reference
          [!?ioTemporaries newTempLLVMVar ?let property_llvmName]
          [!?ioInstructionGenerationList appendGetUniversalPropertyReference
            !currentType
            !currentLLVMAddressVar
            !property_llvmName
            !propertyIndex
            !methodName
          ]
        #--- Code generation
          ioInstructionGenerationList += !@indirectRoutineCallIR.new {
            !.reference {!type:propertyType !llvmName:property_llvmName}
            !propertyType
            !.null # Function does not return any value
            !effectiveParameterListIR
          }
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#·······················································································································

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @objectIR mParameter
}

#·······················································································································

enum @calleeKindIR {
  case function
  case primitiveFromProcessorUserMode
  case sectionFromProcessorUserMode
  case serviceFromProcessorUserMode
  case primitiveFromProcessorPrivilegedMode
  case sectionFromProcessorPrivilegedMode
  case serviceFromProcessorPrivilegedMode
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
