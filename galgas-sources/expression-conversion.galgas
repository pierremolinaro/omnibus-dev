#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @conversionExpressionAST : @expressionAST {
  @expressionAST mExpression
  @lstring mTypeName
  @bool mSilently
  @location mEndOfExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @conversionExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*
#! @conversionExpressionAST
#----------------------------------------------------------------------------------------------------------------------*

override method @conversionExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let convertedExpressionType
    ?result:@variableKindIR expressionResult
  ]
#--- 
  if (not inAllowExceptions) && (not mSilently) then
    error mTypeName : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
  end
#--- Analyze type
  outExpressionType = .searchKey {!inContext.mTypeMap !mTypeName}
#--- Check types
  if not [[outExpressionType kind] isInteger] then
    error mTypeName : "this type is not an integer type"
  elsif not [[convertedExpressionType kind] isInteger] then
    error mEndOfExpression : "expression type is not an integer type"
  else
      [[convertedExpressionType kind] integer ?min:let minSource ?max:let maxSource ?unsigned:* ?bitCount:*]
      [[outExpressionType kind] integer ?min:let minTarget ?max:let maxTarget ?unsigned:* ?bitCount:*]
      let alwaysPossible = (minTarget <= minSource) && (maxTarget >= maxSource)
      if alwaysPossible then
        error mTypeName:"useless explicit conversion"
      end
  end
#--- Temp var
  getNewTempVariable (!?ioTemporaries ?outResult)
#--- Generate code
  ioInstructionGenerationList += !@conversionInstructionIR.new {
    !outExpressionType
    !convertedExpressionType
    !outResult
    !expressionResult
    !mSilently
    !mTypeName.location
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @conversionInstructionIR
#----------------------------------------------------------------------------------------------------------------------*

class @conversionInstructionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @unifiedTypeMap-proxy mConvertedExpressionType
  @variableKindIR mTemporaryResultVariable
  @variableKindIR mOperand
  @bool mSilently
  @location mLocation
}

#----------------------------------------------------------------------------------------------------------------------*

override method @conversionInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @conversionInstructionIR instructionCode -> @string outCode {
  if mSilently || [option plm_options.noExceptionGeneration value] then
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mTemporaryResultVariable mangledName]
    outCode += " = ((" + mangledNameForType (!name:[mTargetType key]) + ") " + [mOperand mangledName] + ") ;\n"
  else
    let okVar = "ok" + [mLocation locationIndex]
    [[mConvertedExpressionType kind] integer ?min:let minSource ?max:let maxSource ?unsigned:* ?bitCount:*]
    [[mTargetType kind] integer ?min:let minTarget ?max:let maxTarget ?unsigned:* ?bitCount:*]
    outCode = "const bool " + okVar + " = "
    if minTarget > minSource then
      outCode += "(" + [mOperand mangledName] + " >= " + minTarget + ")"
    end
    if maxTarget < maxSource then
      if minTarget > minSource then
        outCode += " && "
      end
      outCode += "(" + [mOperand mangledName] + " <= " + maxTarget + ")"
    end
    outCode += " ;\n"
    outCode += "if (!" + okVar + ") {\n"
    outCode += "  raise_exception (5, "
       + [[[mLocation file] lastPathComponent] utf8Representation]
       + ", " + [mLocation line] + ") ;\n"
    outCode += "}\n" 
    outCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mTemporaryResultVariable mangledName]
    outCode += " = ((" + mangledNameForType (!name:[mTargetType key]) + ") " + [mOperand mangledName] + ") ;\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @conversionInstructionIR llvmInstructionCode ?!@string ioCode {
  if mSilently || [option plm_options.noExceptionGeneration value] then
    ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mTemporaryResultVariable mangledName]
    ioCode += " = ((" + mangledNameForType (!name:[mTargetType key]) + ") " + [mOperand mangledName] + ") ;\n"
  else
    let okVar = "ok" + [mLocation locationIndex]
    [[mConvertedExpressionType kind] integer ?min:let minSource ?max:let maxSource ?unsigned:* ?bitCount:*]
    [[mTargetType kind] integer ?min:let minTarget ?max:let maxTarget ?unsigned:* ?bitCount:*]
    ioCode += "const bool " + okVar + " = "
    if minTarget > minSource then
      ioCode += "(" + [mOperand mangledName] + " >= " + minTarget + ")"
    end
    if maxTarget < maxSource then
      if minTarget > minSource then
        ioCode += " && "
      end
      ioCode += "(" + [mOperand mangledName] + " <= " + maxTarget + ")"
    end
    ioCode += " ;\n"
    ioCode += "if (!" + okVar + ") {\n"
    ioCode += "  raise_exception (5, "
       + [[[mLocation file] lastPathComponent] utf8Representation]
       + ", " + [mLocation line] + ") ;\n"
    ioCode += "}\n" 
    ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mTemporaryResultVariable mangledName]
    ioCode += " = ((" + mangledNameForType (!name:[mTargetType key]) + ") " + [mOperand mangledName] + ") ;\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*
