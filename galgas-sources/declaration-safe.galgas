#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @safeDeclarationListAST {
  @lstring mSafeName
  @bool mPublic
  @lstringlist mSafeAttributeList
  @procFormalArgumentList mSafeFormalArgumentList
  @lstring mReturnTypeName
  @instructionListAST mSafeInstructionList
  @location mEndOfSafeLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <safe> ?!@safeDeclarationListAST ioSafeListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $safe$
    $identifier$ ?let safeName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let safeFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      $\$type$ ?returnTypeName
    end
    ${$
    <instructionList> ?let instructionList
    $}$
    ioSafeListAST +=
      !safeName
      !public
      !attributeList
      !safeFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @safeDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mSafeFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mSafeInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @safeDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for safe in self do
  #--- Signature
    var routineMangledName = if inReceiverTypeName == "" then
      safe.mSafeName
    else
      @lstring.new {!inReceiverTypeName + "." + safe.mSafeName !safe.mSafeName.location}
    end
    @procedureSignature signature = {}
    routineMangledName.string += "("
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in safe.mSafeFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
      routineMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
    end
    routineMangledName.string += ")"
    let returnType = if safe.mReturnTypeName.string == "" then
      @unifiedTypeMap-proxy.null
    else
      @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !safe.mReturnTypeName}
    end
  #--- Attributes
    var mutating = false
    for (attribute) in safe.mSafeAttributeList do
      if attribute.string == mutatingAttribute () then
        mutating = true    
      end
    end
  #--- Enter in context
    [!?ioContext.mRoutineMapForContext insertKey
      !routineMangledName
      !routineMangledName
      !safe.mPublic
      !false
      !.userMode
      !signature
      !.safe
      !false # Not weak
      !returnType
      !false # No appendFileAndLineArgumentForPanicLocation
      !mutating # canMutateProperties
      !true # canAccessPropertiesInUserMode
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @safeDeclarationListAST sectionSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for safe in self do
    var mutating = false
    var noUnusedWarning = false
    for (attribute) in safe.mSafeAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if noUnusedWarning then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute" fixit { remove }
        end
        noUnusedWarning = true    
      elsif attribute.string == mutatingAttribute () then
        if mutating then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute" fixit { remove }
        end
        mutating = true    
      else
        error attribute 
        : "unknown attribute; available attributes are @" + mutatingAttribute () + ", @" + mutatingAttribute ()
        fixit { remove }
      end
    end
    routineSemanticAnalysis (
      !receiverType:inReceiverType
      !.safe
      !.safeMode
      !safe.mSafeName
      !safe.mSafeFormalArgumentList
      !returnTypeName:safe.mReturnTypeName
      !safe.mSafeInstructionList
      !safe.mEndOfSafeLocation
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:mutating
      !warnIfUnused:not noUnusedWarning
      !globalFunction:true
      !weakFunction:false
#      !registerAccess:.readWriteAccess
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR safeCodeGeneration
  ?!@string ioLLVMcode
  ?!@2stringlist ioSafeList
{
  for safe in self do
    if safe.mKind == .safe then
      let safeCallName = llvmNameForSafeCall (!safe.mRoutineNameForGeneration.string)
      let safeImplementationName = llvmNameForSafeImplementation (!safe.mRoutineNameForGeneration.string)
      ioSafeList += !safeCallName !safeImplementationName
      ioLLVMcode += llvmTitleComment (!safeCallName)
      ioLLVMcode += "declare"
      if safe.mReturnType == .null then
        ioLLVMcode += " void"
      else
        ioLLVMcode += " " + [safe.mReturnType llvmTypeName]
      end
      ioLLVMcode += " @" + safeCallName + " ("
      var first = true
      if safe.mReceiverType != .null then
        ioLLVMcode += [safe.mReceiverType llvmTypeName] + " * %receiver"
        first = false
      end
      for () in safe.mFormalArgumentListForGeneration do
        if first then
          first = false
        else
          ioLLVMcode += ", "
        end
        switch mFormalArgumentKind
        case input :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
        case output :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
       case inputOutput :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
        end
      end
      ioLLVMcode += ")" + llvmAttributeFunction () + "\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

