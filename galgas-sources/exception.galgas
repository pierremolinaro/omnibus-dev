#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

struct @exceptionAST {
  @location mExceptionLocation
  @instructionListAST mExceptionInstructionList
  @location mEndOfExceptionInstructions
  @bool mExceptionDefined
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $exception$
    let loc = @location.here
    if ioAST.mException.mExceptionDefined then
      error loc : "exception clause already defined"
    end
    ${$
    <instructionList> ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mException.mExceptionLocation = loc
    ioAST.mException.mExceptionInstructionList = instructionList
    ioAST.mException.mEndOfExceptionInstructions = endOfInstructionList
    ioAST.mException.mExceptionDefined = true
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

func %once exceptionModeName -> @string outResult {
  outResult = "exception"
}

#----------------------------------------------------------------------------------------------------------------------*

method @exceptionAST exceptionSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@uint ioTemporaryIndex
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  if mExceptionDefined then
    if not [inContext.mModeMap hasKey !exceptionModeName ()] then
      error mExceptionLocation : "the $exception mode should be defined in order to use an exception clause"
    end
  #--- Variable map
    @variableMap variableMap = initialVariableMap (!context:inContext !globalsAreConstant:false)
  #--- Insert predefined input arguments
    let uintType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !["UInt32" nowhere]}
    let StaticStringType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !["StaticString" nowhere]}
    let codeArg = @lstring.new {!"CODE" !mExceptionLocation}
    [!?variableMap insertUsedConstantInputFormalArgument
      !codeArg
      !uintType
      !{!exceptionModeName ()}
      !mangledNameForInArgument (!name:codeArg.string)
      !.inArgument {!name:codeArg}
      ![uintType copiable]
    ]
    let fileArg = @lstring.new {!"FILE" !mExceptionLocation}
    [!?variableMap insertUsedConstantInputFormalArgument
      !fileArg
      !StaticStringType
      !{!exceptionModeName ()}
      !mangledNameForInArgument (!name:fileArg.string)
      !.inArgument {!name:fileArg}
      ![StaticStringType copiable]
    ]
    let lineArg = @lstring.new {!"LINE" !mExceptionLocation}
    [!?variableMap insertUsedConstantInputFormalArgument
      !lineArg
      !uintType
      !{!exceptionModeName ()}
      !mangledNameForInArgument (!name:lineArg.string)
      !.inArgument {!name:lineArg}
      ![uintType copiable]
    ]
  #--- Analyze instruction list
    @instructionListIR instructionGenerationList = {}
    [mExceptionInstructionList analyzeRoutineInstructionList
      !optionalReceiverType:.noReceiver
      !context:inContext
      !mode:exceptionModeName ()
      !allowException:false
      !?temporary:ioTemporaryIndex
      !?staticStringMap:ioIntermediateCodeStruct.mGlobalLiteralStringMap
      !?variableMap:variableMap
      !?generatedCode:instructionGenerationList
    ]
  #---
    [variableMap checkAutomatonStates !mEndOfExceptionInstructions]
  #--- Code generation
    ioIntermediateCodeStruct.mExceptionInstructionListIR = instructionGenerationList
  end
}

#----------------------------------------------------------------------------------------------------------------------*

