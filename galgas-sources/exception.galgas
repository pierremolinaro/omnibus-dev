#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @exceptionTypesAST {
  @lstring mExceptionCodeTypeName
  @lstring mExceptionLineTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

sortedlist @exceptionClauseListAST {
  @lstring mExceptionClauseName
  @instructionListAST mExceptionInstructionList
  @location mEndOfExceptionInstructions
  @uint64 mPriority
  @location mLocationPriority
}{
  mPriority <
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $exception$
    $identifier$ ?let exceptionClauseName
    $integer$ ?let priority
    ${$
    <instructionList> ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mExceptionClauses +=
      !exceptionClauseName
      !instructionList
      !endOfInstructionList
      !priority.uint64
      !priority.location
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $exception$
    $:$
    $identifier$ ?let exceptionCodeTypeName 
    $identifier$ ?let exceptionLineTypeName
    ioAST.mExceptionTypes += !exceptionCodeTypeName !exceptionLineTypeName
  }
  
  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

method @exceptionClauseListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
  if mExceptionClauseName.string == "setup" then
    [!?ioContext.mExceptionSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mLocationPriority}]
  elsif mExceptionClauseName.string == "loop" then
    [!?ioContext.mExceptionLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mLocationPriority}]
  else
    error mExceptionClauseName : "exception routine name should be \"setup\" or \"loop\""
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

func %once exceptionModeName -> @string outResult {
  outResult = "exception"
}

#----------------------------------------------------------------------------------------------------------------------*

map @exceptionRoutinePriorityMap {
  insert insertSetupKey error message "an exception setup routine with priority %K has been already declared"
  insert insertLoopKey error message "an exception loop routine with priority %K has been already declared"
  search searchSetupKey error message "there is no exception setup routine with priority %K"
  search searchLoopKey error message "there is no  exception loop routine with priority %K"
}

#----------------------------------------------------------------------------------------------------------------------*

method @exceptionClauseListAST-element exceptionSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  if not [inContext.mModeMap hasKey !exceptionModeName ()] then
    error mExceptionClauseName : "the $" + exceptionModeName () + " mode should be defined in order to use an exception clause"
  end
  let routineNameForInvocationGraph = @lstring.new  {
    !"exception " + mExceptionClauseName + " " + mPriority
    !mExceptionClauseName.location
  }
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineMangledName:routineNameForInvocationGraph.string
    !context:inContext
    !globalsAreConstant:false
  )
#--- Insert predefined input arguments
  let StaticStringType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !["StaticString" nowhere]}
  let codeArg = @lstring.new {!"CODE" !mExceptionClauseName.location}
  [!?variableMap insertUsedConstantInputFormalArgument
    !codeArg
    !inContext.mExceptionCodeType
    !true
    !mangledNameForInArgument (!name:codeArg.string)
    !.inArgument {!name:codeArg.string}
    ![inContext.mExceptionCodeType copiable]
    !{}
    !false
  ]
  let fileArg = @lstring.new {!"FILE" !mExceptionClauseName.location}
  [!?variableMap insertUsedConstantInputFormalArgument
    !fileArg
    !StaticStringType
    !true
    !mangledNameForInArgument (!name:fileArg.string)
    !.inArgument {!name:fileArg.string}
    ![StaticStringType copiable]
    !{}
    !false
  ]
  let lineArg = @lstring.new {!"LINE" !mExceptionClauseName.location}
  [!?variableMap insertUsedConstantInputFormalArgument
    !lineArg
    !inContext.mExceptionLineType
    !true
    !mangledNameForInArgument (!name:lineArg.string)
    !.inArgument {!name:lineArg.string}
    ![inContext.mExceptionLineType copiable]
    !{}
    !false
  ]
#---
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mExceptionInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !optionalReceiverType:.noReceiver
    !context:inContext
    !modes:{!exceptionModeName ()}
    !allowException:false
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mGlobalLiteralStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfExceptionInstructions]
#--- Code generation
  if mExceptionClauseName.string == "setup" then
    [!?ioTemporaries.mExceptionSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mLocationPriority}]
    ioIntermediateCodeStruct.mExceptionSetupInstructionListIR += instructionGenerationList
  elsif mExceptionClauseName.string == "loop" then
    [!?ioTemporaries.mExceptionLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mLocationPriority}]
    ioIntermediateCodeStruct.mExceptionLoopInstructionListIR += instructionGenerationList
  else
    error mExceptionClauseName : "exception routine name should be \"setup\" or \"loop\""
  end
}

#----------------------------------------------------------------------------------------------------------------------*

