#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @syncDeclarationAST : @abstractDeclarationAST {
  @lstring mSyncToolName
  @structurePropertyListAST mStructurePropertyListAST
  @functionDeclarationListAST mFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mSystemRoutineListAST
  @guardDeclarationListAST mGuardListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $sync$
    $\$type$ ?let structureName
    ${$
    @functionDeclarationListAST procedureDeclarationListAST = {}
    @structurePropertyListAST fieldList = {}
    @systemRoutineDeclarationListAST systemRoutineListAST = {}
    @guardDeclarationListAST guardListAST = {}
    repeat
    while
      <private_or_public_struct_property_declaration> !?ioAST !?fieldList !singletonObject:false
    while
      <function> !?ioAST !?procedureDeclarationListAST
    while
      <system_routine> !?ioAST !?systemRoutineListAST
    while
      <guard> !?ioAST !?guardListAST
    end
    $}$
    ioAST.mDeclarationListAST += !@syncDeclarationAST.new {
      !structureName
      !fieldList
      !procedureDeclarationListAST
      !systemRoutineListAST
      !guardListAST
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @syncDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add structure type name as node
  [!?ioGraph addNode !mSyncToolName !self]
#--- Add property types
  for (propertyName 2* public fieldTypeName initExpression *) in mStructurePropertyListAST do
    if fieldTypeName.string != "" then
      [!?ioGraph addEdge !mSyncToolName !fieldTypeName]
    end
    if public then
      error propertyName : "a sync tool property cannot be public (should be private)"
    end
    switch initExpression
    case noExpression :
    case expression (initExpression) :
      [initExpression addDependenceEdgeForStaticExpression !mSyncToolName !?ioGraph]
    end
  end
#--- Add structure functions
  for () in mFunctionDeclarationListAST do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    if mFunctionReturnTypeName.string != "" then
      [!?ioGraph noteNode !mFunctionReturnTypeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
#--- Add structure services, section, primitives and guards
  [mSystemRoutineListAST noteTypesInPrecedenceGraph !?ioGraph]
  [mGuardListAST noteTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override getter @syncDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "synctype." + mSyncToolName 
}

#·······················································································································

override getter @syncDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mSyncToolName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @syncDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
#---------------------------------------- Self type proxy
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !mSyncToolName ?let selfTypeProxy]
#---------------------------------------- Properties
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @sortedOperandIRList sortedOperandIRList = {}
  @constructorSignature constructorSignature = {}
  @string constructorKey = "("
  for property in mStructurePropertyListAST do
    [property enterPropertyInContext
      !mSyncToolName
      !?context:ioContext
      !?staticEntityMap:ioStaticEntityMap
      !?propertyList
      !?propertyMap
      !?sortedOperandIRList
      !?constructorSignature
      !?constructorKey
      !?*
      !?ioGlobalVariableIRList
    ]
  end
  constructorKey += ")"
#---------------------------------------- Constructor map
  @constructorMap constructorMap = {}
  [!?constructorMap insertKey
    !.new {!constructorKey !mSyncToolName.location}
    !constructorSignature
    !.structure {!sortedOperandList:sortedOperandIRList}
  ]
#---------------------------------------- Enter functions in property map
  [mFunctionDeclarationListAST enterFunctionsInPropertyMap !mSyncToolName !?context:ioContext !?propertyMap]
#---------------------------------------- Enter system routines in property map
  for system in mSystemRoutineListAST do
  #--- Attributes
    @stringset attributeSet = {}
    for attribute in system.mAttributeList do
      attributeSet += !attribute.mValue.string
    end
    let exportedRoutine = [attributeSet hasKey !exportedAttribute ()]
    let canMutateProperties = [attributeSet hasKey !mutatingAttribute ()]
  #--- Routine mangled name
    let routineMangledName = routineMangledNameFromAST (
      !mSyncToolName
      !system.mName
      !system.mFormalArgumentList
    )
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !system.mFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !system.mReturnTypeName ?let returnTypeProxy]
  #--- Attributes
    var mutating = false
    var noUnusedWarning = false
    var isSafe = false
    for (attribute) in system.mAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if noUnusedWarning then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute" fixit { remove }
        end
        noUnusedWarning = true    
      elsif attribute.string == mutatingAttribute () then
        if mutating then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute" fixit { remove }
        end
        mutating = true    
      elsif attribute.string == safeAttribute () then
        if isSafe then
          error attribute : "duplicated @" + safeAttribute () + " attribute" fixit { remove }
        end
        isSafe = true    
      else
        error attribute 
        : "unknown attribute; available attributes are @" + mutatingAttribute () + ", @" + mutatingAttribute ()
        fixit { remove }
      end
    end
  #--- Routine descriptor
    var s = mSyncToolName.string + "."
    s += system.mName.string
    s += "("
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in system.mFormalArgumentList do
      s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
    end
    s += ")"
    let descriptor = @routineDescriptor.new {
      !isPublic:system.mPublic
      !exported:exportedRoutine
      !name:system.mName
      !nameForLLVMGeneration:s # routineMangledName
      !routineKind:system.mRoutineKind
      !signature:signature
      !returnTypeProxy:returnTypeProxy
      !canAccessProperties:true
      !canMutateProperties:canMutateProperties
      !safe:isSafe
    }
  #--- Enter in structure map
    [!?propertyMap insertKey !routineMangledName !system.mPublic !.nonVirtualMethod {!descriptor:descriptor}]
  #--- 
  #--- Routine mangled names
    let userRoutineMangledName = systemUserMangledNameFromAST (
      !mSyncToolName
      !system.mRoutineKind
      !system.mName
      !system.mFormalArgumentList
    )
    let implementationRoutineMangledName = systemImplementationMangledNameFromAST (
      !mSyncToolName
      !system.mRoutineKind
      !system.mName
      !system.mFormalArgumentList
    )
    ioRoutineListIR += !@systemUserRoutineIR.new {
      !userRoutineMangledName
      !false
      !false
      !implementationRoutineMangledName
      !signature
      !selfTypeProxy
      !system.mRoutineKind == .section # If false, service or primitive
      !returnTypeProxy
    }
    @mode mode
    switch system.mRoutineKind
    case section : mode = .sectionMode
    case primitive : mode = .primitiveMode
    case service : mode = .serviceMode
    case function (*) : error system.mEndOfInstructionListLocation : "INTERNAL ERROR" : mode
    end
    @routineAttributes attributes = .mutating | .directPropertyAccess | .controlRegisterReadable
    if not isSafe then
      attributes = attributes | .panicAllowed
    end
    ioDecoratedRoutineList +=
      !mSyncToolName
      !mode
      !false
      !.function {!executionMode: mode}
      !noUnusedWarning
      !true # mExportedRoutine
      !attributes
      !implementationRoutineMangledName
      !system.mFormalArgumentList
      !system.mInstructionList
      !system.mEndOfInstructionListLocation
      !system.mReturnTypeName  # Empty string if no returned value
  end
#---------------------------------------- Enter guards in guard map
  @guardMapForContext guardMap = {}
  for guard in mGuardListAST do
  #--- Guard mangled name
    let guardMangledName = guardUserMangledNameFromAST (
      !mSyncToolName
      !guard.mGuardName
      !guard.mGuardFormalArgumentList
    )
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !guard.mGuardFormalArgumentList ?let signature)
  #--- Enter in context
    [!?guardMap insertKey
      !guardMangledName
      !guard.mIsPublic
      !signature
    ]
  end
#---------------------------------------- Enter in type map
  let structureType = @PLMType.new {
    !propertyMap:propertyMap
    !classConstantMap:{}
    !constructorMap:constructorMap
    !guardMap:guardMap
    !attributes:.instanciable
    !plmTypeDescriptionName:mSyncToolName # "sync " + mSyncToolName
    !kind:.syncTool {!propertyList:propertyList}
    !llvmBaseTypeName:mSyncToolName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:mSyncToolName
    !type:structureType
    !index:[ioContext.mTypeMap count]
    !generate:true
  ]
#---------------- Enter decorated functions
  for function in mFunctionDeclarationListAST do
    var warnIfUnused = true
    var functionAttributes = @routineAttributes.panicAllowed | .controlRegisterReadable
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == userAccessAttribute () then
        if [functionAttributes directPropertyAccess] then
          error attribute : "duplicated @" + userAccessAttribute () + " attribute"
        end
        functionAttributes = functionAttributes | .directPropertyAccess   
      elsif attribute.string == safeAttribute () then
        if not [functionAttributes panicAllowed] then
          error attribute : "duplicated @" + safeAttribute () + " attribute"
        end
        functionAttributes = functionAttributes - .panicAllowed   
      elsif attribute.string == mutatingAttribute () then
        if [functionAttributes mutating] then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        functionAttributes = functionAttributes | .mutating    
      else
        error attribute : "unknown attribute; available attributes are @" + noUnusedWarningAttribute ()
          + ", @" + mutatingAttribute () + " and @" + userAccessAttribute ()
      end
    end
    let functionMangledName = routineMangledNameFromAST (!mSyncToolName !function.mFunctionName !function.mFunctionFormalArgumentList)
    ioDecoratedRoutineList +=
      !mSyncToolName
      !function.mMode
      !false
      !.function {!executionMode: function.mMode}
      !warnIfUnused
      !false # mExportedRoutine
      !functionAttributes
      !functionMangledName
      !function.mFunctionFormalArgumentList
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !function.mFunctionReturnTypeName  # Empty string if no returned value
  end
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedStructureDeclaration.new {
    !mSyncToolName
    !mGuardListAST
    !false # Do not implement deinit
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

