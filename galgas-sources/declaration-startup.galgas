#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @startupAST : @abstractDeclarationAST {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @location mStartupLocation
  @instructionListAST mInstructionList
  @location mEndOfStartupLocation
}

#·······················································································································

list @startupListAST {
  @startupAST mStartup
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration_startup> ?!@ast ioAST ?let @lstring inDriverName  ?let @lstringlist inDependanceList !@startupAST outInit {
    $startup$
    let initLocation = @location.here
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfStartup = @location.here
    $}$
    outInit = .new {!inDriverName !inDependanceList !initLocation !instructionList !endOfStartup}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @startupAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @startupAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {!"startup " + mDriverName !mStartupLocation}
 [!?ioGraph addNode !nodeName !self]
 [!?ioGraph addEdge !nodeName !mDriverName]
 for (dependanceDriverName) in mDriverDependanceList do
   let dependanceNodeName = @lstring.new {!"startup " + dependanceDriverName !dependanceDriverName}
   [!?ioGraph addEdge !nodeName !dependanceNodeName]
 end
}

#·······················································································································

override getter @startupAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "startup " + mDriverName 
}

#·······················································································································

override getter @startupAST location -> @location outLocation {
  outLocation = mStartupLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @startupAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @startupAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
   let routineNameForInvocationGraph = initNameForInvocationGraph (!llvmDriverNameFromName (!mDriverName) !mStartupLocation)
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedStartupRoutine.new {
    !mDriverName
    !mDriverDependanceList
    !mInstructionList
    !mEndOfStartupLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedStartupRoutine : @abstractDecoratedDeclaration {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @instructionListAST mInstructionList
  @location mEndOfStartupLocation
}

#·······················································································································

override method @decoratedStartupRoutine routineSemanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#·······················································································································

override method @decoratedStartupRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let selfType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !llvmDriverNameFromName (!mDriverName)} type]
  startupSemanticAnalysis (
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
    !selfType:selfType
    !location:mDriverName.location
    !instructionList:mInstructionList
    !endOfDeclaration:mEndOfStartupLocation
    ?let @allocaList allocaList
    ?let @instructionListIR instructionGenerationList
  )
#--- Build initialized driver set
  ioTemporaries.mInitializedDriverSet += !mDriverName.string
#--- Code generation
  ioIntermediateCodeStruct.mStartupList +=
    !selfType
    !mDriverName
    !allocaList
    !instructionGenerationList
}

#·······················································································································

private proc startupSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  ?selfType:let @PLMType inSelfType
  ?location:let @location inLocation
  ?instructionList:let @instructionListAST inInstructionListAST
  ?endOfDeclaration:let @location inEndOfStartupDeclaration
  !@allocaList outAllocaList
  !@instructionListIR outInstructionGenerationList
{
#--- Check init routine is unique
  let routineNameForInvocationGraph = initNameForInvocationGraph (!inSelfType.plmOriginalTypeName !inLocation)
#---
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
  end
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
#--- Analyze instruction list
  outInstructionGenerationList = {}
  outAllocaList = {}
  [inInstructionListAST analyzeRoutineInstructionList
    !self:inSelfType
    !routineAttributes:.mutating | .directPropertyAccess | .controlRegisterReadable
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.startupMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
    !?variableMap:universalMap
    !?alloca:outAllocaList
    !?generatedCode:outInstructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState !?outInstructionGenerationList]
  [!?universalMap closeBranch !inEndOfStartupDeclaration]
  [!?universalMap closeOverride !inEndOfStartupDeclaration]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @startupListIR {
  @PLMType mSelfType
  @string mDriverName
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
}

#·······················································································································

method @startupListIR generateLLVMinitCode
  ?!@string ioLLVMcode
  ?let @routineMapIR unused inProcedureMapIR
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Startup")
  ioLLVMcode += "define internal void @startup ()" + llvmAttributeFunction () + "{\n"
  for init in self do
    ioLLVMcode += "  call void @startup." + init.mDriverName + " ("
    ioLLVMcode += [init.mSelfType llvmTypeName] + "* " + llvmNameForGlobalVariable (!init.mDriverName)
    ioLLVMcode += ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
  for startup in self do
    ioLLVMcode += llvmSeparatorLine () + "\n"
    ioLLVMcode += "define internal void @startup." + startup.mDriverName + " ("
    if startup.mSelfType.kind != .void then
      ioLLVMcode += [startup.mSelfType llvmTypeName] + "* " + llvmNameForSelf ()
    end
    ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
    [startup.mAllocaList generateAllocaList !?ioLLVMcode]
    [startup.mInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
