
setter @instructionListIR appendGetArrayElementReference
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?arrayReference:let @objectIR inArrayIR
  ?index:let @objectIR inIndexIR
  !elementPtr:@objectIR outElementPtr
{
  [!?ioTemporaries newTempLLVMVar ?let llvmName]
  [[inArrayIR type].kind arrayType ?elementType:let elementType ?1*]
  outElementPtr = @objectIR.reference {!type:elementType !llvmName:llvmName}
  self += !@getArrayElementReferenceIR.new {!outElementPtr !inArrayIR !inIndexIR}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @getArrayElementReferenceIR : @abstractInstructionIR {
  @objectIR mTarget
  @objectIR mArray
  @objectIR mIndex
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @getArrayElementReferenceIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [[mArray type] llvmTypeName]
  ioLLVMcode += "  " + [mTarget llvmName] + " = getelementptr inbounds "
  ioLLVMcode += llvmType + ", " + llvmType + " * " + [mArray llvmName] + ", i32 0, " + [mIndex llvmTypeName]
             + " " + [mIndex llvmName]
             + " ; Element of index " + [mIndex llvmName] + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @getArrayElementReferenceIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
