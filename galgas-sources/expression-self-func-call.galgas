#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @selfFunctionCallInExpressionAST : @expressionAST {
  @location mSelfLocation
  @fieldList mFieldList
  @effectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    <self_access> ?let selfLocation ?var fieldList
    <effective_parameters> ?let @effectiveParameterListAST effectiveParameterList ?*
    outExpression = @selfFunctionCallInExpressionAST.new {!selfLocation !fieldList !effectiveParameterList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfFunctionCallInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfFunctionCallInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfFunctionCallInExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Last field is method name, array access not allowed
  var fieldList = mFieldList
  [!?fieldList popLast ?let functionName ?let arrayAccess]
  if [arrayAccess isAccess] then
    error functionName : "array access not allowed here"
  end
#--- Function call not allowed in guard
  if inGuard then
    error functionName : "a function cannot be called in guard expression"
  end
#--- Self access analysis
  analyzeSelfAccess (
    !fieldList:fieldList
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.null
    !context:inContext
    !modes:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?resultPtr:let @objectInMemoryIR propertyAddressLLVMvar
  )
#--- Routine mangled name
  let receiverType = [propertyAddressLLVMvar type]
  var routineMangledName = @lstring.new {!"$" + [receiverType key] + "." + functionName !functionName.location}
  routineMangledName.string += "("
  for (passingMode selector) in mEffectiveParameterList do
    routineMangledName.string += [passingMode matchingFormalArgument]
    routineMangledName.string += selector.string
    routineMangledName.string += ":"
  end
  routineMangledName.string += ")"
#---
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  effectiveParameterListIR += !.outputInput !.selfObject {!type:receiverType}
  [inContext.mRoutineMapForContext searchKey
    !routineMangledName
    ?let routineNameForGeneration
    ?let isPublic
    ?let modeMap
    ?let @procedureSignature formalSignature
    ?let @routineKind routineKind
    ?*
    ?let returnedType
    ?let appendFileAndLineArgumentForPanicLocation
    ?let canMutateProperties
    ?let canAccessPropertiesInUserMode
  ]
  if (routineKind == .function) && canAccessPropertiesInUserMode && not inDirectAccessToPropertiesAllowed then
    error functionName : "the callee accesses properties, the current function should be declared with @"
       + userAccessAttribute () + " attribute"
  end
  if canMutateProperties then
    error functionName : "a function should not mutate properties"
  end
#--- Check accessibility
  if ([fieldList length] > 0) && not isPublic then
    error functionName : "this function is not public"
  end  
#--- Enter in invocation graph
#  @lstring routineNameForInvocationGraph
#  switch routineKind
#  case function :
#    routineNameForInvocationGraph = procNameForInvocationGraph (!receiverType !functionName)
#  case section :
#    routineNameForInvocationGraph = sectionNameForInvocationGraph (!receiverType !functionName)
#  case service :
#    routineNameForInvocationGraph = serviceNameForInvocationGraph (!receiverType !functionName)
#  case primitive :
#    routineNameForInvocationGraph = primitiveNameForInvocationGraph (!receiverType !functionName)
#  end
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForGeneration]
#--- Check modes
  let routineKindIR = checkMode (
    !requiredModes:inRequiredModeSet
    !possibleModes:[modeMap keySet]
    !kind:routineKind
    !error:functionName.location
  )
#--- Analyze effective parameters
  analyzeEffectiveParameters (
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !propertiesAreMutable:false
    !formal:formalSignature
    !effective:mEffectiveParameterList
    !errorLocation:functionName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )
  if returnedType == .null then
    error functionName : "cannot be called in expression: no return value"
  end
#--- New LLVM variable for function call result
  getNewTempVariable (!returnedType !?ioTemporaries ?outResult)
#--- Code generation
  ioInstructionGenerationList += !@functionCallIR.new {
    !outResult
    !routineMangledName
    !routineNameForGeneration
    !routineKindIR
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @selfVariableFunctionCallInExpressionAST analyzeExpression
#  ?self:let @unifiedTypeMap-proxy inSelfType
#  ?inGuard:let @bool inGuard
#  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
#  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
#  ?context:let @semanticContext inContext
#  ?modes:let @stringset inRequiredModeSet
#  ?allowPanic:let @bool inAllowPanic
#  ?!temporary:@semanticTemporariesStruct ioTemporaries
#  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
#  ?!variableMap:@variableMap ioVariableMap
#  ?!alloca:@allocaList ioAllocaList
#  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
#  !result:@objectIR outResult
#{
#  if inGuard then
#    error mFunctionName : "a function cannot be called in guard expression"
#  end
##--- Analyze self type -- should be a structure
#  @propertyMap propertyMap
#  switch [inSelfType kind]
#  case structure (propMap *) : propertyMap = propMap
#  case enumeration (*) : propertyMap = {}
#  case integer (* * * *) : propertyMap = {}
#  case staticInteger : propertyMap = {}
#  case boolean : propertyMap = {}
#  case boolset : propertyMap = {}
#  case literalString : propertyMap = {}
#  case opaque (*) : propertyMap = {}
#  case arrayType (* *) : propertyMap = {}
#  end
#  [propertyMap searchKey !mFieldName ?* ?let fieldType ?let fieldIndex]
##--- Get field pointer
#  getLocalNameOfNewTempObjectInMemory (!fieldType !?ioTemporaries ?let fieldPtr)
#  [!?ioInstructionGenerationList appendGetElementPtrFromSelf !fieldPtr !inSelfType !{!.absolute {!index:fieldIndex} !mFieldName.string}]
#  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
#  effectiveParameterListIR += !.outputInput ![fieldPtr address]
##--- Analyze call
#  let routineMangledName = @lstring.new {!"$" + [fieldType key] + "." + mFunctionName !mFunctionName.location}
#  [inContext.mRoutineMapForContext searchKey
#    !routineMangledName
#    ?let isPublic
#    ?let modeMap
#    ?let @procedureSignature formalSignature
#    ?let @routineKind routineKind
#    ?*
#    ?let returnedType
#    ?let appendFileAndLineArgumentForPanicLocation
#  ]
##--- Check accessibility
#  if not isPublic then
#    let @string declarationFile = [[inContext.mRoutineMapForContext locationForKey !routineMangledName.string] file]
#    let invocationFile = [mFunctionName.location file]
#    if invocationFile != declarationFile then
#      error mFunctionName : "this function is not public"
#    end
#  end  
##--- Enter in invocation graph
#  @lstring routineNameForInvocationGraph
#  switch routineKind
#  case function :
#    routineNameForInvocationGraph = procNameForInvocationGraph (!fieldType !mFunctionName)
#  case section :
#    routineNameForInvocationGraph = sectionNameForInvocationGraph (!fieldType !mFunctionName)
#  case service :
#    routineNameForInvocationGraph = serviceNameForInvocationGraph (!fieldType !mFunctionName)
#  case primitive :
#    routineNameForInvocationGraph = primitiveNameForInvocationGraph (!fieldType !mFunctionName)
#  end
#  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForInvocationGraph]
##--- Check modes
#  let routineKindIR = checkMode (
#    !requiredModes:inRequiredModeSet
#    !possibleModes:[modeMap keySet]
#    !kind:routineKind
#    !error:mFunctionName.location
#  )
##--- Analyze effective parameters
#  analyzeEffectiveParameters (
#    !self:inSelfType
#    !formal:formalSignature
#    !effective:mEffectiveParameterList
#    !errorLocation:mFunctionName.location
#    !callerForInvocationGraph:inCallerNameForInvocationGraph
#    !context:inContext
#    !requiredModeSet:inRequiredModeSet
#    !allowPanic:inAllowPanic
#    !?temporary:ioTemporaries
#    !?staticStringMap:ioGlobalLiteralStringMap
#    !?variableMap:ioVariableMap
#    !?alloca:ioAllocaList
#    !?instructionListIR:ioInstructionGenerationList
#    !?effectiveIR:effectiveParameterListIR
#  )
#  if returnedType == .null then
#    error mFunctionName : "cannot be called in expression: no return value"
#  end
##--- New LLVM variable for function call result
#  getNewTempVariable (!returnedType !?ioTemporaries ?outResult)
##--- Code generation
#  ioInstructionGenerationList += !@functionCallIR.new {
#    !outResult
#    !routineMangledName.string
#    !routineKindIR
#    !effectiveParameterListIR
#    !appendFileAndLineArgumentForPanicLocation
#  }
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
