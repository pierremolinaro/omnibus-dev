
enum @llvmBinaryOperation {
  case addNoOVF
  case subNoOVF
  case mulNoOVF
  case udivNoOVF
  case sdivNoOVF
  case uremNoOVF
  case sremNoOVF

  case uaddOVF
  case saddOVF
  case usubOVF
  case ssubOVF
  case umulOVF
  case smulOVF
  case udivOVF
  case sdivOVF
  case uremOVF
  case sremOVF

  case and
  case ior
  case xor
  case shl
  case ashr
  case lshr
  
  case icmp_eq
  case icmp_ne
  case icmp_ult
  case icmp_ule
  case icmp_ugt
  case icmp_uge
  case icmp_slt
  case icmp_sle
  case icmp_sgt
  case icmp_sge
}

#----------------------------------------------------------------------------------------------------------------------*

setter @instructionListIR appendBinaryOperation
  ?let @valueIR inTarget
  ?let @unifiedTypeMap-proxy inOperandType
  ?let @location inLocation
  ?let @valueIR inLeft
  ?let @llvmBinaryOperation inOperation
  ?let @valueIR inRight
{
  self += !@binaryOperationIR.new {!inTarget !inOperandType !inLeft !inOperation !inRight !inLocation}
}

#----------------------------------------------------------------------------------------------------------------------*

class @binaryOperationIR : @abstractInstructionIR {
  @valueIR mTarget
  @unifiedTypeMap-proxy mOperandType
  @valueIR mLeft
  @llvmBinaryOperation mOperation
  @valueIR mRight
  @location mLocation
}

#----------------------------------------------------------------------------------------------------------------------*

override method @binaryOperationIR enterAccessibleEntities ?!@accessibleEntities unused ioAccessibleEntities {
}

#----------------------------------------------------------------------------------------------------------------------*

method @binaryOperationIR enterCodeForOverflowOperation 
  ?let @string inOperation
  ?let @uint inCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  [!?ioGenerationAdds.mStaticStringMap findOrAddStaticString 
    ![[[mLocation file] lastPathComponent] stringByDeletingPathExtension]
    ?let staticStringIndex
  ]
  let llvmType = [mOperandType llvmTypeName]
  ioLLVMcode += "  " + mTarget + ".r = call {" + llvmType + ", i1} @llvm." + inOperation + ".with.overflow." + llvmType
  ioLLVMcode += " (" + llvmType + " " + mLeft + ", " + llvmType + " " + mRight + ")\n"
  ioLLVMcode += "  " + mTarget + ".hasOvf = extractvalue {" + llvmType + ", i1} " + mTarget + ".r, 1\n"
  let labelName = [mTarget name]
  ioLLVMcode += "  br i1 " + mTarget + ".hasOvf, label %" + labelName + ".ovf, label %" + labelName + ".noovf\n\n"
  ioLLVMcode += labelName + ".ovf:\n"
  ioLLVMcode += "  %" + labelName + ".str = load i8*, i8** " + literalStringName (!staticStringIndex) + "\n"
  ioLLVMcode += "  call void @raise_exception ("
  ioLLVMcode += inGenerationContext.mExceptionLineLLVMType + " " + [mLocation line] + ", "
  ioLLVMcode += inGenerationContext.mExceptionCodeLLVMType + " " + inCode + ", "
  ioLLVMcode += "i8* %" + labelName + ".str)\n"
  ioLLVMcode += "  unreachable\n\n"
  ioLLVMcode += labelName + ".noovf:\n"
  ioLLVMcode += "  " + mTarget + " = extractvalue {" + llvmType + ", i1} " + mTarget + ".r, 0\n"
  ioGenerationAdds.mIntrinsicsDeclarationSet += !"declare {" + llvmType + ", i1} @llvm." + inOperation + ".with.overflow."
     + llvmType + " (" + llvmType + " %a, " + llvmType + " %b)"
}

#----------------------------------------------------------------------------------------------------------------------*

method @binaryOperationIR enterCodeForDivisionWithZeroDivisorException 
  ?let @string inOperation
  ?let @uint inCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  [!?ioGenerationAdds.mStaticStringMap findOrAddStaticString
    ![[[mLocation file] lastPathComponent] stringByDeletingPathExtension]
    ?let staticStringIndex
  ]
  let llvmType = [mOperandType llvmTypeName]
  ioLLVMcode += "  " + mRight + ".isZero = icmp eq " + llvmType + " " + mRight + ", 0\n"
  let labelName = [mTarget name]
  ioLLVMcode += "  br i1 " + mRight + ".isZero, label %" + labelName + ".divideByZero, label %" + labelName + ".ok\n\n"
  ioLLVMcode += labelName + ".divideByZero:\n"
  ioLLVMcode += "  %" + labelName + ".str = load i8*, i8** " + literalStringName (!staticStringIndex) + "\n"
  ioLLVMcode += "  call void @raise_exception ("
  ioLLVMcode += inGenerationContext.mExceptionLineLLVMType + " " + [mLocation line] + ", "
  ioLLVMcode += inGenerationContext.mExceptionCodeLLVMType + " " + inCode + ", "
  ioLLVMcode += "i8* %" + labelName + ".str)\n"
  ioLLVMcode += "  unreachable\n\n"
  ioLLVMcode += labelName + ".ok:\n"
  ioLLVMcode += "  " + mTarget + " = " + inOperation + " " + llvmType + " " + mLeft + ", " + mRight + "\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @binaryOperationIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let llvmType = [mOperandType llvmTypeName]
  switch mOperation
  case addNoOVF :
    ioLLVMcode += "  " + mTarget + " = add " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case subNoOVF :
    ioLLVMcode += "  " + mTarget + " = sub " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case mulNoOVF :
    ioLLVMcode += "  " + mTarget + " = mul " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case udivNoOVF :
    ioLLVMcode += "  " + mTarget + " = udiv " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case sdivNoOVF :
    ioLLVMcode += "  " + mTarget + " = sdiv " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case uremNoOVF :
    ioLLVMcode += "  " + mTarget + " = urem " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case sremNoOVF :
    ioLLVMcode += "  " + mTarget + " = srem " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case uaddOVF :
    [self enterCodeForOverflowOperation
      !"uadd"
      !10
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case saddOVF :
    [self enterCodeForOverflowOperation
      !"sadd"
      !10
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case usubOVF :
    [self enterCodeForOverflowOperation
      !"usub"
      !11
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case ssubOVF :
    [self enterCodeForOverflowOperation
      !"ssub"
      !11
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case umulOVF :
    [self enterCodeForOverflowOperation
      !"umul"
      !12
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case smulOVF :
    [self enterCodeForOverflowOperation
      !"smul"
      !12
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case udivOVF :
    [self enterCodeForDivisionWithZeroDivisorException
      !"udiv"
      !13
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case sdivOVF :
    [self enterCodeForDivisionWithZeroDivisorException
      !"sdiv"
      !13
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case uremOVF :
    [self enterCodeForDivisionWithZeroDivisorException
      !"urem"
      !14
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case sremOVF :
    [self enterCodeForDivisionWithZeroDivisorException
      !"srem"
      !14
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  case and :
    ioLLVMcode += "  " + mTarget + " = and " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case ior :
    ioLLVMcode += "  " + mTarget + " = or " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case xor :
    ioLLVMcode += "  " + mTarget + " = xor " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case shl :
    ioLLVMcode += "  " + mTarget + " = shl " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case ashr :
    ioLLVMcode += "  " + mTarget + " = ashr " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case lshr :
    ioLLVMcode += "  " + mTarget + " = lshr " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_eq :
    ioLLVMcode += "  " + mTarget + " = icmp eq " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_ne :
    ioLLVMcode += "  " + mTarget + " = icmp ne " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_ult :
    ioLLVMcode += "  " + mTarget + " = icmp ult " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_ule :
    ioLLVMcode += "  " + mTarget + " = icmp ule " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_ugt :
    ioLLVMcode += "  " + mTarget + " = icmp ugt " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_uge :
    ioLLVMcode += "  " + mTarget + " = icmp uge " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_slt :
    ioLLVMcode += "  " + mTarget + " = icmp slt " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_sle :
    ioLLVMcode += "  " + mTarget + " = icmp sle " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_sgt :
    ioLLVMcode += "  " + mTarget + " = icmp sgt " + llvmType + " " + mLeft + ", " + mRight + "\n"
  case icmp_sge :
    ioLLVMcode += "  " + mTarget + " = icmp sge " + llvmType + " " + mLeft + ", " + mRight + "\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*
