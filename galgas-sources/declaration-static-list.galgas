#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticlistPropertyListAST {
  @lstring mPropertyName
  @lstring mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticlistAST : @abstractDeclaration {
  @lstring mStaticListName
  @staticlistPropertyListAST mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticlistAST location -> @location {
  result = mStaticListName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticlistAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticlist$
    $identifier$ ?let staticListName
    ${$
    @staticlistPropertyListAST propertyList = {}
    repeat
      $let$
      $identifier$ ?let propertyName
      $\$type$ ?let typeName
      propertyList += !propertyName !typeName
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticlistAST.new {!staticListName !propertyList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add 'constant name' node
  [!?ioGraph addNode !mStaticListName !self]
#---
  for (* propertyTypeName) in mPropertyList do
    let typeName = @lstring.new {!"$" + propertyTypeName !propertyTypeName.location}
    [!?ioGraph addEdge !mStaticListName !typeName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticlistPropertyList {
  @lstring mPropertyName
  @unifiedTypeMap-proxy mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @staticlistPropertyList mStaticlistPropertyList

  insert insertKey error message "static list '%K' is already defined"
  search searchKey error message "static list '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  @staticlistPropertyList staticlistPropertyList = {}
  @stringset propertyNameSet = {}
  for (propertyName propertyTypeName) in mPropertyList do
    let propertyType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName}
    if [propertyNameSet hasKey !propertyName] then
      error propertyName : "duplicated property name"
    end
    propertyNameSet += !propertyName
    staticlistPropertyList += !propertyName !propertyType
  end
  [!?ioContext.mStaticlistMap insertKey
    !mStaticListName
    !staticlistPropertyList
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistMap generateLLVM ?!@string ioLLVMcode {
  if [self count] > 0 then
    ioLLVMcode += llvmTitleComment (!"Static List Element Types")
    for (lkey propertyList) in self do
      ioLLVMcode += "%static.list.type." + lkey + " = type {"
      for (* propertyType) in propertyList
      do
        ioLLVMcode += [propertyType llvmTypeName]
      between
        ioLLVMcode += ", "
      end
      ioLLVMcode += "}\n"
    end
    ioLLVMcode += "\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
