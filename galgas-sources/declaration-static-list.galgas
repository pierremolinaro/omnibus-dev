#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @staticListPropertyTypeAST {
  case valueType (@lstring type)
  case function (@mode mode @bool safe @routineFormalArgumentListAST formalArgs @lstring returnType)
}

#·······················································································································

list @staticListPropertyListAST {
  @lstring mPropertyName
  @staticListPropertyTypeAST mPropertyType
}

#·······················································································································

class @staticListAST : @abstractDeclarationAST {
  @lstring mStaticListName
  @staticListPropertyListAST mPropertyList
  @staticListValueListAST mValueList
}

#·······················································································································

list @staticListValueListAST {
  @extendStaticListElementListAST mExpressions
}

#·······················································································································

enum @extendStaticListExpressionAST {
  case expression (@expressionAST exp)
  case function (@lstring functionName @routineFormalArgumentListAST formalArgs)
}

#·······················································································································

list @extendStaticListElementListAST {
  @extendStaticListExpressionAST mExpression
  @location mEndOfExpression
}

#·······················································································································

list @extendStaticArrayDeclarationAST {
  @lstring mStaticListName
  @extendStaticListElementListAST mExpressions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticArray$
    $identifier$ ?let staticListName
    ${$
    @staticListPropertyListAST propertyList = {}
    repeat
      <staticArrayProperty>!?ioAST !?propertyList
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticListAST.new {!staticListName !propertyList !{}}
  }

  #·····················································································································

  rule <staticArrayProperty> ?!@ast ioAST ?!@staticListPropertyListAST ioPropertyList {
    $let$
    $identifier$ ?let propertyName
    select
      <type_definition> !?ioAST ?let typeName
      ioPropertyList += !propertyName !.valueType{!type:typeName}
    or
      $func$
      <mode> ?let mode
      @lstringlist attributeList = {}
      repeat
      while
        $@attribute$ ?let attribute
        attributeList += !attribute
      end
      <procedure_formal_arguments> !?ioAST ?let formalArgs
      @lstring returnType
      select
        returnType = ["" here]
      or
        $->$
        <type_definition>!?ioAST ?returnType
      end
      var isSafe = false
      for (attribute) in attributeList do
        if attribute.string == safeAttribute () then
          if isSafe then
            error attribute : "duplicated attribute" fixit { remove }
          else
            isSafe = true
          end
        else
          error attribute : "invalid attribute" fixit {replace "@" + safeAttribute () }
        end
      end
      ioPropertyList += !propertyName !.function{!mode:mode !safe:isSafe !formalArgs:formalArgs !returnType:returnType}
    end
  }

  #·····················································································································
  # STATIC ARRAY VALUE
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticArray$
    $identifier$ ?let staticListName
    $($
    repeat
      @extendStaticListElementListAST expressions = {}
      repeat
        <staticArray_exp> !?ioAST !?expressions
      while
        $,$
      end
      ioAST.mExtendStaticArrayDeclarationAST += !staticListName !expressions
    while
      $::$
    end
    $)$
  }

  #·····················································································································

  rule <staticArray_exp> ?!@ast ioAST ?!@extendStaticListElementListAST ioExpressions {
    select
      <expression> !?ioAST ?let exp
      ioExpressions += !.expression {!exp:exp} !.here
    or
      $func$
      $identifier$ ?let functionName
      <procedure_formal_arguments> !?ioAST ?let formalArgs
      ioExpressions +=
        !.function {!functionName:functionName !formalArgs:formalArgs}
        !.here
    end
   }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticListAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add node
  [!?ioGraph addNode !mStaticListName !self]
#--- Add dependency edges for type declaration
  for (* type) in mPropertyList do
    switch type
    case valueType (@lstring propertyTypeName) :
      [!?ioGraph addEdge !mStaticListName !propertyTypeName]
    case function (* * @routineFormalArgumentListAST formalArgs @lstring returnType) :
      for (* * formalArgumentTypeName *) in formalArgs do
        [!?ioGraph noteNode !formalArgumentTypeName]
      end
      if returnType.string != "" then
        [!?ioGraph addEdge !mStaticListName !returnType]
      end
    end
  end
#--- Add dependency edge for static type values declarations
  for (value) in mValueList do
    for (operand *) in value do
      switch operand
      case expression (@expressionAST exp) :
        [exp addDependenceEdgeForStaticExpression !mStaticListName !?ioGraph]
      case function (* @routineFormalArgumentListAST formalArgs) :
        for (* * formalArgumentTypeName *) in formalArgs do
          [!?ioGraph noteNode !formalArgumentTypeName]
        end
      end
    end
  end
}

#·······················································································································

override getter @staticListAST locationForErrorSignaling -> @location {
  result = mStaticListName.location
}

#·······················································································································

override getter @staticListAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Static list
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func plmNameForStaticListType ?let @lstring inStaticListName -> @lstring {
  result = .new {!"staticlist " + inStaticListName !inStaticListName}
}

#·······················································································································

private func llvmNameForStaticListType ?let @lstring inStaticListName -> @lstring {
  result = .new {!"staticlist-" + inStaticListName !inStaticListName}
}

#·······················································································································

private func plmNameForStaticListElementType ?let @lstring inStaticListName -> @lstring {
  result = .new {!"staticlist element " + inStaticListName !inStaticListName}
}

#·······················································································································

private func llvmNameForStaticListElementType ?let @lstring inStaticListName -> @lstring {
  result = .new{!"staticlist-element-type-" + [inStaticListName assemblerRepresentation] !inStaticListName.location}
}

#·······················································································································

map @staticlistMap {
  @propertyList mStaticListPropertyList

  insert insertKey error message "static list '%K' is already defined"
}

#·······················································································································

map @staticListInitializationMap {
  @stringlist mInitializationList

  insert insertKey error message "static list '%K' is already defined"
}

#·······················································································································

override method @staticListAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
  @routineMapCTXT routineMap = {}
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @stringset propertyNameSet = {}
  let plmElementTypeName = plmNameForStaticListElementType (!mStaticListName)
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !plmElementTypeName ?let elementTypeProxy]
#-------------------------------------------------------------------- Build property list, map
  for (propertyName kind) in mPropertyList do (propertyIndex)
    switch kind
    case valueType (@lstring propertyTypeName) :
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName} type]
      if [propertyNameSet hasKey !propertyName] then
        error propertyName : "duplicated property name"
      else
        propertyNameSet += !propertyName
        propertyList += !propertyName !propertyType
        [!?propertyMap insertKey
          !propertyName
          !true # Public
          !.indexed{!type:propertyType !index:propertyIndex}
        ]
      end
    case function (@mode mode @bool safe @routineFormalArgumentListAST formalArgs @lstring returnTypeName) :
    #--- Routine LLVM name
      let routineLLVMName = routineMangledNameFromAST (
        !llvmNameForStaticListElementType (!mStaticListName)
        !propertyName
        !formalArgs
      )
    #--- Signature
      routineTypedSignature (!?ioContext.mTypeMap !formalArgs ?let signature)
      let @unifiedTypeMap-proxy returnTypeProxy = if returnTypeName.string == "" then
        .null
      else
        @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !returnTypeName}
      end
      let descriptor = @routineDescriptor.new {
        !isPublic:true # Routine is declared with "public"
        !exported:false # Routine is declared with @exported attribute
        !name:propertyName
        !nameForLLVMGeneration:routineLLVMName
        !routineKind:.function {!executionMode:mode} # @routineKind mRoutineKind
        !signature:signature
        !returnTypeProxy:returnTypeProxy 
        !canAccessProperties:true # Routine is declared with @access attribute
        !canMutateProperties:true # Routine is declared with @mutating attribute
        !safe:safe # Routine is declared with @safe attribute
      }
      let type = functionType (!descriptor)
      if not [ioContext.mTypeMap hasKey !routineLLVMName] then
        [!?ioContext.mTypeMap insertType
          !lkey:routineLLVMName
          !type:type
          !index:[ioContext.mTypeMap count]
          !generate:false
        ]
      end
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !routineLLVMName} type]
      propertyList += !propertyName !propertyType
    #--- Ex
      [!?propertyMap insertKey
        !routineLLVMName # propertyName
        !true # Public
        !.indexed{!type:propertyType !index:propertyIndex}
      ]
    #--- Enter in routine map
      let routineMangledName = @lstring.new {
        !propertyName.string + [formalArgs routineSignature !propertyName]
        !propertyName
      }
      [!?routineMap insertKey
        !routineMangledName
        !true
        !signature
        !returnTypeProxy
        !{!.userMode !routineLLVMName}
        !true
        !false
        !.userMode
      ]
    #--- Generate glue function
#      routineTypedSignature !?ioContext.mTypeMap !
#                           ?let @routineFormalArgumentListAST inFormalArgumentList
#                           !@routineTypedSignature outSignature
      ioRoutineListIR += !@staticListIndirectRoutineIR.new {
        !routineLLVMName
        !true
        !true
        !elementTypeProxy
        !signature
        !returnTypeProxy # .void if no return value
        !propertyIndex
      }
    end
  end
  [!?ioContext.mStaticListMap insertKey !mStaticListName !propertyList]
#-------------------------------------------------------------------- Enter element type in type map
  let type = @PLMType.new {
    !propertyMap:propertyMap
    !routineMap: routineMap
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.none
    !plmTypeDescriptionName:plmNameForStaticListElementType (!mStaticListName)
    !kind:.structure {!propertyList:propertyList}
    !llvmBaseTypeName:llvmNameForStaticListElementType (!mStaticListName)
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmElementTypeName
    !type:type
    !index:[ioContext.mTypeMap count]
    !generate:true
  ]
#-------------------------------------------------------------------- Enter static list values
  @stringlist stringValueList = {}
  for value in mValueList do
    if [propertyList length] != [value.mExpressions length] then
      error mStaticListName
      : [[propertyList length] string] + " expressions required, "
      + [[value.mExpressions length] string] + " provided"
    else
      var staticValue = "{"
      for (operand endOfExp) in value.mExpressions, (* type) in propertyList do
        switch operand
        case expression (@expressionAST exp) :
          if [type.kind isFunction] then
            error endOfExp : "a function name is expected here"
          else
            @semanticTemporariesStruct temporaries = .default
            @instructionListIR instructionGenerationList = {}
            @allocaList allocaList = {}
            [exp analyzeExpression
              !self:voidType ()
              !routineAttributes:.none
              !optionalTargetType:type
              !context:ioContext
              !mode:.bootMode
              !?temporary:temporaries
              !?staticEntityMap:ioStaticEntityMap
              !?variableMap:ioContext.mValuedObjectMap # universalMap
              !?alloca:allocaList
              !?instructionListIR:instructionGenerationList
              ?result:let @objectIR expressionResult
            ]
          #--- Check assignment compatibility
            let result = checkAssignmentCompatibility (
              !source:expressionResult
              !targetAnnotationType:type
              !errorLocation:endOfExp
              !staticTypeAllowed:false
            )
            if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [result isStatic] then
              error endOfExp : "source expression cannot be statically computed"
            end
          #--- Enter in static value
            staticValue += [type llvmTypeName] + " " + [expressionResult llvmName]
          end      
        case function (@lstring functionName @routineFormalArgumentListAST formalArgs) :
          if not [type.kind isFunction] then
            error endOfExp : "a static expression is expected here"
          else
            [type.kind function ?descriptor:let descriptor]
            let argumentSignature = [formalArgs routineSignature !functionName]
            let functionMangledName = @lstring.new {!functionName.string + argumentSignature !functionName}
            [ioContext.mRoutineMap searchKey
              !functionMangledName
              ?let unused candidateIsPublic
              ?let candidateSignature
              ?let candidateReturnTypeProxy # null if no returned value
              ?let implementedModeDictionary
              ?let unused implementedIsSafe
              ?let unused implementedIsExported
              ?let candidateMode
            ]
          #--- Check accessibility
#            if not candidateIsPublic then
#              let declarationFile = [functionDefinitionLocation file]
#              let invocationFile = [functionName.location file]
#              if invocationFile != declarationFile then
#                error functionName : "this function is not public"
#              end
#            end
            @string routineLLVMName
            if [implementedModeDictionary hasKey !.userMode] then
              [implementedModeDictionary searchKey !.userMode ?routineLLVMName]
            elsif [implementedModeDictionary hasKey !.anyMode] then
              [implementedModeDictionary searchKey !.anyMode ?routineLLVMName]
            else
              error functionName : "the function should be callable from user mode" :routineLLVMName
            end
            let currentMode = [descriptor.routineKind executionMode]
            if currentMode != candidateMode then
              error functionName : "this function runs in " + candidateMode + " mode, but " + currentMode + " is required"
            end
            if (descriptor.returnTypeProxy == .null) && (candidateReturnTypeProxy != .null) then
              error functionName : "this function should return an $" + [candidateReturnTypeProxy key] + " object"
            elsif (descriptor.returnTypeProxy != .null) && (candidateReturnTypeProxy == .null) then
              error functionName : "this function should return no object"
            end
            if [descriptor.signature length] != [candidateSignature length] then
              error functionName
              : "this function has " + [candidateSignature length] + " argument(s) ("
              + [descriptor.signature length] + " required)"
            else
              for required in descriptor.signature, candidate in candidateSignature do
                if required.mTypeProxy != candidate.mTypeProxy then
                  error candidate.mSelector : "argument type should be $" + [required.mTypeProxy key]
                end
              end
            end
            staticValue += [type llvmTypeName] + " @" + [routineLLVMName assemblerRepresentation]
          end
        end
      between
        staticValue += ", "
      end
      staticValue += "}"
      stringValueList += !staticValue
    end
  end
  [!?ioStaticListValueMap insertKey !mStaticListName !stringValueList]
#-------------------------------------------------------------------- List type property map
  @propertyMap listTypePropertyMap = {}
  [!?listTypePropertyMap insertKey # "count" property
    !.new {!"count" !mStaticListName.location}
    !true # public
    !.constantProperty {!value:.literalInteger {!type:staticIntegerType () !value:[mValueList length]}}
  ]
#-------------------------------------------------------------------- Enter list type in type map
  let elementType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !plmElementTypeName} type]
  let arrayType = @PLMType.new {
    !propertyMap:listTypePropertyMap
    !routineMap: {}
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.instanciable | .equatable | .copyable
    !plmTypeDescriptionName:plmNameForStaticListType (!mStaticListName)
    !kind:.arrayType {!elementType:elementType !size:[stringValueList length]}
    !llvmBaseTypeName:llvmNameForStaticListType (!mStaticListName)
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmNameForStaticListType (!mStaticListName)
    !type:arrayType
    !index:[ioContext.mTypeMap count]
    !generate:true
  ]
#-------------------------------------------------------------------- Enter list in constant map
  let staticListType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !plmNameForStaticListType (!mStaticListName)}
  [!?ioContext.mGlobalConstantMap insertKey
    !mStaticListName
    !.reference {!type:[staticListType type] !llvmName:llvmNameForGlobalVariable (!mStaticListName)}
  ]
  [!?ioContext.mValuedObjectMap insertGlobalConstant
    !mStaticListName
    !.reference {!type:[staticListType type] !llvmName:llvmNameForGlobalVariable (!mStaticListName)}
  ]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedStaticList.new {!mStaticListName !mValueList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticListInvokedFunctionSetMap {
  @stringset mInvokedFunctionSet
  
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#·······················································································································

class @decoratedStaticList : @abstractDecoratedDeclaration {
  @lstring mStaticListName
  @staticListValueListAST mValueList
}

#·······················································································································

override method @decoratedStaticList semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @stringset invokedFunctionSet = {}
  for value in mValueList do
    for (operand endOfExp) in value.mExpressions do
      switch operand
      case expression (@expressionAST unused exp) :
      case function (@lstring functionName @routineFormalArgumentListAST formalArgs) :
      #--- Routine mangled name
        let routineMangledName = routineMangledNameFromAST (
          !"" 
          !functionName
          !formalArgs
        )
        invokedFunctionSet += !routineMangledName
      end
    end
  end
  [!?ioTemporaries.mStaticArrayMapForTemporaries insertKey !mStaticListName !invokedFunctionSet]
  [!?ioIntermediateCodeStruct.mStaticArrayMapForIntermediate insertKey !mStaticListName !invokedFunctionSet]
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticListInitializationMap generateLLVMForStaticLists
  ?let @staticListInvokedFunctionSetMap inUsefulStaticArrayMap
  ?!@string ioLLVMcode
{
  var first = true
  for (key initList) in self do
    if [inUsefulStaticArrayMap hasKey !key] then
      if first then
        first = false
        ioLLVMcode += llvmTitleComment (!"Static Arraies")
      end
      ioLLVMcode += llvmNameForGlobalVariable (!key) + " = private unnamed_addr constant ["
      ioLLVMcode += [[initList length] string] + " x %" + llvmNameForStaticListElementType (![key nowhere]) + "] [\n"
      for (value) in initList
      do
        ioLLVMcode += "  %" + llvmNameForStaticListElementType (![key nowhere]) + " " + value
      between
        ioLLVMcode += ",\n"
      end
      ioLLVMcode += "\n]\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: INDIRECT FUNCTION CALL
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticListIndirectRoutineIR : @abstractRoutineIR {
  @unifiedTypeMap-proxy mStaticListElementType
  @routineTypedSignature mFormalArgumentListForGeneration
  @unifiedTypeMap-proxy mReturnTypeProxy # .void if no return value
  @uint mPropertyIndex
}

#·······················································································································

override method @staticListIndirectRoutineIR enterAccessibleEntities
   ?!@stringset ioInvokedRoutineSet
   ?!@uint ioMaxBranchOfOnInstructions
{
}

#·······················································································································

override method @staticListIndirectRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!mRoutineMangledName)
  ioLLVMcode += "define internal "
  if mReturnTypeProxy == .null then
    ioLLVMcode += "void"
  else
    ioLLVMcode += [[mReturnTypeProxy type] llvmTypeName]
  end
  ioLLVMcode += " @" + [mRoutineMangledName assemblerRepresentation] + " ("
  let receiverLLVMTypeName = [[mStaticListElementType type] llvmTypeName]
  var first = true
  if receiverLLVMTypeName != "" then
    ioLLVMcode += receiverLLVMTypeName + "* " + llvmNameForSelf ()
    first = false
  end
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentPassingMode
    case input :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + " %in." + [mFormalArgumentName assemblerRepresentation]
    case output :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + "* %out." + [mFormalArgumentName assemblerRepresentation]
   case inputOutput :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + "* %inout." + [mFormalArgumentName assemblerRepresentation]
    end
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
#--- Indirect function LLVM type name
  @string llvmFunctionTypeName
  if mReturnTypeProxy == .null then
    llvmFunctionTypeName = "void"
  else
    llvmFunctionTypeName = [[mReturnTypeProxy type] llvmTypeName]
  end
  llvmFunctionTypeName += "("
  first = true
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      llvmFunctionTypeName += ", "
    end
    switch mFormalArgumentPassingMode
    case input :
      llvmFunctionTypeName += [[mTypeProxy type] llvmTypeName]
    case output :
      llvmFunctionTypeName += [[mTypeProxy type] llvmTypeName] + "*"
   case inputOutput :
      llvmFunctionTypeName += [[mTypeProxy type] llvmTypeName] + "*"
    end
  end
  llvmFunctionTypeName += ")*"
#--- Indirect call
  ioLLVMcode += "  %ptr = getelementptr inbounds " + receiverLLVMTypeName 
  ioLLVMcode += ", " + receiverLLVMTypeName + "* %self, i32 0, i32 " + mPropertyIndex + "\n"
  ioLLVMcode += "  %f = load " + llvmFunctionTypeName + ", " + llvmFunctionTypeName + "* %ptr\n"
  if mReturnTypeProxy == .null then
    ioLLVMcode += "  call void"
  else
    ioLLVMcode += "  %result = call " + [[mReturnTypeProxy type] llvmTypeName]
  end
  ioLLVMcode += " %f ("
  first = true
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentPassingMode
    case input :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + " %in." + [mFormalArgumentName assemblerRepresentation]
    case output :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + "* %out." + [mFormalArgumentName assemblerRepresentation]
   case inputOutput :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + "* %inout." + [mFormalArgumentName assemblerRepresentation]
    end
  end
  ioLLVMcode += ")\n"
#--- Epilog
  if mReturnTypeProxy == .null then
    ioLLVMcode += "  ret void\n"
  else
    ioLLVMcode += "  ret " + [[mReturnTypeProxy type] llvmTypeName] + " %result\n"
  end
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
