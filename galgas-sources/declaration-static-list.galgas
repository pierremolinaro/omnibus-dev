#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticlistPropertyListAST {
  @lstring mPropertyName
  @lstring mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticlistListAST {
  @lstring mStaticListName
  @staticlistPropertyListAST mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticlist$
    $identifier$ ?let staticListName
    ${$
    @staticlistPropertyListAST propertyList = {}
    repeat
    while
      $let$
      $identifier$ ?let propertyName
      $\$type$ ?let typeName
      propertyList += !propertyName !typeName
    end
    $}$
    ioAST.mStaticlistListAST += !staticListName !propertyList
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticlist$
    $identifier$ ?let staticListName
    $:$
    $($
    repeat
      <expression> ?let expression
    while
      $,$
    end
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (* propertyList) in self do
    for (* propertyTypeName) in propertyList do
      let typeName = @lstring.new {!"$" + propertyTypeName !propertyTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticlistPropertyList {
  @lstring mPropertyName
  @unifiedTypeMap-proxy mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @staticlistPropertyList mStaticlistPropertyList

  insert insertKey error message "static list '%K' is already defined"
#  search searchKey error message "static list '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistListAST enterStaticListsInContext
  ?!context:@semanticContext ioContext
{
  for staticlist in self do
    [staticlist enterStaticListInContext !?context:ioContext]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistListAST-element enterStaticListInContext
  ?!context:@semanticContext ioContext
{
  @staticlistPropertyList staticlistPropertyList = {}
  @stringset propertyNameSet = {}
  for (propertyName propertyTypeName) in mPropertyList do
    let propertyType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName}
    if [propertyNameSet hasKey !propertyName] then
      error propertyName : "duplicated property name"
    end
    propertyNameSet += !propertyName
    staticlistPropertyList += !propertyName !propertyType
  end
  [!?ioContext.mStaticlistMap insertKey
    !mStaticListName
    !staticlistPropertyList
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#map @bootRoutinePriorityMap {
#  insert insertKey error message "a boot routine with priority %K has been already declared"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistListAST-element staticlistSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
##  if not [inContext.mModeMap hasKey !bootModeName ()] then
##    error mBootLocation : "the `" + bootModeName () + " mode should be defined in order to use boot routines"
##  end
#  [!?ioTemporaries.mBootRoutinePriorityMap insertKey !.new{![mPriority string] !mPriorityLocation}]
##---
#  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mPriority !mPriorityLocation}
#  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
#    [!?ioTemporaries.mSubprogramInvocationGraph addNode
#      !routineNameForInvocationGraph
#      !routineNameForInvocationGraph
#    ]
#  end
##--- Variable map
#  initialVariableMap (
#    !context:inContext
#    !mode:.bootMode
##    !userMode:false
##    !registerAccess:.readWriteAccess
#    !globalsAreConstant:false
#    !returnTypeName:["" nowhere]
#    ?@variableMap variableMap
#  )
##--- Analyze instruction list
#  @instructionListIR instructionGenerationList = {}
#  @allocaList bootAllocaList = {}
#  [mInstructionList analyzeRoutineInstructionList
#    !self:.null
#    !directAccessToPropertiesAllowed:false
#    !propertiesAreMutable:false
#    !routineNameForInvocationGraph:routineNameForInvocationGraph
#    !context:inContext
#    !mode:.bootMode
#    !?temporary:ioTemporaries
#    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
#    !?variableMap:variableMap
#    !?alloca:bootAllocaList
#    !?generatedCode:instructionGenerationList
#  ]
##--- End of variableMap
##  [variableMap deinitTopLevelVariables]
#  [variableMap checkAutomatonStates !mEndOfBootLocation]
#  drop variableMap
##--- Code generation
#  ioIntermediateCodeStruct.mBootList +=
#    !mPriority
#    !mBootLocation
#    !bootAllocaList
#    !instructionGenerationList
#    !mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @bootListIR {
#  @bigint mBootIndex
#  @location mInitLocation
#  @allocaList mAllocaList
#  @instructionListIR mInstructionListIR
#  @location mEndOfInitLocation
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

