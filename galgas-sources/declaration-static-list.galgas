#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticlistPropertyListAST {
  @lstring mPropertyName
  @lstring mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticlistAST : @abstractDeclaration {
  @lstring mStaticListName
  @staticlistPropertyListAST mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticlistAST location -> @location {
  result = mStaticListName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticlistAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticlist$
    $identifier$ ?let staticListName
    ${$
    @staticlistPropertyListAST propertyList = {}
    repeat
      $let$
      $identifier$ ?let propertyName
      $\$type$ ?let typeName
      propertyList += !propertyName !typeName
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticlistAST.new {!staticListName !propertyList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add 'constant name' node
  [!?ioGraph addNode !mStaticListName !self]
#---
  for (* propertyTypeName) in mPropertyList do
    let typeName = @lstring.new {!"$" + propertyTypeName !propertyTypeName.location}
    [!?ioGraph addEdge !mStaticListName !typeName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @propertyList mStaticlistPropertyList

  insert insertKey error message "static list '%K' is already defined"
  search searchKey error message "static list '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  @propertyList staticlistPropertyList = {}
  @propertyMap staticlistPropertyMap = {}
  @stringset propertyNameSet = {}
  for (propertyName propertyTypeName) in mPropertyList do
    let propertyType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName}
    if [propertyNameSet hasKey !propertyName] then
      error propertyName : "duplicated property name"
    end
    propertyNameSet += !propertyName
    staticlistPropertyList += !propertyName !propertyType
    let propertyIndex = [staticlistPropertyMap count]
    [!?staticlistPropertyMap insertKey
      !propertyName
      !true # Public
      !.property {!type:propertyType !plmName:propertyName !index:propertyIndex}
      !propertyIndex
    ]
  end
  [!?ioContext.mStaticlistMap insertKey
    !mStaticListName
    !staticlistPropertyList
  ]
#--- Enter element type in type map
  [!?ioContext.mTypeMap insertType
    !lkey:plmNameForStaticListElementType (!mStaticListName)
    !llvmTypeName:llvmNameForStaticListElementType (!mStaticListName)
    !kind:.structure {!propertyMap:staticlistPropertyMap !propertyList:staticlistPropertyList}
    !classConstantMap:{}
    !instantiable:false
    !copyable:false
    !equatable:false
    !comparable:false
    !enumerationType:.null # Not enumerable
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticlistAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
