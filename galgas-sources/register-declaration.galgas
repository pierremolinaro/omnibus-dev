#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterNameList {
  @lstring mRegisterName
  @lstringlist mAttributeList
  @lbigint mRegisterAddress
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterDeclarationListAST {
  @controlRegisterNameList mRegisterNameList
  @lstring mRegisterTypeName
  @controlRegisterBitSliceList mRegisterBitSliceList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterBitSliceList {
  @controlRegisterBitSlice mRegisterBitSlice
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @controlRegisterBitSlice {
  case unusedBits (@lbigint count)
  case namedBit (@lstring name @lbigint count)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $register$
    @controlRegisterNameList registerDeclarationList = {}
    repeat
      $identifier$ ?let registerName
      @lstringlist attributeList = {}
      repeat
      while
        $attribute$ ?let attribute
        attributeList += !attribute
      end 
      $at$
      $integer$ ?let @lbigint registerAddress
      registerDeclarationList += !registerName !attributeList !registerAddress
    while
    end
    $typeName$ ?let registerTypeName
    @controlRegisterBitSliceList registerBitSliceList = {}
    select
    or
      ${$
      repeat
        @controlRegisterBitSlice registerBitSlice
        select
          $integer$ ?let @lbigint unusedBitCount
          registerBitSlice = .unusedBits {!count:unusedBitCount}
        or
          $identifier$ ?let bitName
          select
            registerBitSlice = .namedBit {!name:bitName !count:.new{!1G !.here}}
          or
            $[$
            $integer$ ?let @lbigint bitCount
            $]$
            registerBitSlice = .namedBit {!name:bitName !count:bitCount}
          end
        end
        registerBitSliceList += !registerBitSlice
      while
        $,$
      end
      $}$
    end
    ioAST.mControlRegisterDeclarationListAST +=
      !registerDeclarationList
      !registerTypeName
      !registerBitSliceList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @registerFieldMap {
  @uint mBitIndex
  @uint mBitCount
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @registerBitSliceAccessMap {
  @llvmBinaryOperation mAccessOperator
  @bigint mAccessRightOperand
  @registerBitSliceAccessMap mSubMap
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @registerMap {
  @unifiedTypeMap-proxy mType
  @bool mIsReadOnly
  @registerBitSliceAccessMap mRegisterFieldAccessMap
  @registerFieldMap mRegisterFieldMap
  @bigint mAddress
  insert insertKey error message "the '%K' register has been already declared in %L"
  search searchKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterControlRegistersInContext
  ?let @controlRegisterDeclarationListAST inRegisterDeclarationListAST
  ?!context:@semanticContext ioContext
{
  for (registerNameList registerTypeName registerBitSliceList) in inRegisterDeclarationListAST do
  #---
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !registerTypeName ?let registerType]
  #--- Build bit slice map
    @registerFieldMap registerFieldMap = {}
    @registerBitSliceAccessMap registerBitSliceMap = {}
    if [registerBitSliceList length] > 0 then
      @uint shiftCount = 0
      for > () in registerBitSliceList do
        switch mRegisterBitSlice
        case unusedBits (@lbigint count) :
          shiftCount = shiftCount + [count.bigint uint]
        case namedBit (@lstring name @lbigint count) :
          let bitCount = [count.bigint uint]
          [!?registerFieldMap insertKey
            !name
            !shiftCount
            !bitCount
          ]
          @registerBitSliceAccessMap registerSubMap = {}
          [!?registerSubMap insertKey
            !.new{!"shift" !name.location}
            !.lshr
            ![shiftCount bigint]
            !{}
            !registerType
          ]
          [!?registerSubMap insertKey
            !.new{!"bool" !name.location}
            !.icmp_ne
            !0G
            !{}
            !ioContext.mBooleanType
          ]
          let mask = ((1G << bitCount) - 1G) << shiftCount
          [!?registerBitSliceMap insertKey
            !name
            !.and
            !mask
            !registerSubMap
            !registerType
          ]
          shiftCount = shiftCount + bitCount
        end
      end
    end
  #---  
    for () in registerNameList do
    #--- Analyze attributes
      var isReadOnly = false
      for (att) in mAttributeList do
        if att.string != "ro" then
          error att : "only @ro attribute (read only) is accepted here"
        elsif isReadOnly then
          error att : "duplicated attribute"
        else
          isReadOnly = true
        end
      end
      [!?ioContext.mRegisterMap insertKey
        !mRegisterName
        !registerType
        !isReadOnly
        !registerBitSliceMap
        !registerFieldMap
        !mRegisterAddress.bigint
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc controlRegistersSemanticAnalysis
  ?let @controlRegisterDeclarationListAST inRegisterDeclarationListAST
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for (registerNameList registerTypeName registerBitSliceList) in inRegisterDeclarationListAST do
  #--- Check type
    let registerType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !registerTypeName}
    switch [registerType kind]
    case boolean : error registerTypeName : "a boolean type is not valid for a register"
    case boolset : error registerTypeName : "a boolset type is not valid for a register"
    case integer (* * @bool unsigned @uint size) :
      if [registerBitSliceList length] > 0 then
        if not unsigned then
          error registerTypeName:"the register type should be unsigned in order to define bit slices"
        end
        @uint shiftCount = 0
        for > () in registerBitSliceList do
          switch mRegisterBitSlice
          case unusedBits (@lbigint count) :
            shiftCount = shiftCount + [count.bigint uint]
          case namedBit (* @lbigint count) :
            shiftCount = shiftCount + [count.bigint uint]
          end
        end
        if size != shiftCount then
          error registerTypeName : "total bit slice count is " + shiftCount + " (should be " + size + ")"
        end
      end
    case literalString : error registerTypeName : "a literal string type is not valid for a register"
    case structure (* *) : error registerTypeName : "a structure type is not valid for a register"
    case enumeration (*) : error registerTypeName : "an enumeration type is not valid for a register"
    case staticInteger : error registerTypeName : "a literal integer type is not valid for a register"
    end
  #--- Check address value
    let @bigint maxAddress = (1G << inContext.mPointerSize) - 1G
    for () in registerNameList do
      if mRegisterAddress.bigint > maxAddress then
        error mRegisterAddress : "register address should be lower or equal to " + [maxAddress hexString]
      end
    #---
      [!?ioIntermediateCodeStruct.mRegisterMap insertKey
        !mRegisterName
        !registerTypeName.string
        !mRegisterAddress.bigint
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

