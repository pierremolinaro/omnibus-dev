#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @registerDeclarationList {
  @lstring mRegisterName
  @lstringlist mAttributeList
  @luint64 mRegisterAddress
}

#----------------------------------------------------------------------------------------------------------------------*

class @registerDeclaration : @abstractDeclaration {
  @registerDeclarationList mRegisterDeclarationList
  @lstring mRegisterTypeName
  @registerBitSliceList mRegisterBitSliceList
}

#----------------------------------------------------------------------------------------------------------------------*

list @registerBitSliceList {
  @registerBitSlice mRegisterBitSlice
}

#----------------------------------------------------------------------------------------------------------------------*

enum @registerBitSlice {
  case unusedBits (@luint64 count)
  case namedBit (@lstring name @luint64 count)
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerDeclaration location -> @location outLocation {
  outLocation = mRegisterTypeName.location
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $register$
    @registerDeclarationList registerDeclarationList = {}
    repeat
      @lstringlist attributeList = {}
      repeat
      while
        $attribute$ ?let attribute
        attributeList += !attribute
      end 
      $identifier$ ?let registerName
      $at$
      $integer$ ?let @luint64 registerAddress
      registerDeclarationList += !registerName !attributeList !registerAddress
    while
    end
    $:$
    $identifier$ ?let registerTypeName
    @registerBitSliceList registerBitSliceList = {}
    select
    or
      ${$
      repeat
        @registerBitSlice registerBitSlice
        select
          $integer$ ?let @luint64 unusedBitCount
          registerBitSlice = .unusedBits {!count:unusedBitCount}
        or
          $identifier$ ?let bitName
          select
            registerBitSlice = .namedBit {!name:bitName !count:.new{!1L !.here}}
          or
            $[$
            $integer$ ?let @luint64 bitCount
            $]$
            registerBitSlice = .namedBit {!name:bitName !count:bitCount}
          end
        end
        registerBitSliceList += !registerBitSlice
      while
        $,$
      end
      $}$
    end
    ioAST.mDeclarationList += !@registerDeclaration.new {
      !registerDeclarationList
      !registerTypeName
      !registerBitSliceList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode ![mRegisterDeclarationList mRegisterNameAtIndex !0] !self]
  [!?ioGraph addEdge ![mRegisterDeclarationList mRegisterNameAtIndex !0] !mRegisterTypeName]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "register " + [mRegisterDeclarationList mRegisterNameAtIndex !0]
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @registerBitSliceMap {
  @infixOperatorIR mAccessOperator
  @variableKindIR mAccessRightOperand
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @registerMap {
  @unifiedTypeMap-proxy mType
  @bool mIsReadOnly
  @registerBitSliceMap mRegisterBitSliceMap
  insert insertKey error message "the '%K' register has been already declared in %L"
  search searchKey error message "** internal error **"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
#---
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mRegisterTypeName ?let registerType]
#--- Build bit slice map
  @registerBitSliceMap registerBitSliceMap = {}
  if [mRegisterBitSliceList length] > 0 then
    @uint shiftCount = 0
    for > () in mRegisterBitSliceList do
      switch mRegisterBitSlice
      case unusedBits (@luint64 count) :
        shiftCount = shiftCount + [count.uint64 uint]
      case namedBit (@lstring name @luint64 count) :
        let bitCount = [count.uint64 uint]
        let mask = ((1L << bitCount) - 1L) << shiftCount
        [!?registerBitSliceMap insertKey
          !name
          !.infix {!infixOperator:"&"}
          !.literalUnsignedInteger{!type:registerType !value:mask}
        ]
        shiftCount = shiftCount + bitCount
      end
    end
  end
#---  
  for () in mRegisterDeclarationList do
  #--- Analyze attributes
    var isReadOnly = false
    for (att) in mAttributeList do
      if att.string != "ro" then
        error att : "only @ro attribute (read only) is accepted here"
      elsif isReadOnly then
        error att : "duplicated attribute"
      else
        isReadOnly = true
      end
    end
    [!?ioContext.mRegisterMap insertKey
      !mRegisterName
      !registerType
      !isReadOnly
      !registerBitSliceMap
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check type
  let registerType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mRegisterTypeName}
  switch [registerType kind]
  case boolean : error mRegisterTypeName : "a boolean type is not valid for a register"
  case boolset : error mRegisterTypeName : "a boolset type is not valid for a register"
  case integer (* * @bool unsigned @uint size) :
    if [mRegisterBitSliceList length] > 0 then
      if not unsigned then
        error mRegisterTypeName:"the register type should be unsigned in order to define bit slices"
      end
      @uint shiftCount = 0
      for > () in mRegisterBitSliceList do
        switch mRegisterBitSlice
        case unusedBits (@luint64 count) :
          shiftCount = shiftCount + [count.uint64 uint]
        case namedBit (* @luint64 count) :
          shiftCount = shiftCount + [count.uint64 uint]
        end
      end
      if size != shiftCount then
        error mRegisterTypeName : "total bit slice count is " + shiftCount + " (should be " + size + ")"
      end
    end
  case literalString : error mRegisterTypeName : "a literal string type is not valid for a register"
  case structure (*) : error mRegisterTypeName : "a structure type is not valid for a register"
  case enumeration (*) : error mRegisterTypeName : "an enumeration type is not valid for a register"
  end
#--- Check address value
  [inContext.mTargetBaseTypeMap searchKey !["size" nowhere] ?* ?let size ?let isSigned]
  if isSigned then
    error mRegisterTypeName : "base type 'size' should be unsigned"
  end
  @uint64 maxAddress
  if size == 8 then
    maxAddress = 255L
  elsif size == 16 then
    maxAddress = 65535L
  elsif size == 32 then
    maxAddress = [@uint.max uint64]
  elsif size == 16 then
    maxAddress = @uint64.max
  else
    error mRegisterTypeName : "base type 'size' has an invalid size" : maxAddress
  end
  for () in mRegisterDeclarationList do
    if mRegisterAddress.uint64 > maxAddress then
      error mRegisterAddress : "register address should be lower or equal to " + [maxAddress hexString]
    end
  #---
    [!?ioIntermediateCodeStruct.mRegisterMap insertKey
      !mRegisterName
      !mRegisterTypeName.string
      !mRegisterAddress.uint64
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper registerGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "register-declaration.galgasTemplate"
    ?@string REGISTER_TYPE_NAME
    ?@string REGISTER_NAME
    ?@uint64 REGISTER_ADDRESS
}

#----------------------------------------------------------------------------------------------------------------------*

getter @registerMapIR-element headerCodeGenerationForRegister -> @string outCode {
  outCode = [filewrapper registerGenerationTemplate.declaration
    !mRegisterTypeName
    !lkey.string
    !mRegisterAddress
  ]
}

#----------------------------------------------------------------------------------------------------------------------*



