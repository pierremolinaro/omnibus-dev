#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @registerDeclarationList {
  @lstring mRegisterName
  @lstringlist mAttributeList
  @lbigint mRegisterAddress
}

#----------------------------------------------------------------------------------------------------------------------*

class @registerDeclaration : @abstractDeclaration {
  @registerDeclarationList mRegisterDeclarationList
  @lstring mRegisterTypeName
  @registerBitSliceList mRegisterBitSliceList
}

#----------------------------------------------------------------------------------------------------------------------*

list @registerBitSliceList {
  @registerBitSlice mRegisterBitSlice
}

#----------------------------------------------------------------------------------------------------------------------*

enum @registerBitSlice {
  case unusedBits (@lbigint count)
  case namedBit (@lstring name @lbigint count)
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerDeclaration location -> @location outLocation {
  outLocation = mRegisterTypeName.location
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $register$
    @registerDeclarationList registerDeclarationList = {}
    repeat
      $identifier$ ?let registerName
      @lstringlist attributeList = {}
      repeat
      while
        $attribute$ ?let attribute
        attributeList += !attribute
      end 
      $at$
      $integer$ ?let @lbigint registerAddress
      registerDeclarationList += !registerName !attributeList !registerAddress
    while
    end
    $typeName$ ?let registerTypeName
    @registerBitSliceList registerBitSliceList = {}
    select
    or
      ${$
      repeat
        @registerBitSlice registerBitSlice
        select
          $integer$ ?let @lbigint unusedBitCount
          registerBitSlice = .unusedBits {!count:unusedBitCount}
        or
          $identifier$ ?let bitName
          select
            registerBitSlice = .namedBit {!name:bitName !count:.new{!1G !.here}}
          or
            $[$
            $integer$ ?let @lbigint bitCount
            $]$
            registerBitSlice = .namedBit {!name:bitName !count:bitCount}
          end
        end
        registerBitSliceList += !registerBitSlice
      while
        $,$
      end
      $}$
    end
    ioAST.mDeclarationList += !@registerDeclaration.new {
      !registerDeclarationList
      !registerTypeName
      !registerBitSliceList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode ![mRegisterDeclarationList mRegisterNameAtIndex !0] !self]
  [!?ioGraph addEdge ![mRegisterDeclarationList mRegisterNameAtIndex !0] !mRegisterTypeName]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "register " + [mRegisterDeclarationList mRegisterNameAtIndex !0]
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @registerFieldMap {
  @uint mBitIndex
  @uint mBitCount
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @registerBitSliceAccessMap {
  @llvmBinaryOperation mAccessOperator
  @bigint mAccessRightOperand
  @registerBitSliceAccessMap mSubMap
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @registerMap {
  @unifiedTypeMap-proxy mType
  @bool mIsReadOnly
  @registerBitSliceAccessMap mRegisterFieldAccessMap
  @registerFieldMap mRegisterFieldMap
  @bigint mAddress
  insert insertKey error message "the '%K' register has been already declared in %L"
  search searchKey error message "** internal error **"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
#---
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mRegisterTypeName ?let registerType]
#--- Build bit slice map
  @registerFieldMap registerFieldMap = {}
  @registerBitSliceAccessMap registerBitSliceMap = {}
  if [mRegisterBitSliceList length] > 0 then
    @uint shiftCount = 0
    for > () in mRegisterBitSliceList do
      switch mRegisterBitSlice
      case unusedBits (@lbigint count) :
        shiftCount = shiftCount + [count.bigint uint]
      case namedBit (@lstring name @lbigint count) :
        let bitCount = [count.bigint uint]
        [!?registerFieldMap insertKey
          !name
          !shiftCount
          !bitCount
        ]
        @registerBitSliceAccessMap registerSubMap = {}
        [!?registerSubMap insertKey
          !.new{!"shift" !name.location}
          !.lshr
          ![shiftCount bigint]
          !{}
          !registerType
        ]
        [!?registerSubMap insertKey
          !.new{!"bool" !name.location}
          !.icmp_ne
          !0G
          !{}
          !ioContext.mBooleanType
        ]
        let mask = ((1G << bitCount) - 1G) << shiftCount
        [!?registerBitSliceMap insertKey
          !name
          !.and
          !mask
          !registerSubMap
          !registerType
        ]
        shiftCount = shiftCount + bitCount
      end
    end
  end
#---  
  for () in mRegisterDeclarationList do
  #--- Analyze attributes
    var isReadOnly = false
    for (att) in mAttributeList do
      if att.string != "ro" then
        error att : "only @ro attribute (read only) is accepted here"
      elsif isReadOnly then
        error att : "duplicated attribute"
      else
        isReadOnly = true
      end
    end
    [!?ioContext.mRegisterMap insertKey
      !mRegisterName
      !registerType
      !isReadOnly
      !registerBitSliceMap
      !registerFieldMap
      !mRegisterAddress.bigint
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration initAnalysis ?!context:@semanticContext unused ioContext { }

#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check type
  let registerType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mRegisterTypeName}
  switch [registerType kind]
  case boolean : error mRegisterTypeName : "a boolean type is not valid for a register"
  case boolset : error mRegisterTypeName : "a boolset type is not valid for a register"
  case integer (* * @bool unsigned @uint size) :
    if [mRegisterBitSliceList length] > 0 then
      if not unsigned then
        error mRegisterTypeName:"the register type should be unsigned in order to define bit slices"
      end
      @uint shiftCount = 0
      for > () in mRegisterBitSliceList do
        switch mRegisterBitSlice
        case unusedBits (@lbigint count) :
          shiftCount = shiftCount + [count.bigint uint]
        case namedBit (* @lbigint count) :
          shiftCount = shiftCount + [count.bigint uint]
        end
      end
      if size != shiftCount then
        error mRegisterTypeName : "total bit slice count is " + shiftCount + " (should be " + size + ")"
      end
    end
  case literalString : error mRegisterTypeName : "a literal string type is not valid for a register"
  case structure (* * *) : error mRegisterTypeName : "a structure type is not valid for a register"
  case enumeration (*) : error mRegisterTypeName : "an enumeration type is not valid for a register"
  case literalInteger : error mRegisterTypeName : "a literal integer type is not valid for a register"
  end
#--- Check address value
  let @bigint maxAddress = (1G << inContext.mPointerSize) - 1G
  for () in mRegisterDeclarationList do
    if mRegisterAddress.bigint > maxAddress then
      error mRegisterAddress : "register address should be lower or equal to " + [maxAddress hexString]
    end
  #---
    [!?ioIntermediateCodeStruct.mRegisterMap insertKey
      !mRegisterName
      !mRegisterTypeName.string
      !mRegisterAddress.bigint
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*



