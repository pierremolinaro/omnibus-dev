#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @registerDeclaration : @abstractDeclaration {
  @lstring mRegisterTypeName
  @lstring mRegisterName
  @luint64 mRegisterAddress
  @lstringlist mAttributeList
  @registerBitSliceList mRegisterBitSliceList
}

#----------------------------------------------------------------------------------------------------------------------*

list @registerBitSliceList {
  @registerBitSlice mRegisterBitSlice
}

#----------------------------------------------------------------------------------------------------------------------*

enum @registerBitSlice {
  case unusedBits (@luint64 count)
  case namedBit (@lstring name @luint64 count)
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerDeclaration location -> @location outLocation {
  outLocation = mRegisterName.location
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $register$
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end 
    $identifier$ ?let registerName
    $:$
    $identifier$ ?let registerTypeName
    $at$
    $integer$ ?let @luint64 registerAddress
    @registerBitSliceList registerBitSliceList = {}
    select
    or
      ${$
      repeat
        @registerBitSlice registerBitSlice
        select
          $integer$ ?let @luint64 unusedBitCount
          registerBitSlice = .unusedBits {!count:unusedBitCount}
        or
          $identifier$ ?let bitName
          select
            registerBitSlice = .namedBit {!name:bitName !count:.new{!1L !.here}}
          or
            $[$
            $integer$ ?let @luint64 bitCount
            $]$
            registerBitSlice = .namedBit {!name:bitName !count:bitCount}
          end
        end
        registerBitSliceList += !registerBitSlice
      while
        $,$
      end
      $}$
    end
    ioAST.mDeclarationList += !@registerDeclaration.new {
      !registerTypeName
      !registerName
      !registerAddress
      !attributeList
      !registerBitSliceList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !mRegisterName !self]
  [!?ioGraph addEdge !mRegisterName !mRegisterTypeName]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "register " + mRegisterName 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @registerBitSliceMap {
  @uint mShiftCount
  @uint mBitCount
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @registerMap {
  @unifiedTypeMap-proxy mType
  @bool mIsReadOnly
  @registerBitSliceMap mRegisterBitSliceMap
  insert insertKey error message "the '%K' register has been already declared in %L"
  search searchKey error message "** internal error **"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
#---
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mRegisterTypeName ?let registerType]
#--- Analyze attributes
  var isReadOnly = false
  for (att) in mAttributeList do
    if att.string != "ro" then
      error att : "only @ro attribute (read only) is accepted here"
    elsif isReadOnly then
      error att : "duplicated attribute"
    else
      isReadOnly = true
    end
  end
#--- Build bit slice map
  @registerBitSliceMap registerBitSliceMap = {}
  if [mRegisterBitSliceList length] > 0 then
    @uint shiftCount = 0
    for > () in mRegisterBitSliceList do
      switch mRegisterBitSlice
      case unusedBits (@luint64 count) :
        shiftCount = shiftCount + [count.uint64 uint]
      case namedBit (@lstring name @luint64 count) :
        let bitCount = [count.uint64 uint]
        [!?registerBitSliceMap insertKey !name !shiftCount !bitCount]
        shiftCount = shiftCount + bitCount
      end
    end
  end
#---  
  [!?ioContext.mRegisterMap insertKey
    !mRegisterName
    !registerType
    !isReadOnly
    !registerBitSliceMap
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check type
  let registerType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mRegisterTypeName}
  switch [registerType kind]
  case boolean : error mRegisterTypeName : "a boolean type is not valid for a register"
  case boolset : error mRegisterTypeName : "a boolset type is not valid for a register"
  case integer (* * @bool unsigned @uint size) :
    if [mRegisterBitSliceList length] > 0 then
      if not unsigned then
        error mRegisterName:"the register type should be unsigned in order to define bit slices"
      end
      @uint shiftCount = 0
      for > () in mRegisterBitSliceList do
        switch mRegisterBitSlice
        case unusedBits (@luint64 count) :
          shiftCount = shiftCount + [count.uint64 uint]
        case namedBit (* @luint64 count) :
          shiftCount = shiftCount + [count.uint64 uint]
        end
      end
      if size != shiftCount then
        error mRegisterName : "total bit slice count is " + shiftCount + " (should be " + size + ")"
      end
    end
  case literalString : error mRegisterTypeName : "a literal string type is not valid for a register"
  case structure (*) : error mRegisterTypeName : "a structure type is not valid for a register"
  case enumeration (*) : error mRegisterTypeName : "an enumeration type is not valid for a register"
  end
#--- Check address value
  [inContext.mTargetBaseTypeMap searchKey !["size" nowhere] ?* ?let size ?let isSigned]
  if isSigned then
    error mRegisterName : "base type 'size' should be unsigned"
  end
  @uint64 maxAddress
  if size == 8 then
    maxAddress = 255L
  elsif size == 16 then
    maxAddress = 65535L
  elsif size == 32 then
    maxAddress = [@uint.max uint64]
  elsif size == 16 then
    maxAddress = @uint64.max
  else
    error mRegisterName : "base type 'size' has an invalid size" : maxAddress
  end
  if mRegisterAddress.uint64 > maxAddress then
    error mRegisterAddress : "register address should be lower or equal to " + [maxAddress hexString]
  end
#---
  [!?ioIntermediateCodeStruct.mRegisterMap insertKey
    !mRegisterName
    !mRegisterTypeName.string
    !mRegisterAddress.uint64
  ]    
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper registerGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "register-declaration.galgasTemplate"
    ?@string REGISTER_TYPE_NAME
    ?@string REGISTER_NAME
    ?@uint64 REGISTER_ADDRESS
}

#----------------------------------------------------------------------------------------------------------------------*

getter @registerMapIR-element headerCodeGenerationForRegister -> @string outCode {
  outCode = [filewrapper registerGenerationTemplate.declaration
    !mRegisterTypeName
    !lkey.string
    !mRegisterAddress
  ]
}

#----------------------------------------------------------------------------------------------------------------------*



