#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @controlRegisterKind {
  case scalar
  case registerArray (@expressionAST arraySize # a power of 2 >= 2
                      @location arraySizeLocation
                      @expressionAST arrayElementSize
                      @location arrayElementSizeLocation)
}  

#·······················································································································

list @controlRegisterNameListAST {
  @lstring mRegisterName
  @controlRegisterKind mControlRegisterKind
  @lstringlist mAttributeList
  @expressionAST mRegisterAddress
  @location mRegisterAddressLocation
}

#·······················································································································

list @controlRegisterDeclarationList {
  @controlRegisterNameListAST mRegisterArrayList
  @lstring mRegisterTypeName
  @controlRegisterBitSliceList mRegisterBitSliceList
  @location mRegisterBitSliceListLocation
}

#·······················································································································

list @controlRegisterBitSliceList {
  @controlRegisterBitSlice mRegisterBitSlice
}

#·······················································································································

enum @controlRegisterBitSlice {
  case unusedBits (@lbigint count)
  case namedBit (@lstring name @lbigint count)
}

#·······················································································································

enum @controlRegisterGroupKindAST {
  case single (@lbigint registerGroupBaseAddress)
}

#·······················································································································

list @registerGroupListAST {
  @lstring mRegisterGroupName
  @controlRegisterGroupKindAST mControlRegisterGroupKind
}

#·······················································································································

class @controlRegisterGroupDeclarationAST  : @abstractDeclarationAST {
  @registerGroupListAST mRegisterGroupList
  @controlRegisterDeclarationList mRegisters
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $registers$
    @registerGroupListAST registerGroupListAST = {}
    repeat
      $identifier$ ?let registerGroupName
      $integer$ ?let @lbigint registerGroupBaseAddress
      let groupKind = @controlRegisterGroupKindAST.single {!registerGroupBaseAddress:registerGroupBaseAddress}
      registerGroupListAST += !registerGroupName !groupKind
    while
      $,$
    end
    ${$
    @controlRegisterDeclarationList controlRegisterDeclarationList = {}
    repeat
    while
      @controlRegisterNameListAST registerDeclarationList = {}
      repeat
        <registerDeclaration> !?ioAST !?registerDeclarationList
      while
      end
      $\$type$ ?let registerTypeName
      @controlRegisterBitSliceList registerBitSliceList = {}
      select
      or
        ${$
        repeat
          @controlRegisterBitSlice registerBitSlice
          select
            $integer$ ?let @lbigint unusedBitCount
            registerBitSlice = .unusedBits {!count:unusedBitCount}
          or
            $identifier$ ?let bitName
            select
              registerBitSlice = .namedBit {!name:bitName !count:.new{!1G !.here}}
            or
              $:$
              $integer$ ?let @lbigint bitCount
              registerBitSlice = .namedBit {!name:bitName !count:bitCount}
            end
          end
          registerBitSliceList += !registerBitSlice
        while
          $,$
        end
        $}$
      end
      let endOfBitSlice = @location.here
      controlRegisterDeclarationList += !registerDeclarationList !registerTypeName !registerBitSliceList !endOfBitSlice
    end
    ioAST.mDeclarationListAST += !@controlRegisterGroupDeclarationAST.new {
      !registerGroupListAST
      !controlRegisterDeclarationList
    }
    $}$
  }

  #·····················································································································

  rule <registerDeclaration> ?!@ast ioAST ?!@controlRegisterNameListAST ioRegisterDeclarationList {
    $identifier$ ?let registerName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    select
      <expression> !?ioAST ?let registerAddress
      ioRegisterDeclarationList +=
        !registerName
        !.scalar
        !attributeList
        !registerAddress 
        !.here
    or
      $[$
      <expression> !?ioAST ?let sizeExpression
      let sizeExpressionLocation = @location.here
      $]$
      <expression> !?ioAST ?let baseAddressExpression
      let baseAddressExpressionLocation = @location.here
      $@attribute$ ?let attribute
      if attribute.string != "inc" then
        error attribute : "attribute should be @inc" fixit { replace "@inc" }
      end
      <expression> !?ioAST ?let arrayElementSizeExpression
      let arrayElementSizeExpressionLocation = @location.here
      ioRegisterDeclarationList +=
        !registerName
        !.registerArray {
           !arraySize:sizeExpression
           !arraySizeLocation:sizeExpressionLocation
           !arrayElementSize:arrayElementSizeExpression
           !arrayElementSizeLocation:arrayElementSizeExpressionLocation
         }
        !attributeList
        !baseAddressExpression 
        !baseAddressExpressionLocation
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterFieldList { # Used for displaying in HTML file
  @uint mFieldBitCount
  @string mFieldName # "—" if unused
}

#·······················································································································

map @controlRegisterFieldMap {
  @uint mBitIndex
  @uint mBitCount
  insert insertKey error message "the '%K' slice has been already declared"
  search searchKey error message "the '%K' slice is not declared"
}

#·······················································································································

map @sliceMap {
  @llvmBinaryOperation mAccessOperator
  @bigint mAccessRightOperand
  @sliceMap mSubMap
  @PLMType mResultType
  insert insertKey error message "the '%K' slice has been already declared"
  search searchKey error message "the '%K' slice is not declared"
}

#·······················································································································

enum @controlRegisterGroupKind {
  case single (@bigint address)
}

#·······················································································································

map @controlRegisterMap {
  @PLMType mType
  @bool mIsReadOnly
  @bool mUserAccess
  @sliceMap mRegisterFieldAccessMap
  @controlRegisterFieldMap mRegisterFieldMap
  @controlRegisterGroupKind mControlRegisterGroupKind
  @controlRegisterFieldList mControlRegisterFieldList # Used for HTML file
  @uint mRegisterBitCount
  @uint mArraySize # 0 if not an array
  @uint mElementArraySize # 0 if not an array
  insert insertKey error message "the '%K' register has been already declared in %L"
  search searchKey error message "** internal error **"
}

#·······················································································································

map @controlRegisterGroupMap {
  @controlRegisterMap mControlRegisterMap
  insert insertKey error message "the '%K' control register group has been already declared in %L"
  search searchKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   PRECEDENCE GRAPH
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @controlRegisterGroupDeclarationAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for reg in mRegisters do
    let typeName = llvmTypeNameFromPLMname (!reg.mRegisterTypeName)
    [!?ioGraph noteNode !typeName]
  end
}

#·······················································································································

override getter @controlRegisterGroupDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = registerGroupNameFromPLMname (![mRegisterGroupList mRegisterGroupNameAtIndex !0])
}

#·······················································································································

override getter @controlRegisterGroupDeclarationAST location -> @location {
  result = [mRegisterGroupList mRegisterGroupNameAtIndex !0]
}

#·······················································································································

override method @controlRegisterGroupDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#·······················································································································

override method @controlRegisterGroupDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let nodeName = registerGroupNameFromPLMname (![mRegisterGroupList mRegisterGroupNameAtIndex !0])
#--- Add node
  [!?ioGraph addNode !nodeName !self]
#--- Add dependence definitions
  for reg in mRegisters do
  #--- Add dependency from type name
    let typeName = llvmTypeNameFromPLMname (!reg.mRegisterTypeName)
    [!?ioGraph addEdge !nodeName !typeName]
  #--- Add dependency from the number of integer type name (i.e. $uint32 --> $uint5)
    let split = [reg.mRegisterTypeName componentsSeparatedByString !"uint"]
    if ([split length] == 2) && [[split mValueAtIndex !1] isDecimalUnsignedNumber] then
      let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
      if n > 0 then
        let bitSizeTypeName = @lstring.new {!"uint" + [n-1 significantBitCount] !reg.mRegisterTypeName}
        [!?ioGraph addEdge !nodeName !llvmTypeNameFromPLMname (!bitSizeTypeName)]
      end
    end
  #--- Add integer type corresponding to slices
    for (slice) in reg.mRegisterBitSliceList do
      switch slice
      case unusedBits (*) :
      case namedBit (* @lbigint count) :
        if count.bigint >= 0G then
          [!?ioGraph noteUINTType ![count.bigint uint] !count.location]
        end
      end
    end
  #--- Add dependency from config node
    let rootNode =  @lstring.new {!configurationNodeNameForPrecedenceGraph () !nodeName.location}
    [!?ioGraph addEdge !nodeName !rootNode]
  #--- Add dependency from source expression
    for register in reg.mRegisterArrayList do
      switch register.mControlRegisterKind
      case scalar :
      case registerArray (@expressionAST arraySize * @expressionAST arrayElementSize *) :
        [arraySize addDependenceEdgeForStaticExpression !nodeName !?ioGraph]
        [arrayElementSize addDependenceEdgeForStaticExpression !nodeName !?ioGraph]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc controlRegisterType
  ?let @lstring inRegisterTypeName
  ?!context:@semanticContext ioContext
  !type:@PLMType outRegisterType
  !bitCount:@uint outRegisterBitCount
{
  outRegisterType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inRegisterTypeName} type]
  switch outRegisterType.kind
  case integer (* * * bitCount):
    outRegisterBitCount = bitCount
  case boolean, void :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case enumeration (*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case literalString :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case staticInteger :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case structure (*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case syncTool (*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case opaque (*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case arrayType (* *) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case dynamicArrayType (2*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case function (*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  case pointer (*) :
    error inRegisterTypeName : "a register should be an $intXX or an $uintXX" : outRegisterBitCount
  end
}

#·······················································································································

private proc buildControlRegisterSliceMap
  ?let @controlRegisterBitSliceList inRegisterBitSliceList
  ?let @location inEndOfBitSliceLocation
  ?!context:@semanticContext ioContext
  ?!type:@PLMType ioRegisterType
  ?bitCount:let @uint inRegisterBitCount
  !@controlRegisterFieldMap outRegisterFieldMap
  !@sliceMap outRegisterBitSliceMap
  !@controlRegisterFieldList outControlRegisterFieldList
{
#--- Build bit slice map
  outRegisterFieldMap = {}
  outRegisterBitSliceMap = {}
  outControlRegisterFieldList = {} # Used for HTML file
  if [inRegisterBitSliceList length] > 0 then
    @uint shiftCount = 0
    for > () in inRegisterBitSliceList do
      switch mRegisterBitSlice
      case unusedBits (@lbigint count) :
        shiftCount = shiftCount + [count.bigint uint]
        outControlRegisterFieldList += ![count.bigint uint] ! "—"
      case namedBit (@lstring name @lbigint count) :
        let bitCount = [count.bigint uint]
        outControlRegisterFieldList += !bitCount !name.string
        [!?outRegisterFieldMap insertKey
          !name
          !shiftCount
          !bitCount
        ]
        @sliceMap registerSubMap = {}
      #--- "shifted" property
        [!?registerSubMap insertKey
          !.new{!"shifted" !name.location}
          !.lshr
          ![shiftCount bigint]
          !{}
          !ioRegisterType
        ]
      #--- "bool" property
        [!?registerSubMap insertKey
          !.new{!boolTypeName () !name.location}
          !.icmp_ne
          !0G
          !{}
          ![ioContext booleanType]
        ]
      #--- property name
        let mask = ((1G << bitCount) - 1G) << shiftCount
        [!?outRegisterBitSliceMap insertKey
          !name
          !.and
          !mask
          !registerSubMap
          !ioRegisterType
        ]
        shiftCount = shiftCount + bitCount
      end
    end
  #--- Check slice bit count is correct
    if inRegisterBitCount != shiftCount then
      error inEndOfBitSliceLocation
       : "total bit slice count is " + shiftCount + " (should be " + inRegisterBitCount + ")"
    end
  end
}

#·······················································································································

method @controlRegisterDeclarationList-element enterControlRegisterGroupInContext
  ?let @controlRegisterGroupKindAST inRegisterGroupKind
  ?!context:@semanticContext ioContext
  ?!@controlRegisterMap ioControlRegisterMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
{
  controlRegisterType (!mRegisterTypeName !?context:ioContext ?type:var registerType ?bitCount:let registerBitCount)
#--- Build bit slice map
  buildControlRegisterSliceMap (
    !mRegisterBitSliceList
    !mRegisterBitSliceListLocation
    !?context:ioContext
    !?type:registerType
    !bitCount:registerBitCount
    ?let registerFieldMap
    ?let registerBitSliceMap
    ?let controlRegisterFieldList  # Used for HTML file
  )
#---  
  let @bigint maxRegisterAddress = (1G << ioContext.mTargetParameters.mPointerSize) - 1G
  for register in mRegisterArrayList do
  #--- Analyze attributes
    var isReadOnly = false
    var userAccess = false
    for (att) in register.mAttributeList do
      if att.string == "ro" then
        if isReadOnly then
          error att : "duplicated attribute"
        else
          isReadOnly = true
        end
      elsif att.string == userAttributeForRegister () then
        if userAccess then
          error att : "duplicated attribute"
        else
          userAccess = true
        end
      else
        error att : "only @ro (read only) and @" + userAttributeForRegister () + " attributes are accepted here"
      end
    end
  #--- Analyse register address expression
    [register.mRegisterAddress analyzeStaticExpression
      !errorLocation:register.mRegisterAddressLocation
      !context:ioContext
      !?staticEntityMap:ioStaticEntityMap
      ?result:let @objectIR addressOffsetExpressionResult
    ]
    @controlRegisterGroupKind controlRegisterGroupKind
    if not [addressOffsetExpressionResult isLiteralInteger] then
      error register.mRegisterAddressLocation
        : "control register address offset is not a static integer expression"
        : controlRegisterGroupKind
    else
      [addressOffsetExpressionResult literalInteger ?1* ?value:let registerAddressOffset]
      switch inRegisterGroupKind
      case single (baseAddress) :
        let registerAddress = baseAddress.bigint + registerAddressOffset
        controlRegisterGroupKind = .single {!address:registerAddress}
#      registerAddress = inRegisterGroupBaseAddress + registerAddressOffset
     #--- Check address value
        if registerAddress > maxRegisterAddress then
          error register.mRegisterAddressLocation
           : "register address should be lower or equal to " + [maxRegisterAddress hexString]
        end
      end
    end
    @bigint arraySize
    @uint elementArraySize
    switch register.mControlRegisterKind
    case scalar :
      arraySize = 0G
      elementArraySize = 0
    case registerArray (@expressionAST arraySizeExpression @location arraySizeLocation
                        @expressionAST arrayElementSizeExpression @location arrayElementSizeLocation) :
    #--- Analyse register array size expression
      @semanticTemporariesStruct temporaries = .default
      @instructionListIR instructionGenerationList = {}
      @allocaList allocaList = {}
      [arraySizeExpression analyzeExpression
        !self:voidType ()
        !routineAttributes:.none
        !routineNameForInvocationGraph:["compiler" nowhere]
        !optionalTargetType:voidType ()
        !context:ioContext
        !mode:.bootMode
        !?temporary:temporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap:ioContext.mValuedObjectMap # universalMap
        !?alloca:allocaList
        !?instructionListIR:instructionGenerationList
        ?result:@objectIR sizeExpressionResult
      ]
      if not [sizeExpressionResult isLiteralInteger] then
        error arraySizeLocation : "control register address is not a static integer expression" : arraySize
      else
        [sizeExpressionResult literalInteger ?1* ?value:arraySize]
        if arraySize < 2G then
          error arraySizeLocation
            : "control register array size should be a static integer expression >= 2, equal to a power of 2"
            : arraySize
        else
          let powerOfTwoForArraySize = [arraySize - 1G bitCountForUnsignedRepresentation]
          if arraySize != (1G << powerOfTwoForArraySize) then
            error arraySizeLocation
              : "control register array size should be a static integer expression >= 2, equal to a power of 2"
              : arraySize
          end
        end
      end
    #--- Analyse element array size expression
      [arrayElementSizeExpression analyzeStaticExpression
        !errorLocation:arrayElementSizeLocation
        !context:ioContext
        !?staticEntityMap:ioStaticEntityMap
        ?result:let @objectIR elementArraySizeExpressionResult
      ]
      if not [elementArraySizeExpressionResult isLiteralInteger] then
        error arrayElementSizeLocation
          : "element size is not a static integer expression"
          : elementArraySize
      else
        [elementArraySizeExpressionResult literalInteger ?1* ?value:let elementArraySizeAsBigInt]
        elementArraySize = [elementArraySizeAsBigInt uint]
      end
    end
    [!?ioControlRegisterMap insertKey
      !register.mRegisterName
      !registerType
      !isReadOnly
      !userAccess
      !registerBitSliceMap
      !registerFieldMap
      !controlRegisterGroupKind
      !controlRegisterFieldList
      !registerBitCount
      ![arraySize uint]
      !elementArraySize
    ]
  end
}

#·······················································································································

override method @controlRegisterGroupDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
{
  for group in mRegisterGroupList while @uint.errorCount == 0 do
    @controlRegisterMap controlRegisterMap = {}
    for reg in mRegisters do
      [reg enterControlRegisterGroupInContext
        !group.mControlRegisterGroupKind
        !?context:ioContext
        !?controlRegisterMap
        !?staticEntityMap:ioStaticEntityMap
      ]
    end
    [!?ioContext.mControlRegisterGroupMap insertKey !group.mRegisterGroupName !controlRegisterMap]
    [!?ioContext.mValuedObjectMap insertRegisterGroup !group.mRegisterGroupName !controlRegisterMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  BUILD HTML FILE                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @controlRegisterByAddress {
  @bigint mAddress
  @string mHTML
}{
  mAddress <
}

#·······················································································································

proc buildControlRegisterMapHTMLFile
  ?let @controlRegisterGroupMap inControlRegisterGroupMap
  ?sourceFile:let @lstring inSourceFile
{
#------------------------------- Build an HTML file that contains all declared control registers, ordered by names
  @string typeDumpFilePath = inSourceFile.string + ".control-registers-by-names.html"
  if [option plm_options.writeControlRegisterHTMLDumpFile value] then
    @stringset firstLetterSet = {}
    for () in inControlRegisterGroupMap do
      firstLetterSet += ![[lkey.string characterAtIndex!0] string]
    end
    @string tableOfTypeString = ""
    @char currentFirstLetter = ' '
    @uint controlRegisterCount = 0
    for () group_ in inControlRegisterGroupMap do
      for () reg_ in group_mControlRegisterMap do
        let registerName = group_lkey.string + ":" + reg_lkey
        if currentFirstLetter != [registerName characterAtIndex !0] then
          currentFirstLetter = [registerName characterAtIndex !0]
          tableOfTypeString += "<br><a name=\"" + [currentFirstLetter uint] + "\"><b>" + currentFirstLetter + "</b></a><br>"
        end
        if reg_mArraySize == 0 then
          controlRegisterCount = controlRegisterCount + 1
          tableOfTypeString += linkForControlRegister (!registerName) + "<br>"
        else
          controlRegisterCount = controlRegisterCount + reg_mArraySize
          for i in 0 ..< reg_mArraySize do
            tableOfTypeString += linkForControlRegister (!registerName + "[" + i + "]") + "<br>"
          end
        end
      end
    end
    let @string typeDumpString = [filewrapper controlRegisterDumpGenerationTemplate.dumpByName
      ![inSourceFile lastPathComponent]
      !controlRegisterCount
      !inControlRegisterGroupMap
      !firstLetterSet
      !tableOfTypeString
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
#------------------------------- Build an HTML file that contains all declared control registers, ordered by address
  typeDumpFilePath = inSourceFile.string + ".control-registers-by-address.html"
  if [option plm_options.writeControlRegisterHTMLDumpFile value] then
    @controlRegisterByAddress controlRegisterByAddress = {}
    @uint controlRegisterCount = 0
    for () group_ in inControlRegisterGroupMap do
      for () reg_ in group_mControlRegisterMap do
        switch reg_mControlRegisterGroupKind
        case single (registerAddress) :
          if reg_mArraySize == 0 then
            controlRegisterCount = controlRegisterCount + 1
            var s = "<tr class=\"result_line\"><td class=\"name\">"
              + group_lkey.string + ":" + reg_lkey
              + "</td><td class=\"type\">$" + reg_mType.plmOriginalTypeName + "</td><td class=\"address\">"
              + [registerAddress hexStringSeparatedBy !'_' !4] + "</td><td>"
            if [reg_mControlRegisterFieldList length] > 0 then
              s += "<table class=\"fields\">"
                + "<tr>" + fieldIndexColumns (!reg_mRegisterBitCount) +  "</tr>"
                + "<tr>"
              for > () in reg_mControlRegisterFieldList do
                s += "<td class=\"fields\" colspan=\"" + [mFieldBitCount string] + "\">" + mFieldName + "</td>"
              end
              s += "</tr></table>"
            end  
            s += "</td></tr>\n"
            controlRegisterByAddress += !registerAddress !s
          else
            controlRegisterCount = controlRegisterCount + reg_mArraySize
            for () in arrayIndexListFor (!size:reg_mArraySize) do
              let address = registerAddress + mValue * reg_mElementArraySize
              var s = "<tr class=\"result_line\"><td class=\"name\">"
                + group_lkey.string + ":" + reg_lkey + "[" + [mValue string] + "]"
                +"</td><td class=\"type\">$" + reg_mType.plmOriginalTypeName + "</td><td class=\"address\">"
                + [address hexStringSeparatedBy !'_' !4]
                + "</td><td>"
              if [reg_mControlRegisterFieldList length] > 0 then
                s += "<table class=\"fields\">"
                  + "<tr>" + fieldIndexColumns (!reg_mRegisterBitCount) + "</tr><tr>"
                for > () in reg_mControlRegisterFieldList do
                  s += "<td class=\"fields\" colspan=\"" + [mFieldBitCount string] + "\">" + mFieldName + "</td>"
                end
                s += "</tr></table>"
              end  
              s += "</td></tr>\n"
              controlRegisterByAddress += !registerAddress !s
            end
          end
        end
      end
    end
    let @string typeDumpString = [filewrapper controlRegisterDumpGenerationTemplate.dumpByAddress
      ![inSourceFile lastPathComponent]
      !controlRegisterCount
      !controlRegisterByAddress
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper controlRegisterDumpGenerationTemplate in "../generation-templates/" {
}{
}{
  template dumpByName "controlRegisterByNameDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@uint CONTROL_REGISTER_COUNT
    ?@controlRegisterGroupMap CONTROL_REGISTER_GROUP_MAP
    ?@stringset FIRST_LETTER_SET
    ?@string TABLE_OF_TYPES_STRING

  template dumpByAddress "controlRegisterByAddressDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@uint CONTROL_REGISTER_COUNT
    ?@controlRegisterByAddress CONTROL_REGISTER_SORTED_BY_ADDRESS
}

#----------------------------------------------------------------------------------------------------------------------*

private func linkForControlRegister ?let @string inControlRegisterName -> @string {
  result = "<a class=\"header_link\" href=\"#" + inControlRegisterName + "\">" + inControlRegisterName + "</a>"
}

#----------------------------------------------------------------------------------------------------------------------*

func fieldIndexColumns ?let @uint inBitCount -> @string  {
  result = ""
  for > x in 0 ..< inBitCount do
    result += "<td class=\"fields\">" + x + "</td>"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

func arrayIndexListFor ?size:let @uint inSize -> @uintlist {
  result = {}
  for i in 0 ..< inSize do
    result += !i
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

