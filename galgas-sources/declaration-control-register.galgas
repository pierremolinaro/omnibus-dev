#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterNameList {
  @lstring mRegisterName
  @lstringlist mAttributeList
  @expressionAST mRegisterAddress
  @location mRegisterAddressLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterDeclarationListAST {
  @controlRegisterNameList mRegisterNameList
  @lstring mRegisterTypeName
  @controlRegisterBitSliceList mRegisterBitSliceList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterBitSliceList {
  @controlRegisterBitSlice mRegisterBitSlice
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @controlRegisterBitSlice {
  case unusedBits (@lbigint count)
  case namedBit (@lstring name @lbigint count)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $register$
    @controlRegisterNameList registerDeclarationList = {}
    repeat
      $identifier$ ?let registerName
      @lstringlist attributeList = {}
      repeat
      while
        $attribute$ ?let attribute
        attributeList += !attribute
      end
      select
        $at$
        <expression> ?let registerAddress
        registerDeclarationList += !registerName !attributeList !registerAddress !.here
      or
        $[$
        <expression> ?let sizeExpression
        $]$
        $at$
        <expression> ?let baseAddressExpression
        $:$
        <expression> ?let registerAddressMultiplicator
      end
    while
    end
    $typeName$ ?let registerTypeName
    @controlRegisterBitSliceList registerBitSliceList = {}
    select
    or
      ${$
      repeat
        @controlRegisterBitSlice registerBitSlice
        select
          $integer$ ?let @lbigint unusedBitCount
          registerBitSlice = .unusedBits {!count:unusedBitCount}
        or
          $identifier$ ?let bitName
          select
            registerBitSlice = .namedBit {!name:bitName !count:.new{!1G !.here}}
          or
            $[$
            $integer$ ?let @lbigint bitCount
            $]$
            registerBitSlice = .namedBit {!name:bitName !count:bitCount}
          end
        end
        registerBitSliceList += !registerBitSlice
      while
        $,$
      end
      $}$
    end
    ioAST.mControlRegisterDeclarationListAST +=
      !registerDeclarationList
      !registerTypeName
      !registerBitSliceList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @controlRegisterFieldList { # Used for displaying in HTML file
  @uint mFieldBitCount
  @string mFieldName # "—" if unused
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @controlRegisterFieldMap {
  @uint mBitIndex
  @uint mBitCount
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @controlRegisterBitSliceAccessMap {
  @llvmBinaryOperation mAccessOperator
  @bigint mAccessRightOperand
  @controlRegisterBitSliceAccessMap mSubMap
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "the '%K' register slice has been already declared"
  search searchKey error message "the '%K' register slice is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @controlRegisterMap {
  @unifiedTypeMap-proxy mType
  @bool mIsReadOnly
  @bool mIsAccessibleInUserMode
  @controlRegisterBitSliceAccessMap mRegisterFieldAccessMap
  @controlRegisterFieldMap mRegisterFieldMap
  @bigint mAddress
  @controlRegisterFieldList mControlRegisterFieldList # Used for HTML file
  @uint mRegisterBitCount
  insert insertKey error message "the '%K' register has been already declared in %L"
  search searchKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @controlRegisterDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (registerNameList registerTypeName *) in self do
    let typeName = @lstring.new {!"$" + registerTypeName !registerTypeName.location}
    [!?ioGraph noteNode !typeName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterControlRegistersInContext
  ?let @controlRegisterDeclarationListAST inRegisterDeclarationListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  for register in inRegisterDeclarationListAST do
    [register enterControlRegistersInContext !?context:ioContext !?staticStringMap:ioGlobalLiteralStringMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @controlRegisterDeclarationListAST-element enterControlRegistersInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  let registerType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mRegisterTypeName}
  @uint registerBitCount
  switch [registerType kind]
  case integer (*** bitCount):
    registerBitCount = bitCount
  case boolean :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" :registerBitCount
  case boolset :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  case enumeration (*) :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  case literalString :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  case staticInteger :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  case structure (**) :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  case opaque (*) :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  case arrayType (* *) :
    error mRegisterTypeName : "a register should be an $intXX or an $uintXX" : registerBitCount
  end
#--- Build bit slice map
  let @bigint maxRegisterAddress = (1G << ioContext.mPointerSize) - 1G
  @classConstantMap classConstantMap = {}
  @controlRegisterFieldMap registerFieldMap = {}
  @controlRegisterBitSliceAccessMap registerBitSliceMap = {}
  @controlRegisterFieldList controlRegisterFieldList = {} # Used for HTML file
  if [mRegisterBitSliceList length] > 0 then
    @uint shiftCount = 0
    for > () in mRegisterBitSliceList do
      switch mRegisterBitSlice
      case unusedBits (@lbigint count) :
        shiftCount = shiftCount + [count.bigint uint]
        controlRegisterFieldList += ![count.bigint uint] ! "—"
      case namedBit (@lstring name @lbigint count) :
        let bitCount = [count.bigint uint]
        if bitCount == 1 then
          [!?classConstantMap insertKey !name !.new{!registerType !.literalInteger {!value:1G << shiftCount}}]
        end
        controlRegisterFieldList += !bitCount !name.string
        [!?registerFieldMap insertKey
          !name
          !shiftCount
          !bitCount
        ]
        @controlRegisterBitSliceAccessMap registerSubMap = {}
        [!?registerSubMap insertKey
          !.new{!"shifted" !name.location}
          !.lshr
          ![shiftCount bigint]
          !{}
          !registerType
        ]
        [!?registerSubMap insertKey
          !.new{!boolTypeName () !name.location}
          !.icmp_ne
          !0G
          !{}
          !ioContext.mBooleanType
        ]
        let mask = ((1G << bitCount) - 1G) << shiftCount
        [!?registerBitSliceMap insertKey
          !name
          !.and
          !mask
          !registerSubMap
          !registerType
        ]
        shiftCount = shiftCount + bitCount
      end
    end
  end
#---  
  for register in mRegisterNameList do
  #--- Analyze attributes
    var isReadOnly = false
    var isAccessibleInUserMode = false
    for (att) in register.mAttributeList do
      if att.string == "ro" then
        if isReadOnly then
          error att : "duplicated attribute"
        else
          isReadOnly = true
        end
      elsif att.string == userModeName () then
        if isAccessibleInUserMode then
          error att : "duplicated attribute"
        else
          isAccessibleInUserMode = true
        end
      else
        error att : "only @ro attribute (read only) and @user (accessible un `user mode) are accepted here"
      end
    end
  #--- Analyse register address expression
    @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    @allocaList allocaList = {}
    [register.mRegisterAddress analyzeExpression
      !self:.null
      !directAccessToPropertiesAllowed:false
      !inGuard:false
      !routineNameForInvocationGraph:["compiler" nowhere]
      !optionalTargetType:.null
      !context:ioContext
      !modes:{}
      !allowPanic:true
      !?temporary:temporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:*
      !?alloca:allocaList
      !?instructionListIR:instructionGenerationList
      ?result:let @operandIR expressionResult
    ]
    @bigint registerAddress
    if ([allocaList length] > 0) || ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
      error register.mRegisterAddressLocation : "control register address is not a static expression" : registerAddress
    else
      [expressionResult.mValue literalInteger ?value:registerAddress]
   #--- Check address value
      if registerAddress > maxRegisterAddress then
        error register.mRegisterAddressLocation : "register address should be lower or equal to " + [maxRegisterAddress hexString]
      end
    end
  #--- Enter in control register map
    [!?ioContext.mControlRegisterMap insertKey
      !register.mRegisterName
      !registerType
      !isReadOnly
      !isAccessibleInUserMode
      !registerBitSliceMap
      !registerFieldMap
      !registerAddress
      !controlRegisterFieldList
      !registerBitCount
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc controlRegistersSemanticAnalysis
  ?let @controlRegisterDeclarationListAST inRegisterDeclarationListAST
  ?context:let @semanticContext inContext
{
  for (registerNameList registerTypeName registerBitSliceList) in inRegisterDeclarationListAST do
  #--- Check type
    let registerType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !registerTypeName}
    switch [registerType kind]
    case boolean : error registerTypeName : "a boolean type is not valid for a register"
    case boolset : error registerTypeName : "a boolset type is not valid for a register"
    case integer (* * @bool unsigned @uint size) :
      if [registerBitSliceList length] > 0 then
        if not unsigned then
          error registerTypeName:"the register type should be unsigned in order to define bit slices"
        end
        @uint shiftCount = 0
        for > () in registerBitSliceList do
          switch mRegisterBitSlice
          case unusedBits (@lbigint count) :
            shiftCount = shiftCount + [count.bigint uint]
          case namedBit (* @lbigint count) :
            shiftCount = shiftCount + [count.bigint uint]
          end
        end
        if size != shiftCount then
          error registerTypeName : "total bit slice count is " + shiftCount + " (should be " + size + ")"
        end
      end
    case literalString : error registerTypeName : "a literal string type is not valid for a register"
    case structure (* *) : error registerTypeName : "a structure type is not valid for a register"
    case enumeration (*) : error registerTypeName : "an enumeration type is not valid for a register"
    case staticInteger : error registerTypeName : "a literal integer type is not valid for a register"
    case opaque (*) : error registerTypeName : "an opaque type is not valid for a register"
    case arrayType (* *) : error registerTypeName : "an array type is not valid for a register"
    end
  #--- Enter in control register map
#    for () in registerNameList do
#      [inContext.mControlRegisterMap searchKey !mRegisterName ?5* ?let address ?2*]
#      [!?ioIntermediateCodeStruct.mControlRegisterMapIR insertKey
#        !mRegisterName
#        !registerTypeName.string
#        !address
#      ]
#    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  BUILD HTML FILE                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildControlRegisterMapHTMLFile
  ?let @controlRegisterMap inControlRegisterMap
  ?sourceFile:let @lstring inSourceFile
{
#------------------------------------ Build an HTML file that contains all declared constants
  let @string typeDumpFilePath = inSourceFile.string + ".control-registers.html"
  if [option plm_options.writeControlRegisterHTMLDumpFile value] then
    @stringset firstLetterSet = {}
    for () in inControlRegisterMap do
      firstLetterSet += ![[lkey.string characterAtIndex!0] string]
    end
    @string tableOfTypeString = ""
    @char currentFirstLetter = ' '
    for () type_ in inControlRegisterMap do
      if currentFirstLetter != [type_lkey.string characterAtIndex !0] then
        currentFirstLetter = [type_lkey.string characterAtIndex !0]
        tableOfTypeString += "<br><a name=\"" + [currentFirstLetter uint] + "\"><b>" + currentFirstLetter + "</b></a><br>"
      end
      tableOfTypeString += linkForControlRegister (!type_lkey.string) + "<br>"
    end
    let @string typeDumpString = [filewrapper controlRegisterDumpGenerationTemplate.dump
      ![inSourceFile lastPathComponent]
      !inControlRegisterMap
      !firstLetterSet
      !tableOfTypeString
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper controlRegisterDumpGenerationTemplate in "../generation-templates/" {
}{
}{
  template dump "controlRegisterDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@controlRegisterMap CONTROL_REGISTER_MAP
    ?@stringset FIRST_LETTER_SET
    ?@string TABLE_OF_TYPES_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

private func linkForControlRegister ?let @string inControlRegisterName -> @string outResult {
  outResult = "<a class=\"header_link\" href=\"#" + inControlRegisterName + "\">" + inControlRegisterName + "</a>"
}

#----------------------------------------------------------------------------------------------------------------------*

func fieldIndexColumns ?let @uint inBitCount -> @string outResult {
  outResult = ""
  for > x in 0 ..< inBitCount do
    outResult += "<td class=\"fields\">" + x + "</td>"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

