#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @compileTimeIntegerDeclarationAST : @abstractDeclarationAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @compileTimeIntegerDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compileTimeIntegerDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let ctIntegerTypeName = [ctIntegerTypeName () nowhere]
  [!?ioGraph addNode !ctIntegerTypeName !self]
  [!?ioGraph addEdge !compileTimeDeclarationBarrier () !ctIntegerTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @compileTimeIntegerDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = ctIntegerTypeName () 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compileTimeIntegerDeclarationAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
  let integerTypeName = [ctIntegerTypeName () nowhere]
 #---
  [!?ioContext.mTypeMap insertType
    !lkey:integerTypeName
    !type: compileTimeIntegerType ()
  ]
#--- Enter integer operators
  enterLiteralIntegerOperators (
    !?context:ioContext
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enterLiteralIntegerOperators
  ?!context:@semanticContext ioContext
{
  let literalIntegerTypeName = [ctIntegerTypeName () nowhere]
#--- Infix operators
  let intIntOp = combineTypeNamesForInfixOperator (!literalIntegerTypeName.string !literalIntegerTypeName.string)
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !literalIntegerTypeName} type]
#--- Comparison infix operator
  let booleanType = [ioContext booleanType]
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_eq}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !booleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_slt}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_sle}
  ]
#--- Bit Wise operators (for unsigned integers)
  [!?ioContext.mAndOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.and}
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.ior}
  ]
  [!?ioContext.mXorOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.xor}
  ]
#  [!?ioContext.mUnsignedComplementOperatorMap insertKey
#    !literalIntegerTypeName
#  ]
#--- Negate operator
#  [!?ioContext.mUnaryMinusOperatorMap insertKey
#    !literalIntegerTypeName
#  ]
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.saddOVF}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.ssubOVF}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.smulOVF}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sdivOVF}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sdivNoOVF}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sremOVF}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sremNoOVF}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.lshr}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INFIX OPERATIONS                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_literal_integerInfixOperation : @omnibusInfixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_literal_integerInfixOperation generateInfixOperatorCode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  !@objectIR outResult
{
  [inLeftOperand  literalInteger ?1* ?value:let @bigint leftValue]
  [inRightOperand literalInteger ?1* ?value:let @bigint rightValue]
  let result = [self performStaticOperation !leftValue !rightValue]
  outResult = .literalInteger {!type: inResultType !value:result}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

