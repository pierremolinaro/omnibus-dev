#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @requiredProcedureDeclarationListAST {
  @bool mMutating
  @lstring mRequiredProcedureName
  @lstringlist mProcedureModeList
  @procFormalArgumentList mProcFormalArgumentList
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $required$
    <procedure_header>
      ?procModes:let requiredModeList
      ?name:let procName
      ?attributes:let unused attributeList
      ?formalArguments:let procFormalArgumentList
      ?mutating:let mutating
    ioAST.mRequiredProcList += !mutating !procName !requiredModeList !procFormalArgumentList !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkRequiredProcedures
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location inEndOfSourceFile
{
  for requiredProc in inAST.mRequiredProcList do
    let lkey = @lstring.new {!"." + requiredProc.mRequiredProcedureName !requiredProc.mRequiredProcedureName.location}
    if not [inSemanticContext.mRoutineMapForContext hasKey !lkey.string] then
      var s = "the '" + requiredProc.mRequiredProcedureName + "' should be defined as: proc"
      for (mode) in requiredProc.mProcedureModeList do
        s += " `" + mode
      end
      s += " " + requiredProc.mRequiredProcedureName
      for arg in requiredProc.mProcFormalArgumentList do
        s += " "
        switch arg.mFormalArgumentPassingMode
        case input : s += "?"
        case output : s += "!"
        case inputOutput : s += "?!"
        end
        if arg.mSelector.string != "" then
          s += arg.mSelector.string + ":"
        end
        s += arg.mFormalArgumentTypeName.string
      end
      error inEndOfSourceFile : s
    else
      [inSemanticContext.mRoutineMapForContext searchKey !lkey ?* ?let procModes ?3*]
      let actualProcModeSet = [procModes keySet]
      let requiredProcModeSet = @stringset.setWithLStringList{!requiredProc.mProcedureModeList}
      if actualProcModeSet != requiredProcModeSet then
        var s = "required modes:"
        for (mode) in requiredProcModeSet do
          s += " `" + mode
        end
        error [inSemanticContext.mRoutineMapForContext locationForKey !lkey.string] : s
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
