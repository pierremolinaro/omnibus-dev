#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @requiredFunctionDeclarationListAST {
  @lstring mName
  @mode mExecutionMode
  @bool mIsExported
  @bool mIsSafe
  @routineFormalArgumentListAST mFormalArgumentList
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $required$
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    var isGlobal = false
    var isSafe = false
    for (attribute) in attributeList do
      if attribute.string == exportedAttribute () then
        if isGlobal then
          error attribute : "duplicated attribute" fixit { remove }
        else
          isGlobal = true
        end
      elsif attribute.string == safeAttribute () then
        if isSafe then
          error attribute : "duplicated attribute" fixit { remove }
        else
          isSafe = true
        end
      else
        error attribute : "invalid attribute" fixit { replace "@" + exportedAttribute () replace "@" + safeAttribute () }
      end
    end
    ioAST.mRequiredFunctionListAST +=
      !procName
      !mode
      !isGlobal
      !isSafe
      !procFormalArgumentList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkRequiredProcedures
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location unused inEndOfSourceFile
{
  for requiredFunction in inAST.mRequiredFunctionListAST do
    let argumentSignature = [requiredFunction.mFormalArgumentList routineSignature !requiredFunction.mName]
    if not [inSemanticContext.mRoutineMapForContextEX hasKey !"" !requiredFunction.mName !argumentSignature] then
      error requiredFunction.mName : "required func is not implemented"
    else
      [inSemanticContext.mRoutineMapForContextEX searchKey
        !""
        !requiredFunction.mName
        !argumentSignature
        ?*
        ?let @routineDescriptor routineDescriptor
        ?let @location routineLocation
      ]
      let isExported = routineDescriptor.exported
      let mode = [routineDescriptor.routineKind executionMode]
    #--- Check modes
      if mode != requiredFunction.mExecutionMode then
        error routineLocation : "required mode should be '" + requiredFunction.mExecutionMode + "'"    
      end
    #--- Check attributes
      if requiredFunction.mIsExported && not isExported then
        error routineLocation
        : "missing @" + exportedAttribute () + " attribute (required function declaration names it)"
        fixit { after " @" + exportedAttribute () }
      elsif isExported && not requiredFunction.mIsExported then
        error routineLocation
        : "incorrect @" + exportedAttribute () + " attribute (required function declaration does not name it)"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
