#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @requiredProcedureDeclarationListAST {
  @lstring mName
  @mode mMode
  @bool mIsGlobal
  @procFormalArgumentList mFormalArgumentList
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $required$
    <function_header>
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
#    let funcMangledName = routineMangledNameFromAST (
#      !"" 
#      !procName
#      !procFormalArgumentList
#    )
    var isGlobal = false
    for (attribute) in attributeList do
      if attribute.string != exportedAttribute () then
        error attribute : "invalid attribute" fixit { replace "@" + exportedAttribute () }
      elsif isGlobal then
        error attribute : "duplicated attribute" fixit { remove }
      else
        isGlobal = true
      end
    end
    ioAST.mRequiredProcListAST +=
      !procName
#      !.new{!funcMangledName !procName.location}
      !mode
      !isGlobal
      !procFormalArgumentList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkRequiredProcedures
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location unused inEndOfSourceFile
{
  for requiredProc in inAST.mRequiredProcListAST do
    let argumentSignature = argumentSignatureFromFormalArgumentList (!requiredProc.mName !requiredProc.mFormalArgumentList)
    if not [inSemanticContext.mRoutineMapForContext hasKey !requiredProc.mName !argumentSignature] then
      error requiredProc.mName : "required func is not implemented"
    else
      [inSemanticContext.mRoutineMapForContext searchKey
        !requiredProc.mName
        !argumentSignature
        ?*
        ?let @routineDescriptor routineDescriptor
        ?let @location routineLocation
      ]
      let isGlobal = routineDescriptor.mGlobal
      let mode = routineDescriptor.mMode
    #--- Check modes
      if mode != requiredProc.mMode then
        error routineLocation : "required mode should be '" + requiredProc.mMode + "'"    
      end
    #--- Check attributes
      if requiredProc.mIsGlobal && not isGlobal then
        error routineLocation
        : "missing @" + exportedAttribute () + " attribute (required function declaration names it)"
        fixit { after " @" + exportedAttribute () }
      elsif isGlobal && not requiredProc.mIsGlobal then
        error routineLocation
        : "incorrect @" + exportedAttribute () + " attribute (required function declaration does not name it)"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
