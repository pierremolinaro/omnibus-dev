#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @requiredProcedureDeclarationListAST {
  @lstring mRequiredProcedureName
  @mode mMode
  @bool mIsGlobal
  @procFormalArgumentList mProcFormalArgumentList
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $required$
    <function_header>
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    var funcMangledName = procName.string + "("
    for (passingMode selector * *) in procFormalArgumentList do
      funcMangledName += [passingMode formalPassingModeString]
      funcMangledName += selector
      funcMangledName += ":"
    end
    funcMangledName += ")"
    var isGlobal = false
    for (attribute) in attributeList do
      if attribute.string != globalAttribute () then
        error attribute : "invalid attribute" fixit { replace "@" + globalAttribute () }
      elsif isGlobal then
        error attribute : "duplicated attribute" fixit { remove }
      else
        isGlobal = true
      end
    end
    ioAST.mRequiredProcListAST +=
      !.new{!funcMangledName !procName.location}
      !mode
      !isGlobal
      !procFormalArgumentList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkRequiredProcedures
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location unused inEndOfSourceFile
{
  for requiredProc in inAST.mRequiredProcListAST do
    if not [inSemanticContext.mRoutineMapForContext hasKey !requiredProc.mRequiredProcedureName.string] then
      error requiredProc.mRequiredProcedureName : "required func is not implemented"
    else
      [inSemanticContext.mRoutineMapForContext searchKey
        !requiredProc.mRequiredProcedureName
        ?2*
        ?let isGlobal
        ?*
        ?let @mode mode 
        ?5*
      ]
    #--- Check modes
      if mode != requiredProc.mMode then
        error [inSemanticContext.mRoutineMapForContext locationForKey !requiredProc.mRequiredProcedureName.string]
        : "required mode should be '" + requiredProc.mMode + "'"
      
      end
    #--- Check attributes
      if requiredProc.mIsGlobal && not isGlobal then
        error [inSemanticContext.mRoutineMapForContext locationForKey !requiredProc.mRequiredProcedureName]
        : "missing @" + globalAttribute () + " attribute (required function declaration names it)"
        fixit { after " @" + globalAttribute () }
      elsif isGlobal && not requiredProc.mIsGlobal then
        error [inSemanticContext.mRoutineMapForContext locationForKey !requiredProc.mRequiredProcedureName]
        : "incorrect @" + globalAttribute () + " attribute (required function declaration does not name it)"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
