#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @structureDeclaration : @abstractDeclaration {
  @lstring mStructureName
  @lstringlist mAttributeListAST
  @structureFieldListAST mStructureFieldListAST
  @procedureDeclarationListAST mProcedureDeclarationListAST
  @functionDeclarationListAST mFunctionDeclarationListAST
  @serviceDeclarationListAST mServiceListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @structureDeclaration location -> @location outLocation {
  outLocation = mStructureName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @structureFieldListAST {
  @lstring mFieldName
  @lstring mFieldTypeName
  @expressionAST mInitExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $struct$
    $typeName$ ?let structureName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end 
    ${$
    @procedureDeclarationListAST procedureDeclarationListAST = {}
    @structureFieldListAST fieldList = {}
    @functionDeclarationListAST functionDeclarationListAST = {}
    @serviceDeclarationListAST serviceListAST = {}
    repeat
    while
      $var$
      $identifier$ ?let fieldName
      $typeName$ ?let typeName
      $=$
      <expression> ?let initExpression
      fieldList += !fieldName !typeName !initExpression
    while
      <procedure> !?procedureDeclarationListAST
    while
      <service> !?serviceListAST
    while
      $func$
      <function_declaration> !?functionDeclarationListAST
    while
      $;$
    end
    $}$
    ioAST.mDeclarationList += !@structureDeclaration.new {
      !structureName
      !attributeList
      !fieldList
      !procedureDeclarationListAST
      !functionDeclarationListAST
      !serviceListAST
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration addExtension
  ?!@extensionDeclarationListAST ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  @structureDeclaration newDeclaration = self
  let currentExtensionDeclarationListAST = ioExtensionDeclarationListAST
  ioExtensionDeclarationListAST = {}
  for (typeName procedures fieldList functions) in currentExtensionDeclarationListAST do
    if mStructureName.string == typeName.string then
      newDeclaration = .new {
        ![newDeclaration mStructureName]
        ![newDeclaration mAttributeListAST]
        ![newDeclaration mStructureFieldListAST] + fieldList
        ![newDeclaration mProcedureDeclarationListAST] + procedures
        ![newDeclaration mFunctionDeclarationListAST] + functions
        ![newDeclaration mServiceListAST]
      }
    else
      ioExtensionDeclarationListAST += !typeName !procedures !fieldList !functions
    end
  end
  outNewDeclaration = newDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let structureTypeName = @lstring.new {!"$" + mStructureName !mStructureName.location}
#--- Add structure type name as node
  [!?ioGraph addNode !structureTypeName !self]
#--- add field types
  for (* fieldTypeName initExpression) in mStructureFieldListAST do
    if fieldTypeName.string != "" then
      let typeName = @lstring.new {!"$" + fieldTypeName !fieldTypeName.location}
      [!?ioGraph addEdge !structureTypeName !typeName]
      [initExpression addDependenceEdgeForStaticExpression !structureTypeName !?ioGraph]
    end
  end
#--- Add structure procedures
  for () in mProcedureDeclarationListAST do
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
#--- Add structure functions
  for () in mFunctionDeclarationListAST do
    for (* formalArgumentTypeName *) in mFuncFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    let resultTypeName = @lstring.new {!"$" + mResultTypeName !mResultTypeName.location}
    [!?ioGraph noteNode !resultTypeName]
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
#--- Add structure services
  [mServiceListAST noteTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @structureDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "struct $" + mStructureName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @propertyList {
  @string mPropertyName
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @propertyMap {
  @unifiedTypeMap-proxy mTypeProxy
  @uint mIndex
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Attribute "unique"
  var copiable = true
  for (s) in mAttributeListAST do
    if s.string == "unique" then
      if not copiable then
        error s : "duplicated attribute"
      end
      copiable = false
    else
      error s : "unknown attribute"
    end
  end
#--- Properties
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  for () in mStructureFieldListAST do
    let fieldTypeNameProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mFieldTypeName}
    propertyList += !mFieldName.string !fieldTypeNameProxy
    [!?propertyMap insertKey !mFieldName !fieldTypeNameProxy ![propertyMap count]]
  end
#--- Procedures
  @procedureMap procedureMap = {}
  for procedure in mProcedureDeclarationListAST do
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in procedure.mProcFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
  #--- Check modes
    @modeMap procedureModeMap = {}
    for mode in procedure.mProcedureModeList do
      [ioContext.mModeMap searchKey !mode.mValue]
      [!?procedureModeMap insertKey !mode.mValue]
    end
    [!?procedureMap insertKey
      !procedure.mProcedureName
      !procedure.mMutating
      !procedureModeMap
      !signature
      !false # not weak
    ]
  end
#--- Functions
  @functionMap functionMap = {}
  for function in mFunctionDeclarationListAST do
    @funcSignature signature = {}
    for (selector formalArgumentTypeName *) in function.mFuncFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !selector !typeProxy
    end
  #--- Mode map
    @modeMap functionModeMap = {}
    for () in function.mFunctionModeList do
      [!?functionModeMap insertKey !mValue] ;
    end
  #--- Result type
    let resultType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !function.mResultTypeName}
  #--- Enter in context
    [!?functionMap insertKey
      !function.mFunctionName
      !functionModeMap
      !signature
      !resultType
    ]
  end
#--- services
  [mServiceListAST enterInContext !receiverType:"$" + mStructureName.string !?context:ioContext]
#--- Enter in type map
  [!?ioContext.mTypeMap insertKey
    !lkey:mStructureName
    !llvmTypeName:"%$" + mStructureName.string
    !kind:.structure {!propertyMap:propertyMap !propertyList:propertyList}
    !typedConstantMap:{}
    !procedureMap:procedureMap
    !functionMap:functionMap
    !copiable:copiable
    !equatable:false
    !comparable:false
    !enumerationType:.null # Not enumerable
  ]
#--- Enter init value in context
  @staticStringMap globalLiteralStringMap = {} # Unused here
  @operandIRList operandIRList = {}
  for () in mStructureFieldListAST do
  #--- Field type
    let @unifiedTypeMap-proxy fieldType = if mFieldTypeName.string == ""
      then .null
      else .searchKey {!ioContext.mTypeMap !mFieldTypeName}
    end
  #--- Init expression
    @instructionListIR initInstructionGenerationList = {}
    @semanticTemporariesStruct temporaries = .default
    [mInitExpression analyzeExpression
      !routineNameForInvocationGraph:.new {!mStructureName.string + " init" !mStructureName.location}
      !optionalTargetType:fieldType
      !context:ioContext
      !modes:{}
      !allowException:false
      !?temporary:temporaries
      !?staticStringMap:globalLiteralStringMap
      !?variableMap:*
      !?instructionListIR:initInstructionGenerationList
      ?result:@operandIR expressionIR
    ]
    if not [expressionIR.mValue isStatic] then
      error mFieldName : "initialization expression cannot be computed statically"
    end
    @unifiedTypeMap-proxy type
    if fieldType != .null then
      type = fieldType
    else
      type = expressionIR.mType
    end
    operandIRList += !.new {!type !expressionIR.mValue}
  end
  [!?ioContext.mConstructorMap insertKey !mStructureName !.structure{!values:operandIRList}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let structureType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mStructureName}
  @propertyMap propertyMap
  switch [structureType kind]
  case structure (propMap *) : propertyMap = propMap
  case enumeration (*) : propertyMap = {}
  case integer (* * * *) : propertyMap = {}
  case staticInteger : propertyMap = {}
  case boolean : propertyMap = {}
  case boolset : propertyMap = {}
  case literalString : propertyMap = {}
  case opaque (*) : propertyMap = {}
  end
#--- Analyze procedures
  [self procedureSemanticAnalysis
    !structureType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Analyze functions
  [self functionSemanticAnalysis
    !structureType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Analyze services
  [mServiceListAST serviceSemanticAnalysis
    !receiverType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @structureDeclaration functionSemanticAnalysis
  ?structureType:let @unifiedTypeMap-proxy inStructureType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for function in mFunctionDeclarationListAST do
  #--- Check modes
    @stringset functionModeSet = {}
    for mode in function.mFunctionModeList do
      [inContext.mModeMap searchKey !mode.mValue]
      functionModeSet += !mode.mValue.string
    end
  #--- Check attributes
    @bool warnIfUnused = true
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noWarningIfUnusedAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated attribute"
        end
        warnIfUnused = false
      else
        error attribute : "unknown attribute"
      end
    end
  #--- Variable map
    @variableMap variableMap = initialVariableMap (
      !routineNameForInvocation:funcNameForInvocationGraph (!inStructureType !function.mFunctionName).string
      !context:inContext
      !userMode:[functionModeSet hasKey !"user"]
      !globalsAreConstant:true
    )
  #--- Add "self" variable to variable map
    [!?variableMap insertUsedLocalConstant
      !.new {!"self" !.here}
      !inStructureType
      !true # mReadAccessAllowed
      !.localValue {!type:inStructureType !name:"self"}
      !true # copiable
      !{} # fieldMap
      !false # mCanBeUsedAsInputParameter
      !true # mIsConstant
    ]
  #--- Add 'result" variable
    let resultVarName = @lstring.new {!"result" !function.mResultTypeName.location}
    let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !function.mResultTypeName}
    [!?variableMap insertOutputFormalArgument
      !resultVarName
      !resultType
      !true
      !.localValue {!type:resultType !name:resultVarName.string}
      !true
      !{}
      !true
      !false # Is not constant
    ]
  #--- Analyse formal arguments
    @procFormalArgumentListForGeneration formalArguments = {}
    formalArguments += !.inputOutput !inStructureType !llvmNameForLocalVariable (!"self")
    for (* formalArgumentTypeName formalArgumentName) in function.mFuncFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
      [!?variableMap insertConstantInputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !false
        !true # Is constant
      ]
      formalArguments += !.input !typeProxy !llvmNameForLocalVariable (!formalArgumentName.string)
    end
  #---
    let routineNameForInvocationGraph = funcNameForInvocationGraph (!inStructureType !function.mFunctionName)
    if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
      [!?ioTemporaries.mSubprogramInvocationGraph addNode
        !routineNameForInvocationGraph
        !routineNameForInvocationGraph
      ]
    end
  #--- Analyze instruction list
    @instructionListIR instructionGenerationList = {}
    [function.mInstructionList analyzeRoutineInstructionList
      !routineNameForInvocationGraph:routineNameForInvocationGraph
      !context:inContext
      !modes:functionModeSet
      !allowException:not [functionModeSet hasKey !panicModeName ()]
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
      !?variableMap:variableMap
      !?generatedCode:instructionGenerationList
    ]
  #---
    [variableMap checkAutomatonStates !function.mEndOfFuncLocation]
  #--- Code generation
    [!?ioIntermediateCodeStruct.mFunctionMapIR insertKey
      !.new {!mStructureName.string + "." + function.mFunctionName !function.mFunctionName.location}
      !formalArguments
      !instructionGenerationList
      !resultType
      !resultVarName.string
      !warnIfUnused
    ]  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @structureDeclaration procedureSemanticAnalysis
  ?structureType:let @unifiedTypeMap-proxy inStructureType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for procedure in mProcedureDeclarationListAST do
  #--- Enter subprogram invocation graph
    let procNameForInvocationGraph = procNameForInvocationGraph (!inStructureType !procedure.mProcedureName)
    if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !procNameForInvocationGraph.string] then
      [!?ioTemporaries.mSubprogramInvocationGraph addNode
        !procNameForInvocationGraph
        !procedure.mProcedureName
      ]
    end
  #--- Check modes
    @stringset procedureModeSet = {}
    for mode in procedure.mProcedureModeList do
      [inContext.mModeMap searchKey !mode.mValue]
      procedureModeSet += !mode.mValue.string
    end
  #--- Variable map
    @variableMap variableMap = initialVariableMap (
      !routineNameForInvocation:procNameForInvocationGraph (!inStructureType !procedure.mProcedureName).string
      !context:inContext
      !userMode:[procedureModeSet hasKey !"user"]
      !globalsAreConstant:false
    )
  #--- Add "self" to variable map
    if procedure.mMutating then
      [!?variableMap insertDefinedLocalVariable
        !.new {!"self" !.here}
        !inStructureType
        !true # mReadAccessAllowed
        !.localValue {!type:inStructureType !name:"self"}
        !true # copiable
        !{} # fieldMap
        !true # mCanBeUsedAsInputParameter
        !false # mIsConstant
      ]
    else
      [!?variableMap insertUsedLocalConstant
        !.new {!"self" !.here}
        !inStructureType
        !true # mReadAccessAllowed
        !.localValue {!type:inStructureType !name:"self"}
        !true # copiable
        !{} # fieldMap
        !false # mCanBeUsedAsInputParameter
        !true # mIsConstant
      ]
    end
  #--- Analyse formal arguments
    @procFormalArgumentListForGeneration formalArguments = {}
    formalArguments += !.inputOutput !inStructureType !llvmNameForLocalVariable (!"self")
    enterFormalArguments (
      !context:inContext
      !procedure.mProcFormalArgumentList
      !?variableMap
      !?formalArguments
    )
  #--- Analyze instruction list
    @instructionListIR instructionGenerationList = {}
    [procedure.mInstructionList analyzeRoutineInstructionList
      !routineNameForInvocationGraph:procNameForInvocationGraph
      !context:inContext
      !modes:procedureModeSet
      !allowException:not [procedureModeSet hasKey !panicModeName ()]
      !?temporary:ioTemporaries
      !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
      !?variableMap:variableMap
      !?generatedCode:instructionGenerationList
    ]
    [variableMap checkAutomatonStates !procedure.mEndOfProcLocation]
  #--- Check attributes
    @bool warnIfUnused = true
    for (attribute) in procedure.mProcedureAttributeList do
      if attribute.string == noWarningIfUnusedAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated attribute"
        end
        warnIfUnused = false
      else
        error attribute : "unknown attribute"
      end
    end
  #--- Enter in map
    [!?ioIntermediateCodeStruct.mProcedureMapIR insertKey
      !.new {!mStructureName.string + "." + procedure.mProcedureName !procedure.mProcedureName.location}
      !formalArguments
      !instructionGenerationList
      !false # [ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !mProcedureName.string]
      !warnIfUnused
      !false
      !false
      !false
    ]  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc declareLLVMstructureInitRoutines ?let @typeInitializerMap inTypeInitializerMap ?!@string ioLLVMcode {
#  for (* llvmTypeName initializerMap) in inTypeInitializerMap do
#    for (initializerName propertyList) in initializerMap do
#      ioLLVMcode += "define internal %" + llvmTypeName + " @" + llvmTypeName + "." + initializerName + " () nounwind {\n"
#      var s = "undef"
#      for () in propertyList do (idx)
#        let target = "%result." + idx
#        ioLLVMcode += "  " + target + " = insertvalue %" + llvmTypeName + " " + s
#        ioLLVMcode += ", " + [mOperand.mType llvmTypeName] + " " + [mOperand.mValue llvmName] + ", " + idx + "\n"
#        s = target
#      end
#      ioLLVMcode += "  ret %" + llvmTypeName + " " + s + "\n"
#      ioLLVMcode += "}\n\n"
#    end
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

