#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @structureDeclarationAST : @abstractDeclarationAST {
  @lstring mStructureName
  @lstringlist mAttributeListAST
  @structurePropertyListAST mStructurePropertyListAST
  @functionDeclarationListAST mFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mSystemRoutineListAST
  @guardDeclarationListAST mGuardListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @structureDeclarationAST location -> @location outLocation {
  outLocation = mStructureName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @structurePropertyInitOptionalExpressionAST {
  case expression (@expressionAST initExpression)
  case noExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @structurePropertyListAST {
  @lstring mPropertyName
  @bool mIsConstant # declared by "let" --> true, declared by "var" --> false
  @bool mIsPublic
  @lstring mPropertyTypeName
  @structurePropertyInitOptionalExpressionAST mInitialisation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <private_or_public_struct_property_declaration> ?!@structurePropertyListAST ioFieldListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <struct_property_declaration> !public !?ioFieldListAST
  }
  
  #·····················································································································

  rule <private_struct_property_declaration> ?!@structurePropertyListAST ioFieldListAST {
    <struct_property_declaration> !false !?ioFieldListAST
  }

  #·····················································································································

  rule <struct_property_declaration> ?let @bool isPublic ?!@structurePropertyListAST ioFieldListAST {
    @bool constant
    select
      $var$
      constant = false
    or
      $let$
      constant = true
    end
    $identifier$ ?let fieldName
    select
      $\$type$ ?let typeName
      select
        ioFieldListAST += !fieldName !constant !isPublic !typeName !.noExpression
      or
        $=$
        <expression> ?let initExpression
        ioFieldListAST += !fieldName !constant !isPublic !typeName !.expression{!initExpression:initExpression}
      end
    or
      $=$
      <expression> ?let initExpression
      ioFieldListAST += !fieldName !constant !isPublic !["" nowhere] !.expression{!initExpression:initExpression}
    end
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $struct$
    $\$type$ ?let structureName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end 
    ${$
    @functionDeclarationListAST procedureDeclarationListAST = {}
    @structurePropertyListAST fieldList = {}
    @systemRoutineDeclarationListAST systemRoutineListAST = {}
    @guardDeclarationListAST guardListAST = {}
    repeat
    while
      <private_or_public_struct_property_declaration> !?fieldList
    while
      <function> !?procedureDeclarationListAST
    while
      <system_routine> !?systemRoutineListAST
    while
      <guard> !?guardListAST
    while
      $;$
    end
    $}$
    ioAST.mDeclarationListAST += !@structureDeclarationAST.new {
      !structureName
      !attributeList
      !fieldList
      !procedureDeclarationListAST
      !systemRoutineListAST
      !guardListAST
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclarationAST addExtension
  ?!@extensionDeclarationListAST ioExtensionDeclarationListAST
  !@abstractDeclarationAST outNewDeclaration
{
  @structureDeclarationAST newDeclaration = self
  let currentExtensionDeclarationListAST = ioExtensionDeclarationListAST
  ioExtensionDeclarationListAST = {}
  for (typeName functions properties svcs guards) in currentExtensionDeclarationListAST do
    if mStructureName.string == typeName.string then
      newDeclaration = .new {
        ![newDeclaration mStructureName]
        ![newDeclaration mAttributeListAST]
        ![newDeclaration mStructurePropertyListAST] + properties
        ![newDeclaration mFunctionDeclarationListAST] + functions
        ![newDeclaration mSystemRoutineListAST] + svcs
        ![newDeclaration mGuardListAST] + guards      
      }
    else
      ioExtensionDeclarationListAST += !typeName !functions !properties !svcs !guards
    end
  end
  outNewDeclaration = newDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let structureTypeName = llvmRegularTypeMangledNameFromName (!mStructureName)
#--- Add structure type name as node
  [!?ioGraph addNode !structureTypeName !self]
#--- Add property types
  for (* * * fieldTypeName initExpression) in mStructurePropertyListAST do
    if fieldTypeName.string != "" then
      let typeName = llvmRegularTypeMangledNameFromName (!fieldTypeName)
      [!?ioGraph addEdge !structureTypeName !typeName]
    end
    switch initExpression
    case noExpression :
    case expression (initExpression) :
      [initExpression addDependenceEdgeForStaticExpression !structureTypeName !?ioGraph]
    end
  end
#--- Add structure functions
  for () in mFunctionDeclarationListAST do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      let typeName = llvmRegularTypeMangledNameFromName (!formalArgumentTypeName)
      [!?ioGraph noteNode !typeName]
    end
    if mFunctionReturnTypeName.string != "" then
      let typeName = llvmRegularTypeMangledNameFromName (!mFunctionReturnTypeName)
      [!?ioGraph noteNode !typeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
#--- Add structure services, section, primitives and guards
  [mSystemRoutineListAST noteTypesInPrecedenceGraph !?ioGraph]
  [mGuardListAST noteTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @structureDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "struct $" + mStructureName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @propertyList {
  @string mPropertyName
  @PLMType mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @propertyMap {
  @bool mIsPublic
  @objectIR mPropertyObject
  @PLMType mType
  @propertyAccessKind mAccess
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @constructorSignature {
  @string mSelector
  @PLMType mType
  @uint mFieldIndex
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @sortedOperandIRList {
  @objectIR mOperand
  @uint mIndex
}{
  mIndex <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
#---------------------------------------- Properties
#  @universalPropertyAndRoutineMapForContext universalPropertyAndRoutineMapForContext = .default
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @sortedOperandIRList sortedOperandIRList = {}
  @constructorSignature constructorSignature = {}
  var canBeCopied = true
  for property in mStructurePropertyListAST do
    [property enterInContext
      !mStructureName
      !?context:ioContext
      !?staticStringMap:ioGlobalLiteralStringMap
#      !?universalPropertyAndRoutineMapForContext
      !?propertyList
      !?propertyMap
      !?sortedOperandIRList
      !?constructorSignature
      !?canBeCopied
    ]
  end
#--- Enter in constructor map
  [!?ioContext.mConstructorMap insertKey
    !mStructureName
    !.structure{!constructorSignature:constructorSignature !sortedOperandList:sortedOperandIRList}
  ]
#---------------------------------------- Attribute "copyable"
  var flags = @PLMTypeFlags.instanciable
  for (s) in mAttributeListAST do
    if s.string == "copyable" then
      if [flags copyable] then
        error s : "duplicated attribute"
      elsif not canBeCopied then
        error mStructureName : "this structure cannot be copied, one field is not copyable"
      else
        flags = flags | @PLMTypeFlags.copyable
      end
    else
      error s : "only @copyable attribute is allowed here"
    end
  end
#---------------------------------------- Enter routines in property map
  for function in mFunctionDeclarationListAST do
  #--- Attribute set
    @stringset attributeSet = {}
    for attribute in function.mFunctionAttributeList do
      attributeSet += !attribute.mValue.string
    end
  end
  for system in mSystemRoutineListAST do
  #--- Attribute set
    @stringset attributeSet = {}
    for attribute in system.mAttributeList do
      attributeSet += !attribute.mValue.string
    end
  end
#---------------------------------------- Enter in type map
  [!?ioContext.mTypeMap insertType
    !lkey:mStructureName
    !type:.structure {
      !typeName:mStructureName
      !propertyMap:propertyMap
      !propertyList:propertyList
      !flags:flags
      !plmTypeName:mStructureName
    }
    !index:[ioContext.mTypeMap count]
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @structurePropertyListAST-element enterInContext
  ?let @lstring inStructureName
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
#  ?!@universalPropertyAndRoutineMapForContext universalPropertyAndRoutineMapForContext
  ?!@propertyList propertyList
  ?!@propertyMap propertyMap
  ?!@sortedOperandIRList sortedOperandIRList
  ?!@constructorSignature constructorSignature
  ?!@bool canBeCopied
{
#--- Property type
  let @PLMType optionalPropertyType = if mPropertyTypeName.string == ""
    then .void
    else [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mPropertyTypeName} type]
  end
#--- Variable map (with constants)
  variableMapWithConstants (
    !context:ioContext
    ?@universalPropertyAndRoutineMapForContext universalMap
  )
#--- Init expression
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  switch mInitialisation
  case expression (initExpression) :
    [initExpression analyzeExpression
      !self:.void
      !inGuard:false
      !routineNameForInvocationGraph:.new {!inStructureName.string + " init" !inStructureName.location}
      !optionalTargetType:optionalPropertyType
      !context:ioContext
      !mode:.bootMode
      !?temporary:temporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:universalMap
      !?alloca:allocaList
      !?instructionListIR:initInstructionGenerationList
      ?result:let @objectIR expressionIR
    ]
    if (([initInstructionGenerationList length] + [allocaList length]) > 0) || not [expressionIR isStatic] then
      error mPropertyName : "initialization expression cannot be computed statically"
    end
    @PLMType actualPropertyType
    if optionalPropertyType != .void then
      actualPropertyType = optionalPropertyType
    else
      actualPropertyType = [expressionIR type]
    end
    if not [actualPropertyType instanciable] then
      error mPropertyName : "$" + [actualPropertyType key] + " type is not instanciable"
    end
    if not [actualPropertyType copyable] then
      canBeCopied = false
    end
    if mIsConstant then
     let constantProperty = @propertyAccessKind.constant{!llvmValue:[expressionIR name]}
     [!?propertyMap insertKey
        !mPropertyName
        !mIsPublic
        !.propertyRef {!type:actualPropertyType !plmName:mPropertyName !access:constantProperty}
        !actualPropertyType
        !constantProperty
      ]
#      [!?universalPropertyAndRoutineMapForContext insertProperty
#        !mPropertyName
#        !readOnly:mIsConstant
#        !public:mIsPublic
#        !type:actualPropertyType
#        !access:constantProperty
#      ]
    else
      let propertyIndex = [propertyList length]
      let indexedProperty = @propertyAccessKind.indexed{!index:propertyIndex}
      propertyList += !mPropertyName.string !actualPropertyType
      [!?propertyMap insertKey
        !mPropertyName
        !mIsPublic
        !.propertyRef {!type:actualPropertyType !plmName:mPropertyName !access:indexedProperty}
        !actualPropertyType
        !indexedProperty
      ]
#      [!?universalPropertyAndRoutineMapForContext insertProperty
#        !mPropertyName
#        !readOnly:mIsConstant
#        !public:mIsPublic
#        !type:actualPropertyType
#        !access:indexedProperty
#      ]
      sortedOperandIRList += ![expressionIR withType !actualPropertyType] !propertyIndex
    end
  case noExpression :
    if not [optionalPropertyType instanciable] then
      error mPropertyName : "$" + [optionalPropertyType key] + " type is not instanciable"
    end
    let propertyIndex = [propertyList length]
    propertyList += !mPropertyName.string !optionalPropertyType
    [!?propertyMap insertKey
      !mPropertyName
      !mIsPublic
      !.propertyRef {!type:optionalPropertyType !plmName:mPropertyName !access:.indexed{!index:propertyIndex}}
      !optionalPropertyType
      !.indexed{!index:propertyIndex}
    ]
#    [!?universalPropertyAndRoutineMapForContext insertProperty
#      !mPropertyName
#      !readOnly:mIsConstant
#      !public:mIsPublic
#      !type:optionalPropertyType
#      !access:.indexed{!index:propertyIndex}
#    ]
    constructorSignature += !mPropertyName.string !optionalPropertyType !propertyIndex
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [mFunctionDeclarationListAST enterFunctionInContext
    !selfTypeName:llvmRegularTypeMangledNameFromName (!mStructureName).string
    !?context:ioContext
  ]
  [mSystemRoutineListAST enterInContext
    !receiverType:llvmRegularTypeMangledNameFromName (!mStructureName).string
    !?context:ioContext
  ]
  [mGuardListAST enterInContext
    !receiverType:llvmRegularTypeMangledNameFromName (!mStructureName).string
    !?context:ioContext
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclarationAST semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let structureType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mStructureName} type]
#--- Analyze functions
  [self functionSemanticAnalysis
    !structureType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Analyze system routines
  [mSystemRoutineListAST systemRoutineSemanticAnalysis
    !receiverType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Analyze guards
  [mGuardListAST guardSemanticAnalysis
    !receiverType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Generate property access
  generatePropertyAccess (!structureType:structureType !?intermediateCode:ioIntermediateCodeStruct)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @structureDeclarationAST functionSemanticAnalysis
  ?structureType:let @PLMType inStructureType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for function in mFunctionDeclarationListAST do
    var warnIfUnused = true
    var mutating = false
    var accessProperties = false
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == userAccessAttribute () then
        if accessProperties then
          error attribute : "duplicated @" + userAccessAttribute () + " attribute"
        end
        accessProperties = true    
      elsif attribute.string == mutatingAttribute () then
        if mutating then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        mutating = true    
      else
        error attribute : "unknown attribute; available attributes are @" + noUnusedWarningAttribute ()
          + ", @" + mutatingAttribute () + " and @" + userAccessAttribute ()
      end
    end
    accessProperties = function.mMode != .userMode
    routineSemanticAnalysis (
      !receiverType:inStructureType
      !.function {!executionMode:function.mMode}
      !function.mMode
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
      !returnTypeName:function.mFunctionReturnTypeName
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !directAccessToPropertiesAllowed:accessProperties
      !propertiesAreMutable:mutating
      !warnIfUnused:warnIfUnused
      !globalFunction:false
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  GENERATE PROPERTY ACCESS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @propertyAccessRoutineList {
  @PLMType mStructureKind
  @PLMType mPropertyType
  @string mPropertyName
  @propertyAccessKind mAccessKind
}

#·······················································································································

proc generatePropertyAccess
  ?structureType:let @PLMType inType
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [inType structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
  for (propertyName * objectIR * *) in propertyMap do
    [objectIR propertyRef ?type:let propertyType ?plmName:* ?access:let access]
    ioIntermediateCodeStruct.mPropertyAccessRoutineList += 
      !inType
      !propertyType
      !propertyName.string
      !access
  end
}

#·······················································································································

method @propertyAccessRoutineList generateCode ?!@string ioLLVMcode {
  for (structureKind propertyType propertyName accessKind) in self do
    var propTypeName = [propertyType llvmTypeName]
    let structTypeName = [structureKind llvmTypeName]
    ioLLVMcode += llvmTitleComment (!"Access property '" + propertyName + "' of structure " + structTypeName)
    switch accessKind
    case indexed (index) :
      ioLLVMcode += "define internal " + propTypeName
      ioLLVMcode += " * @\"" + structTypeName + ".access." + propertyName + "\""
      ioLLVMcode += " (" + structTypeName + " * %self) nounwind {\n"
      ioLLVMcode += "  %result = getelementptr inbounds " + structTypeName + ", " + structTypeName + " * %self, "
      ioLLVMcode += "i32 0, i32 " + index + " ; " + propertyName + ", index " + index + "\n"
      ioLLVMcode += "  ret " + propTypeName + " * %result\n"
      ioLLVMcode += "}\n\n"
    case constant (value) :
      let constantName = "@\"" + structTypeName + ".constant." + propertyName + "\""
      ioLLVMcode += constantName + " = private unnamed_addr constant " + propTypeName + " " + value + "\n\n"
      ioLLVMcode += "define internal " + propTypeName
      ioLLVMcode += " * @\"" + structTypeName + ".access." + propertyName + "\""
      ioLLVMcode += " (" + structTypeName + " * %self) nounwind {\n"
      ioLLVMcode += "  ret " + propTypeName + " * " + constantName + "\n"
      ioLLVMcode += "}\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

