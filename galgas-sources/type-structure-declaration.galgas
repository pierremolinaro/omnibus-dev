#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @structureDeclarationAST : @abstractDeclarationAST {
  @lstring mReceiverTypeName
  @lstring mPLMTypeSpecificName
  @lstring mLLVMBaseTypeName
  @lstringlist mAttributeListAST
  @bool mGenerateAssignmentRoutine
  @structurePropertyListAST mStructurePropertyListAST
  @functionDeclarationListAST mFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mSystemRoutineListAST
  @guardDeclarationListAST mGuardListAST
  @bool mMayImplementDeinit
}

#·······················································································································

enum @structurePropertyInitOptionalExpressionAST {
  case expression (@expressionAST initExpression)
  case noExpression
}

#·······················································································································

list @propertyAttributeList {
  @lstring mAttributeName
  @lbigint mAttributeValue
}

#·······················································································································

list @structurePropertyListAST {
  @lstring mPropertyName
  @propertyAttributeList mPropertyAttributeList
  @bool mIsConstant # declared by "let" --> true, declared by "var" --> false
  @bool mIsPublic
  @lstring mPropertyTypeName
  @structurePropertyInitOptionalExpressionAST mInitialisation
  @bool mIsSingletonObject # true, this property is an automomous variable (reserved to driver)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <private_or_public_struct_property_declaration>
    ?!@ast ioAST
    ?!@structurePropertyListAST ioFieldListAST
    ?singletonObject:let @bool isSingletonObject
  {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <struct_property_declaration> !?ioAST !public !?ioFieldListAST !isSingletonObject
  }
  
  #·····················································································································

  rule <private_struct_property_declaration>
    ?!@ast ioAST
    ?!@structurePropertyListAST ioFieldListAST
    ?let @bool isSingletonObject
  {
    <struct_property_declaration> !?ioAST !false !?ioFieldListAST !isSingletonObject
  }

  #·····················································································································

  rule <struct_property_declaration>
    ?!@ast ioAST
    ?let @bool isPublic
    ?!@structurePropertyListAST ioFieldListAST
    ?let @bool isSingletonObject
{
    @bool constant
    select
      $var$
      constant = false
    or
      $let$
      constant = true
    end
    $identifier$ ?let fieldName
    select
      <type_definition> !?ioAST  ?let typeName
      select
        ioFieldListAST += !fieldName !{} !constant !isPublic !typeName !.noExpression !isSingletonObject
      or
        $=$
        <expression> !?ioAST ?let initExpression
        ioFieldListAST +=
          !fieldName
          !{}
          !constant
          !isPublic
          !typeName 
          !.expression{!initExpression:initExpression}
          !isSingletonObject
      end
    or
      $=$
      <expression> !?ioAST ?let initExpression
      ioFieldListAST +=
        !fieldName
        !{}
        !constant
        !isPublic
        !["" nowhere]
        !.expression{!initExpression:initExpression}
        !isSingletonObject
    end
  }

 #·····················································································································

  rule <structure_function> ?!@ast ioAST ?!@functionDeclarationListAST ioProcListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $func$
    $identifier$ ?let procName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments>  !?ioAST ?let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition>!?ioAST  ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    ioProcListAST +=
      !.anyMode
      !public
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
    $}$
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $struct$
    $\$type$ ?let structureName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end 
    ${$
    @functionDeclarationListAST procedureDeclarationListAST = {}
    @structurePropertyListAST fieldList = {}
    repeat
    while
      <private_or_public_struct_property_declaration> !?ioAST !?fieldList !singletonObject:false
    while
      <structure_function> !?ioAST !?procedureDeclarationListAST
    end
    $}$
    ioAST.mDeclarationListAST += !@structureDeclarationAST.new {
      !structureName
      !structureName
      !structureName
      !attributeList
      !true # Generate assignment routine
      !fieldList
      !procedureDeclarationListAST
      !{}
      !{}
      !true
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add structure type name as node
  [!?ioGraph addNode !mReceiverTypeName !self]
#--- Add property types
  for (4* fieldTypeName initExpression *) in mStructurePropertyListAST do
    if fieldTypeName.string != "" then
      [!?ioGraph addEdge !mReceiverTypeName !fieldTypeName]
    end
    switch initExpression
    case noExpression :
    case expression (initExpression) :
      [initExpression addDependenceEdgeForStaticExpression !mReceiverTypeName !?ioGraph]
    end
  end
#--- Add structure functions
  for () in mFunctionDeclarationListAST do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    if mFunctionReturnTypeName.string != "" then
      [!?ioGraph noteNode !mFunctionReturnTypeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
#--- Add structure services, section, primitives and guards
  [mSystemRoutineListAST noteTypesInPrecedenceGraph !?ioGraph]
  [mGuardListAST noteTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override getter @structureDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = mReceiverTypeName 
}

#·······················································································································

override getter @structureDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mReceiverTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @propertyList {
  @string mPropertyName
  @PLMType mType
}

#·······················································································································

sortedlist @sortedOperandIRList {
  @objectIR mOperand
  @uint mIndex
}{
  mIndex <
}

#·······················································································································

sortedlist @globalVariableIRList {
  @string mLLVMVariable
  @objectIR mExpression
  @uint mAlignment
}{
  mAlignment >
}

#·······················································································································

override method @structureDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
#---------------------------------------- Properties
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @sortedOperandIRList sortedOperandIRList = {}
  @constructorSignature constructorSignature = {}
  @string constructorKey = "("
  var canBeCopied = true
  for property in mStructurePropertyListAST do
    [property enterPropertyInContext
      !mLLVMBaseTypeName
      !?context:ioContext
      !?staticEntityMap:ioStaticEntityMap
      !?propertyList
      !?propertyMap
      !?sortedOperandIRList
      !?constructorSignature
      !?constructorKey
      !?canBeCopied
      !?ioGlobalVariableIRList
    ]
  end
  constructorKey += ")"
#---------------------------------------- Constructor map
  @constructorMap constructorMap = {}
  [!?constructorMap insertKey
    !.new {!constructorKey !mReceiverTypeName.location}
    !constructorSignature
    !.structure {!sortedOperandList:sortedOperandIRList}
  ]
#---------------------------------------- Attribute instanciable, copyable
  var typeAttributes = @PLMTypeAttributes.instanciable
#---------------------------------------- Check structure is copyable
  for (s) in mAttributeListAST do
    if s.string == copyableAttribute () then
      if [typeAttributes copyable] then
        error s : "duplicated attribute"
      elsif not canBeCopied then
        error mReceiverTypeName : "this structure cannot be copied, one field is not copyable"
      end
    else
      error s : "only @copyable attribute is allowed here"
    end
  end
  if mGenerateAssignmentRoutine & canBeCopied then
    typeAttributes = typeAttributes | .copyable
  end
#---------------------------------------- Enter functions in property map
  [mFunctionDeclarationListAST enterFunctionsInPropertyMap
    !receiverTypeName: mReceiverTypeName
    !receiverLLVMBaseTypeName: mLLVMBaseTypeName
    !?propertyMap: propertyMap
    !?context: ioContext
    !?ioDecoratedRoutineList
    !?ioRoutineListIR
  ]
#---------------------------------------- Enter system routines in property map
  [mSystemRoutineListAST enterSystemRoutineInContext
    !receiverTypeName: mReceiverTypeName
    !receiverLLVMBaseTypeName: mLLVMBaseTypeName
    !?propertyMap: propertyMap
    !?context: ioContext
    !?ioDecoratedRoutineList
    !?ioRoutineListIR
  ]
#---------------------------------------- Enter guards in guard map
  @guardMapForContext guardMap = {}
  [mGuardListAST enterGuardsInContext
    !receiverTypeName:mReceiverTypeName
    !receiverLLVMBaseTypeName:mLLVMBaseTypeName
    !?context: ioContext
    !?guardMap: guardMap
    !?ioDecoratedDeclarationList
  ]
#---------------------------------------- Enter in type map
  let structureType = @PLMType.new {
    !propertyMap:propertyMap
    !classConstantMap:{}
    !constructorMap:constructorMap
    !guardMap:guardMap
    !attributes:typeAttributes
    !plmTypeDescriptionName:mPLMTypeSpecificName
    !kind:.structure {!propertyList:propertyList}
    !llvmBaseTypeName:mLLVMBaseTypeName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:mReceiverTypeName
    !type:structureType
    !index:[ioContext.mTypeMap count]
    !generate:true
  ]
}

#·······················································································································

method @structurePropertyListAST-element enterPropertyInContext
  ?let @lstring inStructureName
  ?!context:@semanticContext ioContext
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!@propertyList ioPropertyList
  ?!@propertyMap ioPropertyMap
  ?!@sortedOperandIRList sortedOperandIRList
  ?!@constructorSignature constructorSignature
  ?!@string ioConstructorKey
  ?!@bool canBeCopied
  ?!@globalVariableIRList ioGlobalVariableIRList
{
#---------- Attributes
  @lbigint explicitAlignment = .new {!0G !.nowhere}
  var alignmentDefined = false
  for (attribute align) in mPropertyAttributeList do
    if attribute.string != "align" then
      error attribute : "only the @align attribute is allowed here"
    elsif alignmentDefined then
      error attribute : "@align attribute already defined"
    else
    #--- Check alignment is a power of 2
      if align.bigint != (1G << [align.bigint - 1G bitCountForUnsignedRepresentation]) then
        error align : "alignment should be a power of 2"
      else
        explicitAlignment = align
        alignmentDefined = true
      end
    end
  end
#---------- Property type
  let @PLMType optionalPropertyType = if mPropertyTypeName.string == ""
    then voidType ()
    else [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mPropertyTypeName} type]
  end
#---------- Init expression
  switch mInitialisation
  case expression (initExpression) :
    [initExpression analyzeExpression
      !self:voidType ()
      !routineAttributes:.none
      !optionalTargetType:optionalPropertyType
      !context:ioContext
      !mode:.bootMode
      !?temporary:*
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap:ioContext.mValuedObjectMap
      !?alloca:*
      !?instructionListIR:*
      ?result:let @objectIR expressionIR
    ]
    if not [expressionIR isStatic] then
      error mPropertyName : "initialization expression cannot be computed statically"
    end
    @PLMType actualPropertyType
    if optionalPropertyType.kind != .void then
      actualPropertyType = optionalPropertyType
    else
      actualPropertyType = [expressionIR type]
    end
    if not [actualPropertyType instanciable] then
      error mPropertyName : actualPropertyType.plmTypeDescriptionName + " type is not instanciable"
    end
    if not [actualPropertyType copyable] then
      canBeCopied = false
    end
    if mIsConstant then
     [!?ioPropertyMap insertKey
        !mPropertyName
        !mIsPublic
        !.constantProperty {!value:[expressionIR withType !actualPropertyType]}
      ]
    elsif mIsSingletonObject then
      var alignment = [actualPropertyType defaultAlignment]
      if alignmentDefined then
        if [explicitAlignment.bigint uint] < alignment then
          error explicitAlignment : "minimum alignment for this property is " + alignment
        else
          alignment = [explicitAlignment.bigint uint]
        end
      end
      let name = @lstring.new {!inStructureName.string + "." + mPropertyName !mPropertyName}
      let llvmName = llvmNameForGlobalVariable (!name)
      let object = @objectIR.reference {!type:actualPropertyType !llvmName:llvmName}
      [!?ioPropertyMap insertKey
        !mPropertyName
        !mIsPublic
        !.singleton {!object:object !errorLocation:mPropertyName}
      ]
      ioGlobalVariableIRList += !llvmName ![expressionIR withType !actualPropertyType] !alignment
    else
      let propertyIndex = [ioPropertyList length]
      ioPropertyList += !mPropertyName.string !actualPropertyType
      [!?ioPropertyMap insertKey
        !mPropertyName
        !mIsPublic
        !.indexed{!type:actualPropertyType !index:propertyIndex}
      ]
      sortedOperandIRList += ![expressionIR withType !actualPropertyType] !propertyIndex
    end
  case noExpression :
    if not [optionalPropertyType instanciable] then
      error mPropertyName : optionalPropertyType.plmTypeDescriptionName + " type is not instanciable"
    end
    let propertyIndex = [ioPropertyList length]
    ioPropertyList += !mPropertyName.string !optionalPropertyType
    [!?ioPropertyMap insertKey
      !mPropertyName
      !mIsPublic
      !.indexed{!type: optionalPropertyType!index:propertyIndex}
    ]
    constructorSignature += !mPropertyName.string !optionalPropertyType !propertyIndex
    ioConstructorKey += "!" + mPropertyName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateLLVMcodeForStructure
  ?!@string ioLLVMcode
  ?!@generationAdds ioGenerationAdds
  ?let @PLMType inStructureType
  ?let @uint inPointerSize
{
  let llvmTypeName = [inStructureType llvmTypeName]
  let llvmBaseTypeName = [[inStructureType llvmBaseTypeName] assemblerRepresentation]
  if [inStructureType deinitNeeded] then
    ioLLVMcode += llvmTitleComment (!"CODE FOR STRUCTURE TYPE " + inStructureType.plmTypeDescriptionName)
    ioLLVMcode += "define internal void @deinit." + llvmBaseTypeName
    ioLLVMcode += " (i" + inPointerSize + " %inPointer) nounwind {\n"
    let arg = "ptr"
    ioLLVMcode += "  " + llvmNameForLocalVariable (!arg) + " = inttoptr i" + inPointerSize + " %inPointer to " + llvmTypeName + "*\n"
    [inStructureType generateRelease !arg !?ioLLVMcode !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
#--- Assignment
  if [inStructureType.attributes copyable] then
      let arcAssignmentList = [inStructureType arcList !{}]
    
      ioLLVMcode += llvmSeparatorLine () + "\n"
      ioLLVMcode += "define internal void @plm.assign."
      ioLLVMcode += llvmBaseTypeName
      ioLLVMcode += "."
      ioLLVMcode += llvmBaseTypeName
      ioLLVMcode += " (" + llvmTypeName + " * %inTarget, " + llvmTypeName + "* %inSource) nounwind optsize {\n"
      ioLLVMcode += ";--- Handle ARC properties\n"
      for (propertyName propertyType indexPath) in arcAssignmentList do
        let propertyTypeLLVMName = [propertyType llvmTypeName]
        let llvmVarName = "%arc.retain." + [propertyName assemblerRepresentation] + ioGenerationAdds.mUniqueIndex
        ioGenerationAdds.mUniqueIndex ++
        ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* %inSource, i32 0"
        for (idx) in indexPath do
          ioLLVMcode += ", i32 " + idx
        end
        ioLLVMcode += " ; " + propertyName + "\n"
        let llvmLoadedVarName = llvmVarName + ".loaded"
        ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
        ioLLVMcode += "  call void @arc.retain (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
      end
      for (propertyName propertyType indexPath) in arcAssignmentList do
        let llvmVarName = "%arc.release." + [propertyName assemblerRepresentation] + ioGenerationAdds.mUniqueIndex
        ioGenerationAdds.mUniqueIndex ++
        ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* %inTarget, i32 0"
        for (idx) in indexPath do
          ioLLVMcode += ", i32 " + idx
        end
        ioLLVMcode += " ; " + propertyName + "\n"
        let propertyTypeLLVMName = [propertyType llvmTypeName]
        let llvmLoadedVarName = llvmVarName + ".loaded"
        ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
        ioLLVMcode += "  call void @arc.release (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
      end
      ioLLVMcode += ";--- Compute type size\n"
      ioLLVMcode += "  %sizeAsPtr = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* null, i32 1\n"
      ioLLVMcode += "  %byteCount = ptrtoint " + llvmTypeName + "* %sizeAsPtr to i32\n"
      ioLLVMcode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
      ioLLVMcode += "  br i1 %useLoadStore, label %loadStore, label %copyBytesOrCopyWords\n"
      ioLLVMcode += ";--- Copy\n"
      ioLLVMcode += "loadStore:\n"
      ioLLVMcode += "  %v = load " + llvmTypeName + ", " + llvmTypeName + "* %inSource\n" 
      ioLLVMcode += "  store " + llvmTypeName + " %v, " + llvmTypeName + "* %inTarget\n" 
      ioLLVMcode += "  br label %copy.end\n"
      ioLLVMcode += "copyBytesOrCopyWords:\n"
      ioLLVMcode += "  %byteCountAnd3 = and i32 %byteCount, 3\n"
      ioLLVMcode += "  %byteCountIsMutipleOf4 = icmp eq i32 %byteCountAnd3, 0\n"
      ioLLVMcode += "  br i1 %byteCountIsMutipleOf4, label %testTarget, label %copyBytes\n"
      ioLLVMcode += "testTarget:\n"
      ioLLVMcode += "  %targetAsUnsigned = ptrtoint " + llvmTypeName + "* %inTarget to i32\n"
      ioLLVMcode += "  %targetAsUnsignedAnd3 = and i32 %targetAsUnsigned, 3\n"
      ioLLVMcode += "  %targetAsUnsignedIsMutipleOf4 = icmp eq i32%targetAsUnsignedAnd3, 0\n"
      ioLLVMcode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %testSource, label %copyBytes\n"
      ioLLVMcode += "testSource:\n"
      ioLLVMcode += "  %sourceAsUnsigned = ptrtoint " + llvmTypeName + "* %inSource to i32\n"
      ioLLVMcode += "  %sourceAsUnsignedAnd3 = and i32 %sourceAsUnsigned, 3\n"
      ioLLVMcode += "  %sourceAsUnsignedIsMutipleOf4 = icmp eq i32 %sourceAsUnsignedAnd3, 0\n"
      ioLLVMcode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %copyWords, label %copyBytes\n"
      ioLLVMcode += "copyWords:\n"
      ioLLVMcode += "  %target32 = bitcast " + llvmTypeName + "* %inTarget to i32*\n"
      ioLLVMcode += "  %source32 = bitcast " + llvmTypeName + "* %inSource to i32*\n"
      ioLLVMcode += "  %temp = add nsw nuw i32 %byteCount, 3\n"
      ioLLVMcode += "  %wordCount = udiv i32 %temp, 4\n"
      ioLLVMcode += "  br label %copyWords.loop\n"
      ioLLVMcode += "copyWords.loop:\n"
      ioLLVMcode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
      ioLLVMcode += "  br label %copy.end\n"
      ioLLVMcode += "copyBytes:\n"
      ioLLVMcode += "  %target8 = bitcast " + llvmTypeName + "* %inTarget to i8*\n"
      ioLLVMcode += "  %source8 = bitcast " + llvmTypeName + "* %inSource to i8*\n"
      ioLLVMcode += "  call void @copy.byte.array (i8* %target8, i8* %source8, i32 %byteCount)\n"
      ioLLVMcode += "  br label %copy.end\n"
      ioLLVMcode += "copy.end:\n"
      ioLLVMcode += "  ret void\n"
      ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
