#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @structureDeclaration : @abstractDeclaration {
  @lstring mStructureName
  @lstringlist mAttributeListAST
  @structurePropertyListAST mStructureFieldListAST
  @functionDeclarationListAST mFunctionDeclarationListAST
  @svcDeclarationListAST mSVCListAST
  @guardDeclarationListAST mGuardListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @structureDeclaration location -> @location outLocation {
  outLocation = mStructureName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @structureVarInit {
  case expression (@expressionAST initExpression)
  case noExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @structurePropertyListAST {
  @lstring mFieldName
  @bool mIsPublic
  @lstring mFieldTypeName
  @structureVarInit mInitialisation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration_struct_var> ?!@structurePropertyListAST ioFieldListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $var$
    $identifier$ ?let fieldName
    select
      $\$type$ ?let typeName
      select
        ioFieldListAST += !fieldName !public !typeName !.noExpression
      or
        $=$
        <expression> ?let initExpression
        ioFieldListAST += !fieldName !public !typeName !.expression{!initExpression:initExpression}
      end
    or
      $=$
      <expression> ?let initExpression
      ioFieldListAST += !fieldName !public !["" nowhere] !.expression{!initExpression:initExpression}
    end
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $struct$
    $\$type$ ?let structureName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end 
    ${$
    @functionDeclarationListAST procedureDeclarationListAST = {}
    @structurePropertyListAST fieldList = {}
    @svcDeclarationListAST svcListAST = {}
    @guardDeclarationListAST guardListAST = {}
    repeat
    while
      <declaration_struct_var> !?fieldList
    while
      <function> !?procedureDeclarationListAST
    while
      <section> !?svcListAST
    while
      <guard> !?guardListAST
    while
      $;$
    end
    $}$
    ioAST.mDeclarationListAST += !@structureDeclaration.new {
      !structureName
      !attributeList
      !fieldList
      !procedureDeclarationListAST
      !svcListAST
      !guardListAST
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration addExtension
  ?!@extensionDeclarationListAST ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  @structureDeclaration newDeclaration = self
  let currentExtensionDeclarationListAST = ioExtensionDeclarationListAST
  ioExtensionDeclarationListAST = {}
  for (typeName functions properties svcs guards) in currentExtensionDeclarationListAST do
    if mStructureName.string == typeName.string then
      newDeclaration = .new {
        ![newDeclaration mStructureName]
        ![newDeclaration mAttributeListAST]
        ![newDeclaration mStructureFieldListAST] + properties
        ![newDeclaration mFunctionDeclarationListAST] + functions
        ![newDeclaration mSVCListAST] + svcs
        ![newDeclaration mGuardListAST] + guards      
      }
    else
      ioExtensionDeclarationListAST += !typeName !functions !properties !svcs !guards
    end
  end
  outNewDeclaration = newDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let structureTypeName = llvmRegularTypeMangledNameFromName (!mStructureName)
#--- Add structure type name as node
  [!?ioGraph addNode !structureTypeName !self]
#--- add field types
  for (* * fieldTypeName initExpression) in mStructureFieldListAST do
    if fieldTypeName.string != "" then
      let typeName = llvmRegularTypeMangledNameFromName (!fieldTypeName)
      [!?ioGraph addEdge !structureTypeName !typeName]
    end
    switch initExpression
    case noExpression :
    case expression (initExpression) :
      [initExpression addDependenceEdgeForStaticExpression !structureTypeName !?ioGraph]
    end
  end
#--- Add structure procedures
  for () in mFunctionDeclarationListAST do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      let typeName = llvmRegularTypeMangledNameFromName (!formalArgumentTypeName)
      [!?ioGraph noteNode !typeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
#--- Add structure services, section, primitives and guards
  [mSVCListAST noteTypesInPrecedenceGraph !?ioGraph]
  [mGuardListAST noteTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @structureDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "struct $" + mStructureName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @propertyList {
  @string mPropertyName
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @propertyMap {
  @bool mIsPublic
  @objectIR mPropertyObject
  @uint mIndex
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @constructorSignature {
  @string mSelector
  @unifiedTypeMap-proxy mType
  @uint mFieldIndex
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @sortedOperandIRList {
  @objectIR mOperand
  @uint mIndex
}{
  mIndex <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#---------------------------------------- Properties
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @sortedOperandIRList sortedOperandIRList = {}
  @constructorSignature constructorSignature = {}
  var canBeCopied = true
  for () in mStructureFieldListAST do (propertyIndex)
  #--- Field type
    let @unifiedTypeMap-proxy optionalPropertyType = if mFieldTypeName.string == ""
      then .null
      else .searchKey {!ioContext.mTypeMap !mFieldTypeName}
    end
  #--- Init expression
    @instructionListIR initInstructionGenerationList = {}
    @allocaList allocaList = {}
    @semanticTemporariesStruct temporaries = .default
    switch mInitialisation
    case expression (initExpression) :
      [initExpression analyzeExpression
        !self:.null
        !directAccessToPropertiesAllowed:false
        !inGuard:false
        !routineNameForInvocationGraph:.new {!mStructureName.string + " init" !mStructureName.location}
        !optionalTargetType:optionalPropertyType
        !context:ioContext
        !mode:.bootMode
        !?temporary:temporaries
        !?staticStringMap:*
        !?variableMap:*
        !?alloca:allocaList
        !?instructionListIR:initInstructionGenerationList
        ?result:@objectIR expressionIR
      ]
      if ([initInstructionGenerationList length] > 0) || ([allocaList length] > 0) || not [expressionIR isStatic] then
        error mFieldName : "initialization expression cannot be computed statically"
      end
      @unifiedTypeMap-proxy actualPropertyType
      if optionalPropertyType != .null then
        actualPropertyType = optionalPropertyType
      else
        actualPropertyType = [expressionIR type]
      end
      if not [actualPropertyType instantiable] then
        error mFieldName : "$" + [actualPropertyType key] + " type is not instanciable"
      end
      if not [actualPropertyType copyable] then
        canBeCopied = false
      end
      propertyList += !mFieldName.string !actualPropertyType
      [!?propertyMap insertKey
        !mFieldName
        !mIsPublic
        !.property {!type:actualPropertyType !plmName:mFieldName !index:propertyIndex}
        !propertyIndex
      ]
      sortedOperandIRList += ![expressionIR withType !actualPropertyType] !propertyIndex
    case noExpression :
      if not [optionalPropertyType instantiable] then
        error mFieldName : "$" + [optionalPropertyType key] + " type is not instanciable"
      end
      propertyList += !mFieldName.string !optionalPropertyType
      [!?propertyMap insertKey
        !mFieldName
        !mIsPublic
        !.property {!type:optionalPropertyType !plmName:mFieldName !index:propertyIndex}
        !propertyIndex
      ]
      constructorSignature += !mFieldName.string !optionalPropertyType !propertyIndex
    end
  end
#--- Enter in constructor map
  [!?ioContext.mConstructorMap insertKey
    !mStructureName
    !.structure{!constructorSignature:constructorSignature !sortedOperandList:sortedOperandIRList}
  ]
#---------------------------------------- Attribute "copyable"
  var copyableAttribute = false
  for (s) in mAttributeListAST do
    if s.string == "copyable" then
      if copyableAttribute then
        error s : "duplicated attribute"
      end
      copyableAttribute = true
    else
      error s : "only @copyable attribute is allowed here"
    end
  end
  if copyableAttribute && not canBeCopied then
    error mStructureName : "this structure cannot be copied, one field is not copyable"
    copyableAttribute = false
  end
#---------------------------------------- Enter in type map
  [!?ioContext.mTypeMap insertType
    !lkey:mStructureName
#    !llvmTypeName:"%" + ["$" + mStructureName assemblerRepresentation]
    !kind:.structure {!typeName:mStructureName !propertyMap:propertyMap !propertyList:propertyList}
    !classConstantMap:{}
    !instantiable:true
    !copyable:copyableAttribute
    !equatable:false
    !comparable:false
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [mFunctionDeclarationListAST enterFunctionInContext
    !selfTypeName:llvmRegularTypeMangledNameFromName (!mStructureName).string
    !?context:ioContext
  ]
  [mSVCListAST enterInContext !receiverType:llvmRegularTypeMangledNameFromName (!mStructureName).string !?context:ioContext]
  [mGuardListAST enterInContext !receiverType:llvmRegularTypeMangledNameFromName (!mStructureName).string !?context:ioContext]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structureDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let structureType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mStructureName}
#--- Analyze functions
  [self functionSemanticAnalysis
    !structureType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Analyze svc
  [mSVCListAST svcSemanticAnalysis
    !receiverType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
#--- Analyze guards
  [mGuardListAST guardSemanticAnalysis
    !receiverType:structureType
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @structureDeclaration functionSemanticAnalysis
  ?structureType:let @unifiedTypeMap-proxy inStructureType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for function in mFunctionDeclarationListAST do
    var warnIfUnused = true
    var mutating = false
    var accessProperties = false
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == userAccessAttribute () then
        if accessProperties then
          error attribute : "duplicated @" + userAccessAttribute () + " attribute"
        end
        accessProperties = true    
      elsif attribute.string == mutatingAttribute () then
        if mutating then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        mutating = true    
      else
        error attribute : "unknown attribute; available attributes are @" + noUnusedWarningAttribute ()
          + ", @" + mutatingAttribute () + " and @" + userAccessAttribute ()
      end
    end
#    @stringset modeSet = {}
#    for (mode) in function.mFunctionModeList do
#      modeSet += !mode.string
#    end
#    if not [modeSet hasKey !userModeName ()] then
#      if accessProperties then
#        error function.mFunctionName : "useless @" + userAccessAttribute ()
#          + " attribute: function is never executed in `" + userModeName () + " mode"
#      end
#      accessProperties = true
#    end
    accessProperties = function.mMode != .userMode
    routineSemanticAnalysis (
      !receiverType:inStructureType
      !.function
      !function.mMode
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
      !returnTypeName:function.mFunctionReturnTypeName
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !directAccessToPropertiesAllowed:accessProperties
      !propertiesAreMutable:mutating
      !warnIfUnused:warnIfUnused
      !globalFunction:false
      !weakFunction:false
#      !registerAccess:.readWriteAccess
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

