#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @enumerationDeclaration : @abstractDeclaration {
  @lstring mEnumerationName
#  @lstringlist mAttributeList
  @lstringlist mCaseNameList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @enumerationDeclaration location -> @location outLocation {
  outLocation = mEnumerationName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $enum$
    $typeName$ ?let enumName
#    @lstringlist attributeList = {}
#    repeat
#    while
#      $attribute$ ?let attribute
#      attributeList += !attribute
#    end 
    ${$
    @lstringlist enumCaseList = {}
    repeat
      $case$
      $identifier$ ?let constantName
      enumCaseList += !constantName
    while
    end
    $}$
    ioAST.mDeclarationList += !@enumerationDeclaration.new {
      !enumName
#      !attributeList
      !enumCaseList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumerationDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumerationDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let typeName = @lstring.new {!"$" + mEnumerationName !mEnumerationName.location}
  [!?ioGraph addNode !typeName !self]
  [!?ioGraph addEdge !typeName !["$" + boolTypeName () nowhere]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @enumerationDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "enum $" + mEnumerationName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @enumConstantMap {
  @uint mIndex
  insert insertKey error message "the '%K' constant is already declared"
  search searchKey error message "there is no '%K' constant"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumerationDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#---
  var copyable = true
#  for (s) in mAttributeList do
#    if s.string == "unique" then
#      if not copyable then
#        error s : "duplicated attribute"
#      end
#      copyable = false
#    end
#  end
  @enumConstantMap enumConstantMap = {}
  @typedConstantMap constructorMap = {}
  for (cst) in mCaseNameList do
    let idx = [enumConstantMap count]
    [!?enumConstantMap insertKey !cst !idx]
    [!?constructorMap insertKey !cst !.literalInteger {!value:[idx bigint]}]
  end
  [!?ioContext.mTypeMap insertKey
    !lkey:mEnumerationName
    !llvmTypeName:"i" + [[enumConstantMap count] - 1 significantBitCount]
    !kind:.enumeration {!constantMap:enumConstantMap}
    !typedConstantMap:constructorMap
    !functionMap:{}
    !instantiable:true
    !copyable:copyable
    !equatable:true
    !comparable:true
    !enumerationType:.null # Not enumerable
  ]
#--- Infix operators
  enterEnumerationOperators (
    !integerTypeName:mEnumerationName
    !?context:ioContext
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterEnumerationOperators
  ?integerTypeName:@lstring inEnumerationTypeName
  ?!context:@semanticContext ioContext
{
  let key = combineTypeNamesForInfixOperator (!inEnumerationTypeName.string !inEnumerationTypeName.string)
  [!?ioContext.mEqualOperatorMap insertKey
    !key
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !key
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !key
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ult}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !key
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ule}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !key
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ugt}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !key
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_uge}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumerationDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

