#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @enumerationConstantList {
  @lstring mConstantName
  @bigint mConstantValue
}

#·······················································································································

class @enumerationDeclarationAST : @abstractDeclarationAST {
  @lstring mEnumerationName
  @enumerationConstantList mCaseNameList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $enum$
    $\$type$ ?let enumName
    ${$
    @enumerationConstantList enumCaseList = {}
    var idx = 0G
    repeat
      $case$
      $identifier$ ?let constantName
      enumCaseList += !constantName !idx
      idx = idx + 1
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@enumerationDeclarationAST.new {!enumName !enumCaseList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumerationDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumerationDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let typeName = llvmTypeNameFromPLMname (!mEnumerationName)
  [!?ioGraph addNode !typeName !self]
  [!?ioGraph addEdge !typeName !llvmTypeNameFromPLMname (![boolTypeName () nowhere])]
#--- Mark dependance from $uintN used for value property
  @bigint maxValue = 0G
  for (* value) in mCaseNameList do
    if maxValue < value then
      maxValue = value
    end
  end
  @uint representationBitCount = 0
  loop (@uint.max) while maxValue > 0G do
    representationBitCount ++ ;
    maxValue = maxValue / 2G
  end
  [!?ioGraph addEdge !typeName !llvmTypeNameFromPLMname (!["uint" + representationBitCount nowhere])]
}

#·······················································································································

override getter @enumerationDeclarationAST location -> @location outLocation {
  outLocation = mEnumerationName.location
}

#·······················································································································

override getter @enumerationDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "enum $" + mEnumerationName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  UTILITIES                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func integerEnumAccessorName ?forBitCount:let @uint inBitCount -> @string {
  result = "uint" + inBitCount
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @classConstantMap {
  @bigint mIndex
  @lstring mClassTypeName
  insert insertKey error message "the '%K' constant is already declared"
  search searchKey error message "there is no '%K' constant"
}

#·······················································································································

override method @enumerationDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#---------------- Build constant map
  @classConstantMap enumConstantMap = {}
  @bigint maxValue = 0G
  for (name value) in mCaseNameList do
    [!?enumConstantMap insertKey !name !value !mEnumerationName]
    if maxValue < value then
      maxValue = value
    end
  end
#---------------- Compute representation bit count
  @uint representationBitCount = 0
  loop (@uint.max) while maxValue > 0G do
    representationBitCount ++ ;
    maxValue = maxValue / 2G
  end
#---------------- Property map: add uintN() accessor
  @propertyMap propertyMap = {}
  let integerTypeProxy = @unifiedTypeMap-proxy.searchKey {
    !ioContext.mTypeMap
    !.new {!"uint" + representationBitCount !mEnumerationName}
  }
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mEnumerationName ?let enumTypeProxy]
  [!?propertyMap addFunctionWithoutArgument
    !?ioSubprogramInvocationGraph
    !receiverTypeProxy:enumTypeProxy
    !methodName:integerEnumAccessorName (!forBitCount:representationBitCount)
    !safe:true
    !resultTypeProxy:integerTypeProxy
    !canMutateProperties:false
  ]
#---------------- Insert enumeration in type map
  let enumerationType = @PLMType.new {
    !propertyMap:propertyMap
    !classConstantMap:enumConstantMap
    !constructorMap:{}
    !guardMap:{}
    !typeAttributes:.instanciable | .equatable | .copyable | .generateAssignmentRoutine
    !plmOriginalTypeName:mEnumerationName
    !kind:.enumeration {!bitCount:representationBitCount}
    !plmAliasedTypeName:mEnumerationName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:mEnumerationName
    !type:enumerationType
    !index:[ioContext.mTypeMap count]
  ]
#---------------- Infix operators
  enterEnumerationComparisonOperators (!typeName:mEnumerationName !?context:ioContext)
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@enumerationDecoratedDeclaration.new {!mEnumerationName !representationBitCount}
}

#·······················································································································

proc enterEnumerationComparisonOperators
  ?typeName:@lstring inTypeName
  ?!context:@semanticContext ioContext
{
  let key = combineTypeNamesForInfixOperator (!inTypeName.string !inTypeName.string)
  [!?ioContext.mEqualOperatorMap insertKey
    !key
    !booleanType ()
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !key
    !booleanType ()
    !@infixObjectObjectOperatorDescription.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !key
    !booleanType ()
    !@infixObjectObjectOperatorDescription.new {!.icmp_ult}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !key
    !booleanType ()
    !@infixObjectObjectOperatorDescription.new {!.icmp_ule}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !key
    !booleanType ()
    !@infixObjectObjectOperatorDescription.new {!.icmp_ugt}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !key
    !booleanType ()
    !@infixObjectObjectOperatorDescription.new {!.icmp_uge}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @enumerationDecoratedDeclaration : @abstractDecoratedDeclaration {
  @lstring mEnumerationName
  @uint mRepresentationBitCount
}

#·······················································································································

override method @enumerationDecoratedDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#----------- Generate enumeration specific code
  ioIntermediateCodeStruct.mGenerationListIR += !@enumerationIR.new {!mEnumerationName !mRepresentationBitCount}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @enumerationIR : @abstractGenerationIR {
  @lstring mEnumerationName
  @uint mBitCount
}

#·······················································································································

override method @enumerationIR generateLLVMcode ?!@string ioLLVMcode ?!@generationAdds unused ioGenerationAdds {
  let routineMangledName = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!mEnumerationName)
    !.new {!integerEnumAccessorName (!forBitCount:mBitCount) !mEnumerationName}
    !{}
  )
  let routineLLVMName = llvmNameForFunction (!routineMangledName.string)
  let type = "i" + mBitCount
  ioLLVMcode += llvmTitleComment (!routineMangledName)
  ioLLVMcode += "define internal " + type + "  @" + routineLLVMName + " (" + type + "* %inValue) nounwind {\n"
  ioLLVMcode += "  %r = load " + type + ", " + type + "* %inValue\n"
  ioLLVMcode += "  ret " + type + " %r\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

