#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @syncToolInstanceDeclarationAST : @abstractDeclarationAST {
  public var @lstring mSyncTypeName
  public var @lstring mSyncInstanceName
  public var @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $sync$
    $identifier$ ?let syncInstanceName
    let @lstring syncTypeName
    select
      syncTypeName = ["" here]
    or
      <type_definition> !?ioAST ?syncTypeName
    end
    $=$
    <expression> !?ioAST ?let @expressionAST expression
    ioAST.mDeclarationListAST += !@syncToolInstanceDeclarationAST.new {
      !syncTypeName
      !syncInstanceName
      !expression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @syncToolInstanceDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [!?ioGraph addNode !self.mSyncInstanceName !self]
  if self.mSyncTypeName.string != "" then
    [!?ioGraph addEdge !self.mSyncInstanceName !self.mSyncTypeName]
  end
  [self.mSourceExpression addDependenceEdgeForStaticExpression !self.mSyncInstanceName !?ioGraph]
}

#·······················································································································

override getter @syncToolInstanceDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "sync " + self.mSyncInstanceName 
}

#·······················································································································

override getter @syncToolInstanceDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = self.mSyncInstanceName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @globalSyncInstanceMap { # %selectors {
  public var @omnibusType type
  public var @objectIR initialValue

  %insertSetter insertKey %errorMessage "the '%K' global variable is already declared in %L"
  %searchMethod searchKey %errorMessage "there is no '%K' global variable"
}

#·······················································································································

override method @syncToolInstanceDeclarationAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Get sync type
  let @omnibusType optionalSyncType
  if self.mSyncTypeName.string == "" then
    optionalSyncType = voidType ()
  else
    [ioContext.mTypeMap searchType !lkey:self.mSyncTypeName ?type:optionalSyncType]
  end
#--- Analyze source expression
  computeStaticExpression (
    !?context: ioContext
    !?staticEntityMap:ioStaticEntityMap
    !expression:self.mSourceExpression
    !errorLocation:self.mSyncInstanceName
    !optionalContextualTypeName:["" nowhere]
    ?result:let @objectIR expressionResult
  )
#--- Check variable type and expression type
  let result = checkAssignmentCompatibility (
    !ioContext.mAssignmentOperatorMap
    !source:expressionResult
    !targetAnnotationType:optionalSyncType
    !errorLocation:self.mSyncInstanceName.location
    !staticTypeAllowed:false
  )
#---------------- Enter variable in global variable map
  [!?ioContext.mGlobalSyncInstanceMap insertKey
    !self.mSyncInstanceName
    ![result type]
    !result
  ]
#---------------- Check type is a sync tool type
  if not [[result type].kind isSyncTool] then
    error self.mSyncInstanceName : "the type is not a synchronization tool type"
  end
#---------------- Enter in valuated object map
  [!?ioContext.mValuedObjectMap insertGlobalSyncInstance !self.mSyncInstanceName ![result type]]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedSyncInstance.new {!self.mSyncInstanceName !result}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @decoratedSyncInstance : @abstractDecoratedDeclaration {
  public var @lstring mSyncInstanceName
  public var @objectIR mExpressionGeneratedCode
}

#·······················································································································

override method @decoratedSyncInstance semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [!?ioIntermediateCodeStruct.mGlobalSyncInstanceMap insertKey
    !self.mSyncInstanceName
    !self.mExpressionGeneratedCode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @globalSyncInstanceMapIR {
  public var @objectIR mInitialValue
  %insertSetter insertKey %errorMessage "** internal error **"
}

#·······················································································································

method @globalSyncInstanceMapIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalSyncInstance (!self.lkey.string) + " = internal global "
  ioLLVMcode += [[self.mInitialValue type] llvmTypeName] + " " + [self.mInitialValue llvmValue] + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
