#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @syncToolInstanceDeclarationAST : @abstractDeclarationAST {
  @lstring mSyncTypeName
  @lstring mSyncInstanceName
  @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $sync$
    $identifier$ ?let syncInstanceName
    @lstring syncTypeName
    select
      syncTypeName = ["" here]
    or
      <type_definition> !?ioAST ?syncTypeName
    end
    $=$
    <expression> !?ioAST ?let @expressionAST expression
    ioAST.mDeclarationListAST += !@syncToolInstanceDeclarationAST.new {
      !syncTypeName
      !syncInstanceName
      !expression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @syncToolInstanceDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [!?ioGraph addNode !mSyncInstanceName !self]
  if mSyncTypeName.string != "" then
    [!?ioGraph addEdge !mSyncInstanceName !mSyncTypeName]
  end
  [mSourceExpression addDependenceEdgeForStaticExpression !mSyncInstanceName !?ioGraph]
}

#·······················································································································

override getter @syncToolInstanceDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "sync " + mSyncInstanceName 
}

#·······················································································································

override getter @syncToolInstanceDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mSyncInstanceName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @globalSyncInstanceMap %selectors {
  @PLMType type
  @objectIR initialValue

  insert insertKey error message "the '%K' global variable is already declared in %L"
  search searchKey error message "there is no '%K' global variable"
}

#·······················································································································

override method @syncToolInstanceDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Get sync type
  @PLMType optionalSyncType
  if mSyncTypeName.string == "" then
    optionalSyncType = voidType ()
  else
    [ioContext.mTypeMap searchKey !lkey:mSyncTypeName ?type:optionalSyncType]
  end
#--- Analyze source expression
  computeStaticExpression (
    !?context: ioContext
    !?staticEntityMap:ioStaticEntityMap
    !expression:mSourceExpression
    !errorLocation:mSyncInstanceName
    !optionalContextualTypeName:["" nowhere]
    ?result:let @objectIR expressionResult
  )
#--- Check variable type and expression type
  let result = checkAssignmentCompatibility (
    !source:expressionResult
    !targetAnnotationType:optionalSyncType
    !errorLocation:mSyncInstanceName.location
    !staticTypeAllowed:false
  )
#---------------- Enter variable in global variable map
  [!?ioContext.mGlobalSyncInstanceMap insertKey
    !lkey:mSyncInstanceName
    !type:[result type]
    !initialValue:result
  ]
#---------------- Check type is a sync tool type
  if not [[result type].kind isSyncTool] then
    error mSyncInstanceName : "the type is not a synchronization tool type"
  end
#---------------- Enter in valuated object map
  [!?ioContext.mValuedObjectMap insertGlobalSyncInstance !mSyncInstanceName ![result type]]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedSyncInstance.new {!mSyncInstanceName !result}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedSyncInstance : @abstractDecoratedDeclaration {
  @lstring mSyncInstanceName
  @objectIR mExpressionGeneratedCode
}

#·······················································································································

override method @decoratedSyncInstance semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [!?ioIntermediateCodeStruct.mGlobalSyncInstanceMap insertKey
    !mSyncInstanceName
    !mExpressionGeneratedCode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @globalSyncInstanceMapIR {
  @objectIR mInitialValue
  insert insertKey error message "** internal error **"
}

#·······················································································································

method @globalSyncInstanceMapIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalSyncInstance (!lkey.string) + " = internal global "
  ioLLVMcode += [[mInitialValue type] llvmTypeName] + " " + [mInitialValue llvmValue] + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
