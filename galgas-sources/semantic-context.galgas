#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    B U I L D    S E M A N T I C    C O N T E X T                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

enum @typeKind {
  case boolean
  case boolset
  case literalString
  case enumeration (@enumConstantMap constantMap)
  case structure (@propertyMap propertyMap)
  case integer (@bigint min @bigint max @bool unsigned @uint bitCount)
}

#----------------------------------------------------------------------------------------------------------------------*

map @infixOperatorMap {
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
}

#----------------------------------------------------------------------------------------------------------------------*

map @prefixOperatorMap {
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
}

#----------------------------------------------------------------------------------------------------------------------*

map @globalLiteralStringMap {
  @string mLiteralStringCname
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
}

#----------------------------------------------------------------------------------------------------------------------*

map @globalConstantMap {
  @unifiedTypeMap-proxy mConstantType
  @operandIR mExpressionCode
  insert insertKey error message "the '%K' constant is already declared in %L"
  search searchKey error message "there is no '%K' constant"
}

#----------------------------------------------------------------------------------------------------------------------*

map @targetBaseTypeMap {
  @string mCType
  @uint mSize # 8, 16, 32, 64
  @bool mIsSigned
  insert insertKey error message "the '%K' base type is already declared in %L"
  search searchKey error message "there is no '%K' base type"
}

#----------------------------------------------------------------------------------------------------------------------*

map @globalVariableMap {
  @unifiedTypeMap-proxy mVariableType
  @stringset mExecutionModeSet
  @allowedRoutineMap mAllowedProcedureMap
  @operandIR mInitialValue
  insert insertKey error message "the '%K' global variable is already declared in %L"
  search searchKey error message "there is no '%K' global variable"
}

#----------------------------------------------------------------------------------------------------------------------*

map @modeMap {
  insert insertKey error message "the '%%%K' mode is already declared"
  search searchKey error message "there is no '%%%K' mode"
}

#----------------------------------------------------------------------------------------------------------------------*

proc checkMode
  ?requiredModes:let @stringset inRequiredModes
  ?possibleModes:let @stringset inPossibleModes
  ?error:let @location inErrorLocation
{
  if (inPossibleModes & inRequiredModes) != inRequiredModes  then
    let missingModes = inRequiredModes - inPossibleModes
    var s = "cannot be accessed in mode"
    s += if [missingModes count] > 1 then "s" else "" end
    s += ": "
    for (m) in missingModes
    do  s += "$" + m
    between s += ", "
    end
    error inErrorLocation : s
  end
}

#----------------------------------------------------------------------------------------------------------------------*

sharedmap @unifiedTypeMap %selectors {
  @typeKind kind
  @constructorMap constructorMap
  @procedureMap procedureMap
  @bool copiable
  @bool equatable
  @bool comparable

  insert insertKey error message "the '%K' type is already declared in %L"
  search searchKey error message "there is no '%K' type"
}

#----------------------------------------------------------------------------------------------------------------------*

getter @unifiedTypeMap-proxy llvmType -> @string outResult {
  switch [self  kind]
  case boolean : outResult = "i1"
  case boolset : outResult = "<<boolset>>"
  case enumeration (@enumConstantMap unused constantMap) : outResult = "<<enumeration>>"
  case structure (@propertyMap unused propertyMap) :  outResult = "<<structure>>"
  case integer (* * @bool unused unsigned @uint bitCount) : outResult = "i" + bitCount
  case literalString :  outResult = "<<literalString>>"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @variableKindIR loadFromMemory
  ?let @unifiedTypeMap-proxy inVariableType
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !resultingValue:@operandIR outResultingValue
{
  switch self
  case register (@lstring name @bigint address) :
    getNewTempVariable (!?ioTemporaries ?outResultingValue)
    [!?ioInstructionGenerationList appendComment ![outResultingValue string] + " = " + name]
    [!?ioInstructionGenerationList appendLoadVolatile
      !outResultingValue
      !name.string
      !inVariableType
      !address
    ]
  case globalVariable (@lstring name) :
    getNewTempVariable (!?ioTemporaries ?outResultingValue)
    [!?ioInstructionGenerationList appendComment ![outResultingValue string] + " = " + name]
    [!?ioInstructionGenerationList appendLoadGlobalVariable
      !outResultingValue
      !name.string
      !inVariableType
    ]
  case localVariable (@lstring name) :
    error name : "@varInExpressionAST analyzeExpression" : outResultingValue
  case inArgument (@lstring name) :
    error name : "@varInExpressionAST analyzeExpression" : outResultingValue
  case inOutArgument (@lstring name) :
    error name : "@varInExpressionAST analyzeExpression" : outResultingValue
  case outArgument (@lstring name) :
    error name : "@varInExpressionAST analyzeExpression" : outResultingValue
  case localConstant (@lstring name) :
    error name : "@varInExpressionAST analyzeExpression" : outResultingValue
  case globalConstant (@operandIR value) :
    outResultingValue = value
  case temporaryConstant (@uint unused idx) :
    error .nowhere : "@varInExpressionAST analyzeExpression" : outResultingValue
  case localAccess (@lstring access) :
    error access : "@varInExpressionAST analyzeExpression" : outResultingValue
  case literalString (**) :
    error .nowhere : "@varInExpressionAST analyzeExpression" : outResultingValue
  case literalStructure (*) :
    error .nowhere : "@varInExpressionAST analyzeExpression" : outResultingValue
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @variableKindIR storeInMemory
  ?value:@operandIR inValue
  ?let @unifiedTypeMap-proxy inVariableType
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  switch self
  case register (@lstring registerName @bigint address) :
    [!?ioInstructionGenerationList appendStoreVolatile !registerName.string !inVariableType !address !inValue]
  case globalVariable (@lstring name) :
    [!?ioInstructionGenerationList appendStoreGlobalVariable !name.string !inVariableType !inValue]
  case localVariable (@lstring unused name) :
     error .nowhere : "INTERNAL ERROR"
  case inArgument (@lstring unused name) :
     error .nowhere : "INTERNAL ERROR"
  case inOutArgument (@lstring unused name) :
     error .nowhere : "INTERNAL ERROR"
  case outArgument (@lstring unused name) :
     error .nowhere : "INTERNAL ERROR"
  case localConstant (@lstring unused name) :
     error name : "INTERNAL ERROR"
  case globalConstant (@operandIR unused value) :
     error .nowhere : "INTERNAL ERROR"
  case temporaryConstant (@uint unused idx) :
     error .nowhere : "INTERNAL ERROR"
  case localAccess (@lstring unused access) :
     error .nowhere : "INTERNAL ERROR"
  case literalString (@string unused value @string unused name) :
     error .nowhere : "INTERNAL ERROR"
  case literalStructure (@literalStructureList unused value) :
     error .nowhere : "INTERNAL ERROR"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

map @constructorMap {
  @operandIR mValue
  insert insertKey error message "the '%K' constructor is already declared in %L"
  search searchKey error message "there is no '%K' constructor"
}

#----------------------------------------------------------------------------------------------------------------------*

list @typeList {
  @unifiedTypeMap-proxy mActualType
}

#----------------------------------------------------------------------------------------------------------------------*

struct @semanticContext {
  @targetBaseTypeMap mTargetBaseTypeMap
  @unifiedTypeMap-proxy mBooleanType
  @unifiedTypeMap-proxy mExceptionCodeType
  @unifiedTypeMap-proxy mExceptionLineType
  @unifiedTypeMap mTypeMap
  @instanciationMap mInstanciationMap
  @procedureMap mProcedureMap
  @functionMap mFunctionMap
  @initRoutineMap mInitRoutineMap
  @exceptionRoutinePriorityMap mExceptionSetupRoutinePriorityMap 
  @exceptionRoutinePriorityMap mExceptionLoopRoutinePriorityMap 
  @registerMap mRegisterMap
  @globalConstantMap mGlobalConstantMap
  @globalVariableMap mGlobalVariableMap
  @modeMap mModeMap
  @stringset mTypeNameSetForIncDec              # ++ and --
  @infixOperatorMap mEqualOperatorMap           # ==
  @infixOperatorMap mNonEqualOperatorMap        # !=
  @infixOperatorMap mStrictInfOperatorMap       # <
  @infixOperatorMap mInfEqualOperatorMap        # <=
  @infixOperatorMap mStrictSupOperatorMap       # >
  @infixOperatorMap mSupEqualOperatorMap        # >=
  @infixOperatorMap mAndOperatorMap             # &
  @infixOperatorMap mBooleanAndOperatorMap      # and
  @infixOperatorMap mOrOperatorMap              # |
  @infixOperatorMap mBooleanOrOperatorMap       # or
  @infixOperatorMap mXorOperatorMap             # ^
  @infixOperatorMap mBooleanXorOperatorMap      # xor
  @infixOperatorMap mAddOperatorMap             # +
  @infixOperatorMap mAddNoOvfOperatorMap        # &+
  @infixOperatorMap mSubOperatorMap             # -
  @infixOperatorMap mSubNoOvfOperatorMap        # &-
  @infixOperatorMap mMulOperatorMap             # *
  @infixOperatorMap mMulNoOvfOperatorMap        # &*
  @infixOperatorMap mDivOperatorMap             # /
  @infixOperatorMap mDivNoOvfOperatorMap        # &/
  @infixOperatorMap mModOperatorMap             # %
  @infixOperatorMap mLeftShiftOperatorMap       # <<
  @infixOperatorMap mRightShiftOperatorMap      # >>
  @prefixOperatorMap mUnaryMinusOperatorMap     # - and &-
  @prefixOperatorMap mNotOperatorMap            # not
  @prefixOperatorMap mUnsignedComplementOperatorMap # ~
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractDeclaration initAnalysis
  ?!context:@semanticContext ioContext

#----------------------------------------------------------------------------------------------------------------------*

proc buildSemanticContext
  ?orderedDeclarationList:let @declarationListAST inDeclarationListAST
  ?ast:let @ast inAST
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  !context:@semanticContext outSemanticContext
{
  outSemanticContext = .default
#--- Add predefined modes
  [!?outSemanticContext.mModeMap insertKey !["boot" nowhere]]
  [!?outSemanticContext.mModeMap insertKey !["init" nowhere]]
  [!?outSemanticContext.mModeMap insertKey !["exception" nowhere]]
#--- Enter init routines
  for initRoutine in inAST.mInitList do
    [initRoutine enterInContext
      !?context:outSemanticContext
    ]
  end
#--- Enter exception routines
  for execptionRoutine in inAST.mExceptionClauses do
    [execptionRoutine enterInContext
      !?context:outSemanticContext
    ]
  end
#---
  for (declaration) in inDeclarationListAST do
    [declaration enterInContext
      !procedureDeclarationList:inAST.mProcedureListAST
      !?context:outSemanticContext
      !?staticStringMap:ioGlobalLiteralStringMap
    ]
  end
#--- Solve exception types
  if [inAST.mExceptionTypes length] != 1 then
    error ["" nowhere]
    : "exactly one exception type declaration should be provided (found:" + [inAST.mExceptionTypes length] + ")"
    for () in inAST.mExceptionTypes do
      error mExceptionCodeTypeName:"exception type declaration is here"
    end
  else
    [inAST.mExceptionTypes first ?let @lstring exceptionCodeTypeName ?let @lstring exceptionLineTypeName]
    outSemanticContext.mExceptionCodeType = @unifiedTypeMap-proxy.searchKey {
      !outSemanticContext.mTypeMap
      !exceptionCodeTypeName
    }
    outSemanticContext.mExceptionLineType = @unifiedTypeMap-proxy.searchKey {
      !outSemanticContext.mTypeMap
      !exceptionLineTypeName
    }
  end
#---
  for procedure in inAST.mProcedureListAST do
    [procedure enterInContext !?context: outSemanticContext]
  end
#---
  for function in inAST.mFunctionListAST do
    [function enterInContext !?context: outSemanticContext]
  end
#--- Check required procs mode
  if @uint.errorCount == 0 then
    for requiredProc in inAST.mRequiredProcList do
      for (mode) in requiredProc.mProcedureModeList do
        [outSemanticContext.mModeMap searchKey !mode]
      end
    end
  end
#--- Build instanciation map
  if @uint.errorCount == 0 then
    for (declaration) in inAST.mDeclarationList do
      [declaration initAnalysis
        !?context:outSemanticContext
       ]
    end
  end
#--- Check global var declaration
  if @uint.errorCount == 0 then
    for globalVar in inAST.mGlobalVarDeclarationList do
      [globalVar enterInContext
        !?context:outSemanticContext
        !?staticStringMap:ioGlobalLiteralStringMap
      ]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

func solveInferredType
  ?targetType:let @unifiedTypeMap-proxy inTargetType
  ?sourceType:let @unifiedTypeMap-proxy inSourceType
  ?errorLocation:let @location inErrorLocation
  -> @unifiedTypeMap-proxy outType
{
  if inSourceType == .null then
    if inTargetType == .null then
      error inErrorLocation : "Cannot infer type" : outType
    else
      outType = inTargetType
    end
  else
    outType = inSourceType
  end
}

#----------------------------------------------------------------------------------------------------------------------*
