#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @panicAST : @abstractDeclarationAST {
  @bool mIsSetup # true: setup, false: loop
  @instructionListAST mPanicInstructionList
  @location mEndOfPanicInstructions
  @lbigint mPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $panic$
    $@attribute$ ?let attribute
    @bool isSetup
    if attribute.string == "setup" then
      isSetup = true
    elsif attribute.string == "loop" then
      isSetup = false
    else
      error attribute : "attribute should be @setup or @loop" : isSetup
    end
    $integer$ ?let priority
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mDeclarationListAST += !@panicAST.new {
      !isSetup
      !instructionList
      !endOfInstructionList
      !priority
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @panicAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mPanicInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @panicAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {
   !"panic " + if mIsSetup then "setup" else "loop" end + " " + mPriority.bigint
   !mPriority.location
 }
 [!?ioGraph addNode !nodeName !self]
  let configNode =  @lstring.new {!configurationNodeNameForPrecedenceGraph () !mPriority.location}
 [!?ioGraph addEdge !nodeName !configNode]
}

#·······················································································································

override getter @panicAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "panic " + if mIsSetup then "setup" else "loop" end + " " + mPriority.bigint
}

#·······················································································································

override getter @panicAST locationForErrorSignaling -> @location outLocation {
  outLocation = mPriority.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @panicRoutinePriorityMap {
  insert insertSetupKey error message "a panic setup routine with priority %K has been already declared"
  insert insertLoopKey error message "a panic loop routine with priority %K has been already declared"
  search searchSetupKey error message "there is no panic setup routine with priority %K"
  search searchLoopKey error message "there is no panic loop routine with priority %K"
}

#·······················································································································

override method @panicAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
  if mIsSetup then
    [!?ioContext.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
  else
    [!?ioContext.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
  end
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedPanicRoutine.new {
    !mIsSetup
    !mPriority
  }
#--- Insert predefined input arguments
  @routineFormalArgumentListAST arguments = {}
  arguments +=
    !.input
    !["" nowhere]
    ![[ioContext.mPanicLineType llvmBaseTypeName] nowhere]
    !["LINE" nowhere]
  arguments +=
    !.input
    !["" nowhere]
    ![[ioContext.mPanicCodeType llvmBaseTypeName] nowhere]
    !["CODE" nowhere]
  arguments +=
    !.input
    !["" nowhere]
    ![staticStringTypeName () nowhere]
    !["FILE" nowhere]
  let routineMangledName = @lstring.new {
    !"panic." + if mIsSetup then "setup" else "loop" end + "." + mPriority.bigint
    !mPriority.location
  }
  ioDecoratedRoutineList +=
    !["" nowhere] # Empty string if standalone function
    !.panicMode # @mode mMode
    !.function {!executionMode:.panicMode} # @routineKind mRoutineKind
    !true # @bool mWarnIfUnused
    !false # @bool mExportedRoutine
    !.none # @routineAttributes mRoutineAttributes
    !routineMangledName
    !arguments
    !mPanicInstructionList
    !mEndOfPanicInstructions
    !["" nowhere] # @lstring mReturnTypeName  # Empty string if no returned value
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc appendPanicRoutines
  ?allSourceFilePaths:let @stringset inSourceFileAbsolutePathSet
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  ioIntermediateCodeStruct.mRoutineListIR += !@universalModePanicRoutineIR.new {
    !["section.user.handle.panic" nowhere]
    !false
    !false
  }
#--- Section panic routine
  ioIntermediateCodeStruct.mRoutineListIR += !@sectionModePanicRoutineIR.new {
    !["section.implementation.handle.panic" nowhere]
    !false
    !false
    !ioIntermediateCodeStruct.mPanicSetupListIR
    !ioIntermediateCodeStruct.mPanicLoopListIR
  }
#--- Panic routines, specific to every source file
#  for (sourceFilePath) in inSourceFileAbsolutePathSet do
#    let fileBaseName = [[sourceFilePath lastPathComponent] stringByDeletingPathExtension]
#    ioIntermediateCodeStruct.mRoutineListIR += !@fileSpecificPanicRoutineIR.new {
#      !["raise.panic.file." + fileBaseName nowhere]
#      !false
#      !false
#      !sourceFilePath
#    }
#  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once panicModeName -> @string {
  result = "panic"
}

#·······················································································································

class @decoratedPanicRoutine : @abstractDecoratedDeclaration {
  @bool mIsSetup # true: setup, false: loop
  @lbigint mPriority
}

#·······················································································································

override method @decoratedPanicRoutine semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Code generation
  if mIsSetup then
    [!?ioTemporaries.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicSetupListIR += !mPriority.bigint
  else
    [!?ioTemporaries.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicLoopListIR += !mPriority.bigint
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @panicSortedListIR {
  @bigint mPriority
}{
  mPriority <
}

#·······················································································································

proc generatePanicCode
  ?!@string ioLLVMcode
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
  ?generationContext:let @generationContext inGenerationContext
  ?!generationAdds:@generationAdds ioGenerationAdds
{
#--- Panic for isr
  [!?ioGenerationAdds.mStaticEntityMap findOrAddStaticString !"" ?let emptyStringIndex]
  ioLLVMcode += llvmTitleComment (!"Panic for ISR")
  ioLLVMcode += "define internal void @panic.isr (" + [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE) " + llvmAttributeFunction () + "noreturn {\n"
  ioLLVMcode += "  %str.FILE = load i8*, i8** " + literalStringName (!emptyStringIndex) + "\n"
  ioLLVMcode += "  call void @" + llvmNameForSectionImplementation (!panicRoutineName ()) + " ("    
  ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " 0, "
  ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
  ioLLVMcode += "i8* %str.FILE"
  ioLLVMcode += " )\n"    
  ioLLVMcode += "  unreachable\n"    
  ioLLVMcode += "}\n\n"    
#--- File specific routines
  for (filePath) in inSourceFileAbsolutePathSet do
    [!?ioGenerationAdds.mStaticEntityMap findOrAddStaticString
      ![[filePath lastPathComponent] stringByDeletingPathExtension]
      ?let staticStringIndex
    ]
    let routineName = "@raise.panic." + staticStringIndex
    ioLLVMcode += llvmTitleComment (!routineName + " (" + [filePath lastPathComponent] + ")")
    ioLLVMcode += "define internal void " + routineName + " ("
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %inSourceLine, "
    ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %inCode)" + llvmAttributeFunction () + "noreturn {\n"
    ioLLVMcode += "  %str.FILE = load i8*, i8** " + literalStringName (!staticStringIndex) + "\n"
    ioLLVMcode += "  call void @" + llvmNameForSectionCall (!panicRoutineName ()) + " ("
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %inSourceLine, "
    ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %inCode, i8* %str.FILE)\n"
    ioLLVMcode += "  unreachable\n"
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: Panic routine, specific to a source file 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @fileSpecificPanicRoutineIR : @abstractRoutineIR {
  @string inFilePath
}

#·······················································································································

override method @fileSpecificPanicRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let arguments = " ("
    + [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
    + [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
    + "i8* %in.FILE)"
  let fileBaseName = [[inFilePath lastPathComponent] stringByDeletingPathExtension]
  
  [!?ioGenerationAdds.mStaticEntityMap findOrAddStaticString
    !fileBaseName
    ?let staticStringIndex
  ]
  ioLLVMcode += llvmTitleComment (!mRoutineMangledName)
  ioLLVMcode += "define internal void @" + [mRoutineMangledName assemblerRepresentation] + " ("
  ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
  ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE)" + llvmAttributeFunction () + "noreturn {\n"
  ioLLVMcode += "  %in.FILE = load i8*, i8** " + literalStringName (!staticStringIndex) + "\n"
  ioLLVMcode += "  call void @" + llvmNameForSectionCall (!panicRoutineName ()) + arguments + "\n"
  ioLLVMcode += "  unreachable\n"
  ioLLVMcode += "}\n\n"
}

#·······················································································································

override method @fileSpecificPanicRoutineIR enterAccessibleEntities
   ?!@stringset ioInvokedRoutineSet
   ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioInvokedRoutineSet += !llvmNameForSectionCall (!panicRoutineName ())
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: Panic routine, in universal mode 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @universalModePanicRoutineIR : @abstractRoutineIR {
}

#·······················································································································

override method @universalModePanicRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let arguments = " ("
    + [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
    + [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
    + "i8* %in.FILE)"

  ioLLVMcode += llvmTitleComment (!"Raise Panic internal")
  ioLLVMcode += "declare void @" + llvmNameForSectionCall (!panicRoutineName ())
  ioLLVMcode += arguments
  ioLLVMcode += llvmAttributeFunction () + "noreturn\n\n"
}

#·······················································································································

override method @universalModePanicRoutineIR svcDeclarationGeneration
  ?!@primitiveAndServiceIRlist unused ioPrimitiveAndServiceList
  ?!@sectionIRlist ioSectionList
  ?!@generationAdds unused ioGenerationAdds
{
  ioSectionList += 
    !llvmNameForSectionCall (!panicRoutineName ())
    !llvmNameForSectionImplementation (!panicRoutineName ())
    !false # Invocation from any mode
}

#·······················································································································

override method @universalModePanicRoutineIR enterAccessibleEntities
   ?!@stringset ioInvokedRoutineSet
   ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioInvokedRoutineSet += !llvmNameForSectionImplementation (!panicRoutineName ())
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: Panic routine, in section mode 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @sectionModePanicRoutineIR : @abstractRoutineIR {
  @panicSortedListIR mPanicSetupListIR
  @panicSortedListIR mPanicLoopListIR
}

#·······················································································································

override method @sectionModePanicRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Raise Panic internal (section mode)")
  
  let arguments = " ("
    + [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
    + [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
    + "i8* %in.FILE)"
  
  ioLLVMcode += "define void @" + llvmNameForSectionImplementation (!panicRoutineName ())
  ioLLVMcode += arguments + llvmAttributeFunction () + "noreturn {\n"
#---
  for (priority) in mPanicSetupListIR do
    ioLLVMcode += "  call void @panic.setup." + priority + arguments + "\n"
  end
  ioLLVMcode += "  br label %panic.loop\n\n"
  ioLLVMcode += "panic.loop:\n"
  for (priority) in mPanicLoopListIR do
    ioLLVMcode += "  call void @panic.loop." + priority + arguments + "\n"
  end
  ioLLVMcode += "  br label %panic.loop\n"
  ioLLVMcode += "}\n\n"
}

#·······················································································································

override method @sectionModePanicRoutineIR enterAccessibleEntities
   ?!@stringset ioInvokedRoutineSet
   ?!@uint unused ioMaxBranchOfOnInstructions
{
  for (priority) in mPanicSetupListIR do
    ioInvokedRoutineSet += !"panic.setup." + priority
  end
  for (priority) in mPanicLoopListIR do
    ioInvokedRoutineSet += !"panic.loop." + priority
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
