#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @panicAST : @abstractDeclarationAST {
  @bool mIsSetup # true: setup, false: loop
  @instructionListAST mPanicInstructionList
  @location mEndOfPanicInstructions
  @lbigint mPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $panic$
    $@attribute$ ?let attribute
    @bool isSetup
    if attribute.string == "setup" then
      isSetup = true
    elsif attribute.string == "loop" then
      isSetup = false
    else
      error attribute : "attribute should be @setup or @loop" : isSetup
    end
    $integer$ ?let priority
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mDeclarationListAST += !@panicAST.new {
      !isSetup
      !instructionList
      !endOfInstructionList
      !priority
    }
  }

  #·····················································································································

#  rule <declaration> ?!@ast ioAST {
#    $panic$
#    $loop$
#    $integer$ ?let priority
#    ${$
#    <instructionList> !?ioAST ?let instructionList
#    let endOfInstructionList = @location.here
#    $}$
#    ioAST.mDeclarationListAST += !@panicAST.new {
#      !false
#      !instructionList
#      !endOfInstructionList
#      !priority
#    }
#  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @panicAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mPanicInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @panicAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {
   !"panic " + if mIsSetup then "setup" else "loop" end + " " + mPriority.bigint
   !mPriority.location
 }
 [!?ioGraph addNode !nodeName !self]
}

#·······················································································································

override getter @panicAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "panic " + if mIsSetup then "setup" else "loop" end + " " + mPriority.bigint
}

#·······················································································································

override getter @panicAST locationForErrorSignaling -> @location outLocation {
  outLocation = mPriority.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @panicRoutinePriorityMap {
  insert insertSetupKey error message "a panic setup routine with priority %K has been already declared"
  insert insertLoopKey error message "a panic loop routine with priority %K has been already declared"
  search searchSetupKey error message "there is no panic setup routine with priority %K"
  search searchLoopKey error message "there is no panic loop routine with priority %K"
}

#·······················································································································

override method @panicAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
  if mIsSetup then
    [!?ioContext.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
  else
    [!?ioContext.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
  end
#---------------- Invocation graph
  let routineNameForInvocationGraph = panicNameForInvocationGraph (!if mIsSetup then "setup" else "loop" end !mPriority)
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedPanicRoutine.new {
    !mIsSetup
    !mPanicInstructionList
    !mEndOfPanicInstructions
    !mPriority
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once panicModeName -> @string {
  result = "panic"
}

#·······················································································································

class @decoratedPanicRoutine : @abstractDecoratedDeclaration {
  @bool mIsSetup # true: setup, false: loop
  @instructionListAST mPanicInstructionList
  @location mEndOfPanicInstructions
  @lbigint mPriority
}

#·······················································································································

override method @decoratedPanicRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let routineNameForInvocationGraph = panicNameForInvocationGraph (!if mIsSetup then "setup" else "loop" end !mPriority)
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
#--- Insert predefined input arguments
  let codeArg = @lstring.new {!"CODE" !mPriority.location}
  [!?universalMap insertUsedLocalConstant !codeArg ![inContext.mPanicCodeType type] !codeArg]
  let fileArg = @lstring.new {!"FILE" !mPriority.location}
  let StaticStringType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap ![staticStringTypeName () nowhere]} type]
  [!?universalMap insertUsedLocalConstant !fileArg !StaticStringType !fileArg]
  let lineArg = @lstring.new {!"LINE" !mPriority.location}
  [!?universalMap insertUsedLocalConstant !lineArg ![inContext.mPanicLineType type] !lineArg]
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList initAllocaList = {}
  [mPanicInstructionList analyzeRoutineInstructionList
    !self:voidType ()
    !routineAttributes:.none
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.panicMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
    !?variableMap:universalMap
    !?alloca:initAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState !?instructionGenerationList]
  [!?universalMap closeBranch !mEndOfPanicInstructions]
  [!?universalMap closeOverride !mEndOfPanicInstructions]
#--- Code generation
  if mIsSetup then
    [!?ioTemporaries.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicSetupInstructionListIR += !instructionGenerationList !mPriority.bigint
  else
    [!?ioTemporaries.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicLoopInstructionListIR += !instructionGenerationList !mPriority.bigint
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @instructionListSortedListIR {
  @instructionListIR mInstructionList
  @bigint mPriority
}{
  mPriority <
}

#·······················································································································

proc generatePanicCode
  ?!@string ioLLVMcode
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
  ?generationContext:let @generationContext inGenerationContext
  ?!generationAdds:@generationAdds ioGenerationAdds
  ?setup:let @instructionListSortedListIR inPanicSetupInstructionListIR
  ?loop:let @instructionListSortedListIR inPanicLoopInstructionListIR
{
  ioLLVMcode += llvmTitleComment (!"Raise Panic internal")
  ioLLVMcode += "declare void @" + llvmNameForSectionCall (!panicRoutineName ()) + " ("
  ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
  ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
  ioLLVMcode += "i8* %in.FILE)" + llvmAttributeFunction () + "noreturn\n\n"
  ioLLVMcode += "define void @" + llvmNameForSectionImplementation (!panicRoutineName ()) + " ("
  ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
  ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
  ioLLVMcode += "i8* %in.FILE)" + llvmAttributeFunction () + "noreturn {\n"
#--- Alloca
  @allocaList allocaList = {}
  allocaList += !llvmNameForLocalVariable (!"LINE") !inGenerationContext.mPanicLineLLVMType !true
  allocaList += !llvmNameForLocalVariable (!"CODE") !inGenerationContext.mPanicCodeLLVMType !true
  allocaList += !llvmNameForLocalVariable (!"FILE") !literalStringType () !true
  [allocaList generateAllocaList !?ioLLVMcode]
#--- First argument: line
  ioLLVMcode += "  store " + [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %in.LINE, "
  ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " * " + llvmNameForLocalVariable (!"LINE") + "\n"
#--- Second argument : code
  ioLLVMcode += "  store " + [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
  ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " * " + llvmNameForLocalVariable (!"CODE") + "\n"
#--- Third argument : file    
  ioLLVMcode += "  store i8* %in.FILE, i8** " + llvmNameForLocalVariable (!"FILE") + "\n"
#---
  for (instructionList *) in inPanicSetupInstructionListIR do
    [instructionList instructionListLLVMCode
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  end
  ioLLVMcode += "  br label %panic.loop\n\n"
  ioLLVMcode += "panic.loop:\n"
  for (instructionList *) in inPanicLoopInstructionListIR do
    [instructionList instructionListLLVMCode
      !?ioLLVMcode
      !inGenerationContext
      !?ioGenerationAdds
    ]
  end
  ioLLVMcode += "  br label %panic.loop\n"
  ioLLVMcode += "}\n\n"
#--- Panic for isr
  [!?ioGenerationAdds.mStaticEntityMap findOrAddStaticString !"" ?let emptyStringIndex]
  ioLLVMcode += llvmTitleComment (!"Panic for ISR")
  ioLLVMcode += "define internal void @panic.isr (" + [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE) " + llvmAttributeFunction () + "noreturn {\n"
  ioLLVMcode += "  %str.FILE = load i8*, i8** " + literalStringName (!emptyStringIndex) + "\n"
  ioLLVMcode += "  call void @" + llvmNameForSectionImplementation (!panicRoutineName ()) + " ("    
  ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " 0, "
  ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %in.CODE, "
  ioLLVMcode += "i8* %str.FILE"
  ioLLVMcode += " )\n"    
  ioLLVMcode += "  unreachable\n"    
  ioLLVMcode += "}\n\n"    
#--- File specific routines
  for (filePath) in inSourceFileAbsolutePathSet do
    [!?ioGenerationAdds.mStaticEntityMap findOrAddStaticString
      ![[filePath lastPathComponent] stringByDeletingPathExtension]
      ?let staticStringIndex
    ]
    let routineName = "@raise.panic." + staticStringIndex
    ioLLVMcode += llvmTitleComment (!routineName + " (" + [filePath lastPathComponent] + ")")
    ioLLVMcode += "define internal void " + routineName + " ("
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %inSourceLine, "
    ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %inCode)" + llvmAttributeFunction () + "noreturn {\n"
    ioLLVMcode += "  %str.FILE = load i8*, i8** " + literalStringName (!staticStringIndex) + "\n"
    ioLLVMcode += "  call void @" + llvmNameForSectionCall (!panicRoutineName ()) + " ("
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %inSourceLine, "
    ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " %inCode, i8* %str.FILE)\n"
    ioLLVMcode += "  unreachable\n"
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
