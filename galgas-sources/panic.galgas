#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @panicClauseListAST {
  @bool mIsSetup # true: setup, false: loop
  @instructionListAST mPanicInstructionList
  @location mEndOfPanicInstructions
  @lbigint mPriority
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $panic$
    $setup$
    $integer$ ?let priority
    ${$
    <instructionList> ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mPanicClauses +=
      !true
      !instructionList
      !endOfInstructionList
      !priority
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $panic$
    $loop$
    $integer$ ?let priority
    ${$
    <instructionList> ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mPanicClauses +=
      !false
      !instructionList
      !endOfInstructionList
      !priority
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @panicClauseListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    [mPanicInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @panicClauseListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
  if mIsSetup then
    [!?ioContext.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
  else
    [!?ioContext.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once panicModeName -> @string outResult {
  outResult = "panic"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @panicRoutinePriorityMap {
  insert insertSetupKey error message "a panic setup routine with priority %K has been already declared"
  insert insertLoopKey error message "a panic loop routine with priority %K has been already declared"
  search searchSetupKey error message "there is no panic setup routine with priority %K"
  search searchLoopKey error message "there is no panic loop routine with priority %K"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @panicClauseListAST-element panicSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let routineNameForInvocationGraph = panicNameForInvocationGraph (!if mIsSetup then "setup" else "loop" end !mPriority)
#--- Variable map
  initialVariableMap (
    !context:inContext
    !mode:.panicMode
#    !userMode:false
#    !registerAccess:.readWriteAccess
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
    ?@variableMap variableMap
  )
#--- Insert predefined input arguments
  let StaticStringType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap ![staticStringTypeName () nowhere]}
  let codeArg = @lstring.new {!"CODE" !mPriority.location}
  [!?variableMap insertUsedConstantInputFormalArgument
    !lkey:codeArg
    !type:inContext.mPanicCodeType
    !readAccessAllowed:true
    !objectIR:.localVariableReference {!type:inContext.mPanicCodeType !plmName:codeArg}
    !copyable:[inContext.mPanicCodeType copyable]
    !canBeUsedAsInputParameter:false
  ]
  let fileArg = @lstring.new {!"FILE" !mPriority.location}
  [!?variableMap insertUsedConstantInputFormalArgument
    !lkey:fileArg
    !type:StaticStringType
    !readAccessAllowed:true
    !objectIR:.localVariableReference {!type:StaticStringType !plmName:fileArg}
    !copyable:[StaticStringType copyable]
    !canBeUsedAsInputParameter:false
  ]
  let lineArg = @lstring.new {!"LINE" !mPriority.location}
  [!?variableMap insertUsedConstantInputFormalArgument
    !lkey:lineArg
    !type:inContext.mPanicLineType
    !readAccessAllowed:true
    !objectIR:.localVariableReference {!type:inContext.mPanicLineType !plmName:lineArg}
    !copyable:[inContext.mPanicLineType copyable]
    !canBeUsedAsInputParameter:false
  ]
#---
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList initAllocaList = {}
  [mPanicInstructionList analyzeRoutineInstructionList
    !self:.null
    !directAccessToPropertiesAllowed:false
    !propertiesAreMutable:false
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.panicMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?alloca:initAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [variableMap checkAutomatonStates !mEndOfPanicInstructions]
  drop variableMap
#--- Code generation
  if mIsSetup then
    [!?ioTemporaries.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicSetupInstructionListIR += instructionGenerationList
  else
    [!?ioTemporaries.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicLoopInstructionListIR += instructionGenerationList
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

