#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @panicAST : @abstractDeclarationAST {
  @bool mIsSetup # true: setup, false: loop
  @instructionListAST mPanicInstructionList
  @location mEndOfPanicInstructions
  @lbigint mPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $panic$
    $setup$
    $integer$ ?let priority
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mDeclarationListAST += !@panicAST.new {
      !true
      !instructionList
      !endOfInstructionList
      !priority
    }
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $panic$
    $loop$
    $integer$ ?let priority
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfInstructionList = @location.here
    $}$
    ioAST.mDeclarationListAST += !@panicAST.new {
      !false
      !instructionList
      !endOfInstructionList
      !priority
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @panicAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mPanicInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @panicAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {
   !"panic " + if mIsSetup then "setup" else "loop" end + " " + mPriority.bigint
   !mPriority.location
 }
 [!?ioGraph addNode !nodeName !self]
}

#·······················································································································

override getter @panicAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "panic " + if mIsSetup then "setup" else "loop" end + " " + mPriority.bigint
}

#·······················································································································

override getter @panicAST location -> @location outLocation {
  outLocation = mPriority.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @panicAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @panicRoutinePriorityMap {
  insert insertSetupKey error message "a panic setup routine with priority %K has been already declared"
  insert insertLoopKey error message "a panic loop routine with priority %K has been already declared"
  search searchSetupKey error message "there is no panic setup routine with priority %K"
  search searchLoopKey error message "there is no panic loop routine with priority %K"
}

#·······················································································································

override method @panicAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  if mIsSetup then
    [!?ioContext.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
  else
    [!?ioContext.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
  end
#---------------- Invocation graph
  let routineNameForInvocationGraph = panicNameForInvocationGraph (!if mIsSetup then "setup" else "loop" end !mPriority)
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedPanicRoutine.new {
    !mIsSetup
    !mPanicInstructionList
    !mEndOfPanicInstructions
    !mPriority
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once panicModeName -> @string {
  result = "panic"
}

#·······················································································································

class @decoratedPanicRoutine : @abstractDecoratedDeclaration {
  @bool mIsSetup # true: setup, false: loop
  @instructionListAST mPanicInstructionList
  @location mEndOfPanicInstructions
  @lbigint mPriority
}

#·······················································································································

override method @decoratedPanicRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let routineNameForInvocationGraph = panicNameForInvocationGraph (!if mIsSetup then "setup" else "loop" end !mPriority)
#--- Variable map
  initialVariableMap (
    !context:inContext
    !mode:.panicMode
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
    ?@universalValuedObjectMapForContext universalMap
  )
#--- Insert predefined input arguments
  let codeArg = @lstring.new {!"CODE" !mPriority.location}
  [!?universalMap insertUsedLocalConstant !codeArg ![inContext.mPanicCodeType type] !codeArg]
  let fileArg = @lstring.new {!"FILE" !mPriority.location}
  let StaticStringType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap ![staticStringTypeName () nowhere]} type]
  [!?universalMap insertUsedLocalConstant !fileArg !StaticStringType !fileArg]
  let lineArg = @lstring.new {!"LINE" !mPriority.location}
  [!?universalMap insertUsedLocalConstant !lineArg ![inContext.mPanicLineType type] !lineArg]
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList initAllocaList = {}
  [mPanicInstructionList analyzeRoutineInstructionList
    !self:voidType ()
    !instructionAttributes:.none
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.panicMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:universalMap
    !?alloca:initAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [universalMap checkLocalVariableFinalState]
#  [variableMap checkAutomatonStates !mEndOfPanicInstructions]
#  drop variableMap
#--- Code generation
  if mIsSetup then
    [!?ioTemporaries.mPanicSetupRoutinePriorityMap insertSetupKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicSetupInstructionListIR += !instructionGenerationList !mPriority.bigint
  else
    [!?ioTemporaries.mPanicLoopRoutinePriorityMap insertLoopKey !.new{![mPriority string] !mPriority.location}]
    ioIntermediateCodeStruct.mPanicLoopInstructionListIR += !instructionGenerationList !mPriority.bigint
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @instructionListSortedListIR {
  @instructionListIR mInstructionList
  @bigint mPriority
}{
  mPriority <
}

#·······················································································································

proc generatePanicCode
  ?!@string ioLLVMcode
  ?currentDir:let @string inCurrentDirectory
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
  ?targetParameters:let @targetParameters inTargetParameters
  ?targetName:let @string inTargetName
  ?generationContext:let @generationContext inGenerationContext
  ?!generationAdds:@generationAdds ioGenerationAdds
  ?setup:let @instructionListSortedListIR inPanicSetupInstructionListIR
  ?loop:let @instructionListSortedListIR inPanicLoopInstructionListIR
{
  if not [option plm_options.noPanicGeneration value] then
    let s = getTargetTextFile (
       !currentDir:inCurrentDirectory
       !from:inTargetName + "/" + inTargetParameters.mTargetPanic_LL_filePath
    )
    let s1 = [s stringByReplacingStringByString !"!PANICCODE!" !inGenerationContext.mPanicCodeLLVMType]
    let s2 = [s1 stringByReplacingStringByString !"!PANICLINE!" !inGenerationContext.mPanicLineLLVMType]
    ioLLVMcode += s2
    ioLLVMcode += llvmTitleComment (!"Raise Panic internal")
    ioLLVMcode += "define internal void @raise.panic.internal ("
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " %in.LINE, "
    ioLLVMcode += inGenerationContext.mPanicCodeLLVMType + " %in.CODE, "
    ioLLVMcode += "i8* %in.FILE)" + llvmAttributeFunction () + "noreturn {\n"
  #--- First argument: line
    ioLLVMcode += "  " + llvmNameForLocalVariable (!"LINE") + " = alloca "
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + "\n"
    ioLLVMcode += "  store " + inGenerationContext.mPanicLineLLVMType + " %in.LINE, "
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " * " + llvmNameForLocalVariable (!"LINE") + "\n"
  #--- Second argument : code
    ioLLVMcode += "  " + llvmNameForLocalVariable (!"CODE")
    ioLLVMcode += " = alloca " + inGenerationContext.mPanicCodeLLVMType + "\n"
    ioLLVMcode += "  store " + inGenerationContext.mPanicCodeLLVMType + " %in.CODE, "
    ioLLVMcode += inGenerationContext.mPanicCodeLLVMType + " * " + llvmNameForLocalVariable (!"CODE") + "\n"
  #--- Third argument : file    
    ioLLVMcode += "  " + llvmNameForLocalVariable (!"FILE") + " = alloca i8*\n"
    ioLLVMcode += "  store i8* %in.FILE, i8** " + llvmNameForLocalVariable (!"FILE") + "\n"
    for (instructionList *) in inPanicSetupInstructionListIR do
      [instructionList instructionListLLVMCode
        !?ioLLVMcode
        !inGenerationContext
        !?ioGenerationAdds
      ]
    end
    ioLLVMcode += "  br label %panic.loop\n\n"
    ioLLVMcode += "panic.loop:\n"
    for (instructionList *) in inPanicLoopInstructionListIR do
      [instructionList instructionListLLVMCode
        !?ioLLVMcode
        !inGenerationContext
        !?ioGenerationAdds
      ]
    end
    ioLLVMcode += "  br label %panic.loop\n"
    ioLLVMcode += "}\n\n"
  #--- Panic for isr
    [!?ioGenerationAdds.mStaticStringMap findOrAddStaticString !"" ?let emptyStringIndex]
    ioLLVMcode += llvmTitleComment (!"Panic for ISR")
    ioLLVMcode += "define internal void @panic.isr (" + inGenerationContext.mPanicCodeLLVMType + " %in.CODE) " + llvmAttributeFunction () + "noreturn {\n"
    ioLLVMcode += "  %str.FILE = load i8*, i8** " + literalStringName (!emptyStringIndex) + "\n"
    ioLLVMcode += "  call void @raise.panic.internal ("    
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " 0, "
    ioLLVMcode += inGenerationContext.mPanicCodeLLVMType + " %in.CODE, "
    ioLLVMcode += "i8* %str.FILE"
    ioLLVMcode += " )\n"    
    ioLLVMcode += "  unreachable\n"    
    ioLLVMcode += "}\n\n"    
  #--- File specific routines
    for (filePath) in inSourceFileAbsolutePathSet do
      [!?ioGenerationAdds.mStaticStringMap findOrAddStaticString
        ![[filePath lastPathComponent] stringByDeletingPathExtension]
        ?let staticStringIndex
      ]
      let routineName = "@raise.panic." + staticStringIndex
      ioLLVMcode += llvmTitleComment (!routineName + " (" + [filePath lastPathComponent] + ")")
      ioLLVMcode += "define internal void " + routineName + " ("
      ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " %inSourceLine, "
      ioLLVMcode += inGenerationContext.mPanicCodeLLVMType + " %inCode)" + llvmAttributeFunction () + "noreturn {\n"
      ioLLVMcode += "  %str.FILE = load i8*, i8** " + literalStringName (!staticStringIndex) + "\n"
      ioLLVMcode += "  call void @raise.panic ("
      ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " %inSourceLine, "
      ioLLVMcode += inGenerationContext.mPanicCodeLLVMType + " %inCode, i8* %str.FILE)\n"
      ioLLVMcode += "  unreachable\n"
      ioLLVMcode += "}\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
