setter @instructionListIR appendLoadFromMemory
  ?!@semanticTemporariesStruct ioTemporaries
  ?let @location inErrorLocation
  ?let @objectInMemoryIR inSource
  !@objectIR outResultingValue
{
  switch inSource
  case registerAddress (* *) :
    error .nowhere : "<<@instructionListIR appendLoadFromMemory>>" : outResultingValue
  case register (@unifiedTypeMap-proxy type * * * @bigint address * @uint arraySize *) :
    if arraySize > 0 then
      error inErrorLocation : "register array requires subscripting" : outResultingValue
    else
      getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
      [!?self appendLoadVolatileRegister
        !outResultingValue
        !address
      ]
    end
  case globalVariable (@unifiedTypeMap-proxy type @string name @bool isVolatile) :
    getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
    [!?self appendLoadGlobalVariable
      !outResultingValue
      !name
      !volatile:isVolatile
    ]
  case localVariable (@unifiedTypeMap-proxy type @string name @bool volatile) :
    getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
    [!?self appendLoadLocalVariable
      !outResultingValue
      !name
      !volatile
    ]
  case staticConstant (@objectIR value @lstring unused name) :
    outResultingValue = value

  case property (* * *) :
    error .nowhere : "<<@instructionListIR appendLoadFromMemory>>" : outResultingValue
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendStoreInMemory
  ?let @objectInMemoryIR inTargetPtr
  ?let @objectIR inValue
{
  switch inTargetPtr
  case registerAddress (@unifiedTypeMap-proxy type @string llvmName) :
    [!?self appendStoreVolatileRegisterIndirect !type !llvmName !inValue]
  case register (@unifiedTypeMap-proxy type * * * @bigint address * * *) :
    [!?self appendStoreVolatileRegister !type !address !inValue]
  case globalVariable (@unifiedTypeMap-proxy type @string name @bool isVolatile) :
    [!?self appendStoreGlobalVariable !name !type !inValue !volatile:isVolatile]
  case localVariable (@unifiedTypeMap-proxy type @string name *) :
    [!?self appendStoreLocalVariable !name !type !inValue]
  case staticConstant (* *) :
     error .nowhere : "<<@objectInMemoryIR storeInMemory globalConstant>>"
  case property (* * *) :
    error .nowhere : "<<@instructionListIR appendStoreInMemory>>"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendStoreFromReference
  ?let @objectIR inTargetReference
  ?let @location inErrorLocation
  ?let @objectIR inValue
{
  switch inTargetReference
#--- Temporary ?
  case selfObject (*) :
    error .nowhere : "<<@instructionListIR appendStoreFromReference selfObject>>"
  case llvmGlobalObjectValue (**) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue selfObject>>"
#--- References
  case globalVariableReference (@unifiedTypeMap-proxy type @string plmName) :
    [!?self appendStoreGlobalVariable !plmName !type !inValue !volatile:false]
  case localVariableReference (@unifiedTypeMap-proxy type @string plmName) :
    [!?self appendStoreLocalVariable !plmName !type !inValue]
  case temporaryReference (@unifiedTypeMap-proxy type @string llvmName * @bool volatile) :
    [!?self appendStoreTemporaryReference !type !llvmName !inValue !volatile:volatile]
#    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue temporaryReference>>"
#    [!?self appendStoreTemporaryReference !plmName !type !inValue]
  case registerReference (type * * * address * arraySize *) :
    if arraySize > 0 then
      error inErrorLocation : "register array requires subscripting"
    end
    [!?self appendStoreVolatileRegister !type !address !inValue]
#--- Structure property
  case property (* * *) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue property>>"
#--- Values
  case llvmTemporaryValue (* * *) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue llvmTemporaryValue>>"
  case literalInteger  (* *) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue literalInteger>>"
  case llvmStructureConstant (* *) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue llvmStructureConstant>>"
  case literalString  (* * *) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue literalString>>"
  case zero (*) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue zero>>"
  case possibleFunction (* *) :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue possibleFunction>>"
  case null :
    error .nowhere : "<<@instructionListIR llvmGlobalObjectValue null>>"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendLoadFromReference
  ?!@semanticTemporariesStruct ioTemporaries
  ?let @objectIR inSource
  ?let @location inErrorLocation
  !@objectIR outResultingValue
{
  switch inSource
  case null :
    error .nowhere : "<<@instructionListIR appendLoadFromReference null>>" : outResultingValue
  case possibleFunction (* functionName) :
    error functionName : "<<@instructionListIR appendLoadFromReference possibleFunction>>" : outResultingValue
  case selfObject (*) :
    outResultingValue = inSource
  case llvmGlobalObjectValue (**) :
    outResultingValue = inSource
#--- References
  case globalVariableReference (@unifiedTypeMap-proxy type @string name) :
    getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
    [!?self appendLoadGlobalVariable
      !outResultingValue
      !name
      !volatile:false
    ]
  case localVariableReference (@unifiedTypeMap-proxy type @string name) :
    getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
    [!?self appendLoadLocalVariable
      !outResultingValue
      !name
      !false
    ]
  case temporaryReference (@unifiedTypeMap-proxy type @string llvmName * volatile) :
    getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
    [!?self appendLoadFromTemporaryReference
      !outResultingValue
      !llvmName
      !volatile
    ]
  case registerReference (type * * * address * arraySize *) :
    if arraySize > 0 then
      error inErrorLocation : "register array requires subscripting" : outResultingValue
    else
      getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
      [!?self appendLoadVolatileRegister
        !outResultingValue
        !address
      ]
    end
#--- Structure property
  case property (type plmName index) :
    getNewTempVariable (!type !?ioTemporaries ?outResultingValue)
    [!?self appendGetPropertyReference
      !outResultingValue
      !inSource
      !plmName
      !index
    ]
#--- Values
  case literalInteger (**) :
    outResultingValue = inSource
  case llvmTemporaryValue (***) :
    outResultingValue = inSource
  case llvmStructureConstant (* *) :
    outResultingValue = inSource
  case literalString (***) :
    outResultingValue = inSource
  case zero (*) :
    outResultingValue = inSource
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
