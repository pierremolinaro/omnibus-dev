#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! UNIVERSAL PROPERTY - ROUTINE MAP
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# Cette table contient routines et variables. La clé est le nom de la variable ou le nom de la routine. Il est valide
# d'avoir plusieurs routines de même nom, du moment qu'elle se distinguent par leur signature. Il est valide d'avoir une
# variable de même nom qu'une routine : la syntaxe permet de savoir si une routine ou une variable est attendue.

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @routineMapForContext {
  @internalRoutineMapForContext mInternalRoutineMap
}

#·······················································································································

map @internalRoutineMapForContext { # Key is a mangled name
  @routineArgumentSignatureMapForContext mRoutineArgumentSignatureMapForContext

  insert insertKey error message "the '%K' routine is already declared in %L"
  search searchKey error message "there is no '%K' routine"
}

#·······················································································································

map @routineArgumentSignatureMapForContext { # argument signature is the key
  @lstring mRoutineLLVMName
  @routineDescriptor mDescriptor

  insert insertKey error message "the '%K' routine signature is already declared in %L"
  search searchKey %location error message "there is no '%K' routine signature"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INSERT SETTER
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @routineMapForContext insertRoutine
  ?let @string inReceiverTypeName # "" if not self type
  ?let @lstring inRoutineName
  ?let @lstring inArgumentSignature
  ?let @lstring inRoutineLLVMName
  ?let @routineDescriptor inDescriptor
{
  let routineName = @lstring.new {!inReceiverTypeName + "." + inRoutineName.string !inRoutineName.location}
  
  with routineName.string in !?mInternalRoutineMap do
    [!?mRoutineArgumentSignatureMapForContext insertKey
      !inArgumentSignature
      !inRoutineLLVMName
      !inDescriptor
    ]
  else
    @routineArgumentSignatureMapForContext routineArgumentSignatureMapForContext = {}
    [!?routineArgumentSignatureMapForContext insertKey
      !inArgumentSignature
      !inRoutineLLVMName
      !inDescriptor
    ]
    [!?mInternalRoutineMap insertKey !routineName !routineArgumentSignatureMapForContext]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEARCH METHOD
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapForContext searchKey
  ?let @string inReceiverTypeName # "" if not self type
  ?let @lstring inRoutineName
  ?let @lstring inArgumentSignature
  !@lstring outRoutineLLVMName
  !@routineDescriptor outDescriptor
  !@location outKeyLocation
{
  let routineName = @lstring.new {!inReceiverTypeName + "." + inRoutineName.string !inRoutineName.location}

  [mInternalRoutineMap searchKey !routineName ?let routineArgumentSignatureMapForContext]

  [routineArgumentSignatureMapForContext searchKey !inArgumentSignature ?outRoutineLLVMName ?outDescriptor ?outKeyLocation]
}

#·······················································································································

getter @routineMapForContext hasKey
  ?let @string inReceiverTypeName # "" if not self type
  ?let @lstring inRoutineName
  ?let @lstring inArgumentSignature
  -> @bool
{
  let routineName = @lstring.new {!inReceiverTypeName + "." + inRoutineName.string !inRoutineName.location}

  result = [mInternalRoutineMap hasKey !routineName]
  if result then
    [mInternalRoutineMap searchKey !routineName ?let routineArgumentSignatureMapForContext]
    result = [routineArgumentSignatureMapForContext hasKey !inArgumentSignature]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
