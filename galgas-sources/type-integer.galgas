#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerDeclarationAST : @abstractDeclarationAST {
  @bool mIsSigned
  @uint mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclarationAST location -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @integerDeclarationAST typeName -> @string outName {
  outName = if mIsSigned then "int" else "uint" end + mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let integerTypeName = llvmTypeNameFromPLMname (![[self typeName] nowhere])
  [!?ioGraph addNode !integerTypeName !self]
  [!?ioGraph addEdge !integerTypeName !llvmTypeNameFromPLMname (![staticIntegerTypeName () nowhere])]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "integer " + llvmTypeNameFromPLMname (![[self typeName] nowhere])
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  UTILITIES                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func minValueForInteger ?let @bool inIsUnsigned ?let @uint inBitCount -> @bigint {
  if inIsUnsigned then
    result = 0G
  else # Signed
    result = - (1G << (inBitCount - 1))
  end
}

#·······················································································································

func maxValueForInteger ?let @bool inIsUnsigned ?let @uint inBitCount -> @bigint {
  if inIsUnsigned then
    result = (1G << inBitCount) - 1G
  else # Signed
    result = (1G << (inBitCount - 1)) - 1G
  end
}

#·······················································································································

func %once byteSwappedMethoName -> @string {
  result = "byteSwapped"
}

#·······················································································································

func %once bitReversedMethoName -> @string {
  result = "bitReversed"
}

#·······················································································································

func %once countLeadingZerosMethoName -> @string {
  result = "leadingZeroCount"
}

#·······················································································································

func %once countTrainingZerosMethoName -> @string {
  result = "trainingZeroCount"
}

#·······················································································································

func %once setBitCountMethoName -> @string {
  result = "setBitCount"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
{
  let integerTypeName = [[self typeName] nowhere]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !integerTypeName ?let selfTypeProxy]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !.new {!boolTypeName () !.nowhere} ?let boolTypeProxy]
#--------------------------------------- Get min and max
  let min = minValueForInteger (!not mIsSigned !mSize)
  let max = maxValueForInteger (!not mIsSigned !mSize)
#--------------------------------------- Property map
  @propertyMap propertyMap = {}
  if (mSize mod 16) == 0 then # Add "byteSwapped" intrinsic function
    [!?propertyMap addFunctionWithoutArgument
      !?ioSubprogramInvocationGraph
      !receiverTypeProxy:selfTypeProxy
      !methodName:byteSwappedMethoName ()
      !safe:true
      !resultTypeProxy:selfTypeProxy
      !canMutateProperties:false
    ]
  end
  if mSize == 1 && not mIsSigned then # Add "bool" intrinsic function
    [!?propertyMap addFunctionWithoutArgument
      !?ioSubprogramInvocationGraph
      !receiverTypeProxy:selfTypeProxy
      !methodName:boolTypeName ()
      !safe:true
      !resultTypeProxy:boolTypeProxy
      !canMutateProperties:false
    ]
  end
  [!?propertyMap addFunctionWithoutArgument
    !?ioSubprogramInvocationGraph
    !receiverTypeProxy:selfTypeProxy
    !methodName:bitReversedMethoName ()
    !safe:true
    !resultTypeProxy:selfTypeProxy
    !canMutateProperties:false
  ]
  [!?propertyMap addFunctionWithoutArgument
    !?ioSubprogramInvocationGraph
    !receiverTypeProxy:selfTypeProxy
    !methodName:countLeadingZerosMethoName ()
    !safe:true
    !resultTypeProxy:selfTypeProxy
    !canMutateProperties:false
  ]
  [!?propertyMap addFunctionWithoutArgument
    !?ioSubprogramInvocationGraph
    !receiverTypeProxy:selfTypeProxy
    !methodName:countTrainingZerosMethoName ()
    !safe:true
    !resultTypeProxy:selfTypeProxy
    !canMutateProperties:false
  ]
  [!?propertyMap addFunctionWithoutArgument
    !?ioSubprogramInvocationGraph
    !receiverTypeProxy:selfTypeProxy
    !methodName:setBitCountMethoName ()
    !safe:true
    !resultTypeProxy:selfTypeProxy
    !canMutateProperties:false
  ]
#--------------------------------------- Class constant map
  @classConstantMap classConstantMap = {}
  [!?classConstantMap insertKey !["min" nowhere] !min !integerTypeName]
  [!?classConstantMap insertKey !["max" nowhere] !max !integerTypeName]
#--------------------------------------- Constructor map
  @constructorMap constructorMap = {} 
  [!?constructorMap insertKey !["()" nowhere] !{} !.simple {!value:0}]
#--------------------------------------- Enter in type map
  let integerType = @PLMType.new {
    !propertyMap:propertyMap
    !classConstantMap:classConstantMap
    !constructorMap:constructorMap
    !guardMap:{}
    !attributes:.instanciable | .equatable | .copyable | .generateAssignmentRoutine
    !plmOriginalTypeName:integerTypeName
    !kind:.integer {!min:min !max:max !unsigned:not mIsSigned !bitCount:mSize}
    !plmAliasedTypeName:integerTypeName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:integerTypeName
    !type:integerType
    !index:[ioContext.mTypeMap count]
  ]
#--------------------------------------- Enter integer <-> integer operators
  enter_integer_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--------------------------------------- Enter integer <-> literal operators
  enter_integer_literal_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--------------------------------------- Enter literal <-> integer operators
  enter_literal_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@integerDecoratedDeclaration.new {!integerTypeName !mSize !mIsSigned}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerDecoratedDeclaration : @abstractDecoratedDeclaration {
  @string mTypeName
  @uint mSize
  @bool mIsSigned
}

#·······················································································································

override method @integerDecoratedDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  ioIntermediateCodeStruct.mGenerationListIR += !@integerIR.new {!mTypeName !mSize !mIsSigned}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerIR : @abstractGenerationIR {
  @string mTypeName
  @uint mSize
  @bool mIsSigned
}

#·······················································································································

private proc generateIntegerIntrinsicFunction
  ?PLMTypeName:let @string inPLMtypeName
  ?!@string ioLLVMcode
  ?method:let @string inPLMMethodName
  ?intrinsic:let @string inIntrinsicName
  ?!@generationAdds ioGenerationAdds
  ?LLVMTypeName:let @string inLLVMtypeName
{
  let routineMangledName = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inPLMtypeName)
    ![inPLMMethodName nowhere]
    !{}
  )
  let functionName = llvmNameForFunction (!routineMangledName)
  ioLLVMcode += "define internal " + inLLVMtypeName + " @" + functionName + " (" + inLLVMtypeName + "* %inValue) {\n"
  ioLLVMcode += "  %value = load " + inLLVMtypeName + ", " + inLLVMtypeName + "* %inValue\n"
  ioLLVMcode += "  %result = call " + inLLVMtypeName + " @llvm." + inIntrinsicName + "." + inLLVMtypeName + " (" + inLLVMtypeName + " %value)\n"
  ioLLVMcode += "  ret " + inLLVMtypeName + " %result\n"
  ioLLVMcode += "}\n\n"
  ioGenerationAdds.mExternFunctionDeclarationSet +=
    !inLLVMtypeName + " @llvm." + inIntrinsicName + "." + inLLVMtypeName + " (" + inLLVMtypeName + ")"
}

#·······················································································································

private proc generateUInt1ToBoolFunction
  ?PLMTypeName:let @string inPLMtypeName
  ?!@string ioLLVMcode
  ?LLVMTypeName:let @string inLLVMtypeName
{
  let routineMangledName = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inPLMtypeName)
    ![boolTypeName () nowhere]
    !{}
  )
  let functionName = llvmNameForFunction (!routineMangledName)
  ioLLVMcode += "define internal " + inLLVMtypeName + " @" + functionName + " (" + inLLVMtypeName + "* %inValue) {\n"
  ioLLVMcode += "  %value = load " + inLLVMtypeName + ", " + inLLVMtypeName + "* %inValue\n"
  ioLLVMcode += "  ret i1 %value\n"
  ioLLVMcode += "}\n\n"
}

#·······················································································································

override method @integerIR generateLLVMcode ?!@string ioLLVMcode ?!@generationAdds ioGenerationAdds {
  let llvmTypeName = "i" + mSize
  ioLLVMcode += llvmTitleComment (!"INTEGER TYPE $" + mTypeName)
#--- Add "bool" function for $uint1
  if (mSize == 1) && not mIsSigned then
    generateUInt1ToBoolFunction (
      !PLMTypeName:mTypeName
      !?ioLLVMcode
      !LLVMTypeName:llvmTypeName
    )
  end
#--- Add "byteSwapped" intrinsic function
  if (mSize mod 16) == 0 then
    generateIntegerIntrinsicFunction (
      !PLMTypeName:mTypeName
      !?ioLLVMcode
      !method:byteSwappedMethoName ()
      !intrinsic:"bswap"
      !?ioGenerationAdds
      !LLVMTypeName:llvmTypeName
    )
  end
#--- Add "bitReversed" intrinsic function
  generateIntegerIntrinsicFunction (
    !PLMTypeName:mTypeName
    !?ioLLVMcode
    !method:bitReversedMethoName ()
    !intrinsic:"bitreverse"
    !?ioGenerationAdds
    !LLVMTypeName:llvmTypeName
  )
#--- Add "count leading zeros" intrinsic function
  generateIntegerIntrinsicFunction (
    !PLMTypeName:mTypeName
    !?ioLLVMcode
    !method:countLeadingZerosMethoName ()
    !intrinsic:"ctlz"
    !?ioGenerationAdds
    !LLVMTypeName:llvmTypeName
  )
#--- Add "count training zeros" intrinsic function
  generateIntegerIntrinsicFunction (
    !PLMTypeName:mTypeName
    !?ioLLVMcode
    !method:countTrainingZerosMethoName ()
    !intrinsic:"cttz"
    !?ioGenerationAdds
    !LLVMTypeName:llvmTypeName
  )
#--- Add "count training zeros" intrinsic function
  generateIntegerIntrinsicFunction (
    !PLMTypeName:mTypeName
    !?ioLLVMcode
    !method:setBitCountMethoName ()
    !intrinsic:"ctpop"
    !?ioGenerationAdds
    !LLVMTypeName:llvmTypeName
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN INTEGERS object <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
  let booleanType = [ioContext booleanType]
#--- Comparison infix operator
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !inIntegerTypeName.string)
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.xor}
    ]
    [!?ioContext.mUnsignedComplementOperatorMap insertKey
      !inIntegerTypeName
    ]
  end
#--- Negate operator (for signed integers)
  if inIsSigned then
    [!?ioContext.mUnaryMinusOperatorMap insertKey
      !inIntegerTypeName
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @infixObjectObjectOperatorDescription : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixObjectObjectOperatorDescription generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#  message "INFIX OP " + "\n"
  if [inLeftOperand isLiteralInteger] && [inRightOperand isLiteralInteger] then
    [inLeftOperand  literalInteger ?1* ?value:let @bigint left]
    [inRightOperand literalInteger ?1* ?value:let @bigint right]
#    message "INFIX OP LITERAL LITERAL " + left + " " + right + "\n"
    let resultValue = [self performStaticOperation !left !right]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
#    message "INFIX OP COMPUTE\n"
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inLeftOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN AN INTEGER AND A LITERAL INTEGER object <-> literal integer
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_literal_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
  let booleanType = [ioContext booleanType]
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !staticIntegerTypeName ())
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerObject_literal_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerObject_literal_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#  message "INFIX OP2 " + "\n"
#--- Check right literal integer can be extented to left integer type, ans is not zero
  [inRightOperand literalInteger ?1* ?value:let @bigint literalValue]
  [[inLeftOperand type].kind integer ?min:let @bigint min ?max:let @bigint max ?2*]
  if literalValue < min then
    error inOperatorLocation : "literal right integer expression too small (should be >= " + min + ")" : outResult
  elsif literalValue > max then
    error inOperatorLocation : "literal right integer expression too large (should be <= " + max + ")" : outResult
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inLeftOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN A LITERAL INTEGER AND AN INTEGER literal integer <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_literal_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!staticIntegerTypeName () !inIntegerTypeName.string)
  let booleanType = [ioContext booleanType]
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_integerObject_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_integerObject_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#--- Check left literal integer can be extented to right integer type
  [inLeftOperand literalInteger ?1* ?value:let @bigint literalValue]
  [[inRightOperand type].kind integer ?min:let @bigint min ?max:let @bigint max ?2*]
  if literalValue < min then
    error inOperatorLocation : "literal left integer expression too small (should be >= " + min + ")" : outResult
  elsif literalValue > max then
    error inOperatorLocation : "literal left integer expression too large (should be <= " + max + ")" : outResult
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inRightOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
