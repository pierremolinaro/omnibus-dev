#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerDeclarationAST : @abstractDeclarationAST {
  @bool mIsSigned
  @uint mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @integerDeclarationAST typeName -> @string outName {
  outName = if mIsSigned then "$int" else "$uint" end + mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let integerTypeName = [[self typeName] nowhere]
  [!?ioGraph addNode !integerTypeName !self]
  [!?ioGraph addEdge !integerTypeName ![staticIntegerTypeName () nowhere]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "integer " + [self typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  UTILITIES                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func minValueForInteger ?let @bool inIsUnsigned ?let @uint inBitCount -> @bigint {
  if inIsUnsigned then
    result = 0G
  else # Signed
    result = - (1G << (inBitCount - 1))
  end
}

#·······················································································································

func maxValueForInteger ?let @bool inIsUnsigned ?let @uint inBitCount -> @bigint {
  if inIsUnsigned then
    result = (1G << inBitCount) - 1G
  else # Signed
    result = (1G << (inBitCount - 1)) - 1G
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
  let integerTypeName = [[self typeName] nowhere]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !integerTypeName ?let selfTypeProxy]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !.new {!boolTypeName () !.nowhere} ?let boolTypeProxy]
#--------------------------------------- Get min and max
  let min = minValueForInteger (!not mIsSigned !mSize)
  let max = maxValueForInteger (!not mIsSigned !mSize)
#--------------------------------------- Property map
  let llvmTypeName = "i" + mSize
  @routineMapCTXT routineMap = {}
  @propertyGetterMap propertyGetterMap = {}
#--------------------------------------- byteSwapped
  if (mSize mod 16) == 0 then
    [!?propertyGetterMap addPropertyGetter
      !llvmBaseTypeName:integerTypeName
      !propertyName:["byteSwapped" nowhere]
      !mode:.anySafeMode
      !public: true
      !resultTypeProxy:selfTypeProxy
      ?routineLLVMName: let routineLLVMName
    ]
    ioRoutineListIR += !@integerBuiltinFunctionIR.new {
      !routineLLVMName
      !isRequired:false
      !warnsIfUnused:false
      !llvmTypeName
      !"bswap"
    }
  end
#--------------------------------------- bool for $uint1
  if mSize == 1 && not mIsSigned then # Add "bool" intrinsic function
    [!?propertyGetterMap addPropertyGetter
      !llvmBaseTypeName:integerTypeName
      !propertyName:[boolTypeName () nowhere]
      !mode:.anySafeMode
      !public: true
      !resultTypeProxy:boolTypeProxy
      ?routineLLVMName: let routineLLVMName
    ]
    ioRoutineListIR += !@uint1ToBoolFunctionIR.new {
      !routineLLVMName
      !isRequired:false
      !warnsIfUnused:false
      !llvmTypeName
    }
  end
#--------------------------------------- bitreverse
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["bitReversed" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: var routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"bitreverse"
  }
#--------------------------------------- leadingZeroCount
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["leadingZeroCount" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"ctlz"
  }
#--------------------------------------- trainingZeroCount
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["trainingZeroCount" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"cttz"
  }
#--------------------------------------- setBitCountMethodName
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["setBitCount" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"ctpop"
  }
#--------------------------------------- Class constant map
  @classConstantMap classConstantMap = {}
  [!?classConstantMap insertKey !["min" nowhere] !min !integerTypeName]
  [!?classConstantMap insertKey !["max" nowhere] !max !integerTypeName]
#--------------------------------------- Constructor map
  @constructorMap constructorMap = {} 
  [!?constructorMap insertKey !["()" nowhere] !{} !.simple {!value:0}]
#--------------------------------------- Enter in type map
  let integerType = @PLMType.new {
    !propertyGetterMap:propertyGetterMap
    !propertySetterMap: {}
    !routineMap: routineMap
    !classConstantMap:classConstantMap
    !constructorMap:constructorMap
    !guardMap:{}
    !subscript:.noSubscript
    !assignmentSources: {!integerTypeName}
    !attributes:.instanciable | .equatable | .copyable | .comparable
    !plmTypeDescriptionName:integerTypeName
    !kind:.integer {!min:min !max:max !unsigned:not mIsSigned !bitCount:mSize}
    !llvmBaseTypeName:integerTypeName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:integerTypeName
    !type:integerType
  ]
#--------------------------------------- Enter integer <-> integer operators
  enter_integer_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--------------------------------------- Enter integer <-> literal operators
  enter_integer_literal_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--------------------------------------- Enter literal <-> integer operators
  enter_literal_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#---------- Enter integer assignment function
  ioRoutineListIR += !@integerTypeAssignFunctionIR.new {
    ![assignmentPrefix () + integerTypeName + "." + integerTypeName nowhere]
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN INTEGERS object <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
  let booleanType = [ioContext booleanType]
#--- Comparison infix operator
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName !inIntegerTypeName)
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
#  [!?ioContext.mNonEqualOperatorMap insertKey
#    !intIntOp
#    !booleanType
#    !@infixObjectObjectOperatorDescription.new {!.icmp_ne}
#  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.xor}
    ]
    [!?ioContext.mUnsignedComplementOperatorMap insertKey
      !inIntegerTypeName
    ]
  end
#--- Negate operator (for signed integers)
  if inIsSigned then
    [!?ioContext.mUnaryMinusOperatorMap insertKey
      !inIntegerTypeName
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @infixObjectObjectOperatorDescription : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixObjectObjectOperatorDescription generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
  if [inLeftOperand isLiteralInteger] && [inRightOperand isLiteralInteger] then
    [inLeftOperand  literalInteger ?1* ?value:let @bigint left]
    [inRightOperand literalInteger ?1* ?value:let @bigint right]
    let resultValue = [self performStaticOperation !left !right]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inLeftOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN AN INTEGER AND A LITERAL INTEGER object <-> literal integer
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_literal_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
  let booleanType = [ioContext booleanType]
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !staticIntegerTypeName ())
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!.icmp_eq}
  ]
#  [!?ioContext.mNonEqualOperatorMap insertKey
#    !intLiteralOp
#    !booleanType
#    !@integerObject_literal_infixOperator.new {!.icmp_ne}
#  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerObject_literal_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerObject_literal_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#--- Check right literal integer can be extented to left integer type, ans is not zero
  [inRightOperand literalInteger ?1* ?value:let @bigint rightLiteralValue]
  [[inLeftOperand type].kind integer ?min:let @bigint min ?max:let @bigint max ?2*]
  if rightLiteralValue < min then
    error inOperatorLocation : "literal right integer expression too small (should be >= " + min + ")" : outResult
  elsif rightLiteralValue > max then
    error inOperatorLocation : "literal right integer expression too large (should be <= " + max + ")" : outResult
  elsif [inLeftOperand isLiteralInteger] then
    [inLeftOperand literalInteger ?1* ?value:let @bigint leftLiteralValue]
    let resultValue = [self performStaticOperation !leftLiteralValue !rightLiteralValue]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inLeftOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN A LITERAL INTEGER AND AN INTEGER literal integer <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_literal_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!staticIntegerTypeName () !inIntegerTypeName.string)
  let booleanType = [ioContext booleanType]
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!.icmp_eq}
  ]
#  [!?ioContext.mNonEqualOperatorMap insertKey
#    !intLiteralOp
#    !booleanType
#    !@literal_integerObject_infixOperator.new {!.icmp_ne}
#  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_integerObject_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_integerObject_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#--- Check left literal integer can be extended to right integer type
  [inLeftOperand literalInteger ?1* ?value:let @bigint leftLiteralValue]
  [[inRightOperand type].kind integer ?min:let @bigint min ?max:let @bigint max ?2*]
  if leftLiteralValue < min then
    error inOperatorLocation : "literal left integer expression too small (should be >= " + min + ")" : outResult
  elsif leftLiteralValue > max then
    error inOperatorLocation : "literal left integer expression too large (should be <= " + max + ")" : outResult
  elsif [inRightOperand isLiteralInteger] then
    [inRightOperand literalInteger ?1* ?value:let @bigint rightLiteralValue]
    let resultValue = [self performStaticOperation !leftLiteralValue !rightLiteralValue]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inRightOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: UINT1 TO BOOL FUNCTION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @uint1ToBoolFunctionIR : @abstractRoutineIR {
  @string mLLVMTypeName
}

#·······················································································································

override method @uint1ToBoolFunctionIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "define internal " + mLLVMTypeName + " @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + mLLVMTypeName + "* %inValue) {\n"
  ioLLVMcode += "  %value = load " + mLLVMTypeName + ", " + mLLVMTypeName + "* %inValue\n"
  ioLLVMcode += "  ret i1 %value\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: BUILTIN FUNCTIONS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerBuiltinFunctionIR : @abstractRoutineIR {
  @string mLLVMTypeName
  @string mIntrinsicName
}

#·······················································································································

override method @integerBuiltinFunctionIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += "define internal " + mLLVMTypeName + " @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + mLLVMTypeName + "* %inValue) {\n"
  ioLLVMcode += "  %value = load " + mLLVMTypeName + ", " + mLLVMTypeName + "* %inValue\n"
  ioLLVMcode += "  %result = call " + mLLVMTypeName + " @llvm." + mIntrinsicName + "." + mLLVMTypeName
  ioLLVMcode += " (" + mLLVMTypeName + " %value)\n"
  ioLLVMcode += "  ret " + mLLVMTypeName + " %result\n"
  ioLLVMcode += "}\n\n"
  ioGenerationAdds.mExternFunctionDeclarationSet +=
    !mLLVMTypeName + " @llvm." + mIntrinsicName + "." + mLLVMTypeName + " (" + mLLVMTypeName + ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: INTEGER ASSIGNMENT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerTypeAssignFunctionIR : @abstractRoutineIR {
  @string mLLVMTypeName
}

#·······················································································································

override method @integerTypeAssignFunctionIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "define internal void @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + mLLVMTypeName + "* %outTarget, " + mLLVMTypeName + "* %inSource) alwaysinline {\n"
  ioLLVMcode += ";--- Compute type size\n"
  ioLLVMcode += "  %sizeAsPtr = getelementptr inbounds " + mLLVMTypeName + ", " + mLLVMTypeName + "* null, i32 1\n"
  ioLLVMcode += "  %byteCount = ptrtoint " + mLLVMTypeName + "* %sizeAsPtr to i32\n"
  ioLLVMcode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
  ioLLVMcode += "  br i1 %useLoadStore, label %loadStore, label %copyWords\n"
  ioLLVMcode += ";--- Copy using load/store\n"
  ioLLVMcode += "loadStore:\n"
  ioLLVMcode += "  %value = load " + mLLVMTypeName + ", " + mLLVMTypeName + "* %inSource\n"
  ioLLVMcode += "  store " + mLLVMTypeName + " %value, " + mLLVMTypeName + "* %outTarget\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += ";--- Copy using copy function\n"
  ioLLVMcode += "copyWords:\n"
  ioLLVMcode += "  %target32 = bitcast " + mLLVMTypeName + "* %outTarget to i32*\n"
  ioLLVMcode += "  %source32 = bitcast " + mLLVMTypeName + "* %inSource to i32*\n"
  ioLLVMcode += "  %temp = add nsw nuw i32 %byteCount, 3\n"
  ioLLVMcode += "  %wordCount = udiv i32 %temp, 4\n"
  ioLLVMcode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
