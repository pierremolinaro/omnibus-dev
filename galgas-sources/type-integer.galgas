#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @integerDeclaration : @abstractDeclaration {
  @bool mIsSigned
  @uint mSize
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @integerDeclaration location -> @location outLocation {
  outLocation = .nowhere
}

#----------------------------------------------------------------------------------------------------------------------*

getter @integerDeclaration typeName -> @string outName {
  outName = if mIsSigned then "int" else "uint" end + mSize
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension plm_target_specific_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $signedIntegerType$
    $integer$ ?let @lbigint lowerBound
    $->$
    $integer$ ?let @lbigint upperBound
    if lowerBound.bigint > upperBound.bigint then
      error upperBound : "upper bound is lower than lower bound"
    elsif upperBound.bigint > 1024G then
      error upperBound : "upper bound is too large (should be <= 1024)"
    else
      for i in [lowerBound.bigint uint] ... [upperBound.bigint uint] do
        ioAST.mDeclarationList += !@integerDeclaration.new {!true !i}
      end
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $unsignedIntegerType$
    $integer$ ?let @lbigint lowerBound
    $->$
    $integer$ ?let @lbigint upperBound
    if lowerBound.bigint > upperBound.bigint then
      error upperBound : "upper bound is lower than lower bound"
    elsif upperBound.bigint > 1024G then
      error upperBound : "upper bound is too large (should be <= 1024)"
    else
      for i in [lowerBound.bigint uint] ... [upperBound.bigint uint] do
        ioAST.mDeclarationList += !@integerDeclaration.new {!false !i}
      end
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @integerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let integerTypeName = [[self typeName] nowhere]
  [!?ioGraph addNode !integerTypeName !self]
  [!?ioGraph addEdge !integerTypeName ![boolTypeName () nowhere]]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @integerDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "integer " + [self typeName] 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @integerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
  let integerTypeName = [[self typeName] nowhere]
#--- Get min and max
  @bigint min
  @bigint max
  if mIsSigned then
    min = - (1G << (mSize - 1))
    max = (1G << (mSize - 1)) - 1G
  else # Unsigned
    min = 0G
    max = (1G << mSize) - 1G
  end
 #---
  [!?ioContext.mTypeMap insertKey
    !lkey:integerTypeName
    !kind:.integer {!min:min !max:max !unsigned:not mIsSigned !bitCount:mSize}
    !constructorMap:{}
    !procedureMap:{}
    !copiable:true
    !equatable:true
    !comparable:true
  ]
#--- Enter integer operators
  enterIntegerOperators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
}

#----------------------------------------------------------------------------------------------------------------------*

private proc enterIntegerOperators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- ++ and -- operators
  [!?ioContext.mIncNoOVFOperatorMap insertKey !inIntegerTypeName !.addNoOVF]
  [!?ioContext.mDecNoOVFOperatorMap insertKey !inIntegerTypeName !.subNoOVF]
  [!?ioContext.mIncOVFOperatorMap insertKey !inIntegerTypeName !if inIsSigned then .saddOVF else .uaddOVF end]
  [!?ioContext.mDecOVFOperatorMap insertKey !inIntegerTypeName !if inIsSigned then .ssubOVF else .usubOVF end]
#--- Infix operators
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !inIntegerTypeName ?let selfTypeProxy]
#--- Comparison infix operator
  [!?ioContext.mEqualOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !ioContext.mBooleanType
    !.icmp_eq
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !ioContext.mBooleanType
    !.icmp_ne
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !ioContext.mBooleanType
    !if inIsSigned then .icmp_slt else .icmp_ult end
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !ioContext.mBooleanType
    !if inIsSigned then .icmp_sle else .icmp_ule end
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !ioContext.mBooleanType
    !if inIsSigned then .icmp_sgt else .icmp_ugt end
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !ioContext.mBooleanType
    !if inIsSigned then .icmp_sge else .icmp_uge end
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
      !selfTypeProxy
      !.and
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
      !selfTypeProxy
      !.ior
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
      !selfTypeProxy
      !.xor
    ]
    [!?ioContext.mUnsignedComplementOperatorMap insertKey
      !inIntegerTypeName
      !selfTypeProxy
    ]
  end
#--- Negate operator (for signed integers)
  if inIsSigned then
    [!?ioContext.mUnaryMinusOperatorMap insertKey
      !inIntegerTypeName
      !selfTypeProxy
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .saddOVF else .uaddOVF end
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !.addNoOVF
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .ssubOVF else .usubOVF end
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !.subNoOVF
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .smulOVF else .umulOVF end
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !.mulNoOVF
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .sdivOVF else .udivOVF end
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .sdivNoOVF else .udivNoOVF end
  ]
  [!?ioContext.mModOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .sremOVF else .uremOVF end
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !.shl
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !.new {!inIntegerTypeName.string + "." + inIntegerTypeName !inIntegerTypeName.location}
    !selfTypeProxy
    !if inIsSigned then .ashr else .lshr end
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @integerDeclaration initAnalysis ?!context:@semanticContext unused ioContext { }

#----------------------------------------------------------------------------------------------------------------------*

override method @integerDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @integerIR : @abstractTypeIR {
  @string mIntegerTypeName
  @string mActualTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

private filewrapper integerGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "integer-declaration.galgasTemplate"
    ?@string INTEGER_TYPE_NAME
    ?@string ACTUAL_TYPE_NAME
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @integerIR headerCodeGenerationForType -> @string outCode {
  outCode = [filewrapper integerGenerationTemplate.declaration
    !mIntegerTypeName
    !mActualTypeName
  ]
}

#----------------------------------------------------------------------------------------------------------------------*



