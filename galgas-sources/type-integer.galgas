#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerDeclarationAST : @abstractDeclarationAST {
  @bool mIsSigned
  @uint mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @integerDeclarationAST typeName -> @string outName {
  outName = if mIsSigned then "$int" else "$uint" end + mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let integerTypeName = [[self typeName] nowhere]
  [!?ioGraph addNode !integerTypeName !self]
  [!?ioGraph addEdge !integerTypeName ![staticIntegerTypeName () nowhere]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "integer " + [self typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  UTILITIES                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func minValueForInteger ?let @bool inIsUnsigned ?let @uint inBitCount -> @bigint {
  if inIsUnsigned then
    result = 0G
  else # Signed
    result = - (1G << (inBitCount - 1))
  end
}

#·······················································································································

func maxValueForInteger ?let @bool inIsUnsigned ?let @uint inBitCount -> @bigint {
  if inIsUnsigned then
    result = (1G << inBitCount) - 1G
  else # Signed
    result = (1G << (inBitCount - 1)) - 1G
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
  let integerTypeName = [[self typeName] nowhere]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !integerTypeName ?let selfTypeProxy]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !.new {!boolTypeName () !.nowhere} ?let boolTypeProxy]
#--------------------------------------- Get min and max
  let min = minValueForInteger (!not mIsSigned !mSize)
  let max = maxValueForInteger (!not mIsSigned !mSize)
#--------------------------------------- Property map
  let llvmTypeName = "i" + mSize
  @routineMapCTXT routineMap = {}
  @propertyGetterMap propertyGetterMap = {}
#--------------------------------------- byteSwapped
  if (mSize mod 16) == 0 then
    [!?propertyGetterMap addPropertyGetter
      !llvmBaseTypeName:integerTypeName
      !propertyName:["byteSwapped" nowhere]
      !mode:.anySafeMode
      !public: true
      !resultTypeProxy:selfTypeProxy
      ?routineLLVMName: let routineLLVMName
    ]
    ioRoutineListIR += !@integerBuiltinFunctionIR.new {
      !routineLLVMName
      !isRequired:false
      !warnsIfUnused:false
      !llvmTypeName
      !"bswap"
    }
  end
#--------------------------------------- bool for $uint1
  if mSize == 1 && not mIsSigned then # Add "bool" intrinsic function
    [!?propertyGetterMap addPropertyGetter
      !llvmBaseTypeName:integerTypeName
      !propertyName:[boolTypeName () nowhere]
      !mode:.anySafeMode
      !public: true
      !resultTypeProxy:boolTypeProxy
      ?routineLLVMName: let routineLLVMName
    ]
    ioRoutineListIR += !@uint1ToBoolFunctionIR.new {
      !routineLLVMName
      !isRequired:false
      !warnsIfUnused:false
      !llvmTypeName
    }
  end
#--------------------------------------- bitreverse
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["bitReversed" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: var routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"bitreverse"
  }
#--------------------------------------- leadingZeroCount
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["leadingZeroCount" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"ctlz"
  }
#--------------------------------------- trainingZeroCount
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["trainingZeroCount" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"cttz"
  }
#--------------------------------------- setBitCountMethodName
  [!?propertyGetterMap addPropertyGetter
    !llvmBaseTypeName:integerTypeName
    !propertyName:["setBitCount" nowhere]
    !mode:.anySafeMode
    !public: true
    !resultTypeProxy:selfTypeProxy
    ?routineLLVMName: routineLLVMName
  ]
  ioRoutineListIR += !@integerBuiltinFunctionIR.new {
    !routineLLVMName
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
    !"ctpop"
  }
#--------------------------------------- Class constant map
  @classConstantMap classConstantMap = {}
  [!?classConstantMap insertKey !["min" nowhere] !min !integerTypeName]
  [!?classConstantMap insertKey !["max" nowhere] !max !integerTypeName]
#--------------------------------------- Constructor map
  @constructorMap constructorMap = {} 
  [!?constructorMap insertKey !["()" nowhere] !{} !.simple {!value:0}]
#--------------------------------------- Enter in type map
  let integerType = @PLMType.new {
    !propertyGetterMap:propertyGetterMap
    !propertySetterMap: {}
    !routineMap: routineMap
    !classConstantMap:classConstantMap
    !constructorMap:constructorMap
    !guardMap:{}
    !subscript:.noSubscript
    !assignmentSources: {!integerTypeName}
    !attributes:.instanciable | .equatable | .copyable | .comparable
    !plmTypeDescriptionName:integerTypeName
    !kind:.integer {!min:min !max:max !unsigned:not mIsSigned !bitCount:mSize}
    !llvmBaseTypeName:integerTypeName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:integerTypeName
    !type:integerType
  ]
#--------------------------------------- Enter integer <-> integer operators
  enter_integer_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--------------------------------------- Enter integer <-> literal operators
  enter_integer_literal_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--------------------------------------- Enter literal <-> integer operators
  enter_literal_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#---------- Enter integer assignment function
  ioRoutineListIR += !@integerTypeAssignFunctionIR.new {
    ![assignmentPrefix () + integerTypeName + "." + integerTypeName nowhere]
    !isRequired:false
    !warnsIfUnused:false
    !llvmTypeName
  }
#---------- Enter Cpp Type Generation
#  ioDecoratedDeclarationList += !@integerDecoratedDeclarationAST.new {!integerTypeName !mSize !mIsSigned}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#class @integerDecoratedDeclarationAST : @abstractDecoratedDeclaration {
#  @string mPLMTypeName
#  @uint mSize
#  @bool mIsSigned
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @integerDecoratedDeclarationAST semanticAnalysis
#  ?context:let @semanticContext unused inContext
#  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
#  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
#{
#  ioIntermediateCodeStruct.mTypeCppGenerationList += !@IntegerTypeCppGeneration.new {!mPLMTypeName !mSize !mIsSigned}
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN INTEGERS object <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
  let booleanType = [ioContext booleanType]
#--- Comparison infix operator
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName !inIntegerTypeName)
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !booleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intIntOp
      !selfType
      !@infixObjectObjectOperatorDescription.new {!.xor}
    ]
    [!?ioContext.mUnsignedComplementOperatorMap insertKey
      !inIntegerTypeName
    ]
  end
#--- Negate operator (for signed integers)
  if inIsSigned then
    [!?ioContext.mUnaryMinusOperatorMap insertKey
      !inIntegerTypeName
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @infixObjectObjectOperatorDescription : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixObjectObjectOperatorDescription generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
  if [inLeftOperand isLiteralInteger] && [inRightOperand isLiteralInteger] then
    [inLeftOperand  literalInteger ?1* ?value:let @bigint left]
    [inRightOperand literalInteger ?1* ?value:let @bigint right]
    let resultValue = [self performStaticOperation !left !right]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inLeftOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN AN INTEGER AND A LITERAL INTEGER object <-> literal integer
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_literal_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
  let booleanType = [ioContext booleanType]
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !staticIntegerTypeName ())
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!.icmp_eq}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@integerObject_literal_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerObject_literal_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerObject_literal_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#--- Check right literal integer can be extented to left integer type, ans is not zero
  [inRightOperand literalInteger ?1* ?value:let @bigint rightLiteralValue]
  [[inLeftOperand type].kind integer ?min:let @bigint min ?max:let @bigint max ?2*]
  if rightLiteralValue < min then
    error inOperatorLocation : "literal right integer expression too small (should be >= " + min + ")" : outResult
  elsif rightLiteralValue > max then
    error inOperatorLocation : "literal right integer expression too large (should be <= " + max + ")" : outResult
  elsif [inLeftOperand isLiteralInteger] then
    [inLeftOperand literalInteger ?1* ?value:let @bigint leftLiteralValue]
    let resultValue = [self performStaticOperation !leftLiteralValue !rightLiteralValue]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inLeftOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INFIX OPERATION BETWEEN A LITERAL INTEGER AND AN INTEGER literal integer <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_literal_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName} type]
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!staticIntegerTypeName () !inIntegerTypeName.string)
  let booleanType = [ioContext booleanType]
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!.icmp_eq}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !booleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfType
      !@literal_integerObject_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_integerObject_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_integerObject_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
#--- Check left literal integer can be extended to right integer type
  [inLeftOperand literalInteger ?1* ?value:let @bigint leftLiteralValue]
  [[inRightOperand type].kind integer ?min:let @bigint min ?max:let @bigint max ?2*]
  if leftLiteralValue < min then
    error inOperatorLocation : "literal left integer expression too small (should be >= " + min + ")" : outResult
  elsif leftLiteralValue > max then
    error inOperatorLocation : "literal left integer expression too large (should be <= " + max + ")" : outResult
  elsif [inRightOperand isLiteralInteger] then
    [inRightOperand literalInteger ?1* ?value:let @bigint rightLiteralValue]
    let resultValue = [self performStaticOperation !leftLiteralValue !rightLiteralValue]
    outResult = .literalInteger {!type: inResultType !value:resultValue}
  else
    getNewTempValue (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![inRightOperand type]
      !inOperatorLocation
      !inLeftOperand
      !mOperator
      !inRightOperand
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: UINT1 TO BOOL FUNCTION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @uint1ToBoolFunctionIR : @abstractRoutineIR {
  @string mLLVMTypeName
}

#·······················································································································

override method @uint1ToBoolFunctionIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "define internal " + mLLVMTypeName + " @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + mLLVMTypeName + "* %inValue) {\n"
  ioLLVMcode += "  %value = load " + mLLVMTypeName + ", " + mLLVMTypeName + "* %inValue\n"
  ioLLVMcode += "  ret i1 %value\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: BUILTIN FUNCTIONS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerBuiltinFunctionIR : @abstractRoutineIR {
  @string mLLVMTypeName
  @string mIntrinsicName
}

#·······················································································································

override method @integerBuiltinFunctionIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += "define internal " + mLLVMTypeName + " @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + mLLVMTypeName + "* %inValue) {\n"
  ioLLVMcode += "  %value = load " + mLLVMTypeName + ", " + mLLVMTypeName + "* %inValue\n"
  ioLLVMcode += "  %result = call " + mLLVMTypeName + " @llvm." + mIntrinsicName + "." + mLLVMTypeName
  ioLLVMcode += " (" + mLLVMTypeName + " %value)\n"
  ioLLVMcode += "  ret " + mLLVMTypeName + " %result\n"
  ioLLVMcode += "}\n\n"
  ioGenerationAdds.mExternFunctionDeclarationSet +=
    !mLLVMTypeName + " @llvm." + mIntrinsicName + "." + mLLVMTypeName + " (" + mLLVMTypeName + ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION: INTEGER ASSIGNMENT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerTypeAssignFunctionIR : @abstractRoutineIR {
  @string mLLVMTypeName
}

#·······················································································································

override method @integerTypeAssignFunctionIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "define internal void @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + mLLVMTypeName + "* %outTarget, " + mLLVMTypeName + "* %inSource) alwaysinline {\n"
  ioLLVMcode += ";--- Compute type size\n"
  ioLLVMcode += "  %sizeAsPtr = getelementptr inbounds " + mLLVMTypeName + ", " + mLLVMTypeName + "* null, i32 1\n"
  ioLLVMcode += "  %byteCount = ptrtoint " + mLLVMTypeName + "* %sizeAsPtr to i32\n"
  ioLLVMcode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
  ioLLVMcode += "  br i1 %useLoadStore, label %loadStore, label %copyWords\n"
  ioLLVMcode += ";--- Copy using load/store\n"
  ioLLVMcode += "loadStore:\n"
  ioLLVMcode += "  %value = load " + mLLVMTypeName + ", " + mLLVMTypeName + "* %inSource\n"
  ioLLVMcode += "  store " + mLLVMTypeName + " %value, " + mLLVMTypeName + "* %outTarget\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += ";--- Copy using copy function\n"
  ioLLVMcode += "copyWords:\n"
  ioLLVMcode += "  %target32 = bitcast " + mLLVMTypeName + "* %outTarget to i32*\n"
  ioLLVMcode += "  %source32 = bitcast " + mLLVMTypeName + "* %inSource to i32*\n"
  ioLLVMcode += "  %temp = add nsw nuw i32 %byteCount, 3\n"
  ioLLVMcode += "  %wordCount = udiv i32 %temp, 4\n"
  ioLLVMcode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! C++ CODE GENERATION: INTEGER TYPE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#class @IntegerTypeCppGeneration : @typeCppGeneration {
#  @uint mSize
#  @bool mIsSigned
#}

#·······················································································································

#private func generateIntegerArithmeticOperation
#  ?let @string inPrefix
#  ?let @string inOperator
#  ?let @string inCppTypeName
#  ?let @bool inIsSigned
#  ?let @uint inSize -> @string
#{
#  result  = cppSeparatorLine () + "\n"
#  result += "static " + inCppTypeName + " " + inPrefix + inCppTypeName + " (const " + inCppTypeName + " inA, const " + inCppTypeName + " inB) __attribute__ ((used)) ;\n"
#  result += "static " + inCppTypeName + " " + inPrefix + inCppTypeName + " (const " + inCppTypeName + " inA, const " + inCppTypeName + " inB) {\n"
#  result += "  " + inCppTypeName + " r = inA " + inOperator + " inB ;\n"
#  if (inSize != 8) & (inSize != 16) & (inSize != 32) & (inSize != 64) then
#    if not inIsSigned then
#      result += "  r &= " + [(1G << inSize) - 1G string] + " ;\n"
#    elsif inSize < 8 then
#      result += "  r <<= " + [8 - inSize string] + " ;\n"
#      result += "  r >>= " + [8 - inSize string] + " ;\n"
#    elsif inSize < 16 then
#      result += "  r <<= " + [16 - inSize string] + " ;\n"
#      result += "  r >>= " + [16 - inSize string] + " ;\n"
#    elsif inSize < 32 then
#      result += "  r <<= " + [32 - inSize string] + " ;\n"
#      result += "  r >>= " + [32 - inSize string] + " ;\n"
#    elsif inSize < 64 then
#      result += "  r <<= " + [64 - inSize string] + " ;\n"
#      result += "  r >>= " + [64 - inSize string] + " ;\n"
#    end
#  end
#  result += "  return r ;\n"
#  result += "}\n\n"
#}

#·······················································································································

#private func generateIntegerLogicalOperation
#  ?let @string inPrefix
#  ?let @string inOperator
#  ?let @string inCppTypeName -> @string
#{
#  result  = cppSeparatorLine () + "\n"
#  result += "static " + inCppTypeName + " " + inPrefix + inCppTypeName + " (const " + inCppTypeName + " inA, const " + inCppTypeName + " inB) __attribute__ ((used)) ;\n"
#  result += "static " + inCppTypeName + " " + inPrefix + inCppTypeName + " (const " + inCppTypeName + " inA, const " + inCppTypeName + " inB) {\n"
#  result += "  return inA " + inOperator + " inB ;\n"
#  result += "}\n\n"
#}

#·······················································································································

#override method @IntegerTypeCppGeneration generateTypeCppCode ?!@string ioCppCode {
#  ioCppCode += cppSeparatorLine ()
#  ioCppCode += "// Integer Type: " + mPLMTypeName + "\n"
#  ioCppCode += cppSeparatorLine () + "\n"
#  let cppTypeName = "$" + if mIsSigned then "s" else "u" end + "int" + mSize
#  var cppSupportType = if mIsSigned then "int" else "uint" end
#  if mSize <= 8 then
#    cppSupportType += "8"
#  elsif mSize <= 16 then
#    cppSupportType += "16"
#  elsif mSize <= 32 then
#    cppSupportType += "32"
#  else
#    cppSupportType += "64"
#  end
#  cppSupportType += "_t"
#  ioCppCode += "typedef " + cppSupportType + " " + cppTypeName + " ;\n\n"
#  ioCppCode += generateIntegerArithmeticOperation (!"add" !"+" !cppTypeName !mIsSigned !mSize)
#  ioCppCode += generateIntegerArithmeticOperation (!"sub" !"-" !cppTypeName !mIsSigned !mSize)
#  ioCppCode += generateIntegerArithmeticOperation (!"mul" !"*" !cppTypeName !mIsSigned !mSize)
#  ioCppCode += generateIntegerArithmeticOperation (!"div" !"/" !cppTypeName !mIsSigned !mSize)
#  ioCppCode += generateIntegerArithmeticOperation (!"mod" !"%" !cppTypeName !mIsSigned !mSize)
#  ioCppCode += generateIntegerLogicalOperation (!"or" !"|" !cppTypeName)
#  ioCppCode += generateIntegerLogicalOperation (!"and" !"&" !cppTypeName)
#  ioCppCode += generateIntegerLogicalOperation (!"xor" !"^" !cppTypeName)
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
