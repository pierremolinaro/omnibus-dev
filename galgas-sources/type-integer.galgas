#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerDeclaration : @abstractDeclaration {
  @bool mIsSigned
  @uint mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclaration location -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @integerDeclaration typeName -> @string outName {
  outName = if mIsSigned then "int" else "uint" end + mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let integerTypeName = ["$" + [self typeName] nowhere]
  [!?ioGraph addNode !integerTypeName !self]
  [!?ioGraph addEdge !integerTypeName !["$" + staticIntegerTypeName () nowhere]]
#--- An edge to $bool is useless, as static integer type has an edge to $bool
#  [!?ioGraph addEdge !integerTypeName !["$" + boolTypeName () nowhere]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @integerDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "integer $" + [self typeName] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  let integerTypeName = [[self typeName] nowhere]
#--- Get min and max
  @bigint min
  @bigint max
  if mIsSigned then
    min = - (1G << (mSize - 1))
    max = (1G << (mSize - 1)) - 1G
  else # Unsigned
    min = 0G
    max = (1G << mSize) - 1G
  end
 #---
  [!?ioContext.mTypeMap insertKey
    !lkey:integerTypeName
    !llvmTypeName:"i" + mSize
    !kind:.integer {!min:min !max:max !unsigned:not mIsSigned !bitCount:mSize}
    !typedConstantMap:{}
    !procedureMap:{}
    !functionMap:{}
    !copiable:true
    !equatable:true
    !comparable:true
    !enumerationType:.null # Not enumerable
  ]
#--- Enter integer <-> integer operators
  enter_integer_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--- Enter integer <-> literal operators
  enter_integer_literal_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
#--- Enter literal <-> integer operators
  enter_literal_integer_operators (
    !integerTypeName:integerTypeName
    !signed:mIsSigned
    !?context:ioContext
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INFIX OPERATION BETWEEN INTEGERS                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! object <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
  let selfTypeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName}
#--- Comparison infix operator
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !inIntegerTypeName.string)
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intIntOp
      !selfTypeProxy
      !@infixObjectObjectOperatorDescription.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intIntOp
      !selfTypeProxy
      !@infixObjectObjectOperatorDescription.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intIntOp
      !selfTypeProxy
      !@infixObjectObjectOperatorDescription.new {!.xor}
    ]
    [!?ioContext.mUnsignedComplementOperatorMap insertKey
      !inIntegerTypeName
#      !selfTypeProxy
    ]
  end
#--- Negate operator (for signed integers)
  if inIsSigned then
    [!?ioContext.mUnaryMinusOperatorMap insertKey
      !inIntegerTypeName
#      !selfTypeProxy
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixObjectObjectOperatorDescription.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @infixObjectObjectOperatorDescription : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixObjectObjectOperatorDescription generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @operandIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@operandIR outResult
{
  if [inLeftOperand.mValue isLiteralInteger] && [inRightOperand.mValue isLiteralInteger] then
    [inLeftOperand.mValue  literalInteger ?value:let @bigint left]
    [inRightOperand.mValue literalInteger ?value:let @bigint right]
    let resultValue = [self performStaticOperation !left !right]
    outResult = .new {!inResultType !.literalInteger {!value:resultValue}}
  else
    getNewTempVariable (!inResultType !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult.mValue
      !inLeftOperand.mType
      !inOperatorLocation
      !inLeftOperand.mValue
      !mOperator
      !inRightOperand.mValue
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INFIX OPERATION BETWEEN AN INTEGER AND A LITERAL INTEGER                                                            *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! object <-> literal integer
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_integer_literal_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfTypeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName}
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !staticIntegerTypeName ())
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@integerObject_literal_infixOperator.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@integerObject_literal_infixOperator.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfTypeProxy
      !@integerObject_literal_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfTypeProxy
      !@integerObject_literal_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfTypeProxy
      !@integerObject_literal_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@integerObject_literal_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerObject_literal_infixOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerObject_literal_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @operandIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@operandIR outResult
{
#--- Check right literal integer can be extented to left integer type, ans is not zero
  [inRightOperand.mValue literalInteger ?value:let @bigint literalValue]
  [[inLeftOperand.mType kind] integer ?min:let @bigint min ?max:let @bigint max ?unsigned:* ?bitCount:*]
  if literalValue < min then
    error inOperatorLocation : "literal right integer expression too small (should be >= " + min + ")" : outResult
  elsif literalValue > max then
    error inOperatorLocation : "literal right integer expression too large (should be <= " + max + ")" : outResult
  else
    getNewTempVariable (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult.mValue
      !inLeftOperand.mType
      !inOperatorLocation
      !inLeftOperand.mValue
      !mOperator
      !inRightOperand.mValue
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @integerObject_literal_divisionOperator : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerObject_literal_divisionOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @operandIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@operandIR outResult
{
#--- Check right literal integer can be extented to left integer type
  [inRightOperand.mValue literalInteger ?value:let @bigint literalValue]
  [[inLeftOperand.mType kind] integer ?min:let @bigint min ?max:let @bigint max ?unsigned:* ?bitCount:*]
  if literalValue < min then
    error inOperatorLocation : "literal right integer expression too small (should be >= " + min + ")" : outResult
  elsif literalValue > max then
    error inOperatorLocation : "literal right integer expression too large (should be <= " + max + ")" : outResult
  elsif literalValue == 0G then
    error inOperatorLocation : "division by zero" : outResult
  else
    getNewTempVariable (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult.mValue
      !inLeftOperand.mType
      !inOperatorLocation
      !inLeftOperand.mValue
      !mOperator
      !inRightOperand.mValue
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INFIX OPERATION BETWEEN A LITERAL INTEGER AND AN INTEGER                                                            *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! literal integer <-> object
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enter_literal_integer_operators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?signed:let @bool inIsSigned
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let selfTypeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName}
#--- Comparison infix operator
  let intLiteralOp = combineTypeNamesForInfixOperator (!staticIntegerTypeName () !inIntegerTypeName.string)
  [!?ioContext.mEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@literal_integerObject_infixOperator.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@literal_integerObject_infixOperator.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_slt else .icmp_ult end}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sle else .icmp_ule end}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sgt else .icmp_ugt end}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intLiteralOp
    !ioContext.mBooleanType
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .icmp_sge else .icmp_uge end}
  ]
#--- Bit Wise operators (for unsigned integers)
  if not inIsSigned then
    [!?ioContext.mAndOperatorMap insertKey
      !intLiteralOp
      !selfTypeProxy
      !@literal_integerObject_infixOperator.new {!.and}
    ]
    [!?ioContext.mOrOperatorMap insertKey
      !intLiteralOp
      !selfTypeProxy
      !@literal_integerObject_infixOperator.new {!.ior}
    ]
    [!?ioContext.mXorOperatorMap insertKey
      !intLiteralOp
      !selfTypeProxy
      !@literal_integerObject_infixOperator.new {!.xor}
    ]
  end
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .saddOVF else .uaddOVF end}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ssubOVF else .usubOVF end}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .smulOVF else .umulOVF end}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivOVF else .udivOVF end}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sdivNoOVF else .udivNoOVF end}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremOVF else .uremOVF end}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .sremNoOVF else .uremNoOVF end}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intLiteralOp
    !selfTypeProxy
    !@literal_integerObject_infixOperator.new {!if inIsSigned then .ashr else .lshr end}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_integerObject_infixOperator : @infixOperatorDescription {
#  @llvmBinaryOperation mOperator
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_integerObject_infixOperator generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @operandIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@operandIR outResult
{
#--- Check left literal integer can be extented to right integer type
  [inLeftOperand.mValue literalInteger ?value:let @bigint literalValue]
  [[inRightOperand.mType kind] integer ?min:let @bigint min ?max:let @bigint max ?unsigned:* ?bitCount:*]
  if literalValue < min then
    error inOperatorLocation : "literal left integer expression too small (should be >= " + min + ")" : outResult
  elsif literalValue > max then
    error inOperatorLocation : "literal left integer expression too large (should be <= " + max + ")" : outResult
  else
    getNewTempVariable (!inResultType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult.mValue
      !inRightOperand.mType
      !inOperatorLocation
      !inLeftOperand.mValue
      !mOperator
      !inRightOperand.mValue
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
