
setter @instructionListIR appendStoreGlobalVariable
  ?let @string inGlobalVarName
  ?let @unifiedTypeMap-proxy inTargetVarType
  ?let @objectIR inSourceValue
  ?volatile:let @bool inIsVolatile
{
  self += !@storeGlobalVariableIR.new {!inGlobalVarName !inTargetVarType !inSourceValue !inIsVolatile}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @storeGlobalVariableIR : @abstractInstructionIR {
  @string mGlobalVarName
  @unifiedTypeMap-proxy mTargetVarType
  @objectIR mSourceValue
  @bool mIsVolatile
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @storeGlobalVariableIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [mTargetVarType llvmTypeName]
  ioLLVMcode += "  store "
  if mIsVolatile then
    ioLLVMcode += "volatile "
  end
  ioLLVMcode += llvmType + " " + [mSourceValue llvmName] + ", " + llvmType + " * @" + llvmNameForGlobalVariable (!mGlobalVarName) + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @storeGlobalVariableIR enterAccessibleEntities 
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioAccessibleEntities.mGlobalVariableSet += !mGlobalVarName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
