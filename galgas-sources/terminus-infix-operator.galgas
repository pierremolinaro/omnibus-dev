#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @infixOperatorEnumeration {
 case equal           # ==
 case strictInf       # <

 case booleanOr       # or
 case booleanXor      # xor

 case bitWiseAnd      # &
 case bitWiseOr       # |
 case xor             # ^

 case add             # +
# case sub             # -
 case mul             # *
 case div             # /
 case modulo          # mod

 case divNoOvf        # &/
 case moduloNoOvf     # &%
 case leftShift       # <<
 case rightShift      # >>
}

#·······················································································································

getter @infixOperatorEnumeration string -> @string {
 switch self
 case equal     : result = "=="
 case strictInf : result = "<"
 case booleanOr  : result = "or"
 case bitWiseAnd : result = "&"
 case bitWiseOr : result = "|"
 case xor       : result = "^"
 case booleanXor: result = "xor"
 case add       : result = "+"
 case mul       : result = "*"
 case div       : result = "/"
 case divNoOvf  : result = "!&"
 case modulo    : result = "%"
 case moduloNoOvf: result = "!%"
 case leftShift  : result = "<<"
 case rightShift : result = ">>"
 end
}

#·······················································································································

class @compileTimeInfixOperatorAST : @abstractDeclarationAST {
  @infixOperatorEnumeration mInfixOperator
  @location mInfixOperatorLocation
  @lstring mLeftOperandName
  @lstring mLeftTypeName
  @lstring mRightOperandName
  @lstring mRightTypeName
  @ctExpressionAST mExpression
  @lstring mResultTypeName
}

#·······················································································································

override getter @compileTimeInfixOperatorAST locationForErrorSignaling -> @location outLocation {
  outLocation = mInfixOperatorLocation
}

#·······················································································································

class @llvmInfixOperatorAST : @abstractDeclarationAST {
  @infixOperatorEnumeration mInfixOperator
  @location mInfixOperatorLocation
  @lstring mLeftOperandName
  @lstring mLeftTypeName
  @genericFormalParameterList mLeftGenericFormalParameterList
  @lstring mRightOperandName
  @lstring mRightTypeName
  @genericFormalParameterList mRightGenericFormalParameterList
 # @ctExpressionAST mWhereExpression
  @lstring mResultTypeName
  @genericFormalParameterList mResultGenericFormalParameterList # À modifier
  @llvmGenerationInstructionList mInstructionList
}

#·······················································································································

override getter @llvmInfixOperatorAST locationForErrorSignaling -> @location outLocation {
  outLocation = mInfixOperatorLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <infixOperator> !@infixOperatorEnumeration outOperator {
    select
      $==$
      outOperator = .equal
    or
      $<$
      outOperator = .strictInf
    or
      $or$
      outOperator = .booleanOr
    or
      $&$
      outOperator = .bitWiseAnd
    or
      $|$
      outOperator = .bitWiseOr
    or
      $^$
      outOperator = .xor
    or
      $xor$
      outOperator = .booleanXor
    or
      $+$
      outOperator = .add
    or
      $*$
      outOperator = .mul
    or
      $/$
      outOperator = .div
    or
      $!/$
      outOperator = .divNoOvf
    or
      $%$
      outOperator = .modulo
    or
      $!%$
      outOperator = .moduloNoOvf
    or
      $<<$
      outOperator = .leftShift
    or
      $>>$
      outOperator = .rightShift
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $compiletime$
    $func$
    $($
    $identifier$ ?let leftArgument
    $\$type$ ?let leftType
    $)$
    let operationLocation = @location.here
    <infixOperator> ?let infixOperator
    $($
    $identifier$ ?let rightArgument
    $\$type$ ?let rightType
    $)$
    $->$
    $\$type$ ?let resultType
    ${$
    <compile_time_expression> ?let @ctExpressionAST expression
    $}$
    ioAST.mDeclarationListAST += !@compileTimeInfixOperatorAST.new {
      !infixOperator
      !operationLocation
      !leftArgument
      !leftType
      !rightArgument
      !rightType
      !expression
      !resultType
    }
  }

 #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <llvm_function_header> ?let leftVariableName ?let leftTypeName ?let leftGenericFormalParameterList
    let operationLocation = @location.here
    <infixOperator> ?let infixOperator
    $($
    $identifier$ ?let rightVariableName
    $\$type$ ?let rightType
    <generic_formal_arguments> ?let rightGenericFormalParameterList
    $)$
    $->$
    $\$type$ ?let resultType
    <generic_formal_arguments> ?let resultGenericFormalParameterList
    ${$
    <llvm_instruction_list> ?let instructionList
    $}$
    ioAST.mDeclarationListAST += !@llvmInfixOperatorAST.new {
      !infixOperator
      !operationLocation
      !leftVariableName
      !leftTypeName
      !leftGenericFormalParameterList
      !rightVariableName
      !rightType
      !rightGenericFormalParameterList
      !resultType
      !resultGenericFormalParameterList
      !instructionList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compileTimeInfixOperatorAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = @lstring.new {![mInfixOperator string] + "." + mLeftTypeName + "." + mRightTypeName !mInfixOperatorLocation}
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName !mLeftTypeName]
  [!?ioGraph addEdge !nodeName !mRightTypeName]
  [!?ioGraph addEdge !nodeName !mResultTypeName]
}

#·······················································································································

override getter @compileTimeInfixOperatorAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = mLeftTypeName.string + " " + mInfixOperator + " " + mRightTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @llvmInfixOperatorAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = @lstring.new {![mInfixOperator string] + "." + mLeftTypeName + "." + mRightTypeName !mInfixOperatorLocation}
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName !mLeftTypeName]
  [!?ioGraph addEdge !nodeName !mRightTypeName]
  [!?ioGraph addEdge !nodeName !mResultTypeName]
}

#·······················································································································

override getter @llvmInfixOperatorAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = mLeftTypeName.string + " " + mInfixOperator + " " + mRightTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compileTimeInfixOperatorAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Check types
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mLeftTypeName ?let leftType]
  [[leftType type] checkIsCompileTimeType !mLeftTypeName.location]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mRightTypeName ?let rightType]
  [[rightType type] checkIsCompileTimeType !mRightTypeName.location]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mResultTypeName ?let resultType]
  [[resultType type] checkIsCompileTimeType !mResultTypeName.location]
#--- Check native operator expression
  @ctCheckMap ctCheckMap = {}
  [!?ctCheckMap insertKey !mLeftOperandName]
  [!?ctCheckMap insertKey !mRightOperandName]
  [mExpression checkCompileTimeExpression !ctCheckMap]
#--- Enter in infix operator map  
  let key = @lstring.new {
    ![[leftType type] omnibusTypeDescriptionName] + " " + mInfixOperator + " " + [[rightType type] omnibusTypeDescriptionName]
    !mInfixOperatorLocation
  }
  let definition = @compileTimeInfixOperator.new {
    !mInfixOperatorLocation
    !mLeftOperandName
    !mRightOperandName
    !mExpression
  }
  [!?ioContext.mTerminusInfixOperatorMap insertKey !key ![leftType type] ![rightType type] ![resultType type] !definition]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @llvmInfixOperatorAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Check types
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mLeftTypeName ?let leftTypeProxy]
  let leftType = [leftTypeProxy type]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mRightTypeName ?let rightTypeProxy]
  let rightType = [rightTypeProxy type]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mResultTypeName ?let resultTypeProxy]
  let resultType = [resultTypeProxy type]
  if [leftType isCompileTimeType] & [rightType isCompileTimeType] then
    error mInfixOperatorLocation : "one of the two argument types should not be a compile time type"
  end
  [resultType checkIsNotCompileTimeType !mResultTypeName.location]
#--- Enter in infix operator map  
  let key = @lstring.new {
    ![leftType omnibusTypeDescriptionName] + " " + mInfixOperator + " " + [rightType omnibusTypeDescriptionName]
    !mInfixOperatorLocation
  }
  let definition = @llvmInfixOperator.new {
    !mInfixOperatorLocation
    !mLeftOperandName
    !mRightOperandName
    !mInstructionList
  }
  [!?ioContext.mTerminusInfixOperatorMap insertKey !key !leftType !rightType !resultType !definition]
#--- Generate function
  if not [leftType isCompileTimeType] & not [rightType isCompileTimeType] then
    @assignmentGenerationVarMap varMap = {}
    [!?varMap insertKey !mLeftOperandName !"%" + mLeftOperandName]
    [!?varMap insertKey !mRightOperandName !"%" + mRightOperandName]
    @assignmentGenerationVarMap typeMap = {}
    if not [leftType isCompileTimeType] then
      [!?typeMap insertKey !mLeftOperandName ![leftType llvmTypeName]]
    end
    if not [rightType isCompileTimeType] then
      [!?typeMap insertKey !mRightOperandName ![rightType llvmTypeName]]
    end
    [!?typeMap insertKey !["result" nowhere] ![resultType llvmTypeName]]
    @llvmGenerationInstructionList instructionList = {}
    instructionList += !@llvmVarInstruction.new {!["result" nowhere]}
    instructionList += mInstructionList
    [!?instructionList appendReturn !["result" nowhere] !["result" nowhere]]
    @stringlist generatedInstructions = {}
    @allocaList allocaList = {}
    @uint temporaryIndex = 0
    [instructionList generateIRCode !varMap !typeMap !?generatedInstructions !?temporaryIndex !?allocaList]
    let routine = @infixOperatorRoutineIR.new {
      !.new {!infixOperatorFunctionName (!leftType !mInfixOperator !rightType) !mInfixOperatorLocation}
      !isRequired: true
      !warnsIfUnused: false
      !leftType
      !mLeftOperandName.string
      !rightType
      !mRightOperandName.string
      !resultType
      !generatedInstructions
      !allocaList
    }
    ioRoutineListIR += !routine
  else # One argument is a compile time type
  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   INFIX OPERATOR MAP
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @infixOperatorMap {
  @omnibusType mLeftType
  @omnibusType mRightType
  @omnibusType mResultType
  @terminusInfixOperator mOperator
  insert insertKey error message "the '%K' infix operator is already declared in %L"
  search searchKey error message "there is no '%K' infix operator"
}

#·······················································································································

abstract class @terminusInfixOperator {}

#·······················································································································

class @compileTimeInfixOperator : @terminusInfixOperator {
  @location mInfixOperatorLocation
  @lstring mLeftOperandName
  @lstring mRightOperandName
  @ctExpressionAST mExpression
}

#·······················································································································

class @llvmInfixOperator : @terminusInfixOperator {
  @location mInfixOperatorLocation
  @lstring mLeftOperandName
  @lstring mRightOperandName
  @llvmGenerationInstructionList mInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @infixOperatorRoutineIR : @abstractRoutineIR {
  @omnibusType mTargetType
  @string mTargetVarName
  @omnibusType mSourceType
  @string mSourceVarName
  @omnibusType mResultType
  @stringlist mGeneratedInstructions
  @allocaList mAllocaList
}

#·······················································································································

override method @infixOperatorRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "define internal " + [mResultType llvmTypeName] + " @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + [mTargetType llvmTypeName] + " %" + mTargetVarName
             + ", " + [mSourceType llvmTypeName] + " %" + mSourceVarName + ") nounwind {\n"
  [mAllocaList generateAllocaList !?ioLLVMcode]
  for (instruction) in mGeneratedInstructions do
    ioLLVMcode += "  " + instruction + "\n"
  end
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

