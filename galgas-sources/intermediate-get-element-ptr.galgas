
setter @instructionListIR appendGetPropertyReference
  ?let @objectIR inTarget
  ?let @objectIR inSource
  ?let @string inPLMname
  ?let @string inPropertyIndex
{
  self += !@getPropertyReferenceIR.new {!inTarget !inSource !inPLMname !inPropertyIndex}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @getPropertyReferenceIR : @abstractInstructionIR {
  @objectIR mTarget
  @objectIR mSource
  @string mPLMname
  @string mPropertyIndex
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @getPropertyReferenceIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [[mSource type] llvmTypeName]
  ioLLVMcode += "  " + [mTarget llvmName] + " = getelementptr inbounds "
  ioLLVMcode += llvmType + ", " + llvmType + " * " + [mSource llvmName] + ", i32 0, i32 " + mPropertyIndex
  ioLLVMcode += " ; " + mPLMname + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @getPropertyReferenceIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendGetElementPtr
  ?let @objectInMemoryIR inTarget
  ?let @objectInMemoryIR inSource
  ?let @elementPtrList inElementList
{
  if [inElementList length] == 0 then
    error .nowhere : "<<INTERNAL ERROR:inElementList is empty>>"
  end
  self += !@getElementPtrIR.new {!inTarget !inSource !inElementList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @getElementPtrIR : @abstractInstructionIR {
  @objectInMemoryIR mTarget
  @objectInMemoryIR mSource
  @elementPtrList mElementList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @getElementPtrIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [[mSource type] llvmTypeName]
  ioLLVMcode += "  " + [mTarget llvmName] + " = getelementptr inbounds "
  ioLLVMcode += llvmType + ", " + llvmType + " * " + [mSource llvmName] + ", i32 0"
  for (idx *) in mElementList do
    switch idx
    case absolute (index) : ioLLVMcode += ", i32 " + index
    case indirect (index) : ioLLVMcode += ", " + [index llvmTypeName] + " " + [index llvmName]
    end
  end
  ioLLVMcode += " ;"
  for (* fieldName) in mElementList do
    ioLLVMcode += " " + fieldName
  end
  ioLLVMcode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @getElementPtrIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
