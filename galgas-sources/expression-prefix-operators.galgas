#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @prefixOperator {
  case notOperator
  case minus
  case unsignedComplement
  case minusNoOvf
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @prefixOperatorExpressionAST : @expressionAST {
  @location mOperatorLocation
  @prefixOperator mOp
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST analyzeExpression
  ?self:let @omnibusType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @omnibusType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR expressionResult
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?expressionResult
  ]  
#--- Check expression type accepts prefix operator
  @prefixOperatorMap prefixOperatorMap
  @llvmBinaryOperation binaryOperator
  @objectIR leftOperand
  switch mOp 
  case unsignedComplement :
    prefixOperatorMap = inContext.mUnsignedComplementOperatorMap
    binaryOperator = .xor
    switch [expressionResult type].kind
    case staticArrayType (* *) :
      error mOperatorLocation : "internal error" : leftOperand
    case dynamicArrayType (*) :
      error mOperatorLocation : "internal error" : leftOperand
    case opaque (*) :
      error mOperatorLocation : "internal error" : leftOperand
    case boolean, void :
      error mOperatorLocation : "internal error" : leftOperand
    case literalString :
      error mOperatorLocation : "internal error" : leftOperand
    case enumeration (*) :
      error mOperatorLocation : "internal error" : leftOperand
    case structure (*) :
      error mOperatorLocation : "internal error" : leftOperand
    case syncTool :
      error mOperatorLocation : "internal error" : leftOperand
    case function (3*) :
      error mOperatorLocation : "internal error" : leftOperand
    case compileTimeBool :
      error mOperatorLocation : "internal error" : leftOperand
    case compileTimeInteger :
      if [inOptionalTargetType.kind isInteger] then
        [inOptionalTargetType.kind integer ?min:let minTarget ?max:let maxTarget ?2*]
        if minTarget < 0G then
          error mOperatorLocation : "the ~ operator cannot be applied to an inferred signed integer type" : leftOperand
        else
          leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:maxTarget}
        end
      else
        error mOperatorLocation : "for the ~ operator, the inferred type should be an unsigned integer" : leftOperand
      end
    case integer (* * * @uint bitCount) :
      leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:(1G << bitCount) - 1G}
    end
  case notOperator :
    prefixOperatorMap = inContext.mNotOperatorMap
    binaryOperator = .xor
    leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:1G}
  case minusNoOvf :
    prefixOperatorMap = inContext.mUnaryMinusOperatorMap
    binaryOperator = .subNoOVF
    leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:0G}
  case minus :
    prefixOperatorMap = inContext.mUnaryMinusOperatorMap
    if inMode == .panicMode then
      error mOperatorLocation
        : "operations that can generate panic are not allowed in " + panicModeName () + " mode"
    end
    if [option omnibus_options.noPanicGeneration value] then
      binaryOperator = .subNoOVF
      leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:0G}
    else
      binaryOperator = .ssubOVF
      leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:0G}
    end
  end
#--- Check operator
  [prefixOperatorMap searchKey !.new {![expressionResult omnibusTypeDescriptionName] !mOperatorLocation}]
  let resultType = [expressionResult type]
#---
  if [expressionResult isLiteralInteger] then
    [expressionResult literalInteger ?1* ?value:let @bigint value]
    @bigint result
    switch mOp 
    case minusNoOvf :
      result = - value
    case unsignedComplement :
      if [inOptionalTargetType.kind isInteger] then
        [inOptionalTargetType.kind integer ?min:let minTarget ?max:let maxTarget ?2*]
        if minTarget < 0G then
          error mOperatorLocation : "the ~ operator cannot be applied to an inferred signed integer type" : result
        else
          result = value ^ maxTarget
        end
      else
        error mOperatorLocation : "for the ~ operator, the inferred type should be an unsigned integer" : result
      end
    case minus :
      result = - value
    case notOperator :
      result = 1G ^ value
    end
    outResult = .literalInteger {!type:resultType !value:result}
  else
  #--- Temp var
    getNewTempValue (!resultType !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![outResult type]
      !mOperatorLocation
      !leftOperand
      !binaryOperator
      !expressionResult
    ]      
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
