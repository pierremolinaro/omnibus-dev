#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @prefixOperator {
  case notOp
  case minusOp
  case bitWiseComplement
  case minusNoOvf
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @prefixOperatorExpressionAST : @expressionAST {
  @location mOperatorLocation
  @prefixOperator mOp
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST analyzeExpression
  ?self:let @omnibusType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @omnibusType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR expressionResult
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?expressionResult
  ]  
#--- Check expression type accepts prefix operator
  let currentlyInSafeMode = [inMode isSafe]
  let @bool noPanicGeneration = [option omnibus_options.noPanicGeneration value]
  let key = prefixOperatorMapKey (![expressionResult type] !mOp !mOperatorLocation)
  if [inContext.mPrefixOperatorMap hasKey !key] then
    [inContext.mPrefixOperatorMap generateInfixOperatorCode
      !expressionResult
      !mOp
      !mOperatorLocation
      !safeMode: currentlyInSafeMode
      !noPanicCode: noPanicGeneration
      !?ioTemporaries
      !?ioInstructionGenerationList
      ?outResult
    ]
  else
    error mOperatorLocation : "OLD PREFIX OP " + key + "\n"
    @prefixOperatorMap_EX prefixOperatorMap
    @llvmBinaryOperation binaryOperator
    @objectIR leftOperand
    switch mOp 
    case bitWiseComplement :
      prefixOperatorMap = inContext.mUnsignedComplementOperatorMap
      binaryOperator = .xor
      switch [expressionResult type].kind
      case staticArrayType (* *) :
        error mOperatorLocation : "internal error" : leftOperand
      case dynamicArrayType (*) :
        error mOperatorLocation : "internal error" : leftOperand
      case opaque (*) :
        error mOperatorLocation : "internal error" : leftOperand
      case boolean, void :
        error mOperatorLocation : "internal error" : leftOperand
      case literalString :
        error mOperatorLocation : "internal error" : leftOperand
      case enumeration (*) :
        error mOperatorLocation : "internal error" : leftOperand
      case structure (*) :
        error mOperatorLocation : "internal error" : leftOperand
      case syncTool :
        error mOperatorLocation : "internal error" : leftOperand
      case generic (3*) :
        error mOperatorLocation : "internal error" : leftOperand
      case llvmType (*) :
        error mOperatorLocation : "internal error" : leftOperand
      case function (3*) :
        error mOperatorLocation : "internal error" : leftOperand
      case compileTimeBool :
        error mOperatorLocation : "internal error" : leftOperand
      case compileTimeInteger :
        if [inOptionalTargetType.kind isInteger] then
          [inOptionalTargetType.kind integer ?min:let minTarget ?max:let maxTarget ?2*]
          if minTarget < 0G then
            error mOperatorLocation : "the ~ operator cannot be applied to an inferred signed integer type" : leftOperand
          else
            leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:maxTarget}
          end
        else
          error mOperatorLocation : "for the ~ operator, the inferred type should be an unsigned integer" : leftOperand
        end
      case integer (* * * @uint bitCount) :
        leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:(1G << bitCount) - 1G}
      end
    case notOp :
      prefixOperatorMap = inContext.mNotOperatorMap
      binaryOperator = .xor
      leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:1G}
    case minusNoOvf :
      prefixOperatorMap = inContext.mUnaryMinusOperatorMap
      binaryOperator = .subNoOVF
      leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:0G}
    case minusOp :
      prefixOperatorMap = inContext.mUnaryMinusOperatorMap
      if inMode == .panicMode then
        error mOperatorLocation
          : "operations that can generate panic are not allowed in " + panicModeName () + " mode"
      end
      if [option omnibus_options.noPanicGeneration value] then
        binaryOperator = .subNoOVF
        leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:0G}
      else
        binaryOperator = .ssubOVF
        leftOperand = .literalInteger {!type:compileTimeIntegerType () !value:0G}
      end
    end
  #--- Check operator
    [prefixOperatorMap searchKey !.new {![expressionResult omnibusTypeDescriptionName] !mOperatorLocation}]
    let resultType = [expressionResult type]
  #---
    if [expressionResult isLiteralInteger] then
      [expressionResult literalInteger ?1* ?value:let @bigint value]
      @bigint result
      switch mOp 
      case minusNoOvf :
        result = - value
      case bitWiseComplement :
        if [inOptionalTargetType.kind isInteger] then
          [inOptionalTargetType.kind integer ?min:let minTarget ?max:let maxTarget ?2*]
          if minTarget < 0G then
            error mOperatorLocation : "the ~ operator cannot be applied to an inferred signed integer type" : result
          else
            result = value ^ maxTarget
          end
        else
          error mOperatorLocation : "for the ~ operator, the inferred type should be an unsigned integer" : result
        end
      case minusOp :
        result = - value
      case notOp :
        result = 1G ^ value
      end
      outResult = .literalInteger {!type:resultType !value:result}
    else
    #--- Temp var
      getNewTempValue (!resultType !?ioTemporaries ?outResult)
    #--- Generate code
      [!?ioInstructionGenerationList appendBinaryOperation
        !outResult
        ![outResult type]
        !mOperatorLocation
        !leftOperand
        !binaryOperator
        !expressionResult
      ]      
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
