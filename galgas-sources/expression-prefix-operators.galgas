#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @prefixOperator {
  case notOperator
  case minus
  case unsignedComplement
  case minusNoOvf
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @prefixOperatorExpressionAST : @expressionAST {
  @location mOperatorLocation
  @prefixOperator mOp
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @prefixOperatorExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?localVariableMap: ioLocalVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @objectIR expressionResult
  ]
#--- Check expression type accepts prefix operator
  @prefixOperatorMap prefixOperatorMap
  @llvmBinaryOperation binaryOperator
  @objectIR leftOperand
  switch mOp 
  case unsignedComplement :
    prefixOperatorMap = inContext.mUnsignedComplementOperatorMap
    binaryOperator = .xor
    switch [expressionResult kind]
    case arrayType (* *) : error .nowhere : "internal error" : leftOperand
    case opaque (*) : error .nowhere : "internal error" : leftOperand
    case boolean : error .nowhere : "internal error" : leftOperand
    case literalString : error .nowhere : "internal error" : leftOperand
    case enumeration (*) :  error .nowhere : "internal error" : leftOperand
    case structure (* * *) :  error .nowhere : "internal error" : leftOperand
    case staticInteger :  error .nowhere : "internal error" : leftOperand
    case integer (* * * @uint bitCount) :
      leftOperand = .literalInteger {!type: inContext.mLiteralIntegerType !value:(1G << bitCount) - 1G}
    end
  case notOperator :
    prefixOperatorMap = inContext.mNotOperatorMap
    binaryOperator = .xor
    leftOperand = .literalInteger {!type: inContext.mLiteralIntegerType !value:1G}
  case minusNoOvf :
    prefixOperatorMap = inContext.mUnaryMinusOperatorMap
    binaryOperator = .subNoOVF
    leftOperand = .literalInteger {!type: inContext.mLiteralIntegerType !value:0G}
  case minus :
    prefixOperatorMap = inContext.mUnaryMinusOperatorMap
    if [inModeSet hasKey !panicModeName ()] then
      error mOperatorLocation
        : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
    end
    if [option plm_options.noPanicGeneration value] then
      binaryOperator = .subNoOVF
      leftOperand = .literalInteger {!type: inContext.mLiteralIntegerType !value:0G}
    else
      binaryOperator = .ssubOVF
      leftOperand = .literalInteger {!type: inContext.mLiteralIntegerType !value:0G}
    end
  end
#--- Check operator
  [prefixOperatorMap searchKey !.new {![expressionResult key] !mOperatorLocation}]
  let resultType = [expressionResult type]
#---
  if [expressionResult isLiteralInteger] then
    [expressionResult literalInteger ?1* ?value:let @bigint value]
    @bigint result
    switch mOp 
    case minusNoOvf : result = - value
    case unsignedComplement : error mOperatorLocation : "internal error" : result
    case minus : result = - value
    case notOperator : result = 1G ^ value
    end
    outResult = .literalInteger {!type:resultType !value:result}
  else
  #--- Temp var
    getNewTempVariable (!resultType !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult
      ![outResult type]
      !mOperatorLocation
      !leftOperand
      !binaryOperator
      !expressionResult
    ]      
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
