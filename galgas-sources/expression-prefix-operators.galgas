#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @prefixOperator {
  case notOperator
  case minus
  case unsignedComplement
  case minusNoOvf
}

#----------------------------------------------------------------------------------------------------------------------*

class @prefixOperatorExpressionAST : @expressionAST {
  @location mOperatorLocation
  @prefixOperator mOp
  @expressionAST mExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @prefixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

method @prefixOperatorMap checkWith
  ?type:let @unifiedTypeMap-proxy inType
  ?operatorLocation:let @location inOperatorLocation
  !resultType: @unifiedTypeMap-proxy outResultType
{
  let lkey = @lstring.new {![inType key] !inOperatorLocation}
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType]
  else
    error inOperatorLocation
      : "prefix operation is not defined for '" + [inType key] + " type"
      : outResultType
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @prefixOperatorExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@operandIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @operandIR expressionResult
  ]
#--- Check expression type accepts prefix operator
  @prefixOperatorMap operatorMap
  @llvmBinaryOperation binaryOperator
  @string commentOperator
  @operandIR leftOperand
  switch mOp 
  case unsignedComplement :
    operatorMap = inContext.mUnsignedComplementOperatorMap
    binaryOperator = .xor
    commentOperator = "~"
    switch [expressionResult.mType kind]
    case boolean : error .nowhere : "internal error" : leftOperand
    case boolset : error .nowhere : "internal error" : leftOperand
    case literalString : error .nowhere : "internal error" : leftOperand
    case enumeration (*) :  error .nowhere : "internal error" : leftOperand
    case structure (* * *) :  error .nowhere : "internal error" : leftOperand
    case literalInteger :  error .nowhere : "internal error" : leftOperand
    case integer (* * * @uint bitCount) :
      leftOperand = .new {!inContext.mLiteralIntegerType !.literalInteger {!value:(1G << bitCount) - 1G}}
    end
  case notOperator :
    operatorMap = inContext.mNotOperatorMap
    binaryOperator = .xor
    commentOperator = "!"
    leftOperand = .new {!inContext.mLiteralIntegerType !.literalInteger {!value:1G}}
  case minusNoOvf :
    operatorMap = inContext.mUnaryMinusOperatorMap
    binaryOperator = .subNoOVF
    commentOperator = "-"
    leftOperand = .new {!inContext.mLiteralIntegerType !.literalInteger {!value:0G}}
  case minus :
    operatorMap = inContext.mUnaryMinusOperatorMap
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation
        : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    if [option plm_options.noExceptionGeneration value] then
      binaryOperator = .subNoOVF
      leftOperand = .new {!inContext.mLiteralIntegerType !.literalInteger {!value:0G}}
      commentOperator = "-"
    else
      binaryOperator = .ssubOVF
      leftOperand = .new {!inContext.mLiteralIntegerType !.literalInteger {!value:0G}}
      commentOperator = "-OVF "
    end
  end
  [operatorMap checkWith
    !type:expressionResult.mType
    !operatorLocation:mOperatorLocation
    ?resultType:let resultType
  ]
#---
  if [expressionResult.mValue isLiteralInteger] then
    [expressionResult.mValue literalInteger ?value:let @bigint value]
    @bigint result
    switch mOp 
    case minusNoOvf : result = - value
    case unsignedComplement : error mOperatorLocation : "internal error" : result
    case minus : result = - value
    case notOperator : result = 1G ^ value
    end
    outResult = .new {!resultType !.literalInteger {!value:result}}
  else
  #--- Temp var
    getNewTempVariable (!resultType !?ioTemporaries ?outResult)
  #--- Comment
    var comment = [outResult.mValue string] + " = " + commentOperator + expressionResult.mValue
    [!?ioInstructionGenerationList appendComment !comment]
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResult.mValue
      !outResult.mType
      !mOperatorLocation
      !leftOperand.mValue
      !binaryOperator
      !expressionResult.mValue
    ]      
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @prefixOperatorExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

enum @prefixOperatorIR {
  case prefix (@string prefixOperator)
  case prefixMinusOvf (@uint code)
}

#----------------------------------------------------------------------------------------------------------------------*

class @prefixOperatorExpressionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @valueIR mResult
  @valueIR mOperand
  @prefixOperatorIR mOperator
  @location mOperatorLocation
}

#----------------------------------------------------------------------------------------------------------------------*

override method @prefixOperatorExpressionIR llvmInstructionCode
  ?!@string ioCode
  ?let @generationContext unused inGenerationContext
  ?!@stringset unused ioIntrinsicsDeclarationSet
{
  switch mOperator 
  case prefix (@string prefixOperator) :
    ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + mResult
    ioCode += " = " + prefixOperator + " " + mOperand + " ;\n"
  case prefixMinusOvf (@uint code) :
    @bigint minValue
    switch [mTargetType kind]
    case boolean, boolset, literalString :
      error mOperatorLocation: "Internal Error" : minValue
    case enumeration (*) :
      error mOperatorLocation: "Internal Error" : minValue
    case structure (* * *) :
      error mOperatorLocation: "Internal Error" : minValue
    case integer (@bigint min * * *) :
      minValue = min
    case literalInteger :
      minValue = 0G # TODO
    end
    let ovfVar = "ovf" + [mOperatorLocation locationIndex]
    ioCode += "const bool " + ovfVar + " = " + mOperand + " == " + minValue + " ;\n"
    ioCode += "if (" + ovfVar + ") {\n"
    ioCode += "  raise_exception (" + code
       + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
       + ", " + [mOperatorLocation line] + ") ;\n"
    ioCode += "}\n" 
    ioCode += mangledNameForType (!name:[mTargetType key]) + " " + mResult
       + " = - " + mOperand + " ;\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @prefixOperatorExpressionIR enterAccessibleEntities ?!@accessibleEntities unused ioAccessibleEntities {
#  [mOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
