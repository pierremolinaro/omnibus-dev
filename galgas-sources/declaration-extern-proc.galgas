#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @externProcedureDeclarationListAST {
  @lstring mExternProcedureName
  @lstringlist mProcedureModeList
  @procFormalArgumentList mProcFormalArgumentList
  @lstring mReturnTypeName
  @lstring mRoutineNameForGeneration
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extern$
    <procedure_header>
      ?public:let unused public
      ?procModes:let requiredModeList
      ?name:let procName
      ?attributes:let unused attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      $\$type$ ?returnTypeName
    end
    $:$
    $"string"$ ?let llvmName
    ioAST.mExternProcList += !procName !requiredModeList !procFormalArgumentList !returnTypeName !llvmName !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   ENTER IN CONTEXT                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST enterExternProcInContext
  ?!context:@semanticContext ioContext
{
  for externProcedure in self do
    [externProcedure enterExternProcInContext !?context:ioContext]
  end
}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST-element enterExternProcInContext
  ?!context:@semanticContext ioContext
{
#--- Signature
  @procedureSignature signature = {}
  var routineMangledName = mExternProcedureName
  routineMangledName.string += "("
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in mProcFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
    signature += !formalArgumentPassingMode !selector.string !typeProxy
    routineMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  routineMangledName.string += ")"
#--- Mode map
  @modeMap procedureModeMap = {}
  for () in mProcedureModeList do
    [ioContext.mModeMap searchKey !mValue]
    [!?procedureModeMap insertKey !mValue]
  end
#--- Enter in context
  let returnType = if mReturnTypeName.string == "" then
    @unifiedTypeMap-proxy.null
  else
    @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mReturnTypeName}
  end
  [!?ioContext.mRoutineMapForContext insertKey
    !routineMangledName
    !mRoutineNameForGeneration
    !true # isPublic
    !false # Global
    !procedureModeMap
    !signature
    !.function
    !false # Not weak
    !returnType
    !false # No appendFileAndLineArgumentForPanicLocation
    !false # canMutateProperties
    !false # canAccessPropertiesInUserMode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST externProcedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for externProc in self do
    [externProc externProcedureSemanticAnalysis
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST-element externProcedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Routine mangled name
  var routineMangledName = mExternProcedureName
  routineMangledName.string += "("
  for (passingMode selector * *) in mProcFormalArgumentList do
    routineMangledName.string += [passingMode formalPassingModeString]
     routineMangledName.string += selector.string
     routineMangledName.string += ":"
  end
  routineMangledName.string += ")"
#--- Check modes
  @stringset procedureModeSet = {}
  for mode in mProcedureModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    procedureModeSet += !mode.mValue.string
  end
#--- Variable map
  initialVariableMap (
    !routineNameForInvocation:routineMangledName.string
    !context:inContext
    !userMode:[procedureModeSet hasKey !userModeName ()]
    !registerAccess:.readWriteAccess
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
    ?@variableMap variableMap
  )
#--- Analyse formal arguments
  @procFormalArgumentListForGeneration formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !mProcFormalArgumentList
    !?variableMap
    !?formalArguments
  )
#--- End of variableMap
  drop variableMap
#--- Enter subprogram invocation graph
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineMangledName.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineMangledName
      !routineMangledName
    ]
  end
#--- Return type
  let returnType = if mReturnTypeName.string == "" then
    @unifiedTypeMap-proxy.null
  else
    @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mReturnTypeName}
  end
#--- Routine name for generation
  [!?ioIntermediateCodeStruct.mExternProcedureMapIR insertKey
    !mRoutineNameForGeneration
    !formalArguments
    !returnType
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @externProcedureMapIR {
  @procFormalArgumentListForGeneration mFormalArgumentListForGeneration
  @unifiedTypeMap-proxy mReturnType
  insert insertKey error message "extern procedure %K is already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureMapIR llvmPrototypeGeneration  ?!@string ioLLVMcode {
  for externProc in self do
    [externProc llvmPrototypeGeneration !?ioLLVMcode]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureMapIR-element llvmPrototypeGeneration  ?!@string ioLLVMcode {
  let procName = llvmNameForFunction (!lkey.string)
  ioLLVMcode += llvmTitleComment (!"extern procedure " + lkey)
  ioLLVMcode += "declare"
  if mReturnType == .null then
    ioLLVMcode += " void"
  else
      ioLLVMcode += " " + [mReturnType llvmTypeName]
  end
  ioLLVMcode += " @" + procName + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "; defined in C\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
