#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @externFunctionDeclarationListAST {
  @lstring mExternProcedureName
  @mode mMode
  @lstringlist mAttributeList
  @routineFormalArgumentListAST mProcFormalArgumentList
  @lstring mReturnTypeName
  @lstring mRoutineNameForGeneration
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extern$
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition> !?ioAST ?returnTypeName
    end
    $:$
    $"string"$ ?let llvmName
    ioAST.mExternFunctionListAST += !procName !mode !attributeList !procFormalArgumentList !returnTypeName !llvmName !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externFunctionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    if mReturnTypeName.string != "" then
      [!?ioGraph noteNode !mReturnTypeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   ENTER IN CONTEXT                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externFunctionDeclarationListAST enterExternProcInContext
  ?!context:@semanticContext ioContext
{
  for externProcedure in self do
    [externProcedure enterExternProcInContext !?context:ioContext]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externFunctionDeclarationListAST-element enterExternProcInContext
  ?!context:@semanticContext ioContext
{
#--- Signature
  routineTypedSignature (!?ioContext.mTypeMap !mProcFormalArgumentList ?let signature)
#---
  var safe = false
  for (attribute) in mAttributeList do
    if attribute.string == safeAttribute () then
      safe = true
    end
  end
#--- Return type
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !mReturnTypeName ?let returnTypeProxy]
#--- Enter in context
  let @routineLLVMNameDict routineLLVMNameDict = {!mMode !mRoutineNameForGeneration}
  let routineMangledName = [signature mangledName !mExternProcedureName]
  [!?ioContext.mRoutineMap insertKey
    !routineMangledName
    !true
    !signature
    !returnTypeProxy
    !routineLLVMNameDict
    !safe
    !false
    !mMode
  ]
#--- Enter in context (EX)
  [!?ioContext.mRoutineMapForContextEX insertRoutine
    !""
    !mExternProcedureName
    ![mProcFormalArgumentList routineSignature !mExternProcedureName]
    !mRoutineNameForGeneration
    !.new {
      !isPublic:true
      !exported:false
      !name:mExternProcedureName
      !nameForLLVMGeneration:mRoutineNameForGeneration
      !routineKind:.function {!executionMode:mMode}
      !signature:signature
      !returnTypeProxy:returnTypeProxy
      !canAccessProperties:false
      !canMutateProperties:false
      !safe:safe
    }
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externFunctionDeclarationListAST externProcedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for externProc in self do
    [externProc externProcedureSemanticAnalysis
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externFunctionDeclarationListAST-element externProcedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Analyse formal arguments
  @routineFormalArgumentListIR formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !mProcFormalArgumentList
    !?* # universalMap
    !?formalArguments
    !warningOnUnusedArgs: true
  )
#--- Return type
  let returnType = if mReturnTypeName.string == "" then
    @unifiedTypeMap-proxy.null
  else
    @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mReturnTypeName}
  end
#--- Routine name for generation
  [!?ioIntermediateCodeStruct.mExternProcedureMapIR insertKey
    !mRoutineNameForGeneration
    !formalArguments
    !returnType
  ]  
  ioIntermediateCodeStruct.mRoutineListIR += !@externRoutineIR.new {
    !mRoutineNameForGeneration
    !false # Is not root
    !false # inWarnIfUnused
    !formalArguments
    !returnType
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @externRoutineIR : @abstractRoutineIR {
  @routineFormalArgumentListIR mFormalArgumentListForGeneration
  @unifiedTypeMap-proxy mReturnType
}

#·······················································································································

override method @externRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!mRoutineMangledName)
  ioLLVMcode += "declare"
  if mReturnType == .null then
    ioLLVMcode += " void"
  else
      ioLLVMcode += " " + [[mReturnType type] llvmTypeName]
  end
  ioLLVMcode += " @" + [mRoutineMangledName assemblerRepresentation] + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "; declared by extern PLM function declaration\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @externProcedureMapIR {
  @routineFormalArgumentListIR mFormalArgumentListForGeneration
  @unifiedTypeMap-proxy mReturnType
  insert insertKey error message "extern procedure %K is already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureMapIR llvmPrototypeGeneration  ?!@string unused ioLLVMcode {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureMapIR-element llvmPrototypeGeneration  ?!@string ioLLVMcode {
  let procName = llvmNameForFunction (!lkey.string)
  ioLLVMcode += "declare"
  if mReturnType == .null then
    ioLLVMcode += " void"
  else
      ioLLVMcode += " " + [[mReturnType type] llvmTypeName]
  end
  ioLLVMcode += " @" + procName + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "; declared by extern PLM function declaration\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
