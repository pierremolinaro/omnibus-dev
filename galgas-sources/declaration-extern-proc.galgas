#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @externProcedureDeclarationListAST {
  @lstring mExternProcedureName
  @mode mMode
  @lstringlist mAttributeList
  @routineFormalArgumentListAST mProcFormalArgumentList
  @lstring mReturnTypeName
  @lstring mRoutineNameForGeneration
  @location mEndOfProcLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extern$
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition> !?ioAST ?returnTypeName
    end
    $:$
    $"string"$ ?let llvmName
    ioAST.mExternProcListAST += !procName !mode !attributeList !procFormalArgumentList !returnTypeName !llvmName !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      let typeName = llvmTypeNameFromPLMname (!formalArgumentTypeName)
      [!?ioGraph noteNode !typeName]
    end
    if mReturnTypeName.string != "" then
      let typeName = llvmTypeNameFromPLMname (!mReturnTypeName)
      [!?ioGraph noteNode !typeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   ENTER IN CONTEXT                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST enterExternProcInContext
  ?!context:@semanticContext ioContext
{
  for externProcedure in self do
    [externProcedure enterExternProcInContext !?context:ioContext]
  end
}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST-element enterExternProcInContext ?!context:@semanticContext ioContext {
#--- Signature
  routineSignature (!?ioContext.mTypeMap !mProcFormalArgumentList ?let signature)
#---
  var safe = false
  for (attribute) in mAttributeList do
    if attribute.string == safeAttribute () then
      safe = true
    end
  end
#--- Enter in context
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !mReturnTypeName ?let returnTypeProxy]
  [!?ioContext.mRoutineMapForContext insertRoutine
    !mExternProcedureName
    ![mProcFormalArgumentList routineSignature !mExternProcedureName]
    !mRoutineNameForGeneration
    !.new {
      !isPublic:true
      !exported:false
      !routineKind:.function {!executionMode:mMode}
      !signature:signature
      !returnTypeProxy:returnTypeProxy
      !canAccessProperties:false
      !canMutateProperties:false
      !safe:safe
    }
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST externProcedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for externProc in self do
    [externProc externProcedureSemanticAnalysis
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureDeclarationListAST-element externProcedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Routine mangled name
  let routineMangledName = routineMangledNameFromAST (
    !"" 
    !mExternProcedureName
    !mProcFormalArgumentList
  )
#--- Analyse formal arguments
  @routineFormalArgumentListIR formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !mProcFormalArgumentList
    !?* # universalMap
    !?formalArguments
  )
#--- Enter subprogram invocation graph
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineMangledName.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineMangledName
      !routineMangledName
    ]
  end
#--- Return type
  let returnType = if mReturnTypeName.string == "" then
    @unifiedTypeMap-proxy.null
  else
    @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mReturnTypeName}
  end
#--- Routine name for generation
  [!?ioIntermediateCodeStruct.mExternProcedureMapIR insertKey
    !mRoutineNameForGeneration
    !formalArguments
    !returnType
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @externProcedureMapIR {
  @routineFormalArgumentListIR mFormalArgumentListForGeneration
  @unifiedTypeMap-proxy mReturnType
  insert insertKey error message "extern procedure %K is already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureMapIR llvmPrototypeGeneration  ?!@string ioLLVMcode {
  ioLLVMcode += llvmTitleComment (!"extern functions")
  for externProc in self do
    [externProc llvmPrototypeGeneration !?ioLLVMcode]
  end
  ioLLVMcode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @externProcedureMapIR-element llvmPrototypeGeneration  ?!@string ioLLVMcode {
  let procName = llvmNameForFunction (!lkey.string)
  ioLLVMcode += "declare"
  if mReturnType == .null then
    ioLLVMcode += " void"
  else
      ioLLVMcode += " " + [[mReturnType type] llvmTypeName]
  end
  ioLLVMcode += " @" + procName + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "; defined in C\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
