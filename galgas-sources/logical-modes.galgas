#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  Logical modes                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @mode {
  case userMode
  case sectionMode
  case serviceMode
  case primitiveMode
  case guardMode
  case panicMode
  case bootMode
  case startupMode
  case anyMode
}

#·······················································································································

getter @mode string -> @string {
  switch self
  case userMode : result = "user"
  case sectionMode : result = "section"
  case serviceMode : result = "service"
  case primitiveMode : result = "primitive"
  case guardMode : result = "guard"
  case panicMode : result = "panic"
  case bootMode : result = "boot"
  case startupMode : result = "startup"
  case anyMode : result = "any"
  end
}

#·······················································································································

getter @mode routineLLVMDictionaryForFunction ?let @string inRoutineNameForGeneration -> @routineLLVMNameDict {
  result = {!self !inRoutineNameForGeneration}
  if self == .serviceMode then
    result += !.primitiveMode !inRoutineNameForGeneration
    result += !.guardMode !inRoutineNameForGeneration
  elsif self == .sectionMode then
    result += !.primitiveMode !inRoutineNameForGeneration
    result += !.serviceMode !inRoutineNameForGeneration
    result += !.guardMode !inRoutineNameForGeneration
    result += !.startupMode !inRoutineNameForGeneration
  elsif self == .guardMode then
    result += !.serviceMode !inRoutineNameForGeneration
  end
}

#·······················································································································

getter @mode routineLLVMDictionaryForSystemRoutine
  ?let @string inUserRoutineNameForGeneration
  ?let @string inImplementationRoutineNameForGeneration
  -> @routineLLVMNameDict
{
  result = {!self !inImplementationRoutineNameForGeneration}
  result += !.userMode !inUserRoutineNameForGeneration
  if self == .serviceMode then
    result += !.primitiveMode !inImplementationRoutineNameForGeneration
    result += !.guardMode !inImplementationRoutineNameForGeneration
  elsif self == .sectionMode then
    result += !.primitiveMode !inImplementationRoutineNameForGeneration
    result += !.serviceMode !inImplementationRoutineNameForGeneration
    result += !.guardMode !inImplementationRoutineNameForGeneration
    result += !.startupMode !inImplementationRoutineNameForGeneration
  elsif self == .guardMode then
    result += !.serviceMode !inImplementationRoutineNameForGeneration
  end
}

#·······················································································································

func checkMode
  ?callerMode:let @mode inCallerMode
  ?calleeMode:let @mode inCalleeMode
  ?kind:let @routineKind inRoutineKind
  ?error:let @location inErrorLocation
  -> @calleeKindIR outResult
{
  switch inRoutineKind
  case section :
    if inCallerMode == .userMode then
      outResult = .sectionFromProcessorUserMode
    elsif (inCallerMode == .primitiveMode) || (inCallerMode == .sectionMode) || (inCallerMode == .startupMode) || (inCallerMode == .guardMode) then
      outResult = .sectionFromProcessorPrivilegedMode
    else
      error inErrorLocation : "a section cannot be called from " + inCallerMode + " mode" : outResult
    end
  case primitive :
    if inCallerMode == .userMode then
      outResult = .primitiveFromProcessorUserMode
    else
      error inErrorLocation : "a primitive cannot be called from " + inCallerMode + " mode" : outResult
    end
  case service :
    if inCallerMode == .userMode then
      outResult = .serviceFromProcessorUserMode
    elsif (inCallerMode == .primitiveMode) || (inCallerMode == .serviceMode) || (inCallerMode == .guardMode) then
      outResult = .serviceFromProcessorPrivilegedMode
    else
      error inErrorLocation : "a service cannot be called from " + inCallerMode + " mode" : outResult
    end
  case function (*) :
    var ok = inCallerMode == inCalleeMode
    if not ok then
      switch inCallerMode
      case userMode :
        ok = inCalleeMode == .anyMode
      case sectionMode :
        ok = inCalleeMode == .anyMode
      case serviceMode :
        ok = (inCalleeMode == .sectionMode) || (inCalleeMode == .anyMode)
      case primitiveMode :
        ok = (inCalleeMode == .serviceMode) || (inCalleeMode == .sectionMode) || (inCalleeMode == .anyMode)
      case guardMode :
        ok = (inCalleeMode == .serviceMode) || (inCalleeMode == .sectionMode) || (inCalleeMode == .anyMode)
      case panicMode, startupMode :
        ok = (inCalleeMode == .anyMode)
      case bootMode :
      case anyMode :
      end
    end
    if not ok then
      error inErrorLocation
      : "a func " + inCalleeMode + " cannot be called from " + inCallerMode + " mode"
    end
    outResult = .function
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @mode controlRegisterAccess ?let @bool inIsAccessibleInUserMode -> @bool {
  switch self
  case userMode, anyMode :
    result = inIsAccessibleInUserMode
  case sectionMode, serviceMode, primitiveMode, panicMode, bootMode, startupMode :
    result = true
  case guardMode :
    result = false
  end
}
