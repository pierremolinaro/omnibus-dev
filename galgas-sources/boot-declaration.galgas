#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @bootList {
  @location mBootLocation
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
  @bigint mPriority
  @location mPriorityLocation
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $boot$
    $integer$ ?let @lbigint priority
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    let endOfInit = @location.here
    $}$
    ioAST.mBootList +=
      !priority.location
      !instructionList
      !endOfInit
      !priority.bigint
      !priority.location
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @bootRoutinePriorityMap {
  insert insertKey error message "a boot routine with priority %K has been already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootList-element bootSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  if not [inContext.mModeMap hasKey !bootModeName ()] then
    error mBootLocation : "the `" + bootModeName () + " mode should be defined in order to use boot routines"
  end
  [!?ioTemporaries.mBootRoutinePriorityMap insertKey !.new{![mPriority string] !mPriorityLocation}]
#---
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mPriority !mPriorityLocation}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineNameForInvocation:routineNameForInvocationGraph.string
    !context:inContext
    !globalsAreConstant:false
  )
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !modes:{!bootModeName ()}
    !allowException:true
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfBootLocation]
#--- Code generation
  ioIntermediateCodeStruct.mBootList +=
    !mBootLocation
    !instructionGenerationList
    !mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @bootListIR {
  @location mInitLocation
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

