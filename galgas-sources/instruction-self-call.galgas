#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @unifiedSelfCallInstructionAST : @abstractCallInstructionAST {
  @location mSelfLocation
  @fieldList mFieldList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <routine_call> !@location outInstructionLocation !@abstractCallInstructionAST outInstruction {
    <self_access> ?outInstructionLocation ?let @fieldList fieldList
    <effective_parameters> ?let effectiveParameterList
    outInstruction = @unifiedSelfCallInstructionAST.new {
      !effectiveParameterList
      !outInstructionLocation
      !fieldList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @unifiedSelfCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Last field is method name, array access not allowed
  var fieldList = mFieldList
  [!?fieldList popLast ?let methodName ?let arrayAccess]
  if [arrayAccess isAccess] then
    error methodName : "array access not allowed here"
  end
#--- Self access analysis
  analyzeSelfAccess (
    !fieldList:fieldList
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.null
    !context:inContext
    !modes:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?resultPtr:let @objectInMemoryIR propertyAddressLLVMvar
  )
  let receiverType = [propertyAddressLLVMvar type]
  let routineMangledName = @lstring.new {!"$" + [receiverType key] + "." + methodName !methodName.location}
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  effectiveParameterListIR += !.outputInput ![propertyAddressLLVMvar address] #--- add "load receiver" as first argument
  [inContext.mRoutineMapForContext searchKey
    !routineMangledName
    ?let isPublic
    ?let modeMap
    ?let @procedureSignature formalSignature
    ?let @routineKind routineKind
    ?*
    ?let returnedType
    ?let appendFileAndLineArgumentForPanicLocation
    ?let canMutateProperties
    ?let canAccessPropertiesInUserMode
  ]
  if canAccessPropertiesInUserMode && not inDirectAccessToPropertiesAllowed then
    error methodName : "the callee access properties, but current routine is not declared with @" + userAccessAttribute () + " attribute"
  end
  if canMutateProperties && not inRoutineCanMutateProperties then
    error methodName : "the callee mutates properties, but current routine is not declared with @" + mutatingAttribute () + " attribute"
  end
  if ([fieldList length] > 0) && not isPublic then
    error routineMangledName : "this routine is not public"
  end
#--- Enter in invocation graph
  @lstring routineNameForInvocationGraph
  switch routineKind
  case function :
    routineNameForInvocationGraph = procNameForInvocationGraph (!receiverType !methodName)
  case section :
    routineNameForInvocationGraph = sectionNameForInvocationGraph (!receiverType !methodName)
  case service :
    routineNameForInvocationGraph = serviceNameForInvocationGraph (!receiverType !methodName)
  case primitive :
    routineNameForInvocationGraph = primitiveNameForInvocationGraph (!receiverType !methodName)
  end
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForInvocationGraph]
#--- Check modes
  let routineKindIR = checkMode (
    !requiredModes:inRequiredModeSet
    !possibleModes:[modeMap keySet]
    !kind:routineKind
    !error:methodName.location
  )
#--- Analyze effective parameters
  analyzeEffectiveParameters (
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !propertiesAreMutable:inRoutineCanMutateProperties
    !formal:formalSignature
    !effective:mEffectiveParameterList
    !errorLocation:methodName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:effectiveParameterListIR
  )
  if returnedType != .null then
    error methodName : "cannot be called in instruction: routine has a return value"
  end
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !"" # Receiver is self
    !routineMangledName
    !routineKindIR
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
