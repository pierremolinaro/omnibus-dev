#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @varInExpressionAST : @expressionAST {
  @lstring mSourceVarName
  @lstringlist mFieldNameList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let sourceVarName
    @lstringlist fieldNameList = {}
    repeat
    while
      $.$
      $identifier$ ?let fieldName
      fieldNameList += !fieldName
    end 
    outExpression = @varInExpressionAST.new {!sourceVarName !fieldNameList}
  }

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @varInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mSourceVarName]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @varInExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring unused inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType unused inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext unused inContext
  ?modes:let @stringset unused inModeSet
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !type:@unifiedTypeMap-proxy outExpressionType
  !result:@operandIR outResultValueName
{
#--- Search variable
  [!?ioVariableMap searchForReadAccess
    !mSourceVarName
    ?let @unifiedTypeMap-proxy variableType
    ?let accessIsAllowed
    ?@variableKindIR variableKind
    ?*
    ?@registerBitSliceAccessMap registerBitSliceMap
    ?*
  ]
  if not accessIsAllowed then
    error mSourceVarName : "routine has no access right on the this variable"
  end
#--- Load variable
  [variableKind loadFromMemory
    !?temporary:ioTemporaries
    !?instructionListIR:ioInstructionGenerationList
    ?resultingValue:@operandIR variableValueName
  ]
#--- Solve inferred type
  outExpressionType = solveInferredType (
    !targetType:inOptionalTargetType
    !sourceType:variableType
    !errorLocation:mSourceVarName.location
  )
#--- Field ?
  for (field) in mFieldNameList do
    if [registerBitSliceMap count] > 0 then # It is a register
      [registerBitSliceMap searchKey
        !field
        ?let @llvmBinaryOperation accessOperator
        ?let @bigint accessRightOperand
        ?let submap
        ?let newResultType
       ]
    #--- Temp var
      getNewTempVariable (!?ioTemporaries ?let newResultingVariable)
      [!?ioInstructionGenerationList appendBinaryOperation
        !newResultingVariable
        !outExpressionType
        !variableValueName
        !accessOperator
        !.literalInteger {!value:accessRightOperand}
        !mSourceVarName.location
      ]
      variableValueName = newResultingVariable 
      registerBitSliceMap = submap
      outExpressionType = newResultType
    else
      switch [outExpressionType kind]
        case boolean :
          error field : "a boolean does not handle field access"
        case boolset :
          error field : "a boolset does not handle field access"
        case literalString :
          error field : "a literal string does not handle field access"
        case enumeration (*) :
          error field : "an enumeration does not handle field access"
        case structure (@propertyMap propertyMap) :
          [propertyMap searchKey !field ?outExpressionType]
          getNewTempVariable (!?ioTemporaries ?let newResultingVariable)
#          ioInstructionGenerationList += !@fieldAccessIR.new {
#            !outExpressionType
#            !newResultingVariable
#            !resultingVariable
#            !field
#          }
          variableValueName = newResultingVariable 
        case integer (* * * *) :
          error field : "an integer does not handle field access"
      end    
    end
  end
#--- Generate code
  outResultValueName = variableValueName
}

#----------------------------------------------------------------------------------------------------------------------*
#! @fieldAccessIR
#----------------------------------------------------------------------------------------------------------------------*

class @fieldAccessIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mResult
  @variableKindIR mSource
  @lstring mField
}

#----------------------------------------------------------------------------------------------------------------------*

override method @fieldAccessIR llvmInstructionCode
  ?!@string ioCode
  ?let @generationContext unused inGenerationContext
  ?!@stringset unused ioIntrinsicsDeclarationSet
{
  ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
  ioCode += " = " +  [mSource mangledName] + "." + mangledNameForProperty (!name:mField.string) + " ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @fieldAccessIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mSource enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
