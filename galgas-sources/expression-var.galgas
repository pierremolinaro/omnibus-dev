#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @varInExpressionAST : @expressionAST {
  @lstring mSourceVarName
  @lstringlist mFieldNameList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································
  
  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let sourceVarName
    @lstringlist fieldNameList = {}
    repeat
    while
      $.$
      $identifier$ ?let fieldName
      fieldNameList += !fieldName
    end 
    outExpression = @varInExpressionAST.new {!sourceVarName !fieldNameList}
  }

  #·····················································································································
  
  rule <primary> !@expressionAST outExpression {
    $self$
    let sourceVarName = @lstring.new {!"self" !.here}
    @lstringlist fieldNameList = {}
    repeat
    while
      $.$
      $identifier$ ?let fieldName
      fieldNameList += !fieldName
    end 
    outExpression = @varInExpressionAST.new {!sourceVarName !fieldNameList}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @varInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mSourceVarName]
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @varInExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring unused inRoutineNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext unused inContext
  ?modes:let @stringset unused inModeSet
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@operandIR outResult
{
#--- Search variable
  [!?ioVariableMap searchForReadAccess
    !mSourceVarName
    ?let @unifiedTypeMap-proxy variableType
    ?let accessIsAllowed
    ?@objectInMemoryIR variableKind
    ?*
    ?@registerBitSliceAccessMap registerBitSliceMap
    ?2*
  ]
  if not accessIsAllowed then
    error mSourceVarName : "routine has no access right on the this variable"
  end
#--- Load variable
  [variableKind loadFromMemory
    !?temporary:ioTemporaries
    !?instructionListIR:ioInstructionGenerationList
    ?resultingValue:outResult
  ]
#--- Solve inferred type
  var expressionType = solveInferredType (
    !targetType:inOptionalTargetType
    !sourceType:variableType
    !errorLocation:mSourceVarName.location
  )
#--- Field ?
  for (field) in mFieldNameList do
    if [registerBitSliceMap count] > 0 then # It is a register
      [registerBitSliceMap searchKey
        !field
        ?let @llvmBinaryOperation accessOperator
        ?let @bigint accessRightOperand
        ?let submap
        ?let newResultType
       ]
    #--- Temp var
      getNewTempVariable (!newResultType !?ioTemporaries ?let newResultingVariable)
      [!?ioInstructionGenerationList appendBinaryOperation
        !newResultingVariable.mValue
        !outResult.mType
        !mSourceVarName.location
        !outResult.mValue
        !accessOperator
        !.literalInteger {!value:accessRightOperand}
      ]
      outResult = newResultingVariable 
      registerBitSliceMap = submap
    else
      switch [outResult.mType kind]
        case boolean :
          error field : "a boolean does not handle field access"
        case literalInteger :
          error field : "an integer does not handle field access"
        case boolset :
          error field : "a boolset does not handle field access"
        case literalString :
          error field : "a literal string does not handle field access"
        case enumeration (*) :
          error field : "an enumeration does not handle field access"
        case structure (@propertyMap propertyMap *) :
          [propertyMap searchKey !field ?let type ?let idx]
          getNewTempVariable (!type !?ioTemporaries ?let newResultingVariable)
          [!?ioInstructionGenerationList appendExtractValue
            !newResultingVariable
            !outResult
            !idx
           ]
           outResult = newResultingVariable 
        case integer (* * * *) :
          error field : "an integer does not handle field access"
      end    
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
