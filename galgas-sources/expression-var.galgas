#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @varInExpressionAST : @expressionAST {
  @lstring mSourceVarName
  @lstringlist mFieldNameList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let sourceVarName
    @lstringlist fieldNameList = {}
    repeat
    while
      $.$
      $identifier$ ?let fieldName
      fieldNameList += !fieldName
    end 
    outExpression = @varInExpressionAST.new {!sourceVarName !fieldNameList}
  }

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @varInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mSourceVarName]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @varInExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring unused inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType unused inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext unused inContext
  ?modes:let @stringset unused inModeSet
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResultValueName
{
#--- Search variable
  [!?ioVariableMap searchForReadAccess
    !mSourceVarName
    ?let variableType
    ?let accessIsAllowed
    ?let unused varAccess
    ?@variableKindIR resultingVariable
    ?*
    ?@registerBitSliceAccessMap registerBitSliceMap
    ?*
  ]
  if not accessIsAllowed then
    error mSourceVarName : "routine has no access right on the this variable"
  end
#--- Solve inferred type
  outExpressionType = solveInferredType (
    !targetType:inOptionalTargetType
    !sourceType:variableType
    !errorLocation:mSourceVarName.location
  )
#--- Field ?
  for (field) in mFieldNameList do
    if [registerBitSliceMap count] > 0 then # It is a register
      [registerBitSliceMap searchKey
        !field
        ?let @infixOperatorIR accessOperator
        ?let @variableKindIR accessRightOperand
        ?let submap
        ?let newResultType
       ]
    #--- Temp var
      getNewTempVariable (!?ioTemporaries ?let newResultingVariable)
      ioInstructionGenerationList += !@operatorInfixExpressionIR.new {
        !newResultType
        !newResultingVariable
        !resultingVariable
        !accessOperator
        !accessRightOperand
        !mSourceVarName.location
      }
      resultingVariable = newResultingVariable 
      registerBitSliceMap = submap
      outExpressionType = newResultType
    else
      switch [outExpressionType kind]
        case boolean :
          error field : "a boolean does not handle field access"
        case boolset :
          error field : "a boolset does not handle field access"
        case literalString :
          error field : "a literal string does not handle field access"
        case enumeration (*) :
          error field : "an enumeration does not handle field access"
        case structure (@propertyMap propertyMap) :
          [propertyMap searchKey !field ?outExpressionType]
          getNewTempVariable (!?ioTemporaries ?let newResultingVariable)
          ioInstructionGenerationList += !@fieldAccessIR.new {
            !outExpressionType
            !newResultingVariable
            !resultingVariable
            !field
          }
          resultingVariable = newResultingVariable 
        case integer (* * * *) :
          error field : "an integer does not handle field access"
      end    
    end
  end
#--- Generate code
  outResultValueName = resultingVariable
}

#----------------------------------------------------------------------------------------------------------------------*

class @fieldAccessIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mResult
  @variableKindIR mSource
  @lstring mField
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @fieldAccessIR instructionCode -> @string outCode {
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mSource mangledName] + "." + mangledNameForProperty (!name:mField.string) + " ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @fieldAccessIR llvmInstructionCode !@string outCode {
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mSource mangledName] + "." + mangledNameForProperty (!name:mField.string) + " ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @fieldAccessIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mSource enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
