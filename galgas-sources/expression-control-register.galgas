#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @registerInExpressionAST : @expressionAST {
  @controlRegisterLValueAST mControlRegisterLValue
  @lstring mFieldName # Empty string if no field access
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    <control_register_lvalue> !?ioAST ?let registerLValue
    @lstring fieldName
    select
      fieldName = ["" nowhere]
    or
      $:$
      $identifier$ ?fieldName
    end
  #--- AST
    outExpression = @registerInExpressionAST.new {!registerLValue !fieldName}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mControlRegisterLValue.mRegisterGroupName]
  [mControlRegisterLValue addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mControlRegisterLValue noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?safe:let @bool inIsSafe
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [mControlRegisterLValue controlRegisterLValueSemanticAnalysis
    !writeAccess:false
    !self: inSelfType
    !routineAttributes: inRoutineAttributes
    !context: inContext
    !mode: inMode
    !safe: inIsSafe
    !?temporary: ioTemporaries
    !?staticEntityMap: ioStaticEntityMap
    !?variableMap: ioUniversalMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?registerType:let registerType
    ?registerBitCount:*
    ?sliceMap:let sliceMap
    ?llvmRegisterAddressName:let llvmRegisterAddressName
  ]
#-------------------- Load register
  getNewTempValue (!registerType !?ioTemporaries ?outResult)
  [!?ioInstructionGenerationList appendLoadIndirectVolatileRegister !outResult !llvmRegisterAddressName]
#-------------------- Field access
  if mFieldName.string != "" then
    [sliceMap searchKey
      !mFieldName
      ?let @llvmBinaryOperation accessOperator
      ?let @bigint accessRightOperand
      ?let @PLMType resultType
    ]
    getNewTempValue (!resultType !?ioTemporaries ?let resultIR)
    [!?ioInstructionGenerationList appendBinaryOperation
      !resultIR
      ![outResult type]
      !mFieldName.location
      !outResult
      !accessOperator
      !.literalInteger {!type:staticIntegerType () !value:accessRightOperand}
    ]
    outResult = resultIR
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
