#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @registerIndexAST {
  case noIndex
  case index (@expressionAST index @location endOfIndex)
}

#·······················································································································

class @registerInExpressionAST : @expressionAST {
  @lstring mGroupName
  @lstring mRegisterName
  @registerIndexAST mRegisterIndex
  @lstring mFieldName # Empty string if no field access
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let registerGroupName
    $:$
    $identifier$ ?let registerName
  @registerIndexAST registerIndex
    select
      registerIndex = .noIndex
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      registerIndex = .index {!index:expression !endOfIndex:endOfIndex}
    end
    @lstring fieldName
    select
      fieldName = ["" nowhere]
    or
      $:$
      $identifier$ ?fieldName
    end
  #--- AST
    outExpression = @registerInExpressionAST.new {!registerGroupName !registerName !registerIndex !fieldName}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mGroupName]
  switch mRegisterIndex
  case noIndex :
  case index (@expressionAST indexExpression *) :
    [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  switch mRegisterIndex
  case noIndex :
  case index (@expressionAST indexExpression *) :
    [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [ioUniversalMap searchEntity !mGroupName ?let entity]
  switch entity
  case globalConstant (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case driver (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case globalSyncInstance (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case localConstant (3*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case localVariable (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case task (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case registerGroup (registerMap) :
    if [inRoutineAttributes guard] then
      error mGroupName : "control register is not readable in guard" : outResult
    elsif not [inRoutineAttributes controlRegisterReadable] then
      error mGroupName : "control register is not readable in this context" : outResult
    else
      analyzeRegisterExpression (
        !self: inSelfType
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !registerMap
        !mRegisterName
        !mRegisterIndex
        !mFieldName # Empty string if no field access
        ?result: outResult
      )
    end
  end
}

#·······················································································································

private proc analyzeRegisterExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @controlRegisterMap inControlRegisterMap
  ?let @lstring inRegisterName
  ?let @registerIndexAST inRegisterIndex
  ?let @lstring inFieldName # Empty string if no field access
  !result:@objectIR outResult
{
#-------------------- Search register in group
  [inControlRegisterMap searchKey
    !inRegisterName
    ?let @PLMType inRegisterType
    ?*
    ?let @bool userAccess
    ?let @sliceMap inRegisterSliceMap
    ?let @controlRegisterFieldMap unused mRegisterFieldMap
    ?let @controlRegisterGroupKind controlRegisterGroupKind
    ?let @controlRegisterFieldList unused mControlRegisterFieldList # Used for HTML file
    ?let @uint unused mRegisterBitCount
    ?let @uint inRegisterArraySize # 0 if not an array
    ?let @uint inRegisterElementSize # 0 if not an array
  ]
#-------------------- Register index
  switch inRegisterIndex
  case noIndex :
    getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
    switch controlRegisterGroupKind
    case single (registerAddress) :
      [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !registerAddress]
    end
  case index (@expressionAST indexExpression @location endOfIndex) :
    handleArraySubscriptNew (
       !self: inSelfType
       !routineAttributes:inRoutineAttributes
       !routineNameForInvocationGraph: inCallerNameForInvocationGraph
       !context: inContext
       !mode: inMode
       !?temporary: ioTemporaries
       !?staticEntityMap:ioStaticEntityMap
       !?variableMap: ioUniversalMap
       !?alloca: ioAllocaList
       !indexExpression 
       !endOfIndex
       !arraySize:inRegisterArraySize
       !elementType:inRegisterType
       !? ioInstructionGenerationList
       ?let @objectIR indexIR
    )
    if [indexIR isLiteralInteger] then # subscript expression is constant
      [indexIR literalInteger ?1* ?value:let @bigint idx]
      switch controlRegisterGroupKind
      case single (registerAddress) :
        let addr = registerAddress + idx * inRegisterElementSize
        getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
        [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !addr]
      end
    else
      getNewTempValue (!inRegisterType  !?ioTemporaries ?outResult)
      switch controlRegisterGroupKind
      case single (registerAddress) :
        [!?ioInstructionGenerationList appendLoadVolatileRegisterWithSubscript
          !outResult
          !indexIR
          !registerAddress
          !inRegisterElementSize
        ]
      end
    end
  end
#-------------------- Field access
  if inFieldName.string != "" then
    [inRegisterSliceMap searchKey
      !inFieldName
      ?let @llvmBinaryOperation accessOperator
      ?let @bigint accessRightOperand
      ?*
      ?let @PLMType resultType
    ]
    getNewTempValue (!resultType !?ioTemporaries ?let resultIR)
    [!?ioInstructionGenerationList appendBinaryOperation
      !resultIR
      ![outResult type]
      !inFieldName.location
      !outResult
      !accessOperator
      !.literalInteger {!type:staticIntegerType () !value:accessRightOperand}
    ]
    outResult = resultIR
  end
#-------------------- User mode ?
  if not userAccess && ([inMode isUserMode] || [inMode isAnyMode]) then
    error inRegisterName : "this control register is not accessible in user mode" : outResult
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
