#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @registerIndexAST {
  case noIndex
  case index (@expressionAST index @location endOfIndex)
}

#·······················································································································

class @registerInExpressionAST : @expressionAST {
  @lstring mGroupName
  @lstring mRegisterName
  @registerIndexAST mRegisterIndex
  @lstring mFieldName # Empty string if no field access
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let registerGroupName
    $:$
    $identifier$ ?let registerName
  @registerIndexAST registerIndex
    select
      registerIndex = .noIndex
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      registerIndex = .index {!index:expression !endOfIndex:endOfIndex}
    end
    @lstring fieldName
    select
      fieldName = ["" nowhere]
    or
      $:$
      $identifier$ ?fieldName
    end
  #--- AST
    outExpression = @registerInExpressionAST.new {!registerGroupName !registerName !registerIndex !fieldName}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mGroupName]
  switch mRegisterIndex
  case noIndex :
  case index (@expressionAST indexExpression *) :
    [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  switch mRegisterIndex
  case noIndex :
  case index (@expressionAST indexExpression *) :
    [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [ioUniversalMap searchEntity !mGroupName ?let entity]
  @controlRegisterMap controlRegisterMap
  switch entity
  case globalConstant (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : controlRegisterMap
  case driver (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : controlRegisterMap
  case globalSyncInstance (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : controlRegisterMap
  case localConstant (3*) :
    error mGroupName : "the \":\" access is reserved for a control register" : controlRegisterMap
  case localVariable (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : controlRegisterMap
  case task (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : controlRegisterMap
  case registerGroup (registerMap) :
    if [inRoutineAttributes guard] then
      error mGroupName : "control register is not readable in guard" : controlRegisterMap
    elsif not [inRoutineAttributes controlRegisterReadable] then
      error mGroupName : "control register is not readable in this context" : controlRegisterMap
    else
      controlRegisterMap = registerMap
    end
  end
#-------------------- Search register in group
  [controlRegisterMap searchKey
    !mRegisterName
    ?let @PLMType registerType
    ?*
    ?let @bool userAccess
    ?let @sliceMap registerSliceMap
    ?*
    ?let @controlRegisterGroupKind controlRegisterGroupKind
    ?2*
    ?let @uint registerArraySize # 0 if not an array
    ?let @uint registerElementSize # 0 if not an array
  ]
#-------------------- Register index
  @string llvmName
  switch mRegisterIndex
  case noIndex :
    switch controlRegisterGroupKind
    case single (registerAddress) :
      let registerName = mGroupName.string + ":" + mRegisterName
      [!?ioInstructionGenerationList appendEnterRegisterAddress !?ioTemporaries ?llvmName !registerAddress !registerName]
    end
  case index (@expressionAST indexExpression @location endOfIndex) :
    handleArraySubscriptNew (
       !self: inSelfType
       !routineAttributes:inRoutineAttributes
       !routineNameForInvocationGraph: inCallerNameForInvocationGraph
       !context: inContext
       !mode: inMode
       !?temporary: ioTemporaries
       !?staticEntityMap:ioStaticEntityMap
       !?variableMap: ioUniversalMap
       !?alloca: ioAllocaList
       !indexExpression 
       !endOfIndex
       !arraySize:registerArraySize
       !elementType:registerType
       !? ioInstructionGenerationList
       ?let @objectIR indexIR
    )
    if [indexIR isLiteralInteger] then # subscript expression is constant
      [indexIR literalInteger ?1* ?value:let @bigint idx]
      switch controlRegisterGroupKind
      case single (registerAddress) :
        let addr = registerAddress + idx * registerElementSize
        let registerName = mGroupName.string + ":" + mRegisterName + "[" + idx + "]"
        [!?ioInstructionGenerationList appendEnterRegisterAddress !?ioTemporaries ?llvmName !addr !registerName]
      end
    else
      switch controlRegisterGroupKind
      case single (registerAddress) :
        [!?ioInstructionGenerationList appendComputeSubscriptedVolatileRegisterAddress
          !?ioTemporaries
          ?llvmName
          !indexIR
          !registerAddress
          !registerElementSize
        ]
      end
    end
  end
#-------------------- Load register
  getNewTempValue (!registerType !?ioTemporaries ?outResult)
  [!?ioInstructionGenerationList appendLoadIndirectVolatileRegister !outResult !llvmName]
#-------------------- Field access
  if mFieldName.string != "" then
    [registerSliceMap searchKey
      !mFieldName
      ?let @llvmBinaryOperation accessOperator
      ?let @bigint accessRightOperand
      ?*
      ?let @PLMType resultType
    ]
    getNewTempValue (!resultType !?ioTemporaries ?let resultIR)
    [!?ioInstructionGenerationList appendBinaryOperation
      !resultIR
      ![outResult type]
      !mFieldName.location
      !outResult
      !accessOperator
      !.literalInteger {!type:staticIntegerType () !value:accessRightOperand}
    ]
    outResult = resultIR
  end
#-------------------- User mode ?
  if not userAccess && ([inMode isUserMode] || [inMode isAnyMode]) then
    error mRegisterName : "this control register is not accessible in user mode" : outResult
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
