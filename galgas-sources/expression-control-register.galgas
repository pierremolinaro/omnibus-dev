#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @registerInExpressionAST : @expressionAST {
  @lstring mGroupName
#  @lstring mRegisterName
  @primaryInExpressionAccessListAST mAccessList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let registerGroupName
    $:$
    @primaryInExpressionAccessListAST accessList = {}
    $identifier$ ?let registerName
    accessList += !.register {!name:registerName}
    select
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      accessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    select
    or
      $:$
      $identifier$ ?let fieldName
      accessList += !.register {!name:fieldName}
    end
  #--- AST
    outExpression = @registerInExpressionAST.new {!registerGroupName !accessList}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
#  if mReceiverName.string != "" then
    [!?ioGraph addEdge !inConstantName !mGroupName]
#  end
  for (access) in mAccessList do
    switch access
    case register (*) :
    case integerSlice (2*) :
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case integerSlice (@lbigint low @lbigint high) :
      if high.bigint >= low.bigint then
        [!?ioGraph noteUINTType ![high.bigint - low.bigint + 1G uint] !low.location]
      end
    case register (*) :
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [ioUniversalMap searchEntity !mGroupName ?let entity]
  switch entity
  case globalConstant (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case driver (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case globalSyncInstance (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case localConstant (3*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case localVariable (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case task (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case registerGroup (registerMap) :
    if [inRoutineAttributes guard] then
      error mGroupName : "control register is not readable in guard" : outResult
    elsif not [inRoutineAttributes controlRegisterReadable] then
      error mGroupName : "control register is not readable in this context" : outResult
    else
      analyzeRegisterExpression (
        !self: inSelfType
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !registerMap
        !mGroupName.location
        !mAccessList
        ?result: outResult
      )
    end
  end
}

#·······················································································································

private proc analyzeRegisterExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @controlRegisterMap inControlRegisterMap
  ?let @location inErrorLocation
  ?let @primaryInExpressionAccessListAST inAccessList
  !result:@objectIR outResult
{
  if [inAccessList length] == 0 then # No subscript, no slice
    error inErrorLocation : "a control register group has no value" : outResult
  else
    var accessList = inAccessList
    [!?accessList popFirst ?let registerNameAsField]
    if not [registerNameAsField isRegister] then
      error inErrorLocation : "the control register group should be followed by a control register name" : outResult
    else
      [registerNameAsField register ?name:let controlRegisterName]
      [inControlRegisterMap searchKey
        !controlRegisterName
        ?let @PLMType inRegisterType
        ?*
        ?let @bool userAccess
        ?let @sliceMap inRegisterSliceMap
        ?let @controlRegisterFieldMap unused mRegisterFieldMap
        ?let @controlRegisterGroupKind controlRegisterGroupKind
        ?let @controlRegisterFieldList unused mControlRegisterFieldList # Used for HTML file
        ?let @uint unused mRegisterBitCount
        ?let @uint inRegisterArraySize # 0 if not an array
        ?let @uint inRegisterElementSize # 0 if not an array
      ]
      if not userAccess && ([inMode isUserMode] || [inMode isAnyMode]) then
        error controlRegisterName : "this control register is not accessible in user mode" : outResult
      elsif [accessList length] == 0 then # No subscript, no slice
        getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
        switch controlRegisterGroupKind
        case single (registerAddress) :
          [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !registerAddress]
        end
      elsif [[accessList mAccessAtIndex !0] isArrayAccess] then
        [!?accessList popFirst ?let first]
        [first arrayAccess ?index:let @expressionAST indexExpression ?endOfIndex:let @location endOfIndex]
        handleArraySubscriptNew (
           !self: inSelfType
           !routineAttributes:inRoutineAttributes
           !routineNameForInvocationGraph: inCallerNameForInvocationGraph
           !context: inContext
           !mode: inMode
           !?temporary: ioTemporaries
           !?staticEntityMap:ioStaticEntityMap
           !?variableMap: ioUniversalMap
           !?alloca: ioAllocaList
           !indexExpression 
           !endOfIndex
           !arraySize:inRegisterArraySize
           !elementType:inRegisterType
           !? ioInstructionGenerationList
           ?let @objectIR indexIR
        )
        if [indexIR isLiteralInteger] then # subscript expression is constant
          [indexIR literalInteger ?1* ?value:let @bigint idx]
          switch controlRegisterGroupKind
          case single (registerAddress) :
            let addr = registerAddress + idx * inRegisterElementSize
            getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
            [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !addr]
          end
        else
          getNewTempValue (!inRegisterType  !?ioTemporaries ?outResult)
          switch controlRegisterGroupKind
          case single (registerAddress) :
            [!?ioInstructionGenerationList appendLoadVolatileRegisterWithSubscript
              !outResult
              !indexIR
              !registerAddress
              !inRegisterElementSize
            ]
          end
        end
      else
        getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
        switch controlRegisterGroupKind
        case single (registerAddress) :
          [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !registerAddress]
        end
      end
    #--- Access list
      var currentSliceMap = inRegisterSliceMap
      var currentType = inRegisterType
      for (access) in accessList do
        switch access
        case integerSlice (@lbigint low *) :
          error low : "cannot extract a slice from a register"
        case property (@lstring propertyName) :
          error propertyName : "invalid prperty access"
        case register (@lstring registerName) :
          [currentSliceMap searchKey
            !registerName
            ?let @llvmBinaryOperation accessOperator
            ?let @bigint accessRightOperand
            ?let @sliceMap subMap
            ?let @PLMType resultType
          ]
          getNewTempValue (!resultType !?ioTemporaries ?let resultIR)
          [!?ioInstructionGenerationList appendBinaryOperation
            !resultIR
            ![outResult type]
            !registerName.location
            !outResult
            !accessOperator
            !.literalInteger {!type:staticIntegerType () !value:accessRightOperand}
          ]
          currentSliceMap = subMap
          currentType = resultType
          outResult = resultIR
        case arrayAccess (* @location endOfIndex) :
          error endOfIndex : "receiver is a control register, subscripting is invalid here"
        case funcCall (* * errorLocation) :
          error errorLocation : "receiver is a control register, cannot be used as a function"
        end
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
