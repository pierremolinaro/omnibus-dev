#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @registerInExpressionAST : @expressionAST {
  @lstring mGroupName
  @lstring mRegisterName
  @primaryInExpressionAccessListAST mAccessList
  @lstring mFieldName # Empty string if no field access
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let registerGroupName
    $:$
    $identifier$ ?let registerName
    @primaryInExpressionAccessListAST accessList = {}
    select
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      accessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    @lstring fieldName
    select
      fieldName = ["" nowhere]
    or
      $:$
      $identifier$ ?fieldName
#      accessList += !.register {!name:fieldName}
    end
  #--- AST
    outExpression = @registerInExpressionAST.new {!registerGroupName !registerName !accessList !fieldName}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mGroupName]
  for (access) in mAccessList do
    switch access
    case register (*) :
    case integerSlice (2*) :
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case integerSlice (@lbigint low @lbigint high) :
      if high.bigint >= low.bigint then
        [!?ioGraph noteUINTType ![high.bigint - low.bigint + 1G uint] !low.location]
      end
    case register (*) :
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @registerInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [ioUniversalMap searchEntity !mGroupName ?let entity]
  switch entity
  case globalConstant (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case driver (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case globalSyncInstance (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case localConstant (3*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case localVariable (2*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case task (*) :
    error mGroupName : "the \":\" access is reserved for a control register" : outResult
  case registerGroup (registerMap) :
    if [inRoutineAttributes guard] then
      error mGroupName : "control register is not readable in guard" : outResult
    elsif not [inRoutineAttributes controlRegisterReadable] then
      error mGroupName : "control register is not readable in this context" : outResult
    else
      analyzeRegisterExpression (
        !self: inSelfType
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !registerMap
        !mRegisterName
        !mAccessList
        !mFieldName # Empty string if no field access
        ?result: outResult
      )
    end
  end
}

#·······················································································································

private proc analyzeRegisterExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @controlRegisterMap inControlRegisterMap
  ?let @lstring inRegisterName
  ?let @primaryInExpressionAccessListAST inAccessList
  ?let @lstring inFieldName # Empty string if no field access
  !result:@objectIR outResult
{
  var accessList = inAccessList
  [inControlRegisterMap searchKey
    !inRegisterName
    ?let @PLMType inRegisterType
    ?*
    ?let @bool userAccess
    ?let @sliceMap inRegisterSliceMap
    ?let @controlRegisterFieldMap unused mRegisterFieldMap
    ?let @controlRegisterGroupKind controlRegisterGroupKind
    ?let @controlRegisterFieldList unused mControlRegisterFieldList # Used for HTML file
    ?let @uint unused mRegisterBitCount
    ?let @uint inRegisterArraySize # 0 if not an array
    ?let @uint inRegisterElementSize # 0 if not an array
  ]
  if not userAccess && ([inMode isUserMode] || [inMode isAnyMode]) then
    error inRegisterName : "this control register is not accessible in user mode" : outResult
  elsif [accessList length] == 0 then # No subscript, no slice
    getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
    switch controlRegisterGroupKind
    case single (registerAddress) :
      [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !registerAddress]
    end
  elsif [[accessList mAccessAtIndex !0] isArrayAccess] then
    [!?accessList popFirst ?let first]
    [first arrayAccess ?index:let @expressionAST indexExpression ?endOfIndex:let @location endOfIndex]
    handleArraySubscriptNew (
       !self: inSelfType
       !routineAttributes:inRoutineAttributes
       !routineNameForInvocationGraph: inCallerNameForInvocationGraph
       !context: inContext
       !mode: inMode
       !?temporary: ioTemporaries
       !?staticEntityMap:ioStaticEntityMap
       !?variableMap: ioUniversalMap
       !?alloca: ioAllocaList
       !indexExpression 
       !endOfIndex
       !arraySize:inRegisterArraySize
       !elementType:inRegisterType
       !? ioInstructionGenerationList
       ?let @objectIR indexIR
    )
    if [indexIR isLiteralInteger] then # subscript expression is constant
      [indexIR literalInteger ?1* ?value:let @bigint idx]
      switch controlRegisterGroupKind
      case single (registerAddress) :
        let addr = registerAddress + idx * inRegisterElementSize
        getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
        [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !addr]
      end
    else
      getNewTempValue (!inRegisterType  !?ioTemporaries ?outResult)
      switch controlRegisterGroupKind
      case single (registerAddress) :
        [!?ioInstructionGenerationList appendLoadVolatileRegisterWithSubscript
          !outResult
          !indexIR
          !registerAddress
          !inRegisterElementSize
        ]
      end
    end
  else
    getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
    switch controlRegisterGroupKind
    case single (registerAddress) :
      [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !registerAddress]
    end
  end
#---------- Field access
  if inFieldName.string != "" then
    [inRegisterSliceMap searchKey
      !inFieldName
      ?let @llvmBinaryOperation accessOperator
      ?let @bigint accessRightOperand
      ?*
      ?let @PLMType resultType
    ]
    getNewTempValue (!resultType !?ioTemporaries ?let resultIR)
    [!?ioInstructionGenerationList appendBinaryOperation
      !resultIR
      ![outResult type]
      !inFieldName.location
      !outResult
      !accessOperator
      !.literalInteger {!type:staticIntegerType () !value:accessRightOperand}
    ]
    outResult = resultIR
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
