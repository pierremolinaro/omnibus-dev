#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forLowerUpperBoundInstructionAST : @instructionAST {
  @lstring mVarName
  @lstring mTypeName
  @expressionAST mLowerBoundExpression
  @location mEndOf_lowerBoundExpression_instruction
  @expressionAST mUpperBoundExpression
  @location mEndOf_upperBoundExpression_instruction
  @instructionListAST mDoInstructionList
  @location mEndOf_do_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $for$
    @lstring varName
    select
      $_$
      varName = ["" here]
    or
      $identifier$ ?varName
    end
    $\$type$ ?let typeName
    $in$
    <expression> ?let @expressionAST lowerBoundExpression
    let endOf_lowerBoundExpression_instruction = @location.here
    $..<$
    <expression> ?let @expressionAST upperBoundExpression
    let endOf_upperBoundExpression_instruction = @location.here
    ${$
    <instructionList> ?let instructionList
    let endOfInstruction = @location.here
    $}$
    ioInstructionList += !@forLowerUpperBoundInstructionAST.new {
      !varName.location
      !varName
      !typeName
      !lowerBoundExpression
      !endOf_lowerBoundExpression_instruction
      !upperBoundExpression
      !endOf_upperBoundExpression_instruction
      !instructionList
      !endOfInstruction
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forLowerUpperBoundInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  if mTypeName.string != "" then
    let typeName = llvmRegularTypeMangledNameFromName (!mTypeName)
    [!?ioGraph noteNode !typeName]
  end
  [mDoInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  [mLowerBoundExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [mUpperBoundExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forLowerUpperBoundInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Get iterated element type
  let type = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTypeName} type]
  switch [type mKind]
  case boolean, void :
    error mTypeName : "an integer type is required here"
  case arrayType (* * * * * * *) :
    error mTypeName : "an integer type is required here"
  case enumeration (* * *) :
  case literalString :
    error mTypeName : "an integer type is required here"
  case opaque (* * * *) :
    error mTypeName : "an integer type is required here"
  case staticInteger :
    error mTypeName : "an integer type is required here"
  case structure (* * * * *) :
    error mTypeName : "an integer type is required here"
  case pointer (*) :
    error mTypeName : "an integer type is required here"
  case function (*) :
    error mTypeName : "an integer type is required here"
  case integer (@bigint unused min @bigint unused max @bool unsigned @uint unused bitCount *) :
  #--- Analyze expressions
    [mLowerBoundExpression analyzeExpression
      !self:inSelfType
      !inGuard:false
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !optionalTargetType:type
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?result:let @objectIR lowerBoundExpressionResultPossibleReference
    ]
    [!?ioInstructionGenerationList appendLoadWhenReference
      !?ioTemporaries
      !lowerBoundExpressionResultPossibleReference
      ?let lowerBoundExpressionResult
    ]  
    [mUpperBoundExpression analyzeExpression
      !self:inSelfType
      !inGuard:false
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !optionalTargetType:type
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?result:let @objectIR upperBoundExpressionResultPossibleReference
    ]
    [!?ioInstructionGenerationList appendLoadWhenReference
      !?ioTemporaries
      !upperBoundExpressionResultPossibleReference
      ?let upperBoundExpressionResult
    ]  
  #--- Check expression types
    let lowerBound = checkAssignmentCompatibility (
      !source:lowerBoundExpressionResult
      !targetAnnotationType:type
      !errorLocation:mEndOf_lowerBoundExpression_instruction
      !staticTypeAllowed:false
    )
    let upperBound = checkAssignmentCompatibility (
      !source:upperBoundExpressionResult
      !targetAnnotationType:type
      !errorLocation:mEndOf_upperBoundExpression_instruction
      !staticTypeAllowed:false
    )
  #---
    [!?ioUniversalMap openOverrideForRepeatBlock]
  #--- Enter iteration variable name
    let enumeratedVarName = @lstring.new {!mVarName.string + "." + ioTemporaries.mTemporaryIndex !mVarName}
    ioTemporaries.mTemporaryIndex ++
    ioAllocaList += !llvmNameForLocalVariable (!enumeratedVarName) ![type llvmTypeName]
    if mVarName.string != "" then
     [!?ioUniversalMap insertLocalConstant !mVarName !type !enumeratedVarName]
    end
  #--- Analyze instruction list
    @instructionListIR instructionGenerationList = {}
    [mDoInstructionList analyzeBranchInstructionList
      !self:inSelfType
      !propertiesAreMutable:inRoutineCanMutateProperties
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !endOfInstructionList:mEndOf_do_instruction
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:instructionGenerationList
    ]
    [!?ioUniversalMap closeOverride !mEndOf_do_instruction]
  #--- Code generation
    ioInstructionGenerationList += !@forLowerUpperBoundInstructionIR.new {
      !enumeratedVarName
      !type
      !unsigned
      !mEndOf_do_instruction
      !lowerBound
      !upperBound
      !instructionGenerationList
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forLowerUpperBoundInstructionIR : @abstractInstructionIR {
  @string mVarName
  @PLMType mType
  @bool mUnsigned
  @location mLocation
  @objectIR mLowerExpressionResult
  @objectIR mUpperExpressionResult
  @instructionListIR mInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#         for x in LOW ..< UP do INST end 
#  is implemented as:
#         x := LOW ; while x < UP do INST ; x := x + 1 end

override method @forLowerUpperBoundInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let llvmType = [mType llvmTypeName]
  let llvmVarName = llvmNameForLocalVariable (!mVarName)
  let testLabel = "for." + [mLocation locationIndex] + ".test"
  let loopLabel = "for." + [mLocation locationIndex] + ".loop"
  let endLabel  = "for." + [mLocation locationIndex] + ".end"
  let testResult = "%for." + [mLocation locationIndex] + ".test.result"
  let loadedVarName = "" + llvmNameForLocalVariable (!mVarName + ".loaded")
  let currentVarName = "" + llvmNameForLocalVariable (!mVarName + ".current")
  let nextVarName = "" + llvmNameForLocalVariable (!mVarName + ".next")
#--- Store LOW in x
  ioLLVMcode += "  store " + llvmType + " " + [mLowerExpressionResult llvmName] + ", " + llvmType + " * " + llvmVarName + "\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"
#--- Test
  ioLLVMcode += testLabel + ":\n"
  ioLLVMcode += "  " + loadedVarName + " = load " + llvmType + ", " + llvmType + " * " + llvmVarName + "\n"
  ioLLVMcode += "  " + testResult + " = icmp "
  ioLLVMcode += if mUnsigned then "ult" else "slt" end
  ioLLVMcode += " " + llvmType + " " + loadedVarName + ", " + [mUpperExpressionResult llvmName] + "\n"
  ioLLVMcode += "  br i1 " + testResult + ", label %" + loopLabel + ", label %" + endLabel + "\n\n"
#--- Loop  
  ioLLVMcode += loopLabel + ":\n"
  [mInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  ioLLVMcode += "  " + currentVarName + " = load " + llvmType + ", " + llvmType + " * " + llvmVarName + "\n"
  ioLLVMcode += "  " + nextVarName + " = add " + llvmType + " " + currentVarName + ", 1\n"
  ioLLVMcode += "  store " + llvmType + " " + nextVarName + ", " + llvmType + " * " + llvmVarName + "\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"
#--- End
  ioLLVMcode += endLabel + ":\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forLowerUpperBoundInstructionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
