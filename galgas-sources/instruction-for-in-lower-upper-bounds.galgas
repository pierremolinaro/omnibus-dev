#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forLowerUpperBoundInstructionAST : @instructionAST {
  @lstring mVarName
  @lstring mTypeName
  @expressionAST mLowerBoundExpression
  @location mEndOf_lowerBoundExpression_instruction
  @expressionAST mUpperBoundExpression
  @location mEndOf_upperBoundExpression_instruction
  @instructionListAST mDoInstructionList
  @location mEndOf_do_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $for$
    $identifier$ ?let varName
    $\$type$ ?let typeName
    $in$
    <expression> ?let @expressionAST lowerBoundExpression
    let endOf_lowerBoundExpression_instruction = @location.here
    $..<$
    <expression> ?let @expressionAST upperBoundExpression
    let endOf_upperBoundExpression_instruction = @location.here
    ${$
    <instructionList> ?let instructionList
    let endOfInstruction = @location.here
    $}$
    ioInstructionList += !varName.location !@forLowerUpperBoundInstructionAST.new {
      !varName
      !typeName
      !lowerBoundExpression
      !endOf_lowerBoundExpression_instruction
      !upperBoundExpression
      !endOf_upperBoundExpression_instruction
      !instructionList
      !endOfInstruction
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forLowerUpperBoundInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  if mTypeName.string != "" then
    let typeName = llvmRegularTypeMangledNameFromName (!mTypeName)
    [!?ioGraph noteNode !typeName]
  end
  [mDoInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  [mLowerBoundExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [mUpperBoundExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forLowerUpperBoundInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Get iterated element type
  let type = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTypeName}
  switch [type kind]
  case boolean :
    error mTypeName : "an integer type is required here"
  case arrayType (* * * * *) :
    error mTypeName : "an integer type is required here"
  case enumeration (* *) :
  case literalString :
    error mTypeName : "an integer type is required here"
  case opaque (* *) :
    error mTypeName : "an integer type is required here"
  case staticInteger :
    error mTypeName : "an integer type is required here"
  case structure (* * * *) :
    error mTypeName : "an integer type is required here"
  case function (*) :
    error mTypeName : "an integer type is required here"
  case integer (@bigint unused min @bigint unused max @bool unsigned @uint unused bitCount) :
  #--- Analyze expressions
    [mLowerBoundExpression analyzeExpression
      !self:inSelfType
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !inGuard:false
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !optionalTargetType:type
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?result:@objectIR lowerBoundExpressionResultPossibleReference
    ]
    [!?ioInstructionGenerationList appendLoadFromReference
      !?ioTemporaries
      !lowerBoundExpressionResultPossibleReference
      !mEndOf_lowerBoundExpression_instruction
      ?let lowerBoundExpressionResult
    ]  
    [mUpperBoundExpression analyzeExpression
      !self:inSelfType
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !inGuard:false
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !optionalTargetType:type
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?result:@objectIR upperBoundExpressionResultPossibleReference
    ]
    [!?ioInstructionGenerationList appendLoadFromReference
      !?ioTemporaries
      !upperBoundExpressionResultPossibleReference
      !mEndOf_upperBoundExpression_instruction
      ?let upperBoundExpressionResult
    ]  
  #--- Check expression types
    let lowerBound = checkAssignmentCompatibility (
      !source:lowerBoundExpressionResult
      !targetAnnotationType:type
      !errorLocation:mEndOf_lowerBoundExpression_instruction
      !staticTypeAllowed:false
    )
    let upperBound = checkAssignmentCompatibility (
      !source:upperBoundExpressionResult
      !targetAnnotationType:type
      !errorLocation:mEndOf_upperBoundExpression_instruction
      !staticTypeAllowed:false
    )
  #---
    let enumeratedVarLLVMName = @lstring.new {!mVarName.string + "." + ioTemporaries.mTemporaryIndex !mVarName}
    ioTemporaries.mTemporaryIndex ++
    ioAllocaList += !enumeratedVarLLVMName ![[type kind] llvmTypeName]
  #--- Analyze instruction list
    [!?ioVariableMap openOverrideForRepeatBlock]
    [!?ioVariableMap insertUsedConstant
      !lkey:mVarName
      !type:type
      !readAccessAllowed:true # Read access ok
      !objectIR:.localVariableReference {!type:type !plmName:enumeratedVarLLVMName}
      !copyable:true
      !canBeUsedAsInputParameter:false
    ]
    @instructionListIR instructionGenerationList = {}
    [mDoInstructionList analyzeBranchInstructionList
      !self:inSelfType
      !propertiesAreMutable:inRoutineCanMutateProperties
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !endOfInstructionList:mEndOf_do_instruction
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?alloca:ioAllocaList
      !?instructionListIR:instructionGenerationList
    ]
    [!?ioVariableMap closeOverride !mEndOf_do_instruction]
  #--- Code generation
    ioInstructionGenerationList += !@forLowerUpperBoundInstructionIR.new {
      !enumeratedVarLLVMName
      !type
      !unsigned
      !mEndOf_do_instruction
      !lowerBound
      !upperBound
      !instructionGenerationList
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forLowerUpperBoundInstructionIR : @abstractInstructionIR {
  @string mVarName
  @unifiedTypeMap-proxy mType
  @bool mUnsigned
  @location mLocation
  @objectIR mLowerExpressionResult
  @objectIR mUpperExpressionResult
  @instructionListIR mInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#         for x in LOW ..< UP do INST end 
#  is implemented as:
#         x := LOW ; while x < UP do INST ; x := x + 1 end

override method @forLowerUpperBoundInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let llvmType = [[mType kind] llvmTypeName]
  let llvmVarName = llvmNameForLocalVariable (!mVarName)
  let testLabel = "for." + [mLocation locationIndex] + ".test"
  let loopLabel = "for." + [mLocation locationIndex] + ".loop"
  let endLabel  = "for." + [mLocation locationIndex] + ".end"
  let testResult = "%for." + [mLocation locationIndex] + ".test.result"
  let loadedVarName = "%" + llvmNameForLocalVariable (!mVarName + ".loaded")
  let currentVarName = "%" + llvmNameForLocalVariable (!mVarName + ".current")
  let nextVarName = "%" + llvmNameForLocalVariable (!mVarName + ".next")
#--- Store LOW in x
  ioLLVMcode += "  store " + llvmType + " " + [mLowerExpressionResult llvmName] + ", " + llvmType + " * %" + llvmVarName + "\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"
#--- Test
  ioLLVMcode += testLabel + ":\n"
  ioLLVMcode += "  " + loadedVarName + " = load " + llvmType + ", " + llvmType + " * %" + llvmVarName + "\n"
  ioLLVMcode += "  " + testResult + " = icmp "
  ioLLVMcode += if mUnsigned then "ult" else "slt" end
  ioLLVMcode += " " + llvmType + " " + loadedVarName + ", " + [mUpperExpressionResult llvmName] + "\n"
  ioLLVMcode += "  br i1 " + testResult + ", label %" + loopLabel + ", label %" + endLabel + "\n\n"
#--- Loop  
  ioLLVMcode += loopLabel + ":\n"
  [mInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  ioLLVMcode += "  " + currentVarName + " = load " + llvmType + ", " + llvmType + " * %" + llvmVarName + "\n"
  ioLLVMcode += "  " + nextVarName + " = add " + llvmType + " " + currentVarName + ", 1\n"
  ioLLVMcode += "  store " + llvmType + " " + nextVarName + ", " + llvmType + " * %" + llvmVarName + "\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"
#--- End
  ioLLVMcode += endLabel + ":\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forLowerUpperBoundInstructionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
