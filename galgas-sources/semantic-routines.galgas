#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @routineFormalArgumentListIR {
  @procFormalArgumentPassingMode mFormalArgumentKind
  @PLMType mFormalArgumentType
  @string mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterFormalArguments
  ?context:let @semanticContext inContext
  ?let @routineFormalArgumentListAST inFormalArgumentPassingMode
  ?!@universalValuedObjectMap ioUniversalMap
  ?!@routineFormalArgumentListIR ioFormalArguments
  ?warningOnUnusedArgs:let @bool inUnusedWarning
{
  for (argumentKind selector formalArgumentTypeName formalArgumentName) in inFormalArgumentPassingMode do
    let typeProxy = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName} type]
    ioFormalArguments += !argumentKind !typeProxy !formalArgumentName.string
    switch argumentKind
    case input :
      if inUnusedWarning then
        [!?ioUniversalMap insertLocalConstant !formalArgumentName !true !typeProxy !formalArgumentName]
      else
        [!?ioUniversalMap insertUsedLocalConstant !formalArgumentName !typeProxy !formalArgumentName]
      end
    case inputOutput :
      if inUnusedWarning then
        [!?ioUniversalMap insertLocalVariable !formalArgumentName !typeProxy !formalArgumentName !.hasUnreadValue !true]
      else
        [!?ioUniversalMap insertLocalVariable !formalArgumentName !typeProxy !formalArgumentName !.hasReadValue !true]
      end
    case output :
      [!?ioUniversalMap insertLocalVariable !formalArgumentName !typeProxy !formalArgumentName !.noValue !true]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allocaList {
  @string mVarLLVMName
  @PLMType mLLVMType
  @bool mFormalInputArgument
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineListIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for procedure in self do
    ioGenerationAdds.mUniqueIndex = 0
    [procedure.mRoutine llvmCodeGeneration !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  end
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @allocaList generateAllocaList ?!@string ioLLVMcode {
  for (variable type *) in self do
    ioLLVMcode += "  " + variable + " = alloca " + [type llvmTypeName] + "\n"
  end
#--- Init ARC variables
  for (variable type formalInputArgument) in self do
    if [type.kind isDynamicArrayType] && not formalInputArgument then
      ioLLVMcode += ";--- init dynamic array type '" + variable + "'\n"
      ioLLVMcode += "  store " + [type llvmTypeName] + " null, " + [type llvmTypeName] + "* " + variable + " ; init ARC value\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
