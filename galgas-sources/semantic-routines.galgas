#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procFormalArgumentListForGeneration {
  @procFormalArgumentPassingMode mFormalArgumentKind
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @subprogramInvocationGraph (@lstringlist) {
  insert addNode error message "the '%K' subprogram is already declared at %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterFormalArguments
  ?context:let @semanticContext inContext
  ?let @procFormalArgumentList inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@namedObjectMap ioNamedObjectMap
  ?!@procFormalArgumentListForGeneration ioFormalArguments
{
  for (argumentKind selector formalArgumentTypeName formalArgumentName) in inFormalArgumentPassingMode do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    [!?ioNamedObjectMap insertKey
      !formalArgumentName
      !.localVariableReference {!type:typeProxy !plmName:formalArgumentName}
    ]
    ioFormalArguments += !argumentKind !typeProxy !formalArgumentName.string
    switch argumentKind
    case input :
      [!?ioVariableMap insertConstantInputFormalArgument
        !lkey:formalArgumentName
        !type:typeProxy
        !readAccessAllowed:true
        !objectIR:.localVariableReference {!type:typeProxy !plmName:formalArgumentName}
        !copyable:[typeProxy copyable]
        !canBeUsedAsInputParameter:true
      ]
    case inputOutput :
      [!?ioVariableMap insertInputOutputFormalArgument
        !lkey:formalArgumentName
        !type:typeProxy
        !readAccessAllowed:true
        !objectIR:.localVariableReference {!type:typeProxy !plmName:formalArgumentName}
        !copyable:[typeProxy copyable]
        !canBeUsedAsInputParameter:true
      ]
    case output :
      [!?ioVariableMap insertOutputFormalArgument
        !lkey:formalArgumentName
        !type:typeProxy
        !readAccessAllowed:true
        !objectIR:.localVariableReference {!type:typeProxy !plmName:formalArgumentName}
        !copyable:[typeProxy copyable]
        !canBeUsedAsInputParameter:true
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @accessKind {
  case noAccess
  case readAccess # privilegedModeAccess
  case readWriteAccess # userModeAccess
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc routineSemanticAnalysis
  ?receiverType:let @unifiedTypeMap-proxy inSelfType
  ?let @routineKind inRoutineKind
  ?let @lstringlist inRoutineModeList
  ?let @lstring inRoutineName
  ?let @procFormalArgumentList inRoutineFormalArgumentList
  ?returnTypeName:let @lstring inReturnTypeName
  ?let @instructionListAST inRoutineInstructionList
  ?let @location inEndOfRoutineDeclaration
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?warnIfUnused:let @bool inWarnIfUnused
  ?globalFunction:let @bool inGlobalFunction
  ?weakFunction:let @bool inWeakFunction
  ?registerAccess:let @accessKind inRegisterAccessKind
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check modes
  @stringset procedureModeSet = {}
  for mode in inRoutineModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    procedureModeSet += !mode.mValue.string
  end
#--- Mangled routine name
  var routineMangledName = if inSelfType == .null then
    inRoutineName
  else
    @lstring.new {!"$" + [inSelfType key] + "." + inRoutineName !inRoutineName.location}
  end
  routineMangledName.string += "("
  for (formalArgumentPassingMode selector * *) in inRoutineFormalArgumentList do
    routineMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  routineMangledName.string += ")"
#--- Variable map
  initialVariableMap (
    !routineNameForInvocation:routineMangledName.string
    !context:inContext
    !userMode:[procedureModeSet hasKey !userModeName ()]
    !registerAccess:inRegisterAccessKind
    !globalsAreConstant:false
    !returnTypeName:inReturnTypeName
    ?@variableMap variableMap
    ?@namedObjectMap namedObjectMap
  )
#--- Analyse formal arguments
  @procFormalArgumentListForGeneration formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !inRoutineFormalArgumentList
    !?variableMap
    !?namedObjectMap
    !?formalArguments
  )
#--- Enter subprogram invocation graph
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineMangledName.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineMangledName
      !routineMangledName
    ]
  end
#--- Analyze instruction list
  @allocaList allocaList = {}
  @instructionListIR instructionGenerationList = {}
  [inRoutineInstructionList analyzeRoutineInstructionList
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !propertiesAreMutable:inRoutineCanMutateProperties
    !routineNameForInvocationGraph:routineMangledName
    !context:inContext
    !modes:procedureModeSet
    !allowPanic:not [procedureModeSet hasKey !panicModeName ()]
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?namedObjectMap: namedObjectMap
    !?alloca:allocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [variableMap checkAutomatonStates !inEndOfRoutineDeclaration]
  drop variableMap
#--- Code generation
  let returnType = if inReturnTypeName.string == "" then
    @unifiedTypeMap-proxy.null
  else
    @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName}
  end
  if [ioIntermediateCodeStruct.mRoutineMapIR hasKey !routineMangledName.string] then
    let weak = [ioIntermediateCodeStruct.mRoutineMapIR mWeakForKey !routineMangledName.string]
    if inWeakFunction && not weak then
      # redefined weak procedure is ignored
    elsif inWeakFunction && weak then
      error routineMangledName : "this weak procedure overrides a weak procedure"
    elsif (not inWeakFunction) && weak then
      [!?ioIntermediateCodeStruct.mRoutineMapIR removeKey !routineMangledName ?11*] # Remove weak routine
      [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
        !routineMangledName
        !routineMangledName
        !formalArguments
        !allocaList
        !instructionGenerationList
        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
        !inWarnIfUnused
        !inWeakFunction
        !inGlobalFunction
        !inRoutineKind
        !returnType
        !false
      ]  
    else # (not weakProcedure) && (not weak)
      [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey # Raises a redefinition error
        !routineMangledName
        !routineMangledName
        !formalArguments
        !allocaList
        !instructionGenerationList
        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
        !inWarnIfUnused
        !inWeakFunction
        !inGlobalFunction
        !inRoutineKind
        !returnType
        !false
      ]
    end
  else
    [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
      !routineMangledName
      !routineMangledName
      !formalArguments
      !allocaList
      !instructionGenerationList
      ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
      !inWarnIfUnused
      !inWeakFunction
      !inGlobalFunction
      !inRoutineKind
      !returnType
      !false
    ]  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allocaList {
  @string mVarName
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for procedure in self do
    [procedure llvmCodeGeneration !?ioLLVMcode !?ioAssemblerCode !inGenerationContext !?ioGenerationAdds]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string unused ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  @string routineName
  switch mKind
  case function : routineName = llvmNameForFunction (!mRoutineNameForGeneration.string)
  case section : routineName = llvmNameForSectionImplementation (!mRoutineNameForGeneration.string)
  case service : routineName = llvmNameForServiceImplementation (!mRoutineNameForGeneration.string)
  case primitive : routineName = llvmNameForPrimitiveImplementation (!mRoutineNameForGeneration.string)
  end
  ioLLVMcode += llvmTitleComment (!routineName)
  ioLLVMcode += "define"
  if not mGlobal then
    ioLLVMcode += " internal"
  end
  if mReturnType == .null then
    ioLLVMcode += " void"
  else
    ioLLVMcode += " " + [mReturnType llvmTypeName]
  end
  ioLLVMcode += " @" + routineName + " ("
  let receiverTypeName = [lkey.string stringByDeletingPathExtension]
  var first = true
  if receiverTypeName != "" then
    ioLLVMcode += "%" + [receiverTypeName assemblerRepresentation] + " * %self"
    first = false
  end
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  if not [option plm_options.noPanicGeneration value] && mAppendFileAndLineArgumentForPanicLocation then
    if not first then
      ioLLVMcode += ", "
    end
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " %LINE, i8* %FILE"
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
#--- Add result variable ?
  if mReturnType != .null then
    ioLLVMcode += "  %" + llvmNameForLocalVariable (!functionResultVariableName ()) + " = alloca " + [mReturnType llvmTypeName] + "\n"
  end
  for (variable type) in mAllocaList do
    ioLLVMcode += "  %" + llvmNameForLocalVariable (!variable) + " = alloca " + [type llvmTypeName] + "\n"
  end
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  %" + llvmNameForLocalVariable (!mFormalArgumentName) + " = alloca " + llvmType + "\n"
    case output, inputOutput :
    end
  end
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + " * %" + llvmNameForLocalVariable (!mFormalArgumentName) + "\n"
    case output, inputOutput :
    end
  end
#--- Instruction list
  [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Epilog
  if mReturnType == .null then
    ioLLVMcode += "  ret void\n"
  else
    let resultVarLLVMName = "%" + llvmNameForLocalVariable (!functionResultVariableName ())
    ioLLVMcode += "  %result = load " + [mReturnType llvmTypeName] + ", " + [mReturnType llvmTypeName] + " * " + resultVarLLVMName + "\n"
    ioLLVMcode += "  ret " + [mReturnType llvmTypeName] + " %result\n"
  end
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
