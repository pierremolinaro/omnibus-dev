#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @routineFormalArgumentListIR {
  @procFormalArgumentPassingMode mFormalArgumentKind
  @PLMType mFormalArgumentType
  @string mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @subprogramInvocationGraph (@lstringlist) {
  insert addNode error message "the '%K' routine is already declared at %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterFormalArguments
  ?context:let @semanticContext inContext
  ?let @routineFormalArgumentListAST inFormalArgumentPassingMode
  ?!@universalValuedObjectMap ioUniversalMap
  ?!@routineFormalArgumentListIR ioFormalArguments
{
  for (argumentKind selector formalArgumentTypeName formalArgumentName) in inFormalArgumentPassingMode do
    let typeProxy = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName} type]
    ioFormalArguments += !argumentKind !typeProxy !formalArgumentName.string
    switch argumentKind
    case input :
      [!?ioUniversalMap insertLocalConstant !formalArgumentName !true !typeProxy !formalArgumentName]
    case inputOutput :
      [!?ioUniversalMap insertLocalVariable !formalArgumentName !typeProxy !formalArgumentName !.hasUnreadValue !true]
    case output :
      [!?ioUniversalMap insertLocalVariable !formalArgumentName !typeProxy !formalArgumentName !.noValue !true]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc routineSemanticAnalysis
  ?receiverType:let @PLMType inSelfType
  ?let @routineKind inRoutineKind
  ?let @mode inRoutineMode
  ?let @lstring inRoutineName
  ?let @routineFormalArgumentListAST inRoutineFormalArgumentList
  ?returnTypeName:let @lstring inReturnTypeName
  ?let @instructionListAST inRoutineInstructionList
  ?let @location inEndOfRoutineDeclaration
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?warnIfUnused:let @bool inWarnIfUnused
  ?globalFunction:let @bool inGlobalFunction
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Reset index to temporaries
  ioTemporaries.mTemporaryIndex = 0
#--- Mangled routine name
  let routineMangledName = routineMangledNameFromAST (
    !if inSelfType.kind == .void then "" else inSelfType.llvmBaseTypeName end
    !inRoutineName
    !inRoutineFormalArgumentList
  )
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
  if inReturnTypeName.string != "" then
    let resultVarName = @lstring.new {!functionResultVariableName () !inReturnTypeName.location}
    let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName} type]
    [!?universalMap insertLocalVariable !resultVarName !resultType !resultVarName !.noValue !true]
  end
#--- Analyse formal arguments
  @routineFormalArgumentListIR formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !inRoutineFormalArgumentList
    !?universalMap
    !?formalArguments
  )
#--- Enter subprogram invocation graph
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineMangledName.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineMangledName
      !routineMangledName
    ]
  end
#--- Analyze instruction list
  @allocaList allocaList = {}
  @instructionListIR instructionGenerationList = {}
  [inRoutineInstructionList analyzeRoutineInstructionList
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !routineNameForInvocationGraph:routineMangledName
    !context:inContext
    !mode:inRoutineMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
    !?variableMap:universalMap
    !?alloca:allocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState !?instructionGenerationList]
  [!?universalMap closeBranch !inEndOfRoutineDeclaration]
  [!?universalMap closeOverride !inEndOfRoutineDeclaration]
#--- Code generation
  let returnType = if inReturnTypeName.string == "" then
    voidType ()
  else
    [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName} type]
  end
  [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
    !routineMangledName
    !inSelfType
    !routineMangledName
    !formalArguments
    !allocaList
    !instructionGenerationList
    ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
    !inWarnIfUnused
    !inGlobalFunction
    !inRoutineKind
    !returnType
    !false
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allocaList {
  @string mVarLLVMName
  @PLMType mLLVMType
  @bool mFormalInputArgument
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for procedure in self do
    [procedure llvmCodeGeneration !?ioLLVMcode !?ioAssemblerCode !inGenerationContext !?ioGenerationAdds]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string unused ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  @string routineName
  switch mKind
  case function (*) : routineName = llvmNameForFunction (!mRoutineNameForGeneration.string)
  case section : routineName = llvmNameForSectionImplementation (!mRoutineNameForGeneration.string)
  case service : routineName = llvmNameForServiceImplementation (!mRoutineNameForGeneration.string)
  case primitive : routineName = llvmNameForPrimitiveImplementation (!mRoutineNameForGeneration.string)
  end
  ioLLVMcode += llvmTitleComment (!routineName)
  ioLLVMcode += "define"
  if not mExportedFunction then
    ioLLVMcode += " internal"
  end
  ioLLVMcode += " " + [mReturnType llvmTypeName]
  ioLLVMcode += " @" + routineName + " ("
  let receiverLLVMTypeName = if mReceiverType.kind == .void
    then ""
    else [mReceiverType llvmTypeName]
  end
  var first = true
  if receiverLLVMTypeName != "" then
    ioLLVMcode += receiverLLVMTypeName + "* " + llvmNameForSelf ()
    first = false
  end
  for () in mFormalArgumentListForGeneration do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  if not [option plm_options.noPanicGeneration value] && mAppendFileAndLineArgumentForPanicLocation then
    if not first then
      ioLLVMcode += ", "
    end
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " %LINE, i8* %FILE"
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
#--- Add result variable ?
  var allocaList = mAllocaList
  if mReturnType.kind != .void then
    allocaList += !llvmNameForLocalVariable (!functionResultVariableName ()) !mReturnType !false
  end
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      allocaList += !llvmNameForLocalVariable (!mFormalArgumentName) !mFormalArgumentType !true
    case output, inputOutput :
    end
  end
  [allocaList generateAllocaList !?ioLLVMcode]
#--- Copy input arguments and generate retain instructions for input arguments
#    Insulate input and input/output arguments
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += ";--------- Input argument '" + mFormalArgumentName + "'\n"
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + " * "
                 + llvmNameForLocalVariable (!mFormalArgumentName) + "\n"
      [mFormalArgumentType generateRetain !mFormalArgumentName !?ioLLVMcode !?ioGenerationAdds]
      if mKind == .section then
        [mFormalArgumentType generateInsulate !mFormalArgumentName !?ioLLVMcode !?ioGenerationAdds]
      end
    case inputOutput :
      if mKind == .section then
       ioLLVMcode += ";--------- Insulate input/output argument '" + mFormalArgumentName + "'\n"
       [mFormalArgumentType generateInsulate !mFormalArgumentName !?ioLLVMcode !?ioGenerationAdds]
      end
    case output :
    end
  end
#--- Instruction list
  ioLLVMcode += ";--------- Function instruction list\n"
  [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Generate release instructions for input arguments
#    Insulate output and input/output arguments
  ioLLVMcode += ";--------- Release input arguments\n"
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      [mFormalArgumentType generateRelease !mFormalArgumentName !?ioLLVMcode !?ioGenerationAdds]
    case inputOutput :
      if mKind == .section then
       ioLLVMcode += ";--------- Insulate input/output argument '" + mFormalArgumentName + "'\n"
       [mFormalArgumentType generateInsulate !mFormalArgumentName !?ioLLVMcode !?ioGenerationAdds]
      end
    case output :
      if mKind == .section then
       ioLLVMcode += ";--------- Insulate output argument '" + mFormalArgumentName + "'\n"
       [mFormalArgumentType generateInsulate !mFormalArgumentName !?ioLLVMcode !?ioGenerationAdds]
      end
    end
  end
#--- Epilog
  ioLLVMcode += ";--------- Return\n"
  if mReturnType.kind == .void then
    ioLLVMcode += "  ret void\n"
  else
    let resultVarLLVMName = llvmNameForLocalVariable (!functionResultVariableName ())
    ioLLVMcode += "  %result = load " + [mReturnType llvmTypeName] + ", " + [mReturnType llvmTypeName] + " * " + resultVarLLVMName + "\n"
    ioLLVMcode += "  ret " + [mReturnType llvmTypeName] + " %result\n"
  end
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @allocaList generateAllocaList ?!@string ioLLVMcode {
  for (variable type *) in self do
    ioLLVMcode += "  " + variable + " = alloca " + [type llvmTypeName] + "\n"
  end
#--- Init ARC variables
  for (variable type formalInputArgument) in self do
    if [type.kind isDynamicArrayType] && not formalInputArgument then
      ioLLVMcode += ";--- init dynamic array type '" + variable + "'\n"
      ioLLVMcode += "  store " + [type llvmTypeName] + " null, " + [type llvmTypeName] + "* " + variable + " ; init ARC value\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
