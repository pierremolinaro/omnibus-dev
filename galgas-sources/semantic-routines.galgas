#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procFormalArgumentListForGeneration {
  @procFormalArgumentPassingMode mFormalArgumentKind
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @subprogramInvocationGraph (@lstringlist) {
  insert addNode error message "the '%K' subprogram is already declared at %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterFormalArguments
  ?context:let @semanticContext inContext
  ?let @procFormalArgumentList inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@procFormalArgumentListForGeneration ioFormalArguments
{
  for (argumentKind selector formalArgumentTypeName formalArgumentName) in inFormalArgumentPassingMode do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    switch argumentKind
    case input :
      [!?ioVariableMap insertConstantInputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !true
        !true # Is constant
      ]
      ioFormalArguments += !argumentKind !typeProxy !llvmNameForLocalVariable (!formalArgumentName.string)
    case inputOutput :
      [!?ioVariableMap insertInputOutputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !true
        !false # Is not constant
      ]
      ioFormalArguments += !argumentKind !typeProxy !llvmNameForLocalVariable (!formalArgumentName.string)
    case output :
      [!?ioVariableMap insertOutputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !true
        !false # Is not constant
      ]
      ioFormalArguments += !argumentKind !typeProxy !llvmNameForLocalVariable (!formalArgumentName.string)
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc routineSemanticAnalysis
  ?receiverType:let @unifiedTypeMap-proxy inReceiverType
  ?let @routineKind inRoutineKind
  ?let @lstringlist inRoutineModeList
  ?let @lstring inRoutineName
  ?let @lstringlist inRoutineAttributeList
  ?let @procFormalArgumentList inRoutineFormalArgumentList
  ?let @instructionListAST inRoutineInstructionList
  ?let @location inEndOfRoutineDeclaration
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check modes
  @stringset procedureModeSet = {}
  for mode in inRoutineModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    procedureModeSet += !mode.mValue.string
  end
#--- Attributes
  var warnIfUnused = true
  var globalProcedure = false
  var weakProcedure = false
  var nullOnNoException = false
  for (attribute) in inRoutineAttributeList do
    if attribute.string == noWarningIfUnusedAttribute () then
      if not warnIfUnused then
        error attribute : "duplicate @" + noWarningIfUnusedAttribute () + " attribute"
      end
      warnIfUnused = false    
    elsif attribute.string == globalAttribute () then
      if globalProcedure then
        error attribute : "duplicate @" + globalAttribute () + " attribute"
      end
      globalProcedure = true    
    elsif attribute.string == weakAttribute () then
      if weakProcedure then
        error attribute : "duplicate @" + weakAttribute () + " attribute"
      end
      weakProcedure = true    
    elsif attribute.string == nullWhenPanicDisabledAttribute () then
      if nullOnNoException then
        error attribute : "duplicate @" + nullWhenPanicDisabledAttribute () + " attribute"
      end
      nullOnNoException = true    
    else
      error attribute : "unknown attribute; available attributes are @"
        + noWarningIfUnusedAttribute ()
        + ", @" + weakAttribute ()
        + ", @" + globalAttribute ()
    end
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineNameForInvocation:procNameForInvocationGraph (!inReceiverType !inRoutineName).string
    !context:inContext
    !userMode:[procedureModeSet hasKey !userModeName ()]
    !globalsAreConstant:false
  )
#--- Analyse formal arguments
  @procFormalArgumentListForGeneration formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !inRoutineFormalArgumentList
    !?variableMap
    !?formalArguments
  )
#--- Enter subprogram invocation graph
  @lstring routineNameForInvocationGraph
  switch inRoutineKind
  case procedure : routineNameForInvocationGraph = procNameForInvocationGraph (!inReceiverType !inRoutineName)
  case section : routineNameForInvocationGraph = sectionNameForInvocationGraph (!inReceiverType !inRoutineName)
  case service : routineNameForInvocationGraph = serviceNameForInvocationGraph (!inReceiverType !inRoutineName)
  end
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !inRoutineName
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [inRoutineInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !modes:procedureModeSet
    !allowException:not [procedureModeSet hasKey !panicModeName ()]
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !inEndOfRoutineDeclaration]
#--- Code generation
  let routineMangledName = if inReceiverType == .null then
    @lstring.new {!"." + inRoutineName !inRoutineName.location}
  else
    @lstring.new {!"$" + [inReceiverType key] + "." + inRoutineName !inRoutineName.location}
  end
  if [ioIntermediateCodeStruct.mRoutineMapIR hasKey !routineMangledName.string] then
    let weak = [ioIntermediateCodeStruct.mRoutineMapIR mWeakForKey !routineMangledName.string]
    if weakProcedure && not weak then
      # redefined weak procedure is ignored
    elsif weakProcedure && weak then
      error routineMangledName : "this weak procedure overrides a weak procedure"
    elsif (not weakProcedure) && weak then
      [!?ioIntermediateCodeStruct.mRoutineMapIR removeKey !routineMangledName ?8*] # Remove weak routine
      [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
        !routineMangledName
        !formalArguments
        !instructionGenerationList
        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
        !warnIfUnused
        !weakProcedure
        !nullOnNoException
        !globalProcedure
        !.procedure
      ]  
    else # (not weakProcedure) && (not weak)
      [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey # Raises a redefinition error
        !routineMangledName
        !formalArguments
        !instructionGenerationList
        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
        !warnIfUnused
        !weakProcedure
        !nullOnNoException
        !globalProcedure
        !.procedure
      ]
    end
  else
    [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
      !routineMangledName
      !formalArguments
      !instructionGenerationList
      ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
      !warnIfUnused
      !weakProcedure
      !nullOnNoException
      !globalProcedure
      !.procedure
    ]  
  end

#  if [ioIntermediateCodeStruct.mRoutineMapIR hasKey !routineMangledName.string] then
#    let weak = [ioIntermediateCodeStruct.mRoutineMapIR mWeakForKey !routineMangledName.string]
#    if weakProcedure && not weak then
#      # redefined weak procedure is ignored
#    elsif weakProcedure && weak then
#      error routineMangledName : "this weak procedure overrides a weak procedure"
#    elsif (not weakProcedure) && weak then
#      [!?ioIntermediateCodeStruct.mRoutineMapIR removeKey !routineMangledName ?8*] # Remove weak routine
#      [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
#        !routineMangledName
#        !formalArguments
#        !instructionGenerationList
#        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
#        !warnIfUnused
#        !weakProcedure
#        !nullOnNoException
#        !globalProcedure
#        !inRoutineKind
#      ]  
#    else # (not weakProcedure) && (not weak)
#      [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey # Raises a redefinition error
#        !routineMangledName
#        !formalArguments
#        !instructionGenerationList
#        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
#        !warnIfUnused
#        !weakProcedure
#        !nullOnNoException
#        !globalProcedure
#        !inRoutineKind
#      ]
#    end
#  else
#    [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
#      !routineMangledName
#      !formalArguments
#      !instructionGenerationList
#      ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
#      !warnIfUnused
#      !weakProcedure
#      !nullOnNoException
#      !globalProcedure
#      !inRoutineKind
#    ]  
#  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for procedure in self do
    if [inGenerationContext.mProceduresThatShouldNotBeGenerated hasKey !procedure.lkey.string] then
      [procedure llvmPrototypeGeneration !?ioLLVMcode]
    else
      [procedure llvmCodeGeneration !?ioLLVMcode !?ioAssemblerCode !inGenerationContext !?ioGenerationAdds]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR-element llvmPrototypeGeneration 
  ?!@string ioLLVMcode
{
  @string routineName
  switch mKind
  case procedure : routineName = llvmNameForProcedure (!lkey.string)
  case section : routineName = llvmNameForSectionImplementation (!lkey.string)
  case service : routineName = llvmNameForServiceImplementation (!lkey.string)
  end
  #--- In LLVM, declare routine as extern
  ioLLVMcode += llvmTitleComment (!"proc " + routineName)
  ioLLVMcode += "declare void @" + routineName + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ") nounwind ; defined in assembly code\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  @string routineName
  switch mKind
  case procedure : routineName = llvmNameForProcedure (!lkey.string)
  case section : routineName = llvmNameForSectionImplementation (!lkey.string)
  case service : routineName = llvmNameForServiceImplementation (!lkey.string)
  end
  if [option plm_options.noPanicGeneration value] && mNullOnNoException then
  #--- Generate in assembly code routine pointer as NULL value
    ioAssemblerCode += asSeparatorLine ()
    ioAssemblerCode += "  .global " + routineName + "\n"
    ioAssemblerCode += "  " + routineName + " = 0\n\n"
  #--- In LLVM, declare routine as extern
    ioLLVMcode += llvmTitleComment (!"proc " + routineName)
    ioLLVMcode += "declare void @" + routineName + " ("
    for () in mFormalArgumentListForGeneration
    do
      switch mFormalArgumentKind
      case input :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
      case output :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
     case inputOutput :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ") nounwind ; NULL in assembly code\n\n"
  else
    ioLLVMcode += llvmTitleComment (!"proc " + routineName)
    ioLLVMcode += "define"
    if not mGlobal then
      ioLLVMcode += " internal"
    end
    ioLLVMcode += " void @" + routineName + " ("
    for () in mFormalArgumentListForGeneration
    do
      switch mFormalArgumentKind
      case input :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
      case output :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
     case inputOutput :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ") nounwind {\n"
  #--- Store input arguments in memory
    for () in mFormalArgumentListForGeneration do
      switch mFormalArgumentKind
      case input :
        let llvmType = [mFormalArgumentType llvmTypeName]
        ioLLVMcode += "  %" + mFormalArgumentName + " = alloca " + [mFormalArgumentType llvmTypeName] + "\n"
        ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + "* %" + mFormalArgumentName + "\n"
      case output, inputOutput :
      end
    end
   
  #--- Instruction list
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  #--- Epilog
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
