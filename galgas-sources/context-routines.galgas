#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ROUTINE TYPED SIGNATURE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# La signature typée d'une routine est la liste du mode de passage, du sélecteur, du type de ses arguments formels.

list @routineTypedSignature {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @unifiedTypeMap-proxy mTypeProxy # Nécessaire car le type n'est pas forcément résolu au moment de la construction
}

#·······················································································································

getter @routineTypedSignature string -> @string {
  result = "("
  for (formalArgumentPassingMode selector *) in self do
    result += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ROUTINE SIGNATURE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# La signature d'une routine est une chaîne de caractères constituée :
#   - du caractère "(" ;
#   - pour chaque argument :
#       * du mode de passage de l'argument formel ("?", "?!" ou "!"),
#       * du sélecteur,
#       * du caractère ":"
#   - du caractère ")".
# Le couple (nom de routine, signature) est unique. Pour un nom de routine donné, la signature identifie la routine.
# La signature est facilement calculable à partir de la liste des paramètres formels ou de la liste des arguments
# effectifs d'un appel.

#·······················································································································

getter @routineFormalArgumentListAST routineSignature ?let @location inRoutineNameLocation -> @lstring {
  var key = "("
  for (formalArgumentPassingMode selector * *) in self do
    key += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  key += ")"
  result = .new {!key !inRoutineNameLocation}
}

#·······················································································································

getter @effectiveArgumentListAST routineSignature ?let @location inRoutineNameLocation -> @lstring {
  var key = ""
  key += "("
  for (passingMode selector) in self do
    key += [passingMode matchingFormalArgument] + selector + ":"
  end
  key += ")"
  result = .new {!key !inRoutineNameLocation}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @routineKind {
  case function (@mode executionMode)
  case section
  case service
  case primitive
}

#·······················································································································

getter @routineKind executionMode -> @mode {
  switch self
  case function (mode) : result = mode
  case section : result = .sectionMode
  case service : result = .serviceMode
  case primitive : result = .primitiveMode
  end
}

#·······················································································································

struct @routineDescriptor {
  @bool isPublic %selector # Routine is declared with "public"
  @bool exported %selector # Routine is declared with @exported attribute
  @string name %selector
  @string nameForLLVMGeneration %selector
  @routineKind routineKind %selector
  @routineTypedSignature signature %selector
  @unifiedTypeMap-proxy returnTypeProxy %selector # Nécessaire car le type n'est pas forcément résolu au moment de la construction 
  @bool canAccessProperties %selector # Routine is declared with @access attribute
  @bool canMutateProperties %selector # Routine is declared with @mutating attribute
  @bool safe %selector # Routine is declared with @safe attribute
}

#·······················································································································

func routineMangledNameFromAST ?let @string inReceiverTypeName
                               ?let @lstring inRoutineName
                               ?let @routineFormalArgumentListAST inFormalArgumentList -> @lstring
{
  var s = "func."
  if inReceiverTypeName != "" then
    s += inReceiverTypeName + "."
  end
  s += inRoutineName.string
  s += "("
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  s += ")"
  result = .new {!s !inRoutineName.location}
}

#·······················································································································

func routineMangledNameFromCall ?let @string inReceiverTypeName
                                ?let @lstring inRoutineName
                                ?let @effectiveArgumentListAST inEffectiveParameterList-> @lstring
{
  var s = "func."
  if inReceiverTypeName != "" then
    s += inReceiverTypeName + "."
  end
  s += inRoutineName.string
  s += "("
  for (passingMode selector) in inEffectiveParameterList do
    s += [passingMode matchingFormalArgument] + selector + ":"
  end
  s += ")"
  result = .new {!s !inRoutineName.location}
}

#·······················································································································

proc routineSignature ?!@unifiedTypeMap ioTypeMap
                      ?let @routineFormalArgumentListAST inFormalArgumentList
                      !@routineTypedSignature outSignature
{
  outSignature = {}
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !formalArgumentTypeName ?let typeProxy]
    outSignature += !formalArgumentPassingMode !selector !typeProxy
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! OLD
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Key is a mangled name: "type.routineName"; for standalone routine, ".routineName"
map @guardMapForContext {
  @bool mIsPublic
  @routineTypedSignature mSignature

  insert insertKey error message "the '%K' guard is already declared in %L"
  search searchKey error message "there is no '%K' guard"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
