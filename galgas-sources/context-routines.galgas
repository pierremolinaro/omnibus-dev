#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    B U I L D    S E M A N T I C    C O N T E X T                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @routineKind {
  case procedure
  case section
  case service
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Key is a mangled name: "type.routineName"; for standalone routine, ".routineName"
map @routineMapForContext {
  @bool mMutating
  @modeMap mModeMap
  @procedureSignature mSignature
  @routineKind mRoutineKind
  @bool mWeak

  insert insertKey error message "the '%K' routine is already declared in %L"
  search searchKey error message "there is no '%K' routine"
  remove removeKey error message "there is no '%K' routine"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @procedureDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mServiceFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mServiceInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @sectionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mSectionFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mSectionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procedureSignature {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @string mSelector
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @procedureDeclarationListAST enterInContext 
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for procedure in self do
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in procedure.mProcFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
  #--- Mode map
    @modeMap procedureModeMap = {}
    for () in procedure.mProcedureModeList do
      [!?procedureModeMap insertKey !mValue] ;
    end
  #--- Weak procedure ?
    var weakProcedure = false
    for (attribute) in procedure.mProcedureAttributeList while not weakProcedure do
      weakProcedure = attribute.string == weakAttribute ()
    end
  #--- Enter in context
    let lkey = @lstring.new {!inReceiverTypeName + "." + procedure.mProcedureName !procedure.mProcedureName.location}
    if [ioContext.mRoutineMapForContext hasKey !lkey.string] then
      let weak = [ioContext.mRoutineMapForContext mWeakForKey !lkey.string]
      if weakProcedure && not weak then
        # redefined weak procedure is ignored
      elsif weakProcedure && weak then
        error procedure.mProcedureName : "this weak procedure overrides a weak procedure"
      elsif (not weakProcedure) && weak then
        [!?ioContext.mRoutineMapForContext removeKey !lkey ?5*] # Remove weak routine
        [!?ioContext.mRoutineMapForContext insertKey # Insert routine
          !lkey
          !false # not mutating
          !procedureModeMap
          !signature
          !.procedure
          !weakProcedure
        ]
      else # (not weakProcedure) && (not weak)
        [!?ioContext.mRoutineMapForContext insertKey # Raises a redefinition error
          !lkey
          !false # not mutating
          !procedureModeMap
          !signature
          !.procedure
          !weakProcedure
        ]
      end
    else
      [!?ioContext.mRoutineMapForContext insertKey
        !lkey
        !false # not mutating
        !procedureModeMap
        !signature
        !.procedure
        !weakProcedure
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for service in self do
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in service.mServiceFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
  #--- Enter in context
    [!?ioContext.mRoutineMapForContext insertKey
      !@lstring.new {!inReceiverTypeName + "." + service.mServiceName !service.mServiceName.location}
      !true # service.mMutating
      !@modeMap {![userModeName () nowhere]}
      !signature
      !.service
      !false # Not weak
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @sectionDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for section in self do
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in section.mSectionFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
  #--- Enter in context
    [!?ioContext.mRoutineMapForContext insertKey
      !@lstring.new {!inReceiverTypeName + "." + section.mSectionName !section.mSectionName.location}
      !true # section.mMutating
      !@modeMap {![userModeName () nowhere]}
      !signature
      !.section
      !false # Not weak
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
