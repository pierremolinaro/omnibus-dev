#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    B U I L D    S E M A N T I C    C O N T E X T                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @routineKind {
  case function
  case section
  case service
  case primitive
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Key is a mangled name: "type.routineName"; for standalone routine, ".routineName"
map @routineMapForContext {
  @bool mIsPublic
  @modeMap mModeMap
  @procedureSignature mSignature
  @routineKind mRoutineKind
  @bool mWeak
  @unifiedTypeMap-proxy mReturnType

  insert insertKey error message "the '%K' routine is already declared in %L"
  search searchKey error message "there is no '%K' routine"
  remove removeKey error message "there is no '%K' routine"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Key is a mangled name: "type.routineName"; for standalone routine, ".routineName"
map @guardMapForContext {
  @bool mIsPublic
  @procedureSignature mSignature

  insert insertKey error message "the '%K' guard is already declared in %L"
  search searchKey error message "there is no '%K' guard"
  remove removeKey error message "there is no '%K' guard"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @procedureDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mProcedureFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mProcedureInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @sectionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mSectionFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mSectionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procedureSignature {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @string mSelector
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @procedureDeclarationListAST enterInContext 
  ?selfTypeName:let @string inSelfTypeName
  ?!context:@semanticContext ioContext
{
  for procedure in self do
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in procedure.mProcedureFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
  #--- Return type
    let returnType = if procedure.mReturnTypeName.string == "" then
      @unifiedTypeMap-proxy.null
    else
      @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !procedure.mReturnTypeName}
    end
  #--- Mode map
    @modeMap procedureModeMap = {}
    for () in procedure.mProcedureModeList do
      [!?procedureModeMap insertKey !mValue] ;
    end
  #--- Weak procedure ?
    var weakProcedure = false
    for (attribute) in procedure.mProcedureAttributeList while not weakProcedure do
      weakProcedure = attribute.string == weakAttribute ()
    end
  #--- Enter in context
    let lkey = @lstring.new {!inSelfTypeName + "." + procedure.mProcedureName !procedure.mProcedureName.location}
    if [ioContext.mRoutineMapForContext hasKey !lkey.string] then
      let weak = [ioContext.mRoutineMapForContext mWeakForKey !lkey.string]
      if weakProcedure && not weak then
        # redefined weak procedure is ignored
      elsif weakProcedure && weak then
        error procedure.mProcedureName : "this weak procedure overrides a weak procedure"
      elsif (not weakProcedure) && weak then
        [!?ioContext.mRoutineMapForContext removeKey !lkey ?6*] # Remove weak routine
        [!?ioContext.mRoutineMapForContext insertKey # Insert routine
          !lkey
          !procedure.mPublic
          !procedureModeMap
          !signature
          !.function
          !weakProcedure
          !returnType
        ]
      else # (not weakProcedure) && (not weak)
        [!?ioContext.mRoutineMapForContext insertKey # Raises a redefinition error
          !lkey
          !procedure.mPublic
          !procedureModeMap
          !signature
          !.function
          !weakProcedure
          !returnType
        ]
      end
    else
      [!?ioContext.mRoutineMapForContext insertKey
        !lkey
        !procedure.mPublic
        !procedureModeMap
        !signature
        !.function
        !weakProcedure
        !returnType
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @sectionDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for section in self do
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in section.mSectionFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
    let returnType = if section.mReturnTypeName.string == "" then
      @unifiedTypeMap-proxy.null
    else
      @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !section.mReturnTypeName}
    end
  #--- Enter in context
    [!?ioContext.mRoutineMapForContext insertKey
      !@lstring.new {!inReceiverTypeName + "." + section.mSectionName !section.mSectionName.location}
      !section.mPublic
      !@modeMap {![userModeName () nowhere]}
      !signature
      !.section
      !false # Not weak
      !returnType
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
