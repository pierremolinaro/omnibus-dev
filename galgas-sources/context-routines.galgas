#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @routineDescriptor {
  @bool mIsPublic
  @bool mGlobal
  @routineKind mRoutineKind
  @mode mMode
  @procedureSignature mSignature
  @unifiedTypeMap-proxy mReturnType # .null if no returned value
  @bool mCanAccessProperties
  @bool mCanMutateProperties
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#map @newRoutineMapForContext { # Key is a routine name
#  @newRoutineSignatureMapForContext mSignatureMap
#
#  insert insertKey error message "the '%K' routine is already declared in %L"
#  search searchKey error message "there is no '%K' routine"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#map @newRoutineSignatureMapForContext { # Key is the signature name
#  @routineDescriptor mDescriptor
#
#  insert insertKey error message "the '%K' routine is already declared in %L"
#  search searchKey error message "there is no '%K' routine"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func routineMangledNameFromAST ?let @string inReceiverTypeName
                               ?let @lstring inRoutineName
                               ?let @procFormalArgumentList inFormalArgumentList-> @lstring
{
  result = if inReceiverTypeName == "" then
    inRoutineName
  else
    @lstring.new {!inReceiverTypeName + "." + inRoutineName !inRoutineName.location}
  end
  result.string += "("
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    result.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  result.string += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func routineMangledNameFromCall ?let @string inReceiverTypeName
                                ?let @lstring inRoutineName
                                ?let @effectiveParameterListAST inEffectiveParameterList-> @lstring
{
  result = if inReceiverTypeName == "" then
    inRoutineName
  else
    @lstring.new {!inReceiverTypeName + "." + inRoutineName !inRoutineName.location}
  end
  result.string += "("
  for (passingMode selector) in inEffectiveParameterList do
    result.string += [passingMode matchingFormalArgument] + selector + ":"
  end
  result.string += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc routineSignature ?!@unifiedTypeMap ioTypeMap
                      ?let @procFormalArgumentList inFormalArgumentList
                      !@procedureSignature outResult
{
  outResult = {}
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !formalArgumentTypeName ?let typeProxy]
    outResult += !formalArgumentPassingMode !selector !typeProxy
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func argumentSignatureFromFormalArgumentList ?let @location inRoutineNameLocation
                                             ?let @procFormalArgumentList inFormalArgumentList-> @lstring
{
  var key = ""
  key += "("
  for (formalArgumentPassingMode selector * *) in inFormalArgumentList do
    key += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  key += ")"
  result = .new {!key !inRoutineNameLocation}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#map @routineArgumentSignatureMapForContext { # Key is the argument signature
#  @lstring mRoutineLLVMName
#  @routineDescriptor mDescriptor
#
#  insert insertKey error message "the '%K' routine is already declared in %L"
#  search searchKey error message "there is no '%K' routine"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @routineMapForContext { # Key is a mangled name
  @lstring mArgumentSignature
  @lstring mRoutineLLVMName
  @routineDescriptor mDescriptor

  insert insertKey error message "the '%K' routine is already declared in %L"
  search searchKey error message "there is no '%K' routine"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#map @outineMapForContext { # Key is a mangled name
#  @lstring mRoutineLLVMName
#  @routineDescriptor mDescriptor
#
#  insert insertKey error message "the '%K' routine is already declared in %L"
#  search searchKey error message "there is no '%K' routine"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Key is a mangled name: "type.routineName"; for standalone routine, ".routineName"
map @guardMapForContext {
  @bool mIsPublic
  @procedureSignature mSignature

  insert insertKey error message "the '%K' guard is already declared in %L"
  search searchKey error message "there is no '%K' guard"
  remove removeKey error message "there is no '%K' guard"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procedureSignature {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
