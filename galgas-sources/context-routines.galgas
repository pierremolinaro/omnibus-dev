#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ROUTINE TYPED SIGNATURE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# La signature typée d'une routine est la liste du mode de passage, du sélecteur, du type de ses arguments formels.

list @routineTypedSignature {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @unifiedTypeMap-proxy mType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ROUTINE SIGNATURE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# La signature d'une routine est une chaîne de caractères constituée :
#   - du caractère "(" ;
#   - pour chaque argument :
#       * du mode de passage de l'argument formel,
#       * du sélecteur,
#       * du caractère ":"
#   - du caractère ")".
# Le couple (nom de routine, signature) est unique. Pour un nom de routine donné, la signature identifie la routine.
# La signature est facilement calculable à partir de la liste des paramètres formels ou de la liste des arguments
# effectifs d'un appel.

#·······················································································································

#getter @routineTypedSignature signatureAsLString ?let @location inRoutineNameLocation -> @lstring {
#  var s = "("
#  for argument in self do
#    s += [argument.mFormalArgumentPassingMode formalPassingModeString]
#    s += argument.mSelector.string
#    s += ":"
#  end
#  s += ")"
#  result = .new {!s !inRoutineNameLocation}
#}

#·······················································································································

getter @routineFormalArgumentList routineSignature ?let @location inRoutineNameLocation -> @lstring {
  var key = ""
  key += "("
  for (formalArgumentPassingMode selector * *) in self do
    key += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  key += ")"
  result = .new {!key !inRoutineNameLocation}
}

#·······················································································································

getter @effectiveArgumentListAST routineSignature ?let @location inRoutineNameLocation -> @lstring {
  var key = ""
  key += "("
  for (passingMode selector) in self do
    key += [passingMode matchingFormalArgument] + selector + ":"
  end
  key += ")"
  result = .new {!key !inRoutineNameLocation}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @routineKind {
  case function
  case section
  case safe
  case service
  case primitive
}

#·······················································································································

struct @routineDescriptor {
  @bool mIsPublic # Routine is declared with "public"
  @bool mExported # Routine is declared with @exported attribute
  @routineKind mRoutineKind
  @mode mExecutionMode
  @routineTypedSignature mSignature
  @unifiedTypeMap-proxy mReturnType # .null if no returned value
  @bool mCanAccessProperties
  @bool mCanMutateProperties # Routine is declared with @mutating attribute
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func routineMangledNameFromAST ?let @string inReceiverTypeName
                               ?let @lstring inRoutineName
                               ?let @routineFormalArgumentList inFormalArgumentList -> @lstring
{
  result = if inReceiverTypeName == "" then
    inRoutineName
  else
    @lstring.new {!inReceiverTypeName + "." + inRoutineName !inRoutineName.location}
  end
  result.string += "("
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    result.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  result.string += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func routineMangledNameFromCall ?let @string inReceiverTypeName
                                ?let @lstring inRoutineName
                                ?let @effectiveArgumentListAST inEffectiveParameterList-> @lstring
{
  result = if inReceiverTypeName == "" then
    inRoutineName
  else
    @lstring.new {!inReceiverTypeName + "." + inRoutineName !inRoutineName.location}
  end
  result.string += "("
  for (passingMode selector) in inEffectiveParameterList do
    result.string += [passingMode matchingFormalArgument] + selector + ":"
  end
  result.string += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc routineSignature ?!@unifiedTypeMap ioTypeMap
                      ?let @routineFormalArgumentList inFormalArgumentList
                      !@routineTypedSignature outResult
{
  outResult = {}
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !formalArgumentTypeName ?let typeProxy]
    outResult += !formalArgumentPassingMode !selector !typeProxy
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @routineArgumentSignatureMapForContext { # argument signature is the key
  @lstring mRoutineLLVMName
  @routineDescriptor mDescriptor

  insert insertKey error message "the '%K' routine signature is already declared in %L"
  search searchKey %location error message "there is no '%K' routine signature"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @internalRoutineMapForContext { # Key is a mangled name
  @routineArgumentSignatureMapForContext mRoutineArgumentSignatureMapForContext

  insert insertKey error message "the '%K' routine is already declared in %L"
  search searchKey error message "there is no '%K' routine"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @routineMapForContext {
  @internalRoutineMapForContext mInternalRoutineMapForContext
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @routineMapForContext insertKey
  ?let @lstring inRoutineName
  ?let @lstring inArgumentSignature
  ?let @lstring inRoutineLLVMName
  ?let @routineDescriptor inDescriptor
{
  with inRoutineName.string in !?mInternalRoutineMapForContext do
    [!?mRoutineArgumentSignatureMapForContext insertKey
      !inArgumentSignature
      !inRoutineLLVMName
      !inDescriptor
    ]
  else
    @routineArgumentSignatureMapForContext routineArgumentSignatureMapForContext = {}
    [!?routineArgumentSignatureMapForContext insertKey
      !inArgumentSignature
      !inRoutineLLVMName
      !inDescriptor
    ]
    [!?mInternalRoutineMapForContext insertKey !inRoutineName !routineArgumentSignatureMapForContext]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapForContext searchKey
  ?let @lstring inRoutineName
  ?let @lstring inArgumentSignature
  !@lstring outRoutineLLVMName
  !@routineDescriptor outDescriptor
  !@location outKeyLocation
{
  [mInternalRoutineMapForContext searchKey !inRoutineName ?let routineArgumentSignatureMapForContext]
  [routineArgumentSignatureMapForContext searchKey !inArgumentSignature ?outRoutineLLVMName ?outDescriptor ?outKeyLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @routineMapForContext hasKey ?let @lstring inRoutineName ?let @lstring inArgumentSignature -> @bool {
  result = [mInternalRoutineMapForContext hasKey !inRoutineName]
  if result then
    [mInternalRoutineMapForContext searchKey !inRoutineName ?let routineArgumentSignatureMapForContext]
    result = [routineArgumentSignatureMapForContext hasKey !inArgumentSignature]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

# Key is a mangled name: "type.routineName"; for standalone routine, ".routineName"
map @guardMapForContext {
  @bool mIsPublic
  @routineTypedSignature mSignature

  insert insertKey error message "the '%K' guard is already declared in %L"
  search searchKey error message "there is no '%K' guard"
  remove removeKey error message "there is no '%K' guard"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! UNIVERSAL PROPERTY - ROUTINE MAP
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# Cette table contient routines et variables. La clé est le nom de la variable ou le nom de la routine. Il est valide
# d'avoir plusieurs routines de même nom, du moment qu'elle se distinguent par leur signature. Il est valide d'avoir une
# variable de même nom qu'une routine : la syntaxe permet de savoir si une routine ou une variable est attendue.


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
