#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionDeclarationAST : @abstractDeclarationAST {
  @mode mMode
  @bool mPublicFunction
  @lstring mReceiverTypeName # Empty string if standalone
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @routineFormalArgumentListAST mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <function_declaration> ?!@ast ioAST ?receiverTypeName: let @lstring inReceiverTypeName {
  #--- Public ?
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition>!?ioAST  ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioAST.mDeclarationListAST += !@functionDeclarationAST.new {
      !mode
      !public
      !inReceiverTypeName
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
    }
  }

  #·····················································································································

  rule <mode> !@mode outMode {
    select
      outMode = .anyMode
    or
      $user$
      outMode = .userMode
    or
      $panic$
      outMode = .panicMode
    or
      $boot$
      outMode = .bootMode
    or
      $startup$
      outMode = .startupMode
    or
      $section$
      outMode = .sectionMode
    or
      $service$
      outMode = .serviceMode
    or
      $primitive$
      outMode = .primitiveMode
    or
      $guard$
      outMode = .guardMode
    or
      $safe$
      select
        outMode = .anySafeMode
      or
        $user$
        outMode = .safeUserMode
      or
        $section$
        outMode = .safeSectionMode
      or
        $service$
        outMode = .safeServiceMode
      or
        $primitive$
        outMode = .safePrimitiveMode
      or
        $guard$
        outMode = .safeGuardMode
      end
    end
  }

  #·····················································································································

  rule <function_header>
    ?!@ast ioAST
    !mode:@mode outMode
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@routineFormalArgumentListAST outProcFormalArgumentList
  {
    $func$
    $identifier$ ?outProcName
    <mode> ?outMode
    outAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?outProcFormalArgumentList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  var s = ""
  if mReceiverTypeName.string != "" then
    s += mReceiverTypeName.string + "."
  end
  s += mFunctionName.string + "("
  for (formalArgumentPassingMode selector * *) in mFunctionFormalArgumentList do
    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  s += ")"
  [!?ioGraph addNode !.new {!s !mFunctionName.location} !self]
#---
  for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
    [!?ioGraph noteNode !formalArgumentTypeName]
  end
  [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  if mReceiverTypeName.string != "" then
    [!?ioGraph noteNode !mReceiverTypeName]
  end
  if mFunctionReturnTypeName.string != "" then
    [!?ioGraph noteNode !mFunctionReturnTypeName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @functionDeclarationAST keyRepresentationForErrorSignaling -> @string {
  result = "function " + mReceiverTypeName + "." + mFunctionName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @functionDeclarationAST locationForErrorSignaling -> @location {
  result = mFunctionName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionDeclarationAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Signature
  routineTypedSignature (!?ioContext.mTypeMap !mFunctionFormalArgumentList ?let signature)
#--- Return type
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !mFunctionReturnTypeName ?let returnTypeProxy]
#--- Attributes
  var warnIfUnused = true
  var exportedFunction = false
  var canMutateProperties = false
  for (attribute) in mFunctionAttributeList do
    if attribute.string == noUnusedWarningAttribute () then
      if not warnIfUnused then
        error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
      end
      warnIfUnused = false    
    elsif attribute.string == exportedAttribute () then
      if exportedFunction then
        error attribute : "duplicated @" + exportedAttribute () + " attribute"
      end
      exportedFunction = true
    elsif attribute.string == mutatingAttribute () then
      if canMutateProperties then
        error attribute : "duplicated @" + mutatingAttribute () + " attribute"
      end
      canMutateProperties = true
    else
      error attribute : "unknown attribute; available attributes are @"
        + noUnusedWarningAttribute () + ", @" + noUnusedWarningAttribute () + " and @" + exportedAttribute ()
    end
  end
#--- Routine mangled name
  let functionLLVMName = routineMangledNameFromAST (
    !mReceiverTypeName.string
    !mFunctionName
    !mFunctionFormalArgumentList
  )
#---------------- Enter in routine map (for function availability)
  let routineLLVMNameDict = [mMode routineLLVMDictionaryForFunction !functionLLVMName]
  let routineMangledName = [signature mangledName !receiverTypeName: mReceiverTypeName.string !functionName: mFunctionName]
  [!?ioContext.mRoutineMap insertKey
    !routineMangledName
    !mPublicFunction
    !signature
    !returnTypeProxy
    !routineLLVMNameDict
    !exportedFunction
    !mMode
  ]
#---------------- Add decorated declaration (for function semantic analysis)
  ioDecoratedRoutineList +=
    !receiverTypeName: mReceiverTypeName
    !mode:mMode
    !isRequired:[ioContext.mRequiredRoutineSet hasKey !functionLLVMName.string]
    !routineKind: .function
    !warnIfUnused: warnIfUnused
    !exportedRoutine: exportedFunction
    !routineAttributes: .none
    !routineMangledLLVMName: functionLLVMName
    !formalArgumentList: mFunctionFormalArgumentList
    !warningOnUnusedArgs: true
    !mFunctionInstructionList
    !mEndOfFunctionDeclaration
    !returnTypeName: mFunctionReturnTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
