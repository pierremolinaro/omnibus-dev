#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionDeclarationAST : @abstractDeclarationAST {
  @mode mMode
  @bool mPublicFunction
  @lstring mReceiverTypeName # Empty string if standalone
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @routineFormalArgumentListAST mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <function_declaration> !?ioAST !receiverTypeName: ["" nowhere]
  }

  #·····················································································································

  rule <function_declaration> ?!@ast ioAST ?receiverTypeName: let @lstring inReceiverTypeName {
  #--- Public ?
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition>!?ioAST  ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioAST.mDeclarationListAST += !@functionDeclarationAST.new {
      !mode
      !public
      !inReceiverTypeName
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
    }
  }

  #·····················································································································

  rule <mode> !@mode outMode {
    select
      outMode = .anyMode
    or
      $user$
      outMode = .userMode
    or
      $panic$
      outMode = .panicMode
    or
      $boot$
      outMode = .bootMode
    or
      $startup$
      outMode = .startupMode
    or
      $section$
      outMode = .sectionMode
    or
      $service$
      outMode = .serviceMode
    or
      $primitive$
      outMode = .primitiveMode
    or
      $guard$
      outMode = .guardMode
    or
      $safe$
      select
        outMode = .anySafeMode
      or
        $user$
        outMode = .safeUserMode
      or
        $section$
        outMode = .safeSectionMode
      or
        $service$
        outMode = .safeServiceMode
      or
        $primitive$
        outMode = .safePrimitiveMode
      or
        $guard$
        outMode = .safeGuardMode
      end
    end
  }

  #·····················································································································

  rule <function_header>
    ?!@ast ioAST
    !mode:@mode outMode
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@routineFormalArgumentListAST outProcFormalArgumentList
  {
    $func$
    $identifier$ ?outProcName
    <mode> ?outMode
    outAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?outProcFormalArgumentList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  var s = ""
  if mReceiverTypeName.string != "" then
    s += mReceiverTypeName.string + "."
  end
  s += mFunctionName.string + "("
  for (formalArgumentPassingMode selector * *) in mFunctionFormalArgumentList do
    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  s += ")"
  let nodeName = @lstring.new {!s !mFunctionName.location}
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName !compileTimeDeclarationBarrier ()]
#---
  for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
    [!?ioGraph noteNode !formalArgumentTypeName]
  end
  [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  if mReceiverTypeName.string != "" then
    [!?ioGraph noteNode !mReceiverTypeName]
  end
  if mFunctionReturnTypeName.string != "" then
    [!?ioGraph noteNode !mFunctionReturnTypeName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @functionDeclarationAST keyRepresentationForErrorSignaling -> @string {
  result = "function " + mReceiverTypeName + "." + mFunctionName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @functionDeclarationAST locationForErrorSignaling -> @location {
  result = mFunctionName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionDeclarationAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Signature
  routineTypedSignature (!?ioContext.mTypeMap !mFunctionFormalArgumentList ?let signature)
#--- Return type
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !mFunctionReturnTypeName ?let returnTypeProxy]
#--- Attributes
  var warnIfUnused = true
  var exportedFunction = false
  var canMutateProperties = false
  for (attribute) in mFunctionAttributeList do
    if attribute.string == noUnusedWarningAttribute () then
      if not warnIfUnused then
        error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
      end
      warnIfUnused = false    
    elsif attribute.string == exportedAttribute () then
      if exportedFunction then
        error attribute : "duplicated @" + exportedAttribute () + " attribute"
      end
      exportedFunction = true
    elsif attribute.string == mutatingAttribute () then
      if canMutateProperties then
        error attribute : "duplicated @" + mutatingAttribute () + " attribute"
      end
      canMutateProperties = true
    else
      error attribute : "unknown attribute; available attributes are @"
        + noUnusedWarningAttribute () + ", @" + noUnusedWarningAttribute () + " and @" + exportedAttribute ()
    end
  end
#--- Routine mangled name
  let functionLLVMName = routineMangledNameFromAST (
    !mReceiverTypeName.string
    !mFunctionName
    !mFunctionFormalArgumentList
  )
#---------------- Enter in routine map (for function availability)
  let routineLLVMNameDict = [mMode routineLLVMDictionaryForFunction !functionLLVMName]
  let routineMangledName = [signature mangledName !receiverTypeName: mReceiverTypeName.string !functionName: mFunctionName]
  [!?ioContext.mRoutineMap insertKey
    !routineMangledName
    !mPublicFunction
    !signature
    !returnTypeProxy
    !routineLLVMNameDict
    !exportedFunction
    !mMode
  ]
#---------------- Add decorated declaration (for function semantic analysis)
  ioDecoratedRoutineList +=
    !receiverTypeName: mReceiverTypeName
    !mode:mMode
    !isRequired:[ioContext.mRequiredRoutineSet hasKey !functionLLVMName.string]
    !routineKind: .function
    !warnIfUnused: warnIfUnused
    !exportedRoutine: exportedFunction
    !routineAttributes: .none
    !routineMangledLLVMName: functionLLVMName
    !formalArgumentList: mFunctionFormalArgumentList
    !warningOnUnusedArgs: true
    !mFunctionInstructionList
    !mEndOfFunctionDeclaration
    !returnTypeName: mFunctionReturnTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ROUTINE MAP
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @routineMapForContext {
  @bool mIsPublic
  @routineTypedSignature mSignature
  @unifiedTypeMap-proxy mReturnTypeProxy # null if no returned value
  @routineLLVMNameDict mModeDictionary
  @bool mIsExported
  @mode mFunctionMode

  insert insertKey error message "the '%K' function is already declared in %L"
  search searchKey error message "there is no '%K' function"
}

#·······················································································································

dict @routineLLVMNameDict : @mode {
  @string mRoutineLLVMName
}

#·······················································································································

setter @propertyGetterMap addPropertyGetter
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?propertyName:let @lstring inPropertyName
  ?mode:let @mode inMode
  ?public:let @bool inPublic
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultTypeProxy
  !routineLLVMName:@lstring outRoutineLLVMName
{
  outRoutineLLVMName = .new {!getterLLVMName (!inLLVMBaseTypeName !inPropertyName) !inPropertyName}
  let modeDictionary = [inMode routineLLVMDictionaryForFunction !outRoutineLLVMName]
  [!?self insertKey
    !inPropertyName
    !inPublic
    !.computedProperty {!typeProxy:inResultTypeProxy !modeDictionary:modeDictionary}
  ]
}

#·······················································································································

setter @routineMapForContext addFunctionWithoutArgument
  ?omnibusTypeDescriptionName: let @string inOmnibusTypeDescriptionName
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @lstring inMethodName
  ?mode:let @mode inMode
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  !routineLLVMName:@lstring outRoutineLLVMName
{
  let @routineFormalArgumentListAST formalArguments = {}
  let routineMangledName = @lstring.new {
    !inOmnibusTypeDescriptionName + "." + inMethodName.string + [formalArguments routineSignature !inMethodName]
    !inMethodName
  }
  outRoutineLLVMName = routineMangledNameFromAST (!inLLVMBaseTypeName !inMethodName !formalArguments)
  let modeDictionary = [inMode routineLLVMDictionaryForFunction !outRoutineLLVMName]
  [!?self insertKey
    !routineMangledName
    !true
    !{}
    !inResultType
    !modeDictionary
    !false
    !inMode
  ]
}

#·······················································································································

setter @routineMapForContext addFunctionWithInputArgument
  ?omnibusTypeDescriptionName: let @string inOmnibusTypeDescriptionName
  ?!context:@semanticContext ioContext
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @lstring inMethodName
  ?mode:let @mode inMode
  ?inputArgumentSelector:let @string inInputSelector
  ?inputArgumentTypeProxy:let @unifiedTypeMap-proxy inInputArgumentTypeProxy
  ?inputArgumentName: let @string inInputArgumentName
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  !routineLLVMName:@lstring outRoutineLLVMName
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector nowhere]
    ![[inInputArgumentTypeProxy key] nowhere]
    ![inInputArgumentName nowhere]
  }
  routineTypedSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let routineMangledName = @lstring.new {
    !inOmnibusTypeDescriptionName + "." + inMethodName.string + [argumentList routineSignature !inMethodName]
    !inMethodName
  }
  outRoutineLLVMName = routineMangledNameFromAST (!inLLVMBaseTypeName !inMethodName !argumentList)
  let modeDictionary = [inMode routineLLVMDictionaryForFunction !outRoutineLLVMName]
  [!?self insertKey
    !routineMangledName
    !true
    !signature
    !inResultType
    !modeDictionary
    !false
    !inMode
  ]
}

#·······················································································································

setter @routineMapForContext addFunctionWithTwoInputArguments
  ?omnibusTypeDescriptionName: let @string inOmnibusTypeDescriptionName
  ?!context:@semanticContext ioContext
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @lstring inMethodName
  ?mode:let @mode inMode
  ?inputArgumentSelector1:let @string inInputSelector1
  ?inputArgumentTypeProxy1:let @unifiedTypeMap-proxy inInputArgumentTypeProxy1
  ?inputArgumentName1: let @string inInputArgumentName1
  ?inputArgumentSelector2:let @string inInputSelector2
  ?inputArgumentTypeProxy2:let @unifiedTypeMap-proxy inInputArgumentTypeProxy2
  ?inputArgumentName2: let @string inInputArgumentName2
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  !routineLLVMName:@lstring outRoutineLLVMName
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector1 nowhere]
    ![[inInputArgumentTypeProxy1 key] nowhere]
    ![inInputArgumentName1 nowhere]
  ,
    !.input
    ![inInputSelector2 nowhere]
    ![[inInputArgumentTypeProxy2 key] nowhere]
    ![inInputArgumentName2 nowhere]
  }
  outRoutineLLVMName = routineMangledNameFromAST (
    !inLLVMBaseTypeName
    !.new {!inMethodName !.nowhere}
    !argumentList
  )
  routineTypedSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let routineMangledName = @lstring.new {
    !inOmnibusTypeDescriptionName + "." + inMethodName.string + [argumentList routineSignature !inMethodName]
    !inMethodName
  }
  let modeDictionary = [inMode routineLLVMDictionaryForFunction !outRoutineLLVMName]
  [!?self insertKey
    !routineMangledName
    !true
    !signature
    !inResultType
    !modeDictionary
    !false
    !inMode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
