#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @staticArrayPropertyTypeAST {
  case valueType (@lstring type)
  case function (@mode mode @routineFormalArgumentList formalArgs @lstring returnType)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticArrayPropertyListAST {
  @lstring mPropertyName
  @staticArrayPropertyTypeAST mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticArrayAST : @abstractDeclarationAST {
  @lstring mStaticListName
  @staticArrayPropertyListAST mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticArrayAST location -> @location {
  result = mStaticListName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticArrayAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticArray$
    $identifier$ ?let staticListName
    ${$
    @staticArrayPropertyListAST propertyList = {}
    repeat
      <staticArrayProperty> !?propertyList
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticArrayAST.new {!staticListName !propertyList}
  }

  #·····················································································································

  rule <staticArrayProperty> ?!@staticArrayPropertyListAST ioPropertyList {
    $let$
    $identifier$ ?let propertyName
    select
      $\$type$ ?let typeName
      ioPropertyList += !propertyName !.valueType{!type:typeName}
    or
      $func$
      <mode> ?let mode
      <procedure_formal_arguments> ?formalArguments:let formalArgs
      @lstring returnType
      select
        returnType = ["" here]
      or
        $->$
        $\$type$ ?returnType
      end
      ioPropertyList += !propertyName !.function{!mode:mode !formalArgs:formalArgs !returnType:returnType}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add 'constant name' node
  [!?ioGraph addNode !mStaticListName !self]
#---
  for (* type) in mPropertyList do
    switch type
    case valueType (@lstring propertyTypeName) :
      let typeName = llvmRegularTypeMangledNameFromName (!propertyTypeName)
      [!?ioGraph addEdge !mStaticListName !typeName]
    case function (* @routineFormalArgumentList formalArgs @lstring returnType) :
      for (* * formalArgumentTypeName *) in formalArgs do
        let typeName = llvmRegularTypeMangledNameFromName(!formalArgumentTypeName)
        [!?ioGraph noteNode !typeName]
      end
      if returnType.string != "" then
        let returnTypeName = llvmRegularTypeMangledNameFromName (!returnType)
        [!?ioGraph addEdge !mStaticListName !returnTypeName]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @propertyList mStaticlistPropertyList

  insert insertKey error message "static list '%K' is already defined"
  search searchKey error message "static list '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  @propertyList propertyList = {}
  @propertyMap staticlistPropertyMap = {}
  @universalPropertyAndRoutineMapForContext universalMap = .default
  @stringset propertyNameSet = {}
  let plmTypeName = plmNameForStaticListElementType (!mStaticListName)
  for (propertyName type) in mPropertyList do (propertyIndex)
    switch type
    case valueType (@lstring propertyTypeName) :
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName} type]
      if [propertyNameSet hasKey !propertyName] then
        error propertyName : "duplicated property name"
      end
      propertyNameSet += !propertyName
      propertyList += !propertyName !propertyType
      let objectIR = @objectIR.property {!type:propertyType !plmName:propertyName !access:.indexed{!index:propertyIndex}}
      [!?universalMap insertProperty !propertyName !readOnly:true !public:true !objectIR]
      [!?staticlistPropertyMap insertKey
        !propertyName
        !true # Public
        !objectIR
      ]
    case function (@mode mode @routineFormalArgumentList formalArgs @lstring returnTypeName) :
    #--- Routine mangled name
      let routineMangledName = routineMangledNameFromAST (
        !"" 
        !propertyName
        !formalArgs
      )
    #--- Signature
      routineSignature (!?ioContext.mTypeMap !formalArgs ?let signature)
      let @unifiedTypeMap-proxy returnTypeProxy = if returnTypeName.string == "" then
        .null
      else
        @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !returnTypeName}
      end
      let type = @PLMType.function {!signature:signature !mode:mode !returnTypeProxy:returnTypeProxy}
      let descriptor = @routineDescriptor.new {
        !true
        !false
        !.function {!executionMode:mode}
        !signature
        !returnTypeProxy
        !false
        !false
        !.propertyIndirectCall {!type:type}
      }
      [!?universalMap insertRoutine
        !propertyName
        ![formalArgs routineSignature !propertyName]
        !routineMangledName
        !descriptor
      ]
      if not [ioContext.mTypeMap hasKey !routineMangledName] then
        [!?ioContext.mTypeMap insertType
          !lkey:routineMangledName
          !type:type
          !index:[ioContext.mTypeMap count]
        ]
      end
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !routineMangledName} type]
      propertyList += !propertyName !propertyType
      let propertyIndex = [staticlistPropertyMap count]
      [!?staticlistPropertyMap insertKey
        !propertyName
        !true # Public
        !.property {!type:propertyType !plmName:propertyName !access:.indexed{!index:propertyIndex}}
      ]
    end
  end
  [!?ioContext.mStaticlistMap insertKey !mStaticListName !propertyList]
#--- Enter element type in type map
  let kind = @PLMType.structure {
    !typeName:llvmNameForStaticListElementType (!mStaticListName)
    !propertyMap:staticlistPropertyMap
    !universalMap:universalMap
    !propertyList:propertyList
    !flags:.none
    !plmTypeName:mStaticListName
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmTypeName
    !type:kind
    !index:[ioContext.mTypeMap count]
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Generate property access
  let plmTypeName = plmNameForStaticListElementType (!mStaticListName)
  [inContext.mTypeMap searchKey !lkey:plmTypeName ?type:let type ?1*]
  generatePropertyAccess (!structureType:type !?intermediateCode:ioIntermediateCodeStruct)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
