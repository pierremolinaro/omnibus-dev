#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @staticArrayPropertyTypeAST {
  case valueType (@lstring type)
  case function (@mode mode @routineFormalArgumentList formalArgs @lstring returnType)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticArrayPropertyListAST {
  @lstring mPropertyName
  @staticArrayPropertyTypeAST mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticArrayAST : @abstractDeclarationAST {
  @lstring mStaticListName
  @staticArrayPropertyListAST mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticArrayAST location -> @location {
  result = mStaticListName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticArrayAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticArray$
    $identifier$ ?let staticListName
    ${$
    @staticArrayPropertyListAST propertyList = {}
    repeat
      <staticArrayProperty> !?propertyList
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticArrayAST.new {!staticListName !propertyList}
  }

  #·····················································································································

  rule <staticArrayProperty> ?!@staticArrayPropertyListAST ioPropertyList {
    $let$
    $identifier$ ?let propertyName
    select
      $\$type$ ?let typeName
      ioPropertyList += !propertyName !.valueType{!type:typeName}
    or
      $func$
      <mode> ?let mode
      <procedure_formal_arguments> ?formalArguments:let formalArgs
      @lstring returnType
      select
        returnType = ["" here]
      or
        $->$
        $\$type$ ?returnType
      end
      ioPropertyList += !propertyName !.function{!mode:mode !formalArgs:formalArgs !returnType:returnType}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add 'constant name' node
  [!?ioGraph addNode !mStaticListName !self]
#---
  for (* type) in mPropertyList do
    switch type
    case valueType (@lstring propertyTypeName) :
      let typeName = llvmRegularTypeMangledNameFromName (!propertyTypeName)
      [!?ioGraph addEdge !mStaticListName !typeName]
    case function (* @routineFormalArgumentList formalArgs @lstring returnType) :
      for (* * formalArgumentTypeName *) in formalArgs do
        let typeName = llvmRegularTypeMangledNameFromName(!formalArgumentTypeName)
        [!?ioGraph noteNode !typeName]
      end
      if returnType.string != "" then
        let returnTypeName = llvmRegularTypeMangledNameFromName (!returnType)
        [!?ioGraph addEdge !mStaticListName !returnTypeName]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @propertyList mStaticlistPropertyList

  insert insertKey error message "static list '%K' is already defined"
  search searchKey error message "static list '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @stringset propertyNameSet = {}
  let plmTypeName = plmNameForStaticListElementType (!mStaticListName)
  for (propertyName kind) in mPropertyList do (propertyIndex)
    switch kind
    case valueType (@lstring propertyTypeName) :
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName} type]
      if [propertyNameSet hasKey !propertyName] then
        error propertyName : "duplicated property name"
      else
        propertyNameSet += !propertyName
        propertyList += !propertyName !propertyType
        [!?propertyMap insertKey
          !propertyName
          !true # Public
          !.indexed{!type:propertyType !index:propertyIndex}
        ]
      end
    case function (@mode mode @routineFormalArgumentList formalArgs @lstring returnTypeName) :
    #--- Routine mangled name
      let routineMangledName = routineMangledNameFromAST (
        !"" 
        !propertyName
        !formalArgs
      )
    #--- Signature
      routineSignature (!?ioContext.mTypeMap !formalArgs ?let signature)
      let @unifiedTypeMap-proxy returnTypeProxy = if returnTypeName.string == "" then
        .null
      else
        @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !returnTypeName}
      end
      let descriptor = @routineDescriptor.new {
        !true # Routine is declared with "public"
        !false # Routine is declared with @exported attribute
        !.function {!executionMode:mode} # @routineKind mRoutineKind
        !signature
        !returnTypeProxy 
        !true # mCanAccessProperties # Routine is declared with @access attribute
        !true # mCanMutateProperties # Routine is declared with @mutating attribute
     }
     let type = @PLMType.function {!descriptor:descriptor}
      if not [ioContext.mTypeMap hasKey !routineMangledName] then
        [!?ioContext.mTypeMap insertType
          !lkey:routineMangledName
          !type:type
          !index:[ioContext.mTypeMap count]
        ]
      end
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !routineMangledName} type]
      propertyList += !propertyName !propertyType
      [!?propertyMap insertKey
        !routineMangledName # propertyName
        !true # Public
        !.indexed{!type:propertyType !index:propertyIndex}
      ]
    end
  end
  [!?ioContext.mStaticlistMap insertKey !mStaticListName !propertyList]
#--- Enter element type in type map
  let kind = @PLMType.structure {
    !typeName:llvmNameForStaticListElementType (!mStaticListName)
    !propertyMap:propertyMap
    !propertyList:propertyList
    !flags:.none
    !guardMap:{}
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmTypeName
    !type:kind
    !index:[ioContext.mTypeMap count]
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
