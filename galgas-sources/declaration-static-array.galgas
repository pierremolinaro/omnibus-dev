#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @staticArrayPropertyTypeAST {
  case valueType (@lstring type)
  case function (@mode mode @procFormalArgumentList formalArgs @lstring returnType)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @staticArrayPropertyListAST {
  @lstring mPropertyName
  @staticArrayPropertyTypeAST mPropertyType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticArrayAST : @abstractDeclaration {
  @lstring mStaticListName
  @staticArrayPropertyListAST mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticArrayAST location -> @location {
  result = mStaticListName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @staticArrayAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticArray$
    $identifier$ ?let staticListName
    ${$
    @staticArrayPropertyListAST propertyList = {}
    repeat
      $let$
      $identifier$ ?let propertyName
      select
        $\$type$ ?let typeName
        propertyList += !propertyName !.valueType{!type:typeName}
      or
        $func$
        <mode> ?let mode
        <procedure_formal_arguments> ?formalArguments:let formalArgs
        @lstring returnType
        select
          returnType = ["" here]
        or
          $->$
          $\$type$ ?returnType
        end
        propertyList += !propertyName !.function{!mode:mode !formalArgs:formalArgs !returnType:returnType}
      end
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticArrayAST.new {!staticListName !propertyList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add 'constant name' node
  [!?ioGraph addNode !mStaticListName !self]
#---
  for (* type) in mPropertyList do
    switch type
    case valueType (@lstring propertyTypeName) :
      let typeName = llvmRegularTypeMangledNameFromName (!propertyTypeName)
      [!?ioGraph addEdge !mStaticListName !typeName]
    case function (* @procFormalArgumentList formalArgs @lstring returnType) :
      for (* * formalArgumentTypeName *) in formalArgs do
        let typeName = llvmRegularTypeMangledNameFromName(!formalArgumentTypeName)
        [!?ioGraph noteNode !typeName]
      end
      if returnType.string != "" then
        let returnTypeName = llvmRegularTypeMangledNameFromName (!returnType)
        [!?ioGraph addEdge !mStaticListName !returnTypeName]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @propertyList mStaticlistPropertyList

  insert insertKey error message "static list '%K' is already defined"
  search searchKey error message "static list '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  @propertyList propertyList = {}
  @propertyMap staticlistPropertyMap = {}
  @stringset propertyNameSet = {}
  let plmTypeName = plmNameForStaticListElementType (!mStaticListName)
  for (propertyName type) in mPropertyList do
    switch type
    case valueType (@lstring propertyTypeName) :
      let propertyType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName}
      if [propertyNameSet hasKey !propertyName] then
        error propertyName : "duplicated property name"
      end
      propertyNameSet += !propertyName
      propertyList += !propertyName !propertyType
      let propertyIndex = [staticlistPropertyMap count]
      [!?staticlistPropertyMap insertKey
        !propertyName
        !true # Public
        !.property {!type:propertyType !plmName:propertyName !index:propertyIndex}
        !propertyIndex
      ]
    case function (@mode mode @procFormalArgumentList formalArgs @lstring returnTypeName) :
      var routineMangledName = propertyName.string + "("
      @procedureSignature signature = {}
      for (formalArgumentPassingMode selector formalArgumentTypeName *) in formalArgs do
        let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
        signature += !formalArgumentPassingMode !selector !typeProxy
        routineMangledName += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
                           + [[typeProxy kind] llvmTypeName]
      end
      routineMangledName += ")" + returnTypeName.string
      let @unifiedTypeMap-proxy returnTypeProxy = if returnTypeName.string == "" then
        .null
      else
        .searchKey {!ioContext.mTypeMap !returnTypeName}
      end
      let lRoutineMangledName = @lstring.new {!routineMangledName !propertyName.location}
      if not [ioContext.mTypeMap hasKey !lRoutineMangledName] then
        [!?ioContext.mTypeMap insertType
          !lkey:lRoutineMangledName
          !kind:.function{!mode:mode !signature:signature !returnTypeProxy:returnTypeProxy}
        ]
      end
      let propertyType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !lRoutineMangledName}
      propertyList += !propertyName !propertyType
      let propertyIndex = [staticlistPropertyMap count]
      [!?staticlistPropertyMap insertKey
        !propertyName
        !true # Public
        !.property {!type:propertyType !plmName:propertyName !index:propertyIndex}
        !propertyIndex
      ]
    end
  end
  [!?ioContext.mStaticlistMap insertKey
    !mStaticListName
    !propertyList
  ]
#--- Enter element type in type map
  let kind = @typeKind.structure {
    !typeName:llvmNameForStaticListElementType (!mStaticListName)
    !propertyMap:staticlistPropertyMap
    !propertyList:propertyList
    !flags:0
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmTypeName
    !kind:kind
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
