#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @staticListPropertyTypeAST {
  case valueType (@lstring type)
  case function (@mode mode @bool safe @routineFormalArgumentListAST formalArgs @lstring returnType)
}

#·······················································································································

list @staticListPropertyListAST {
  @lstring mPropertyName
  @staticListPropertyTypeAST mPropertyType
}

#·······················································································································

class @staticListAST : @abstractDeclarationAST {
  @lstring mStaticListName
  @staticListPropertyListAST mPropertyList
  @staticListValueListAST mValueList
}

#·······················································································································

list @staticListValueListAST {
  @extendStaticListElementListAST mExpressions
}

#·······················································································································

enum @extendStaticListExpressionAST {
  case expression (@expressionAST exp)
  case function (@lstring functionName @routineFormalArgumentListAST formalArgs)
}

#·······················································································································

list @extendStaticListElementListAST {
  @extendStaticListExpressionAST mExpression
  @location mEndOfExpression
}

#·······················································································································

list @extendStaticArrayDeclarationAST {
  @lstring mStaticListName
  @extendStaticListElementListAST mExpressions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $staticArray$
    $identifier$ ?let staticListName
    ${$
    @staticListPropertyListAST propertyList = {}
    repeat
      <staticArrayProperty>!?ioAST !?propertyList
    while
    end
    $}$
    ioAST.mDeclarationListAST += !@staticListAST.new {!staticListName !propertyList !{}}
  }

  #·····················································································································

  rule <staticArrayProperty> ?!@ast ioAST ?!@staticListPropertyListAST ioPropertyList {
    $let$
    $identifier$ ?let propertyName
    select
      <type_definition> !?ioAST ?let typeName
      ioPropertyList += !propertyName !.valueType{!type:typeName}
    or
      $func$
      <mode> ?let mode
      @lstringlist attributeList = {}
      repeat
      while
        $@attribute$ ?let attribute
        attributeList += !attribute
      end
      <procedure_formal_arguments> !?ioAST ?let formalArgs
      @lstring returnType
      select
        returnType = ["" here]
      or
        $->$
        <type_definition>!?ioAST ?returnType
      end
      var isSafe = false
      for (attribute) in attributeList do
        if attribute.string == safeAttribute () then
          if isSafe then
            error attribute : "duplicated attribute" fixit { remove }
          else
            isSafe = true
          end
        else
          error attribute : "invalid attribute" fixit {replace "@" + safeAttribute () }
        end
      end
      ioPropertyList += !propertyName !.function{!mode:mode !safe:isSafe !formalArgs:formalArgs !returnType:returnType}
    end
  }

  #·····················································································································
  # STATIC ARRAY VALUE
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticArray$
    $identifier$ ?let staticListName
    $($
    repeat
      @extendStaticListElementListAST expressions = {}
      repeat
        <staticArray_exp> !?ioAST !?expressions
      while
        $,$
      end
      ioAST.mExtendStaticArrayDeclarationAST += !staticListName !expressions
    while
      $::$
    end
    $)$
  }

  #·····················································································································

  rule <staticArray_exp> ?!@ast ioAST ?!@extendStaticListElementListAST ioExpressions {
    select
      <expression> !?ioAST ?let exp
      ioExpressions += !.expression {!exp:exp} !.here
    or
      $func$
      $identifier$ ?let functionName
      <procedure_formal_arguments> !?ioAST ?let formalArgs
      ioExpressions +=
        !.function {!functionName:functionName !formalArgs:formalArgs}
        !.here
    end
   }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticListAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add node
  [!?ioGraph addNode !mStaticListName !self]
#--- Add dependency edges for type declaration
  for (* type) in mPropertyList do
    switch type
    case valueType (@lstring propertyTypeName) :
      [!?ioGraph addEdge !mStaticListName !propertyTypeName]
    case function (* * @routineFormalArgumentListAST formalArgs @lstring returnType) :
      for (* * formalArgumentTypeName *) in formalArgs do
        [!?ioGraph noteNode !formalArgumentTypeName]
      end
      if returnType.string != "" then
        [!?ioGraph addEdge !mStaticListName !returnType]
      end
    end
  end
#--- Add dependency edge for static type values declarations
  for (value) in mValueList do
    for (operand *) in value do
      switch operand
      case expression (@expressionAST exp) :
        [exp addDependenceEdgeForStaticExpression !mStaticListName !?ioGraph]
      case function (* @routineFormalArgumentListAST formalArgs) :
        for (* * formalArgumentTypeName *) in formalArgs do
          [!?ioGraph noteNode !formalArgumentTypeName]
        end
      end
    end
  end
}

#·······················································································································

override getter @staticListAST location -> @location {
  result = mStaticListName.location
}

#·······················································································································

override getter @staticListAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticlistMap {
  @propertyList mStaticListPropertyList

  insert insertKey error message "static list '%K' is already defined"
}

#·······················································································································

map @staticListInitializationMap {
  @stringlist mInitializationList

  insert insertKey error message "static list '%K' is already defined"
}

#·······················································································································

override method @staticListAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  @stringset propertyNameSet = {}
  let plmElementTypeName = plmNameForStaticListElementType (!mStaticListName)
#-------------------------------------------------------------------- Build property list, map
  for (propertyName kind) in mPropertyList do (propertyIndex)
    switch kind
    case valueType (@lstring propertyTypeName) :
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !propertyTypeName} type]
      if [propertyNameSet hasKey !propertyName] then
        error propertyName : "duplicated property name"
      else
        propertyNameSet += !propertyName
        propertyList += !propertyName !propertyType
        [!?propertyMap insertKey
          !propertyName
          !true # Public
          !.indexed{!type:propertyType !index:propertyIndex}
        ]
      end
    case function (@mode mode @bool safe @routineFormalArgumentListAST formalArgs @lstring returnTypeName) :
    #--- Routine mangled name
      let routineMangledName = routineMangledNameFromAST (
        !"" 
        !propertyName
        !formalArgs
      )
    #--- Signature
      routineSignature (!?ioContext.mTypeMap !formalArgs ?let signature)
      let @unifiedTypeMap-proxy returnTypeProxy = if returnTypeName.string == "" then
        .null
      else
        @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !returnTypeName}
      end
      let descriptor = @routineDescriptor.new {
        !isPublic:true # Routine is declared with "public"
        !exported:false # Routine is declared with @exported attribute
        !name:propertyName
        !routineKind:.function {!executionMode:mode} # @routineKind mRoutineKind
        !signature:signature
        !returnTypeProxy:returnTypeProxy 
        !canAccessProperties:true # Routine is declared with @access attribute
        !canMutateProperties:true # Routine is declared with @mutating attribute
        !safe:safe # Routine is declared with @safe attribute
     }
     let type = functionType (!descriptor)
      if not [ioContext.mTypeMap hasKey !routineMangledName] then
        [!?ioContext.mTypeMap insertType
          !lkey:routineMangledName
          !type:type
          !index:[ioContext.mTypeMap count]
        ]
      end
      let propertyType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !routineMangledName} type]
      propertyList += !propertyName !propertyType
      [!?propertyMap insertKey
        !routineMangledName # propertyName
        !true # Public
        !.indexed{!type:propertyType !index:propertyIndex}
      ]
    end
  end
  [!?ioContext.mStaticListMap insertKey !mStaticListName !propertyList]
#-------------------------------------------------------------------- Enter element type in type map
  let type = @PLMType.new {
    !propertyMap:propertyMap
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.none
    !plmTypeDescriptionName:llvmNameForStaticListElementType (!mStaticListName)
    !kind:.structure {!propertyList:propertyList}
    !llvmBaseTypeName:llvmNameForStaticListElementType (!mStaticListName)
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmElementTypeName
    !type:type
    !index:[ioContext.mTypeMap count]
  ]
#-------------------------------------------------------------------- Enter static list values
  @stringlist stringValueList = {}
  for value in mValueList do
    if [propertyList length] != [value.mExpressions length] then
      error mStaticListName
      : [[propertyList length] string] + " expressions required, "
      + [[value.mExpressions length] string] + " provided"
    else
      var staticValue = "{"
      for (operand endOfExp) in value.mExpressions, (* type) in propertyList do
        switch operand
        case expression (@expressionAST exp) :
          if [type.kind isFunction] then
            error endOfExp : "a function name is expected here"
          else
            @semanticTemporariesStruct temporaries = .default
            @instructionListIR instructionGenerationList = {}
            @allocaList allocaList = {}
            [exp analyzeExpression
              !self:voidType ()
              !routineAttributes:.none
              !routineNameForInvocationGraph:["compiler" nowhere]
              !optionalTargetType:type
              !context:ioContext
              !mode:.bootMode
              !?temporary:temporaries
              !?staticEntityMap:ioStaticEntityMap
              !?variableMap:ioContext.mValuedObjectMap # universalMap
              !?alloca:allocaList
              !?instructionListIR:instructionGenerationList
              ?result:let @objectIR expressionResult
            ]
          #--- Check assignment compatibility
            let result = checkAssignmentCompatibility (
              !source:expressionResult
              !targetAnnotationType:type
              !errorLocation:endOfExp
              !staticTypeAllowed:false
            )
            if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [result isStatic] then
              error endOfExp : "source expression cannot be statically computed"
            end
          #--- Enter in static value
            staticValue += [type llvmTypeName] + " " + [expressionResult llvmName]
          end      
        case function (@lstring functionName @routineFormalArgumentListAST formalArgs) :
          if not [type.kind isFunction] then
            error endOfExp : "a static expression is expected here"
          else
            [type.kind function ?descriptor:let descriptor]
            let argumentSignature = [formalArgs routineSignature !functionName]
            [ioContext.mRoutineMapForContext searchKey
              !""
              !functionName
              !argumentSignature
              ?let @lstring candidateRoutineLLVMName
              ?let @routineDescriptor routineDescriptor
              ?let functionDefinitionLocation
            ]
            let candidateIsPublic = routineDescriptor.isPublic
            let candidateRoutineKind = routineDescriptor.routineKind
            let candidateMode = [routineDescriptor.routineKind executionMode]
            let candidateSignature = routineDescriptor.signature
            let candidateReturnTypeProxy = routineDescriptor.returnTypeProxy
          #--- Check accessibility
            if not candidateIsPublic then
              let declarationFile = [functionDefinitionLocation file]
              let invocationFile = [functionName.location file]
              if invocationFile != declarationFile then
                error functionName : "this function is not public"
              end
            end
            if not [candidateRoutineKind isFunction] then
              error functionName : "this routine is not a function"
            end
            let currentMode = [descriptor.routineKind executionMode]
            if currentMode != candidateMode then
              error functionName : "this function runs in " + candidateMode + " mode, but " + currentMode + " is required"
            end
            if (descriptor.returnTypeProxy == .null) && (candidateReturnTypeProxy != .null) then
              error functionName : "this function should return an $" + [candidateReturnTypeProxy key] + " object"
            elsif (descriptor.returnTypeProxy != .null) && (candidateReturnTypeProxy == .null) then
              error functionName : "this function should return no object"
            end
            if [descriptor.signature length] != [candidateSignature length] then
              error functionName
              : "this function has " + [candidateSignature length] + " argument(s) ("
              + [descriptor.signature length] + " required)"
            else
              for required in descriptor.signature, candidate in candidateSignature do
                if required.mTypeProxy != candidate.mTypeProxy then
                  error candidate.mSelector : "argument type should be $" + [required.mTypeProxy key]
                end
              end
            end
            staticValue += [type llvmTypeName] + " @" + llvmNameForFunction (!candidateRoutineLLVMName)
          end
        end
      between
        staticValue += ", "
      end
      staticValue += "}"
      stringValueList += !staticValue
    end
  end
  [!?ioStaticListValueMap insertKey !mStaticListName !stringValueList]
#-------------------------------------------------------------------- List type property map
  @propertyMap listTypePropertyMap = {}
  [!?listTypePropertyMap insertKey # "count" property
    !.new {!"count" !mStaticListName.location}
    !true # public
    !.constantProperty {!value:.literalInteger {!type:staticIntegerType () !value:[mValueList length]}}
  ]
#-------------------------------------------------------------------- Enter list type in type map
  let elementType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !plmElementTypeName} type]
  let arrayType = @PLMType.new {
    !propertyMap:listTypePropertyMap
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.instanciable | .equatable | .copyable | .generateAssignmentRoutine
    !plmTypeDescriptionName:plmNameForStaticListType (!mStaticListName)
    !kind:.arrayType {!elementType:elementType !size:[stringValueList length]}
    !llvmBaseTypeName:plmNameForStaticListType (!mStaticListName)
  }
  [!?ioContext.mTypeMap insertType
    !lkey:plmNameForStaticListType (!mStaticListName)
    !type:arrayType
    !index:[ioContext.mTypeMap count]
  ]
#-------------------------------------------------------------------- Enter list in constant map
  let staticListType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !plmNameForStaticListType (!mStaticListName)}
  [!?ioContext.mGlobalConstantMap insertKey
    !mStaticListName
    !.reference {!type:[staticListType type] !llvmName:llvmNameForGlobalVariable (!mStaticListName)}
  ]
  [!?ioContext.mValuedObjectMap insertGlobalConstant
    !mStaticListName
    !.reference {!type:[staticListType type] !llvmName:llvmNameForGlobalVariable (!mStaticListName)}
  ]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedStaticList.new {!mStaticListName !mValueList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticListInvokedFunctionSetMap {
  @stringset mInvokedFunctionSet
  
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#·······················································································································

class @decoratedStaticList : @abstractDecoratedDeclaration {
  @lstring mStaticListName
  @staticListValueListAST mValueList
}

#·······················································································································

override method @decoratedStaticList routineSemanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#·······················································································································

override method @decoratedStaticList semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @stringset invokedFunctionSet = {}
  for value in mValueList do
    for (operand endOfExp) in value.mExpressions do
      switch operand
      case expression (@expressionAST unused exp) :
      case function (@lstring functionName @routineFormalArgumentListAST formalArgs) :
      #--- Routine mangled name
        let routineMangledName = routineMangledNameFromAST (
          !"" 
          !functionName
          !formalArgs
        )
        invokedFunctionSet += !routineMangledName
      end
    end
  end
  [!?ioTemporaries.mStaticArrayMapForTemporaries insertKey !mStaticListName !invokedFunctionSet]
  [!?ioIntermediateCodeStruct.mStaticArrayMapForIntermediate insertKey !mStaticListName !invokedFunctionSet]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticListInitializationMap generateLLVMForStaticLists
  ?let @staticListInvokedFunctionSetMap inUsefulStaticArrayMap
  ?!@string ioLLVMcode
{
  var first = true
  for (key initList) in self do
    if [inUsefulStaticArrayMap hasKey !key] then
      if first then
        first = false
        ioLLVMcode += llvmTitleComment (!"Static Arraies")
      end
      ioLLVMcode += llvmNameForGlobalVariable (!key) + " = private unnamed_addr constant ["
      ioLLVMcode += [[initList length] string] + " x %" + llvmNameForStaticListElementType (![key nowhere]) + "] [\n"
      for (value) in initList
      do
        ioLLVMcode += "  %" + llvmNameForStaticListElementType (![key nowhere]) + " " + value
      between
        ioLLVMcode += ",\n"
      end
      ioLLVMcode += "\n]\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
