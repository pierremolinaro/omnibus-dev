#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @registerConstantInExpressionAST : @expressionAST {
  @lstring mRegisterName
  @lstring mFieldName
}

#----------------------------------------------------------------------------------------------------------------------*

class @registerIntegerExpInExpressionAST : @expressionAST {
  @lstring mRegisterName
  @lstring mFieldName
  @expressionAST mExpression
  @location mExpressionLocation
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let registerName
    $::$
    $identifier$ ?let fieldName
    outExpression = @registerConstantInExpressionAST.new {!registerName !fieldName}
  }

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let registerName
    $::$
    $identifier$ ?let fieldName
    $($
    <expression> ?let expression
    let endOfExpression = @location.here
    $)$
    outExpression = @registerIntegerExpInExpressionAST.new {!registerName !fieldName !expression !endOfExpression}
  }

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerConstantInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mRegisterName]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerIntegerExpInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mRegisterName]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @registerConstantInExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring unused inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType unused inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset unused inModeSet
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@semanticTemporariesStruct unused ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap unused ioVariableMap
  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResultValueName
{
#--- Search variable
  [inContext.mRegisterMap searchKey
    !mRegisterName
    ?outExpressionType
    ?let unused readOnly
    ?let @registerBitSliceAccessMap unused registerBitSliceMap
    ?let @registerFieldMap registerFieldMap
    ?let @bigint unused registerAddress
  ]
#--- Field
  [registerFieldMap searchKey
    !mFieldName
    ?let @uint bitIndex
    ?let @uint bitCount
  ]
#--- Generate code
  outResultValueName = .literalUnsignedInteger {!value:((1G << bitCount) - 1G) << bitIndex}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerIntegerExpInExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResultValueName
{
#--- Search variable
  [inContext.mRegisterMap searchKey
    !mRegisterName
    ?outExpressionType
    ?let unused readOnly
    ?let @registerBitSliceAccessMap unused registerBitSliceMap
    ?let @registerFieldMap registerFieldMap
    ?let @bigint unused registerAddress
  ]
#--- Field
  [registerFieldMap searchKey
    !mFieldName
    ?let @uint fieldBitIndex
    ?let @uint fieldBitCount
  ]
#--- Check field
  if fieldBitCount == 1 then
    error mFieldName : "this field is not an integer field"
  end
#--- Analyze expression
  [mExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let @unifiedTypeMap-proxy expressionType
    ?result:let @variableKindIR expressionResult
  ]
#--- Check expression type
  switch [expressionType kind]
  case enumeration (*) :
    error mExpressionLocation: "an unsigned integer expression is required here" : outResultValueName
  case structure (*) :
    error mExpressionLocation: "an unsigned integer expression is required here" : outResultValueName
  case boolset, boolean :
    error mExpressionLocation: "an unsigned integer expression is required here" : outResultValueName
  case literalString :
    error mExpressionLocation: "an unsigned integer expression is required here" : outResultValueName
  case integer (@bigint unused min @bigint unused max @bool unsigned @uint expressionBitCount) :
    if not unsigned then
      error mExpressionLocation: "an unsigned integer expression is required here" : outResultValueName
    elsif [expressionResult isLiteralSignedInteger] then
      error mExpressionLocation: "internal error" : outResultValueName
    elsif [expressionResult isLiteralString] then
      error mExpressionLocation: "internal error" : outResultValueName
    elsif [expressionResult isLiteralUnsignedInteger] then
      [expressionResult literalUnsignedInteger ?value:let @bigint value]
      if value < (1G << fieldBitCount) then
        outResultValueName = .literalUnsignedInteger {!value:value << fieldBitIndex}        
      else # Overflow, detected at compile time
        error mExpressionLocation
        : "static unsigned integer expression overflow: maximum value is " + ((1L << fieldBitCount) - 1L)
        : outResultValueName
      end
    else
      let assertGenerated = expressionBitCount > fieldBitCount
      if assertGenerated && [inModeSet hasKey !exceptionModeName ()] then
        error mExpressionLocation
          : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
      end
      getNewTempVariable (!?ioTemporaries ?outResultValueName)
      ioInstructionGenerationList += !@registerIntegerConstantInExpressionIR.new {
        !mExpressionLocation
        !expressionResult
        !(1L << fieldBitCount) - 1L
        !fieldBitIndex
        !outResultValueName
        !outExpressionType
        !not assertGenerated
      }
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @registerIntegerConstantInExpressionIR : @abstractInstructionIR {
  @location mInstructionLocation
  @variableKindIR mExpressionValue
  @uint64 mMaxBound
  @uint mBitShift
  @variableKindIR mResultVariable
  @unifiedTypeMap-proxy mTargetType
  @bool mNoCheck
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @registerIntegerConstantInExpressionIR instructionCode -> @string outCode {
  if mNoCheck then
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResultVariable mangledName]
            + " = ((" + mangledNameForType (!name:[mTargetType key]) + " *) "
            + [mExpressionValue mangledName] + ") << " + mBitShift + "\n" 
  elsif [option plm_options.noExceptionGeneration value] then
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResultVariable mangledName]
            + " = (" + [mExpressionValue mangledName] + " & " + mMaxBound + ") << " + mBitShift + "\n" 
  else
    outCode  = "if (" + [mExpressionValue mangledName] + " > " + mMaxBound + ") {\n"
    outCode += "  raise_exception (4, "
       + [[[mInstructionLocation file] lastPathComponent] utf8Representation]
       + ", " + [mInstructionLocation line] + ") ;\n"
    outCode += "}\n" 
    outCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResultVariable mangledName]
               + " = " + [mExpressionValue mangledName] + " << " + mBitShift + "\n" 
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerIntegerConstantInExpressionIR llvmInstructionCode ?!@string ioCode {
  if mNoCheck then
    ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResultVariable mangledName]
            + " = ((" + mangledNameForType (!name:[mTargetType key]) + " *) "
            + [mExpressionValue mangledName] + ") << " + mBitShift + "\n" 
  elsif [option plm_options.noExceptionGeneration value] then
    ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResultVariable mangledName]
            + " = (" + [mExpressionValue mangledName] + " & " + mMaxBound + ") << " + mBitShift + "\n" 
  else
    ioCode += "if (" + [mExpressionValue mangledName] + " > " + mMaxBound + ") {\n"
    ioCode += "  raise_exception (4, "
       + [[[mInstructionLocation file] lastPathComponent] utf8Representation]
       + ", " + [mInstructionLocation line] + ") ;\n"
    ioCode += "}\n" 
    ioCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResultVariable mangledName]
               + " = " + [mExpressionValue mangledName] + " << " + mBitShift + "\n" 
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @registerIntegerConstantInExpressionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
{
  [mExpressionValue enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
