#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionCallInExpressionAST : @abstractFunctionCallInExpressionAST {
  @lstring mReceiverName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractFunctionCallInExpressionAST : @expressionAST {
  @lstring mFunctionName
  @effectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let functionName
    <effective_parameters> ?let @effectiveParameterListAST effectiveParameterList ?*
    outExpression = @functionCallInExpressionAST.new {!functionName !effectiveParameterList !["" here]}
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let receiverName
    $.$
    $identifier$ ?let functionName
    <effective_parameters> ?let @effectiveParameterListAST effectiveParameterList ?*
    outExpression = @functionCallInExpressionAST.new {!functionName !effectiveParameterList !receiverName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractFunctionCallInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractFunctionCallInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallInExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  if inGuard then
    error mFunctionName : "a function cannot be called in guard expression"
  end
  analyzeRoutineCall (
    !self:inSelfType
    !propertiesAreMutable:false
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !receiverName:mReceiverName
    !routineName:mFunctionName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?localVariableMap: ioLocalVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKindIR routineKind
    ?routineMangledName:let @lstring functionMangledName
    ?routineNameForGeneration:let @lstring functionNameForGeneration
    ?returnType:let @unifiedTypeMap-proxy returnedType
    ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
  )
  if returnedType == .null then
    error mFunctionName : "cannot be called in expression: no return value"
  end
#--- New LLVM variable for function call result
  getNewTempVariable (!returnedType !?ioTemporaries ?outResult)
#--- Code generation
  ioInstructionGenerationList += !@functionCallIR.new {
    !outResult
    !functionMangledName
    !functionNameForGeneration
    !routineKind
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionCallIR : @abstractInstructionIR {
  @objectIR mResult
  @lstring mFunctionMangledName
  @lstring mFunctionNameForGeneration
  @routineKindIR mKind
  @procCallEffectiveParameterListIR mArgumentList
  @bool mAppendFileAndLineArgumentForPanicLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "  " + [mResult llvmName] + " = call " + [mResult llvmTypeName] + " @"
  switch mKind 
  case function : ioLLVMcode += llvmNameForFunction (!mFunctionNameForGeneration.string)
  case serviceInProcessorUserMode : ioLLVMcode += llvmNameForServiceCall (!mFunctionNameForGeneration.string)
  case serviceInProcessorPrivilegedMode : ioLLVMcode += llvmNameForServiceImplementation (!mFunctionNameForGeneration.string)
  case sectionInProcessorUserMode : ioLLVMcode += llvmNameForSectionCall (!mFunctionNameForGeneration.string)
  case sectionInProcessorPrivilegedMode : ioLLVMcode += llvmNameForSectionImplementation (!mFunctionNameForGeneration.string)
  case primitiveInProcessorUserMode : ioLLVMcode += llvmNameForPrimitiveCall (!mFunctionNameForGeneration.string)
  case primitiveInProcessorPrivilegedMode : ioLLVMcode += llvmNameForPrimitiveImplementation (!mFunctionNameForGeneration.string)
  end
  ioLLVMcode += " ("
  for () in mArgumentList do
    switch mEffectiveParameterPassingMode
    case input:
      ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
    case output:
      ioLLVMcode += [mParameter llvmTypeName] + " " + [mParameter llvmName]
    case outputInput:
      ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
 {
  ioAccessibleEntities.mRoutineSet += !mFunctionMangledName.string
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
