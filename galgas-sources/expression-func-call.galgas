#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionCallEffectiveParameterList {
  @lstring mSelector
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionCallInExpressionAST : @expressionAST {
  @lstring mReceiverName
  @lstring mFunctionName
  @functionCallEffectiveParameterList mParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $self$
    let receiverName = @lstring.new {!"self" !.here}
    $.$
    $identifier$ ?let functionName
    $($
    @functionCallEffectiveParameterList parameterList = {}
    repeat
    while
      $!$ ?let selector
      <expression> ?let expression
      parameterList += !selector !expression
    end
    $)$
    outExpression = @functionCallInExpressionAST.new {!receiverName !functionName !parameterList}
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    @lstring receiverName
    @lstring functionName
    $identifier$ ?let x
#    select
      functionName = x
      receiverName = ["" nowhere]
#    or
#      $.$
#      receiverName = x
#      $identifier$ ?functionName
#    end
    $($
    @functionCallEffectiveParameterList parameterList = {}
    repeat
    while
      $!$ ?let selector
      <expression> ?let expression
      parameterList += !selector !expression
    end
    $)$
    outExpression = @functionCallInExpressionAST.new {!receiverName !functionName !parameterList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mParameterList do
    [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mParameterList do
    [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallInExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@operandIR outResult
{
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
#--- Search in function map
  @lstring functionMangledName
  @unifiedTypeMap-proxy receiverType
  if mReceiverName.string != "" then
    [!?ioVariableMap searchForReadAccess
      !lkey:mReceiverName
      ?type:receiverType
      ?1*
      ?variableKind:@objectInMemoryIR variableKind
      ?4*
    ]
    functionMangledName = .new {!"$" + [receiverType key] + "." + mFunctionName !mFunctionName.location}
    effectiveParameterListIR += !.outputInput !"" ![variableKind address] #--- add "load receiver" as first argument
  else
    functionMangledName = .new {!"." + mFunctionName !mFunctionName.location}
    receiverType = .null
  end
  [inContext.mRoutineMapForContext searchKey
    !functionMangledName
    ?let unused mutating
    ?let functionModeMap
    ?let @procedureSignature functionSignature
    ?let routineKind
    ?*
    ?let functionResultType
  ]
#---
  if functionResultType == .null then
    error mFunctionName : "cannot be used as function: no returned value"
  end
#--- Enter in invocation graph
  @lstring routineNameForInvocationGraph
  switch routineKind
  case procedure : routineNameForInvocationGraph = procNameForInvocationGraph (!receiverType !mFunctionName)
  case section : routineNameForInvocationGraph = sectionNameForInvocationGraph (!receiverType !mFunctionName)
  case service : routineNameForInvocationGraph = serviceNameForInvocationGraph (!receiverType !mFunctionName)
  end
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge
    !inCallerNameForInvocationGraph
    !routineNameForInvocationGraph
  ]
#--- Check mode
  checkMode (
    !requiredModes:inModeSet
    !possibleModes:[functionModeMap keySet]
    !error:mFunctionName.location
  )
#---
  var s = llvmNameForFunction (!name:mFunctionName.string) + " ("
  if [functionSignature length] != [mParameterList length] then
    error mFunctionName : "this function declares " + [functionSignature length] 
      + " formal parameters, the call names " + [mParameterList length] + " effective arguments"
  else
    for formal in functionSignature, actual in mParameterList
    do
      if actual.mSelector.string != formal.mSelector then
        var s = "!"
        if formal.mSelector != "" then
          s += formal.mSelector + ":"
        end
        error actual.mSelector : "required selector: " + s
      end
      [actual.mExpression analyzeExpression
        !self:inSelfType
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:formal.mType
        !context:inContext
        !modes:inModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?instructionListIR:ioInstructionGenerationList
        ?result:@operandIR argumentIR
      ]
      if [argumentIR.mType key] == [formal.mType key] then
        effectiveParameterListIR +=
          !.output
          !formal.mSelector
          !argumentIR
      elsif [[argumentIR.mType kind] isStaticInteger] && [[formal.mType kind] isInteger] then
        [argumentIR.mValue literalInteger ?value:let @bigint value]
        [[formal.mType kind] integer ?min:let @bigint min ?max:let @bigint max ?unsigned:* ?bitCount:*]
        if (min <= value) && (value <= max) then
          effectiveParameterListIR += !.output !formal.mSelector !.new {!formal.mType !argumentIR.mValue}
        else
          error actual.mSelector: "the literal integer cannot fit in an $" + [formal.mType key]
        end
      else
        error actual.mSelector : "the actual parameter has the $" + [argumentIR.mType key]
         + ", but the formal argument has the $" + [formal.mType key] + " type"
      end
    between 
      s += ", "
    end
  end
  s += ")"
#--- New LLVM variable for function call result
  getNewTempVariable (!functionResultType !?ioTemporaries ?outResult)
#--- Code generation
  ioInstructionGenerationList += !@functionCallIR.new {
    !outResult
    !functionMangledName.string
    !routineKind
    !effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionCallIR : @abstractInstructionIR {
  @operandIR mResult
  @string mFunctionName
  @routineKind mKind
  @procCallEffectiveParameterListIR mArgumentList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "  " + [mResult.mValue llvmName] + " = call " + [mResult.mType llvmTypeName] + " @"
  switch mKind 
  case procedure : ioLLVMcode += llvmNameForProcedure (!mFunctionName)
  case service : ioLLVMcode += llvmNameForServiceCall (!mFunctionName)
  case section : ioLLVMcode += llvmNameForSectionCall (!mFunctionName)
  end
  ioLLVMcode += " ("
  for () in mArgumentList do
    switch mEffectiveParameterPassingMode
    case input:
      ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
    case output:
      ioLLVMcode += [mParameter.mType llvmTypeName] + " " + [mParameter.mValue llvmName]
    case outputInput:
      ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
 {
  ioAccessibleEntities.mRoutineSet += !mFunctionName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
