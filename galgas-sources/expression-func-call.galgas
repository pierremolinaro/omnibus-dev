#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionCallInExpressionAST : @abstractFunctionCallInExpressionAST {
  @lstring mReceiverName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractFunctionCallInExpressionAST : @expressionAST {
  @lstring mFunctionName
  @effectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let functionName
    <effective_parameters> ?let @effectiveParameterListAST effectiveParameterList ?*
    outExpression = @functionCallInExpressionAST.new {!functionName !effectiveParameterList !["" here]}
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let receiverName
    $.$
    $identifier$ ?let functionName
    <effective_parameters> ?let @effectiveParameterListAST effectiveParameterList ?*
    outExpression = @functionCallInExpressionAST.new {!functionName !effectiveParameterList !receiverName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractFunctionCallInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractFunctionCallInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallInExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  if inGuard then
    error mFunctionName : "a function cannot be called in guard expression"
  end
  analyzeRoutineCall (
    !self:inSelfType
    !propertiesAreMutable:false
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !receiverName:mReceiverName
    !routineName:mFunctionName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?localVariableMap: ioLocalVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKindIR routineKind
    ?routineMangledName:let @lstring functionMangledName
    ?routineNameForGeneration:let @lstring functionNameForGeneration
    ?returnType:let @unifiedTypeMap-proxy returnedType
    ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
  )
  if returnedType == .null then
    error mFunctionName : "cannot be called in expression: no return value"
  end
#--- New LLVM variable for function call result
  getNewTempVariable (!returnedType !?ioTemporaries ?outResult)
#--- Code generation
  ioInstructionGenerationList += !@functionCallIR.new {
    !outResult
    !functionMangledName
    !functionNameForGeneration
    !routineKind
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
}

