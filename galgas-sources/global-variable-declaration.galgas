#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @allowedProcList {
  @bool mHasWriteAccess
  @lstring mProcName
  @procFormalArgumentList mProcFormalArgumentList
}

#----------------------------------------------------------------------------------------------------------------------*

list @globalVarDeclarationList {
  @generalizedTypeEnumAST mType
  @lstring mVarName
  @expressionAST mSourceExpression
  @allowedProcList mAllowedProcList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $var$
    $identifier$ ?let varName
    $:$
    $identifier$ ?let typeName
    $=$
    <expression> ?let @expressionAST expression
    @allowedProcList allowedProcList = {}
    ${$
    repeat
      @bool hasWriteAccess
      select
        hasWriteAccess = false
      or
        $attribute$ ?let attribute
        if attribute.string != "rw" then
          error attribute: "attribute should be @rw"
        end
        hasWriteAccess = true
      end
      $proc$
      $identifier$ ?let procName
      <procedure_formal_arguments> ?formalArguments:let @procFormalArgumentList procFormalArgumentList
      allowedProcList += !hasWriteAccess !procName !procFormalArgumentList
    while
    end
    $}$
    ioAST.mGlobalVarDeclarationList +=
      !.valueType {!typeName:typeName}
      !varName
      !expression
      !allowedProcList
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @allowedProcedureMap {
  @bool mHasWriteAccess
  insert insertKey error message "the '%K' proc is already declared in %L"
  search searchKey error message "there is no '%K' proc"
}

#----------------------------------------------------------------------------------------------------------------------*

method @globalVarDeclarationList-element enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  switch mType
  case valueType (@lstring typeName) :
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !typeName ?let variableType]
  #--- Analyze source expression
    @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    @variableMap variableMap = variableMapWithConstants (!context:ioContext)
    [mSourceExpression analyzeExpression
       !routineNameForInvocationGraph:["compiler" nowhere]
       !optionalReceiverType:.noReceiver
       !optionalTargetType:variableType
       !context:ioContext
       !modes:{}
       !allowException:true
       !?temporary:temporaries
       !?staticStringMap:ioGlobalLiteralStringMap
       !?variableMap:variableMap
       !?instructionListIR:instructionGenerationList
       ?expressionType:let @unifiedTypeMap-proxy expressionType
       ?result:let @variableKindIR resultValueName
    ]
    if ([instructionGenerationList length] > 0) || not [resultValueName isStatic] then
      error mVarName : "source expression cannot be statically computed"
    end
  #--- Check variable type and expression type
    checkAssignmentCompatibility (
      !sourceType:expressionType
      !targetType:variableType
      !errorLocation:mVarName.location
    )
  #--- Check allowed procedures are defined
    @stringset executionModes = {}
    @allowedProcedureMap allowedProcedureMap = {}
    for () in mAllowedProcList do
      var allowedProcMangledName = mProcName.string
      for () in mProcFormalArgumentList do
        switch mFormalArgumentPassingMode
        case input : allowedProcMangledName += "?"
        case output : allowedProcMangledName += "?"
        case inputOutput : allowedProcMangledName += "?!"
        end
        allowedProcMangledName += mSelector.string + ":"
      end
      let allowedProcMangledNameWithLocation = @lstring.new {!allowedProcMangledName !mProcName.location}
      [ioContext.mProcedureMap searchKey
        !allowedProcMangledNameWithLocation
        ?*
        ?let procedureModeMap
        ?let unused signature
        ?*
      ]
      for () in procedureModeMap do
        executionModes += !lkey.string
      end
      [!?allowedProcedureMap insertKey !allowedProcMangledNameWithLocation !mHasWriteAccess]
    end
    [!?ioContext.mGlobalVariableMap insertKey
      !mVarName
      !variableType
      !executionModes
      !allowedProcedureMap
      !resultValueName
    ]
  case procType (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

method @globalVarDeclarationList-element semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Code generation
  [inContext.mGlobalVariableMap searchKey
    !mVarName
    ?let inferredType
    ?let executionModeSet
    ?let unused allowedProcedureMap
    ?let expressionGeneratedCode
  ]
  [!?ioIntermediateCodeStruct.mGlobalVariableMap insertKey
    !mVarName
    ![inferredType key]
    ![executionModeSet count] > 1
    !expressionGeneratedCode
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper globalVariableGenerationTemplate in "../generation-templates" {
}{
}{
  template implementation "global-var-declaration.galgasTemplate"
    ?@string GLOBAL_VAR_NAME
    ?@string GLOBAL_TYPE_NAME
    ?@bool GENERATE_VOLATILE
    ?@string INITIAL_VALUE_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

getter @globalVariableMapIR-element implementationCodeGeneration -> @string outCode {
  var initialValueString = [mInitialValue mangledName]
  if [mInitialValue isLiteralUnsignedInteger] then
    [mInitialValue literalUnsignedInteger ?value:let @uint64 value] ;
    if value == 0L then
      initialValueString = ""
    end
  end
  outCode = [filewrapper globalVariableGenerationTemplate.implementation
    !lkey.string # mGlobalVariableName
    !mActualTypeName
    !mGenerateVolatile
    !initialValueString
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
