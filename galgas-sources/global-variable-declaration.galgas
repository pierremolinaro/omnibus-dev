#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @allowedProcList {
  @bool mHasWriteAccess
  @lstring mProcName
  @procFormalArgumentList mProcFormalArgumentList
}

#----------------------------------------------------------------------------------------------------------------------*

list @allowedInitList {
  @bool mHasWriteAccess
  @lbigint mInitPriority
}

#----------------------------------------------------------------------------------------------------------------------*

list @allowedExceptionList {
  @bool mHasWriteAccess
  @lstring mExceptionName
  @lbigint mExceptionPriority
}

#----------------------------------------------------------------------------------------------------------------------*

list @globalVarDeclarationList {
  @generalizedTypeEnumAST mType
  @lstring mVarName
  @expressionAST mSourceExpression
  @allowedProcList mAllowedProcList
  @allowedInitList mAllowedInitList
  @allowedExceptionList mAllowedExceptionList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $var$
    $identifier$ ?let varName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $typeName$ ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
    @allowedProcList allowedProcList = {}
    @allowedInitList allowedInitList = {}
    @allowedExceptionList allowedExceptionList = {}
    ${$
    repeat
      @bool hasWriteAccess
      select
        hasWriteAccess = false
      or
        $attribute$ ?let attribute
        if attribute.string != "rw" then
          error attribute: "attribute should be @rw"
        end
        hasWriteAccess = true
      end
      select
        $proc$
        $identifier$ ?let procName
        <procedure_formal_arguments> ?formalArguments:let @procFormalArgumentList procFormalArgumentList
        allowedProcList += !hasWriteAccess !procName !procFormalArgumentList
      or
        $init$
        $integer$ ?let @lbigint priority
        allowedInitList += !hasWriteAccess !priority
      or
        $exception$
        $identifier$ ?let exceptionName
        $integer$ ?let @lbigint priority
        allowedExceptionList += !hasWriteAccess !exceptionName !priority
      end
    while
    end
    $}$
    ioAST.mGlobalVarDeclarationList +=
      !.valueType {!typeName:typeName}
      !varName
      !expression
      !allowedProcList
      !allowedInitList
      !allowedExceptionList
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @allowedRoutineMap {
  @bool mHasWriteAccess
  insert insertKey error message "the '%K' is already declared in %L"
  search searchKey error message "there is no '%K'"
}

#----------------------------------------------------------------------------------------------------------------------*

method @globalVarDeclarationList-element enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  switch mType
  case valueType (@lstring typeName) :
    @unifiedTypeMap-proxy variableType
    if typeName.string == "" then
      variableType = .null
    else
      [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !typeName ?variableType]
    end
  #--- Analyze source expression
    @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    @variableMap variableMap = variableMapWithConstants (!context:ioContext)
    [mSourceExpression analyzeExpression
       !routineNameForInvocationGraph:["compiler" nowhere]
       !optionalReceiverType:.noReceiver
       !optionalTargetType:variableType
       !context:ioContext
       !modes:{}
       !allowException:true
       !?temporary:temporaries
       !?staticStringMap:ioGlobalLiteralStringMap
       !?variableMap:variableMap
       !?instructionListIR:instructionGenerationList
       ?type:let @unifiedTypeMap-proxy resultType
       ?result:let @operandIR resultValue
    ]
    if ([instructionGenerationList length] > 0) || not [resultValue isStatic] then
      error mVarName : "source expression cannot be statically computed"
    end
  #--- Check variable type and expression type
    checkAssignmentCompatibility (
      !sourceType:resultType
      !sourceValue:resultValue
      !targetType:variableType
      !errorLocation:mVarName.location
    )
    @stringset executionModes = {}
    @allowedRoutineMap allowedProcedureMap = {}
  #--- Check allowed init routines are defined
    for () in mAllowedInitList do
      [ioContext.mInitRoutineMap searchKey !.new {![mInitPriority.bigint string] !mInitPriority.location}]
      [!?allowedProcedureMap insertKey
         !.new {!"init " + [mInitPriority.bigint string] !mInitPriority.location}
         !mHasWriteAccess
      ]
    end
  #--- Check allowed exception routines are defined
    for () in mAllowedExceptionList do
      if mExceptionName.string == "setup" then
        [ioContext.mExceptionSetupRoutinePriorityMap searchSetupKey
          !.new{![mExceptionPriority.bigint string]
          !mExceptionPriority.location}
        ]
      elsif mExceptionName.string == "loop" then
        [ioContext.mExceptionLoopRoutinePriorityMap searchLoopKey
          !.new{![mExceptionPriority.bigint string]
          !mExceptionPriority.location}
        ]
      else
        error mExceptionName : "exception routine name should be \"setup\" or \"loop\""
      end
      [!?allowedProcedureMap insertKey
        !.new {!"exception " + mExceptionName + " " + [mExceptionPriority.bigint string] !mExceptionName.location}
        !mHasWriteAccess
      ]
    end
  #--- Check allowed procedures are defined
    for () in mAllowedProcList do
      var allowedProcMangledName = mProcName.string
      for () in mProcFormalArgumentList do
        switch mFormalArgumentPassingMode
        case input : allowedProcMangledName += "?"
        case output : allowedProcMangledName += "?"
        case inputOutput : allowedProcMangledName += "?!"
        end
        allowedProcMangledName += mSelector.string + ":"
      end
      let allowedProcMangledNameWithLocation = @lstring.new {!allowedProcMangledName !mProcName.location}
      [ioContext.mProcedureMap searchKey
        !allowedProcMangledNameWithLocation
        ?*
        ?let procedureModeMap
        ?let unused signature
        ?*
      ]
      for () in procedureModeMap do
        executionModes += !lkey.string
      end
      [!?allowedProcedureMap insertKey
         !.new {!"proc " + allowedProcMangledName !mProcName.location}
         !mHasWriteAccess
      ]
    end
    [!?ioContext.mGlobalVariableMap insertKey
      !mVarName
      !if variableType == .null then resultType else variableType end
      !executionModes
      !allowedProcedureMap
      !resultValue
      !false # Is not constant
    ]
  case procType (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

method @globalVarDeclarationList-element semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Code generation
  [inContext.mGlobalVariableMap searchKey
    !mVarName
    ?let inferredType
    ?let executionModeSet
    ?let unused allowedProcedureMap
    ?let expressionGeneratedCode
    ?let isConstant
  ]
  [!?ioIntermediateCodeStruct.mGlobalVariableMap insertKey
    !mVarName
    !inferredType
    ![executionModeSet count] > 1
    !expressionGeneratedCode
#    !isConstant
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

method @globalVariableMapIR-element generateLLVM ?!@string ioCode {
  ioCode += "@" + mangledNameForGlobalVariable (!lkey.string) + " = internal global "
  ioCode += [mType llvmTypeName] + " "
  let initialString = [mInitialValue string]
  if initialString == "" then
    ioCode += "zeroinitializer"
  else
    ioCode += initialString
  end
  ioCode += "\n"
}

#----------------------------------------------------------------------------------------------------------------------*
