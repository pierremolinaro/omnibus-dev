#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allowedProcList {
  @bool mHasWriteAccess
  @lstring mReceiverTypeName
  @lstring mProcName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allowedSectionList {
  @bool mHasWriteAccess
  @lstring mReceiverTypeName
  @lstring mSectionName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allowedFunctionList {
  @lstring mReceiverTypeName
  @lstring mFuncName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allowedInitList {
  @bool mHasWriteAccess
  @lbigint mInitPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @allowedExceptionList {
  @bool mHasWriteAccess
  @lstring mExceptionName
  @lbigint mExceptionPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @globalVarDeclarationList {
  @lstring mTypeName # Empty string if no type annotation
  @lstring mVarName
  @expressionAST mSourceExpression
  @allowedProcList mAllowedProcList
  @allowedInitList mAllowedInitList
  @allowedExceptionList mAllowedExceptionList
  @allowedFunctionList mAllowedFunctionList
  @allowedSectionList mAllowedSectionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $var$
    $identifier$ ?let varName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $typeName$ ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
    @allowedProcList allowedProcList = {}
    @allowedInitList allowedInitList = {}
    @allowedFunctionList allowedFunctionList = {}
    @allowedExceptionList allowedExceptionList = {}
    @allowedSectionList allowedSectionList = {}
    ${$
    repeat
      @bool hasWriteAccess
      select
        hasWriteAccess = false
      or
        $attribute$ ?let attribute
        if attribute.string != "rw" then
          error attribute: "attribute should be @rw"
        end
        hasWriteAccess = true
      end
      select
        $section$
        @lstring typeName
        select
          typeName = ["" nowhere]
        or
          $typeName$ ?typeName
        end
        $identifier$ ?let sectionName
        allowedSectionList += !hasWriteAccess !typeName !sectionName
      or
        $proc$
        @lstring typeName
        select
          typeName = ["" nowhere]
        or
          $typeName$ ?typeName
        end
        $identifier$ ?let procName
        allowedProcList += !hasWriteAccess !typeName !procName
      or
        $func$
        @lstring typeName
        select
          typeName = ["" nowhere]
        or
          $typeName$ ?typeName
        end
        $identifier$ ?let funcName
        if hasWriteAccess then
          error funcName : "a function cannot write a global variable"
        end
        allowedFunctionList += !typeName !funcName
      or
        $init$
        $integer$ ?let @lbigint priority
        allowedInitList += !hasWriteAccess !priority
      or
        $panic$
        $proc$
        $identifier$ ?let exceptionName
        $integer$ ?let @lbigint priority
        allowedExceptionList += !hasWriteAccess !exceptionName !priority
      end
    while
    end
    $}$
    ioAST.mGlobalVarDeclarationList +=
      !typeName
      !varName
      !expression
      !allowedProcList
      !allowedInitList
      !allowedExceptionList
      !allowedFunctionList
      !allowedSectionList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVarDeclarationList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (globalVariableTypeName 7*) in self do
    if globalVariableTypeName.string != "" then
      let typeName = @lstring.new {!"$" + globalVariableTypeName !globalVariableTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @allowedRoutineMap {
  @bool mHasWriteAccess
  insert insertKey error message "the '%K' procedure is already declared in %L"
  search searchKey error message "there is no '%K'"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVarDeclarationList-element enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  @unifiedTypeMap-proxy variableAnnotationType
  if mTypeName.string == "" then
    variableAnnotationType = .null
  else
    variableAnnotationType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mTypeName}
  end
#--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
  @instructionListIR instructionGenerationList = {}
  @variableMap variableMap = variableMapWithConstants (!context:ioContext)
  [mSourceExpression analyzeExpression
     !routineNameForInvocationGraph:["compiler" nowhere]
     !optionalTargetType:variableAnnotationType
     !context:ioContext
     !modes:{}
     !allowException:true
     !?temporary:temporaries
     !?staticStringMap:ioGlobalLiteralStringMap
     !?variableMap:variableMap
     !?instructionListIR:instructionGenerationList
     ?result:let @operandIR expressionResult
  ]
  if ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
    error mVarName : "source expression cannot be statically computed"
  end
#--- Check variable type and expression type
  if variableAnnotationType == .null && [[expressionResult.mType kind] isStaticInteger] then
    error mVarName : "cannot infer type"
  end
  let result = checkAssignmentCompatibility (
    !source:expressionResult
    !targetAnnotationType:variableAnnotationType
    !errorLocation:mVarName.location
    !staticTypeAllowed:false
  )
  @stringset executionModes = {}
#--- Check allowed function are defined
  @allowedRoutineMap allowedRoutineMap = {}
  for (typeName funcName) in mAllowedFunctionList do
    @unifiedTypeMap-proxy receiverType
    if typeName.string == "" then
      [ioContext.mFunctionMap searchKey !funcName ?3*]
      receiverType = .null
    else
      receiverType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !typeName}
      [[receiverType functionMap] searchKey !funcName ?3*]
    end
    [!?allowedRoutineMap insertKey !funcNameForInvocationGraph (!receiverType !funcName) !false]
  end
#--- Check allowed init routines are defined
  for () in mAllowedInitList do
    [ioContext.mInitRoutineMap searchKey !.new {![mInitPriority.bigint string] !mInitPriority.location}]
    [!?allowedRoutineMap insertKey !initNameForInvocationGraph (!mInitPriority) !mHasWriteAccess]
  end
#--- Check allowed exception routines are defined
  for () in mAllowedExceptionList do
    if mExceptionName.string == "setup" then
      [ioContext.mExceptionSetupRoutinePriorityMap searchSetupKey
        !.new{![mExceptionPriority.bigint string]
        !mExceptionPriority.location}
      ]
    elsif mExceptionName.string == "loop" then
      [ioContext.mExceptionLoopRoutinePriorityMap searchLoopKey
        !.new{![mExceptionPriority.bigint string]
        !mExceptionPriority.location}
      ]
    else
      error mExceptionName : "exception routine name should be \"setup\" or \"loop\""
    end
    [!?allowedRoutineMap insertKey
      !exceptionNameForInvocationGraph (!mExceptionName.string !mExceptionPriority)
      !mHasWriteAccess
    ]
  end
#--- Check allowed procedures are defined
  for procedure in mAllowedProcList do
    @unifiedTypeMap-proxy receiverType
    if procedure.mReceiverTypeName.string == "" then
      receiverType = .null
      [ioContext.mProcedureMap searchKey
        !procedure.mProcName
        ?*
        ?let procedureModeMap
        ?2*
      ]
      for () in procedureModeMap do
        executionModes += !lkey.string
      end
    else
      receiverType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !procedure.mReceiverTypeName}
      [[receiverType procedureMap] searchKey
        !procedure.mProcName
        ?*
        ?let procedureModeMap
        ?2*
      ]
      for () in procedureModeMap do
        executionModes += !lkey.string
      end
    end
    [!?allowedRoutineMap insertKey
       !procNameForInvocationGraph (!receiverType !procedure.mProcName)
       !procedure.mHasWriteAccess
    ]
  end
#--- Check allowed sections are defined
  for section in mAllowedSectionList do
    @unifiedTypeMap-proxy receiverType
#    if section.mReceiverTypeName.string == "" then
      receiverType = .null
      [ioContext.mSectionMap searchKey
        !section.mSectionName
        ?2*
      ]
#    else
#      receiverType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !section.mReceiverTypeName}
#      [[receiverType sectionMap] searchKey
#        !section.mSectionName
#        ?2*
#      ]
#    end
    [!?allowedRoutineMap insertKey
       !sectionNameForInvocationGraph (!receiverType !section.mSectionName)
       !section.mHasWriteAccess
    ]
  end
#--- Enter variable in globale variable map
  [!?ioContext.mGlobalVariableMap insertKey
    !mVarName
    !result.mType
    !executionModes
    !allowedRoutineMap
    !result.mValue
    !false # Is not constant
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVarDeclarationList-element semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Code generation
  [inContext.mGlobalVariableMap searchKey
    !mVarName
    ?let inferredType
    ?let executionModeSet
    ?let unused allowedProcedureMap
    ?let expressionGeneratedCode
    ?let unused isConstant
  ]
  [!?ioIntermediateCodeStruct.mGlobalVariableMap insertKey
    !mVarName
    !inferredType
    ![executionModeSet count] > 1
    !expressionGeneratedCode
#    !isConstant
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVariableMapIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += "@" + llvmNameForGlobalVariable (!lkey.string) + " = internal global "
  ioLLVMcode += [mType llvmTypeName] + " "
  let initialString = [mInitialValue llvmName]
  if initialString == "" then
    ioLLVMcode += "zeroinitializer"
  else
    ioLLVMcode += initialString
  end
  ioLLVMcode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
