#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @allowedProcList {
  @bool mHasWriteAccess
  @lstring mProcName
  @procFormalArgumentList mProcFormalArgumentList
}

#----------------------------------------------------------------------------------------------------------------------*

list @allowedInitList {
  @bool mHasWriteAccess
  @luint64 mInitPriority
}

#----------------------------------------------------------------------------------------------------------------------*

list @allowedExceptionList {
  @bool mHasWriteAccess
  @lstring mExceptionName
  @luint64 mExceptionPriority
}

#----------------------------------------------------------------------------------------------------------------------*

list @globalVarDeclarationList {
  @generalizedTypeEnumAST mType
  @lstring mVarName
  @expressionAST mSourceExpression
  @allowedProcList mAllowedProcList
  @allowedInitList mAllowedInitList
  @allowedExceptionList mAllowedExceptionList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $var$
    $identifier$ ?let varName
    $:$
    $identifier$ ?let typeName
    $=$
    <expression> ?let @expressionAST expression
    @allowedProcList allowedProcList = {}
    @allowedInitList allowedInitList = {}
    @allowedExceptionList allowedExceptionList = {}
    ${$
    repeat
      @bool hasWriteAccess
      select
        hasWriteAccess = false
      or
        $attribute$ ?let attribute
        if attribute.string != "rw" then
          error attribute: "attribute should be @rw"
        end
        hasWriteAccess = true
      end
      select
        $proc$
        $identifier$ ?let procName
        <procedure_formal_arguments> ?formalArguments:let @procFormalArgumentList procFormalArgumentList
        allowedProcList += !hasWriteAccess !procName !procFormalArgumentList
      or
        $init$
        $integer$ ?let @luint64 priority
        allowedInitList += !hasWriteAccess !priority
      or
        $exception$
        $identifier$ ?let exceptionName
        $integer$ ?let @luint64 priority
        allowedExceptionList += !hasWriteAccess !exceptionName !priority
      end
    while
    end
    $}$
    ioAST.mGlobalVarDeclarationList +=
      !.valueType {!typeName:typeName}
      !varName
      !expression
      !allowedProcList
      !allowedInitList
      !allowedExceptionList
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @allowedRoutineMap {
  @bool mHasWriteAccess
  insert insertKey error message "the '%K' is already declared in %L"
  search searchKey error message "there is no '%K'"
}

#----------------------------------------------------------------------------------------------------------------------*

method @globalVarDeclarationList-element enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  switch mType
  case valueType (@lstring typeName) :
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !typeName ?let variableType]
  #--- Analyze source expression
    @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    @variableMap variableMap = variableMapWithConstants (!context:ioContext)
    [mSourceExpression analyzeExpression
       !routineNameForInvocationGraph:["compiler" nowhere]
       !optionalReceiverType:.noReceiver
       !optionalTargetType:variableType
       !context:ioContext
       !modes:{}
       !allowException:true
       !?temporary:temporaries
       !?staticStringMap:ioGlobalLiteralStringMap
       !?variableMap:variableMap
       !?instructionListIR:instructionGenerationList
       ?expressionType:let @unifiedTypeMap-proxy expressionType
       ?result:let @variableKindIR resultValueName
    ]
    if ([instructionGenerationList length] > 0) || not [resultValueName isStatic] then
      error mVarName : "source expression cannot be statically computed"
    end
  #--- Check variable type and expression type
    checkAssignmentCompatibility (
      !sourceType:expressionType
      !targetType:variableType
      !errorLocation:mVarName.location
    )
    @stringset executionModes = {}
    @allowedRoutineMap allowedProcedureMap = {}
  #--- Check allowed init routines are defined
    for () in mAllowedInitList do
      [ioContext.mInitRoutineMap searchKey !.new {![mInitPriority.uint64 string] !mInitPriority.location}]
      [!?allowedProcedureMap insertKey
         !.new {!"init " + [mInitPriority.uint64 string] !mInitPriority.location}
         !mHasWriteAccess
      ]
    end
  #--- Check allowed exception routines are defined
    for () in mAllowedExceptionList do
      if mExceptionName.string == "setup" then
        [ioContext.mExceptionSetupRoutinePriorityMap searchSetupKey
          !.new{![mExceptionPriority.uint64 string]
          !mExceptionPriority.location}
        ]
      elsif mExceptionName.string == "loop" then
        [ioContext.mExceptionLoopRoutinePriorityMap searchLoopKey
          !.new{![mExceptionPriority.uint64 string]
          !mExceptionPriority.location}
        ]
      else
        error mExceptionName : "exception routine name should be \"setup\" or \"loop\""
      end
      [!?allowedProcedureMap insertKey
        !.new {!"exception " + mExceptionName + " " + [mExceptionPriority.uint64 string] !mExceptionName.location}
        !mHasWriteAccess
      ]
    end
  #--- Check allowed procedures are defined
    for () in mAllowedProcList do
      var allowedProcMangledName = mProcName.string
      for () in mProcFormalArgumentList do
        switch mFormalArgumentPassingMode
        case input : allowedProcMangledName += "?"
        case output : allowedProcMangledName += "?"
        case inputOutput : allowedProcMangledName += "?!"
        end
        allowedProcMangledName += mSelector.string + ":"
      end
      let allowedProcMangledNameWithLocation = @lstring.new {!allowedProcMangledName !mProcName.location}
      [ioContext.mProcedureMap searchKey
        !allowedProcMangledNameWithLocation
        ?*
        ?let procedureModeMap
        ?let unused signature
        ?*
      ]
      for () in procedureModeMap do
        executionModes += !lkey.string
      end
      [!?allowedProcedureMap insertKey
         !.new {!"proc " + allowedProcMangledName !mProcName.location}
         !mHasWriteAccess
      ]
    end
    [!?ioContext.mGlobalVariableMap insertKey
      !mVarName
      !variableType
      !executionModes
      !allowedProcedureMap
      !resultValueName
    ]
  case procType (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

method @globalVarDeclarationList-element semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Code generation
  [inContext.mGlobalVariableMap searchKey
    !mVarName
    ?let inferredType
    ?let executionModeSet
    ?let unused allowedProcedureMap
    ?let expressionGeneratedCode
  ]
  [!?ioIntermediateCodeStruct.mGlobalVariableMap insertKey
    !mVarName
    ![inferredType key]
    ![executionModeSet count] > 1
    !expressionGeneratedCode
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper globalVariableGenerationTemplate in "../generation-templates" {
}{
}{
  template implementation "global-var-declaration.galgasTemplate"
    ?@string GLOBAL_VAR_NAME
    ?@string GLOBAL_TYPE_NAME
    ?@bool GENERATE_VOLATILE
    ?@string INITIAL_VALUE_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

getter @globalVariableMapIR-element implementationCodeGeneration -> @string outCode {
  var initialValueString = [mInitialValue mangledName]
  if [mInitialValue isLiteralUnsignedInteger] then
    [mInitialValue literalUnsignedInteger ?value:let @uint64 value] ;
    if value == 0L then
      initialValueString = ""
    end
  end
  outCode = [filewrapper globalVariableGenerationTemplate.implementation
    !lkey.string # mGlobalVariableName
    !mActualTypeName
    !mGenerateVolatile
    !initialValueString
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
