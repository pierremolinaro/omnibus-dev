#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @globalVarDeclaration : @abstractDeclaration {
  @lstringlist mModeList
  @generalizedTypeEnumAST mType
  @lstring mVarName
  @expressionAST mSourceExpression
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @globalVarDeclaration location -> @location outLocation {
  outLocation = mVarName.location
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $var$
    $identifier$ ?let varName
    @lstringlist modeList = {}
    repeat
      $modeName$ ?let modeName
      modeList += !modeName
    while
    end
    $:$
    $identifier$ ?let typeName
    $=$
    <expression> ?let @expressionAST expression
    ioAST.mDeclarationList += !@globalVarDeclaration.new {
      !modeList
      !.valueType {!typeName:typeName}
      !varName
      !expression
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @globalVarDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  enterNodeInPrecedenceGraph (!nodeName:mVarName !nodeInfo:self !type:mType !?ioGraph)
  [mSourceExpression addDependenceEdgeForStaticExpression !mVarName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @globalVarDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "global variable " + mVarName 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @globalVarDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  switch mType
  case valueType (@lstring typeName) :
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !typeName ?let variableType]
  #--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    @variableMap variableMap = variableMapWithConstants (!context:ioContext)
    [mSourceExpression analyzeExpression
       !routineNameForInvocationGraph:["compiler" nowhere]
       !optionalReceiverType:.noReceiver
       !optionalTargetType:variableType
       !context:ioContext
       !modes:{}
       !allowException:true
       !?temporary:temporaries
       !?staticStringMap:ioGlobalLiteralStringMap
       !?variableMap:variableMap
       !?instructionListIR:instructionGenerationList
       ?expressionType:let @unifiedTypeMap-proxy expressionType
       ?result:let @variableKindIR resultValueName
    ]
    if ([instructionGenerationList length] > 0) || not [resultValueName isStatic] then
      error mVarName : "source expression cannot be statically computed"
    end
  #--- Execution mode set
    @stringset executionModes = {}
    for (m) in mModeList do
      executionModes += !m.string
    end
  #--- Check variable type and expression type
    checkAssignmentCompatibility (
      !sourceType:expressionType
      !targetType:variableType
      !errorLocation:mVarName.location
    )
  #--- Enter in context
    [!?ioContext.mGlobalVariableMap insertKey
      !mVarName
      !variableType
      !executionModes
      !resultValueName
    ]
  case procType (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @globalVarDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check execution mode names
  @stringset executionModes = {}
  for (m) in mModeList do
    [inContext.mModeMap searchKey !m]
    if m.string == bootModeName () then
      error m: "a global variable does not accept the $" + bootModeName () + " mode"
    end
    executionModes += !m.string
  end
#--- Code generation
  [inContext.mGlobalVariableMap searchKey
    !mVarName
    ?let inferredType
    ?let executionModeSet
    ?let expressionGeneratedCode
  ]
  [!?ioIntermediateCodeStruct.mGlobalVariableMap insertKey
    !mVarName
    ![inferredType key]
    ![executionModeSet count] > 1
    !expressionGeneratedCode
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper globalVariableGenerationTemplate in "../generation-templates" {
}{
}{
  template implementation "global-var-declaration.galgasTemplate"
    ?@string GLOBAL_VAR_NAME
    ?@string GLOBAL_TYPE_NAME
    ?@bool GENERATE_VOLATILE
    ?@string INITIAL_VALUE_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

getter @globalVariableMapIR-element implementationCodeGeneration -> @string outCode {
  var initialValueString = [mInitialValue mangledName]
  if [mInitialValue isLiteralUnsignedInteger] then
    [mInitialValue literalUnsignedInteger ?value:let @uint64 value] ;
    if value == 0L then
      initialValueString = ""
    end
  end
  outCode = [filewrapper globalVariableGenerationTemplate.implementation
    !lkey.string # mGlobalVariableName
    !mActualTypeName
    !mGenerateVolatile
    !initialValueString
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
