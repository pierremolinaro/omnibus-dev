#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "plm-target"
message "a target definition text file with the .plm-target extension"
grammar plm_target_grammar
?sourceFilePath:@lstring unused inSourceFile {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "plm"
message "a source text file with the .plm extension"
grammar plm_grammar
?sourceFilePath:@lstring inSourceFile
{
  if ([option .mode value] == "") & not [option .outputConcreteSyntaxTree value] then
    importFilesAndCompile (!sourceFilePath:inSourceFile)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc importFilesAndCompile ?sourceFilePath:let @lstring inSourceFile
{
#--- Parsing
  @ast ast = .default
  grammar plm_grammar in inSourceFile
    !?ast
    ?importClauseList:let importedFileList
    ?endOfSourceFile:let endOfSourceFile
#--- Recursively import files
  @stringset importedFileAbsolutePathSet = .setWithString {!inSourceFile.string}
  let currentDirectory = [inSourceFile stringByDeletingLastPathComponent]
  recursiveImportFiles (
    !?ast:ast
    !currentDirectory:currentDirectory
    !importClauseList:importedFileList
    !?importedFilePathSet:importedFileAbsolutePathSet
  )
#--- Check target names are not duplicated
  if @uint.errorCount == 0 then
    @stringset targetNameSet = {}
    for (targetName) in ast.mTargetListAST do
      if [targetNameSet hasKey !targetName.string] then
        error targetName : "Duplicated target"
      end
      targetNameSet += !targetName.string
    end
  end
#--- Compile project for every target
  if @uint.errorCount == 0 then
    if [ast.mTargetListAST length] == 0 then
      warning endOfSourceFile : "no target: only syntax analysis is performed"
    elsif [ast.mTargetListAST length] > 1 then
      warning endOfSourceFile : [[ast.mTargetListAST length] string] + " targets: only syntax analysis is performed"
    else
      for (targetName) in ast.mTargetListAST do
        compileProject (
          !sourceFile:inSourceFile
          !ast:ast
          !forTarget:targetName
          !endOfSourceFile:endOfSourceFile
          !currentDirectory:currentDirectory
          !importedFilePathSet:importedFileAbsolutePathSet
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc compileProject
  ?sourceFile:let @lstring inSourceFile
  ?ast:let @ast inAST
  ?forTarget:let @lstring inTargetName
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?currentDirectory:let @string inCurrentDirectory
  ?importedFilePathSet:let @stringset inImportedFileAbsolutePathSet
{
  @ast ast = inAST
  @stringset sourceFileAbsolutePathSet = inImportedFileAbsolutePathSet
#------------------------------------------------------------ Add target specific files
  addTargetSpecificFiles (
    !forTarget:inTargetName
    !?toAST:ast
    !currentDirectory:inCurrentDirectory
    !?importedFilePathSet:sourceFileAbsolutePathSet
  )
  if @uint.errorCount == 0 then
  #------------------------------------------------------------ Add Predefined types
  #--- Add boolean type
    ast.mDeclarationListAST += !@booleanDeclarationAST.new {![boolTypeName () nowhere]}
  #--- Literal integer type
    ast.mDeclarationListAST += !@literalIntegerDeclarationAST.new
  #--- Add String type
    ast.mDeclarationListAST += !@literalStringDeclarationAST.new {![staticStringTypeName () nowhere]}
  #------------------------------------------------------------  Add type extensions
    let declarationList = ast.mDeclarationListAST
    var @declarationListAST newDeclarationList = {}
    var extensionDeclarationListAST = ast.mExtensionDeclarationListAST
    var extendStaticArrayDeclarationAST = ast.mExtendStaticArrayDeclarationAST
    for (declaration) in declarationList do
      [declaration addExtension !?extensionDeclarationListAST !?extendStaticArrayDeclarationAST ?let newDeclaration]
      newDeclarationList += !newDeclaration
    end
    ast.mDeclarationListAST = newDeclarationList
  #--- Raise an error for every unhandled extension
    for (typeName * * * *) in extensionDeclarationListAST do
      error typeName : "this type is not defined or does not support extension"
    end
  #--- Raise an error for every static array list extension
    for (staticListName *) in extendStaticArrayDeclarationAST do
      error staticListName : "this static list is not defined"
    end
  end
#------------------------------------------------------------ Retain required drivers
  if @uint.errorCount == 0 then
    retainRequiredDrivers (!?ast)
  end
#------------------------------------------------------------ Ordered declaration list
  @declarationListAST orderedDeclarationListAST = .default
  if @uint.errorCount == 0 then
    buildOrderedDeclarationList (
      !ast:ast
      !sourceFile:inSourceFile.string
      !endOfSourceFile:inEndOfSourceFile
      ?orderedDeclarationList:orderedDeclarationListAST
    )
  end
#------------------------------------------------------------ Check "check target" declarations
  if @uint.errorCount == 0 then
    for (targetLocation acceptedTargetList) in ast.mCheckTargetListAST do
      var accepted = false
      for (possibleTarget) in acceptedTargetList while not accepted do
        accepted = possibleTarget.string != inTargetName
      end
      if not accepted then
        error targetLocation : "invalid target"
      end
    end
  end
#------------------------------------------------------------ Semantic context
  @semanticContext semanticContext = .default
  @staticStringMap globalLiteralStringMap = {}
  @staticListInitializationMap staticListValueMap = {}
  ast.mDeclarationListAST = orderedDeclarationListAST
  @subprogramInvocationGraph subprogramInvocationGraph = .emptyGraph
  @declarationDecorationList decoratedDeclarationList = {}
  if @uint.errorCount == 0 then
    var @timer t = .start 
    buildSemanticContext (
      !sourceFile:inSourceFile
      !ast:ast
      !?staticStringMap:globalLiteralStringMap
      !?staticlistValues:staticListValueMap
      ?context:semanticContext
      ?subprogramInvocationGraph
      ?decoratedDeclarationList
    )
    message "Context: " + [t string] + "\n" 
  end
#------------------------------------------------------------ Semantic analysis
  @intermediateCodeStruct intermediateCodeStruct = .default
  if @uint.errorCount == 0 then
    var @timer t = .start 
    semanticAnalysis (
      !sourceFile:inSourceFile.string
      !ast:ast
      !decoratedDeclarationList:decoratedDeclarationList
      !context:semanticContext
      !subprogramInvocationGraph
      !endOfSourceFile:inEndOfSourceFile
      !staticStringMap:globalLiteralStringMap
      ?intermediateCode:intermediateCodeStruct
    )
    message "Semantic: " + [t string] + "\n" 
  end
#------------------------------------------------------------ Code optimisation
  if @uint.errorCount == 0 then
    var @timer tOpt = .start 
    codeOptimisation (!?intermediateCode:intermediateCodeStruct)
    message "Optimization: " + [tOpt string] + "\n" 
  end
#------------------------------------------------------------ Code generation
  if @uint.errorCount == 0 then
    var @timer tGen = .start 
    codeGeneration (
      !currentDir:inCurrentDirectory
      !outputFile:inSourceFile.string
      !eof:inEndOfSourceFile
      !intermediateCode:intermediateCodeStruct
      !typeMap:semanticContext.mTypeMap
      !target:inTargetName
      !panicCodeType:semanticContext.mPanicCodeType
      !panicLineType:semanticContext.mPanicLineType
      !interrupts:semanticContext.mAvailableInterruptMap
      !staticlistValues:staticListValueMap
      !sourceFileSet:sourceFileAbsolutePathSet
      !targetParameters:semanticContext.mTargetParameters
    )
    message "Code generation: " + [tGen string] + "\n" 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc addTargetSpecificFiles
  ?forTarget:let @lstring inTargetName
  ?!toAST:@ast ioAST
  ?currentDirectory:let @string inCurrentDirectory
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
#  @ast ast = .default
  if [option plm_options.useDirAsTargetDir value] != "" then # Target is defined in files
    let targetDirectory = [[option plm_options.useDirAsTargetDir value] absolutePathFromPath !inCurrentDirectory]
    if [targetDirectory directoryExists] then
      let targetDefinitionFullPath = targetDirectory + "/" + inTargetName.string + "/+config.plm-target"
      if [targetDefinitionFullPath fileExists] then
        grammar plm_target_grammar in [targetDefinitionFullPath nowhere]
          !?ioAST
          ?importClauseList:let importedFileList
          ?endOfSourceFile:*
        recursiveImportFileSystemTargetFiles (
          !?ast:ioAST
          !targetDirectory:targetDirectory + "/" + inTargetName.string
          !importClauseList:importedFileList
          !?importedFilePathSet:ioImportedFileAbsolutePathSet
        )
      else
        error inTargetName
          : "This target is not defined in '" + [option plm_options.useDirAsTargetDir value] + "' directory"
      end
    else
      error ["" nowhere]: "the '" + [option plm_options.useDirAsTargetDir value] + "' directory does not exist"
    end
  else # Target is defined in embedded files
  #--- Parse target definition file
    let @filewrapper fw = [filewrapper targetTemplates]
    if [fw fileExistsAtPath !inTargetName.string + "/+config.plm-target"] then
      let source = [fw textFileContentsAtPath !inTargetName.string + "/+config.plm-target"]
      grammar plm_target_grammar on (source, inTargetName.string)
        !?ioAST
        ?importClauseList:let importedFileList
        ?endOfSourceFile:*
      recursiveImportEmbeddedTargetFiles (
        !?ast:ioAST
        !currentDirectory:inTargetName.string
        !importClauseList:importedFileList
        !?importedFilePathSet:ioImportedFileAbsolutePathSet
      )
    else
      error inTargetName
        : "This target is not defined in embedded targets"
    end
  end
#  ioAST.mDeclarationListAST = ast.mDeclarationListAST + ioAST.mDeclarationListAST
#  ioAST.mGlobalVarDeclarationListAST = ast.mGlobalVarDeclarationListAST + ioAST.mGlobalVarDeclarationListAST
#  ioAST.mExtensionDeclarationListAST = ast.mExtensionDeclarationListAST + ioAST.mExtensionDeclarationListAST
#  ioAST.mExtendStaticArrayDeclarationAST = ast.mExtendStaticArrayDeclarationAST + ioAST.mExtendStaticArrayDeclarationAST
#  ioAST.mStandAloneFunctionDeclarationListAST = ast.mStandAloneFunctionDeclarationListAST + ioAST.mStandAloneFunctionDeclarationListAST
#  ioAST.mRequiredProcListAST = ast.mRequiredProcListAST + ioAST.mRequiredProcListAST
#  ioAST.mExternProcListAST = ast.mExternProcListAST + ioAST.mExternProcListAST
#  ioAST.mStandAloneSystemRoutineListAST = ast.mStandAloneSystemRoutineListAST + ioAST.mStandAloneSystemRoutineListAST
#  ioAST.mGuardListAST = ast.mGuardListAST + ioAST.mGuardListAST
#  ioAST.mTargetListAST += ast.mTargetListAST
#  ioAST.mISRDeclarationListAST = ast.mISRDeclarationListAST + ioAST.mISRDeclarationListAST
#  ioAST.mTaskListAST = ast.mTaskListAST + ioAST.mTaskListAST
#  ioAST.mModuleDeclarationListAST = ast.mModuleDeclarationListAST + ioAST.mModuleDeclarationListAST
#  ioAST.mRequiredModuleListAST = ast.mRequiredModuleListAST + ioAST.mRequiredModuleListAST
#  ioAST.mCheckTargetListAST = ast.mCheckTargetListAST + ioAST.mCheckTargetListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportFileSystemTargetFiles
  ?!ast:@ast ioAST
  ?targetDirectory:let @string inTargetDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let absolutePath = inTargetDirectory + "/" + path.string
    if [absolutePath fileExists] then
      if not [ioImportedFileAbsolutePathSet hasKey !absolutePath] then
        ioImportedFileAbsolutePathSet += !absolutePath
        if [absolutePath pathExtension] == "plm" then
          grammar plm_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFileSystemTargetFiles (
            !?ast:ioAST
            !targetDirectory:inTargetDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [absolutePath pathExtension] == "plm-target" then
          grammar plm_target_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFileSystemTargetFiles (
            !?ast:ioAST
            !targetDirectory:inTargetDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      error path : "file does not exist in file system target definition"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportEmbeddedTargetFiles
  ?!ast:@ast ioAST
  ?currentDirectory:let @string inCurrentDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let fullPath = inCurrentDirectory + "/" + path
    let @filewrapper fw = [filewrapper targetTemplates]
    if [fw fileExistsAtPath !fullPath] then
      let embeddedPath = ":" + fullPath
      if not [ioImportedFileAbsolutePathSet hasKey !embeddedPath] then
        ioImportedFileAbsolutePathSet += !embeddedPath
        grammar plm_grammar on ([fw textFileContentsAtPath !fullPath], path.string)
          !?ioAST
          ?importClauseList:let importedFileList
          ?endOfSourceFile:*
        recursiveImportEmbeddedTargetFiles (
          !?ast:ioAST
          !currentDirectory:[fullPath stringByDeletingLastPathComponent]
          !importClauseList:importedFileList
          !?importedFilePathSet:ioImportedFileAbsolutePathSet
        )
      end
    else
      error path : "cannot find this file in embedded files"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportFiles
  ?!ast:@ast ioAST
  ?currentDirectory:@string inCurrentDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let absolutePath = [path.string absolutePathFromPath !inCurrentDirectory]
    if [absolutePath fileExists] then # Exists in file system ?
      if not [ioImportedFileAbsolutePathSet hasKey !absolutePath] then
        ioImportedFileAbsolutePathSet += !absolutePath
        if [absolutePath pathExtension] == "plm" then
          grammar plm_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFiles (
            !?ast:ioAST
            !currentDirectory:inCurrentDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [absolutePath pathExtension] == "plm-target" then
          grammar plm_target_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFiles (
            !?ast:ioAST
            !currentDirectory:inCurrentDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      let @filewrapper fw = [filewrapper targetTemplates]
      if [fw fileExistsAtPath !path.string] then
        let embeddedPath = ":" + path
        if not [ioImportedFileAbsolutePathSet hasKey !embeddedPath] then
          ioImportedFileAbsolutePathSet += !embeddedPath
          if [path pathExtension] == "plm" then
            grammar plm_grammar on ([fw textFileContentsAtPath !path.string], path.string)
              !?ioAST
              ?importClauseList:let importedFileList
              ?endOfSourceFile:*
            recursiveImportFiles (
              !?ast:ioAST
              !currentDirectory:inCurrentDirectory
              !importClauseList:importedFileList
              !?importedFilePathSet:ioImportedFileAbsolutePathSet
            )
          elsif [path pathExtension] == "plm-target" then
            grammar plm_target_grammar on ([fw textFileContentsAtPath !path.string], path.string)
              !?ioAST
              ?importClauseList:let importedFileList
              ?endOfSourceFile:*
            recursiveImportFiles (
              !?ast:ioAST
              !currentDirectory:inCurrentDirectory
              !importClauseList:importedFileList
              !?importedFilePathSet:ioImportedFileAbsolutePathSet
            )
          else
            error path : "invalid extension (should be .plm or .plm-target)"
          end
        end
      else
        error path : "cannot find this file in file system and in embedded files"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
