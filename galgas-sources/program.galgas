#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "plm-target"
message "a target definition text file with the .plm-target extension"
grammar plm_target_grammar
?sourceFilePath:@lstring unused inSourceFile {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "plm"
message "a source text file with the .plm extension"
grammar plm_grammar
?sourceFilePath:@lstring inSourceFile
{
  if ([option .mode value] == "") & not [option .outputConcreteSyntaxTree value] then
    importFilesAndCompile (!sourceFilePath:inSourceFile)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc importFilesAndCompile ?sourceFilePath:let @lstring inSourceFile
{
#--- Parsing
  @ast ast = .default
  grammar plm_grammar in inSourceFile
    !?ast
    ?importClauseList:let importedFileList
    ?endOfSourceFile:let endOfSourceFile
#--- Recursively import files
  @stringset importedFileAbsolutePathSet = .setWithString {!inSourceFile.string}
  let currentDirectory = [inSourceFile stringByDeletingLastPathComponent]
  recursiveImportFiles (
    !?ast:ast
    !currentDirectory:currentDirectory
    !importClauseList:importedFileList
    !?importedFilePathSet:importedFileAbsolutePathSet
  )
#--- Check target names are not duplicated
  if @uint.errorCount == 0 then
    @stringset targetNameSet = {}
    for (targetName) in ast.mTargetListAST do
      if [targetNameSet hasKey !targetName.string] then
        error targetName : "Duplicated target"
      end
      targetNameSet += !targetName.string
    end
  end
#--- Compile project for every target
  if @uint.errorCount == 0 then
    if [ast.mTargetListAST length] == 0 then
      warning endOfSourceFile : "no target: only syntax analysis is performed"
    elsif [ast.mTargetListAST length] > 1 then
      warning endOfSourceFile : [[ast.mTargetListAST length] string] + " targets: only syntax analysis is performed"
    else
      for (targetName) in ast.mTargetListAST do
        compileProject (
          !sourceFile:inSourceFile
          !ast:ast
          !forTarget:targetName
          !endOfSourceFile:endOfSourceFile
          !currentDirectory:currentDirectory
          !importedFilePathSet:importedFileAbsolutePathSet
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc compileProject
  ?sourceFile:let @lstring inSourceFile
  ?ast:let @ast inAST
  ?forTarget:let @lstring inTargetName
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?currentDirectory:let @string inCurrentDirectory
  ?importedFilePathSet:let @stringset inImportedFileAbsolutePathSet
{
  @ast ast = inAST
  @stringset sourceFileAbsolutePathSet = inImportedFileAbsolutePathSet
#------------------------------------------------------------ Add target specific files
  addTargetSpecificFiles (
    !forTarget:inTargetName
    !?toAST:ast
    !currentDirectory:inCurrentDirectory
    !?importedFilePathSet:sourceFileAbsolutePathSet
  )
#------------------------------------------------------------ Add Predefined types
#--- Add boolean type
  ast.mDeclarationListAST += !@booleanDeclaration.new {![boolTypeName () nowhere]}
#--- Literal integer type
  ast.mDeclarationListAST += !@literalIntegerDeclaration.new
#--- Add String type
  ast.mDeclarationListAST += !@literalStringDeclaration.new {![staticStringTypeName () nowhere]}
#------------------------------------------------------------  Add type extensions
  let declarationList = ast.mDeclarationListAST
  var @declarationListAST newDeclarationList = {}
  var extensionDeclarationListAST = ast.mExtensionDeclarationListAST
  for (declaration) in declarationList do
    [declaration addExtension !?extensionDeclarationListAST ?let newDeclaration]
    newDeclarationList += !newDeclaration
  end
  ast.mDeclarationListAST = newDeclarationList
#--- Raise an error for every unhandled extension
  for (typeName * * * *) in extensionDeclarationListAST do
    error typeName : "this type is not defined or does not support extension"
  end
#------------------------------------------------------------ Ordered declaration list
  buildOrderedDeclarationList (
    !ast:ast
    !sourceFile:inSourceFile.string
    !endOfSourceFile:inEndOfSourceFile
    ?orderedDeclarationList:let @declarationListAST orderedDeclarationListAST
  )
#------------------------------------------------------------ Check "check target" declarations
  for (targetNameToCheck) in ast.mCheckTargetListAST do
    if targetNameToCheck.string != inTargetName then
      error targetNameToCheck : "invalid target" fixit { replace "\"" + inTargetName.string + "\"" }
    end
  end
#------------------------------------------------------------ Semantic context
  if @uint.errorCount == 0 then
    @staticStringMap globalLiteralStringMap = {}
    @staticlistValues_listMap staticListValueMap = {}
    buildSemanticContext (
      !orderedDeclarationList:orderedDeclarationListAST
      !sourceFile:inSourceFile
      !ast:ast
      !?staticStringMap:globalLiteralStringMap
      !?staticlistValues:staticListValueMap
      ?context:let @semanticContext semanticContext
    )
  #--- Semantic analysis
    if @uint.errorCount == 0 then
      semanticAnalysis (
        !sourceFile:inSourceFile.string
        !ast:ast
        !context:semanticContext
        !endOfSourceFile:inEndOfSourceFile
        !staticStringMap:globalLiteralStringMap
        ?intermediateCode:@intermediateCodeStruct intermediateCodeStruct
      )
    #--- Code generation
      if @uint.errorCount == 0 then
        codeOptimisation (!?intermediateCode:intermediateCodeStruct)
        codeGeneration (
          !currentDir:inCurrentDirectory
          !outputFile:inSourceFile.string
          !eof:inEndOfSourceFile
          !intermediateCode:intermediateCodeStruct
          !typeMap:semanticContext.mTypeMap
          !target:inTargetName
          !panicCodeType:semanticContext.mPanicCodeType
          !panicLineType:semanticContext.mPanicLineType
          !interrupts:semanticContext.mAvailableInterruptMap
          !staticlistValues:staticListValueMap
          !sourceFileSet:sourceFileAbsolutePathSet
          !sectionImplementation:semanticContext.mSectionInvocationScheme
          !targetParameters:semanticContext.mTargetParameters #.m_C_definitionFiles
#          !SsourceFileList:semanticContext.mTargetParameters.m_S_definitionFiles
#          !LLsourceFileList:semanticContext.mTargetParameters.m_LL_definitionFiles
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc addTargetSpecificFiles
  ?forTarget:let @lstring inTargetName
  ?!toAST:@ast ioAST
  ?currentDirectory:let @string inCurrentDirectory
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  @ast ast = .default
  if [option plm_options.useDirAsTargetDir value] != "" then # Target is definied in files
    let targetDirectory = [[option plm_options.useDirAsTargetDir value] absolutePathFromPath !inCurrentDirectory]
    if [targetDirectory directoryExists] then
      recursiveImportFileSystemTargetFiles (
        !?ast:ast
        !targetDirectory:targetDirectory
        !importClauseList:{!.new {!inTargetName.string + ".plm-target" !inTargetName.location}}
        !?importedFilePathSet:ioImportedFileAbsolutePathSet
      )
    else
      error ["" nowhere]: "the '" + [option plm_options.useDirAsTargetDir value] + "' directory does not exist"
    end
  else # Target is defined in embedded files
  #--- Parse target definition file
    let @filewrapper fw = [filewrapper targetTemplates]
    let source = [fw textFileContentsAtPath !inTargetName.string + "/+config.plm-target"]
    grammar plm_target_grammar on (source, inTargetName.string)
      !?ioAST
      ?importClauseList:let importedFileList
      ?endOfSourceFile:*
    recursiveImportEmbeddedTargetFiles (
      !?ast:ast
      !currentDirectory:inTargetName.string
      !importClauseList:importedFileList
      !?importedFilePathSet:ioImportedFileAbsolutePathSet
    )
  end
  ioAST.mDeclarationListAST = ast.mDeclarationListAST + ioAST.mDeclarationListAST
  ioAST.mGlobalVarDeclarationListAST = ast.mGlobalVarDeclarationListAST + ioAST.mGlobalVarDeclarationListAST
  ioAST.mControlRegisterDeclarationListAST = ast.mControlRegisterDeclarationListAST + ioAST.mControlRegisterDeclarationListAST
  ioAST.mExtensionDeclarationListAST = ast.mExtensionDeclarationListAST + ioAST.mExtensionDeclarationListAST
  ioAST.mProcedureListAST = ast.mProcedureListAST + ioAST.mProcedureListAST
  ioAST.mRequiredProcListAST = ast.mRequiredProcListAST + ioAST.mRequiredProcListAST
  ioAST.mExternProcListAST = ast.mExternProcListAST + ioAST.mExternProcListAST
  ioAST.mStandAloneSystemRoutineListAST = ast.mStandAloneSystemRoutineListAST + ioAST.mStandAloneSystemRoutineListAST
  ioAST.mGuardListAST = ast.mGuardListAST + ioAST.mGuardListAST
  ioAST.mTargetListAST += ast.mTargetListAST
  ioAST.mInitListAST += ast.mInitListAST
  ioAST.mBootListAST += ast.mBootListAST
  ioAST.mPanicClauseListAST += ast.mPanicClauseListAST
  ioAST.mISRDeclarationListAST = ast.mISRDeclarationListAST + ioAST.mISRDeclarationListAST
  ioAST.mTaskListAST = ast.mTaskListAST + ioAST.mTaskListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportFileSystemTargetFiles
  ?!ast:@ast ioAST
  ?targetDirectory:let @string inTargetDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let absolutePath = inTargetDirectory + "/" + path.string
    if [absolutePath fileExists] then
      if not [ioImportedFileAbsolutePathSet hasKey !absolutePath] then
        ioImportedFileAbsolutePathSet += !absolutePath
        if [absolutePath pathExtension] == "plm" then
          grammar plm_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFileSystemTargetFiles (
            !?ast:ioAST
            !targetDirectory:inTargetDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [absolutePath pathExtension] == "plm-target" then
          grammar plm_target_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFileSystemTargetFiles (
            !?ast:ioAST
            !targetDirectory:inTargetDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      error path : "file does not exist in file system target definition"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportEmbeddedTargetFiles
  ?!ast:@ast ioAST
  ?currentDirectory:let @string inCurrentDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let fullPath = inCurrentDirectory + "/" + path
    let @filewrapper fw = [filewrapper targetTemplates]
    if [fw fileExistsAtPath !fullPath] then
      let embeddedPath = ":" + fullPath
      if not [ioImportedFileAbsolutePathSet hasKey !embeddedPath] then
        ioImportedFileAbsolutePathSet += !embeddedPath
        grammar plm_grammar on ([fw textFileContentsAtPath !fullPath], path.string)
          !?ioAST
          ?importClauseList:let importedFileList
          ?endOfSourceFile:*
        recursiveImportEmbeddedTargetFiles (
          !?ast:ioAST
          !currentDirectory:[fullPath stringByDeletingLastPathComponent]
          !importClauseList:importedFileList
          !?importedFilePathSet:ioImportedFileAbsolutePathSet
        )
      end
    else
      error path : "cannot find this file in embedded files"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportFiles
  ?!ast:@ast ioAST
  ?currentDirectory:@string inCurrentDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let absolutePath = [path.string absolutePathFromPath !inCurrentDirectory]
    if [absolutePath fileExists] then # Exists in file system ?
      if not [ioImportedFileAbsolutePathSet hasKey !absolutePath] then
        ioImportedFileAbsolutePathSet += !absolutePath
        if [absolutePath pathExtension] == "plm" then
          grammar plm_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFiles (
            !?ast:ioAST
            !currentDirectory:inCurrentDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [absolutePath pathExtension] == "plm-target" then
          grammar plm_target_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFiles (
            !?ast:ioAST
            !currentDirectory:inCurrentDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      let @filewrapper fw = [filewrapper targetTemplates]
      if [fw fileExistsAtPath !path.string] then
        let embeddedPath = ":" + path
        if not [ioImportedFileAbsolutePathSet hasKey !embeddedPath] then
          ioImportedFileAbsolutePathSet += !embeddedPath
          if [path pathExtension] == "plm" then
            grammar plm_grammar on ([fw textFileContentsAtPath !path.string], path.string)
              !?ioAST
              ?importClauseList:let importedFileList
              ?endOfSourceFile:*
            recursiveImportFiles (
              !?ast:ioAST
              !currentDirectory:inCurrentDirectory
              !importClauseList:importedFileList
              !?importedFilePathSet:ioImportedFileAbsolutePathSet
            )
          elsif [path pathExtension] == "plm-target" then
            grammar plm_target_grammar on ([fw textFileContentsAtPath !path.string], path.string)
              !?ioAST
              ?importClauseList:let importedFileList
              ?endOfSourceFile:*
            recursiveImportFiles (
              !?ast:ioAST
              !currentDirectory:inCurrentDirectory
              !importClauseList:importedFileList
              !?importedFilePathSet:ioImportedFileAbsolutePathSet
            )
          else
            error path : "invalid extension (should be .plm or .plm-target)"
          end
        end
      else
        error path : "cannot find this file in file system and in embedded files"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
