#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "plm-target"
message "a target definition text file with the .plm-target extension"
grammar plm_target_grammar
?sourceFilePath:@lstring unused inSourceFile {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

case . "plm"
message "a source text file with the .plm extension"
grammar plm_grammar
?sourceFilePath:@lstring inSourceFile
{
  if ([option .mode value] == "") & not [option .outputConcreteSyntaxTree value] then
    importFilesAndCompile (!sourceFilePath:inSourceFile)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc importFilesAndCompile ?sourceFilePath:let @lstring inSourceFile
{
#--- Parsing
  @ast ast = .default
  grammar plm_grammar in inSourceFile
    !?ast
    ?importClauseList:let importedFileList
    ?endOfSourceFile:let endOfSourceFile
#--- Recursively import files
  @stringset importedFileAbsolutePathSet = .setWithString {!inSourceFile.string}
  let currentDirectory = [inSourceFile stringByDeletingLastPathComponent]
  recursiveImportFiles (
    !?ast:ast
    !currentDirectory:currentDirectory
    !importClauseList:importedFileList
    !?importedFilePathSet:importedFileAbsolutePathSet
  )
#--- Check target names are not duplicated
  if @uint.errorCount == 0 then
    @stringset targetNameSet = {}
    for (targetName) in ast.mTargetList do
      if [targetNameSet hasKey !targetName.string] then
        error targetName : "Duplicated target"
      end
      targetNameSet += !targetName.string
    end
  end
#--- Compile project for every target
  if @uint.errorCount == 0 then
    if [ast.mTargetList length] == 0 then
      warning endOfSourceFile : "no target: only syntax analysis is performed"
    elsif [ast.mTargetList length] > 1 then
      warning endOfSourceFile : [[ast.mTargetList length] string] + " targets: only syntax analysis is performed"
    else
      for (targetName) in ast.mTargetList do
        compileProject (
          !sourceFile:inSourceFile
          !ast:ast
          !forTarget:targetName
          !endOfSourceFile:endOfSourceFile
          !currentDirectory:currentDirectory
          !importedFilePathSet:importedFileAbsolutePathSet
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc compileProject
  ?sourceFile:let @lstring inSourceFile
  ?ast:let @ast inAST
  ?forTarget:let @lstring inTargetName
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?currentDirectory:let @string inCurrentDirectory
  ?importedFilePathSet:let @stringset inImportedFileAbsolutePathSet
{
  @ast ast = inAST
  @stringset sourceFileAbsolutePathSet = inImportedFileAbsolutePathSet
#--- Add target specific files
  addTargetSpecificFiles (
    !forTarget:inTargetName
    !?toAST:ast
    !currentDirectory:inCurrentDirectory
    !?importedFilePathSet:sourceFileAbsolutePathSet
  )
#--- Add Predefined types
  addPredefinedTypes (!?declarationList:ast.mDeclarationList)
#--- Add type extensions
  let declarationList = ast.mDeclarationList
  var @declarationListAST newDeclarationList = {}
  var extensionDeclarationListAST = ast.mExtensionDeclarationListAST
  for (declaration) in declarationList do
    [declaration addExtension !?extensionDeclarationListAST ?let newDeclaration]
    newDeclarationList += !newDeclaration
  end
  ast.mDeclarationList = newDeclarationList
#--- Raise an error for every unhandled extension
  for (typeName * * *) in extensionDeclarationListAST do
    error typeName : "this type is not defined or does not support extension"
  end
#--- Ordered declaration list
  buildOrderedDeclarationList (
    !ast:ast
    !sourceFile:inSourceFile.string
    !endOfSourceFile:inEndOfSourceFile
    ?orderedDeclarationList:let @declarationListAST orderedDeclarationListAST
  )
#--- Semantic context
  if @uint.errorCount == 0 then
    @staticStringMap globalLiteralStringMap = {}
    buildSemanticContext (
      !orderedDeclarationList:orderedDeclarationListAST
      !sourceFile:inSourceFile
      !ast:ast
      !?staticStringMap:globalLiteralStringMap
      ?context:let @semanticContext semanticContext
    )
  #--- Semantic analysis
    if @uint.errorCount == 0 then
      semanticAnalysis (
        !sourceFile:inSourceFile.string
        !ast:ast
        !context:semanticContext
        !endOfSourceFile:inEndOfSourceFile
        !staticStringMap:globalLiteralStringMap
        ?intermediateCode:@intermediateCodeStruct intermediateCodeStruct
      )
    #--- Code generation
      if @uint.errorCount == 0 then
        codeOptimisation (!?intermediateCode:intermediateCodeStruct)
        codeGeneration (
          !currentDir:inCurrentDirectory
          !outputFile:inSourceFile.string
          !eof:inEndOfSourceFile
          !intermediateCode:intermediateCodeStruct
          !typeMap:semanticContext.mTypeMap
#          !typeInitialierMap:semanticContext.mTypeInitializerMap
          !target:inTargetName
          !exceptionCodeType:semanticContext.mExceptionCodeType
          !exceptionLineType:semanticContext.mExceptionLineType
          !sourceFileSet:sourceFileAbsolutePathSet
          !proceduresThatShouldNotBeGenerated:semanticContext.mProceduresThatShouldNotBeGenerated
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc addPredefinedTypes
  ?!declarationList:@declarationListAST ioDeclarationList
{
#--- Add boolean type
  ioDeclarationList += !@booleanDeclaration.new {![boolTypeName () nowhere] !{}}
#--- Literal integer type
  ioDeclarationList += !@literalIntegerDeclaration.new
#--- Add String type
  ioDeclarationList += !@literalStringDeclaration.new {![staticStringTypeName () nowhere]}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc addTargetSpecificFiles
  ?forTarget:let @lstring inTargetName
  ?!toAST:@ast ioAST
  ?currentDirectory:let @string inCurrentDirectory
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  @ast ast = .default
  if [option plm_options.useDirAsTargetDir value] != "" then
    let targetDirectory = [[option plm_options.useDirAsTargetDir value] absolutePathFromPath !inCurrentDirectory]
    if [targetDirectory directoryExists] then
      recursiveImportFileSystemTargetFiles (
        !?ast:ast
        !targetDirectory:targetDirectory
        !importClauseList:{!.new {!inTargetName.string + ".plm-target" !inTargetName.location}}
        !?importedFilePathSet:ioImportedFileAbsolutePathSet
      )
    else
      error ["" nowhere]: "the '" + [option plm_options.useDirAsTargetDir value] + "' directory does not exist"
    end
  else
    recursiveImportEmbeddedTargetFiles (
      !?ast:ast
      !importClauseList:{!.new {!inTargetName.string + ".plm-target" !inTargetName.location}}
      !?importedFilePathSet:ioImportedFileAbsolutePathSet
    )
  end
  ioAST.mDeclarationList = ast.mDeclarationList + ioAST.mDeclarationList
  ioAST.mGlobalVarDeclarationList = ast.mGlobalVarDeclarationList + ioAST.mGlobalVarDeclarationList
  ioAST.mControlRegisterDeclarationListAST = ast.mControlRegisterDeclarationListAST + ioAST.mControlRegisterDeclarationListAST
  ioAST.mExtensionDeclarationListAST = ast.mExtensionDeclarationListAST + ioAST.mExtensionDeclarationListAST
  ioAST.mProcedureListAST = ast.mProcedureListAST + ioAST.mProcedureListAST
  ioAST.mRequiredProcList = ast.mRequiredProcList + ioAST.mRequiredProcList
  ioAST.mFunctionListAST = ast.mFunctionListAST + ioAST.mFunctionListAST
  ioAST.mExternProcList = ast.mExternProcList + ioAST.mExternProcList
  ioAST.mSectionListAST = ast.mSectionListAST + ioAST.mSectionListAST
  ioAST.mServiceListAST = ast.mServiceListAST + ioAST.mServiceListAST
  ioAST.mTargetList += ast.mTargetList
  ioAST.mInitList += ast.mInitList
  ioAST.mBootList += ast.mBootList
  ioAST.mExceptionClauses += ast.mExceptionClauses
  ioAST.mExceptionTypes = ast.mExceptionTypes + ioAST.mExceptionTypes
  ioAST.mTaskList = ast.mTaskList + ioAST.mTaskList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportFileSystemTargetFiles
  ?!ast:@ast ioAST
  ?targetDirectory:let @string inTargetDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let absolutePath = inTargetDirectory + "/" + path.string
    if [absolutePath fileExists] then
      if not [ioImportedFileAbsolutePathSet hasKey !absolutePath] then
        ioImportedFileAbsolutePathSet += !absolutePath
        if [absolutePath pathExtension] == "plm" then
          grammar plm_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFileSystemTargetFiles (
            !?ast:ioAST
            !targetDirectory:inTargetDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [absolutePath pathExtension] == "plm-target" then
          grammar plm_target_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFileSystemTargetFiles (
            !?ast:ioAST
            !targetDirectory:inTargetDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      error path : "file does not exist in file system target definition"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportEmbeddedTargetFiles
  ?!ast:@ast ioAST
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let @filewrapper fw = [filewrapper targetTemplates]
    if [fw fileExistsAtPath !path.string] then
      let embeddedPath = ":" + path
      if not [ioImportedFileAbsolutePathSet hasKey !embeddedPath] then
        ioImportedFileAbsolutePathSet += !embeddedPath
        if [path pathExtension] == "plm" then
          grammar plm_grammar on ([fw textFileContentsAtPath !path.string], path.string)
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportEmbeddedTargetFiles (
            !?ast:ioAST
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [path pathExtension] == "plm-target" then
          grammar plm_target_grammar on ([fw textFileContentsAtPath !path.string], path.string)
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportEmbeddedTargetFiles (
            !?ast:ioAST
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      error path : "cannot find this file in embedded files"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc recursiveImportFiles
  ?!ast:@ast ioAST
  ?currentDirectory:@string inCurrentDirectory
  ?importClauseList:@lstringlist inImportedClauseList
  ?!importedFilePathSet:@stringset ioImportedFileAbsolutePathSet
{
  for (path) in inImportedClauseList do
    let absolutePath = [path.string absolutePathFromPath !inCurrentDirectory]
    if [absolutePath fileExists] then # Exists in file system ?
      if not [ioImportedFileAbsolutePathSet hasKey !absolutePath] then
        ioImportedFileAbsolutePathSet += !absolutePath
        if [absolutePath pathExtension] == "plm" then
          grammar plm_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFiles (
            !?ast:ioAST
            !currentDirectory:inCurrentDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        elsif [absolutePath pathExtension] == "plm-target" then
          grammar plm_target_grammar in @lstring.new {!absolutePath !path.location}
            !?ioAST
            ?importClauseList:let importedFileList
            ?endOfSourceFile:*
          recursiveImportFiles (
            !?ast:ioAST
            !currentDirectory:inCurrentDirectory
            !importClauseList:importedFileList
            !?importedFilePathSet:ioImportedFileAbsolutePathSet
          )
        else
          error path : "invalid extension (should be .plm or .plm-target)"
        end
      end
    else
      let @filewrapper fw = [filewrapper targetTemplates]
      if [fw fileExistsAtPath !path.string] then
        let embeddedPath = ":" + path
        if not [ioImportedFileAbsolutePathSet hasKey !embeddedPath] then
          ioImportedFileAbsolutePathSet += !embeddedPath
          if [path pathExtension] == "plm" then
            grammar plm_grammar on ([fw textFileContentsAtPath !path.string], path.string)
              !?ioAST
              ?importClauseList:let importedFileList
              ?endOfSourceFile:*
            recursiveImportFiles (
              !?ast:ioAST
              !currentDirectory:inCurrentDirectory
              !importClauseList:importedFileList
              !?importedFilePathSet:ioImportedFileAbsolutePathSet
            )
          elsif [path pathExtension] == "plm-target" then
            grammar plm_target_grammar on ([fw textFileContentsAtPath !path.string], path.string)
              !?ioAST
              ?importClauseList:let importedFileList
              ?endOfSourceFile:*
            recursiveImportFiles (
              !?ast:ioAST
              !currentDirectory:inCurrentDirectory
              !importClauseList:importedFileList
              !?importedFilePathSet:ioImportedFileAbsolutePathSet
            )
          else
            error path : "invalid extension (should be .plm or .plm-target)"
          end
        end
      else
        error path : "cannot find this file in file system and in embedded files"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
