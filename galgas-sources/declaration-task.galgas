#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskList {
  @lstring mTaskName
  @lbigint mPriority
  @lbigint mStackSize
  @taskVarListAST mVarList
  @taskProcListAST mTaskProcList
  @location mEndOfTaskDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskVarListAST {
  @lstring mVarName
  @lstring mVarTypeName
  @expressionAST mVarInitExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskProcListAST {
  @lstring mProcName
  @instructionListAST mInstructionList
  @location mEndOfProcDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $task$
    $identifier$ ?let taskName
    $priority$
    $integer$ ?let @lbigint priority
    $stackSize$
    $integer$ ?let @lbigint stackSize
    ${$
    @taskVarListAST taskVarList = {}
    @taskProcListAST taskProcList = {}
    repeat
    while
      $var$
      $identifier$ ?let varName
      @lstring typeName
      select
        typeName = ["" nowhere]
      or
        $typeName$ ?typeName
      end
      $=$
      <expression> ?let initExpression
      taskVarList += !varName !typeName !initExpression
    while
      $proc$
      $identifier$ ?let procName
      ${$
      <instructionList> ?let instructionList !?*
      let endOfProc = @location.here
      $}$
      taskProcList += !procName !instructionList !endOfProc
    end
    let endOfTask = @location.here
    $}$
    ioAST.mTaskList +=
      !taskName
      !priority
      !stackSize
      !taskVarList
      !taskProcList
      !endOfTask
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for variable in mVarList do
      [variable.mVarInitExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
      if variable.mVarTypeName.string != "" then
        let typeName = @lstring.new {!"$" + variable.mVarTypeName !variable.mVarTypeName.location}
        [!?ioGraph noteNode !typeName]
      end
    end
    for procedure in mTaskProcList do
      [procedure.mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskVariableMap {
  @unifiedTypeMap-proxy mType
  @valueIR mInitialValue
  insert insertKey error message "the '%K' task variable is already declared in %L"
  search searchKey error message "there is no '%K' task variable"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskProcedureMap {
  insert insertKey error message "the '%K' proc is already declared in %L"
  search searchKey error message "there is no '%K' proc"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskMap {
  @taskProcedureMap mTaskProcedureMap
  insert insertKey error message "the '%K' task is already declared in %L"
  search searchKey error message "there is no '%K' task"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  for task in self do
  #--- task variables
    @propertyList propertyList = {}
    @propertyMap propertyMap = {}
    @operandIRList initialValueList = {}
    for variable in task.mVarList do
      [variable enterInContext
        !taskName:task.mTaskName.string
        !?context:ioContext
        !?staticStringMap:ioGlobalLiteralStringMap
        !?propertyList
        !?propertyMap
        !?initialValueList
      ]
    end
  #--- Enter task variable map as structure type in type map
    [!?ioContext.mTypeMap insertKey
      !lkey:task.mTaskName
      !llvmTypeName:"%$" + task.mTaskName.string
      !kind:.structure {!propertyMap:propertyMap !propertyList:propertyList}
      !typedConstantMap:{}
      !functionMap:{}
      !instanciable:false
      !copiable:false
      !equatable:false
      !comparable:false
      !enumerationType:.null # Not enumerable
    ]
    ioContext.mGlobalTaskVariableList += !task.mTaskName.string !task.mTaskName.string !.llvmStructureConstant{!values:initialValueList}
  #--- Task procedures
    @taskProcedureMap taskProcedureMap = {}
    for procedure in task.mTaskProcList do
      [!?taskProcedureMap insertKey !procedure.mProcName]
    end
    if not [taskProcedureMap hasKey !"setup"] then
      error task.mEndOfTaskDeclaration : "a task should declare an 'setup' procedure"
    end
    if not [taskProcedureMap hasKey !"loop"] then
      error task.mEndOfTaskDeclaration : "a task should declare an 'loop' procedure"
    end
    [!?ioContext.mTaskMap insertKey !task.mTaskName !taskProcedureMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskVarListAST-element enterInContext
  ?taskName:let @string inTaskName
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!@propertyList ioPropertyList
  ?!@propertyMap ioPropertyMap
  ?!@operandIRList ioInitialValueList
{
#--- Get destination type
  @unifiedTypeMap-proxy variableAnnotationType
  if mVarTypeName.string == "" then
    variableAnnotationType = .null
  else
    variableAnnotationType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mVarTypeName}
  end
#--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
  @instructionListIR instructionGenerationList = {}
  @variableMap variableMap = variableMapWithConstants (!context:ioContext)
  [mVarInitExpression analyzeExpression
     !routineNameForInvocationGraph:["compiler" nowhere]
     !optionalTargetType:variableAnnotationType
     !context:ioContext
     !modes:{}
     !allowException:true
     !?temporary:temporaries
     !?staticStringMap:ioGlobalLiteralStringMap
     !?variableMap:variableMap
     !?instructionListIR:instructionGenerationList
     ?result:let @operandIR expressionResult
  ]
  if ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
    error mVarName : "source expression cannot be statically computed"
  end
#--- Check variable type and expression type
  if variableAnnotationType == .null && [[expressionResult.mType kind] isStaticInteger] then
    error mVarName : "cannot infer type"
  end
  let result = checkAssignmentCompatibility (
    !source:expressionResult
    !targetAnnotationType:variableAnnotationType
    !errorLocation:mVarName.location
    !staticTypeAllowed:false
  )
  drop variableAnnotationType, expressionResult
#--- Enter variable in task variable map
  [!?ioContext.mTaskVariableMap insertKey
    !.new{!inTaskName + "." + mVarName !mVarName.location}
    !result.mType
    !result.mValue
  ]
  ioPropertyList += !mVarName.string !result.mType
  [!?ioPropertyMap insertKey !mVarName !result.mType ![ioPropertyMap count]]
  ioInitialValueList += !result
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @stringset prioritySet = {}
  for task in self do
    [task semanticAnalysis
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
    let priorityString = [task.mPriority.bigint string]
    if [prioritySet hasKey !priorityString] then
      error task.mPriority : "duplicate priority"
    end
    prioritySet += !priorityString
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList-element semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check stack size is >= 64, and a multiple of 8
  let stackSize = mStackSize.bigint
  if (stackSize < 64G) || ((stackSize mod 8G) != 0G) then
    error mStackSize : "stack size should be a multiple of 8, and >= 64"
  end
#--- Analyze task procedures
  @taskProcedureMapIR taskProcedureMapIR = {}
  for procedure in mTaskProcList do
    [procedure taskProcedureSemanticAnalysis
      !mTaskName.string
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
  end
#--- Generate task
  [!?ioIntermediateCodeStruct.mTaskMapIR insertKey
    !mTaskName
    !mPriority.bigint
    !mStackSize.bigint
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskProcListAST-element taskProcedureSemanticAnalysis
  ?let @string inTaskName
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Attributes
#  var warnIfUnused = true
#  var globalProcedure = false
#  var weakProcedure = false
#  var nullOnNoException = false
#  for (attribute) in mProcedureAttributeList do
#    if attribute.string == noWarningIfUnusedAttribute () then
#      if not warnIfUnused then
#        error attribute : "duplicate @" + noWarningIfUnusedAttribute () + " attribute"
#      end
#      warnIfUnused = false    
#    elsif attribute.string == globalAttribute () then
#      if globalProcedure then
#        error attribute : "duplicate @" + globalAttribute () + " attribute"
#      end
#      globalProcedure = true    
#    elsif attribute.string == weakAttribute () then
#      if weakProcedure then
#        error attribute : "duplicate @" + weakAttribute () + " attribute"
#      end
#      weakProcedure = true    
#    elsif attribute.string == nullWhenPanicDisabledAttribute () then
#      if nullOnNoException then
#        error attribute : "duplicate @" + nullWhenPanicDisabledAttribute () + " attribute"
#      end
#      nullOnNoException = true    
#    else
#      error attribute : "unknown attribute; available attributes are @"
#        + noWarningIfUnusedAttribute ()
#        + ", @" + weakAttribute ()
#        + ", @" + globalAttribute ()
#    end
#  end
#--- Variable map
  @variableMap variableMap = initialVariableMapForTaskRoutine (
    !taskName:inTaskName
    !context:inContext
  )
#--- Analyse formal arguments
  @procFormalArgumentListForGeneration formalArguments = {}
#  enterFormalArguments (
#    !context:inContext
#    !mProcFormalArgumentList
#    !?variableMap
#    !?formalArguments
#  )
#--- Enter subprogram invocation graph
  let procNameForInvocationGraph = taskProcNameForInvocationGraph (!inTaskName !mProcName)
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !procNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !procNameForInvocationGraph
      !mProcName
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:procNameForInvocationGraph
    !context:inContext
    !modes:{!userModeName ()}
    !allowException:true
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfProcDeclaration]
#--- Code generation
  [!?ioIntermediateCodeStruct.mTaskProcedureMap insertKey
    !.new{!inTaskName + "." + mProcName !mProcName.location}
#    !formalArguments
    !instructionGenerationList
#    ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !mProcedureName.string]
    !true # warnIfUnused
#    !weakProcedure
#    !nullOnNoException
#    !globalProcedure
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskProcedureMapIR {
#  @procFormalArgumentListForGeneration mFormalArgumentListForGeneration
  @instructionListIR mInstructionGenerationList
#  @bool mIsRequired
  @bool mWarnIfUnused
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
  remove removeKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskMapIR {
  @bigint mPriority
  @bigint mStackSize
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
  remove removeKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @taskListIR {
  @string mTaskName
  @bigint mPriority
  @bigint mStackSize
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskMapIR generateCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
#--- Declare task variables
  ioLLVMcode += llvmTitleComment (!"Task variables")
  for (taskName taskTypeName initValueList) in inGenerationContext.mGlobalTaskVariableList do
    ioLLVMcode += "@" + "task.var." + taskName
    ioLLVMcode += " = internal global %$"
    ioLLVMcode += taskTypeName + " "
    let initialString = [initValueList llvmName]
    if initialString == "" then
      ioLLVMcode += "zeroinitializer"
    else
      ioLLVMcode += initialString
    end
    ioLLVMcode += "\n"
  end
  ioLLVMcode += "\n"
#--- Build ordered task list
  @taskListIR orderedTaskList = {}
  for task in self do
    orderedTaskList += !task.lkey.string !task.mPriority !task.mStackSize
  end
#--- Declare stacks and task variables
  for task in orderedTaskList do
    ioLLVMcode += llvmTitleComment (!"Task " + task.mTaskName)
    ioLLVMcode += stackNameForTask (!task.mTaskName) + " = global [" + (task.mStackSize / 4) + " x i32] zeroinitializer\n"
    for (mangledName type initValue) in inGenerationContext.mTaskVariableMap do
      if task.mTaskName == [mangledName stringByDeletingPathExtension] then
        ioLLVMcode += "@" + llvmNameForTaskVariable (!task.mTaskName ![mangledName pathExtension])
        ioLLVMcode += " = internal global "
        ioLLVMcode += [type llvmTypeName] + " "
        let initialString = [initValue llvmName]
        if initialString == "" then
          ioLLVMcode += "zeroinitializer"
        else
          ioLLVMcode += initialString
        end
        ioLLVMcode += "\n"
      end
    end
    ioLLVMcode += "\n"
    for (procMangledName instructionList *) in inGenerationContext.mTaskProcedureMap do
      if task.mTaskName == [procMangledName stringByDeletingPathExtension] then
        ioLLVMcode += llvmSeparatorLine ()
        ioLLVMcode += "\n"
        ioLLVMcode += "define internal void " + taskProcedureName (!task.mTaskName ![procMangledName pathExtension]) + " () nounwind {\n"
        [instructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
        ioLLVMcode += "  ret void\n"
        ioLLVMcode += "}\n\n"
      end
    end
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
    ioLLVMcode += "define internal void " + mainRoutineNameForTask (!task.mTaskName) + " () nounwind noreturn naked {\n"
    ioLLVMcode += "  call void " + taskProcedureName (!task.mTaskName !"setup") + " ()\n"
    ioLLVMcode += "  br label %loop\n"
    ioLLVMcode += "loop:\n"
    ioLLVMcode += "  call void " + taskProcedureName (!task.mTaskName !"loop") + " ()\n"
    ioLLVMcode += "  br label %loop\n"
    ioLLVMcode += "}\n\n"
  end
#--- Start tasks
  ioLLVMcode += llvmTitleComment (!"Start tasks")
  ioLLVMcode += "define internal void @start.tasks () nounwind {\n"
  for task in orderedTaskList do (idx)
    ioLLVMcode += "  " + stackAddressForTask (!task.mTaskName)
    ioLLVMcode += " = getelementptr inbounds [" + (task.mStackSize / 4) + " x i32], "
    ioLLVMcode += "[" + (task.mStackSize / 4) + " x i32]* " + stackNameForTask (!task.mTaskName)
    ioLLVMcode += ", i32 0, i32 0\n"
    ioLLVMcode += "  call void @kernel_create_task ("
    ioLLVMcode += "i32 " + idx
    ioLLVMcode += ", i32* " + stackAddressForTask (!task.mTaskName)
    ioLLVMcode += ", i32 " + task.mStackSize
    ioLLVMcode += ", void ()* " + mainRoutineNameForTask (!task.mTaskName) + ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

