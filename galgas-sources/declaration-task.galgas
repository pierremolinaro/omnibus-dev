#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskList {
  @lstring mTaskName
  @lbigint mPriority
  @lbigint mStackSize
  @taskVarListAST mVarList
  @functionDeclarationListAST mTaskProcList
  @taskInitListAST mTaskInitListAST
  @syncInstructionBranchList mGuardedCommandList
  @location mEndOfTaskDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskVarListAST {
  @lstring mVarName
  @lstring mVarTypeName
  @expressionAST mVarInitExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskInitListAST {
  @lbigint mTaskInitPriority
  @instructionListAST mTaskInitInstructionList
  @location mEndOfTaskInitDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @taskInitSortedListAST {
  @lbigint mTaskInitPriority
  @instructionListAST mTaskInitInstructionList
  @location mEndOfTaskInitDeclaration
  @bigint mPriority
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $task$
    $identifier$ ?let taskName
    $priority$
    $integer$ ?let @lbigint priority
    $stackSize$
    $integer$ ?let @lbigint stackSize
    ${$
    @taskVarListAST taskVarList = {}
    @functionDeclarationListAST taskProcList = {}
    @taskInitListAST taskInitListAST = {}
    @syncInstructionBranchList branchList = {}
    repeat
    while
      $var$
      $identifier$ ?let varName
      @lstring typeName
      select
        typeName = ["" nowhere]
      or
        $typeName$ ?typeName
      end
      $=$
      <expression> ?let initExpression
      taskVarList += !varName !typeName !initExpression
    while
      $func$
      $identifier$ ?let procName
      <procedure_formal_arguments> ?formalArguments:let @procFormalArgumentList formalArgumentList
      @lstring returnTypeName
      select
        returnTypeName = ["" here]
      or
        $->$
        $typeName$ ?returnTypeName
      end
      ${$
      <instructionList> ?let instructionList !?*
      let endOfProc = @location.here
      $}$
      taskProcList += !{} !false !procName !{} !formalArgumentList !returnTypeName !instructionList !endOfProc
    while
      $init$
      $integer$ ?let @lbigint priority
      ${$
      <instructionList> ?let instructionList !?*
      let endOfInit = @location.here
      $}$
      taskInitListAST += !priority !instructionList !endOfInit
    while
      <guarded_command> ?let @guardedCommand guardedCommand
      ${$
      <instructionList> ?let instructionList !?*
      let endOfInstructions = @location.here
      $}$
      branchList += !guardedCommand !instructionList !endOfInstructions
    end
    let endOfTask = @location.here
    $}$
    ioAST.mTaskList +=
      !taskName
      !priority
      !stackSize
      !taskVarList
      !taskProcList
      !taskInitListAST
      !branchList
      !endOfTask
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for variable in mVarList do
      [variable.mVarInitExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
      if variable.mVarTypeName.string != "" then
        let typeName = @lstring.new {!"$" + variable.mVarTypeName !variable.mVarTypeName.location}
        [!?ioGraph noteNode !typeName]
      end
    end
    for procedure in mTaskProcList do
      [procedure.mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    end
    for guardedCommand in mGuardedCommandList do
      [guardedCommand.mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskProcedureMap {
  insert insertKey error message "the '%K' proc is already declared in %L"
  search searchKey error message "there is no '%K' proc"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskMap {
  @taskProcedureMap mTaskProcedureMap
  insert insertKey error message "the '%K' task is already declared in %L"
  search searchKey error message "there is no '%K' task"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  for task in self do
  #--- task variables
    @propertyList propertyList = {}
    @propertyMap propertyMap = {}
    @operandIRList initialValueList = {}
    @namedObjectMap objectMap = {}
    for variable in task.mVarList do
      [variable enterInContext
        !?context:ioContext
        !?staticStringMap:ioGlobalLiteralStringMap
        !?propertyList
        !?propertyMap
        !?objectMap
        !?initialValueList
      ]
    end
  #--- Enter task variable map as structure type in type map
    [!?ioContext.mTypeMap insertType
      !lkey:task.mTaskName
      !llvmTypeName:"%" + ["$" + task.mTaskName assemblerRepresentation]
      !kind:.structure {!objectMap: objectMap !propertyMap:propertyMap !propertyList:propertyList}
      !classConstantMap:{}
      !instantiable:false
      !copyable:false
      !equatable:false
      !comparable:false
      !enumerationType:.null # Not enumerable
    ]
    let taskType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !task.mTaskName}
    ioContext.mGlobalTaskVariableList +=
      !task.mTaskName.string 
      !task.mTaskName.string
      !.llvmStructureConstant{!type: taskType !values:initialValueList}
  #--- Task procedures
    [task.mTaskProcList enterFunctionInContext !selfTypeName:"$" + task.mTaskName !?context:ioContext]
#    @taskProcedureMap taskProcedureMap = {}
#    for procedure in task.mTaskProcList do
#      [!?taskProcedureMap insertKey !procedure.mFunctionName]
#    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskVarListAST-element enterInContext
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!@propertyList ioPropertyList
  ?!@propertyMap ioPropertyMap
  ?!@namedObjectMap ioObjectMap
  ?!@operandIRList ioInitialValueList
{
#--- Get destination type
  @unifiedTypeMap-proxy variableAnnotationType
  if mVarTypeName.string == "" then
    variableAnnotationType = .null
  else
    variableAnnotationType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mVarTypeName}
  end
#--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
  @instructionListIR instructionGenerationList = {}
  @allocaList allocaList = {}
  variableMapWithConstants (
    !context:ioContext
    ?@variableMap variableMap
    ?@namedObjectMap namedObjectMap
    ?@localVariableMap localVariableMap
  )
  [mVarInitExpression analyzeExpression
    !self:.null
    !directAccessToPropertiesAllowed:false
    !inGuard:false
    !routineNameForInvocationGraph:["compiler" nowhere]
    !optionalTargetType:variableAnnotationType
    !context:ioContext
    !modes:{}
    !allowPanic:true
    !?temporary:temporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:variableMap
    !?localVariableMap: localVariableMap
    !?namedObjectMap: namedObjectMap
    !?alloca:allocaList
    !?instructionListIR:instructionGenerationList
    ?result:let @valueIR expressionResult
  ]
  if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [expressionResult isStatic] then
    error mVarName : "source expression cannot be statically computed"
  end
#--- Check variable type and expression type
  if variableAnnotationType == .null && [[expressionResult kind] isStaticInteger] then
    error mVarName : "cannot infer type"
  end
  let @valueIR result = checkAssignmentCompatibility (
    !source:expressionResult
    !targetAnnotationType:variableAnnotationType
    !errorLocation:mVarName.location
    !staticTypeAllowed:false
  )
  drop variableAnnotationType, expressionResult
#--- Enter variable
  if not [[result type] instantiable] then
    error mVarName : "$" + [result key] + " type is not instanciable"
  end
  [!?ioPropertyMap insertKey !mVarName !false ![result type] ![ioPropertyList length]]
  ioInitialValueList += !result
  [!?ioObjectMap insertKey
    !mVarName
    !.property {!type:[result type] !name:mVarName !index:[ioPropertyList length]}
  ]
  ioPropertyList += !mVarName.string ![result type]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @stringset prioritySet = {}
  for task in self do
    [task semanticAnalysis
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
    let priorityString = [task.mPriority.bigint string]
    if [prioritySet hasKey !priorityString] then
      error task.mPriority : "duplicate priority"
    end
    prioritySet += !priorityString
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskList-element semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#------------------------------------------- Check stack size is >= 64, and a multiple of 8
  let stackSize = mStackSize.bigint
  if (stackSize < 64G) || ((stackSize mod 8G) != 0G) then
    error mStackSize : "stack size should be a multiple of 8, and >= 64"
  end
#------------------------------------------- Analyze task procedures
  let taskType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTaskName}
  for procedure in mTaskProcList do
    routineSemanticAnalysis (
      !receiverType:taskType
      !.function
      !{!.new {!userModeName () !procedure.mFunctionName.location}}
      !procedure.mFunctionName
      !procedure.mFunctionFormalArgumentList
      !returnTypeName:procedure.mFunctionReturnTypeName
      !procedure.mFunctionInstructionList
      !procedure.mEndOfFunctionDeclaration
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !warnIfUnused:true
      !globalFunction:false
      !weakFunction:false
      !registerAccess:.noAccess
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
#------------------------------------------- Analyze task init routines
  @taskInitSortedListAST taskInitSortedListAST = {}
  for (priority instructionList endOfDeclaration) in mTaskInitListAST do
    taskInitSortedListAST += !priority !instructionList !endOfDeclaration !priority.bigint
  end
  @instructionListIR initInstructionListIR = {}
  @allocaList initAllocaList = {}
  for (taskInitPriority taskInitInstructionList endOfTaskInitDeclaration *) in taskInitSortedListAST do
    initSemanticAnalysis (
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
      !selfType:taskType
      !priority:taskInitPriority
      !modes:{!userModeName ()}
      !requiredBy:{}
      !instructionList:taskInitInstructionList
      !endOfDeclaration:endOfTaskInitDeclaration
      ?let partialAllocaList
      ?let @instructionListIR partialInstructionGenerationList
    )
    initInstructionListIR += partialInstructionGenerationList
    initAllocaList += partialAllocaList
  end
#------------------------------------------- Analyze task guarded command
#  Build a "task.loop" function that contains a sync instruction
  @instructionListAST taskListInstructionList = {}
  if [mGuardedCommandList length] > 0 then
    let syncInstruction = @syncInstructionAST.new {!mTaskName.location !mGuardedCommandList !mTaskName.location}
    taskListInstructionList += !.nowhere !syncInstruction
  end
  routineSemanticAnalysis (
    !receiverType:taskType
    !.function
    !{!.new {!userModeName () !mTaskName.location}}
    !.new {!llvmNameForTaskLoopFunction () !mTaskName.location}
    !{} # No argument
    !returnTypeName:["" nowhere]
    !taskListInstructionList
    !mTaskName.location
    !directAccessToPropertiesAllowed:true
    !propertiesAreMutable:true
    !warnIfUnused:true
    !globalFunction:false
    !weakFunction:false
    !registerAccess:.noAccess
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  )
#------------------------------------------- Generate task
  [!?ioIntermediateCodeStruct.mTaskMapIR insertKey
    !mTaskName
    !taskType
    !mPriority.bigint
    !mStackSize.bigint
    !initAllocaList
    !initInstructionListIR
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskMapIR {
  @unifiedTypeMap-proxy mTaskType
  @bigint mPriority
  @bigint mStackSize
  @allocaList mAllocaList
  @instructionListIR mInitInstructionListIR
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
  remove removeKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @taskSortedListIR {
  @string mTaskName
  @bigint mPriority
  @bigint mStackSize
  @allocaList mAllocaList
  @instructionListIR mInitInstructionListIR
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskMapIR generateCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
  ?!@2stringlist ioServiceList
{
#--- Declare task self terminate service
  ioLLVMcode += llvmTitleComment (!"Task self terminate service")
  let selfTerminateImplementationName = llvmNameForServiceImplementation (!llvmNameForTaskSelfTerminateService ())
  let selfTerminateCallName = llvmNameForServiceCall (!llvmNameForTaskSelfTerminateService ())
  ioServiceList += !selfTerminateCallName !selfTerminateImplementationName
  ioLLVMcode += "declare void @" + selfTerminateCallName + " () nounwind noreturn\n\n"
#--- Declare task variables
  ioLLVMcode += llvmTitleComment (!"Task variables")
  for (taskName taskTypeName initValueList) in inGenerationContext.mGlobalTaskVariableList do
    ioLLVMcode += "@" + llvmNameForTaskGlobalVar (!taskName)
    ioLLVMcode += " = internal global %"
    ioLLVMcode += ["$" + taskTypeName assemblerRepresentation] + " "
    let initialString = [initValueList llvmName]
    if initialString == "" then
      ioLLVMcode += "zeroinitializer"
    else
      ioLLVMcode += initialString
    end
    ioLLVMcode += "\n"
  end
  ioLLVMcode += "\n"
#--- Build ordered task list
  @taskSortedListIR orderedTaskList = {}
  for task in self do
    orderedTaskList += !task.lkey.string !task.mPriority !task.mStackSize  !task.mAllocaList !task.mInitInstructionListIR
  end
#--- Declare task stacks and main routine
  for task in orderedTaskList do
    ioLLVMcode += llvmTitleComment (!"Task " + task.mTaskName)
    let assemblerTaskName = ["$" + task.mTaskName assemblerRepresentation]
    ioLLVMcode += stackNameForTask (!task.mTaskName) + " = global [" + (task.mStackSize / 4) + " x i32] zeroinitializer\n"
    ioLLVMcode += "\n"
    let effectiveParameter = "(%" + assemblerTaskName + " * @" + llvmNameForTaskGlobalVar (!task.mTaskName) + ")"
    let formalArgument = "(%" + assemblerTaskName + " * %self)"
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
    ioLLVMcode += "define internal void " + initNameForTaskType (!task.mTaskName) + " " + formalArgument + llvmAttributeFunction () + "{\n"
    for (variable type) in task.mAllocaList do
      ioLLVMcode += "  %" + llvmNameForLocalVariable (!variable) + " = alloca " + [type llvmTypeName] + "\n"
    end
    [task.mInitInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
    ioLLVMcode += "define internal void " + mainRoutineNameForTask (!task.mTaskName) + " ()" + llvmAttributeFunction () + "noreturn {\n"
    ioLLVMcode += "  call void " + initNameForTaskType (!task.mTaskName) + " " + effectiveParameter + "\n"
    ioLLVMcode += "  call void @" + llvmNameForFunction (!"$" + task.mTaskName + "." + llvmNameForTaskLoopFunction () + "()") + " " + effectiveParameter + "\n"
    ioLLVMcode += "  call void @" + selfTerminateCallName + " ()\n"
    ioLLVMcode += "  unreachable\n"
    ioLLVMcode += "}\n\n"
  end
#--- Start tasks
  ioLLVMcode += llvmTitleComment (!"Start tasks")
  ioLLVMcode += "define internal void @start.tasks ()" + llvmAttributeFunction () + "{\n"
  for task in orderedTaskList do (idx)
    ioLLVMcode += "  " + stackAddressForTask (!task.mTaskName)
    ioLLVMcode += " = getelementptr inbounds [" + (task.mStackSize / 4) + " x i32], "
    ioLLVMcode += "[" + (task.mStackSize / 4) + " x i32]* " + stackNameForTask (!task.mTaskName)
    ioLLVMcode += ", i32 0, i32 0\n"
    ioLLVMcode += "  call void @kernel_create_task ("
    ioLLVMcode += "i32 " + idx
    ioLLVMcode += ", i32* " + stackAddressForTask (!task.mTaskName)
    ioLLVMcode += ", i32 " + task.mStackSize
    ioLLVMcode += ", void ()* " + mainRoutineNameForTask (!task.mTaskName) + ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

