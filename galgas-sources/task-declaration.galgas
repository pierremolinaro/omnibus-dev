#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskListAST {
  @lstring mTaskName
  @lstringlist mLowerPriorityTaskList
  @lbigint mStackSize
  @structurePropertyListAST mVarList
  @functionDeclarationListAST mTaskFunctionList
  @taskSetupListAST mTaskSetupListAST
  @taskSetupListAST mTaskActivateListAST
  @taskSetupListAST mTaskDeactivateListAST
  @syncInstructionBranchListAST mGuardedCommandList
  @location mEndOfTaskDeclaration
  @bool mActivate
}

#·······················································································································

list @taskSetupListAST {
  @lstring mName
  @lstringlist mDependanceList
  @instructionListAST mTaskSetupInstructionList
  @location mEndOfTaskSetupDeclaration
}

#·······················································································································

list @taskSetupSortedListAST {
  @instructionListAST mTaskSetupInstructionList
  @location mEndOfTaskSetupDeclaration
  @luint mPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $task$
    $identifier$ ?let taskName
    @lstringlist higherPriorityTaskList = {}
    select
    or
      $>$
      repeat
        $identifier$ ?let aTaskName
        higherPriorityTaskList += !aTaskName
      while
        $,$
      end
    end
    $@attribute$ ?let stackSizeAttribute
    if stackSizeAttribute.string != "stacksize" then
      error stackSizeAttribute : "this attribute should be @stacksize"
    end
    $integer$ ?let @lbigint stackSize
  #--- @activate attribute
    var activate = false
    select
    or
      $@attribute$ ?let activateAttribute
      if activateAttribute.string != "activate" then
        error activateAttribute : "this attribute should be @activate"
      end
      activate = true
    end
    ${$
    @structurePropertyListAST taskVarList = {}
    @functionDeclarationListAST taskProcList = {}
    @taskSetupListAST taskSetupListAST = {}
    @taskSetupListAST taskActivateListAST = {}
    @taskSetupListAST taskDeactivateListAST = {}
    @syncInstructionBranchListAST branchList = {}
    repeat
    while
      <private_struct_property_declaration> !?ioAST !?taskVarList !true
    while
      $func$
      $identifier$ ?let procName
      <procedure_formal_arguments> !?ioAST ?let @routineFormalArgumentListAST formalArgumentList
      @lstring returnTypeName
      select
        returnTypeName = ["" here]
      or
        $->$
        <type_definition> !?ioAST ?returnTypeName
      end
      ${$
      <instructionList> !?ioAST ?let instructionList
      taskProcList += !.userMode !false !procName !{} !formalArgumentList !returnTypeName !instructionList !.here
      $}$
    while
      $on$
      $@attribute$ ?let attribute
      $identifier$ ?let name
      @lstringlist dependenceList = {}
      select
      or
        $>$
        repeat
          $identifier$ ?let dependenceName
          dependenceList += !dependenceName
        while
          $,$
        end
      end
      ${$
      <instructionList> !?ioAST ?let instructionList
      let endOfInit = @location.here
      $}$
      if attribute.string == "setup" then
        taskSetupListAST += !name !dependenceList !instructionList !endOfInit
      elsif attribute.string == "activate" then
        taskActivateListAST += !name !dependenceList !instructionList !endOfInit
      elsif attribute.string == "deactivate" then
        taskDeactivateListAST += !name !dependenceList !instructionList !endOfInit
      else
        error attribute : "attribute should be @setup, @activate or @deactivate"
      end
    while
      <guarded_command> !?ioAST ?let @guardedCommandAST guardedCommand
      ${$
      <instructionList> !?ioAST ?let instructionList
      let endOfInstructions = @location.here
      $}$
      branchList += !guardedCommand !instructionList !endOfInstructions
    end
    let endOfTask = @location.here
    $}$
    ioAST.mTaskListAST +=
      !taskName
      !higherPriorityTaskList
      !stackSize
      !taskVarList
      !taskProcList
      !taskSetupListAST
      !taskActivateListAST
      !taskDeactivateListAST
      !branchList
      !endOfTask
      !activate
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for variable in mVarList do
      if variable.mPropertyTypeName.string != "" then
        let typeName = llvmTypeNameFromPLMname (!variable.mPropertyTypeName)
        [!?ioGraph noteNode !typeName]
      end
    end
    for setup in mTaskSetupListAST do
      [setup.mTaskSetupInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    end
    for function in mTaskFunctionList do
      [function.mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    end
    for guardedCommand in mGuardedCommandList do
      [guardedCommand.mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskMap {
  @PLMType mTaskType
  insert insertKey error message "the '%K' task is already declared in %L"
  search searchKey error message "there is no '%K' task"
}

#·······················································································································

method @taskListAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList ioGlobalVariableIRList
{
#--- Sort task following their relative priority
  @taskListAST taskList = self
  @taskListAST sortedTaskList = {}
  @stringset handledTaskSet = {}
  var continue = true
  loop ([taskList length]) while continue && ([taskList length] > 0) do
    continue = false
    var idx = 0
    for task in taskList do
      var allPrecedenceDefined = true
      for (precedenceName) in task.mLowerPriorityTaskList while allPrecedenceDefined do
        allPrecedenceDefined = [handledTaskSet hasKey !precedenceName.string]
      end
      if allPrecedenceDefined then
        sortedTaskList +=
          !task.mTaskName
          !task.mLowerPriorityTaskList
          !task.mStackSize
          !task.mVarList
          !task.mTaskFunctionList
          !task.mTaskSetupListAST
          !task.mTaskActivateListAST
          !task.mTaskDeactivateListAST
          !task.mGuardedCommandList
          !task.mEndOfTaskDeclaration
          !task.mActivate
        handledTaskSet += !task.mTaskName.string
        continue = true
        [!?taskList removeAtIndex ?11* !idx]
      else
        idx = idx + 1
      end
    end
  end
#--- Signal unsorted entries as error
  for (name 10*) in taskList do
    error name : "this task is out of priority order"
  end
#---
  @decoratedTaskList decoratedTaskList = {}
  for task in sortedTaskList do
  #--- task variables
    @propertyList propertyList = {}
    @propertyMap propertyMap = {}
    @sortedOperandIRList initialValueList = {}
    for property in task.mVarList do
      [property enterPropertyInContext
        !task.mTaskName
        !?context:ioContext
        !?staticEntityMap:ioStaticEntityMap
        !?propertyList
        !?propertyMap
        !?initialValueList
        !?*
        !?*
        !?*
        !?ioGlobalVariableIRList
      ]
    end
  #---- Add activate function
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !task.mTaskName ?let taskTypeProxy]
    [!?propertyMap addFunctionWithoutArgument
      !?ioSubprogramInvocationGraph
      !receiverTypeProxy:taskTypeProxy
      !methodName:"activate"
      !safe:true
      !resultTypeProxy:.null
      !canMutateProperties:false
    ]
  #---------------- Enter task functions in property map
    [task.mTaskFunctionList enterFunctionsInPropertyMap !?context:ioContext !?propertyMap]
  #---------------- Enter task variable map as structure type in type map
    let taskType = @PLMType.new {
      !propertyMap:propertyMap
      !classConstantMap:{}
      !constructorMap:{}
      !guardMap:{}
      !attributes:.none
      !plmOriginalTypeName:task.mTaskName
      !kind:.structure {!propertyList:propertyList}
      !plmAliasedTypeName:task.mTaskName
    }
    [!?ioContext.mTypeMap insertType
      !lkey:task.mTaskName
      !type:taskType
      !index:[ioContext.mTypeMap count]
    ]
    [!?ioContext.mTaskMap insertKey !task.mTaskName !taskType]
    [!?ioContext.mValuedObjectMap insertTask !task.mTaskName !taskType]
    ioContext.mGlobalTaskVariableList +=
      !task.mTaskName.string 
      !task.mTaskName.string
      !.llvmStructureValue{!type:taskType !values:initialValueList}
  #--- Task functions
    [task.mTaskFunctionList enterFunctionInContext
      !selfTypeName:task.mTaskName
      !?context:ioContext
      !?ioDecoratedDeclarationList
    ]
  #---
    decoratedTaskList += 
      !task.mTaskName
      !task.mStackSize
      !task.mVarList
      !task.mTaskFunctionList
      !task.mTaskSetupListAST
      !task.mTaskActivateListAST
      !task.mTaskDeactivateListAST
      !task.mGuardedCommandList
      !task.mEndOfTaskDeclaration
      !task.mActivate
  end
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedTaskListDeclaration.new {!decoratedTaskList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @decoratedTaskList {
  @lstring mTaskName
  @lbigint mStackSize
  @structurePropertyListAST mVarList
  @functionDeclarationListAST mTaskProcList
  @taskSetupListAST mTaskSetupListAST
  @taskSetupListAST mTaskActivateListAST
  @taskSetupListAST mTaskDeactivateListAST
  @syncInstructionBranchListAST mGuardedCommandList
  @location mEndOfTaskDeclaration
  @bool mActivate
}

#·······················································································································

class @decoratedTaskListDeclaration : @abstractDecoratedDeclaration {
  @decoratedTaskList mTaskList
}

#·······················································································································

override method @decoratedTaskListDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for task in mTaskList do (priority)
    [task taskSemanticAnalysis
      !context:inContext
      !priority:priority
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
  end
}

#·······················································································································

private proc analyzeOrderedTaskRoutines
  ?let @PLMType inTaskType
  ?let @taskSetupListAST inTaskRoutineLISTAST
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  !@instructionListIR outInstructionListIR
  !@allocaList outAllocaList
{
#------------------------------------------- Analyze task setup routines
  @taskSetupSortedListAST taskSetupSortedListAST = {} 
  if [inTaskRoutineLISTAST length] > 0 then
  #--- Check there is exactly one entry without any precedence
    @uint numberOfEntriesWithoutAnyPrecedence = 0
    for (* precedenceList 2*) in inTaskRoutineLISTAST do
      if [precedenceList length] == 0 then
        numberOfEntriesWithoutAnyPrecedence += numberOfEntriesWithoutAnyPrecedence + 1
      end
    end
    if numberOfEntriesWithoutAnyPrecedence == 0 then
      for (name 3*) in inTaskRoutineLISTAST do
        error name : "Exactly one routine should have no precedence"
      end
    elsif numberOfEntriesWithoutAnyPrecedence > 1 then
      for (name precedenceList 2*) in inTaskRoutineLISTAST do
        if [precedenceList length] == 0 then
          error name : "Exactly one routine should have no precedence"
        end
      end    
    end
  #--- Signal unsorted entries as error
    @taskSetupListAST taskSetupListAST = inTaskRoutineLISTAST
    @stringset precedenceSet = {}
    var continue = true
    loop ([inTaskRoutineLISTAST length]) while continue && ([taskSetupListAST length] > 0) do
      continue = false
      var idx = 0
      for (name precedenceList instructionList endOfDeclaration) in taskSetupListAST do
        var allPrecedenceDefined = true
        for (precedenceName) in precedenceList while allPrecedenceDefined do
          allPrecedenceDefined = [precedenceSet hasKey !precedenceName.string]
        end
        if allPrecedenceDefined then
          taskSetupSortedListAST += !instructionList !endOfDeclaration !.new {![taskSetupSortedListAST length] !name}
          precedenceSet += !name.string
          continue = true
          [!?taskSetupListAST removeAtIndex ?4* !idx]
        else
          idx = idx + 1
        end
      end
    end
  #--- Signal unsorted entries as error
    for (name 3*) in taskSetupListAST do
      error name : "this routine is out of execution order"
    end
  end
  outInstructionListIR = {}
  outAllocaList= {}
  for (taskInitInstructionList endOfTaskInitDeclaration taskInitPriority) in taskSetupSortedListAST do
    setupSemanticAnalysis (
      !context:inContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
      !selfType:inTaskType
      !priority:taskInitPriority
      !mode:.userMode
      !instructionList:taskInitInstructionList
      !endOfDeclaration:endOfTaskInitDeclaration
      ?let partialAllocaList
      ?let @instructionListIR partialInstructionGenerationList
    )
    outInstructionListIR += partialInstructionGenerationList
    outAllocaList += partialAllocaList
  end
}

#·······················································································································

method @decoratedTaskList-element taskSemanticAnalysis
  ?context:let @semanticContext inContext
  ?priority:let @uint inPriority
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let taskType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTaskName} type]
#------------------------------------------- Check stack size is >= 64, and a multiple of 8
  let stackSize = mStackSize.bigint
  if (stackSize < 64G) || ((stackSize mod 8G) != 0G) then
    error mStackSize : "stack size should be a multiple of 8, and >= 64"
  end
#------------------------------------------- Analyze task setup routines
  analyzeOrderedTaskRoutines (
    !taskType
    !mTaskSetupListAST
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode: ioIntermediateCodeStruct
    ?let setupInstructionListIR
    ?let setupAllocaList
  )
#------------------------------------------- Analyze task activate routines
  analyzeOrderedTaskRoutines (
    !taskType
    !mTaskActivateListAST
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode: ioIntermediateCodeStruct
    ?let activateInstructionListIR
    ?let activateAllocaList
  )
#------------------------------------------- Analyze task deactivate routines
  analyzeOrderedTaskRoutines (
    !taskType
    !mTaskDeactivateListAST
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode: ioIntermediateCodeStruct
    ?let deactivateInstructionListIR
    ?let deactivateAllocaList
  )
#------------------------------------------- Analyze task guarded command
#  Build a "task.loop" function that contains a sync instruction
  @instructionListAST taskListInstructionList = {}
  if [mGuardedCommandList length] > 0 then
    let syncInstruction = @syncInstructionAST.new {!mTaskName.location !mGuardedCommandList !mTaskName.location}
    taskListInstructionList += !syncInstruction
  end
  routineSemanticAnalysis (
    !receiverType:taskType
    !.function{!executionMode:.userMode}
    !.userMode
    !.new {!llvmNameForTaskLoopFunction () !mTaskName.location}
    !{} # No argument
    !returnTypeName:["" nowhere]
    !taskListInstructionList
    !mTaskName.location
    !routineAttributes:.mutating | .directPropertyAccess | .panicAllowed
    !warnIfUnused:true
    !globalFunction:false
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  )
#------------------------------------------- Task Name string constant index
  [!?ioIntermediateCodeStruct.mStaticEntityMap findOrAddStaticString !mTaskName.string ?let taskNameStringIndex]
#------------------------------------------- Generate task
  [!?ioIntermediateCodeStruct.mTaskMapIR insertKey
    !mTaskName
    !taskType
    !inPriority
    !mStackSize.bigint
    !setupAllocaList
    !setupInstructionListIR
    !activateAllocaList
    !activateInstructionListIR
    !deactivateAllocaList
    !deactivateInstructionListIR
    !taskNameStringIndex
    !mActivate
  ]
}

#·······················································································································

private proc setupSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  ?selfType:let @PLMType inSelfType
  ?priority:let @luint inPriority
  ?mode:let @mode inCurrentMode
  ?instructionList:let @instructionListAST inInstructionListAST
  ?endOfDeclaration:let @location inEndOfInitDeclaration
  !@allocaList outAllocaList
  !@instructionListIR outInstructionGenerationList
{
#--- Check init routine is unique
  let routineNameForInvocationGraph = setupNameForInvocationGraph (!inSelfType.plmOriginalTypeName !inPriority)
#---
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
  end
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
#--- Analyze instruction list
  outInstructionGenerationList = {}
  outAllocaList = {}
  [inInstructionListAST analyzeRoutineInstructionList
    !self:inSelfType
    !routineAttributes:.mutating | .directPropertyAccess | .controlRegisterReadable
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
    !?variableMap:universalMap
    !?alloca:outAllocaList
    !?generatedCode:outInstructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState !?outInstructionGenerationList]
  [!?universalMap closeBranch !inEndOfInitDeclaration]
  [!?universalMap closeOverride !inEndOfInitDeclaration]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @taskMapIR {
  @PLMType mTaskType
  @uint mPriority
  @bigint mStackSize
  @allocaList mSetupAllocaList
  @instructionListIR mSetupInstructionListIR
  @allocaList mActivateAllocaList
  @instructionListIR mActivateInstructionListIR
  @allocaList mDeactivateAllocaList
  @instructionListIR mDeactivateInstructionListIR
  @uint mTaskNameStringIndex
  @bool mActivate
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
  remove removeKey error message "** internal error **"
}

#·······················································································································

sortedlist @taskSortedListIR {
  @string mTaskName
  @uint mPriority
  @bigint mStackSize
  @allocaList mSetupAllocaList
  @instructionListIR mSetupInstructionListIR
  @allocaList mActivateAllocaList
  @instructionListIR mActivateInstructionListIR
  @allocaList mDeactivateAllocaList
  @instructionListIR mDeactivateInstructionListIR
  @uint mTaskNameStringIndex
  @bool mActivate
}{
  mPriority >
}

#·······················································································································

list @globalTaskVariableList {
  @string mTaskName
  @string mTaskTypeName
  @objectIR mInitialValue
}

#·······················································································································

method @taskMapIR generateCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
  ?!@primitiveAndServiceIRlist ioServiceList
{
#---------- Declare "activate task" service
  ioLLVMcode += llvmTitleComment (!"Activate task service")
  let activateTaskImplementationName = llvmNameForServiceImplementation (!llvmNameForActivateTask ())
  let activateTaskCallName = llvmNameForServiceCall (!llvmNameForActivateTask ())
  ioServiceList += !activateTaskCallName !activateTaskImplementationName !false
  ioLLVMcode += "declare void @" + activateTaskCallName + " (i8 %inTaskIndex) nounwind\n\n"
#---------- Declare "wait for activation" service
  ioLLVMcode += llvmTitleComment (!"Wait for activation service")
  let waitForActivationImplementationName = llvmNameForServiceImplementation (!llvmNameForTaskWaitsForActivation ())
  let waitForActivationCallName = llvmNameForServiceCall (!llvmNameForTaskWaitsForActivation ())
  ioServiceList += !waitForActivationCallName !waitForActivationImplementationName !false
  ioLLVMcode += "declare void @" + waitForActivationCallName + " () nounwind\n\n"
#---------- Declare task variables
  ioLLVMcode += llvmTitleComment (!"Task variables")
  for (taskName taskTypeName initValueList) in inGenerationContext.mGlobalTaskVariableList do
    ioLLVMcode += llvmNameForGlobalVariable (!taskName)
    ioLLVMcode += " = internal global %"
    ioLLVMcode += [llvmTypeStringFromPLMname (!taskTypeName) assemblerRepresentation]
    ioLLVMcode += " " + [initValueList llvmValue] + "\n"
  end
  ioLLVMcode += "\n"
#---------- Build ordered task list
  @taskSortedListIR orderedTaskList = {}
  for task in self do
#    message "T " + task.lkey + " " + task.mPriority + "\n"
    orderedTaskList +=
      !task.lkey.string
      !task.mPriority
      !task.mStackSize
      !task.mSetupAllocaList
      !task.mSetupInstructionListIR
      !task.mActivateAllocaList
      !task.mActivateInstructionListIR
      !task.mDeactivateAllocaList
      !task.mDeactivateInstructionListIR
      !task.mTaskNameStringIndex
      !task.mActivate
  end
#---------- Declare task stacks and main routine
  ioLLVMcode += llvmTitleComment (!"Create task extern routine")
  ioLLVMcode += "declare void @kernel_create_task (i32 %inTaskIndex, i8* %inTaskName, i32* %inStackBufferAddress, "
  ioLLVMcode += "i32 %inStackBufferSize, void ()* %inTaskRoutine) nounwind\n\n"
  for task in orderedTaskList do (taskIndex)
    ioLLVMcode += llvmTitleComment (!"Task " + task.mTaskName)
    let assemblerTaskName = [llvmTypeStringFromPLMname (!task.mTaskName) assemblerRepresentation]
    ioLLVMcode += stackNameForTask (!task.mTaskName) + " = global [" + (task.mStackSize / 4) + " x i32] zeroinitializer\n"
    ioLLVMcode += "\n"
    let effectiveParameter = "(%" + assemblerTaskName + "* " + llvmNameForGlobalVariable (!task.mTaskName) + ")"
    let formalArgument = "(%" + assemblerTaskName + "* " + llvmNameForSelf () + ")"
    ioLLVMcode += llvmSeparatorLine () + "\n"
  #---------- Activate method
    let activateFunctionName = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (!task.mTaskName)
      !["activate" nowhere]
      !{}
    )
    ioLLVMcode += "define internal void @" + llvmNameForFunction (!activateFunctionName) + " " + formalArgument + llvmAttributeFunction () + "{\n"
    ioLLVMcode += "  call void @" + activateTaskCallName + " (i8 " + taskIndex + ")\n"
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
  #---------- Setup
    ioLLVMcode += "define internal void " + setupNameForTaskType (!task.mTaskName) + " " + formalArgument + llvmAttributeFunction () + "{\n"
    [task.mSetupAllocaList generateAllocaList !?ioLLVMcode]
    [task.mSetupInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
  #---------- Activate
    ioLLVMcode += "define internal void " + activateNameForTaskType (!task.mTaskName) + " " + formalArgument + llvmAttributeFunction () + "{\n"
    [task.mActivateAllocaList generateAllocaList !?ioLLVMcode]
    [task.mActivateInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
  #---------- Deactivate
    ioLLVMcode += "define internal void " + deactivateNameForTaskType (!task.mTaskName) + " " + formalArgument + llvmAttributeFunction () + "{\n"
    [task.mDeactivateAllocaList generateAllocaList !?ioLLVMcode]
    [task.mDeactivateInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
    ioLLVMcode += llvmSeparatorLine ()
    ioLLVMcode += "\n"
  #---------- Task routine
    ioLLVMcode += "define internal void " + mainRoutineNameForTask (!task.mTaskName) + " ()" + llvmAttributeFunction () + "noreturn {\n"
    ioLLVMcode += "  call void " + setupNameForTaskType (!task.mTaskName) + " " + effectiveParameter + "\n"
    let taskLoopLabel = "loop." + [task.mTaskName assemblerRepresentation]
    ioLLVMcode += "  br label %" + taskLoopLabel + "\n\n"
    ioLLVMcode += taskLoopLabel + ":\n"
    if not task.mActivate then
      ioLLVMcode += "  call void @" + waitForActivationCallName + " ()\n"
    end
    ioLLVMcode += "  call void " + activateNameForTaskType (!task.mTaskName) + " " + effectiveParameter + "\n"
    ioLLVMcode += "  call void @" + llvmNameForFunction (!llvmTypeStringFromPLMname (!task.mTaskName) + "." + llvmNameForTaskLoopFunction () + "()") + " " + effectiveParameter + "\n"
    ioLLVMcode += "  call void " + deactivateNameForTaskType (!task.mTaskName) + " " + effectiveParameter + "\n"
    if task.mActivate then
      ioLLVMcode += "  call void @" + waitForActivationCallName + " ()\n"
    end
    ioLLVMcode += "  br label %" + taskLoopLabel + "\n"
    ioLLVMcode += "}\n\n"
  end
#------------------------------------- Start tasks
  ioLLVMcode += llvmTitleComment (!"Start tasks")
  ioLLVMcode += "define internal void @start.tasks ()" + llvmAttributeFunction () + "{\n"
  for task in orderedTaskList do (idx)
    ioLLVMcode += "  " + stackAddressForTask (!task.mTaskName)
    ioLLVMcode += " = getelementptr inbounds [" + (task.mStackSize / 4) + " x i32], "
    ioLLVMcode += "[" + (task.mStackSize / 4) + " x i32]* " + stackNameForTask (!task.mTaskName)
    ioLLVMcode += ", i32 0, i32 0\n"
    ioLLVMcode += "  %task.name." + idx + " = load i8*, i8** " + literalStringName (!task.mTaskNameStringIndex) + "\n"
    ioLLVMcode += "  call void @kernel_create_task ("
    ioLLVMcode += "i32 " + idx
    ioLLVMcode += ", i8* %task.name." + idx
    ioLLVMcode += ", i32* " + stackAddressForTask (!task.mTaskName)
    ioLLVMcode += ", i32 " + task.mStackSize
    ioLLVMcode += ", void ()* " + mainRoutineNameForTask (!task.mTaskName) + ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
