#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @booleanShortCircuitAndOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @expressionAST mRightExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanShortCircuitAndOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanShortCircuitAndOperatorExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mLeftExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [mRightExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanShortCircuitAndOperatorExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze left expression
  @instructionListIR leftInstructionGenerationList = {}
  [mLeftExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:leftInstructionGenerationList
    ?result:@objectIR leftOperand
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?leftOperand
  ]  
#--- Analyze right expression
  @instructionListIR rightInstructionGenerationList = {}
  [mRightExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !optionalTargetType:[leftOperand type]
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:rightInstructionGenerationList
    ?result:@objectIR rightOperand
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?rightOperand
  ]  
#--- Check left type is boolean
  if [leftOperand type].kind != .boolean then
    error mOperatorLocation : "left operand should be boolean"
  end
#--- Check right type is boolean
  if [rightOperand type].kind != .boolean then
    error mOperatorLocation : "left operand should be boolean"
  end
#--- Static operation, or dynamic operation
  if [leftOperand isLiteralInteger] && [rightOperand isLiteralInteger] then
    [leftOperand literalInteger ?type:* ?value:let @bigint leftStaticValue]
    [rightOperand literalInteger ?type:* ?value:let @bigint rightStaticValue]
    outResult = .literalInteger {!type:[leftOperand type] !value:leftStaticValue & rightStaticValue}
  else
  #--- Result type : bool 
    getNewTempValue (![inContext booleanType] !?ioTemporaries ?outResult)
  #--- Generate code
    [!?ioInstructionGenerationList appendShortCircuitAndOperation
      !outResult
      !leftOperand
      !leftInstructionGenerationList
      !rightOperand
      !rightInstructionGenerationList
      !mOperatorLocation
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
