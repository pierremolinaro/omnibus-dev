#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forInstructionAST : @instructionAST {
  @lstring mVarName
  @expressionAST mIteratedExpression
  @location mEndOf_iteratedExpression_instruction
  @instructionListAST mDoInstructionList
  @location mEndOf_do_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $for$
    $identifier$ ?let varName
    $in$
    <expression> ?let @expressionAST expression
    let endOf_iteratedExpression_instruction = @location.here
    ${$
    <instructionList> ?let instructionList
    let endOfInstruction = @location.here
    $}$
    ioInstructionList += !varName.location !@forInstructionAST.new {
      !varName
      !expression
      !endOf_iteratedExpression_instruction
      !instructionList
      !endOfInstruction
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mDoInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  [mIteratedExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze iterated expression
  [mIteratedExpression analyzeExpression
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.null
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR iteratedExpressionResult
  ]
#--- Get iterated element type
  let @unifiedTypeMap-proxy iteratedElementType = [[iteratedExpressionResult type] enumerationType]
  if iteratedElementType == .null then
    error mEndOf_iteratedExpression_instruction : "this object is not enumerable"
  end
#---
  let enumeratedVarLLVMName = @lstring.new {!mVarName.string + "." + ioTemporaries.mTemporaryIndex !mVarName}
  ioTemporaries.mTemporaryIndex ++
  ioAllocaList += !enumeratedVarLLVMName !iteratedElementType
#--- Analyze instruction list
  [!?ioVariableMap openOverrideForRepeatBlock]
  [!?ioVariableMap insertUsedConstant
    !lkey:mVarName
    !type:iteratedElementType
    !readAccessAllowed:true # Read access ok
    !objectIR:.localVariableReference {!type:iteratedElementType !plmName:enumeratedVarLLVMName}
    !copyable:true
    !canBeUsedAsInputParameter:false
  ]
  @instructionListIR instructionGenerationList = {}
  [mDoInstructionList analyzeBranchInstructionList
    !self:inSelfType
    !propertiesAreMutable:inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !endOfInstructionList:mEndOf_do_instruction
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:instructionGenerationList
  ]
  [!?ioVariableMap closeOverride !mEndOf_do_instruction]
#--- Type kind
  let iteratedTypeKind = [[iteratedExpressionResult type] kind]
#--- Code generation
  if iteratedTypeKind == .literalString then
    ioInstructionGenerationList += !@forInstructionOnStringIR.new {
      !enumeratedVarLLVMName
      !mEndOf_iteratedExpression_instruction
      !iteratedExpressionResult
      !instructionGenerationList
    }
  elsif [iteratedTypeKind isArrayType] then
    [iteratedTypeKind arrayType ?elementType:let elementType ?size:let size]
    let varStaticListInMemory = "for." + [mEndOf_iteratedExpression_instruction locationIndex] + ".list.in.memory"
    ioAllocaList += !varStaticListInMemory ![iteratedExpressionResult type]
    let varIndexInMemory = "for." + [mEndOf_iteratedExpression_instruction locationIndex] + ".index"
    ioAllocaList += !varIndexInMemory !.searchKey {!inContext.mTypeMap !.new {!"uint32" !.nowhere}}
    let varPtrInMemory = "for." + [mEndOf_iteratedExpression_instruction locationIndex] + ".ptr"
    ioAllocaList += !varPtrInMemory !.searchKey {!inContext.mTypeMap !.new {!"uint32" !.nowhere}}
    ioInstructionGenerationList += !@forInstructionOnArrayIR.new {
      !enumeratedVarLLVMName
      !mEndOf_iteratedExpression_instruction
      !iteratedExpressionResult
      !instructionGenerationList
      !elementType
      !size
      !varStaticListInMemory
      !varIndexInMemory
    }
  else
    error mEndOf_iteratedExpression_instruction : "this object is not enumerable"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION (ON ARRAY)
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forInstructionOnArrayIR : @abstractInstructionIR {
  @string mVarName
  @location mLocation
  @objectIR mExpressionResult
  @instructionListIR mInstructionList
  @unifiedTypeMap-proxy mElementType
  @uint mArraySize
  @string mVarStaticListInMemory
  @string mVarIndexInMemory
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#----------------- La boucle exprimée en C est :
#  TYPE_ELEMENT * ptr = VALEUR_LISTE ; 
#  unsigned idx = TAILLE_LISTE ;
#  while (idx > 0) {
#    ... instructions de la boucle ...
#    ptr ++ ;
#    idx -- ;
#  }
#
#-------------------- La boucle est traduite en LLVM :
#  br label %startLabel
#
#startLabel:
#  store [TAILLE_LISTE x %TYPE_ELEMENT] %VALEUR_LISTE, [TAILLE_LISTE x %TYPE_ELEMENT] * %LISTE_EN_MEMOIRE
#  %ptrStart = getelementptr inbounds [TAILLE_LISTE x %TYPE_ELEMENT], [TAILLE_LISTE x %TYPE_ELEMENT]* %LISTE_EN_MEMOIRE, i32 0, i32 0
#  br label %testLabel
#
#testLabel:
#  %ptrVar = phi %TYPE_ELEMENT* [%ptrStart, %startLabel], [%indexVarNext, %loopLabel]
#  %indexVar = phi i32 [TAILLE_LISTE, %startLabel], [%ptrVarNext, %loopLabel]
#  %testExit = icmp eq i32 %indexVar, 0
#  br i1 %testExit, label %endLabel, label %loopLabel
#
#loopLabel:                                      ; preds = %1
#  %...accès.à.une.propriété... = getelementptr inbounds %TYPE_ELEMENT, %TYPE_ELEMENT* %ptrVar, i32 0, i32 0
#  %ptrVarNext = getelementptr inbounds %TYPE_ELEMENT, %TYPE_ELEMENT* %ptrVar, i32 1
#  %indexVarNext = add nsw i32 %indexVar, -1
#  br label %1
#
#endLabel:

override method @forInstructionOnArrayIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let elementTypeLLVMName = [mElementType llvmTypeName]
  let listTypeLLVMName = "[" + mArraySize + " x " + elementTypeLLVMName + "]"
  let startLabel = "for.label." + [mLocation locationIndex] + ".start"
  let testLabel = "for.label." + [mLocation locationIndex] + ".test"
  let exitVar = "for." + [mLocation locationIndex] + ".exit"
  let loopLabel = "for.label." + [mLocation locationIndex] + ".loop"
  let endLabel  = "for.label." + [mLocation locationIndex] + ".end"
#  let ptrVar    = "for." + [mLocation locationIndex] + ".ptr"
  
#--- Start of 'for' instruction
  ioLLVMcode += "  br label %" + startLabel + "\n\n"

#--------- Loop entry
  ioLLVMcode += startLabel + ":\n"
#--- Init pointer
  ioLLVMcode += "  store " + listTypeLLVMName + " " + [mExpressionResult llvmName]
  ioLLVMcode += ", " + listTypeLLVMName + "* %" + llvmNameForLocalVariable (!mVarStaticListInMemory) + "\n"
  ioLLVMcode += "  %" + mVarName + ".start = getelementptr inbounds " + listTypeLLVMName
  ioLLVMcode += ", " + listTypeLLVMName + "* " + "%" + llvmNameForLocalVariable (!mVarStaticListInMemory)
  ioLLVMcode += ", i32 0, i32 0\n"
  ioLLVMcode += "  store " + elementTypeLLVMName + "* %" + mVarName + ".start, "
  ioLLVMcode += elementTypeLLVMName + "* %" + llvmNameForLocalVariable (!mVarName) + "\n"
#--- Init index
  ioLLVMcode += "  store i32 " + mArraySize + ", i32* %" + llvmNameForLocalVariable (!mVarIndexInMemory) + "\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"
  
#--- Test
  ioLLVMcode += testLabel + ":\n"
#  ioLLVMcode += "  %" + ptrVar + " = phi " + elementTypeLLVMName + "* [%" + ptrVar + ".start, %"
#  ioLLVMcode += startLabel + "], [%" + ptrVar + ".next, %" + loopLabel + "]\n"
  ioLLVMcode += "  %" + mVarIndexInMemory + ".test = load i32, i32* %" + llvmNameForLocalVariable (!mVarIndexInMemory) + "\n"
  ioLLVMcode += "  %" + exitVar + " = icmp eq i32 %" + mVarIndexInMemory + ".test, 0\n"
  ioLLVMcode += "  br i1 %" + exitVar + ", label %" + endLabel + ", label %" + loopLabel + "\n\n"

#------------ Loop  
  ioLLVMcode += loopLabel + ":\n"
#--- Loop instructions
  [mInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Increment pointer
  ioLLVMcode += "  %" + mVarName + ".value = load " + elementTypeLLVMName + "* %" + llvmNameForLocalVariable (!mVarName) + "\n"
  ioLLVMcode += "  %" + mVarName + ".next = getelementptr inbounds " + elementTypeLLVMName + ", "
  ioLLVMcode += elementTypeLLVMName + " * %" + mVarName + ".value, i32 1\n"
  ioLLVMcode += "  store " + elementTypeLLVMName + " %" + mVarName + ", " + elementTypeLLVMName
  ioLLVMcode += "* % " + llvmNameForLocalVariable (!mVarName) + "\n"
#--- Decrement index
  ioLLVMcode += "  %" + mVarIndexInMemory + ".value = load i32, i32* %" + llvmNameForLocalVariable (!mVarIndexInMemory) + "\n"
  ioLLVMcode += "  %" + mVarIndexInMemory + ".next = add i32 %" + mVarIndexInMemory + ".value, -1\n"
  ioLLVMcode += "  store i32 %" + mVarIndexInMemory + ".next, i32* %" + llvmNameForLocalVariable (!mVarIndexInMemory) + "\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"

#--- End
  ioLLVMcode += endLabel + ":\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionOnArrayIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION (ON STRING)
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @forInstructionOnStringIR : @abstractInstructionIR {
  @string mVarName
  @location mLocation
  @objectIR mExpressionResult
  @instructionListIR mInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionOnStringIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let startLabel = "for." + [mLocation locationIndex] + ".start"
  let testLabel = "for." + [mLocation locationIndex] + ".test"
  let loopLabel = "for." + [mLocation locationIndex] + ".loop"
  let endLabel  = "for." + [mLocation locationIndex] + ".end"
  let ptrVar    = "for." + [mLocation locationIndex] + ".ptr"
  let currentVar = "for." + [mLocation locationIndex] + ".current"
  
#--- Start of 'for' instruction
  ioLLVMcode += "  br label %" + startLabel + "\n\n"
  ioLLVMcode += startLabel + ":\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"
  
#--- Test
  ioLLVMcode += testLabel + ":\n"
  ioLLVMcode += "  %" + ptrVar + " = phi i8* [" + [mExpressionResult llvmName] + ", %"
  ioLLVMcode += startLabel + "], [%" + ptrVar + ".next, %" + loopLabel + "]\n"
  ioLLVMcode += "  %" + currentVar + " = load i8, i8* %" + ptrVar + "\n"
  ioLLVMcode += "  %" + currentVar + ".nul = icmp eq i8 %" + currentVar + ", 0\n"
  ioLLVMcode += "  br i1 %" + currentVar + ".nul, label %" + endLabel + ", label %" + loopLabel + "\n\n"

#--- Loop  
  ioLLVMcode += loopLabel + ":\n"
  ioLLVMcode += "  store i8 %" + currentVar + ", "
  ioLLVMcode += "i8 * %" + llvmNameForLocalVariable (!mVarName) + "\n"
  [mInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  ioLLVMcode += "  %" + ptrVar + ".next = getelementptr inbounds i8, "
  ioLLVMcode += "i8 * %" + ptrVar + ", i32 1\n"
  ioLLVMcode += "  br label %" + testLabel + "\n\n"

#--- End
  ioLLVMcode += endLabel + ":\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionOnStringIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
