#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @driverPropertyListAST {
  @lstring mPropertyName
  @propertyAttributeList mPropertyAttributeList
  @bool mIsConstant # true if declared with "let"
  @lstring mTypeName # Empty string if no type annotation
  @structurePropertyInitOptionalExpressionAST mOptionalExpression
}

#·······················································································································

list @bootListAST {
  @bootAST mBoot
}

#·······················································································································

struct @driverDeclarationAST {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @driverPropertyListAST mDriverPropertyListAST
  @functionDeclarationListAST mDriverFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mDriverSystemRoutineListAST
  @guardDeclarationListAST mDriverGuardListAST
#  @EXstartupListAST mEXDriverStartupListAST
  @bootListAST mDriverBootListAST
#--- Startup
  @location mStartupLocation
  @instructionListAST mStartupInstructionList
}

#·······················································································································

list @driverDeclarationListAST {
  @driverDeclarationAST mDriver
}

#·······················································································································

list @driverInstanciationArgumentListAST {
  @lstring mSelector
  @expressionAST mExpression
}

#·······················································································································

list @driverInstanciationListAST {
  @lstring mDriverName
  @driverInstanciationArgumentListAST mDriverInstanciationArgumentList
}

#·······················································································································

class @implementedDriverAST : @abstractDeclarationAST {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @bool mIsInstancied
#  @EXstartupListAST mEXDriverStartupListAST
#--- Startup
  @location mStartupLocation
  @instructionListAST mStartupInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <driver_property> ?!@ast ioAST ?!@driverPropertyListAST ioPropertyList {
    @bool constant
    select
      $var$
      constant = false
    or
      $let$
      constant = true
    end
    $identifier$ ?let fieldName
    @propertyAttributeList propertyAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      $integer$ ?let value
      propertyAttributeList += !attribute !value
    end
    select
      <type_definition> !?ioAST ?let typeName
      select
        ioPropertyList += !fieldName !propertyAttributeList !constant !typeName !.noExpression
      or
        $=$
        <expression> !?ioAST ?let initExpression
        ioPropertyList += !fieldName !propertyAttributeList !constant !typeName !.expression {!initExpression:initExpression}
      end
    or
      $=$
      <expression> !?ioAST ?let initExpression
      ioPropertyList += !fieldName !propertyAttributeList !constant !["" nowhere] !.expression {!initExpression:initExpression}
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $driver$
    $identifier$ ?let driverName
    @lstringlist driverDependenceList = {}
    select
    or
      $>$
      repeat
        $identifier$ ?let dependenceName
        driverDependenceList += !dependenceName
      while
        $,$
      end       
    end
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @driverPropertyListAST driverPropertyListAST = {}
    @guardDeclarationListAST guardListAST = {}
    @systemRoutineDeclarationListAST svcListAST = {}
#    @EXstartupListAST startupList = {}
    @bootListAST bootListAST = {}
    @instructionListAST startupInstructionList = {}
    var startupHandled = false
    var startupLocation = @location.here
    repeat
    while
      <declaration_boot>  !?ioAST !driverName !driverDependenceList ?let @bootAST boot
      if [bootListAST length] != 0 then
        error [boot mBootLocation] : "a driver supports at most one boot routine" 
      end
      bootListAST += !boot
    while
      $startup$
      startupLocation = .here
      ${$
      <instructionList> !?ioAST ?startupInstructionList
#      let endOfStartup = @location.here
      $}$
#      <declaration_startup> !?ioAST !driverName !driverDependenceList ?let startup ?startupInstructionList
      if startupHandled then
        error startupLocation : "a driver supports at most one startup routine" 
      end
      startupHandled = true
    while
      <isr> !?ioAST !driverName
    while
      <driver_property>!?ioAST !?driverPropertyListAST
    while
      <function> !?ioAST !?functionDeclarationListAST
    while
     <system_routine>!?ioAST !?svcListAST
    while
      <guard> !?ioAST !?guardListAST
    end
    $}$
  #--- Declare driver
    ioAST.mDriverDeclarationListAST += !@driverDeclarationAST.new {
      !driverName
      !driverDependenceList
      !driverPropertyListAST
      !functionDeclarationListAST
      !svcListAST
      !guardListAST
#      !startupList
      !bootListAST
      !startupLocation
      !startupInstructionList
    }
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $driver$
    $identifier$ ?let driverName
    $($
    @driverInstanciationArgumentListAST driverInstanciationArgumentList = {}
    repeat
    while
      $!selector:$ ?let selector
      <expression> !?ioAST ?let expression
      driverInstanciationArgumentList += !selector !expression
    end
    $)$
    ioAST.mRequiredDriverListAST += !driverName !driverInstanciationArgumentList
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedDriverAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mDriverName !self]
 [!?ioGraph addEdge !mDriverName !typeNameForTypeMapForDriver (!mDriverName)]
 for (driver) in mDriverDependanceList do
   [!?ioGraph addEdge !mDriverName !driver]
 end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @implementedDriverAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "driver " + mDriverName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @implementedDriverAST locationForErrorSignaling -> @location outLocation {
  outLocation = mDriverName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   Driver Names
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func typeNameForTypeMapForDriver ?let @lstring inDriverName -> @lstring {
  result = .new {!"driver." + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func plmTypeSpecificNameForDriver ?let @lstring inDriverName -> @lstring {
  result = .new {!"Driver " + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmDriverNameFromName ?let @lstring inDriverName -> @lstring {
  result = .new {!"driver$" + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  RETAIN REQUIRED DRIVERS IN DECLARATION LIST AST                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @driverInstanciationArgumentMap {
  @expressionAST mExpression
  insert insertKey error message "duplicated '%K' selector"
  search searchKey error message "uninitialized '%K' property"
}

#·······················································································································

map @instanciedDriverMap {
  @driverInstanciationArgumentMap mDriverInstanciationArgumentMap
  insert insertKey error message "the '%K' driver is already instancied in %L"
  search searchKey error message "internal error %K"
}

#·······················································································································

proc retainRequiredDrivers ?!@ast ioAST {
#--- Check at most one drive has no dependence
  @lstringlist driverWithNoDependenceList = {}
  for (declaration) in ioAST.mDriverDeclarationListAST do
     if [declaration.mDriverDependanceList length] == 0 then
       driverWithNoDependenceList += !declaration.mDriverName
     end
  end
  if [driverWithNoDependenceList length] > 1 then
    for (driverName) in driverWithNoDependenceList do
      error driverName : "almost one driver can have no dependence"
    end
  end
#--- Build instancied driver map
  @instanciedDriverMap instanciedDriverMap = {}
  for (driverName args) in ioAST.mRequiredDriverListAST do
     @driverInstanciationArgumentMap driverInstanciationArgumentMap = {}
     for (selector expression) in args do
       [!?driverInstanciationArgumentMap insertKey !selector !expression]
     end
    [!?instanciedDriverMap insertKey !driverName !driverInstanciationArgumentMap]
  end
#--- Append required drivers to declaration list AST (and init list AST)
  @stringset validDriverNames = {} # For checking all required drivers have been declared
  for (declaration) in ioAST.mDriverDeclarationListAST do
    validDriverNames += !declaration.mDriverName.string
    let driverIsInstancied = [instanciedDriverMap hasKey !declaration.mDriverName.string]
  #--- Build driver instanciation property list
    @structurePropertyListAST driverPropertyListAST = {}
    if driverIsInstancied then
      [instanciedDriverMap searchKey !declaration.mDriverName ?let driverInstanciationArgumentMap]
    #--- Build driver property list, adding init expression
      @stringset validArgumentSet = {}
      for (propertyName propertyAttributeList constant optionalPropertyTypeName optionalInitExpression) in declaration.mDriverPropertyListAST do
        @expressionAST initExpression
        switch optionalInitExpression 
        case noExpression :
          [driverInstanciationArgumentMap searchKey !propertyName ?initExpression]
          validArgumentSet += !propertyName.string
        case expression (expression) :
          initExpression = expression
        end
        driverPropertyListAST += 
         !propertyName
         !propertyAttributeList
         !constant
         !false
         !optionalPropertyTypeName
         !.expression{!initExpression:initExpression}
         !true # Variable is singleton
      end
    #--- Check all arguments of driver instanciation have been used
      for (unusedSelector) in [driverInstanciationArgumentMap keySet] - validArgumentSet do
        error [driverInstanciationArgumentMap locationForKey !unusedSelector] : "invalid selector"
      end
    end
  #---
    ioAST.mDeclarationListAST += !@implementedDriverAST.new {
      !declaration.mDriverName
      !declaration.mDriverDependanceList
      !driverIsInstancied
#      !declaration.mEXDriverStartupListAST
      !declaration.mStartupLocation
      !declaration.mStartupInstructionList
    }
    ioAST.mDeclarationListAST += !@structureDeclarationAST.new {
      !typeNameForTypeMapForDriver (!declaration.mDriverName)
      !plmTypeSpecificNameForDriver (!declaration.mDriverName)
      !llvmDriverNameFromName (!declaration.mDriverName)
      !{}
      !false # Do not generate assignment routine
      !driverPropertyListAST
      !declaration.mDriverFunctionDeclarationListAST
      !declaration.mDriverSystemRoutineListAST
      !declaration.mDriverGuardListAST
      !false # Do not implement deinit
    }
#    for (startup) in declaration.mEXDriverStartupListAST do
#      ioAST.mDeclarationListAST += !startup
#    end
#    if [declaration.mEXDriverStartupListAST length] == 0 then
#      ioAST.mDeclarationListAST += !@EXstartupAST.new {
#        !declaration.mDriverName
#        !declaration.mDriverDependanceList
#        !declaration.mDriverName.location
#        !{}
#        !declaration.mDriverName.location
#      }
#    end
    for (boot) in declaration.mDriverBootListAST do
      ioAST.mDeclarationListAST += !boot
    end
    if [declaration.mDriverBootListAST length] == 0 then
      ioAST.mDeclarationListAST += !@bootAST.new {
        !declaration.mDriverName
        !declaration.mDriverDependanceList
        !declaration.mDriverName.location
        !{}
        !declaration.mDriverName.location
      }
    end
  end
  ioAST.mDriverDeclarationListAST = {}
#--- Check all drivers named in instanciation constructs have been implemented
  for (unusedDriverName) in [instanciedDriverMap keySet] - validDriverNames do
    error [instanciedDriverMap locationForKey !unusedDriverName] : "undefined driver"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @driverMap {
  @bool mIsInstancied
  insert insertKey error message "the '%K' driver is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedDriverAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
  [!?ioContext.mDriverMap insertKey !mDriverName !mIsInstancied]
  let driverType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !typeNameForTypeMapForDriver (!mDriverName)} type]
  [!?ioContext.mValuedObjectMap insertDriver !mDriverName !mIsInstancied !driverType]
#---------------- Add startup routine
  ioDecoratedDeclarationList += !@decoratedRoutine.new {
    !typeNameForTypeMapForDriver (!mDriverName)
    !.startupMode
    !.function {!executionMode:.startupMode}
    !true # mWarnIfUnused
    !false # mGlobalFunction
    !.directPropertyAccess # @routineAttributes mRoutineAttributes
    !.new {!"startup" !mStartupLocation} # Function name
    !{} # @routineFormalArgumentListAST mFunctionFormalArgumentList
    !mStartupInstructionList
    !mStartupLocation
    !.new {!"" !mStartupLocation}  # Empty string if no returned value
    !true # Is Required
  }
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedRequiredDriver.new {!mDriverName}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedRequiredDriver : @abstractDecoratedDeclaration {
  @lstring mDriverName
}

#·······················································································································

override method @decoratedRequiredDriver semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let driverTypeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !typeNameForTypeMapForDriver (!mDriverName)}
  let constructorMap = [driverTypeProxy type].constructorMap
  [constructorMap searchKey !.new {!"()" !mDriverName.location} ?* ?let constructorValue]
  [constructorValue structure ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mDriverList += 
    !mDriverName.string
    !driverTypeProxy
    !initialValueList
#--- Build initialized driver set
  ioTemporaries.mInitializedDriverSet += !mDriverName.string
#--- Enter startup routine as required routine
#  [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @driverListIR {
  @string mDriverName
  @unifiedTypeMap-proxy mTypeProxy
  @operandIRList mInitialValueList
}

#·······················································································································

method @driverListIR-element generateLLVMDriverVariableDefinition ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalVariable (!mDriverName) + " = internal global "
  ioLLVMcode += [[mTypeProxy type] llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmValue]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#·······················································································································

method @driverListIR generateLLVMDriverCode ?!@string ioLLVMcode {
  ioLLVMcode += llvmTitleComment (!"Startup")
  ioLLVMcode += "define internal void @startup ()" + llvmAttributeFunction () + "{\n"
  for startup in self do
    let startupRoutineMangledName = routineMangledNameFromAST (
      !llvmDriverNameFromName (![startup.mDriverName nowhere])
      !["startup" nowhere]
      !{}
    )
    ioLLVMcode += "  call void @" + llvmNameForFunction (!startupRoutineMangledName) + " ("
    ioLLVMcode += [[startup.mTypeProxy type] llvmTypeName] + "* " + llvmNameForGlobalVariable (!startup.mDriverName)
    ioLLVMcode += ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
