#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @driverPropertyListAST {
  @lstring mPropertyName
  @propertyAttributeList mPropertyAttributeList
  @bool mIsConstant # true if declared with "let"
  @lstring mTypeName # Empty string if no type annotation
  @structurePropertyInitOptionalExpressionAST mOptionalExpression
}

#·······················································································································

struct @driverDeclarationAST {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @driverPropertyListAST mDriverPropertyListAST
  @functionDeclarationListAST mDriverFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mDriverSystemRoutineListAST
  @guardDeclarationListAST mDriverGuardListAST
#--- Boot
  @location mBootLocation
  @instructionListAST mBootInstructionList
  @location mBootEndLocation
#--- Startup
  @location mStartupLocation
  @instructionListAST mStartupInstructionList
  @location mStartupEndLocation
}

#·······················································································································

list @driverDeclarationListAST {
  @driverDeclarationAST mDriver
}

#·······················································································································

list @driverInstanciationArgumentListAST {
  @lstring mSelector
  @expressionAST mExpression
}

#·······················································································································

list @driverInstanciationListAST {
  @lstring mDriverName
  @driverInstanciationArgumentListAST mDriverInstanciationArgumentList
}

#·······················································································································

class @implementedDriverAST : @abstractDeclarationAST {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @bool mIsInstancied
#--- Boot
  @location mBootLocation
  @instructionListAST mBootInstructionList
  @location mBootEndLocation
#--- Startup
  @location mStartupLocation
  @instructionListAST mStartupInstructionList
  @location mStartupEndLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <driver_property> ?!@ast ioAST ?!@driverPropertyListAST ioPropertyList {
    @bool constant
    select
      $var$
      constant = false
    or
      $let$
      constant = true
    end
    $identifier$ ?let fieldName
    @propertyAttributeList propertyAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      $integer$ ?let value
      propertyAttributeList += !attribute !value
    end
    select
      <type_definition> !?ioAST ?let typeName
      select
        ioPropertyList += !fieldName !propertyAttributeList !constant !typeName !.noExpression
      or
        $=$
        <expression> !?ioAST ?let initExpression
        ioPropertyList += !fieldName !propertyAttributeList !constant !typeName !.expression {!initExpression:initExpression}
      end
    or
      $=$
      <expression> !?ioAST ?let initExpression
      ioPropertyList += !fieldName !propertyAttributeList !constant !["" nowhere] !.expression {!initExpression:initExpression}
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $driver$
    $identifier$ ?let driverName
    @lstringlist driverDependenceList = {}
    select
    or
      $>$
      repeat
        $identifier$ ?let dependenceName
        driverDependenceList += !dependenceName
      while
        $,$
      end       
    end
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @driverPropertyListAST driverPropertyListAST = {}
    @guardDeclarationListAST guardListAST = {}
    @systemRoutineDeclarationListAST svcListAST = {}
    var bootHandled = false
    var bootLocation = @location.here
    @instructionListAST bootInstructionList = {}
    var bootEndLocation = @location.here
    var startupHandled = false
    var startupLocation = @location.here
    @instructionListAST startupInstructionList = {}
    var startupEndLocation = @location.here
    repeat
    while
      $boot$
      bootLocation = .here
      ${$
      <instructionList> !?ioAST ?bootInstructionList
      bootEndLocation = @location.here
      $}$
      if bootHandled then
        error bootLocation : "a driver supports at most one boot routine" 
      end
      bootHandled = true
    while
      $startup$
      startupLocation = .here
      ${$
      <instructionList> !?ioAST ?startupInstructionList
      startupEndLocation = @location.here
      $}$
      if startupHandled then
        error startupLocation : "a driver supports at most one startup routine" 
      end
      startupHandled = true
    while
      <isr> !?ioAST !driverName
    while
      <driver_property>!?ioAST !?driverPropertyListAST
    while
      <function> !?ioAST !?functionDeclarationListAST
    while
     <system_routine>!?ioAST !?svcListAST
    while
      <guard> !?ioAST !?guardListAST
    end
    $}$
  #--- Declare driver
    ioAST.mDriverDeclarationListAST += !@driverDeclarationAST.new {
      !driverName
      !driverDependenceList
      !driverPropertyListAST
      !functionDeclarationListAST
      !svcListAST
      !guardListAST
      !bootLocation
      !bootInstructionList
      !bootEndLocation
      !startupLocation
      !startupInstructionList
      !startupEndLocation
    }
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $driver$
    $identifier$ ?let driverName
    $($
    @driverInstanciationArgumentListAST driverInstanciationArgumentList = {}
    repeat
    while
      $!selector:$ ?let selector
      <expression> !?ioAST ?let expression
      driverInstanciationArgumentList += !selector !expression
    end
    $)$
    ioAST.mRequiredDriverListAST += !driverName !driverInstanciationArgumentList
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedDriverAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mDriverName !self]
 [!?ioGraph addEdge !mDriverName !typeNameForTypeMapForDriver (!mDriverName)]
 for (driver) in mDriverDependanceList do
   [!?ioGraph addEdge !mDriverName !driver]
 end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @implementedDriverAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "driver " + mDriverName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @implementedDriverAST locationForErrorSignaling -> @location outLocation {
  outLocation = mDriverName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   Driver Names
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func typeNameForTypeMapForDriver ?let @lstring inDriverName -> @lstring {
  result = .new {!"driver." + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func plmTypeSpecificNameForDriver ?let @lstring inDriverName -> @lstring {
  result = .new {!"Driver " + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmDriverNameFromName ?let @lstring inDriverName -> @lstring {
  result = .new {!"driver$" + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func llvmBootRoutineNameFromDriver ?let @lstring inDriverName -> @lstring {
  result = .new {!"boot." + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func llvmStartupRoutineNameFromDriver ?let @lstring inDriverName -> @lstring {
  result = .new {!"startup." + inDriverName !inDriverName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  RETAIN REQUIRED DRIVERS IN DECLARATION LIST AST                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @driverInstanciationArgumentMap {
  @expressionAST mExpression
  insert insertKey error message "duplicated '%K' selector"
  search searchKey error message "uninitialized '%K' property"
}

#·······················································································································

map @instanciedDriverMap {
  @driverInstanciationArgumentMap mDriverInstanciationArgumentMap
  insert insertKey error message "the '%K' driver is already instancied in %L"
  search searchKey error message "internal error %K"
}

#·······················································································································

proc retainRequiredDrivers ?!@ast ioAST {
#--- Check at most one drive has no dependence
  @lstringlist driverWithNoDependenceList = {}
  for (declaration) in ioAST.mDriverDeclarationListAST do
     if [declaration.mDriverDependanceList length] == 0 then
       driverWithNoDependenceList += !declaration.mDriverName
     end
  end
  if [driverWithNoDependenceList length] > 1 then
    for (driverName) in driverWithNoDependenceList do
      error driverName : "almost one driver can have no dependence"
    end
  end
#--- Build instancied driver map
  @instanciedDriverMap instanciedDriverMap = {}
  for (driverName args) in ioAST.mRequiredDriverListAST do
     @driverInstanciationArgumentMap driverInstanciationArgumentMap = {}
     for (selector expression) in args do
       [!?driverInstanciationArgumentMap insertKey !selector !expression]
     end
    [!?instanciedDriverMap insertKey !driverName !driverInstanciationArgumentMap]
  end
#--- Append required drivers to declaration list AST (and init list AST)
  @stringset validDriverNames = {} # For checking all required drivers have been declared
  for (declaration) in ioAST.mDriverDeclarationListAST do
    validDriverNames += !declaration.mDriverName.string
    let driverIsInstancied = [instanciedDriverMap hasKey !declaration.mDriverName.string]
  #--- Build driver instanciation property list
    @structurePropertyListAST driverPropertyListAST = {}
    if driverIsInstancied then
      [instanciedDriverMap searchKey !declaration.mDriverName ?let driverInstanciationArgumentMap]
    #--- Build driver property list, adding init expression
      @stringset validArgumentSet = {}
      for (propertyName propertyAttributeList constant optionalPropertyTypeName optionalInitExpression) in declaration.mDriverPropertyListAST do
        @expressionAST initExpression
        switch optionalInitExpression 
        case noExpression :
          [driverInstanciationArgumentMap searchKey !propertyName ?initExpression]
          validArgumentSet += !propertyName.string
        case expression (expression) :
          initExpression = expression
        end
        driverPropertyListAST += 
         !propertyName
         !propertyAttributeList
         !constant
         !false
         !optionalPropertyTypeName
         !.expression{!initExpression:initExpression}
         !true # Variable is singleton
      end
    #--- Check all arguments of driver instanciation have been used
      for (unusedSelector) in [driverInstanciationArgumentMap keySet] - validArgumentSet do
        error [driverInstanciationArgumentMap locationForKey !unusedSelector] : "invalid selector"
      end
    end
  #---
    ioAST.mDeclarationListAST += !@structureDeclarationAST.new {
      !typeNameForTypeMapForDriver (!declaration.mDriverName)
      !plmTypeSpecificNameForDriver (!declaration.mDriverName)
      !llvmDriverNameFromName (!declaration.mDriverName)
      !{}
      !false # Do not generate assignment routine
      !driverPropertyListAST
      !declaration.mDriverFunctionDeclarationListAST
      !declaration.mDriverSystemRoutineListAST
      !declaration.mDriverGuardListAST
      !false # Do not implement deinit
    }
    ioAST.mDeclarationListAST += !@implementedDriverAST.new {
      !declaration.mDriverName
      !declaration.mDriverDependanceList
      !driverIsInstancied
      !declaration.mBootLocation
      !declaration.mBootInstructionList
      !declaration.mBootEndLocation
      !declaration.mStartupLocation
      !declaration.mStartupInstructionList
      !declaration.mStartupEndLocation
    }
  end
  ioAST.mDriverDeclarationListAST = {}
#--- Check all drivers named in instanciation constructs have been implemented
  for (unusedDriverName) in [instanciedDriverMap keySet] - validDriverNames do
    error [instanciedDriverMap locationForKey !unusedDriverName] : "undefined driver"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedDriverAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
  [ioContext.mTypeMap searchKey
    !lkey:typeNameForTypeMapForDriver (!mDriverName)
    ?type:let driverType
  ]
  [!?ioContext.mValuedObjectMap insertDriver !mDriverName !mIsInstancied !driverType]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedRequiredDriver.new {!mDriverName}
#---------------- Add boot routine
  ioDecoratedRoutineList +=
    !receiverTypeName: typeNameForTypeMapForDriver (!mDriverName)
    !mode:.bootMode
    !isRequired:true
    !.function
    !warnIfUnused: true
    !exportedRoutine: false
    !.none
    !llvmBootRoutineNameFromDriver (!mDriverName)
    !{}
    !true # warningOnUnusedArgs
    !mBootInstructionList
    !mBootEndLocation
    !returnTypeName:.new {!"" !mBootLocation}  # Empty string if no returned value
#---------------- Add startup routine
  ioDecoratedRoutineList +=
    !receiverTypeName: typeNameForTypeMapForDriver (!mDriverName)
    !mode:.startupMode
    !isRequired:true
    !.function
    !warnIfUnused: true
    !exportedRoutine: false
    !.none
    !llvmStartupRoutineNameFromDriver (!mDriverName)
    !{} # @routineFormalArgumentListAST mFunctionFormalArgumentList
    !true # warningOnUnusedArgs
    !mStartupInstructionList
    !mStartupEndLocation
    !returnTypeName: .new {!"" !mStartupLocation}  # Empty string if no returned value
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedRequiredDriver : @abstractDecoratedDeclaration {
  @lstring mDriverName
}

#·······················································································································

override method @decoratedRequiredDriver semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [inContext.mTypeMap searchKey
    !lkey:typeNameForTypeMapForDriver (!mDriverName)
    ?type:let driverType
  ]
  let constructorMap = driverType.constructorMap
  [constructorMap searchKey !.new {!"()" !mDriverName.location} ?* ?let constructorValue]
  [constructorValue structure ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mDriverList += 
    !mDriverName
    !driverType
    !initialValueList
#--- Build initialized driver set
  ioTemporaries.mInitializedDriverSet += !mDriverName.string
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @driverListIR {
  @lstring mDriverName
  @PLMType mType
  @operandIRList mInitialValueList
}

#·······················································································································

method @driverListIR-element generateLLVMDriverVariableDefinition ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalVariable (!mDriverName) + " = internal global "
  ioLLVMcode += [mType llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmValue]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#·······················································································································

method @driverListIR generateLLVMDriverCode ?!@string ioLLVMcode {
#--- Boot
  ioLLVMcode += llvmTitleComment (!"Boot")
  ioLLVMcode += "define internal void @boot ()" + llvmAttributeFunction () + "{\n"
  for boot in self do
    ioLLVMcode += "  call void @" + [llvmBootRoutineNameFromDriver (!boot.mDriverName) assemblerRepresentation] + " ("
    ioLLVMcode += [boot.mType llvmTypeName] + "* " + llvmNameForGlobalVariable (!boot.mDriverName)
    ioLLVMcode += ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
#--- Startup
  ioLLVMcode += llvmTitleComment (!"Startup")
  ioLLVMcode += "define internal void @startup ()" + llvmAttributeFunction () + "{\n"
  for startup in self do
    ioLLVMcode += "  call void @" + [llvmStartupRoutineNameFromDriver (!startup.mDriverName) assemblerRepresentation] + " ("
    ioLLVMcode += [startup.mType llvmTypeName] + "* " + llvmNameForGlobalVariable (!startup.mDriverName)
    ioLLVMcode += ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
