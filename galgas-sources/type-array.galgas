#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeArrayDeclarationAST : @abstractDeclarationAST {
  @lstring mArrayTypeName
  @lstring mElementTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclarationAST location -> @location outLocation {
  outLocation = mArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration_type> ?let @lstring inNewTypeName !@abstractDeclarationAST outDeclaration {
    $\$type$ ?let elementTypeName
    $[$
    <expression> ?let sizeExpression
    let sizeExpressionLocation = @location.here
    $]$
    outDeclaration = @typeArrayDeclarationAST.new {
      !inNewTypeName
      !elementTypeName
      !sizeExpression
      !sizeExpressionLocation
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let newTypeName = llvmTypeNameFromPLMname (!mArrayTypeName)
  let elementTypeName = llvmTypeNameFromPLMname (!mElementTypeName)
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !elementTypeName]
  [mSizeExpression addDependenceEdgeForStaticExpression !newTypeName !?ioGraph]
  let rootNode = @lstring.new {!configurationNodeNameForPrecedenceGraph () !mArrayTypeName.location}
  [!?ioGraph addEdge !newTypeName !rootNode]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "arraytype $" + mArrayTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Get element type
  [ioContext.mTypeMap searchKey
    !lkey:mElementTypeName
    ?type:let kind
    ?1*
  ]
  if not [kind copyable] then
    error mElementTypeName : "an array element should be copyable"
  end
  if not [kind instanciable] then
    error mElementTypeName : "an array element should be instanciable"
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  variableMapWithConstants (
    !context:ioContext
    ?@universalValuedObjectMapForContext universalMap
  )
  [mSizeExpression analyzeExpression
    !self:voidType ()
    !inGuard:false
    !routineNameForInvocationGraph:.new {!mArrayTypeName.string + " init" !mArrayTypeName.location}
    !optionalTargetType:voidType ()
    !context:ioContext
    !mode:.bootMode
    !?temporary:temporaries
    !?staticStringMap:*
    !?variableMap:universalMap
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:let @objectIR sizeExpressionIR
  ]
  if not [sizeExpressionIR isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR literalInteger ?1* ?value:let arraySize]
    let elementType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mElementTypeName} type]
  #-------------------------------------------- Class method map : add "count" constructor
    @classConstantMap classConstantMap = {}
   [!?classConstantMap insertKey !.new {!"count" !mArrayTypeName} !arraySize ![staticIntegerTypeName () nowhere]]
  #-------------------------------------------- Property map
    @propertyMap arrayTypePropertyMap = {}
#    [!?propertyMap addFunction
#      !receiverTypeName:integerTypeName
#      !methodName:byteSwappedMethoName ()
#      !resultTypeProxy:selfTypeProxy
#      !?ioSubprogramInvocationGraph
#    ]

    [!?arrayTypePropertyMap insertKey # "count" property
      !.new {!"count" !mArrayTypeName.location}
      !true # public
      !.constantProperty {!value:.literalInteger {!type:staticIntegerType () !value:arraySize}}
    ]
  #-------------------------------------------- Constructor map
    @constructorMap constructorMap = {}
    [!?constructorMap insertKey !["(!repeated)" nowhere] !{} !.arrayValue {!elementType:elementType !size:arraySize}]
  #-------------------------------------------- Type attributes
    @PLMTypeAttributes typeAttributes = .instanciable | .generateAssignmentRoutine
    if [elementType copyable] then
      typeAttributes = typeAttributes | .copyable
    end
  #-------------------------------------------- Enter in type map
    let arrayType = @PLMType.new {
      !arrayTypePropertyMap
      !classConstantMap
      !constructorMap
      !typeAttributes
      !mArrayTypeName
      !.arrayType {!elementType:elementType !size:arraySize}
    }
    [!?ioContext.mTypeMap insertType
      !lkey:mArrayTypeName
      !type:arrayType
      !index:[ioContext.mTypeMap count]
    ]
  #---------------- Add decorated declaration
    ioDecoratedDeclarationList += !@decoratedTypeArrayDeclaration.new {!mArrayTypeName !arraySize}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedTypeArrayDeclaration : @abstractDecoratedDeclaration {
  @lstring mArrayTypeName
  @uint mArraySize
}

#·······················································································································

override method @decoratedTypeArrayDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#----------- Generate enumeration specific code
  ioIntermediateCodeStruct.mGenerationListIR += !@arrayIR.new {!mArrayTypeName !mArraySize}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @arrayIR : @abstractGenerationIR {
  @string mArrayTypePLMName
  @bigint mArraySize
}

#·······················································································································

override method @arrayIR generateLLVMcode ?!@string ioLLVMcode ?!@generationAdds unused ioGenerationAdds {
  let routineMangledName = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!mArrayTypePLMName)
    !["count" nowhere]
    !{}
  )
  let routineLLVMName = llvmNameForFunction (!routineMangledName.string)
  ioLLVMcode += llvmTitleComment (!routineMangledName)
  ioLLVMcode += "define internal i32  @" + routineLLVMName + " (%" + llvmTypeStringFromPLMname (!mArrayTypePLMName) + "* %inUnusedValue) nounwind {\n"
  ioLLVMcode += "  ret i32 " + mArraySize + "\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
