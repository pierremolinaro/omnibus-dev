#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeArrayDeclaration : @abstractDeclaration {
  @lstring mArrayTypeName
  @lstring mElementTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclaration location -> @location outLocation {
  outLocation = mArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $arrayType$
    $typeName$ ?let newTypeName
    $=$
    $typeName$ ?let aliasedTypeName
    $[$
    <expression> ?let sizeExpression
    let sizeExpressionLocation = @location.here
    $]$
    ioAST.mDeclarationList += !@typeArrayDeclaration.new {
      !newTypeName
      !aliasedTypeName
      !sizeExpression
      !sizeExpressionLocation
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let newTypeName = @lstring.new {!"$" + mArrayTypeName !mArrayTypeName.location}
  let elementTypeName = @lstring.new {!"$" + mElementTypeName !mElementTypeName.location}
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !elementTypeName]
  [mSizeExpression addDependenceEdgeForStaticExpression !newTypeName !?ioGraph]
  let rootNode = @lstring.new {!"config" !mArrayTypeName.location}
  [!?ioGraph addEdge !newTypeName !rootNode]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "arraytype $" + mArrayTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  let elementType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mElementTypeName}
#--- Enter "count" function
  let countkey = @lstring.new {!"$" + mArrayTypeName + ".count" !mArrayTypeName.location}
  let countType = ioContext.mUnsignedIntegerType
  [!?ioContext.mRoutineMapForContext insertKey
    !countkey
    !true # Public
    !allModeMap ()
    !{} # Signature
    !.function
    !false # Is not weak
    !countType
  ]
#--- Enter "append" function
  let appendKey = @lstring.new {!"$" + mArrayTypeName + ".append" !mArrayTypeName.location}
  [!?ioContext.mRoutineMapForContext insertKey
    !appendKey
    !true # Public
    !allModeMap ()
    !{!.input !"" !elementType} # Signature
    !.function
    !false # Is not weak
    !.null # No return type
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Get element type
  [ioContext.mTypeMap searchKey
    !lkey:mElementTypeName
    ?llvmTypeName:*
    ?kind:*
    ?classMethodMap:*
    ?instantiable:*
    ?copyable:let copyable
    ?equatable:*
    ?comparable:*
    ?enumerationType:*
  ]
  if not copyable then
    error mElementTypeName : "an array element should be copyable"
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  [mSizeExpression analyzeExpression
    !self:.null
    !inGuard:false
    !routineNameForInvocationGraph:.new {!mArrayTypeName.string + " init" !mArrayTypeName.location}
    !optionalTargetType:.null
    !context:ioContext
    !modes:{}
    !allowPanic:false
    !?temporary:temporaries
    !?staticStringMap:*
    !?variableMap:*
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:@operandIR sizeExpressionIR
  ]
  if (([allocaList length] + [initInstructionGenerationList length]) > 0) || not [sizeExpressionIR.mValue isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR.mValue literalInteger ?value:let arraySize]
    let elementType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mElementTypeName}
  #--- Class method map : add "size" method
    @classMethodMap classMethodMap = {}
    [!?classMethodMap insertKey !["size" nowhere] !sizeExpressionIR]
  #--- Enter in type map
    [!?ioContext.mTypeMap insertKey
      !lkey:mArrayTypeName
      !llvmTypeName:"%$" + mArrayTypeName
      !kind:.arrayType {!countBitSize:ioContext.mPointerSize !elementType:elementType !size:arraySize}
      !classMethodMap:classMethodMap
      !instantiable:true
      !copyable:true
      !equatable:false
      !comparable:false
      !enumerationType:elementType
    ]
  #--- Enter array constructor
    [!?ioContext.mConstructorMap insertKey
      !mArrayTypeName
      !.zero
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let boolType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !["bool" nowhere]}
  let selfType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mArrayTypeName}
  [[selfType kind] arrayType ?2* ?size:let arraySize]
  let elementType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mElementTypeName}
  let countType = inContext.mUnsignedIntegerType
#--------------------------------------------------- "count" function
  @instructionListIR countFunctionInstructionGenerationList = {}
  let @objectInMemoryIR countPtr = .localValue {!type:countType !name:"count.ptr"}
  [!?countFunctionInstructionGenerationList appendGetElementPtrFromSelf !countPtr !selfType !{!.absolute {!index:0} !"count"}]
  [!?countFunctionInstructionGenerationList appendLoadFromMemory !?ioTemporaries !countPtr ?let loadedCountValue]
  let @objectInMemoryIR resultPtr = .localValue {!type:countType !name:"result"}
  [!?countFunctionInstructionGenerationList appendStoreInMemory !resultPtr !loadedCountValue]
  let countFunctionName = @lstring.new {!"$" + mArrayTypeName + ".count" !mArrayTypeName.location}
  ioIntermediateCodeStruct.mRoutineMapIR +=
    !countFunctionName
    !{} # No argument
    !{} # No alloca
    !countFunctionInstructionGenerationList
    !false # No required @bool mIsRequired
    !false # No warning if unused @bool mWarnIfUnused
    !false # Not weak @bool mWeak
    !false # Not global @bool mGlobal
    !.function
    !countType # Return type
#--- Enter "count" function in invocation graph
  let countFunctionNameForInvocationGraph = procNameForInvocationGraph (!selfType !["count" nowhere])
  [!?ioTemporaries.mSubprogramInvocationGraph addNode
    !countFunctionNameForInvocationGraph
    !countFunctionName
  ]
#--------------------------------------------------- "append" function
  @instructionListIR appendFunctionInstructionGenerationList = {}
#--- Load "count" value
  [!?appendFunctionInstructionGenerationList appendGetElementPtrFromSelf !countPtr !selfType !{!.absolute {!index:0} !"count"}]
  [!?appendFunctionInstructionGenerationList appendLoadFromMemory !?ioTemporaries !countPtr ?let loadedCountValue2]
#--- if "count" value is equal to size, raise panic
  if not [option plm_options.noPanicGeneration value] then
    getNewTempVariable (!boolType !?ioTemporaries ?let overflowVar)
    [!?appendFunctionInstructionGenerationList appendBinaryOperation
      !overflowVar.mValue
      !loadedCountValue2.mType
      !.nowhere
      !loadedCountValue2.mValue
      !.icmp_eq
      !.literalInteger {!value:arraySize}
    ]
    appendFunctionInstructionGenerationList += !@ifInstructionIR.new {
      !overflowVar
      !mArrayTypeName.location
      !{!@throwInstructionIR.new {!mArrayTypeName.location !panicCodeForArrayOverflow ()}}
      !{} # No else instruction
    }
  end
#--- Store value in array
  let @objectInMemoryIR elementPtr = .localValue {!type:elementType !name:"insert.ptr"}
  [!?appendFunctionInstructionGenerationList appendGetElementPtrFromSelf
     !elementPtr
     !selfType
     !{!.absolute {!index:1} !"array", !.indirect {!index:loadedCountValue2} !"element"}
   ]
  let @objectInMemoryIR insertedValuePtr = .localValue {!type:elementType !name:"inValue"}
  [!?appendFunctionInstructionGenerationList appendLoadFromMemory !?ioTemporaries !insertedValuePtr ?let loadedInsertionValue]
  [!?appendFunctionInstructionGenerationList appendStoreInMemory !elementPtr !loadedInsertionValue]
#--- Increment count
  getNewTempVariable (!countType !?ioTemporaries ?let incrementedCount)
  [!?appendFunctionInstructionGenerationList appendBinaryOperation
    !incrementedCount.mValue
    !incrementedCount.mType
    !.nowhere
    !loadedCountValue2.mValue
    !.addNoOVF
    !.literalInteger {!value:1G}
  ]
  [!?appendFunctionInstructionGenerationList appendStoreInMemory !countPtr !incrementedCount]
  let appendFunctionName = @lstring.new {!"$" + mArrayTypeName + ".append" !mArrayTypeName.location}
  ioIntermediateCodeStruct.mRoutineMapIR +=
    !appendFunctionName
    !{!.input !elementType !"inValue"} # Signature
    !{} # No alloca
    !appendFunctionInstructionGenerationList
    !false # No required @bool mIsRequired
    !false # No warning if unused @bool mWarnIfUnused
    !false # Not weak @bool mWeak
    !false # Not global @bool mGlobal
    !.function
    !.null # Return type
#--- Enter "append" function in invocation graph
  let appendFunctionNameForInvocationGraph = procNameForInvocationGraph (!selfType !["append" nowhere])
  [!?ioTemporaries.mSubprogramInvocationGraph addNode
    !appendFunctionNameForInvocationGraph
    !appendFunctionName
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
