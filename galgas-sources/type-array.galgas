#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeArrayDeclaration : @abstractDeclaration {
  @lstring mArrayTypeName
  @lstring mElementTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclaration location -> @location outLocation {
  outLocation = mArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $arrayType$
    $typeName$ ?let newTypeName
    $=$
    $typeName$ ?let aliasedTypeName
    $[$
    <expression> ?let sizeExpression
    let sizeExpressionLocation = @location.here
    $]$
    ioAST.mDeclarationList += !@typeArrayDeclaration.new {
      !newTypeName
      !aliasedTypeName
      !sizeExpression
      !sizeExpressionLocation
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let newTypeName = @lstring.new {!"$" + mArrayTypeName !mArrayTypeName.location}
  let elementTypeName = @lstring.new {!"$" + mElementTypeName !mElementTypeName.location}
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !elementTypeName]
  [mSizeExpression addDependenceEdgeForStaticExpression !newTypeName !?ioGraph]
  let rootNode = @lstring.new {!"config" !mArrayTypeName.location}
  [!?ioGraph addEdge !newTypeName !rootNode]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "arraytype $" + mArrayTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Enter "count" function
  let lkey = @lstring.new {!"$" + mArrayTypeName + ".count" !mArrayTypeName.location}
  [!?ioContext.mRoutineMapForContext insertKey
    !lkey
    !true # Public
    !allModeMap ()
    !{} # Signature
    !.function
    !false # Is not weak
    !@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !["uint32" nowhere]}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Get element type
  [ioContext.mTypeMap searchKey
    !lkey:mElementTypeName
    ?llvmTypeName:*
    ?kind:*
    ?classMethodMap:*
    ?instantiable:*
    ?copyable:let copyable
    ?equatable:*
    ?comparable:*
    ?enumerationType:*
  ]
  if not copyable then
    error mElementTypeName : "an array element should be copyable"
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  [mSizeExpression analyzeExpression
    !self:.null
    !inGuard:false
    !routineNameForInvocationGraph:.new {!mArrayTypeName.string + " init" !mArrayTypeName.location}
    !optionalTargetType:.null
    !context:ioContext
    !modes:{}
    !allowPanic:false
    !?temporary:temporaries
    !?staticStringMap:*
    !?variableMap:*
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:@operandIR sizeExpressionIR
  ]
  if (([allocaList length] + [initInstructionGenerationList length]) > 0) || not [sizeExpressionIR.mValue isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR.mValue literalInteger ?value:let arraySize]
    let elementType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mElementTypeName}
  #--- Class method map : add "size" method
    @classMethodMap classMethodMap = {}
    [!?classMethodMap insertKey !["size" nowhere] !sizeExpressionIR]
  #--- Enter in type map
    [!?ioContext.mTypeMap insertKey
      !lkey:mArrayTypeName
      !llvmTypeName:"%$" + mArrayTypeName
      !kind:.arrayType {!countBitSize:ioContext.mPointerSize !elementType:elementType !size:arraySize}
      !classMethodMap:classMethodMap
      !instantiable:true
      !copyable:true
      !equatable:false
      !comparable:false
      !enumerationType:elementType
    ]
  #--- Enter array constructor
    [!?ioContext.mConstructorMap insertKey
      !mArrayTypeName
      !.zero
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let selfType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mArrayTypeName}
  let countType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !["uint32" nowhere]}
#--- "count" function
  @instructionListIR countFunctionInstructionGenerationList = {}
  let @objectInMemoryIR countPtr = .localValue {!type:countType !name:"count.ptr"}
  [!?countFunctionInstructionGenerationList appendGetElementPtrFromSelf !countPtr !selfType !{!0 !"count"}]
  [countPtr loadFromMemory !?temporary:ioTemporaries !?instructionListIR:countFunctionInstructionGenerationList ?resultingValue:let loadedCountValue]
  let @objectInMemoryIR resultPtr = .localValue {!type:countType !name:"result"}
  [resultPtr storeInMemory !value:loadedCountValue !?instructionListIR:countFunctionInstructionGenerationList]
  let countFunctionName = @lstring.new {!"$" + mArrayTypeName + ".count" !mArrayTypeName.location}
  ioIntermediateCodeStruct.mRoutineMapIR +=
    !countFunctionName
    !{} # @procFormalArgumentListForGeneration mFormalArgumentListForGeneration
    !{} # No alloca
    !countFunctionInstructionGenerationList
    !false # No required @bool mIsRequired
    !false # No warning if unused @bool mWarnIfUnused
    !false # Not weak @bool mWeak
    !false # Not global @bool mGlobal
    !.function
    !countType # Return type
#--- Enter "count" function in invocation graph
  let routineNameForInvocationGraph = procNameForInvocationGraph (!selfType !["count" nowhere])
  [!?ioTemporaries.mSubprogramInvocationGraph addNode
    !routineNameForInvocationGraph
    !countFunctionName
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
