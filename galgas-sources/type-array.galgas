#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeArrayDeclaration : @abstractDeclaration {
  @lstring mArrayTypeName
  @lstring mElementTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclaration location -> @location outLocation {
  outLocation = mArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration_type> ?let @lstring inNewTypeName !@abstractDeclaration outDeclaration {
    $\$type$ ?let elementTypeName
    $[$
    <expression> ?let sizeExpression
    let sizeExpressionLocation = @location.here
    $]$
    outDeclaration = @typeArrayDeclaration.new {
      !inNewTypeName
      !elementTypeName
      !sizeExpression
      !sizeExpressionLocation
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let newTypeName = llvmRegularTypeMangledNameFromName (!mArrayTypeName)
  let elementTypeName = llvmRegularTypeMangledNameFromName (!mElementTypeName)
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !elementTypeName]
  [mSizeExpression addDependenceEdgeForStaticExpression !newTypeName !?ioGraph]
  let rootNode = @lstring.new {!"config" !mArrayTypeName.location}
  [!?ioGraph addEdge !newTypeName !rootNode]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeArrayDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "arraytype $" + mArrayTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Get element type
  [ioContext.mTypeMap searchKey
    !lkey:mElementTypeName
    ?kind:let kind
  ]
  if not [kind copyable] then
    error mElementTypeName : "an array element should be copyable"
  end
  if not [kind instanciable] then
    error mElementTypeName : "an array element should be instanciable"
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  variableMapWithConstants (
    !context:ioContext
    ?@unifiedSymbolMap variableMap
    ?@universalPropertyAndRoutineMapForContext universalMap
  )
  [mSizeExpression analyzeExpression
    !self:.null
    !directAccessToPropertiesAllowed:false
    !inGuard:false
    !routineNameForInvocationGraph:.new {!mArrayTypeName.string + " init" !mArrayTypeName.location}
    !optionalTargetType:.null
    !context:ioContext
    !mode:.bootMode
    !?temporary:temporaries
    !?staticStringMap:*
    !?variableMap:variableMap
    !?variableMap:universalMap
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:@objectIR sizeExpressionIR
  ]
  [mSizeExpression analyzeExpressionNew
    !self:.null
    !inGuard:false
    !routineNameForInvocationGraph:.new {!mArrayTypeName.string + " init" !mArrayTypeName.location}
    !optionalTargetType:.null
    !context:ioContext
    !mode:.bootMode
    !?temporary:* # temporaries
    !?staticStringMap:*
    !?variableMap:universalMap
    !?alloca:* # allocaList
    !?instructionListIR:* # initInstructionGenerationList
    ?result:* # @objectIR sizeExpressionIR
  ]
  if (([allocaList length] + [initInstructionGenerationList length]) > 0) || not [sizeExpressionIR isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR literalInteger ?1* ?value:let arraySize]
    let elementType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mElementTypeName}
  #--- Class method map : add "size" method
    @classConstantMap classConstantMap = {}
    [!?classConstantMap insertKey !["size" nowhere] !sizeExpressionIR]
  #--- Enter in type map
    [!?ioContext.mTypeMap insertType
      !lkey:mArrayTypeName
      !kind:.arrayType {
        !typeName:mArrayTypeName
        !elementType:elementType
        !size:arraySize
        !classConstantMap:classConstantMap
        !flags: instanciableFlag () | copyableFlag ()
      }
    ]
  #--- Enter array constructor
    [!?ioContext.mConstructorMap insertKey
      !mArrayTypeName
      !.zero
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeArrayDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
