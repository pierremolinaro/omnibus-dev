#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticArrayTypeDeclarationAST : @abstractDeclarationAST {
  @lstring mAnonymousArrayTypeName
  @lstring mElementTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <type_definition> ?!@ast ioAST !@lstring outTypeName {
    $[$
    <expression> !?ioAST ?let sizeExpression
#    $,$
    $\$type$ ?let elementTypeName
#    <type_definition> !?ioAST ?let elementTypeName
    let sizeExpressionLocation = @location.here
    $]$
    outTypeName = ["anonymous." + ioAST.mTypeDeclarationIndex here]
    ioAST.mTypeDeclarationIndex ++
    ioAST.mDeclarationListAST += !@staticArrayTypeDeclarationAST.new {
      !outTypeName
      !elementTypeName
      !sizeExpression
      !sizeExpressionLocation
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayTypeDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayTypeDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let newTypeName = llvmTypeNameFromPLMname (!mAnonymousArrayTypeName)
  let elementTypeName = llvmTypeNameFromPLMname (!mElementTypeName)
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !elementTypeName]
  [mSizeExpression addDependenceEdgeForStaticExpression !newTypeName !?ioGraph]
  let rootNode = @lstring.new {!configurationNodeNameForPrecedenceGraph () !mAnonymousArrayTypeName.location}
  [!?ioGraph addEdge !newTypeName !rootNode]
}

#·······················································································································

override getter @staticArrayTypeDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "anonymous $" + mAnonymousArrayTypeName 
}

#·······················································································································

override getter @staticArrayTypeDeclarationAST location -> @location outLocation {
  outLocation = mAnonymousArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayTypeDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
#--- Get element type
  [ioContext.mTypeMap searchKey !lkey:mElementTypeName ?type:let elementType ?1*]
  if not [elementType copyable] then
    error mElementTypeName : "an array element should be copyable"
  end
  if not [elementType instanciable] then
    error mElementTypeName : "an array element should be instanciable"
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  [mSizeExpression analyzeExpression
    !self:voidType ()
    !routineAttributes:.none
    !routineNameForInvocationGraph:.new {!mAnonymousArrayTypeName.string + " init" !mAnonymousArrayTypeName.location}
    !optionalTargetType:voidType ()
    !context:ioContext
    !mode:.bootMode
    !?temporary:temporaries
    !?staticEntityMap:*
    !?variableMap:ioContext.mValuedObjectMap # universalMap
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:let @objectIR sizeExpressionIR
  ]
  if not [sizeExpressionIR isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR literalInteger ?1* ?value:let arraySize]
  #-------------------------------------------- Original type name
    let originalTypeName = @lstring.new {!"array." + elementType.plmOriginalTypeName + "." + arraySize !mAnonymousArrayTypeName}
    if [ioContext.mTypeMap hasKey !originalTypeName] then
      [ioContext.mTypeMap searchKey !lkey:originalTypeName ?type:var type ?1*]
      type.plmAliasedTypeName = mAnonymousArrayTypeName
      type.attributes = type.attributes - .generateAssignmentRoutine
      [!?ioContext.mTypeMap insertType
        !lkey:mAnonymousArrayTypeName
        !type:type
        !index:[ioContext.mTypeMap count]
      ]
    else
    #-------------------------------------------- Class method map : add "count" constructor
      @classConstantMap classConstantMap = {}
     [!?classConstantMap insertKey !.new {!"count" !originalTypeName} !arraySize ![staticIntegerTypeName () nowhere]]
    #-------------------------------------------- Property map
      @propertyMap arrayTypePropertyMap = {}
      [!?arrayTypePropertyMap insertKey # "count" property
        !.new {!"count" !originalTypeName.location}
        !true # public
        !.constantProperty {!value:.literalInteger {!type:staticIntegerType () !value:arraySize}}
      ]
    #-------------------------------------------- Constructor map
      @constructorMap constructorMap = {}
    #--- Constructor (!repeated)
      [!?constructorMap insertKey !["(!repeated)" nowhere] !{} !.arrayValue {!elementType:elementType !size:arraySize}]
    #--- Constructor (!!!!)
      var constructorName = "("
      for i in 0 ..< [arraySize uint] do
        constructorName += "!"
      end
      constructorName += ")"
      [!?constructorMap insertKey ![constructorName nowhere] !{} !.arrayValue {!elementType:elementType !size:arraySize}]
    #-------------------------------------------- Type attributes
      @PLMTypeAttributes typeAttributes = .instanciable | .generateAssignmentRoutine | .copyable
    #-------------------------------------------- Enter in type map
      let arrayType = @PLMType.new {
        !propertyMap:arrayTypePropertyMap
        !classConstantMap:classConstantMap
        !constructorMap:constructorMap
        !guardMap:{}
        !attributes:typeAttributes
        !plmOriginalTypeName:originalTypeName
        !kind:.arrayType {!elementType:elementType !size:arraySize}
        !plmAliasedTypeName:originalTypeName
      }
      [!?ioContext.mTypeMap insertType
        !lkey:originalTypeName
        !type:arrayType
        !index:[ioContext.mTypeMap count]
      ]
      let aliasedArrayType = @PLMType.new {
        !propertyMap:arrayTypePropertyMap
        !classConstantMap:classConstantMap
        !constructorMap:constructorMap
        !guardMap:{}
        !attributes:typeAttributes - .generateAssignmentRoutine
        !plmOriginalTypeName:originalTypeName
        !kind:.arrayType {!elementType:elementType !size:arraySize}
        !plmAliasedTypeName:mAnonymousArrayTypeName
      }
      [!?ioContext.mTypeMap insertType
        !lkey:mAnonymousArrayTypeName
        !type:aliasedArrayType
        !index:[ioContext.mTypeMap count]
      ]
    #---------------- Add decorated declaration
      ioDecoratedDeclarationList += !@decoratedStaticArrayTypeDeclaration.new {!originalTypeName !arraySize}
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedStaticArrayTypeDeclaration : @abstractDecoratedDeclaration {
  @lstring mOriginalArrayTypeName
  @uint mArraySize
}

#·······················································································································

override method @decoratedStaticArrayTypeDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#----------- Generate enumeration specific code
  ioIntermediateCodeStruct.mGenerationListIR += !@arrayIR.new {!mOriginalArrayTypeName !mArraySize}
}

#·······················································································································

override method @decoratedStaticArrayTypeDeclaration routineSemanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @arrayIR : @abstractGenerationIR {
  @string mOriginalArrayTypeName
  @bigint mArraySize
}

#·······················································································································

override method @arrayIR generateLLVMcode ?!@string ioLLVMcode ?!@generationAdds unused ioGenerationAdds {
  let routineMangledName = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!mOriginalArrayTypeName)
    !["count" nowhere]
    !{}
  )
  let routineLLVMName = llvmNameForFunction (!routineMangledName.string)
  ioLLVMcode += llvmTitleComment (!routineMangledName)
  ioLLVMcode += "define internal i32  @" + routineLLVMName + " (%"
              + llvmTypeStringFromPLMname (![mOriginalArrayTypeName assemblerRepresentation]) + "* %inUnusedValue) nounwind {\n"
  ioLLVMcode += "  ret i32 " + mArraySize + "\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
