#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @extendStaticlistDeclaration : @abstractDeclaration {
  @lstring mStaticlistName
  @expressionListAST mExpressions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticlistDeclaration location -> @location outLocation {
  outLocation = mStaticlistName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticlistDeclaration keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticlistName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticlist$
    $identifier$ ?let staticListName
    $($
    @expressionListAST expressions = {}
    repeat
      <expression> ?let exp
      expressions += !exp !.here
    while
      $,$
    end
    $)$
    ioAST.mDeclarationListAST += !@extendStaticlistDeclaration.new {!staticListName !expressions}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticlistDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticlistDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Node name
  let nodeName = @lstring.new{!mStaticlistName.string + "." + [[ioGraph keyList] length] !mStaticlistName}
#--- Add 'constant name' node
  [!?ioGraph addNode !nodeName !self]
#--- Add dependency from static type declaration
  [!?ioGraph addEdge !nodeName !mStaticlistName]
#--- Add dependency from source expression
  for (exp *) in mExpressions do
    [exp addDependenceEdgeForStaticExpression !nodeName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

listmap @staticlistValues_listMap (@stringlist)

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticlistDeclaration enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap ioStaticListValueMap
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  [ioContext.mStaticlistMap searchKey !mStaticlistName ?let staticlistPropertyList]
  if [staticlistPropertyList length] != [mExpressions length] then
    error mStaticlistName
    : [[staticlistPropertyList length] string] + " expressions required, "
    + [[mExpressions length] string] + " provided"
  else
    var staticValue = "{"
    for (exp endOfExp) in mExpressions, (* propertyType) in staticlistPropertyList do
      initialVariableMap (
        !context:ioContext
        !mode:.bootMode
        !globalsAreConstant:true # Any value, there is no defined global variable at this stage
        !returnTypeName:["" nowhere]
        ?@variableMap variableMap
      )
      @semanticTemporariesStruct temporaries = .default
      @instructionListIR instructionGenerationList = {}
      @allocaList allocaList = {}
      [exp analyzeExpression
        !self:.null
        !directAccessToPropertiesAllowed:false
        !inGuard:false
        !routineNameForInvocationGraph:["compiler" nowhere]
        !optionalTargetType:propertyType
        !context:ioContext
        !mode:.bootMode
        !?temporary:temporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:variableMap
        !?alloca:allocaList
        !?instructionListIR:instructionGenerationList
        ?result:let @objectIR expressionResult
      ]
    #--- Check assignment compatibility
      let result = checkAssignmentCompatibility (
        !source:expressionResult
        !targetAnnotationType:propertyType
        !errorLocation:endOfExp
        !staticTypeAllowed:false
      )
      if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [result isStatic] then
        error endOfExp : "source expression cannot be statically computed"
      end
    #--- Enter in static value
      staticValue += [propertyType llvmTypeName] + " " + [expressionResult llvmName]
    between
      staticValue += ", "
    end
    staticValue += "}"
    ioStaticListValueMap += !mStaticlistName !staticValue
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticlistDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticlistDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistValues_listMap generateLLVM ?!@string ioLLVMcode {
  if [self count] > 0 then
    ioLLVMcode += llvmTitleComment (!"Static Lists")
    for (lkey initList) in self do
      ioLLVMcode += "@" + llvmNameForGlobalVariable (!lkey) + " = local_unnamed_addr constant ["
      ioLLVMcode += [[initList length] string] + " x " + llvmNameForStaticListElementType (!lkey) + "] [\n"
      for (value) in initList
      do
        ioLLVMcode += "  " + llvmNameForStaticListElementType (!lkey) + " " + value
      between
        ioLLVMcode += ",\n"
      end
      ioLLVMcode += "\n]\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

