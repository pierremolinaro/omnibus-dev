#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @incDecKind {
  case incWithOverflowCheck
  case decWithOverflowCheck
  case incNoOverflowCheck
  case decNoOverflowCheck
}

#----------------------------------------------------------------------------------------------------------------------*

class @incDecInstructionAST : @instructionAST {
  @incDecKind mKind
  @lstring mVarName
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $identifier$ ?let varName
    $++$
    ioInstructionList += !@incDecInstructionAST.new {
      !.incWithOverflowCheck
      !varName
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $identifier$ ?let varName
    $--$
    ioInstructionList += !@incDecInstructionAST.new {
      !.decWithOverflowCheck
      !varName
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $identifier$ ?let varName
    $&++$
    ioInstructionList += !@incDecInstructionAST.new {
      !.incNoOverflowCheck
      !varName
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $identifier$ ?let varName
    $&--$
    ioInstructionList += !@incDecInstructionAST.new {
      !.decNoOverflowCheck
      !varName
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @incDecInstructionAST analyze
  ?optionalReceiverType:let @receiverType unused inReceiverType
  ?context:let @semanticContext inContext
  ?mode:let @string inMode
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@uint unused ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Get target type
  [!?ioVariableMap searchForReadWriteAccess
    !mVarName
    ?let type
    ?let acceptedModeSet
    ?let @string unused variableCName
    ?let @variableKindIR variable
    ?*
  ]
#--- Check mode
  if not [acceptedModeSet hasKey !inMode] then
    error mVarName : "this variable cannot be used in $" + inMode + " mode"
  end
#--- Check type inc / dec operator
  if not [inContext.mTypeNameSetForIncDec hasKey ![type key]] then
    error mVarName : [type key] + " type does not handle incrementation/decrementation operator"
  end
  @sint64 min
  @uint64 max
  switch [type kind]
  case boolean, boolset, literalString :
    error mVarName : "internal error" : min, max
  case enumeration (*) :
    error mVarName : "internal error" : min, max
  case structure (*) :
    error mVarName : "internal error" : min, max
  case integer (kMin kMax) :
    min = kMin
    max = kMax
  end
#--- Exception allowed ?
  switch mKind
  case incNoOverflowCheck, decNoOverflowCheck :
  case incWithOverflowCheck, decWithOverflowCheck :
    if inMode == exceptionModeName () then
      error mVarName : "operations that can generate exception are not allowed in $" + exceptionModeName () + " mode"
    end
  end
#--- Code generation
  ioInstructionGenerationList += !@incDecInstructionIR.new {
   !min
   !max
   !mKind
   !variable
   !mVarName.location
 }
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @incDecInstructionIR : @abstractInstructionIR {
  @sint64 mMin
  @uint64 mMax
  @incDecKind mKind
  @variableKindIR mVariable
  @location mVariableLocation
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @incDecInstructionIR instructionCode -> @string outCode {
  switch mKind
  case incWithOverflowCheck :
    outCode = ""
    if not [option plm_options.noExceptionGeneration value] then
      outCode += "if (" + [mVariable mangledName] + " == " + mMax + ") {\n"
      outCode += "  raise_exception (1, "
        + [[[mVariableLocation file] lastPathComponent] utf8Representation] + ", "
        + [mVariableLocation line] + ") ;\n"
      outCode += "}\n"
    end
    outCode += [mVariable mangledName] + " ++ ;\n"
  case decWithOverflowCheck :
    outCode = ""
    if not [option plm_options.noExceptionGeneration value] then
      outCode += "if (" + [mVariable mangledName] + " == " + mMin + ") {\n"
      outCode += "  raise_exception (2, "
        + [[[mVariableLocation file] lastPathComponent] utf8Representation]
        + ", " + [mVariableLocation line] + ") ;\n"
      outCode += "}\n"
    end
    outCode += [mVariable mangledName] + " -- ;\n"
  case incNoOverflowCheck :
    outCode = [mVariable mangledName] + " ++ ;\n"
  case decNoOverflowCheck :
    outCode = [mVariable mangledName] + " -- ;\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @incDecInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mVariable enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
