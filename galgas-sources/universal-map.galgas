#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! UNIVERSAL VARIABLE MAP
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# Cette table contient les variables.

#·······················································································································

shared class @universalValuedObjectMapForContext {
  @internalValuedObjectMapMapForContext mInternalPropertyAndRoutineMapForContext
  @scopeStack mScopeStack
  @lstringlist mLocalObjectList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INSERT SETTERS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @universalValuedObjectMapForContext insertTask
  ?let @lstring inTaskName
  ?let @PLMType inTaskType
{
  let newValue = @valuedObject.task {!type:inTaskType}
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inTaskName
    !.noValue
    !false
    !newValue
  ]
}

#·······················································································································

setter @universalValuedObjectMapForContext insertDriver
  ?let @lstring inDriverName
  ?let @bool inIsInstancied
  ?let @PLMType inDriverType
{
  let newValue = @valuedObject.driver {!type:inDriverType !instancied:inIsInstancied}
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inDriverName
    !.noValue
    !false
    !newValue
  ]
}

#·······················································································································

setter @universalValuedObjectMapForContext insertRegister
  ?let @lstring inRegisterName
  ?readable:let @bool inReadable
  ?writable:let @bool inWritable
  ?type:let @PLMType inType
  ?address:let @bigint inAddress
  ?sliceMap:let @sliceMap inSliceMap
  ?arraySize:let @uint inArraySize # 0 if not an array
  ?elementSize:let @uint inElementSize
{
  let newValue = @valuedObject.register {
    !readable:inReadable
    !writable:inWritable
    !type:inType
    !address:inAddress
    !sliceMap:inSliceMap
    !arraySize:inArraySize # 0 if not an array
    !elementSize:inElementSize
  }
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inRegisterName
    !.noValue
    !false
    !newValue
  ]
}

#·······················································································································

setter @universalValuedObjectMapForContext insertGlobalConstant
  ?let @lstring inConstantName
  ?let @objectIR inConstantObjectIR
{
  let newValue = @valuedObject.globalConstant {!objectIR:inConstantObjectIR}
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inConstantName
    !.noValue
    !false
    !newValue
  ]
}

#·······················································································································

setter @universalValuedObjectMapForContext insertLocalConstant
  ?let @lstring inLocalConstantName
  ?let @PLMType inType
  ?let @lstring inPLMConstantName
{
  let newValue = @valuedObject.localConstant {!type:inType !plmName:inPLMConstantName}
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inLocalConstantName
    !.hasUnreadValue
    !false
    !newValue
  ]
  mLocalObjectList += !inLocalConstantName
}

#·······················································································································

setter @universalValuedObjectMapForContext insertUsedLocalConstant
  ?let @lstring inLocalConstantName
  ?let @PLMType inType
  ?let @lstring inPLMConstantName
{
  let newValue = @valuedObject.localConstant {!type:inType !plmName:inPLMConstantName}
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inLocalConstantName
    !.hasReadValue
    !false
    !newValue
  ]
  mLocalObjectList += !inLocalConstantName
}

#·······················································································································

setter @universalValuedObjectMapForContext insertLocalVariable
  ?let @lstring inLocalVariableName
  ?let @PLMType inType
  ?let @lstring inPLMName
  ?let @valuedObjectState inVariableInitialState
  ?let @bool inObjectShouldBeValuedAtEndOfScope
{
  let newValue = @valuedObject.localVariable {!type:inType !plmName:inPLMName}
  [!?mInternalPropertyAndRoutineMapForContext insertKey
    !inLocalVariableName
    !inVariableInitialState
    !inObjectShouldBeValuedAtEndOfScope
    !newValue
  ]
  mLocalObjectList += !inLocalVariableName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEARCH METHODS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @universalValuedObjectMapForContext searchEntity
  ?let @lstring inValuedObjectName
  !@valuedObject outEntity
{
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?2* ?outEntity]
}

#·······················································································································

method @universalValuedObjectMapForContext searchValuedObject
  ?let @lstring inValuedObjectName
  !@objectIR outObjectIR
{
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?2* ?let entity]
  switch entity
  case task (@PLMType type) :
    outObjectIR = .reference {!type:type !llvmName:llvmNameForGlobalVariable (!inValuedObjectName)}
  case driver (@PLMType type instancied) :
    if instancied then
      outObjectIR = .reference {!type:type !llvmName:llvmNameForGlobalVariable (!inValuedObjectName)}
    else
      error inValuedObjectName : "the driver should be instancied" : outObjectIR
    end
  case register (* * * * * * *) :
    error inValuedObjectName : "control register ?" : outObjectIR
  case globalConstant (@objectIR objectIR) :
    outObjectIR = objectIR
  case localConstant (@PLMType type @lstring plmName) :
    outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
  case localVariable (@PLMType type @lstring plmName) :
    outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext readAccess ?let @lstring inValuedObjectName {
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?let valueState ?* ?let property]
  switch property
  case task (*) :
  case driver (* *) :
  case register (* * * * * * *) :
  case globalConstant (*) :
  case localConstant (* *) :
    if valueState == .hasUnreadValue then
      [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !.hasReadValue !inValuedObjectName]
    end
  case localVariable (* *) :
    switch valueState 
    case noValue :
      error inValuedObjectName : "'" + inValuedObjectName + "' has no value"
    case hasUnreadValue :
      [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !.hasReadValue !inValuedObjectName]
    case hasReadValue :
    end
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext searchValuedObjectForReadAccess
  ?let @lstring inValuedObjectName
  !@objectIR outObjectIR
{
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?let valueState ?* ?let property]
  switch property
  case task (@PLMType type) :
    outObjectIR = .reference {!type:type !llvmName:llvmNameForGlobalVariable (!inValuedObjectName)}
  case driver (@PLMType type instancied) :
    if instancied then
      outObjectIR = .reference {!type:type !llvmName:llvmNameForGlobalVariable (!inValuedObjectName)}
    else
      error inValuedObjectName : "the driver should be instancied" : outObjectIR
    end
  case register (* * * * * * *) :
    error inValuedObjectName : "control register ??" : outObjectIR
  case globalConstant (@objectIR objectIR) :
    outObjectIR = objectIR
  case localConstant (@PLMType type @lstring plmName) :
    outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    if valueState == .hasUnreadValue then
      [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !.hasReadValue !inValuedObjectName]
    end
  case localVariable (@PLMType type @lstring plmName) :
    switch valueState 
    case noValue :
      error inValuedObjectName : "'" + inValuedObjectName + "' has no value" : outObjectIR
    case hasUnreadValue :
      [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !.hasReadValue !inValuedObjectName]
      outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    case hasReadValue :
      outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    end
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext searchValuedObjectForWriteAccess
  ?let @lstring inValuedObjectName
  !@objectIR outObjectIR
{
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?let valueState ?* ?let property]
  switch property
  case task (*) :
    error inValuedObjectName : "a task has no value" : outObjectIR
  case driver (* *) :
    error inValuedObjectName : "a driver has no value" : outObjectIR
  case register (* * * * * * *) :
    error inValuedObjectName : "control register ???" : outObjectIR
  case globalConstant (*) :
    error inValuedObjectName : "a constant cannot be written" : outObjectIR
  case localConstant (* *) :
    error inValuedObjectName : "a constant cannot be written" : outObjectIR
  case localVariable (@PLMType type @lstring plmName) :
    outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    switch valueState 
    case noValue, hasReadValue :
      [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !.hasUnreadValue !inValuedObjectName]
    case hasUnreadValue :
      warning inValuedObjectName : "previous '" + inValuedObjectName + "' value has not been read"
    end
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext searchValuedObjectForReadWriteAccess
  ?let @lstring inValuedObjectName
  !@objectIR outObjectIR
{
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?let valueState ?* ?let property]
  switch property
  case task (*) :
    error inValuedObjectName : "a task has no value" : outObjectIR
  case driver (* *) :
    error inValuedObjectName : "a driver has no value" : outObjectIR
  case register (* * * * * * *) :
    error inValuedObjectName : "control register ????" : outObjectIR
  case globalConstant (*) :
    error inValuedObjectName : "a constant cannot be written" : outObjectIR
  case localConstant (* *) :
    error inValuedObjectName : "a constant cannot be written" : outObjectIR
  case localVariable (@PLMType type @lstring plmName) :
    switch valueState 
    case noValue :
      error inValuedObjectName : "object has no value" : outObjectIR
    case hasUnreadValue :
      outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    case hasReadValue :
      [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !.hasUnreadValue !inValuedObjectName]
      outObjectIR = @objectIR.reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    end
  end
}

#·······················································································································

method @universalValuedObjectMapForContext searchValuedObjectType
  ?let @lstring inValuedObjectName
  !@PLMType outType
{
  [mInternalPropertyAndRoutineMapForContext searchKey !inValuedObjectName ?2* ?let property]
  switch property
  case task (*) :
    error inValuedObjectName : "undefined in this context" : outType
  case driver (* *) :
    error inValuedObjectName : "undefined in this context" : outType
  case register (* * @PLMType type * * * *) :
    outType = type
  case globalConstant (*) :
    error inValuedObjectName : "undefined in this context" : outType
  case localConstant (* *) :
    error inValuedObjectName : "undefined in this context" : outType
  case localVariable (@PLMType type *) :
    outType = type
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! STATE HANDLING
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @universalValuedObjectMapForContext checkLocalVariableFinalState {
  for entry in mInternalPropertyAndRoutineMapForContext do
    switch entry.mPossibleValuedObject
    case task (*) :
    case driver (* *) :
    case register (* * * * * * *) :
    case globalConstant (*) :
    case localConstant (* *) :
      if entry.mObjectState == .hasUnreadValue then
        warning entry.lkey : "'" + entry.lkey + "' is never read"
      end
    case localVariable (**) :
      if (entry.mObjectState == .noValue) && entry.mObjectShouldBeValuedAtEndOfScope then
        error entry.lkey : "'" + entry.lkey + "' should be valued at the end of routine"
      end
    end
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext openOverrideForSelectBlock {
  @referenceStateMap initialStateMap = {}
  for entry in mInternalPropertyAndRoutineMapForContext do
    switch entry.mPossibleValuedObject
    case task (*) :
    case driver (* *) :
    case register (* * * * * * *) :
    case globalConstant (*) :
    case localConstant (* *) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    case localVariable (**) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    end
  end
  mScopeStack += !.selectScope !true !initialStateMap !{} !mLocalObjectList
  mLocalObjectList = {}
}

#·······················································································································

setter @universalValuedObjectMapForContext openOverrideForRepeatBlock {
  @referenceStateMap initialStateMap = {}
  for entry in mInternalPropertyAndRoutineMapForContext do
    switch entry.mPossibleValuedObject
    case task (*) :
    case driver (* *) :
    case register (* * * * * * *) :
    case globalConstant (*) :
    case localConstant (* *) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    case localVariable (**) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    end
  end
  mScopeStack += !.repeatScope !true !initialStateMap ! {} !mLocalObjectList
  mLocalObjectList = {}
}

#·······················································································································

setter @universalValuedObjectMapForContext openBranch {
  [mScopeStack last ?* ?* ?let initialStateMap ?2*]
  for (key objectState) in initialStateMap do
    [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !objectState !key]
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext closeBranch ?let @location inErrorLocation {
  [!?mScopeStack popLast ?let scopeKind ?let firstBranch ?let initialStateMap ?var referenceStateMap ?let localObjectList]
  if firstBranch then
    @referenceStateMap newReferenceStateMap = {}
    for entry in mInternalPropertyAndRoutineMapForContext do
      switch entry.mPossibleValuedObject
      case task (*) :
      case driver (* *) :
      case register (* * * * * * *) :
      case globalConstant (*) :
      case localConstant (* *) :
        [!?newReferenceStateMap insertKey !entry.lkey !entry.mObjectState]
      case localVariable (**) :
        [!?newReferenceStateMap insertKey !entry.lkey !entry.mObjectState]
      end
    end
    mScopeStack += !scopeKind !false !initialStateMap !newReferenceStateMap !localObjectList
  else
    switch scopeKind
    case selectScope :
      for (lkey referenceState) in referenceStateMap do
        [mInternalPropertyAndRoutineMapForContext searchKey !lkey ?let currentObjectState ?2*]
        if referenceState == currentObjectState then # Ok
        elsif (currentObjectState == .hasUnreadValue) & (referenceState == .hasReadValue) then # Ok
        elsif (currentObjectState == .hasReadValue) & (referenceState == .hasUnreadValue) then # Ok, modify refence state
          [!?referenceStateMap setMStateForKey !.hasReadValue !lkey]
        else
          error inErrorLocation
            : "invalid state for object '" + lkey + "': found " + currentObjectState + ", required " + referenceState
        end
      end
      mScopeStack += !scopeKind !false !initialStateMap !referenceStateMap !localObjectList
    case repeatScope :
     for (lkey objectState) in referenceStateMap do
        [mInternalPropertyAndRoutineMapForContext searchKey !lkey ?let currentObjectState ?2*]
        if objectState != currentObjectState then
          error inErrorLocation
            : "invalid state for object '" + lkey + "': found " + currentObjectState + ", required " + objectState
        end
      end
      mScopeStack += !scopeKind !false !initialStateMap !referenceStateMap !localObjectList
    end
  end
}

#·······················································································································

setter @universalValuedObjectMapForContext closeOverride ?let @location inErrorLocation {
  [!?mScopeStack popLast ?* ?* ?* ?let referenceStateMap ?let localObjectList]
#--- Restore value object state
  for (key objectState) in referenceStateMap do
    [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !objectState !key]
  end
#--- For current scope objects, check their final state
  for (lkey) in mLocalObjectList do
    [mInternalPropertyAndRoutineMapForContext searchKey
      !lkey
      ?let currentObjectState
      ?let objectShouldBeValuedAtEndOfScope
      ?let possibleValuedObject
    ]
    switch possibleValuedObject
    case task (*) :
    case driver (* *) :
    case register (* * * * * * *) :
    case globalConstant (*) :
    case localConstant (* *) :
      if currentObjectState == .hasUnreadValue then
        warning inErrorLocation : "'" + lkey + "' is never read"
      end
    case localVariable (**) :
      if (currentObjectState == .noValue) && objectShouldBeValuedAtEndOfScope then
        error inErrorLocation : "'" + lkey + "' should be valued at the end of routine"
      end
    end
  end
#--- Remove current scope objets
  for (lkey) in mLocalObjectList do
    [!?mInternalPropertyAndRoutineMapForContext removeKey !lkey ?3*]
  end
#--- Restore current scope objects
  mLocalObjectList = localObjectList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INTERNAL MAPS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @internalValuedObjectMapMapForContext { # Key is a valued object
  @valuedObjectState mObjectState
  @bool mObjectShouldBeValuedAtEndOfScope
  @valuedObject mPossibleValuedObject

  insert insertKey error message "the '%K' entity is already declared in %L"
  search searchKey error message "there is no '%K' entity"
  remove removeKey error message "there is no '%K' entity"
}

#·······················································································································

enum @scopeKind {
  case selectScope
  case repeatScope
}

#·······················································································································

list @scopeStack {
  @scopeKind mScopeKind
  @bool mFirstBranch
  @referenceStateMap mInitialStateMap
  @referenceStateMap mReferenceStateMap
  @lstringlist mObjectList
}

#·······················································································································

map @referenceStateMap {
  @valuedObjectState mState
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! VALUED OBJECT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @valuedObject {
  case driver (@PLMType type @bool instancied)
  case task (@PLMType type)
  case register (@bool readable
                 @bool writable
                 @PLMType type
                 @bigint address
                 @sliceMap sliceMap
                 @uint arraySize # 0 if not an array
                 @uint elementSize) # 0 if not an array
  case globalConstant (@objectIR objectIR)
  case localConstant (@PLMType type @lstring plmName)
  case localVariable (@PLMType type @lstring plmName)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! VALUED OBJECT STATE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @valuedObjectState {
  case noValue
  case hasUnreadValue
  case hasReadValue
}

#·······················································································································

getter @valuedObjectState string -> @string {
  switch self
  case noValue : result = "no value"
  case hasUnreadValue : result = "unread value"
  case hasReadValue : result = "read value"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! VARIABLE MAP                                                                                          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc initialVariableMap
  ?context:let @semanticContext inContext
  ?mode:let @mode inRequiredMode
  ?globalsAreConstant:@bool inGlobalsAreConstant
  ?returnTypeName:let @lstring inReturnTypeName
  !@universalValuedObjectMapForContext outUniversalMap
{
  outUniversalMap = .default
#------------------------------------------------------- Add tasks
  for (taskName taskType) in inContext.mTaskMap do
   [!?outUniversalMap insertTask !taskName !taskType]
  end
#------------------------------------------------------- Add drivers
  for (driverName isInstancied) in inContext.mDriverMap do
    let driverTypeName = llvmDriverNameFromName (!driverName)
    let driverType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !driverTypeName} type]
    [!?outUniversalMap insertDriver !driverName !isInstancied !driverType]
  end
#------------------------------------------------------- Add registers
  for register in inContext.mControlRegisterMap do
    let registerIsReadable = [inRequiredMode controlRegisterAccess !register.mIsAccessibleInUserMode]
    let registerIsWritable = registerIsReadable && not register.mIsReadOnly && not inGlobalsAreConstant
    [!?outUniversalMap insertRegister
      !register.lkey
      !readable:registerIsReadable
      !writable:registerIsWritable
      !type:register.mType
      !address:register.mAddress 
      !sliceMap:register.mRegisterFieldAccessMap
      !arraySize:register.mArraySize # 0 if not an array
      !elementSize:register.mElementArraySize # 0 if not an array
    ]
  end
#------------------------------------------------------- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outUniversalMap insertGlobalConstant !constantName !constantValue]
  end
#------------------------------------------------------- Add result variable ?
  if inReturnTypeName.string != "" then
    let resultVarName = @lstring.new {!functionResultVariableName () !inReturnTypeName.location}
    let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName} type]
    [!?outUniversalMap insertLocalVariable !resultVarName !resultType !resultVarName !.noValue !true]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc variableMapWithConstants
  ?context:let @semanticContext inContext
  !@universalValuedObjectMapForContext outUniversalMap
{
  outUniversalMap = .default
#--- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outUniversalMap insertGlobalConstant !constantName !constantValue]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
