#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @allowedRoutineList {
#  @bool mHasWriteAccess
#  @lstring mReceiverTypeName
#  @lstring mRoutineName
#  @routineKind mRoutineKind
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @allowedInitList {
#  @bool mHasWriteAccess
#  @lbigint mInitPriority
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @allowedPanicList {
#  @bool mHasWriteAccess
#  @lstring mPanicName
#  @lbigint mPanicPriority
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @allowedGuardList {
#  @lstring mOptionalTypeName
#  @lstring mGuardName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @allowedISRList {
#  @bool mHasWriteAccess
#  @lstring mISRName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @allowedTaskList {
#  @bool mHasWriteAccess
#  @lstring mTaskName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @globalVarDeclarationList {
  @lstring mTypeName # Empty string if no type annotation
  @lstring mVarName
  @expressionAST mSourceExpression
#  @allowedRoutineList mAllowedProcList
#  @allowedInitList mAllowedInitList
#  @allowedPanicList mAllowedPanicList
#  @allowedGuardList mAllowedGuardList
#  @allowedISRList mAllowedISRList
#  @allowedTaskList mAllowedTaskList
  @bool mAllowedAccessToAll
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $var$
    $identifier$ ?let varName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      <type_definition> ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
#    @allowedRoutineList allowedRoutineList = {}
#    @allowedInitList allowedInitList = {}
#    @allowedPanicList allowedPanicList = {}
#    @allowedGuardList allowedGuardList = {}
#    @allowedISRList allowedISRList = {}
#    @allowedTaskList allowedTaskList = {}
#    select
#    or
#    ${$
#      repeat
#        <global_var_allowed_routine>
#          !?allowedRoutineList
#          !?allowedInitList
#          !?allowedPanicList
#          !?allowedGuardList
#          !?allowedISRList
#          !?allowedTaskList 
#      while
#      end
#      $}$
#    end
    ioAST.mGlobalVarDeclarationListAST +=
      !typeName
      !varName
      !expression
#      !allowedRoutineList
#      !allowedInitList
#      !allowedPanicList
#      !allowedGuardList
#      !allowedISRList
#      !allowedTaskList
      !true # mAllowedAccessToAll
  }

  #·····················································································································

#  rule <global_var_allowed_routine>
#    ?!@allowedRoutineList allowedRoutineList
#    ?!@allowedInitList allowedInitList
#    ?!@allowedPanicList allowedPanicList
#    ?!@allowedGuardList allowedGuardList
#    ?!@allowedISRList allowedISRList
#    ?!@allowedTaskList allowedTaskList 
#  {
#    @bool hasWriteAccess
#    select
#      hasWriteAccess = false
#    or
#      $@attribute$ ?let attribute
#      if attribute.string != "rw" then
#        error attribute: "attribute should be @rw"
#      end
#      hasWriteAccess = true
#    end
#    select
#      $guard$
#      @lstring typeName
#      select
#        typeName = ["" nowhere]
#      or
#        $\$type$ ?typeName
#        $.$
#      end
#      $identifier$ ?let sectionName
#      allowedGuardList += !typeName !sectionName
#    or
#      $section$
#      @lstring typeName
#      select
#        typeName = ["" nowhere]
#      or
#        $\$type$ ?typeName
#        $.$
#      end
#      $identifier$ ?let sectionName
#      allowedRoutineList += !hasWriteAccess !typeName !sectionName !.section
#    or
#      $func$
#      $identifier$ ?let procName
#      allowedRoutineList += !hasWriteAccess !["" nowhere] !procName !.function
#    or
#      $func$
#      $\$type$ ?let typeName
#      $.$
#      $identifier$ ?let procName
#      allowedRoutineList += !hasWriteAccess !typeName !procName !.function
#    or
#      $init$
#      $integer$ ?let @lbigint priority
#      allowedInitList += !hasWriteAccess !priority
#    or
#      $isr$
#      $identifier$ ?let isrName
#      allowedISRList += !hasWriteAccess !isrName
#    or
#      $task$
#      $identifier$ ?let isrName
#      allowedTaskList += !hasWriteAccess !isrName
#    or
#      $panic$
#      $func$
#      $identifier$ ?let panicName
#      $integer$ ?let @lbigint priority
#      allowedPanicList += !hasWriteAccess !panicName !priority
#    end
#  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVarDeclarationList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (globalVariableTypeName 3*) in self do
    if globalVariableTypeName.string != "" then
      let typeName = llvmTypeNameFromPLMname (!globalVariableTypeName)
      [!?ioGraph noteNode !typeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVarDeclarationList-element enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  @PLMType variableAnnotationType
  if mTypeName.string == "" then
    variableAnnotationType = voidType ()
  else
    variableAnnotationType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mTypeName} type]
  end
#--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
  @instructionListIR instructionGenerationList = {}
  @allocaList allocaList = {}
  variableMapWithConstants (
    !context:ioContext
    ?@universalValuedObjectMapForContext universalMap
  )
  [mSourceExpression analyzeExpression
     !self:voidType ()
     !inGuard:false
     !routineNameForInvocationGraph:["compiler" nowhere]
     !optionalTargetType:variableAnnotationType
     !context:ioContext
     !mode:.bootMode
     !?temporary:temporaries
     !?staticStringMap:ioGlobalLiteralStringMap
     !?variableMap:universalMap
     !?alloca:allocaList
     !?instructionListIR:instructionGenerationList
     ?result:@objectIR expressionResult
  ]
  if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [expressionResult isStatic] then
    error mVarName : "source expression cannot be statically computed"
  end
#--- Check variable type and expression type
  if [variableAnnotationType mKind] == .void && [[[expressionResult type] mKind] isStaticInteger] then
    error mVarName : "cannot infer type"
  end
  let result = checkAssignmentCompatibility (
    !source:expressionResult
    !targetAnnotationType:variableAnnotationType
    !errorLocation:mVarName.location
    !staticTypeAllowed:false
  )
  @stringset executionModes = {}
#--- Check allowed init routines are defined
#  @allowedRoutineMap allowedRoutineMap = {}
#  for () in mAllowedInitList do
#    [ioContext.mInitRoutineMap searchKey !.new {![mInitPriority.bigint string] !mInitPriority.location}]
#    [!?allowedRoutineMap insertKey !initNameForInvocationGraph (!.null !mInitPriority) !mHasWriteAccess]
#  end
#--- Check allowed panic routines are defined
#  for () in mAllowedPanicList do
#    if mPanicName.string == "setup" then
#      [ioContext.mPanicSetupRoutinePriorityMap searchSetupKey
#        !.new{![mPanicPriority.bigint string]
#        !mPanicPriority.location}
#      ]
#    elsif mPanicName.string == "loop" then
#      [ioContext.mPanicLoopRoutinePriorityMap searchLoopKey
#        !.new{![mPanicPriority.bigint string]
#        !mPanicPriority.location}
#      ]
#    else
#      error mPanicName : "panic routine name should be \"setup\" or \"loop\""
#    end
#    [!?allowedRoutineMap insertKey
#      !panicNameForInvocationGraph (!mPanicName.string !mPanicPriority)
#      !mHasWriteAccess
#    ]
#  end
#--- Check allowed routines (procedures, sections, services) are defined
#  for procedure in mAllowedProcList do
#    @lstring routineMangledName
#    @unifiedTypeMap-proxy receiverType
#    if procedure.mReceiverTypeName.string == "" then
##      routineMangledName = .new {!"." + procedure.mRoutineName !procedure.mRoutineName.location}
#      routineMangledName = procedure.mRoutineName
#      receiverType = .null
#    else
#      routineMangledName = .new {!llvmTypeNameFromPLMname (procedure.mReceiverTypeName) + "." + procedure.mRoutineName !procedure.mRoutineName.location}
#      receiverType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !procedure.mReceiverTypeName}
#    end
#    [ioContext.mRoutineMapForContext searchKey
#      !routineMangledName
#      ?*
#      ?let unused isPublic
#      ?*
#      ?let procedureModeMap
#      ?7*
#    ]
#    for () in procedureModeMap do
#      executionModes += !lkey.string
#    end
#    [!?allowedRoutineMap insertKey !routineMangledName !procedure.mHasWriteAccess]
#  end
##--- Check allowed guards are defined
  @allowedGuardMap allowedGuardMap = {}
#  for guard in mAllowedGuardList do
#    @lstring guardMangledName
#    @unifiedTypeMap-proxy receiverType
#    if guard.mOptionalTypeName.string == "" then
#      guardMangledName = guard.mGuardName
##      guardMangledName = .new {!"." + guard.mGuardName !guard.mGuardName.location}
#      receiverType = .null
#    else
#      guardMangledName = .new {!llvmTypeNameFromPLMname (!guard.mOptionalTypeName) + "." + guard.mGuardName !guard.mGuardName.location}
#      receiverType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !guard.mOptionalTypeName}
#    end
#    [ioContext.mGuardMapForContext searchKey
#      !guardMangledName
#      ?let unused isPublic
#      ?*
#    ]
#    executionModes += !serviceModeName ()
##    let routineNameForInvocationGraph = guardNameForInvocationGraph (!receiverType !guard.mGuardName)
#    [!?allowedGuardMap insertKey !guardMangledName]
#  end
#--- Check allowed isr are defined
#  @allowedISRMap allowedISRMap = {}
#  for isr in mAllowedISRList do
#    let name = interruptNameForInvocationGraph (!isr.mISRName)
#    [!?allowedISRMap insertKey !name !isr.mHasWriteAccess]
#    if not [ioContext.mDefinedInterruptSet hasKey !isr.mISRName.string] then
#      error isr.mISRName : "this isr is not defined"
#    end
#  end
#--- Check allowed tasks are defined
#  @allowedTaskMap allowedTaskMap = {}
#  for task in mAllowedTaskList do
#    [ioContext.mTaskMap searchKey !task.mTaskName ?*]
#    [!?allowedTaskMap insertKey !task.mTaskName !task.mHasWriteAccess]
#  end
#--- Enter variable in global variable map
  [!?ioContext.mGlobalVariableMap insertKey
    !lkey:mVarName
    !type:[result type]
    !executionModeSet:executionModes
#    !allowedRoutineMap:allowedRoutineMap
    !allowedGuardMap:allowedGuardMap
#    !allowedISRMap:allowedISRMap
#    !allowedTaskMap:allowedTaskMap
    !initialValue:result
    !isConstant:false # Is not constant
    !allowedAccessToAll:mAllowedAccessToAll
  ]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedGlobalVariable.new {!mVarName !executionModes !result}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedGlobalVariable : @abstractDecoratedDeclaration {
  @lstring mVarName
  @stringset mExecutionModeSet
  @objectIR mExpressionGeneratedCode
}

#·······················································································································

override method @decoratedGlobalVariable semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [!?ioIntermediateCodeStruct.mGlobalVariableMap insertKey
    !mVarName
#    ![mExpressionGeneratedCode type]
    ![mExecutionModeSet count] > 1
    !mExpressionGeneratedCode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalVariableMapIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalVariable (!lkey.string) + " = internal global "
  ioLLVMcode += [[mInitialValue type] llvmTypeName] + " "
  let initialString = [mInitialValue llvmName]
  if initialString == "" then
    ioLLVMcode += "zeroinitializer"
  else
    ioLLVMcode += initialString
  end
  ioLLVMcode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
