#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskGuardListAST {
  @lstring mGuardName
  @routineFormalArgumentListAST mGuardFormalArgumentList
  @lstringlist mGuardPath
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <task_guard_declaration> ?!@ast ioAST ?!@taskGuardListAST ioTaskEntryListAST {
    $guard$
    $identifier$ ?let guardName
    $:$
    $self$
    $.$
    @lstringlist guardPath = {}
    repeat
      $identifier$ ?let propertyName
      guardPath += !propertyName
    while
      $.$
    end
    <procedure_formal_arguments> !?ioAST ?let @routineFormalArgumentListAST formalArgumentList
    ioTaskEntryListAST += !guardName !formalArgumentList !guardPath
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskGuardListAST-element enterInContext
  ?taskName:let @lstring inTaskName
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!@decoratedTaskGuardList ioDecoratedTaskGuardList 
  ?!@guardMapForContext ioGuardMap
{
#--- Entry mangled name
  let entryMangledName = routineMangledNameFromAST (!"" !mGuardName !mGuardFormalArgumentList)
#--- Entry signature
  routineSignature (!?ioContext.mTypeMap !mGuardFormalArgumentList ?let guardSignature)
#--- Enter in structure map
  [!?ioGuardMap insertKey !entryMangledName !true !guardSignature]
#--- Extract method name
   var propertyAccessPath = mGuardPath
   [!?propertyAccessPath popLast ?let methodName]
#--- Enter in decorated entry list
  ioDecoratedTaskGuardList +=
    !mGuardName
    !mGuardFormalArgumentList
    !guardSignature
    !propertyAccessPath
    !methodName
#--- Invocation graph
  let entryMangledNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inTaskName)
    !mGuardName
    !mGuardFormalArgumentList
  )
  [!?ioSubprogramInvocationGraph addNode !entryMangledNameForInvocationGraph !entryMangledNameForInvocationGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @decoratedTaskGuardList {
  @lstring mGuardName
  @routineFormalArgumentListAST mGuardFormalArgumentList
  @routineTypedSignature mGuardSignature
  @lstringlist mGuardPath
  @lstring mInvokedGuardName
}

#·······················································································································

method @decoratedTaskGuardList-element taskGuardSemanticAnalysis
  ?taskType:let @PLMType inTaskType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Analyze property path
  @instructionListIR instructionGenerationList = {}
  var currentType = inTaskType
  var currentLLVMName = llvmNameForSelf ()
  for (propertyName) in mGuardPath do
    [currentType.propertyMap searchKey !propertyName ?let @bool unused isPublic ?let propertyAccessKind]
    switch propertyAccessKind
    case constantProperty (*) :
      error propertyName : "a constant property is not allowed here"
    case indexed (@PLMType type @uint index) :
      if [type copyable] then
        error propertyName : "the property type $" + type.plmTypeName + " is copyable"
      end
      [!?ioTemporaries newTempLLVMVar ?let llvmName]
      [!?instructionGenerationList appendGetUniversalPropertyReference
        !currentType
        !currentLLVMName
        !llvmName
        !index
        !propertyName
      ]
      currentType = type
      currentLLVMName = llvmName
    case nonVirtualMethod (*) :
      error propertyName : "a non virtual method is not allowed here"
    end
  end
#--- Invoked method mangled name
  let invokedMethodMangledName = routineMangledNameFromAST (!"" !mInvokedGuardName !mGuardFormalArgumentList)
#--- Analyze invoked guard
  [currentType.guardMap searchKey !invokedMethodMangledName ?let @bool unused isPublic ?*]
#--- Invocation graph
  let entryMangledNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inTaskType.plmTypeName)
    !mGuardName
    !mGuardFormalArgumentList
  )
  let invokedMethodMangledNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!currentType.plmTypeName)
    !mInvokedGuardName
    !mGuardFormalArgumentList
  )
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge
    !entryMangledNameForInvocationGraph
    !invokedMethodMangledNameForInvocationGraph
  ]
#--- Analyse formal arguments
  @routineFormalArgumentListIR formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !mGuardFormalArgumentList
    !?*
    !?formalArguments
  )
#--- Invoked guard effectives parameters
  @procCallEffectiveParameterListIR effectiveParameterListIR = {}
  effectiveParameterListIR += !.outputInput !.reference {!type:currentType !llvmName:currentLLVMName}
  for (kind type name) in formalArguments do
    switch kind
    case input :
      effectiveParameterListIR += !.output !.reference {!type:type !llvmName:"%in." + name}
    case output :
       effectiveParameterListIR += !.input !.llvmValue {!type:type !llvmName:"%var." + name}
   case inputOutput :
      effectiveParameterListIR += !.outputInput !.reference {!type:type !llvmName:"%var." + name}
    end
  end
#--- Generate code
   let convenienceGuard = @guardKindGenerationIR.convenienceGuard {
     !baseGuardAllocaList:{}
     !baseGuardInstructionGenerationList:instructionGenerationList
     !baseGuardMangledName:invokedMethodMangledNameForInvocationGraph
     !baseGuardEffectiveParameterList:effectiveParameterListIR
   } 
  [!?ioIntermediateCodeStruct.mGuardMapIR insertKey
    !entryMangledNameForInvocationGraph
    !formalArguments
    !inTaskType
    !convenienceGuard
    !{} # allocaList
    !{} # instruction list
    !true # inWarnIfUnused
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
