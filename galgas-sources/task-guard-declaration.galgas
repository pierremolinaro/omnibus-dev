#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskGuardListAST {
  @lstring mGuardName
  @routineFormalArgumentListAST mGuardFormalArgumentList
  @lstringlist mGuardPath
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <task_guard_declaration> ?!@ast ioAST ?!@taskGuardListAST ioTaskEntryListAST {
    $guard$
    $identifier$ ?let guardName
    $:$
    $self$
    $.$
    @lstringlist guardPath = {}
    repeat
      $identifier$ ?let propertyName
      guardPath += !propertyName
    while
      $.$
    end
    <procedure_formal_arguments> !?ioAST ?let @routineFormalArgumentListAST formalArgumentList
    ioTaskEntryListAST += !guardName !formalArgumentList !guardPath
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskGuardListAST-element enterInContext
  ?taskName:let @lstring inTaskName
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!@decoratedTaskGuardList ioDecoratedTaskGuardList 
  ?!@propertyMap ioTaskPropertyMap
{
#--- Attributes
  let exportedRoutine = true # [attributeSet hasKey !exportedAttribute ()]
  let canMutateProperties = true # [attributeSet hasKey !mutatingAttribute ()]
#--- Entry mangled name
  let entryMangledName = routineMangledNameFromAST (!"" !mGuardName !mGuardFormalArgumentList)
#--- Entry signature
  routineSignature (!?ioContext.mTypeMap !mGuardFormalArgumentList ?let entrySignature)
#--- Routine descriptor
  let descriptor = @routineDescriptor.new {
    !isPublic:true
    !exported:exportedRoutine
    !routineKind:.function {!executionMode:.userMode}
    !signature:entrySignature
    !returnTypeProxy:.null
    !canAccessProperties:true
    !canMutateProperties:canMutateProperties
  }
#--- Enter in structure map
  [!?ioTaskPropertyMap insertKey !entryMangledName !true !.nonVirtualMethod {!descriptor:descriptor}]
#--- Extract method name
   var propertyAccessPath = mGuardPath
   [!?propertyAccessPath popLast ?let methodName]
#--- Enter in decorated entry list
  ioDecoratedTaskGuardList +=
    !mGuardName
    !mGuardFormalArgumentList
    !entrySignature
    !propertyAccessPath
    !methodName
#--- Invocation graph
  let entryMangledNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inTaskName)
    !mGuardName
    !mGuardFormalArgumentList
  )
  [!?ioSubprogramInvocationGraph addNode !entryMangledNameForInvocationGraph !entryMangledNameForInvocationGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @decoratedTaskGuardList {
  @lstring mGuardName
  @routineFormalArgumentListAST mGuardFormalArgumentList
  @routineTypedSignature mGuardSignature
  @lstringlist mGuardPath
  @lstring mInvokedGuardName
}

#·······················································································································

method @decoratedTaskGuardList-element taskGuardSemanticAnalysis
  ?taskType:let @PLMType inTaskType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Analyze property path
  @instructionListIR instructionGenerationList = {}
  var currentType = inTaskType
  var currentLLVMName = "%self"
  for (propertyName) in mGuardPath do
    [currentType.propertyMap searchKey !propertyName ?let @bool unused isPublic ?let propertyAccessKind]
    switch propertyAccessKind
    case constantProperty (*) :
      error propertyName : "a constant property is not allowed here"
    case indexed (@PLMType type @uint index) :
      [!?ioTemporaries newTempLLVMVar ?let llvmName]
      [!?instructionGenerationList appendGetUniversalPropertyReference
        !currentType
        !currentLLVMName
        !llvmName
        !index
        !propertyName
      ]
      currentType = type
      currentLLVMName = llvmName
    case nonVirtualMethod (*) :
      error propertyName : "a non virtual method is not allowed here"
    end
  end
#--- Invoked method mangled name
  let invokedMethodMangledName = routineMangledNameFromAST (!"" !mInvokedGuardName !mGuardFormalArgumentList)
#--- Analyze invoked method
  [currentType.propertyMap searchKey !invokedMethodMangledName ?let @bool unused isPublic ?let methodAccessKind]
  switch methodAccessKind
  case constantProperty (*) :
    error mInvokedGuardName : "a constant property is not allowed here"
  case indexed (* *) :
    error mInvokedGuardName : "a property is not allowed here"
  case nonVirtualMethod (@routineDescriptor descriptor) :
  #--- Invocation graph
    let entryMangledNameForInvocationGraph = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (!inTaskType.plmTypeName) # mTaskName)
      !mGuardName
      !mGuardFormalArgumentList
    )
    let invokedMethodMangledNameForInvocationGraph = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (!currentType.plmTypeName)
      !mInvokedGuardName
      !mGuardFormalArgumentList
    )
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge
      !entryMangledNameForInvocationGraph
      !invokedMethodMangledNameForInvocationGraph
    ]
  #--- Analyse formal arguments
    @routineFormalArgumentListIR formalArguments = {}
    enterFormalArguments (
      !context:inContext
      !mGuardFormalArgumentList
      !?*
      !?formalArguments
    )
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:.userMode
      !calleeMode:.userMode
      !kind:descriptor.routineKind
      !error:mInvokedGuardName.location
    )
  #--- Build arguments
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    effectiveParameterListIR += !.outputInput !.reference {!type:currentType !llvmName:currentLLVMName}
    for () in formalArguments do
      switch mFormalArgumentKind
      case input :
        effectiveParameterListIR += !.output !.reference {!type:mFormalArgumentType !llvmName:"%in." + mFormalArgumentName}
      case output :
         effectiveParameterListIR += !.input !.llvmValue {!type:mFormalArgumentType !llvmName:"%var." + mFormalArgumentName}
     case inputOutput :
        effectiveParameterListIR += !.outputInput !.reference {!type:mFormalArgumentType !llvmName:"%var." + mFormalArgumentName}
      end
    end
  #--- Generate call instruction
    instructionGenerationList += !@staticRoutineCallIR.new {
      !mInvokedGuardName
      !.null # No result
      !invokedMethodMangledNameForInvocationGraph
      !invokedMethodMangledNameForInvocationGraph # LLVMInvocationRoutineName
      !calleeKind
      !effectiveParameterListIR
    }
    [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey # Raises a redefinition error
      !entryMangledNameForInvocationGraph
      !inTaskType
      !entryMangledNameForInvocationGraph
      !formalArguments
      !{} # allocaList
      !instructionGenerationList
      !false # [ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
      !true # inWarnIfUnused
      !false # inGlobalFunction
      !.function {!executionMode:.userMode}
      !voidType ()
      !false
    ]

  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
