#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

sortedlist @initList {
  @location mInitLocation
  @initRequiredByProcList mRequiredByProcList
  @instructionListAST mInstructionList
  @location mEndOfInitLocation
  @lbigint mPriority
}{
  mPriority <
}

list @initRequiredByProcList {
  @lstring mProcName
  @procFormalArgumentList mProcFormalArgumentList
}
#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $init$
    $integer$ ?let @lbigint priority
    @initRequiredByProcList requiredByProcList = {}
    select
    or
      $requiredBy$
      repeat
        $identifier$ ?let procName
        <procedure_formal_arguments> ?formalArguments:let procFormalArgumentList
        requiredByProcList += !procName !procFormalArgumentList
      while
        $,$
      end
    end
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    let endOfInit = @location.here
    $}$
    ioAST.mInitList +=
      !priority.location
      !requiredByProcList
      !instructionList
      !endOfInit
      !priority
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @initRoutineMap {
  insert insertKey error message "the '%%%K' init routine is already declared"
  search searchKey error message "there is no '%%%K' init routine"
}

#----------------------------------------------------------------------------------------------------------------------*

method @initList-element enterInContext
  ?!context:@semanticContext ioContext
{
  [!?ioContext.mInitRoutineMap insertKey !.new {![mPriority string] !mPriority.location}]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

map @initRoutinePriorityMap {
  insert insertKey error message "an init routine with priority %K has been already declared"
}

#----------------------------------------------------------------------------------------------------------------------*

method @initList-element initSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  if not [inContext.mModeMap hasKey !"init"] then
    error mInitLocation : "the $init mode should be defined in order to use init routines"
  end
  [!?ioTemporaries.mInitRoutinePriorityMap insertKey !.new{![mPriority string] !mPriority.location}]
#--- Check "requiredBy" routines are defined
  for (procName procFormalArgumentList) in mRequiredByProcList do
    let procMangledName = mangledName (
      !forProcedureKind:.standAloneProc
      !procedureName:procName
      !formalArgumentList:procFormalArgumentList
    )
    [inContext.mProcedureMap searchKey !procMangledName ?4*]
  end
#---
  let routineNameForInvocationGraph = @lstring.new  {!"init " + mPriority.bigint !mPriority.location}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
  for (procName procFormalArgumentList) in mRequiredByProcList do
    let procMangledName = mangledName (
      !forProcedureKind:.standAloneProc
      !procedureName:procName
      !formalArgumentList:procFormalArgumentList
    )
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge
      !.new {!"proc " + procMangledName !procMangledName.location}
      !routineNameForInvocationGraph
    ]
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineMangledName:routineNameForInvocationGraph.string
    !context:inContext
    !globalsAreConstant:false
  )
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !optionalReceiverType:.noReceiver
    !context:inContext
    !modes:{!"init"}
    !allowException:true
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfInitLocation]
#--- Code generation
  ioIntermediateCodeStruct.mInitList +=
    !mRequiredByProcList
    !mInitLocation
    !instructionGenerationList
    !mEndOfInitLocation
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

list @initListIR {
  @initRequiredByProcList mInitRequiredByProcList
  @location mInitLocation
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}

#----------------------------------------------------------------------------------------------------------------------*

method @initListIR generateLLVMinitCode
  ?!@string ioLLVMcode
  ?let @procedureMapIR inProcedureMapIR
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Init")
  ioLLVMcode += "define internal void @init () nounwind {\n"
  for init in self do
    @bool generate 
    if [init.mInitRequiredByProcList length] == 0 then
      generate = true
    else
      generate = false
      for (procName *) in init.mInitRequiredByProcList while not generate do
        generate = [inProcedureMapIR hasKey !procName.string]
      end
    end
    if generate then
      [init.mInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    end
  end
  ioLLVMcode += ";---\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}