#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    B U I L D    O R D E R E D    D E C L A R A T I O N    L I S T                                                     
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @semanticTypePrecedenceGraph (@declarationListAST) {
  insert addNode error message "the '%K' symbol is already declared at %L"
}

#·······················································································································

setter @semanticTypePrecedenceGraph noteUINTType ?let @uint inBitSize ?let @location inErrorLocation {
  let typeName = @lstring.new {!"$uint" + inBitSize !inErrorLocation}
  [!?self noteNode !typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @abstractDeclarationAST keyRepresentationForErrorSignaling -> @string

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildOrderedDeclarationList
  ?ast:let @ast inAST
  ?sourceFile:let @string inSourceFile
  ?endOfSourceFile:let @location inEndOfSourceFile
  !orderedDeclarationList:@declarationListAST outDeclarationListAST
{
#-------------------------------------- Build precedence graph
  @semanticTypePrecedenceGraph precedenceGraph = .emptyGraph
  for () in inAST.mDeclarationListAST do
    [mDeclaration enterInPrecedenceGraph !?precedenceGraph]
  end
  [inAST.mStandAloneFunctionDeclarationListAST noteTypesInPrecedenceGraph !?precedenceGraph]
  [inAST.mExternProcListAST noteTypesInPrecedenceGraph !?precedenceGraph]
  [inAST.mStandAloneSystemRoutineListAST noteTypesInPrecedenceGraph !?precedenceGraph]
  [inAST.mTaskListAST noteTypesInPrecedenceGraph !?precedenceGraph]
#--------------------------------------- Add needed $uintXX and $intXX types
  for () in [precedenceGraph undefinedNodeKeyList] do
    let split = [mValue componentsSeparatedByString !"int"]
    if ([split length] == 2) && [[split mValueAtIndex !1] isDecimalUnsignedNumber] then
      if [split mValueAtIndex !0] == "$u" then
        let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
        let declaration = @integerDeclarationAST.new {!false !n}
        [declaration enterInPrecedenceGraph !?precedenceGraph]
      elsif [split mValueAtIndex !0] == "$" then
        let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
        let declaration = @integerDeclarationAST.new {!true !n}
        [declaration enterInPrecedenceGraph !?precedenceGraph]
      end
    end
  end
#------------------------------------------  Write precedence graph file ?
  if (@uint.errorCount == 0) && [option plm_options.writeDeclarationDependencyGraphFile value] then
    let s = [precedenceGraph graphviz]
    let filePath = inSourceFile + ".declarationDependency.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#------------------------------------------  Get ordered declaration list
  outDeclarationListAST = {}
  if [precedenceGraph undefinedNodeCount] > 0 then
    for () in  [precedenceGraph undefinedNodeReferenceList] do
      error mValue : mValue.string + " is not defined"
    end
  else
    [precedenceGraph topologicalSort
      ?outDeclarationListAST
      ?*
      ?let @declarationListAST unsortedSemanticDeclarationListAST
      ?*
    ]
    if [unsortedSemanticDeclarationListAST length] > 0 then
      var s = "semantic analysis not performed, "
            + [unsortedSemanticDeclarationListAST length]
            + " declarations are involved in circular definition:"
      for () in  unsortedSemanticDeclarationListAST do
        s += "\n-  " + [mDeclaration keyRepresentationForErrorSignaling]
      end
      error inEndOfSourceFile : s
      for () in  unsortedSemanticDeclarationListAST do
        error [mDeclaration location] : "the " + [mDeclaration keyRepresentationForErrorSignaling] + " is declared here"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
