#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    B U I L D    O R D E R E D    D E C L A R A T I O N    L I S T                                                     
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @semanticTypePrecedenceGraph (@declarationListAST) {
  insert addNode error message "the '%K' symbol is already declared at %L"
}

#·······················································································································

setter @semanticTypePrecedenceGraph noteUINTType ?let @uint inBitSize ?let @location inErrorLocation {
  let typeName = @lstring.new {!"uint" + inBitSize !inErrorLocation}
  [!?self noteNode !typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @abstractDeclarationAST keyRepresentationForErrorSignaling -> @string

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  COMPILE TIME BARRIER FOR PRECEDENCE GRAPH
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @compileTimeDeclarationBarrierAST : @abstractDeclarationAST {
}

#·······················································································································

override method @compileTimeDeclarationBarrierAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !compileTimeDeclarationBarrier () !self]
}

#·······················································································································

override getter @compileTimeDeclarationBarrierAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = compileTimeDeclarationBarrier ()
}

#·······················································································································

override getter @compileTimeDeclarationBarrierAST locationForErrorSignaling -> @location outLocation {
  outLocation = .nowhere
}

#·······················································································································

override method @compileTimeDeclarationBarrierAST enterInContext
  ?!context:@semanticContext unused ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc appendUnsignedOperatorsTo ?@uint inSize ?let @string inTypeName ?!@semanticTypePrecedenceGraph ioPrecedenceGraph {
#--- Add assignment operator declaration
  @abstractDeclarationAST declaration = buildAssignmentOperatorDeclaration (!inTypeName)
  [declaration enterInPrecedenceGraph !?ioPrecedenceGraph]
#--- Add assignment operator declaration from ctInt
  declaration = buildAssignmentOperatorFrom_ctInt (!inTypeName)
  [declaration enterInPrecedenceGraph !?ioPrecedenceGraph]
#--- ==
  appendInfixOperatorDeclaration (!.equal !"icmp eq" !inTypeName !boolTypeName () !?ioPrecedenceGraph)
#--- ≤
  appendInfixOperatorDeclaration (!.infEqual !"icmp ule" !inTypeName !boolTypeName () !?ioPrecedenceGraph)
#--- <
  appendInfixOperatorDeclaration (!.lessThan !"icmp ult" !inTypeName !boolTypeName () !?ioPrecedenceGraph)
#--- +
  appendInfixOperatorDeclaration (!.addOp !"add" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.addOpNoOvf !"add" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- -
  appendInfixOperatorDeclaration (!.subOp !"sub" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.subOpNoOvf !"sub" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- *
  appendInfixOperatorDeclaration (!.mulOp !"mul" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.mulOpNoOvf !"mul" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- /
  appendInfixOperatorDeclaration (!.divOp !"udiv" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.divOpNoOvf !"udiv" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- %
  appendInfixOperatorDeclaration (!.modOp !"urem" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.modOpNoOvf !"urem" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- |
  appendInfixOperatorDeclaration (!.bitWiseOrOp !"or" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- &
  appendInfixOperatorDeclaration (!.bitWiseAndOp !"and" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- <<
  appendInfixOperatorDeclaration (!.leftShiftOp !"shl" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- >>
  appendInfixOperatorDeclaration (!.rightShiftOp !"lshr" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- ~ 
  appendPrefixOperatorDeclaration_bitWiseComplement (!inTypeName !?ioPrecedenceGraph)
#--- Append slice
  declaration = @sliceDeclarationAST.new {![[inSize string] nowhere] ![inTypeName nowhere]}
  [declaration enterInPrecedenceGraph !?ioPrecedenceGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc appendSignedOperatorsTo ?let @string inTypeName ?!@semanticTypePrecedenceGraph ioPrecedenceGraph {
#--- Add assignment operator declaration
  @abstractDeclarationAST declaration = buildAssignmentOperatorDeclaration (!inTypeName)
  [declaration enterInPrecedenceGraph !?ioPrecedenceGraph]
#--- Add assignment operator declaration from ctInt
  declaration = buildAssignmentOperatorFrom_ctInt (!inTypeName)
  [declaration enterInPrecedenceGraph !?ioPrecedenceGraph]
#--- ==
  appendInfixOperatorDeclaration (!.equal !"icmp eq" !inTypeName !boolTypeName () !?ioPrecedenceGraph)
#--- ≤
  appendInfixOperatorDeclaration (!.infEqual !"icmp sle" !inTypeName !boolTypeName () !?ioPrecedenceGraph)
#--- <
  appendInfixOperatorDeclaration (!.lessThan !"icmp slt" !inTypeName !boolTypeName () !?ioPrecedenceGraph)
#--- +
  appendInfixOperatorDeclaration (!.addOp !"add" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.addOpNoOvf !"add" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- -
  appendInfixOperatorDeclaration (!.subOp !"sub" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.subOpNoOvf !"sub" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- *
  appendInfixOperatorDeclaration (!.mulOp !"mul" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.mulOpNoOvf !"mul" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- %
  appendInfixOperatorDeclaration (!.modOp !"srem" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.modOpNoOvf !"srem" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- /
  appendInfixOperatorDeclaration (!.divOp !"sdiv" !inTypeName !inTypeName !?ioPrecedenceGraph)
  appendInfixOperatorDeclaration (!.divOpNoOvf !"sdiv" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- |
  appendInfixOperatorDeclaration (!.bitWiseOrOp !"or" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- &
  appendInfixOperatorDeclaration (!.bitWiseAndOp !"and" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- <<
  appendInfixOperatorDeclaration (!.leftShiftOp !"shl" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- >>
  appendInfixOperatorDeclaration (!.rightShiftOp !"ashr" !inTypeName !inTypeName !?ioPrecedenceGraph)
#--- - prefixed
  appendPrefixOperatorDeclaration_minus (!inTypeName !?ioPrecedenceGraph)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildOrderedDeclarationList
  ?ast: let @ast inAST
  ?sourceFile: let @string inSourceFile
  ?endOfSourceFile: let @location inEndOfSourceFile
  !orderedDeclarationList: @declarationListAST outSortedDeclarationListAST
{
#-------------------------------------- Build precedence graph
  @semanticTypePrecedenceGraph precedenceGraph = .emptyGraph
  for () in inAST.mDeclarationListAST do
    [mDeclaration enterInPrecedenceGraph !?precedenceGraph]
#    message "Declaration : " + [mDeclaration keyRepresentationForErrorSignaling] + "\n"
  end
  [inAST.mExternFunctionListAST noteTypesInPrecedenceGraph !?precedenceGraph]
  [inAST.mTaskListAST noteTypesInPrecedenceGraph !?precedenceGraph]
#--------------------------------------- Add needed UIntXX and IntXX types
  var addintegerTypeCount = 0
  for () in [precedenceGraph undefinedNodeKeyList] do
    let split = [mValue componentsSeparatedByString !"int"]
    if ([split length] == 2) && [[split mValueAtIndex !1] isDecimalUnsignedNumber] then
      if [split mValueAtIndex !0] == "u" then
        let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
        let declaration = @integerDeclarationAST.new {!false !n}
        [declaration enterInPrecedenceGraph !?precedenceGraph]
      #--- Add assignment operator declaration
        appendUnsignedOperatorsTo (!n !mValue !?precedenceGraph)
      #---
        addintegerTypeCount ++
      elsif [split mValueAtIndex !0] == "" then 
        let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
        let declaration = @integerDeclarationAST.new {!true !n}
        [declaration enterInPrecedenceGraph !?precedenceGraph]
      #--- Add assignment operator declaration
        appendSignedOperatorsTo (!mValue !?precedenceGraph)
      #---
        addintegerTypeCount ++
      end
    end
  end
#------------------------------------------  Add compile time barrier
  let compileTimeDeclarationBarrierAST = @compileTimeDeclarationBarrierAST.new
  [compileTimeDeclarationBarrierAST enterInPrecedenceGraph !?precedenceGraph]
#------------------------------------------  Display ?
  if (@uint.errorCount == 0) &&[option omnibus_options.printPasses value] then
    message "    Added " + addintegerTypeCount + " integer types\n" 
  end
#------------------------------------------  Write precedence graph file ?
  if (@uint.errorCount == 0) && [option omnibus_options.emitDeclarationDependencyGraphFile value] then
    let s = [precedenceGraph graphviz]
    let filePath = inSourceFile + ".declarationDependency.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#------------------------------------------  Get ordered declaration list
  outSortedDeclarationListAST = {}
  if [precedenceGraph undefinedNodeCount] > 0 then
    for () in  [precedenceGraph undefinedNodeReferenceList] do
      error mValue : mValue.string + " is not defined in declaration dependency graph"
    end
  else
    [precedenceGraph topologicalSort
      ?outSortedDeclarationListAST
      ?*
      ?let @declarationListAST unsortedSemanticDeclarationListAST
      ?*
    ]
    if [unsortedSemanticDeclarationListAST length] > 0 then
      var s = "semantic analysis not performed, "
            + [unsortedSemanticDeclarationListAST length]
            + " declarations are involved in circular definition:"
      for () in unsortedSemanticDeclarationListAST do
        s += "\n-  " + [mDeclaration keyRepresentationForErrorSignaling]
      end
      error inEndOfSourceFile : s
      for () in  unsortedSemanticDeclarationListAST do
        error [mDeclaration locationForErrorSignaling] : "the " + [mDeclaration keyRepresentationForErrorSignaling] + " is declared here"
      end
    end
  end
#  for () in outSortedDeclarationListAST do
#    message "Sorted : " + [mDeclaration keyRepresentationForErrorSignaling] + "\n"
#  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
