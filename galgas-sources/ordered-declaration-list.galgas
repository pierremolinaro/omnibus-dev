#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    B U I L D    O R D E R E D    D E C L A R A T I O N    L I S T                                                     
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @semanticTypePrecedenceGraph (@declarationListAST) {
  insert addNode error message "the '%K' symbol is already declared at %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclaration enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @abstractDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildOrderedDeclarationList
  ?ast:let @ast inAST
  ?sourceFile:let @string inSourceFile
  ?endOfSourceFile:let @location inEndOfSourceFile
  !orderedDeclarationList:@declarationListAST outDeclarationListAST
{
#-------------------------------------- Build precedence graph
  @semanticTypePrecedenceGraph precedenceGraph = .emptyGraph
  for () in inAST.mDeclarationList do
    [mDeclaration enterInPrecedenceGraph !?precedenceGraph]
  end
  for procedure in inAST.mProcedureListAST do
    [procedure enterInPrecedenceGraph !?precedenceGraph]
  end
  for function in inAST.mFunctionListAST do
    [function enterInPrecedenceGraph !?precedenceGraph]
  end
  noteControlRegisterTypesInPrecedenceGraph (
    !inAST.mControlRegisterDeclarationListAST
    !?precedenceGraph
  )
  noteGlobalVariableTypesInPrecedenceGraph (
    !inAST.mGlobalVarDeclarationList
    !?precedenceGraph
  )
#--------------------------------------- Add needed $uintXX and $intXX types
  for () in [precedenceGraph undefinedNodeKeyList] do
#    log "UNDEFINED " : mValue
    let split = [mValue componentsSeparatedByString !"int"]
    if ([split length] == 2) && [[split mValueAtIndex !1] isDecimalUnsignedNumber] then
      if [split mValueAtIndex !0] == "$u" then
        let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
        let declaration = @integerDeclaration.new {!false !n}
        [declaration enterInPrecedenceGraph !?precedenceGraph]
      elsif [split mValueAtIndex !0] == "$" then
        let n = [[split mValueAtIndex !1] decimalUnsignedNumber]
        let declaration = @integerDeclaration.new {!true !n}
        [declaration enterInPrecedenceGraph !?precedenceGraph]
      end
    end
  end
#---  Write precedence graph file ?
  if (@uint.errorCount == 0) && [option plm_options.writeTypeDependencyGraphFile value] then
    let s = [precedenceGraph graphviz]
    let filePath = inSourceFile + ".typeDependency.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#---
  outDeclarationListAST = {}
  if [precedenceGraph undefinedNodeCount] > 0 then
    for () in  [precedenceGraph undefinedNodeReferenceList] do
      error mValue : "the $" + mValue + " type is not defined"
    end
  else
    [precedenceGraph topologicalSort
      ?outDeclarationListAST
      ?*
      ?let @declarationListAST unsortedSemanticDeclarationListAST
      ?*
    ]
#    log outDeclarationListAST
    if [unsortedSemanticDeclarationListAST length] > 0 then
      var s = "semantic analysis not performed, "
            + [unsortedSemanticDeclarationListAST length]
            + " declarations are involved in circular definition:"
      for () in  unsortedSemanticDeclarationListAST do
        s += "\n-  " + [mDeclaration keyRepresentationForErrorSignaling]
      end
      error inEndOfSourceFile : s
      for () in  unsortedSemanticDeclarationListAST do
        error [mDeclaration location] : "the " + [mDeclaration keyRepresentationForErrorSignaling] + " is declared here"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
