#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionCallEffectiveParameterListAST {
  @lstring mSelector
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @constructorCallAST : @expressionAST {
  @lstring mTypeName
  @functionCallEffectiveParameterListAST mParameterList
  @location mErrorLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    <type_definition> !?ioAST ?let typeName
    $($
    @functionCallEffectiveParameterListAST parameterList = {}
    repeat
    while
      $!selector:$ ?let selector
      <expression> !?ioAST ?let expression
      parameterList += !selector !expression
    end
    let errorLocation = @location.here
    $)$
    outExpression = @constructorCallAST.new {!typeName !parameterList !errorLocation}
  }

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorCallAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let typeName = llvmTypeNameFromPLMname (!mTypeName)
  [!?ioGraph addEdge !inConstantName !typeName]
  
  for () in mParameterList do
    [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorCallAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let typeName = llvmTypeNameFromPLMname (!mTypeName)
  [!?ioGraph noteNode !typeName]
  for () in mParameterList do
    [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorCallAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze effective argument list
  var constructorKey = "("
  for (selector *) in mParameterList do
    constructorKey += "!" + selector
  end
  constructorKey += ")"
#--- Analyze constructor signature and init value
  let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTypeName} type]
  let constructorMap = resultType.constructorMap
  [constructorMap searchKey !.new {!constructorKey !mErrorLocation} ?let constructorSignature ?let initValue]
#--- Examine init value
  switch initValue
  case arrayValue (elementType size) :
    if [mParameterList length] != 1 then
      error mErrorLocation : "$" + resultType.plmUserTypeName + " array constructor should have one parameter" : outResult
    else
      let expression = [mParameterList mExpressionAtIndex !0]
      [expression analyzeExpression
        !self:inSelfType
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:elementType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
        ?result:let @objectIR expressionResult
      ]
      let result = checkAssignmentCompatibility (
        !source:expressionResult
        !targetAnnotationType:elementType
        !errorLocation:[mParameterList mSelectorAtIndex !0].location
        !staticTypeAllowed:false
      )
      @operandIRList operandIRList = {}
      for i in 0 ..< size do
        operandIRList += !result
      end
      outResult = .llvmArrayValue {!type:resultType !values:operandIRList}
    end
  case simple (value) :
    if [mParameterList length] != 0 then
      error mErrorLocation : "$" + resultType.plmUserTypeName + " constructor should have no parameter" : outResult
    else
      outResult = .literalInteger {!type: resultType !value:value}
    end
  case structure (sortedOperandList) :
    var sortedOperandIRList = sortedOperandList
    if [mParameterList length] != [constructorSignature length] then
      error mErrorLocation : "this constructor call should name " + [constructorSignature length] + " parameter"
        + if [constructorSignature length] > 1 then "s" else "" end
        + " instead of " + [mParameterList length]
      : outResult
    else
      for () formal_ in constructorSignature, () effective_ in mParameterList do
        if effective_mSelector.string != formal_mSelector  then
          error effective_mSelector : "the selector should be '!" + formal_mSelector + ":'"
        end
        [effective_mExpression analyzeExpression
          !self:inSelfType
          !routineAttributes:inRoutineAttributes
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !optionalTargetType:formal_mType
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !?instructionListIR:ioInstructionGenerationList
          ?result:let @objectIR expressionResult
        ]
        let result = checkAssignmentCompatibility (
          !source:expressionResult
          !targetAnnotationType:formal_mType
          !errorLocation:effective_mSelector.location
          !staticTypeAllowed:false
        )
        [!?ioInstructionGenerationList appendLoadWhenReference !?ioTemporaries !result ?let resultAsValue]
        sortedOperandIRList += !resultAsValue !formal_mFieldIndex
      end
      outResult = .llvmStructureValue {!type:resultType !values:sortedOperandIRList}
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
