#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionCallEffectiveParameterList {
  @lstring mSelector
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @constructorCall : @expressionAST {
  @lstring mTypeName
  @functionCallEffectiveParameterList mParameterList
  @location mErrorLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  rule <primary> !@expressionAST outExpression {
    $typeName$ ?let typeName
    $($
    @functionCallEffectiveParameterList parameterList = {}
    repeat
    while
      $!$ ?let selector
      <expression> ?let expression
      parameterList += !selector !expression
    end
    let errorLocation = @location.here
    $)$
    outExpression = @constructorCall.new {!typeName !parameterList !errorLocation}
  }

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorCall addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let typeName = @lstring.new {!"$" + mTypeName !mTypeName.location}
  [!?ioGraph addEdge !inConstantName !typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorCall noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let typeName = @lstring.new {!"$" + mTypeName !mTypeName.location}
  [!?ioGraph noteNode !typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorCall analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@operandIR outResult
{
#--- Analyze constructor source type
  @unifiedTypeMap-proxy resultType
  if mTypeName.string == "" then
    resultType = inOptionalTargetType
  else
    resultType = .searchKey {!inContext.mTypeMap !mTypeName}
  end
  if resultType == .null then
    error mErrorLocation : "cannot infer type" : outResult
  else
    [inContext.mConstructorMap searchKey ![[resultType key] nowhere] ?let initValue]
    switch initValue
    case zero :
      outResult = .new {!resultType !.zero}
    case simple (value) :
      if [mParameterList length] != 0 then
        error mErrorLocation : "$" + [resultType key] + " constructor should have no parameter" : outResult
      else
        outResult = .new {!resultType !.literalInteger {!value:value}}
      end
    case structure (constructorSignature sortedOperandList) :
      var sortedOperandIRList = sortedOperandList
      if [mParameterList length] != [constructorSignature length] then
        error mErrorLocation : "this constructor call should name " + [constructorSignature length] + " parameter"
          + if [constructorSignature length] > 1 then "s" else "" end
          + " instead of " + [mParameterList length]
        : outResult
      else
        for () formal_ in constructorSignature, () effective_ in mParameterList do
          if effective_mSelector.string != formal_mSelector  then
            error effective_mSelector : "the selector should be '!" + formal_mSelector + ":'"
          end
          [effective_mExpression analyzeExpression
            !self:inSelfType
            !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
            !inGuard:inGuard
            !routineNameForInvocationGraph:inCallerNameForInvocationGraph
            !optionalTargetType:formal_mType
            !context:inContext
            !modes:inModeSet
            !allowPanic:inAllowPanic
            !?temporary:ioTemporaries
            !?staticStringMap:ioGlobalLiteralStringMap
            !?variableMap:ioVariableMap
            !?localVariableMap: ioLocalVariableMap
            !?alloca:ioAllocaList
            !?instructionListIR:ioInstructionGenerationList
            ?result:let @operandIR expressionResult
          ]
          let result = checkAssignmentCompatibility (
            !source:expressionResult
            !targetAnnotationType:formal_mType
            !errorLocation:effective_mSelector.location
            !staticTypeAllowed:false
          )
          sortedOperandIRList += !result !formal_mFieldIndex
        end
        @operandIRList initialValueList = {}
        for (initialValue *) in sortedOperandIRList do
          initialValueList += !initialValue
        end
        outResult = .new {!resultType !.llvmStructureConstant {!values:initialValueList}}
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
