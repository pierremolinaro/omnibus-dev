#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeAliasDeclaration : @abstractDeclaration {
  @lstring mNewTypeName
  @lstring mAliasedTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeAliasDeclaration location -> @location outLocation {
  outLocation = mNewTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $newType$
    $typeName$ ?let newTypeName
    $:$
    $typeName$ ?let aliasedTypeName
    ioAST.mDeclarationList += !@typeAliasDeclaration.new {
      !newTypeName
      !aliasedTypeName
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let newTypeName = @lstring.new {!"$" + mNewTypeName !mNewTypeName.location}
  let aliasedTypeName = @lstring.new {!"$" + mAliasedTypeName !mAliasedTypeName.location}
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !aliasedTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @typeAliasDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "typealias $" + mNewTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Enter in type map
  [ioContext.mTypeMap searchKey
    !lkey:mAliasedTypeName
    ?llvmTypeName:let llvmTypeMane
    ?kind:let kind
    ?typedConstantMap:let typedConstantMap
    ?instantiable:let instanciable
    ?copyable:let copyable
    ?equatable:let equatable
    ?comparable:let comparable
    ?enumerationType:let enumerationType
  ]
#--- Enter in type map
  [!?ioContext.mTypeMap insertKey
    !lkey:mNewTypeName
    !llvmTypeName:llvmTypeMane
    !kind:kind
    !typedConstantMap:typedConstantMap
    !instantiable:instanciable
    !copyable:copyable
    !equatable:equatable
    !comparable:comparable
    !enumerationType:enumerationType
  ]
#--- Enter infix operators
  let newNewInfixKey = combineTypeNamesForInfixOperator (!mNewTypeName.string !mNewTypeName.string)
  let aliasAliasInfixKey = combineTypeNamesForInfixOperator (!mAliasedTypeName.string !mAliasedTypeName.string)
  let newLiteralIntegerInfixKey = combineTypeNamesForInfixOperator (!mNewTypeName.string !staticIntegerTypeName ())
  let aliasLiteralIntegerInfixKey = combineTypeNamesForInfixOperator (!mAliasedTypeName.string !staticIntegerTypeName ())
  let literalIntegerNewInfixKey = combineTypeNamesForInfixOperator (!staticIntegerTypeName ()!mNewTypeName.string)
  let literalIntegerAliasInfixKey = combineTypeNamesForInfixOperator (!staticIntegerTypeName ()!mAliasedTypeName.string)
  let newTypeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mNewTypeName}
  let oldTypeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mAliasedTypeName}
  enterAliasInfixOperator (
    !?ioContext.mEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mNonEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mStrictInfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mInfEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mStrictSupOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mSupEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mAndOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mOrOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mXorOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mBooleanXorOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mAddOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mAddNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mSubOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
     !newTypeProxy
    !oldTypeProxy
 )
  enterAliasInfixOperator (
    !?ioContext.mSubNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mMulOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mMulNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mDivOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mDivNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mModOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mModNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mLeftShiftOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasInfixOperator (
    !?ioContext.mRightShiftOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newTypeProxy
    !oldTypeProxy
  )
  enterAliasPrefixOperator (!?ioContext.mUnaryMinusOperatorMap !mNewTypeName !mAliasedTypeName)
  enterAliasPrefixOperator (!?ioContext.mNotOperatorMap !mNewTypeName !mAliasedTypeName)
  enterAliasPrefixOperator (!?ioContext.mUnsignedComplementOperatorMap !mNewTypeName !mAliasedTypeName)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enterAliasPrefixOperator
  ?!@prefixOperatorMap ioInfixOperatorMap
  ?let @lstring inNewTypeName
  ?let @lstring inAliasedTypeName
{
  if [ioInfixOperatorMap hasKey !inAliasedTypeName.string] then
    [ioInfixOperatorMap searchKey
      !inAliasedTypeName
#      ?@unifiedTypeMap-proxy resultType
    ]
    [!?ioInfixOperatorMap insertKey
      !inNewTypeName
#      !resultType
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enterAliasInfixOperator
  ?!@infixOperatorMap ioInfixOperatorMap
  ?let @lstring inNewNewInfixKey
  ?let @lstring inAliasedAliasedInfixKey
  ?let @lstring inNewLiteralIntegerInfixKey
  ?let @lstring inAliasedLiteralIntegerInfixKey
  ?let @lstring inLiteralIntegerNewInfixKey
  ?let @lstring inLiteralIntegerAliasInfixKey
  ?let @unifiedTypeMap-proxy inNewTypeProxy
  ?let @unifiedTypeMap-proxy inOldTypeProxy
{
  if [ioInfixOperatorMap hasKey !inAliasedAliasedInfixKey.string] then
    [ioInfixOperatorMap searchKey
      !inAliasedAliasedInfixKey
      ?@unifiedTypeMap-proxy resultType
      ?let @infixOperatorDescription operation
    ]
    if resultType == inOldTypeProxy then
      resultType = inNewTypeProxy
    end
    [!?ioInfixOperatorMap insertKey
      !inNewNewInfixKey
      !resultType
      !operation
    ]
  end
  if [ioInfixOperatorMap hasKey !inAliasedLiteralIntegerInfixKey.string] then
    [ioInfixOperatorMap searchKey
      !inAliasedLiteralIntegerInfixKey
      ?@unifiedTypeMap-proxy resultType
      ?let @infixOperatorDescription operation
    ]
    if resultType == inOldTypeProxy then
      resultType = inNewTypeProxy
    end
    [!?ioInfixOperatorMap insertKey
      !inNewLiteralIntegerInfixKey
      !resultType
      !operation
    ]
  end
  if [ioInfixOperatorMap hasKey !inLiteralIntegerAliasInfixKey.string] then
    [ioInfixOperatorMap searchKey
      !inLiteralIntegerAliasInfixKey
      ?@unifiedTypeMap-proxy resultType
      ?let @infixOperatorDescription operation
    ]
    if resultType == inOldTypeProxy then
      resultType = inNewTypeProxy
    end
    [!?ioInfixOperatorMap insertKey
      !inLiteralIntegerNewInfixKey
      !resultType
      !operation
    ]
  end
}
  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INIT ANALYSIS                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
