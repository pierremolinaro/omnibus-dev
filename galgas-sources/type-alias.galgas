#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeAliasDeclarationAST : @abstractDeclarationAST {
  @lstring mAliasTypeName
  @lstring mOriginalTypeName
}

#·······················································································································

override getter @typeAliasDeclarationAST locationForErrorSignaling -> @location {
  result = mAliasTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $typealias$
    $\$type$ ?let newTypeName
    $=$
    <type_definition> !?ioAST ?let typeName
    ioAST.mDeclarationListAST += !@typeAliasDeclarationAST.new {!newTypeName !typeName}
  }

  #·····················································································································

  rule <type_definition> ?!@ast unused ioAST !@lstring outTypeName {
    $\$type$ ?outTypeName # Simple redéfinition de type
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !mAliasTypeName !self]
  [!?ioGraph addEdge !mAliasTypeName !mOriginalTypeName]
}

#·······················································································································

override getter @typeAliasDeclarationAST keyRepresentationForErrorSignaling -> @string {
  result = "typealias " + mAliasTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeAliasDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#---------- Enter in type map
  [ioContext.mTypeMap searchKey !lkey:mOriginalTypeName ?type:var type]
#---------- Enter in type map
  [!?ioContext.mTypeMap insertType
    !lkey:mAliasTypeName
    !type:type
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
