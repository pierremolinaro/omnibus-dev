#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @bitbandInstructionAST : @instructionAST {
  @controlRegisterLValueAST mControlRegisterLValue
  @expressionAST mBitExpression
  @location mBitExpressionLocation
  @expressionAST mSourceExpression
  @location mSourceExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@ast ioAST ?!@instructionListAST ioInstructionList {
    $©$
    <control_register_lvalue> !?ioAST ?let registerLValue
    $@attribute$ ?let attribute
    if attribute.string != "bit" then
      error attribute : "attribute should be @bit" fixit { replace "@bit" }
    end
    <expression> !?ioAST ?let bitExpression
    let bitExpressionLocation = @location.here
#    $)$
    $=$
    <expression> !?ioAST ?let sourceExpression
  #--- AST
    ioInstructionList += !@bitbandInstructionAST.new {
      !registerLValue.mRegisterGroupName.location
      !registerLValue
      !bitExpression
      !bitExpressionLocation
      !sourceExpression
      !.here
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @bitbandInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mControlRegisterLValue noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [!?ioGraph noteNode !["uint1" nowhere]]
  [mBitExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [mSourceExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @bitbandInstructionAST instructionSemanticAnalysis
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#-------------------- Source Expression
#--- Inferred source expression type
  [inContext.mTypeMap searchKey
    !lkey:.new {!"uint1" !mSourceExpressionLocation}
    ?type:let requiredSourceExpressionType
  ]
#--- Compute source expression
  [mSourceExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !optionalTargetType:requiredSourceExpressionType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR sourceExpressionOperand
  ]
#--- Load from reference ?
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?sourceExpressionOperand
  ]
#--- If source expression operand is static type, check value and convert it to 'requiredSourceExpressionType'
  if ([sourceExpressionOperand type].plmTypeDescriptionName == staticIntegerTypeName ()) && [sourceExpressionOperand isLiteralInteger] then
    [sourceExpressionOperand literalInteger ?1* ?value:let @bigint value]
    if (value < 0G) || (value > 1G) then
      error mSourceExpressionLocation : "static value should be 0 or 1"
    else
      sourceExpressionOperand = .literalInteger {!type:requiredSourceExpressionType !value:value}
    end
  elsif [sourceExpressionOperand type].plmTypeDescriptionName != requiredSourceExpressionType.plmTypeDescriptionName then
    error mSourceExpressionLocation : "bit expression type should be $" + requiredSourceExpressionType.plmTypeDescriptionName
  end
#-------------------- Control register LValue
  [mControlRegisterLValue controlRegisterLValueSemanticAnalysis
    !writeAccess:false
    !self: inSelfType
    !routineAttributes: inRoutineAttributes
    !context: inContext
    !mode: inMode
    !?temporary: ioTemporaries
    !?staticEntityMap: ioStaticEntityMap
    !?variableMap: ioUniversalMap
    !?alloca: ioAllocaList
    !?instructionListIR: ioInstructionGenerationList
    ?registerType:*
    ?registerBitCount:let registerBitCount
    ?sliceMap:*
    ?llvmRegisterAddressName:let llvmRegisterAddressName
  ]

#-------------------- Bit Expression
#--- Inferred bit expression type
  [inContext.mTypeMap searchKey
    !lkey:.new {!"uint" + [registerBitCount-1G significantBitCount] !mBitExpressionLocation}
    ?type:let requiredBitExpressionType
  ]
#--- Compute bit expression
  [mBitExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !optionalTargetType:requiredBitExpressionType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR bitExpressionOperand
  ]
#--- Load from reference ?
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?bitExpressionOperand
  ]
#--- If bit expression operand is static type, check value and convert it to 'requiredBitExpressionType'
  if ([bitExpressionOperand type].plmTypeDescriptionName == staticIntegerTypeName ()) && [bitExpressionOperand isLiteralInteger] then
    [bitExpressionOperand literalInteger ?1* ?value:let @bigint value]
    if (value < 0G) || (value >= registerBitCount) then
      error mBitExpressionLocation : "static value should be >= 0 and <" + registerBitCount
    else
      bitExpressionOperand = .literalInteger {!type:requiredBitExpressionType !value:value}
    end
  elsif [bitExpressionOperand type].plmTypeDescriptionName != requiredBitExpressionType.plmTypeDescriptionName then
    error mBitExpressionLocation : "bit expression type should be $" + requiredBitExpressionType.plmTypeDescriptionName
  end
#-------------------- Generate code
  ioInstructionGenerationList += !@bitbandInstructionIR.new {
    !llvmRegisterAddressName
    !bitExpressionOperand
    !sourceExpressionOperand
    !inContext.mTargetParameters.mBitbandRegisterBaseAddress.bigint
    !inContext.mTargetParameters.mBitbandRegisterRelocationAddress.bigint
    !inContext.mTargetParameters.mBitbandRegisterOffsetMultiplier.bigint
    !inContext.mTargetParameters.mBitbandRegisterBitMultiplier.bigint
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @bitbandInstructionIR : @abstractInstructionIR {
  @string mRegisterAddressLLVMname
  @objectIR mBitExpressionOperand
  @objectIR mSourceExpressionOperand
  @bigint mBitbandRegisterBaseAddress
  @bigint mBitbandRegisterRelocationAddress
  @bigint mBitbandRegisterOffsetMultiplier
  @bigint mBitbandRegisterBitMultiplier
}

#·······················································································································
#void bitband (const unsigned char inBit, const unsigned inAddress, const unsigned char inValue) {
#  const unsigned register_base = 0x4000 * 0x10000 ;
#  const unsigned byte_offset = inAddress - register_base ;
#  const unsigned bit_word_offset = (byte_offset * 32) + (inBit * 4) ;
#  const unsigned bit_band_base = 0x4200 * 0x10000 ;
#  const unsigned bit_word_addr = bit_band_base + bit_word_offset ;
#  unsigned * ptr = (unsigned *) bit_word_addr ;
#  *ptr = inValue ;
#}
#·······················································································································

override method @bitbandInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let idx = [ioGenerationAdds.mUniqueIndex string]
  ioGenerationAdds.mUniqueIndex ++
  ioLLVMcode += ";--- Bit band\n"
  ioLLVMcode += "  %byte.offset." + idx + " = sub i32 " + mRegisterAddressLLVMname + ", " + mBitbandRegisterBaseAddress + "\n"
  ioLLVMcode += "  %byte.offset." + idx + ".mul = mul i32 %byte.offset." + idx + ", " + mBitbandRegisterOffsetMultiplier + "\n"
  ioLLVMcode += "  %bit.offset." + idx + ".mul = mul i32 " + [mBitExpressionOperand llvmName] + ", " + mBitbandRegisterBitMultiplier + "\n"
  ioLLVMcode += "  %offset." + idx + " = add i32 %byte.offset." + idx + ".mul, %bit.offset." + idx + ".mul\n"
  ioLLVMcode += "  %bit.word.addr." + idx + " = add i32 %offset." + idx + ", " + mBitbandRegisterRelocationAddress + "\n"
  ioLLVMcode += "  %ptr." + idx + " = inttoptr i32 %bit.word.addr." + idx + " to i32*\n"
  ioLLVMcode += "  %value." + idx + " = zext i1 " + [mSourceExpressionOperand llvmName] + " to i32\n"
  ioLLVMcode += "  store i32 %value." + idx + ", i32* %ptr." + idx + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
