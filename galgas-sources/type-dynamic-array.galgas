#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeDynamicArrayDeclarationAST : @abstractDeclarationAST {
  @lstring mDynamicArrayTypeName
  @lstring mElementTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <type_definition> ?!@ast ioAST !@lstring outTypeName {
    $[$
    <type_definition> !?ioAST ?let elementTypeName
    $]$
    outTypeName = ["anonymous." + ioAST.mTypeDeclarationIndex here]
    ioAST.mTypeDeclarationIndex ++
    ioAST.mDeclarationListAST += !@typeDynamicArrayDeclarationAST.new {!outTypeName !elementTypeName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeDynamicArrayDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [!?ioGraph addNode !mDynamicArrayTypeName !self]
  [!?ioGraph addEdge !mDynamicArrayTypeName !mElementTypeName]
  let rootNode = @lstring.new {!configurationNodeNameForPrecedenceGraph () !mDynamicArrayTypeName.location}
  [!?ioGraph addEdge !mDynamicArrayTypeName !rootNode]
}

#·······················································································································

override getter @typeDynamicArrayDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "anonymous $" + mDynamicArrayTypeName 
}

#·······················································································································

override getter @typeDynamicArrayDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mDynamicArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeDynamicArrayDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
  if not ioContext.mTargetParameters.mHandleDynamicArray then
    error mElementTypeName : "this target does not handle dynamic array"
  end
#-------------------------------------------- Get element type
  [ioContext.mTypeMap searchKey !lkey:mElementTypeName ?type:let elementType ?2*]
  if not [elementType copyable] then
    error mElementTypeName : "an array element should be copyable"
  end
  if not [elementType instanciable] then
    error mElementTypeName : "an array element should be instanciable"
  end
#-------------------------------------------- Original type name
  let plmTypeDescriptionName = @lstring.new {!"[" + elementType.plmTypeDescriptionName + "]" !mDynamicArrayTypeName}
  let llvmBaseTypeName = @lstring.new {!"dyn-" + elementType.llvmBaseTypeName !mDynamicArrayTypeName}
#-------------------------------------------- Original type name
  if [ioContext.mTypeMap hasKey !plmTypeDescriptionName] then
    [ioContext.mTypeMap searchKey !lkey:plmTypeDescriptionName ?type:var type ?2*]
    [!?ioContext.mTypeMap insertType
      !lkey:mDynamicArrayTypeName
      !type:type
      !index:[ioContext.mTypeMap count]
      !generate:false
    ]
  else
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !["$uint32" nowhere] ?let uint32TypeProxy]
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mElementTypeName ?let elementTypeProxy]
  #-------------------------------------------- Property map
    @propertyMap propertyMap = {}
  #--- Method 'removeAll()'
    [!?propertyMap addFunctionWithoutArgument
      !?ioSubprogramInvocationGraph
      !llvmBaseTypeName:llvmBaseTypeName
      !methodName:"removeAll"
      !safe:false
      !resultTypeProxy: .null
      !canMutateProperties:true
    ]
  #--- Method 'length()'
    [!?propertyMap addFunctionWithoutArgument
      !?ioSubprogramInvocationGraph
      !llvmBaseTypeName:llvmBaseTypeName
      !methodName:"length"
      !safe:false
      !resultTypeProxy: uint32TypeProxy
      !canMutateProperties:false
    ]
  #--- Method 'append(?:)'
    [!?propertyMap addFunctionWithInputArgument
      !?context:ioContext
      !?ioSubprogramInvocationGraph
      !llvmBaseTypeName:llvmBaseTypeName
      !methodName:"append"
      !safe:false
      !inputArgumentSelector:""
      !inputArgumentTypeProxy:elementTypeProxy
      !inputArgumentName:"inValue"
      !resultTypeProxy:.null
      !canMutateProperties:true
    ]
  #--- Method 'insert(?:?atIndex:)'
    [!?propertyMap addFunctionWithTwoInputArguments
      !?context:ioContext
      !?ioSubprogramInvocationGraph
      !llvmBaseTypeName:llvmBaseTypeName
      !methodName:"insert"
      !safe:false
      !inputArgumentSelector1:""
      !inputArgumentTypeProxy1:elementTypeProxy
      !inputArgumentName1:"inValue"
      !inputArgumentSelector2:"atIndex"
      !inputArgumentTypeProxy2:uint32TypeProxy
      !inputArgumentName2:"inIndex"
      !resultTypeProxy:.null
      !canMutateProperties:true
    ]
  #-------------------------------------------- Constructor map
    @constructorMap constructorMap = {}
    [!?constructorMap insertKey !["()" nowhere] !{} !.null]
  #-------------------------------------------- Type attributes
    let @PLMTypeAttributes typeAttributes = .instanciable | .copyable
  #-------------------------------------------- Enter in type map
    let dynamicArrayType = @PLMType.new {
      !propertyMap:propertyMap
      !classConstantMap:{}
      !constructorMap:constructorMap
      !guardMap:{}
      !attributes:typeAttributes
      !plmTypeDescriptionName:plmTypeDescriptionName
      !kind:.dynamicArrayType {!elementType:elementType}
      !llvmBaseTypeName:llvmBaseTypeName
    }
    [!?ioContext.mTypeMap insertType
      !lkey:mDynamicArrayTypeName
      !type:dynamicArrayType
      !index:[ioContext.mTypeMap count]
      !generate:true
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateLLVMcodeForDynamicArray
  ?!@string ioLLVMcode
  ?!@generationAdds ioGenerationAdds
  ?let @PLMType inArrayType
  ?let @PLMType inElementType
{
  ioGenerationAdds.mNeedsDynamicMemoryAllocation = true
  let llvmArrayBaseTypeName = inArrayType.llvmBaseTypeName # inTemporaryTypeName
  let elementLLVMTypeName = [inElementType llvmTypeName]
#---------- Method 'removeAll()'
  let removeAllRoutineMangledName = routineMangledNameFromAST (
    !llvmArrayBaseTypeName
    !["removeAll" nowhere]
    !{}
  )
  let removeAllRoutineLLVMName = llvmNameForFunction (!removeAllRoutineMangledName.string)
  ioLLVMcode += llvmTitleComment (!removeAllRoutineMangledName.string)
  ioLLVMcode += "define internal void @" + removeAllRoutineLLVMName + " (%ptrtype* %ioArray)" + llvmAttributeFunction () + "{\n"
  ioLLVMcode += "  %buffer.pointer = load %ptrtype, %ptrtype* %ioArray\n"
  ioLLVMcode += "  call void @arc.release (%ptrtype %buffer.pointer)\n"
  ioLLVMcode += "  store %ptrtype null, %ptrtype* %ioArray\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
#---------- Method 'length()'
  let lengthRoutineMangledName = routineMangledNameFromAST (
    !llvmArrayBaseTypeName
    !["length" nowhere]
    !{}
  )
  let lengthRoutineLLVMName = llvmNameForFunction (!lengthRoutineMangledName.string)
  ioLLVMcode += llvmTitleComment (!lengthRoutineMangledName)
  ioLLVMcode += "define internal i32 @" + lengthRoutineLLVMName + " (%ptrtype* %ioArray)" + llvmAttributeFunction () + "{\n"
  ioLLVMcode += "  %buffer.pointer = load %ptrtype, %ptrtype* %ioArray\n"
  ioLLVMcode += "  %length = call i32 @arc.length (%ptrtype %buffer.pointer)\n"
  ioLLVMcode += "  ret i32 %length\n"
  ioLLVMcode += "}\n\n"
#---------- Method 'insert(?:?atIndex:)'
  @routineFormalArgumentListAST argumentList = {
    !.input
    !["" nowhere]
    ![inElementType.llvmBaseTypeName nowhere]
    !["inValue" nowhere]
  ,
    !.input
    !["atIndex" nowhere]
    !["uint32" nowhere]
    !["inIndex" nowhere]
  }
  let insertRoutineMangledName = routineMangledNameFromAST (
    !llvmArrayBaseTypeName
    !["insert" nowhere]
    !argumentList
  )
  let insertRoutineLLVMName = llvmNameForFunction (!insertRoutineMangledName.string)
  ioLLVMcode += llvmTitleComment (!insertRoutineMangledName)
  ioLLVMcode += "define internal void @" + insertRoutineLLVMName + " (%ptrtype* %ioArray"
  ioLLVMcode += ", " + elementLLVMTypeName + " %inValue"
  ioLLVMcode += ", i32 %inIndex"
  ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
  ioLLVMcode += ";--- Inserted element pointer\n"
  ioLLVMcode += "  %insert.address = alloca %ptrtype\n"
  ioLLVMcode += ";--- value pointer\n"
  ioLLVMcode += "  %value.pointer = alloca " + elementLLVMTypeName + "\n"
  ioLLVMcode += "  store " + elementLLVMTypeName + " %inValue, " + elementLLVMTypeName + "* %value.pointer\n"
  ioLLVMcode += ";--- Size of element\n"
  ioLLVMcode += "  %sizeAsPtr = getelementptr inbounds " + elementLLVMTypeName + ", " + elementLLVMTypeName + "* null, i32 1\n"
  ioLLVMcode += "  %element.byte.size = ptrtoint " + elementLLVMTypeName + "* %sizeAsPtr to i32\n"
  ioLLVMcode += ";--- Get inserted element pointer\n"
  ioLLVMcode += "  %current.buffer.pointer = load %ptrtype, %ptrtype* %ioArray\n"
  ioLLVMcode += "  %new.buffer.pointer = call %ptrtype @arc.insert.at.index "
  ioLLVMcode += "(%ptrtype %current.buffer.pointer, i32 %inIndex, i32 %element.byte.size, %ptrtype* %insert.address)\n"
  ioLLVMcode += ";--- Perform copy\n"
  ioLLVMcode += "  %typed.insert.address = bitcast %ptrtype* %insert.address to " + elementLLVMTypeName + "*\n"
  ioLLVMcode += "  call void @plm.assign."
  ioLLVMcode += [inElementType.llvmBaseTypeName assemblerRepresentation]
  ioLLVMcode += "."
  ioLLVMcode += [inElementType.llvmBaseTypeName assemblerRepresentation]
  ioLLVMcode += " (" + elementLLVMTypeName + "* %typed.insert.address, " + elementLLVMTypeName + "* %value.pointer)\n"
  ioLLVMcode += ";--- Store new buffer pointer\n"
  ioLLVMcode += "  store %ptrtype %new.buffer.pointer, %ptrtype* %ioArray\n"
  ioLLVMcode += ";--- Return\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
#---------- Method 'append(?:)'
  argumentList = {
    !.input
    !["" nowhere]
    ![inElementType.llvmBaseTypeName nowhere]
    !["inValue" nowhere]
  }
  let routineMangledName = routineMangledNameFromAST (
    !llvmArrayBaseTypeName
    !["append" nowhere]
    !argumentList
  )
  var routineLLVMName = llvmNameForFunction (!routineMangledName.string)
  ioLLVMcode += llvmTitleComment (!routineMangledName)
  ioLLVMcode += "define internal void @" + routineLLVMName
             + " (%ptrtype* %ioArray, " + elementLLVMTypeName + " %inValue)" + llvmAttributeFunction () + "{\n"
  ioLLVMcode += ";--- Get buffer length\n"
  ioLLVMcode += "  %current.buffer.pointer = load %ptrtype, %ptrtype* %ioArray\n"
  ioLLVMcode += "  %current.buffer.length = call i32 @arc.length (%ptrtype %current.buffer.pointer)\n"
  ioLLVMcode += ";--- Insert\n"
  ioLLVMcode += "  call void @" + insertRoutineLLVMName
             + "(%ptrtype* %ioArray, " + elementLLVMTypeName + " %inValue, i32 %current.buffer.length)\n"
  ioLLVMcode += ";--- Return\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
#--- Assignment
  ioLLVMcode += llvmSeparatorLine () + "\n"
  ioLLVMcode += "define internal void @plm.assign."
  ioLLVMcode += [inArrayType.llvmBaseTypeName assemblerRepresentation]
  ioLLVMcode += "."
  ioLLVMcode += [inArrayType.llvmBaseTypeName assemblerRepresentation]
  ioLLVMcode += " (%ptrtype * %inTargetPtr, %ptrtype* %inSourcePtr) nounwind optsize {\n"
  ioLLVMcode += "  %source = load %ptrtype, %ptrtype* %inSourcePtr\n" 
  ioLLVMcode += "  call void @arc.retain (%ptrtype %source)\n" 
  ioLLVMcode += "  %target = load %ptrtype, %ptrtype* %inTargetPtr\n" 
  ioLLVMcode += "  call void @arc.release (%ptrtype %target)\n" 
  ioLLVMcode += "  store %ptrtype %source, %ptrtype* %inTargetPtr\n" 
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
