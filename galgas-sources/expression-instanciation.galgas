#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @instanciationAST : @expressionAST {
  @lstring mTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $new$
    <type_definition> ?let typeName
    $($
    $)$
    outExpression = @instanciationAST.new {!typeName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @instanciationAST addDependenceEdgeForStaticExpression
  ?let @lstring unused inConstantName
  ?!@constantPrecedenceGraph unused ioGraph
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @instanciationAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMap unused ioUniversalMap
  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze constructor source type
  let expressionType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTypeName}
#--- Generate code
  [inContext.mInstanciationMap searchKey !mTypeName ?let @literalStructureList literalStructureList]
  outResult = .literalStructure {!value:literalStructureList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @instanciationAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool unused inGuard
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMap unused ioUniversalMap
  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze constructor source type
  let expressionType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTypeName}
#--- Generate code
  [inContext.mInstanciationMap searchKey !mTypeName ?let @literalStructureList literalStructureList]
  outResult = .literalStructure {!value:literalStructureList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
