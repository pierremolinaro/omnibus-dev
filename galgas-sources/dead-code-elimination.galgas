#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#                                                                                                                       
#    C O D E    O P T I M I Z A T I O N                                                                                 
#                                                                                                                       
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

abstract method @abstractInstructionIR enterAccessibleEntities
  ?!@stringset ioInvokedRoutineSet
  ?!@uint ioMaxBranchOfOnInstructions

#Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·

method @instructionListIR enterAccessibleEntities ?!@stringset ioInvokedRoutineSet ?!@uint ioMaxBranchOfOnInstructions {
  for (instruction) in self do
    [instruction enterAccessibleEntities !?ioInvokedRoutineSet !?ioMaxBranchOfOnInstructions]
  end
}

#Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·

list @routineAccessibilityIR {
  @abstractRoutineIR mRoutine
  @stringset mAccessibleRoutineSet
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

proc codeOptimization
 ?let @string inSourceFile
 ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @uint maxBranchOfOnInstructions = 0
  @routineAccessibilityIR routineAccessibilityIR = {}
#--- Compute accessiblity graph
  @stringset exploreRoutineSet = {}
  for routine in ioIntermediateCodeStruct.mRoutineListIR do
    @stringset accessibleRoutineSet = {}
    [routine.mRoutine enterAccessibleEntities !?accessibleRoutineSet !?maxBranchOfOnInstructions]
    routineAccessibilityIR += !routine.mRoutine !accessibleRoutineSet
    if routine.mRoutine.mIsRequired then
      exploreRoutineSet += !routine.mRoutine.mRoutineMangledName
    end
  end
  if [option plm_options.printPasses value] then
    var m = "** Dead Code Elimination\n"
    m += "    " + [[ioIntermediateCodeStruct.mRoutineListIR length] string] + " routines, "
    m += [[exploreRoutineSet count] string] + " root routines.\n"
    message m
  end
#--- Compute useful routines
  if [option plm_options.noDeadCodeElimination value] then
    message "    No dead code elimination (option --" + [option plm_options.noDeadCodeElimination string] + ")\n"
  else
    @stringset usefulRoutineSet = {}
    loop ([ioIntermediateCodeStruct.mRoutineListIR length] + 1) while [exploreRoutineSet count] > 0 do
      let currentSet = exploreRoutineSet
      exploreRoutineSet = {}
      for routine in routineAccessibilityIR do
        let routineMangledName = routine.mRoutine.mRoutineMangledName
        if [currentSet hasKey !routineMangledName] & not [usefulRoutineSet hasKey !routineMangledName] then
          usefulRoutineSet += !routineMangledName
          exploreRoutineSet += routine.mAccessibleRoutineSet
        end
      end
    end
    if [option plm_options.printPasses value] then
      var m = "    " + [[usefulRoutineSet count] string] + " useful routines.\n"
  #    for (r) in usefulRoutineSet do
  #      m += "    - " + r + "\n"
  #    end
      message m
    end
  #--- Eliminate useless routines
    ioIntermediateCodeStruct.mRoutineListIR = {}
    for (routine *) in routineAccessibilityIR do
      if [usefulRoutineSet hasKey !routine.mRoutineMangledName] then
        ioIntermediateCodeStruct.mRoutineListIR += !routine
      end
    end
  end
#--- Display invocation graph
  let filePath = inSourceFile + ".routineInvocation.dot"
  if [option plm_options.emitRoutineInvocationGraphFile value] then
    displayInvocationGraph (!ioIntermediateCodeStruct.mRoutineListIR !filePath)
  else
    [@string deleteFileIfExists !filePath]
  end
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

private proc displayInvocationGraph
  ?let @routineListIR inRoutineListIR
  ?let @string inFilePath
{
  var s = "digraph G {\n"
#--- Build graph
  @stringset definedRoutines = {}
  @stringset allRoutines = {}
  for (routine) in inRoutineListIR do
    definedRoutines += !routine.mRoutineMangledName
    allRoutines += !routine.mRoutineMangledName
    @stringset accessibleRoutineSet = {}
    [routine enterAccessibleEntities !?accessibleRoutineSet !?*]
    allRoutines += accessibleRoutineSet
    s += "  \"" + routine.mRoutineMangledName + "\" [shape=rectangle"
    if routine.mIsRequired then
      s += ", color=blue" # Required routines are blue
    end
    s += "] ;\n"
    for accessible in accessibleRoutineSet do
      s += "  \"" + routine.mRoutineMangledName + "\" -> \"" + accessible + "\" ;\n"
    end
  end
#--- For undefined routines, create red nodes
  let undefinedRoutineSet = allRoutines - definedRoutines
  for undefined in undefinedRoutineSet do
    s += "  \"" + undefined + "\" [shape=rectangle, color=red] ;\n"  
  end
  s += "}\n"
  [s writeToFileWhenDifferentContents !inFilePath ?*]
  if [undefinedRoutineSet count] > 0 then
    var m = [[undefinedRoutineSet count] string] + " undefined routine(s) in routine invocation graph"
    for (r) in undefinedRoutineSet do
      m += "\n    - " + r
    end
    error .nowhere : m
  end
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
