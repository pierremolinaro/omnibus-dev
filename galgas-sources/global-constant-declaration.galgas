#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @globalConstantDeclarationListAST {
  @lstring mConstantName
  @lstring mTypeName
  @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $let$
    $identifier$ ?let constantName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $typeName$ ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
    ioAST.mGlobalConstantDeclarationListAST +=
      !constantName
      !typeName
      !expression
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @constantPrecedenceGraph (@globalConstantDeclarationListAST) {
  insert addNode error message "the '%K' symbol is already declared at %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@constantPrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildOrderedConstantDeclarationList
  ?let @globalConstantDeclarationListAST inUnorderedConstantDeclarationList
  ?let @string inSourceFile
  ?let @location inEndOfSourceFile
  !@globalConstantDeclarationListAST outOrderedConstantDeclarationList
{
  @constantPrecedenceGraph constantPrecedenceGraph = .emptyGraph
#--- Enter constant declarations in dependence graph
  for (constantName typeName sourceExpression) in inUnorderedConstantDeclarationList do
    [!?constantPrecedenceGraph addNode !constantName !constantName !typeName !sourceExpression]
    [sourceExpression addDependenceEdgeForStaticExpression !constantName !?constantPrecedenceGraph]
  end
#---  Write precedence graph file ?
  if (@uint.errorCount == 0) && [option plm_options.writeGlobalConstantDependencyGraphFile value] then
    let s = [constantPrecedenceGraph graphviz]
    let filePath = inSourceFile + ".globalConstantDependency.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Get ordered constant declaration list
  outOrderedConstantDeclarationList = {}
  if [constantPrecedenceGraph undefinedNodeCount] > 0 then
    for () in  [constantPrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" + mValue + "' constant is not defined"
    end
  else
    [constantPrecedenceGraph topologicalSort
      ?outOrderedConstantDeclarationList
      ?*
      ?let @globalConstantDeclarationListAST unsortedSemanticDeclarationListAST
      ?*
    ]
    if [unsortedSemanticDeclarationListAST length] > 0 then
      var s = "semantic analysis not performed, "
            + [unsortedSemanticDeclarationListAST length]
            + " constants are involved in circular definition:"
      for () in  unsortedSemanticDeclarationListAST do
        s += "\n-  " + mConstantName
      end
      error inEndOfSourceFile : s
      for () in  unsortedSemanticDeclarationListAST do
        error mConstantName : "the " + mConstantName + " constant is declared here"
      end
    end
  end
#  log outOrderedConstantDeclarationList
}
  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterGlobalConstantsInContext
  ?orderedConstantDeclarationList:let @globalConstantDeclarationListAST inOrderedConstantDeclarationList
  ?sourceFile:let @lstring inSourceFile
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!context:@semanticContext ioContext
{
  @variableMap variableMap = .emptyMap
  for (constantName constantTypeName sourceExpression) in inOrderedConstantDeclarationList do
  #--- Get destination type
    @unifiedTypeMap-proxy annotationType
    if constantTypeName.string == "" then
      annotationType = .null
    else
      [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !constantTypeName ?annotationType]
    end
  #--- Analyze source expression
    @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    [sourceExpression analyzeExpression
       !routineNameForInvocationGraph:["compiler" nowhere]
       !optionalTargetType:annotationType
       !context:ioContext
       !modes:{}
       !allowException:true
       !?temporary:temporaries
       !?staticStringMap:ioGlobalLiteralStringMap
       !?variableMap:variableMap
       !?instructionListIR:instructionGenerationList
       ?result:let @operandIR expressionResult
    ]
  #--- Check assignment compatibility
    checkAssignmentCompatibility (
      !source:expressionResult
      !targetType:annotationType
      !errorLocation:constantName.location
    )
  #--- Constant type
    let constantType = if annotationType == .null then expressionResult.mType else annotationType end
    let result = @operandIR.new {!constantType !expressionResult.mValue}
  #--- Check source expression is statically comtuted
    if ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
      error constantName : "source expression cannot be statically computed"
    end
  #--- Enter in context
    [!?ioContext.mGlobalConstantMap insertKey
      !constantName
      !result
    ]
  #--- Enter in constant variable map
    [!?variableMap insertUsedLocalConstant
      !constantName
      !constantType
      !true
      !.globalConstant{!value:result !name:constantName.string}
      !true
      !{}
      !false # Cannot be used as input parameter
      !true # Is constant
    ]
  end
#------------------------------------ Build an HTML file that contains all declared constants
  let @string typeDumpFilePath = inSourceFile.string + "global-constants.html"
  if [option plm_options.writeGlobalConstantHTMLDumpFile value] then
    @stringset firstLetterSet = {}
    for () in ioContext.mGlobalConstantMap do
      firstLetterSet += ![[lkey.string characterAtIndex!0] string]
    end
    @string tableOfTypeString = ""
    @char currentFirstLetter = ' '
    for () type_ in ioContext.mGlobalConstantMap do
      if currentFirstLetter != [type_lkey.string characterAtIndex !0] then
        currentFirstLetter = [type_lkey.string characterAtIndex !0]
        tableOfTypeString += "<br><a name=\"" + [currentFirstLetter uint] + "\"><b>" + currentFirstLetter + "</b></a><br>"
      end
      tableOfTypeString += linkForGlobalConstant (!type_lkey.string) + "<br>"
    end
    let @string typeDumpString = [filewrapper constantDumpGenerationTemplate.dump
      ![inSourceFile lastPathComponent]
      !ioContext.mGlobalConstantMap
      !firstLetterSet
      !tableOfTypeString
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper constantDumpGenerationTemplate in "../generation-templates/" {
}{
}{
  template dump "globalConstantDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@globalConstantMap GLOBAL_CONSTANT_MAP
    ?@stringset FIRST_LETTER_SET
    ?@string TABLE_OF_TYPES_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

func linkForGlobalConstant ?let @string inConstantName -> @string outResult {
  outResult = "<a class=\"header_link\" href=\"#" + inConstantName + "\">" + inConstantName + "</a>"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc generateGlobalConstantLLVMCode
#  ?context:let @semanticContext inContext
#  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
#  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
#{
#  for (constantName constantValue) in inContext.mGlobalConstantMap do
#    [!?ioIntermediateCodeStruct.mGlobalConstantMap insertKey
#      !constantName
#      !constantValue.mType
#      !constantValue.mValue
#    ]
#  end
#
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#method @globalConstantMapIR-element generateLLVM ?!@string unused ioLLVMcode {
#  ioLLVMcode += "@" + llvmNameForGlobalVariable (!lkey.string) + " = internal constant "
#  ioLLVMcode += [mType llvmTypeName] + " " +  [mSourceExpression llvmName] + "\n"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
