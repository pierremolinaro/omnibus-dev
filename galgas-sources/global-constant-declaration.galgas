#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @globalConstantDeclaration : @abstractDeclaration {
  @lstring mConstantName
  @lstring mConstantTypeName
  @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @globalConstantDeclaration location -> @location outLocation {
  outLocation = mConstantName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $let$
    $identifier$ ?let constantName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $typeName$ ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
    ioAST.mDeclarationList += !@globalConstantDeclaration.new {
      !constantName
      !typeName
      !expression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
#--- Add 'constant name' node
  [!?ioGraph addNode !mConstantName !self]
#--- Add dependency from constant type name
  if mConstantTypeName.string != "" then
    let typeName = @lstring.new {!"$" + mConstantTypeName !mConstantTypeName.location}
    [!?ioGraph addEdge !mConstantName !typeName]
  end
#--- Add dependency from source expression
  [mSourceExpression addDependenceEdgeForStaticExpression !mConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc buildOrderedConstantDeclarationList
#  ?let @globalConstantDeclarationListAST inUnorderedConstantDeclarationList
#  ?let @string inSourceFile
#  ?let @location inEndOfSourceFile
#  !@globalConstantDeclarationListAST outOrderedConstantDeclarationList
#{
#  @semanticTypePrecedenceGraph constantPrecedenceGraph = .emptyGraph
##--- Enter constant declarations in dependence graph
#  for (constantName typeName sourceExpression) in inUnorderedConstantDeclarationList do
#    [!?constantPrecedenceGraph addNode !constantName !constantName !typeName !sourceExpression]
#    [sourceExpression addDependenceEdgeForStaticExpression !constantName !?constantPrecedenceGraph]
#  end
##---  Write precedence graph file ?
#  if (@uint.errorCount == 0) && [option plm_options.writeGlobalConstantDependencyGraphFile value] then
#    let s = [constantPrecedenceGraph graphviz]
#    let filePath = inSourceFile + ".globalConstantDependency.dot"
#    [s writeToFileWhenDifferentContents !filePath ?*]
#  end
##--- Get ordered constant declaration list
#  outOrderedConstantDeclarationList = {}
#  if [constantPrecedenceGraph undefinedNodeCount] > 0 then
#    for () in  [constantPrecedenceGraph undefinedNodeReferenceList] do
#      error mValue : "the '" + mValue + "' constant is not defined"
#    end
#  else
#    [constantPrecedenceGraph topologicalSort
#      ?outOrderedConstantDeclarationList
#      ?*
#      ?let @globalConstantDeclarationListAST unsortedSemanticDeclarationListAST
#      ?*
#    ]
#    if [unsortedSemanticDeclarationListAST length] > 0 then
#      var s = "semantic analysis not performed, "
#            + [unsortedSemanticDeclarationListAST length]
#            + " constants are involved in circular definition:"
#      for () in  unsortedSemanticDeclarationListAST do
#        s += "\n-  " + mConstantName
#      end
#      error inEndOfSourceFile : s
#      for () in  unsortedSemanticDeclarationListAST do
#        error mConstantName : "the " + mConstantName + " constant is declared here"
#      end
#    end
#  end
##  log outOrderedConstantDeclarationList
#}
  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @globalConstantDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "global constant " + mConstantName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  var variableMap = initialVariableMap (
    !routineNameForInvocation:"compiler" # inRoutineNameForInvocation
    !context:ioContext
    !globalsAreConstant:true # Any value, there is no defined global variable at this stage
  )
#--- Get destination type
  @unifiedTypeMap-proxy annotationType
  if mConstantTypeName.string == "" then
    annotationType = .null
  else
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mConstantTypeName ?annotationType]
  end
#--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
  @instructionListIR instructionGenerationList = {}
  [mSourceExpression analyzeExpression
     !routineNameForInvocationGraph:["compiler" nowhere]
     !optionalTargetType:annotationType
     !context:ioContext
     !modes:{}
     !allowException:true
     !?temporary:temporaries
     !?staticStringMap:ioGlobalLiteralStringMap
     !?variableMap:variableMap
     !?instructionListIR:instructionGenerationList
     ?result:let @operandIR expressionResult
  ]
#--- Check assignment compatibility
  checkAssignmentCompatibility (
    !source:expressionResult
    !targetType:annotationType
    !errorLocation:mConstantName.location
  )
#--- Constant type
  let constantType = if annotationType == .null then expressionResult.mType else annotationType end
  let result = @operandIR.new {!constantType !expressionResult.mValue}
#--- Check source expression is statically comtuted
  if ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
    error mConstantName : "source expression cannot be statically computed"
  end
#--- Enter in context
  [!?ioContext.mGlobalConstantMap insertKey
    !mConstantName
    !result
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  BUILD HTML FILE                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildGlobalConstantMapHTMLFile
  ?@globalConstantMap inGlobalConstantMap
  ?sourceFile:let @lstring inSourceFile
{
#------------------------------------ Build an HTML file that contains all declared constants
  let @string typeDumpFilePath = inSourceFile.string + "global-constants.html"
  if [option plm_options.writeGlobalConstantHTMLDumpFile value] then
    @stringset firstLetterSet = {}
    for () in inGlobalConstantMap do
      firstLetterSet += ![[lkey.string characterAtIndex!0] string]
    end
    @string tableOfTypeString = ""
    @char currentFirstLetter = ' '
    for () type_ in inGlobalConstantMap do
      if currentFirstLetter != [type_lkey.string characterAtIndex !0] then
        currentFirstLetter = [type_lkey.string characterAtIndex !0]
        tableOfTypeString += "<br><a name=\"" + [currentFirstLetter uint] + "\"><b>" + currentFirstLetter + "</b></a><br>"
      end
      tableOfTypeString += linkForGlobalConstant (!type_lkey.string) + "<br>"
    end
    let @string typeDumpString = [filewrapper constantDumpGenerationTemplate.dump
      ![inSourceFile lastPathComponent]
      !inGlobalConstantMap
      !firstLetterSet
      !tableOfTypeString
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper constantDumpGenerationTemplate in "../generation-templates/" {
}{
}{
  template dump "globalConstantDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@globalConstantMap GLOBAL_CONSTANT_MAP
    ?@stringset FIRST_LETTER_SET
    ?@string TABLE_OF_TYPES_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

func linkForGlobalConstant ?let @string inConstantName -> @string outResult {
  outResult = "<a class=\"header_link\" href=\"#" + inConstantName + "\">" + inConstantName + "</a>"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INIT ANALYSIS                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override  method @globalConstantDeclaration initAnalysis ?!context:@semanticContext unused ioContext {}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc generateGlobalConstantLLVMCode
#  ?context:let @semanticContext inContext
#  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
#  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
#{
#  for (constantName constantValue) in inContext.mGlobalConstantMap do
#    [!?ioIntermediateCodeStruct.mGlobalConstantMap insertKey
#      !constantName
#      !constantValue.mType
#      !constantValue.mValue
#    ]
#  end
#
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#method @globalConstantMapIR-element generateLLVM ?!@string unused ioLLVMcode {
#  ioLLVMcode += "@" + llvmNameForGlobalVariable (!lkey.string) + " = internal constant "
#  ioLLVMcode += [mType llvmTypeName] + " " +  [mSourceExpression llvmName] + "\n"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
