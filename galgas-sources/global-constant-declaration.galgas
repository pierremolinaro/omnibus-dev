#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @globalConstantDeclaration : @abstractDeclaration {
  @lstring mTypeName
  @lstring mConstantName
  @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @globalConstantDeclaration location -> @location outLocation {
  outLocation = mConstantName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $let$
    $identifier$ ?let constantName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $typeName$ ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
    ioAST.mDeclarationList += !@globalConstantDeclaration.new {
      !typeName
      !constantName
      !expression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !mConstantName !self]
  if mTypeName.string != "" then
    [!?ioGraph addEdge !mConstantName !mTypeName]
  end
  [mSourceExpression addDependenceEdgeForStaticExpression !mConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @globalConstantDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "global constant " + mConstantName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
#--- Get destination type
  @unifiedTypeMap-proxy constantType
  if mTypeName.string == "" then
    constantType = .null
  else
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mTypeName ?constantType]
  end
#--- Analyze source expression
  @semanticTemporariesStruct temporaries = .default
  @instructionListIR instructionGenerationList = {}
  @variableMap variableMap = .emptyMap
  [mSourceExpression analyzeExpression
     !routineNameForInvocationGraph:["compiler" nowhere]
     !optionalTargetType:constantType
     !context:ioContext
     !modes:{}
     !allowException:true
     !?temporary:temporaries
     !?staticStringMap:ioGlobalLiteralStringMap
     !?variableMap:variableMap
     !?instructionListIR:instructionGenerationList
     ?result:let @operandIR expressionResult
  ]
#--- Check assignment compatibility
  checkAssignmentCompatibility (
    !source:expressionResult
    !targetType:constantType
    !errorLocation:mConstantName.location
  )
#--- Check source expression is statically comtuted
  if ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
    error mConstantName : "source expression cannot be statically computed"
  end
#--- Enter in context
  [!?ioContext.mGlobalConstantMap insertKey
    !mConstantName
    !if constantType == .null then expressionResult.mType else constantType end
    !expressionResult.mValue
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration initAnalysis ?!context:@semanticContext unused ioContext { }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @globalConstantDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [inContext.mGlobalConstantMap searchKey
    !mConstantName
    ?let type
    ?let expressionGeneratedCode
  ]
  [!?ioIntermediateCodeStruct.mGlobalConstantMap insertKey
    !mConstantName
    !type
    !expressionGeneratedCode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @globalConstantMapIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += "@" + llvmNameForGlobalVariable (!lkey.string) + " = internal constant "
  ioLLVMcode += [mType llvmTypeName] + " " +  [mSourceExpression llvmName] + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
