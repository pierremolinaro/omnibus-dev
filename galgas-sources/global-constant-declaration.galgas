#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @globalConstantDeclarationListAST {
  @lstring mConstantName
  @lstring mTypeName
  @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $let$
    $identifier$ ?let constantName
    @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $typeName$ ?typeName
    end
    $=$
    <expression> ?let @expressionAST expression
    ioAST.mGlobalConstantDeclarationListAST +=
      !constantName
      !typeName
      !expression
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

graph @constantPrecedenceGraph (@globalConstantDeclarationListAST) {
  insert addNode error message "the '%K' symbol is already declared at %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@constantPrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildOrderedConstantDeclarationList
  ?let @globalConstantDeclarationListAST inUnorderedConstantDeclarationList
  ?let @string inSourceFile
  ?let @location inEndOfSourceFile
  !@globalConstantDeclarationListAST outOrderedConstantDeclarationList
{
  @constantPrecedenceGraph constantPrecedenceGraph = .emptyGraph
#--- Enter constant declarations in dependence graph
  for (constantName typeName sourceExpression) in inUnorderedConstantDeclarationList do
    [!?constantPrecedenceGraph addNode !constantName !constantName !typeName !sourceExpression]
    [sourceExpression addDependenceEdgeForStaticExpression !constantName !?constantPrecedenceGraph]
  end
#---  Write precedence graph file ?
  if (@uint.errorCount == 0) && [option plm_options.writeGlobalConstantDependencyGraphFile value] then
    let s = [constantPrecedenceGraph graphviz]
    let filePath = inSourceFile + ".globalConstantDependency.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Get ordered constant declaration list
  outOrderedConstantDeclarationList = {}
  if [constantPrecedenceGraph undefinedNodeCount] > 0 then
    for () in  [constantPrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" + mValue + "' constant is not defined"
    end
  else
    [constantPrecedenceGraph topologicalSort
      ?outOrderedConstantDeclarationList
      ?*
      ?let @globalConstantDeclarationListAST unsortedSemanticDeclarationListAST
      ?*
    ]
    if [unsortedSemanticDeclarationListAST length] > 0 then
      var s = "semantic analysis not performed, "
            + [unsortedSemanticDeclarationListAST length]
            + " constants are involved in circular definition:"
      for () in  unsortedSemanticDeclarationListAST do
        s += "\n-  " + mConstantName
      end
      error inEndOfSourceFile : s
      for () in  unsortedSemanticDeclarationListAST do
        error mConstantName : "the " + mConstantName + " constant is declared here"
      end
    end
  end
#  log outOrderedConstantDeclarationList
}
  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterGlobalConstantsInContext
  ?orderedConstantDeclarationList:let @globalConstantDeclarationListAST inOrderedConstantDeclarationList
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!context:@semanticContext ioContext
{
  @variableMap variableMap = .emptyMap
  for (constantName constantTypeName sourceExpression) in inOrderedConstantDeclarationList do
  #--- Get destination type
    @unifiedTypeMap-proxy constantType
    if constantTypeName.string == "" then
      constantType = .null
    else
      [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !constantTypeName ?constantType]
    end
  #--- Analyze source expression
    @semanticTemporariesStruct temporaries = .default
    @instructionListIR instructionGenerationList = {}
    [sourceExpression analyzeExpression
       !routineNameForInvocationGraph:["compiler" nowhere]
       !optionalTargetType:constantType
       !context:ioContext
       !modes:{}
       !allowException:true
       !?temporary:temporaries
       !?staticStringMap:ioGlobalLiteralStringMap
       !?variableMap:variableMap
       !?instructionListIR:instructionGenerationList
       ?result:let @operandIR expressionResult
    ]
  #--- Check assignment compatibility
    checkAssignmentCompatibility (
      !source:expressionResult
      !targetType:constantType
      !errorLocation:constantName.location
    )
  #--- Check source expression is statically comtuted
    if ([instructionGenerationList length] > 0) || not [expressionResult.mValue isStatic] then
      error constantName : "source expression cannot be statically computed"
    end
  #--- Enter in context
    [!?ioContext.mGlobalConstantMap insertKey
      !constantName
      !.new {!if constantType == .null then expressionResult.mType else constantType end !expressionResult.mValue}
    ]
  #--- Enter in constant variable map
    [!?variableMap insertUsedLocalConstant
      !constantName
      !constantType
      !true
      !.globalConstant{!value:expressionResult !name:constantName.string}
      !true
      !{}
      !false # Cannot be used as input parameter
      !true # Is constant
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc generateGlobalConstantLLVMCode
#  ?context:let @semanticContext inContext
#  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
#  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
#{
#  for (constantName constantValue) in inContext.mGlobalConstantMap do
#    [!?ioIntermediateCodeStruct.mGlobalConstantMap insertKey
#      !constantName
#      !constantValue.mType
#      !constantValue.mValue
#    ]
#  end
#
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#method @globalConstantMapIR-element generateLLVM ?!@string unused ioLLVMcode {
#  ioLLVMcode += "@" + llvmNameForGlobalVariable (!lkey.string) + " = internal constant "
#  ioLLVMcode += [mType llvmTypeName] + " " +  [mSourceExpression llvmName] + "\n"
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
