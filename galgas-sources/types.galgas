#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    C O N T E X T                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @typeKind {
  case boolean
  case literalString
  case enumeration (@enumConstantMap constantMap @classConstantMap classConstantMap)
  case structure (@lstring typeName @propertyMap propertyMap @propertyList propertyList @uint flags)
  case integer (@bigint min @bigint max @bool unsigned @uint bitCount)
  case staticInteger
  case opaque (@bigint bitCount @uint flags)
  case arrayType (@lstring typeName
                  @unifiedTypeMap-proxy elementType
                  @bigint size
                  @classConstantMap classConstantMap
                  @uint flags)
  case function (@routineDescriptor descriptor)
  case pointer (@typeKind pointee)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sharedmap @unifiedTypeMap %selectors {
  @typeKind kind

  insert insertType error message "the '%K' type is already declared in %L"
  search searchKey error message "there is no '%K' type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#func %once comparableFlag   -> @uint { result = 1 << 1 }

getter @unifiedTypeMap-proxy equatable -> @bool {
  result = [[self kind] equatable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind equatable -> @bool {
  switch self
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* *) :
    result = true
  case structure (* * * @uint flags) :
    result = (flags & equatableFlag ()) != 0
  case integer (* * * *) :
    result = true
  case opaque (* @uint flags) :
    result = (flags & equatableFlag ()) != 0
  case arrayType (* * * * @uint flags) :
    result = (flags & equatableFlag ()) != 0
  case function (*) :
    result = false
  case pointer (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy instanciable -> @bool {
  result = [[self kind] instanciable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind instanciable -> @bool {
  switch self
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* *) :
    result = true
  case structure (* * * @uint flags) :
    result = (flags & instanciableFlag ()) != 0
  case integer (* * * *) :
    result = true
  case opaque (* @uint flags) :
    result = (flags & instanciableFlag ()) != 0
  case arrayType (* * * * @uint flags) :
    result = (flags & instanciableFlag ()) != 0
  case function (*) :
    result = false
  case pointer (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy copyable -> @bool {
  result = [[self kind] copyable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind copyable -> @bool {
  switch self
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* *) :
    result = true
  case structure (* * * @uint flags) :
    result = (flags & copyableFlag ()) != 0
  case integer (* * * *) :
    result = true
  case opaque (* @uint flags) :
    result = (flags & copyableFlag ()) != 0
  case arrayType (* * * * @uint flags) :
    result = (flags & copyableFlag ()) != 0
  case function (*) :
    result = false
  case pointer (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy classConstantMap -> @classConstantMap {
  switch [self kind]
  case boolean, literalString, staticInteger :
    result = {}
  case enumeration (* @classConstantMap classConstantMap) :
    result = classConstantMap
  case structure (* * * *) :
    result = {}
  case integer (* * * *) :
    result = {}
  case opaque (* *) :
    result = {}
  case arrayType (* * * @classConstantMap classConstantMap *) :
    result = classConstantMap
  case function (*) :
    result = {}
  case pointer (*) :
    result = {}
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind llvmTypeName -> @string {
  switch self
  case boolean :
    result = "i1"
  case literalString :
    result = "i8*"
  case enumeration (@enumConstantMap constantMap *) :
    result = "i" + [[constantMap count] - 1 significantBitCount]
  case structure (@lstring typeName * * *) :
    result = "%" + [llvmRegularTypeMangledNameFromName (!typeName) assemblerRepresentation]
  case integer (@bigint unused min @bigint unused max @bool unused unsigned @uint bitCount) :
    result = "i" + bitCount
  case staticInteger :
    error .nowhere : "INTERNAL ERROR" : result
  case opaque (@bigint bitCount *) :
    result = "i" + bitCount
  case arrayType (@lstring typeName * * * *) :
    result = "%" + [typeName assemblerRepresentation]
  case function (descriptor) :
    if descriptor.mReturnType == .null then
      result = "void"
    else
      result = [[descriptor.mReturnType kind] llvmTypeName]
    end
    result += "("
    for () in descriptor.mSignature 
    do
      result += [[mType kind] llvmTypeName]
      switch mFormalArgumentPassingMode
      case inputOutput, output : result += "*"
      case input :
      end
    between result += ", "
    end
    result += ")*"
  case pointer (pointee) :
    result = [pointee llvmTypeName] + "*"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
