#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    P L M    T Y P E                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

boolset @PLMTypeAttributes {
  instanciable, equatable, copyable, comparable
}

#·······················································································································

struct @PLMType {
  @propertyMap propertyMap %selector # Properties and methods
  @classConstantMap classConstantMap %selector # $type.cst, as enumeration values
  @constructorMap constructorMap %selector # $type (!... !...)
  @guardMapForContext guardMap %selector
  @PLMTypeAttributes attributes %selector # as instanciable, copyable, ...
  @string plmTypeDescriptionName %selector # used for type checking and type display
  @typeKind kind %selector
  @string llvmBaseTypeName %selector # Without le leading '$'; empty string for void type kind, used for type implementation
}

#·······················································································································

getter @PLMType llvmTypeName -> @string {
  switch self.kind
  case void :
    result = "void"
  case boolean :
    result = "i1"
  case literalString :
    result = "i8*"
  case enumeration (@uint bitCount) :
    result = "i" + bitCount
  case structure (*) :
    result = "%" + [[self llvmBaseTypeName] assemblerRepresentation]
  case syncTool (*) :
    result = "%" + [[self llvmBaseTypeName] assemblerRepresentation]
  case integer (* * * @uint bitCount) :
    result = "i" + bitCount
  case staticInteger :
    result = "i32"
  case opaque (@bigint bitCount) :
    result = "i" + bitCount
  case arrayType (* *) :
    result = "%" + [[self llvmBaseTypeName] assemblerRepresentation]
  case dynamicArrayType (*) :
    result = "%ptrtype" # "i" + ptrSize
  case function (@routineDescriptor descriptor) :
    if descriptor.returnTypeProxy == .null then
      result = "void"
    else
      result = [[descriptor.returnTypeProxy type] llvmTypeName]
    end
    result += "("
    for () in descriptor.signature 
    do
      result += [[mTypeProxy type] llvmTypeName]
      switch mFormalArgumentPassingMode
      case inputOutput, output : result += "*"
      case input :
      end
    between result += ", "
    end
    result += ")*"
  case pointer (pointee) :
    result = [pointee llvmTypeName] + "*"
  end
}

#·······················································································································

enum @typeKind {
  case void # No actual type, used for no annotation type, ...
  case boolean
  case literalString
  case enumeration (@uint bitCount)
  case structure (@propertyList propertyList)
  case syncTool (@propertyList propertyList)
  case integer (@bigint min @bigint max @bool unsigned @uint bitCount)
  case staticInteger
  case opaque (@bigint bitCount)
  case arrayType (@PLMType elementType @bigint size)
  case dynamicArrayType (@PLMType elementType)
  case function (@routineDescriptor descriptor)
  case pointer (@PLMType pointee)
}

#·······················································································································

func staticIntegerType -> @PLMType {
  result = .new {
    !propertyMap:{}
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.equatable | .copyable
    !plmTypeDescriptionName:staticIntegerTypeName ()
    !kind:.staticInteger
    !llvmBaseTypeName:staticIntegerTypeName ()
  }
}

#·······················································································································

func literalStringType -> @PLMType {
  result = .new {
    !propertyMap:{}
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.instanciable | .equatable | .copyable
    !plmTypeDescriptionName:staticStringTypeName () 
    !kind:.literalString
    !llvmBaseTypeName:staticStringTypeName ()
  }
}

#·······················································································································

func voidType -> @PLMType {
  result = .new {
    !propertyMap:{}
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.none
    !plmTypeDescriptionName:""
    !kind:.void
    !llvmBaseTypeName:""
  }
}

#·······················································································································

func functionType ?let @routineDescriptor inDescriptor -> @PLMType {
  @string llvmTypeName
    if inDescriptor.returnTypeProxy == .null then
      llvmTypeName = "void"
    else
      llvmTypeName = [[inDescriptor.returnTypeProxy type] llvmTypeName]
    end
    llvmTypeName += "("
    for () in inDescriptor.signature 
    do
      llvmTypeName += [[mTypeProxy type] llvmTypeName]
      switch mFormalArgumentPassingMode
      case inputOutput, output : llvmTypeName += "*"
      case input :
      end
    between llvmTypeName += ", "
    end
    llvmTypeName += ")*"
  result = .new{
    !propertyMap:{}
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.none
    !plmTypeDescriptionName:""
    !kind:.function {!descriptor:inDescriptor}
    !llvmBaseTypeName:""
  }
}

#·······················································································································

getter @PLMType equatable -> @bool {
  result = [attributes equatable]
}

#·······················································································································

getter @unifiedTypeMap-proxy instanciable -> @bool {
  result = [[self type] instanciable]
}

#·······················································································································

getter @PLMType instanciable -> @bool {
  result = [attributes instanciable]
}

#·······················································································································

getter @unifiedTypeMap-proxy copyable -> @bool {
  result = [[self type] copyable]
}

#·······················································································································

getter @PLMType copyable -> @bool {
  result = [attributes copyable]
}

#·······················································································································

method @PLMType generateRetain
  ?let @string inPLMName
  ?!@string ioLLVMcode
  ?!@generationAdds ioGenerationAdds
{
  let llvmTypeName = [self llvmTypeName]
  let LLVMVariable =  llvmNameForLocalVariable (!inPLMName)
  if [self.kind isDynamicArrayType] then
    let tempLLVMVariable = "%temp." + [inPLMName assemblerRepresentation] + ".loaded." + ioGenerationAdds.mUniqueIndex
    ioGenerationAdds.mUniqueIndex ++
    ioLLVMcode += "  " + tempLLVMVariable + " = load " + llvmTypeName + ", " + llvmTypeName + "* " + LLVMVariable + "\n"
    ioLLVMcode += "  call void @arc.retain (" + llvmTypeName + " " + tempLLVMVariable + ")\n"
  else
    let arcAssignmentList = [self arcList !{}]
    for (propertyName propertyType indexPath) in arcAssignmentList do 
      let llvmVarName = "%arc.retain." + ioGenerationAdds.mUniqueIndex
      ioGenerationAdds.mUniqueIndex ++
      ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* " + LLVMVariable + ", i32 0"
      for (idx) in indexPath do
        ioLLVMcode += ", i32 " + idx
      end
      ioLLVMcode += " ; " + propertyName + "\n"
      let propertyTypeLLVMName = [propertyType llvmTypeName]
      let llvmLoadedVarName = llvmVarName + ".loaded"
      ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
      ioLLVMcode += "  call void @arc.retain (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
    end
  end
}

#·······················································································································

method @PLMType generateInsulate
  ?let @string inPLMName
  ?!@string ioLLVMcode
  ?!@generationAdds ioGenerationAdds
{
  let llvmTypeName = [self llvmTypeName]
  let LLVMVariable =  llvmNameForLocalVariable (!inPLMName)
  if [self.kind isDynamicArrayType] then
    let loadedVar = "%temp." + [inPLMName assemblerRepresentation] + ".loaded." + ioGenerationAdds.mUniqueIndex   
    let insulatedVar = "%temp." + [inPLMName assemblerRepresentation] + ".insulated." + ioGenerationAdds.mUniqueIndex   
    ioGenerationAdds.mUniqueIndex ++
    ioLLVMcode += "  " + loadedVar + " = load " + llvmTypeName + ", " + llvmTypeName + "* " + LLVMVariable + "\n"
    ioLLVMcode += "  " + insulatedVar + " = call " + llvmTypeName + " @arc.insulate (" + llvmTypeName + " " + loadedVar + ")\n"
    ioLLVMcode += "  store " + llvmTypeName + " " + insulatedVar + ", " + llvmTypeName + "* " + LLVMVariable + "\n"
  else
    let arcAssignmentList = [self arcList !{}]
    for (propertyName propertyType indexPath) in arcAssignmentList do 
      let llvmVarName = "%arc.release." + ioGenerationAdds.mUniqueIndex
      ioGenerationAdds.mUniqueIndex ++
      ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* " + LLVMVariable + ", i32 0"
      for (idx) in indexPath do
        ioLLVMcode += ", i32 " + idx
      end
      ioLLVMcode += " ; " + propertyName + "\n"
      let propertyTypeLLVMName = [propertyType llvmTypeName]
      let loadedVar = llvmVarName + ".loaded." + ioGenerationAdds.mUniqueIndex 
      let insulatedVar = llvmVarName + ".insulated." + ioGenerationAdds.mUniqueIndex 
      ioGenerationAdds.mUniqueIndex ++
      ioLLVMcode += "  " + loadedVar + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
      ioLLVMcode += "  " + insulatedVar + " = call " + propertyTypeLLVMName + " @arc.insulate (" + propertyTypeLLVMName + " " + loadedVar + ")\n" 
      ioLLVMcode += "  store " + propertyTypeLLVMName + " " + insulatedVar + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n"
    end
  end
}

#·······················································································································

method @PLMType generateRelease
  ?let @string inPLMName
  ?!@string ioLLVMcode
  ?!@generationAdds ioGenerationAdds
{
  let llvmTypeName = [self llvmTypeName]
  let LLVMVariable =  llvmNameForLocalVariable (!inPLMName)
  if [self.kind isDynamicArrayType] then
    let tempLLVMVariable = "%temp." + [inPLMName assemblerRepresentation] + ".loaded." + ioGenerationAdds.mUniqueIndex   
    ioGenerationAdds.mUniqueIndex ++
    ioLLVMcode += "  " + tempLLVMVariable + " = load " + llvmTypeName + ", " + llvmTypeName + "* " + LLVMVariable + "\n"
    ioLLVMcode += "  call void @arc.release (" + llvmTypeName + " " + tempLLVMVariable + ")\n"
  else
    let arcAssignmentList = [self arcList !{}]
    for (propertyName propertyType indexPath) in arcAssignmentList do 
      let llvmVarName = "%arc.release." + ioGenerationAdds.mUniqueIndex
      ioGenerationAdds.mUniqueIndex ++
      ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* " + LLVMVariable + ", i32 0"
      for (idx) in indexPath do
        ioLLVMcode += ", i32 " + idx
      end
      ioLLVMcode += " ; " + propertyName + "\n"
      let propertyTypeLLVMName = [propertyType llvmTypeName]
      let llvmLoadedVarName = llvmVarName + ".loaded"
      ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
      ioLLVMcode += "  call void @arc.release (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
    end
  end
}

#·······················································································································

getter @PLMType descriptionForHTMLFile -> @string {
  switch self.kind
  case void :
    result = "Void"
  case boolean :
    result = "Boolean"
  case literalString :
    result = "Literal String"
  case enumeration (*) :
    result = "Enumeration"
  case structure (*) :
    result = "Structure"
  case syncTool (*) :
    result = "Synchronization tool"
  case integer (* * @bool unsigned @uint bitCount) :
    result = "Integer (" + bitCount + " bit" + if bitCount > 1 then "s" else "" end
           + ", " + if unsigned then "unsigned" else "signed" end + ")"
  case staticInteger :
    result = "Static Integer"
  case opaque (@bigint bitCount) :
    result = "Opaque (" + bitCount + " bits)"
  case arrayType (* *) :
    result = "Static array"
  case dynamicArrayType (*) :
    result = "Dynamic array"
  case function (*) :
    result = "Function"
  case pointer (pointee) :
    result = "Pointer to " + [pointee llvmTypeName]
  end
}

#·······················································································································

getter @PLMType defaultAlignment -> @uint{
  switch self.kind
  case void :
    result = 0
  case boolean :
    result = 1
  case literalString :
    result = 4
  case enumeration (bitCount) :
    if bitCount <= 8 then
      result = 1
    elsif bitCount <= 16 then
      result = 2
    else
      result = 4
    end
  case structure (*) :
    result = 4
  case syncTool (*) :
    result = 4
  case integer (3* @uint bitCount) :
    if bitCount <= 8 then
      result = 1
    elsif bitCount <= 16 then
      result = 2
    else
      result = 4
    end
  case staticInteger :
    result = 0
  case opaque (@bigint bitCount) :
    if bitCount <= 8 then
      result = 1
    elsif bitCount <= 16 then
      result = 2
    else
      result = 4
    end
  case arrayType (elementType *) :
    result = [elementType defaultAlignment]
  case dynamicArrayType (*) :
    result = 4
  case function (*) :
    result = 4
  case pointer (*) :
    result = 4
  end
}

#·······················································································································

list @arcAssignmentList {
  @string mPropertyName
  @PLMType mPropertyType
  @uintlist mPropertyIndexPath
}

#·······················································································································

getter @PLMType arcList ?let @uintlist inPropertyIndexPath -> @arcAssignmentList {
  result = {}
  if [kind isDynamicArrayType] then
    result += !"" !self !inPropertyIndexPath
  elsif [kind isStructure] then
    [kind structure ?propertyList:let @propertyList propertyList]
    for (propertyName propertyType) in propertyList do (idx)
      let indexPath = inPropertyIndexPath + {!idx}
      result += [propertyType arcList !indexPath]
    end
  end
}

#·······················································································································

getter @PLMType deinitNeeded -> @bool {
  result = [kind isDynamicArrayType]
  if [kind isStructure] then
    [kind structure ?propertyList:let @propertyList propertyList]
    for (propertyName propertyType) in propertyList while not result do
      result = [propertyType deinitNeeded]
    end
  end
}

#·······················································································································

shared map @unifiedTypeMap %selectors {
  @PLMType type
  @uint index # This index allows to sort type for ensuring no forward LLVM type reference on generation

  insert insertType error message "the '%K' type is already declared in %L"
  search searchKey error message "there is no '%K' type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  BUILD TYPE MAP HTML FILE                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildTypeMapHTMLFile
  ?@unifiedTypeMap inTypeMap
  ?sourceFile:let @lstring inSourceFile
{
#------------------------------------ Build an HTML file that contains all types
  let @string typeDumpFilePath = inSourceFile.string + ".types.html"
  if [option plm_options.emitTypeMap value] then
    @stringset firstLetterSet = {}
    for () in inTypeMap do
      firstLetterSet += ![[lkey.string characterAtIndex!0] string]
    end
    @string tableOfTypeString = ""
    @char currentFirstLetter = ' '
    for () type_ in inTypeMap do
      if currentFirstLetter != [type_lkey.string characterAtIndex !0] then
        currentFirstLetter = [type_lkey.string characterAtIndex !0]
        tableOfTypeString += "<br><a name=\"" + [currentFirstLetter uint] + "\"><b>" + currentFirstLetter + "</b></a><br>"
      end
      tableOfTypeString += linkForHTMLTypeMap (!type_lkey.string) + "<br>"
    end
    let @string typeDumpString = [filewrapper typeDumpGenerationTemplate.dump
      ![inSourceFile lastPathComponent]
      !inTypeMap
      !firstLetterSet
      !tableOfTypeString
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
}

#·······················································································································

filewrapper typeDumpGenerationTemplate in "../generation-templates/" {
}{
}{
  template dump "typeDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@unifiedTypeMap GLOBAL_TYPE_MAP
    ?@stringset FIRST_LETTER_SET
    ?@string TABLE_OF_TYPES_STRING
}

#·······················································································································

func linkForHTMLTypeMap ?let @string inTypeName -> @string {
  result = "<a class=\"header_link\" href=\"#" + inTypeName + "\">" + inTypeName + "</a>"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  LLVM TYPE GENERATION                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @orderedTypeList {
  @PLMType mType
  @uint mIndex
}{
  mIndex <
}

#·······················································································································

proc declareLLVMTypes
  ?let @unifiedTypeMap inTypeMap
  ?let @uint inPointerSize
  ?!@generationAdds ioGenerationAdds
  ?!@string ioLLVMcode
{
#--- Build ordered list
  @orderedTypeList orderedTypeList = {}
  for (* type index) in inTypeMap do
    orderedTypeList += !type !index
  end
#--- Generate LLVM type declarations (using forward type is allowed for pointers)
  ioLLVMcode += llvmTitleComment (!"User Defined Types")
  ioLLVMcode += "%ptrtype = type i8* ; Generic pointer type for dynamic objects\n"
  @stringset generatedTypeSet = {}
  var llvmCodeForGeneratedTypes = ""
  for (type *) in orderedTypeList do
    if not [generatedTypeSet hasKey !type.llvmBaseTypeName] then
      generatedTypeSet += !type.llvmBaseTypeName
      switch type.kind
      case void :
      case boolean :
        generateBoolTypeLLVMCode (!?llvmCodeForGeneratedTypes)
      case enumeration (bitCount) :
        generateLLVMcodeForEnumeration (
          !?llvmCodeForGeneratedTypes
          !?ioGenerationAdds
          !type
          !bitCount
        )
      case integer (* * unsigned size) :
        generateLLVMCodeForIntegerType (
          !?llvmCodeForGeneratedTypes
          !?ioGenerationAdds
          !size
          !not unsigned
        )
      case structure (propertyList) :
        generateLLVMcodeForStructure (
          !?llvmCodeForGeneratedTypes
          !?ioGenerationAdds
          !type
          !inPointerSize
        )
        ioLLVMcode += [type llvmTypeName] + " = type {"
        for () in propertyList
          do ioLLVMcode += [mType llvmTypeName]
          between ioLLVMcode += ", "
        end
        ioLLVMcode += "}\n"
      case syncTool (propertyList) :
        ioLLVMcode += [type llvmTypeName] + " = type {"
        for () in propertyList
          do ioLLVMcode += [mType llvmTypeName]
          between ioLLVMcode += ", "
        end
        ioLLVMcode += "}\n"
      case literalString : 
        generateStaticStringTypeLLVMCode (!?llvmCodeForGeneratedTypes ![type llvmTypeName])
      case staticInteger : 
      case opaque (*) :
      case arrayType (elementType arraySize) :
        generateLLVMCodeForStaticArrayType (
          !?llvmCodeForGeneratedTypes
          !?ioGenerationAdds
          !type
          !arraySize
        )
        ioLLVMcode += [type llvmTypeName] + " = type [" + arraySize + " x " + [elementType llvmTypeName] + "]\n"
      case dynamicArrayType (@PLMType elementType) :
        generateLLVMcodeForDynamicArray (
          !?llvmCodeForGeneratedTypes
          !?ioGenerationAdds
          !type
          !elementType
          !type.plmTypeDescriptionName # !!!! Temporary
        )
      case function (*) :
      case pointer (unused pointee) :
      end
    end
  end
  ioLLVMcode += "\n"
  ioLLVMcode += llvmCodeForGeneratedTypes 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
