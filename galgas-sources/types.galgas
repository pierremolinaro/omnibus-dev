#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    P L M    T Y P E                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

boolset @PLMTypeAttributes {
  instanciable, equatable, copyable
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @constructorValue {
#  case zero
  case simple (@bigint value)
  case structure (@sortedOperandIRList sortedOperandList)
  case arrayValue (@PLMType elementType @uint size)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @constructorMap { # Key is (!selector!selector)
  @constructorSignature mSignature
  @constructorValue mInitValue
  insert insertKey error message "-- internal error --"
  search searchKey error message "-- internal error --"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @PLMType {
  @propertyMap mPropertyMap
  @typeKind mKind
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @typeKind {
  case void # No actual type, used for no annotation type, ...
  case boolean
  case literalString
  case enumeration (@constantMap constantMap @uint bitCount @string plmTypeName)
  case structure (@lstring typeName
                  @propertyList propertyList
                  @PLMTypeAttributes attributes
                  @guardMapForContext guardMap
                  @constructorMap constructorMap)
  case integer (@bigint min
                @bigint max
                @bool unsigned
                @uint bitCount
                @string plmTypeName)
  case staticInteger
  case opaque (@bigint bitCount @PLMTypeAttributes attributes @string plmTypeName @constructorMap constructorMap)
  case arrayType (@lstring typeName
                  @PLMType elementType
                  @bigint size
                  @constantMap constantMap
                  @PLMTypeAttributes flags
                  @string plmTypeName
                  @constructorMap constructorMap)
  case function (@routineDescriptor descriptor)
  case pointer (@PLMType pointee)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func booleanType -> @PLMType {
  result = .new {!{} !.boolean}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func staticIntegerType -> @PLMType {
  result = .new {!{} !.staticInteger}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func literalStringType -> @PLMType {
  result = .new {!{} !.literalString}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func voidType -> @PLMType {
  result = .new {!{} !.void}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func functionType ?let @routineDescriptor inDescriptor -> @PLMType {
  result = .new{!{} !.function {!descriptor:inDescriptor}}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType constructorMap -> @constructorMap {
  switch [self mKind]
  case void :
    result = {}
  case boolean :
    result = {}
  case literalString, staticInteger :
    result = {}
  case enumeration (* * *) :
    result = {}
  case structure (* * * * contructorMap) :
    result = contructorMap
  case integer (* * * * *) :
    result = {}
  case opaque (* * * contructorMap) :
    result = contructorMap
  case arrayType (* * * * * * contructorMap) :
    result = contructorMap
  case function (*) :
    result = {}
  case pointer (*) :
    result = {}
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @PLMType propertyMap -> @propertyMap {
#  switch [self mKind]
#  case void :
#    result = {}
#  case boolean :
#    result = {}
#  case literalString, staticInteger :
#    result = {}
#  case enumeration (* propertyMap * *) :
#    result = propertyMap
#  case structure (* propertyMap * * * *) :
#    result = propertyMap
#  case integer (propertyMap * * * * *) :
#    result = propertyMap
#  case opaque (* * * *) :
#    result = {}
#  case arrayType (* propertyMap * * * * * *) :
#    result = propertyMap
#  case function (*) :
#    result = {}
#  case pointer (*) :
#    result = {}
#  end  
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType equatable -> @bool {
  switch [self mKind]
  case void :
    result = true
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* * *) :
    result = true
  case structure (* * flags * *) :
    result = [flags equatable]
  case integer (* * * * *) :
    result = true
  case opaque (* flags * *) :
    result = [flags equatable]
  case arrayType (* * * * flags * *) :
    result = [flags equatable]
  case function (*) :
    result = false
  case pointer (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy instanciable -> @bool {
  result = [[self type] instanciable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType instanciable -> @bool {
  switch [self mKind]
  case void :
    result = true
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* * *) :
    result = true
  case structure (* * flags * *) :
    result = [flags instanciable]
  case integer (* * * * *) :
    result = true
  case opaque (* flags * *) :
    result = [flags instanciable]
  case arrayType (* * * * flags * *) :
    result = [flags instanciable]
  case function (*) :
    result = false
  case pointer (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy copyable -> @bool {
  result = [[self type] copyable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType copyable -> @bool {
  switch [self mKind]
  case void :
    result = true
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* * *) :
    result = true
  case structure (* * flags * *) :
    result = [flags copyable]
  case integer (* * * * *) :
    result = true
  case opaque (* flags * *) :
    result = [flags copyable]
  case arrayType (* * * * flags * *) :
    result = [flags copyable]
  case function (*) :
    result = false
  case pointer (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType classConstantMap -> @constantMap {
  switch [self mKind]
  case boolean, literalString, staticInteger, void :
    result = {}
  case enumeration (constantMap * *) :
    result = constantMap
  case structure (* * * * *) :
    result = {}
  case integer (* * * * *) :
    result = {}
  case opaque (* * * *) :
    result = {}
  case arrayType (* * * @constantMap constantMap * * *) :
    result = constantMap
  case function (*) :
    result = {}
  case pointer (*) :
    result = {}
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType llvmTypeName -> @string {
  switch [self mKind]
  case void :
    result = "void"
  case boolean :
    result = "i1"
  case literalString :
    result = "i8*"
  case enumeration (* @uint bitCount *) :
    result = "i" + bitCount
  case structure (@lstring typeName * * * *) :
    result = "%" + [llvmRegularTypeMangledNameFromName (!typeName) assemblerRepresentation]
  case integer (* * * @uint bitCount *) :
    result = "i" + bitCount
  case staticInteger :
    result = "—"
  case opaque (@bigint bitCount * * *) :
    result = "i" + bitCount
  case arrayType (@lstring typeName * * * * * *) :
    result = "%" + [typeName assemblerRepresentation]
  case function (@routineDescriptor descriptor) :
    if descriptor.mReturnTypeProxy == .null then
      result = "void"
    else
      result = [[descriptor.mReturnTypeProxy type] llvmTypeName]
    end
    result += "("
    for () in descriptor.mSignature 
    do
      result += [[mTypeProxy type] llvmTypeName]
      switch mFormalArgumentPassingMode
      case inputOutput, output : result += "*"
      case input :
      end
    between result += ", "
    end
    result += ")*"
  case pointer (pointee) :
    result = [pointee llvmTypeName] + "*"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType key -> @string {
  switch [self mKind]
  case void :
    result = "void"
  case boolean :
    result = boolTypeName ()
  case literalString :
    result = staticStringTypeName ()
  case enumeration (* * plmTypeName) :
    result = plmTypeName
  case structure (plmTypeName * * * *) :
    result = plmTypeName
  case integer (* * * * plmTypeName) :
    result = plmTypeName
  case staticInteger :
    result = staticIntegerTypeName ()
  case opaque (* * plmTypeName *) :
    result = plmTypeName
  case arrayType (* * * * * plmTypeName *) :
    result = plmTypeName
  case function (*) :
    error ["" nowhere] : "«internal error @PLMType key function»" : result
  case pointer (*) :
    error ["" nowhere] : "«internal error @PLMType key pointer»" : result
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @PLMType descriptionForHTMLFile -> @string {
  switch [self mKind]
  case void :
    result = "Void"
  case boolean :
    result = "Boolean"
  case literalString :
    result = "Literal String"
  case enumeration (* * *) :
    result = "Enumeration"
  case structure (* * * * *) :
    result = "Structure"
  case integer (* * @bool unsigned @uint bitCount *) :
    result = "Integer (" + bitCount + " bit" + if bitCount > 1 then "s" else "" end
           + ", " + if unsigned then "unsigned" else "signed" end + ")"
  case staticInteger :
    result = "Static Integer"
  case opaque (@bigint bitCount * * *) :
    result = "Opaque (" + bitCount + " bits)"
  case arrayType (* * * * * * *) :
    result = "Array"
  case function (*) :
    result = "Function"
  case pointer (pointee) :
    result = "Pointer to " + [pointee llvmTypeName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared map @unifiedTypeMap %selectors {
  @PLMType type
  @uint index

  insert insertType error message "the '%K' type is already declared in %L"
  search searchKey error message "there is no '%K' type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  BUILD TYPE MAP HTML FILE                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildTypeMapHTMLFile
  ?@unifiedTypeMap inTypeMap
  ?sourceFile:let @lstring inSourceFile
{
#------------------------------------ Build an HTML file that contains all types
  let @string typeDumpFilePath = inSourceFile.string + ".types.html"
  if [option plm_options.emitTypeMap value] then
    @stringset firstLetterSet = {}
    for () in inTypeMap do
      firstLetterSet += ![[lkey.string characterAtIndex!0] string]
    end
    @string tableOfTypeString = ""
    @char currentFirstLetter = ' '
    for () type_ in inTypeMap do
      if currentFirstLetter != [type_lkey.string characterAtIndex !0] then
        currentFirstLetter = [type_lkey.string characterAtIndex !0]
        tableOfTypeString += "<br><a name=\"" + [currentFirstLetter uint] + "\"><b>" + currentFirstLetter + "</b></a><br>"
      end
      tableOfTypeString += linkForHTMLTypeMap (!type_lkey.string) + "<br>"
    end
    let @string typeDumpString = [filewrapper typeDumpGenerationTemplate.dump
      ![inSourceFile lastPathComponent]
      !inTypeMap
      !firstLetterSet
      !tableOfTypeString
    ]
    [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*]
  else
    [@string deleteFileIfExists !typeDumpFilePath]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper typeDumpGenerationTemplate in "../generation-templates/" {
}{
}{
  template dump "typeDump.html.galgasTemplate"
    ?@string PROJECT_NAME
    ?@unifiedTypeMap GLOBAL_TYPE_MAP
    ?@stringset FIRST_LETTER_SET
    ?@string TABLE_OF_TYPES_STRING
}

#----------------------------------------------------------------------------------------------------------------------*

func linkForHTMLTypeMap ?let @string inTypeName -> @string {
  result = "<a class=\"header_link\" href=\"#" + inTypeName + "\">" + inTypeName + "</a>"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
