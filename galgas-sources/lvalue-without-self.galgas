#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @accessInAssignmentAST {
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @accessInAssignmentListAST {
  @accessInAssignmentAST mAccess
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @LValueWithoutSelfAST {
  @lstring mIdentifier
  @accessInAssignmentListAST mAccessList
}

#·······················································································································

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <lvalue_without_self> !@LValueWithoutSelfAST outAssignmentTargetAST {
  #--- Object
    $identifier$ ?let @lstring identifier
  #--- Properties and subscript
    @accessInAssignmentListAST accessList = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessList += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = .new {!identifier !accessList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueWithoutSelfAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @targetAccessKind {
  case read
  case write
  case readWrite
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueWithoutSelfAST analyzeLValueNoSelf
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
  if [ioVariableMap hasKey !mIdentifier] then
    switch inSelfAccessKind
    case read :
      [!?ioVariableMap searchForReadAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case write :
      [!?ioVariableMap searchForWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case readWrite :
      [!?ioVariableMap searchForReadWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    end
    outGlobalVariableReceiverName = if [outCurrentObject isGlobalVariableReference] then mIdentifier.string else "" end
  else # Stand alone function call ?
    outCurrentObject = .possibleFunction {!receiver:.null !functionName:mIdentifier}
    outGlobalVariableReceiverName = ""
  end
#--- Analyze properties, subscripts
  if [mAccessList length] == 0 then # 
    switch inSelfAccessKind
    case read :
      [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?outCurrentObject]
    case write :
      [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?outCurrentObject]
    case readWrite :
      [!?ioUniversalMap searchValuedObjectForReadWriteAccess !mIdentifier ?outCurrentObject]
    end
  else
    for (access) in mAccessList do
      switch access
      case property (propertyName) :
        handlePropertyAccessInAssignment (
          !?outCurrentObject
          !propertyName
          !?ioTemporaries
          !?ioInstructionGenerationList
        )
      case arrayAccess (indexExpression endOfExpression) :
        handleSubscriptInAssignmentAndExpression (
          !self:inSelfType
          !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
          !inGuard:false
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioVariableMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !indexExpression
          !endOfExpression
          !?ioInstructionGenerationList
          !?outCurrentObject
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handlePropertyAccessInAssignment
  ?!@objectIR ioObject
  ?let @lstring inPropertyName
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
{
  if [[ioObject type] isStructure] then
    [[ioObject type] structure
      ?typeName:*
      ?propertyMap:let structureObjectMap
      ?universalMap:let unused universalMap
      ?3*
    ]
    if [structureObjectMap hasKey !inPropertyName] then
      [structureObjectMap searchKey !inPropertyName ?* ?@objectIR property]
      if [property isProperty] then
       [property property ?type:let type ?plmName:let name ?index:let index]
        let newObject = @objectIR.temporaryReference {
          !type:type
          !llvmName:.new {!"temp." + ioTemporaries.mTemporaryIndex !inPropertyName}
          !sliceMap:{}
          !volatile:false
        }
        ioTemporaries.mTemporaryIndex ++
        [!?ioInstructionGenerationList appendGetPropertyReference
          !newObject
          !ioObject
          !name
          !index
        ]
        ioObject = newObject
      else
        error inPropertyName : "<<getNewTemporarySelfObjectPtr>>" : ioObject
      end
    else
      ioObject = .possibleFunction {!receiver:ioObject !functionName:inPropertyName}
    end
  else
    error inPropertyName : "the current object has no property" : ioObject
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @LValueWithoutSelfAST type
#  ?self:let @PLMType inSelfType
#  ?targetAccessKind:let @targetAccessKind inSelfAccessKind
#  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
#  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
#  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
#  ?context:let @semanticContext inContext
#  ?mode:let @mode inCurrentMode
#  -> @PLMType
#{
##--- object access, with ou without self
#  if [ioVariableMap hasKey !mIdentifier] then
#    switch inSelfAccessKind
#    case read :
#      [!?ioVariableMap searchForReadAccess !lkey:mIdentifier ?2* ?objectIR:currentObject ?2*]
#    case write :
#      [!?ioVariableMap searchForWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
#    case readWrite :
#      [!?ioVariableMap searchForReadWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
#    end
#    outGlobalVariableReceiverName = if [outCurrentObject isGlobalVariableReference] then mIdentifier.string else "" end
#  else # Stand alone function call ?
#    outCurrentObject = .possibleFunction {!receiver:.null !functionName:mIdentifier}
#    outGlobalVariableReceiverName = ""
#  end
##--- Analyze properties, subscripts
#  if [mAccessList length] == 0 then # 
#    switch inSelfAccessKind
#    case read :
#      [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?outCurrentObject]
#    case write :
#      [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?outCurrentObject]
#    case readWrite :
#      [!?ioUniversalMap searchValuedObjectForReadWriteAccess !mIdentifier ?outCurrentObject]
#    end
#  else
#    for (access) in mAccessList do
#      switch access
#      case property (propertyName) :
#        handlePropertyAccessInAssignment (
#          !?outCurrentObject
#          !propertyName
#          !?ioTemporaries
#          !?ioInstructionGenerationList
#        )
#      case arrayAccess (indexExpression endOfExpression) :
#        handleSubscriptInAssignmentAndExpression (
#          !self:inSelfType
#          !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
#          !inGuard:false
#          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#          !context:inContext
#          !mode:inCurrentMode
#          !?temporary:ioTemporaries
#          !?staticStringMap:ioGlobalLiteralStringMap
#          !?variableMap:ioVariableMap
#          !?variableMap:ioUniversalMap
#          !?alloca:ioAllocaList
#          !indexExpression
#          !endOfExpression
#          !?ioInstructionGenerationList
#          !?outCurrentObject
#        )
#      end
#    end
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
