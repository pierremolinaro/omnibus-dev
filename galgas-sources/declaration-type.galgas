#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @newTypeDeclaration : @abstractDeclarationAST {
  @lstring mNewTypeName
  @lstring mOriginalTypeName
}

#·······················································································································

override getter @newTypeDeclaration location -> @location outLocation {
  outLocation = mNewTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $newtype$
    $\$type$ ?let newTypeName
    $:$
    <type_definition> !?ioAST ?let typeName
    ioAST.mDeclarationListAST += !@newTypeDeclaration.new {!newTypeName !typeName}
  }

  #·····················································································································

  rule <type_definition> ?!@ast unused ioAST !@lstring outTypeName {
    $\$type$ ?outTypeName # Simple redéfinition de type
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @newTypeDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @newTypeDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let newTypeName = llvmTypeNameFromPLMname (!mNewTypeName)
  let originalTypeName = llvmTypeNameFromPLMname (!mOriginalTypeName)
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !originalTypeName]
}

#·······················································································································

override getter @newTypeDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "newtype $" + mNewTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @newTypeDeclaration enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#---------- Enter in type map
  [ioContext.mTypeMap searchKey !lkey:mOriginalTypeName ?type:var type ?1*]
#---------- Set new type name
  type.plmUserTypeName = mNewTypeName.string
#---------- Transform property map
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mOriginalTypeName ?let originalTypeProxy]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mNewTypeName ?let newTypeProxy]
  let oldPropertyMap = type.propertyMap
  type.propertyMap = {}
  @newTypeDecoratedMethodList newTypeDecoratedMethodList = {}
  for (propertyName public access) in oldPropertyMap do
    switch access 
    case constantProperty (*) :
      [!?type.propertyMap insertKey !propertyName !public !access]
    case indexed  (2*) :
      [!?type.propertyMap insertKey !propertyName !public !access]
    case nonVirtualMethod (@routineDescriptor oldDescriptor) :
      @routineTypedSignature newSignature = {}
      @routineFormalArgumentListAST newSignatureAST = {}
      for (formalArgumentPassingMode selector typeProxy) in oldDescriptor.signature do
        let t = if originalTypeProxy == typeProxy then newTypeProxy else typeProxy end
        newSignature += !formalArgumentPassingMode !selector !t
        newSignatureAST += !formalArgumentPassingMode !selector ![[t key] nowhere] !["" nowhere]
      end
      let newDescriptor = @routineDescriptor.new {
        !isPublic: oldDescriptor.isPublic
        !exported: oldDescriptor.exported
        !name: oldDescriptor.name
        !routineKind: oldDescriptor.routineKind
        !signature:newSignature
        !returnTypeProxy: if oldDescriptor.returnTypeProxy == newTypeProxy then newTypeProxy else oldDescriptor.returnTypeProxy end
        !canAccessProperties: oldDescriptor.canAccessProperties
        !canMutateProperties: oldDescriptor.canMutateProperties
        !safe: oldDescriptor.safe
      }
      [!?type.propertyMap insertKey !propertyName !public !.nonVirtualMethod {!descriptor:newDescriptor}]
      newTypeDecoratedMethodList += !newDescriptor !newSignatureAST
    #--- Enter in invocation graph
      let routineNameForInvocationGraph = routineMangledNameFromAST (
        !llvmTypeStringFromPLMname (!mNewTypeName)
        ![oldDescriptor.name nowhere]
        !newSignatureAST
      )
      [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
    end
  end
#---------- Enter in type map
  [!?ioContext.mTypeMap insertType !lkey:mNewTypeName !type:type !index:[ioContext.mTypeMap count]]
  ioDecoratedDeclarationList += !@newTypeDecoratedDeclaration.new {!newTypeProxy !newTypeDecoratedMethodList !originalTypeProxy}
#---------- Enter infix operators
  let newNewInfixKey = combineTypeNamesForInfixOperator (!mNewTypeName.string !mNewTypeName.string)
  let aliasAliasInfixKey = combineTypeNamesForInfixOperator (!mOriginalTypeName.string !mOriginalTypeName.string)
  let newLiteralIntegerInfixKey = combineTypeNamesForInfixOperator (!mNewTypeName.string !staticIntegerTypeName ())
  let aliasLiteralIntegerInfixKey = combineTypeNamesForInfixOperator (!mOriginalTypeName.string !staticIntegerTypeName ())
  let literalIntegerNewInfixKey = combineTypeNamesForInfixOperator (!staticIntegerTypeName ()!mNewTypeName.string)
  let literalIntegerAliasInfixKey = combineTypeNamesForInfixOperator (!staticIntegerTypeName ()!mOriginalTypeName.string)
  let newType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mNewTypeName} type]
  let oldType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mOriginalTypeName} type]
  enterNewTypeInfixOperator (
    !?ioContext.mEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mNonEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mStrictInfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mInfEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mStrictSupOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mSupEqualOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mAndOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mOrOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mXorOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mBooleanXorOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mAddOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mAddNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mSubOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
     !newType
    !oldType
 )
  enterNewTypeInfixOperator (
    !?ioContext.mSubNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mMulOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mMulNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mDivOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mDivNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mModOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mModNoOvfOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mLeftShiftOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypeInfixOperator (
    !?ioContext.mRightShiftOperatorMap
    !newNewInfixKey
    !aliasAliasInfixKey
    !newLiteralIntegerInfixKey
    !aliasLiteralIntegerInfixKey
    !literalIntegerNewInfixKey
    !literalIntegerAliasInfixKey
    !newType
    !oldType
  )
  enterNewTypePrefixOperator (!?ioContext.mUnaryMinusOperatorMap !mNewTypeName !mOriginalTypeName)
  enterNewTypePrefixOperator (!?ioContext.mNotOperatorMap !mNewTypeName !mOriginalTypeName)
  enterNewTypePrefixOperator (!?ioContext.mUnsignedComplementOperatorMap !mNewTypeName !mOriginalTypeName)
}

#·······················································································································

private proc enterNewTypePrefixOperator
  ?!@prefixOperatorMap ioInfixOperatorMap
  ?let @lstring inNewTypeName
  ?let @lstring inAliasedTypeName
{
  if [ioInfixOperatorMap hasKey !inAliasedTypeName.string] then
    [ioInfixOperatorMap searchKey
      !inAliasedTypeName
    ]
    [!?ioInfixOperatorMap insertKey
      !inNewTypeName
    ]
  end
}

#·······················································································································

private proc enterNewTypeInfixOperator
  ?!@infixOperatorMap ioInfixOperatorMap
  ?let @lstring inNewNewInfixKey
  ?let @lstring inAliasedAliasedInfixKey
  ?let @lstring inNewLiteralIntegerInfixKey
  ?let @lstring inAliasedLiteralIntegerInfixKey
  ?let @lstring inLiteralIntegerNewInfixKey
  ?let @lstring inLiteralIntegerAliasInfixKey
  ?let @PLMType inNewType
  ?let @PLMType inOldType
{
  if [ioInfixOperatorMap hasKey !inAliasedAliasedInfixKey.string] then
    [ioInfixOperatorMap searchKey
      !inAliasedAliasedInfixKey
      ?@PLMType resultType
      ?let @infixOperatorDescription operation
    ]
    if resultType == inOldType then
      resultType = inNewType
    end
    [!?ioInfixOperatorMap insertKey
      !inNewNewInfixKey
      !resultType
      !operation
    ]
  end
  if [ioInfixOperatorMap hasKey !inAliasedLiteralIntegerInfixKey.string] then
    [ioInfixOperatorMap searchKey
      !inAliasedLiteralIntegerInfixKey
      ?@PLMType resultType
      ?let @infixOperatorDescription operation
    ]
    if resultType == inOldType then
      resultType = inNewType
    end
    [!?ioInfixOperatorMap insertKey
      !inNewLiteralIntegerInfixKey
      !resultType
      !operation
    ]
  end
  if [ioInfixOperatorMap hasKey !inLiteralIntegerAliasInfixKey.string] then
    [ioInfixOperatorMap searchKey
      !inLiteralIntegerAliasInfixKey
      ?@PLMType resultType
      ?let @infixOperatorDescription operation
    ]
    if resultType == inOldType then
      resultType = inNewType
    end
    [!?ioInfixOperatorMap insertKey
      !inLiteralIntegerNewInfixKey
      !resultType
      !operation
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @newTypeDecoratedMethodList {
  @routineDescriptor mRoutineDescriptor
  @routineFormalArgumentListAST mFormalArgumentListAST
}

#·······················································································································

class @newTypeDecoratedDeclaration : @abstractDecoratedDeclaration {
  @unifiedTypeMap-proxy mNewTypeProxy
  @newTypeDecoratedMethodList mNewTypeDecoratedMethodList
  @unifiedTypeMap-proxy mOldTypeProxy
}

#·······················································································································

override method @newTypeDecoratedDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#----------- Generate enumeration specific code
  ioIntermediateCodeStruct.mGenerationListIR += !@newTypeIR.new {!mNewTypeProxy !mNewTypeDecoratedMethodList !mOldTypeProxy}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @newTypeIR : @abstractGenerationIR {
  @unifiedTypeMap-proxy mNewTypeProxy
  @newTypeDecoratedMethodList mNewTypeDecoratedMethodList
  @unifiedTypeMap-proxy mOldTypeProxy
}

#·······················································································································

override method @newTypeIR generateLLVMcode ?!@string ioLLVMcode ?!@generationAdds unused ioGenerationAdds {
  for (descriptor formalArgumentListAST) in mNewTypeDecoratedMethodList do
    let oldRoutineMangledName = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (![mOldTypeProxy type].plmUserTypeName)
      ![descriptor.name nowhere]
      !formalArgumentListAST
    )
    let oldRoutineLLVMName = llvmNameForFunction (!oldRoutineMangledName.string)
    let newRoutineMangledName = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (![mNewTypeProxy type].plmUserTypeName)
      ![descriptor.name nowhere]
      !formalArgumentListAST
    )
    let newRoutineLLVMName = llvmNameForFunction (!newRoutineMangledName.string)
    let returnTypeLLVMName = if descriptor.returnTypeProxy == .null then
      "void"
    else
      [[descriptor.returnTypeProxy type] llvmTypeName]
    end
    ioLLVMcode += llvmTitleComment (!newRoutineMangledName)
    ioLLVMcode += "define internal " + returnTypeLLVMName + " @" + newRoutineLLVMName + " ("
    var s = [[mNewTypeProxy type] llvmTypeName] + "* %receiver"
    for (formalArgumentPassingMode * typeProxy) in descriptor.signature do (idx)
      s += ", " + [[typeProxy type] llvmTypeName]
      switch formalArgumentPassingMode
      case input :
      case inputOutput, output :
        s += "*"
      end
      s += " %arg." + idx
    end
    ioLLVMcode +=  s + ")" + llvmAttributeFunction () + "{\n"
    if descriptor.returnTypeProxy == .null then
       ioLLVMcode += "  call void @"
    else
      ioLLVMcode += "  %result = call " + returnTypeLLVMName + " @"
    end
    ioLLVMcode += oldRoutineLLVMName + " (" + s + ")\n"
    if descriptor.returnTypeProxy == .null then
      ioLLVMcode += "  ret void\n"
    else
      ioLLVMcode += "  ret " + [[descriptor.returnTypeProxy type] llvmTypeName] + " %result\n"
    end
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
