#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @newTypeDeclaration : @abstractDeclarationAST {
  @lstring mAliasTypeName
  @lstring mOriginalTypeName
}

#·······················································································································

override getter @newTypeDeclaration location -> @location outLocation {
  outLocation = mAliasTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $typealias$
    $\$type$ ?let newTypeName
    $:$
    <type_definition> !?ioAST ?let typeName
    ioAST.mDeclarationListAST += !@newTypeDeclaration.new {!newTypeName !typeName}
  }

  #·····················································································································

  rule <type_definition> ?!@ast unused ioAST !@lstring outTypeName {
    $\$type$ ?outTypeName # Simple redéfinition de type
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @newTypeDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @newTypeDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let newTypeName = llvmTypeNameFromPLMname (!mAliasTypeName)
  let originalTypeName = llvmTypeNameFromPLMname (!mOriginalTypeName)
  [!?ioGraph addNode !newTypeName !self]
  [!?ioGraph addEdge !newTypeName !originalTypeName]
}

#·······················································································································

override getter @newTypeDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "typealias $" + mAliasTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @newTypeDeclaration enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
{
#---------- Enter in type map
  [ioContext.mTypeMap searchKey !lkey:mOriginalTypeName ?type:var type ?1*]
#---------- Set alias type name
  type.plmAliasedTypeName = mAliasTypeName.string
  type.attributes = type.attributes - .generateAssignmentRoutine
#---------- Enter in type map
  [!?ioContext.mTypeMap insertType !lkey:mAliasTypeName !type:type !index:[ioContext.mTypeMap count]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
