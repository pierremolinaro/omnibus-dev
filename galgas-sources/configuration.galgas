#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @interruptionPanicCode {
  case noCode
  case code (@lbigint value)
}

#·······················································································································

list @interruptionConfigurationList {
  @lstring mInterruptName
  @interruptionPanicCode mInterruptionPanicCode
}

#·······················································································································

enum @sectionImplementationScheme {
  case none
  case svc (@lbigint sectionPushedRegisterByteSize 
            @lstring sectionHandler
            @lstring sectionDispatcherEntry
            @lstring sectionDispatcherHeader
            @lstring sectionDispatcherInvocation)
  case function (@string disableInterruptInLLVM @string enableInterruptInLLVM)
  default none
}

#·······················································································································

getter @sectionImplementationScheme sectionStackByteSize -> @bigint {
  switch self
  case svc (sectionPushedRegisterByteSize * * * *) : result = sectionPushedRegisterByteSize.bigint
  case function (* *) : result = 0G
  case none: result = 0G
  end
}

#·······················································································································

struct @targetParameters {
  @2lstringlist mPython_utilityToolList
  @lstring mPython_build
  @lstring mTargetPanic_LL_filePath
  @lstring mLinkerScript
  @lbigint mPointerSize
  @lbigint mSystemStackSize
  @lbigint mStackedUserRegisterOnInterruptByteSize

  @lstring mNopInstructionStringInLLVM

  @lstring mServiceHandler
  @lbigint mServicePushedRegisterByteSize

  @sectionImplementationScheme mSectionImplementation

  @lstringlist m_C_definitionFiles
  @lstringlist m_S_definitionFiles
  @lstringlist m_LL_definitionFiles
  
  @lstring mXtrInterruptHandler
  @lstring mUndefinedInterruptHandler
  
  @lstring mServiceDispatcherEntry
  @lstring mServiceDispatcherHeader
  @lstring mServiceEntry
}

#·······················································································································

class @configurationDeclarationAST : @abstractDeclarationAST {
  @lstring mPanicCodeTypeName
  @lstring mPanicLineTypeName
  @targetParameters mTargetParameters
  @interruptionConfigurationList mInterruptionConfigurationList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_target_specific_syntax {

  #·····················································································································

  rule <key> ?let @string inKey {
    $identifier$ ?let key
    if key.string != inKey then
      error key : "invalid key" fixit { replace inKey }
    end
    $:$
  }

  #·····················································································································

  rule <python_utility_tool_list> !@2lstringlist outPythonUtilityToolList {
    <key> !"PYTHON_UTILITIES"
    outPythonUtilityToolList = {}
    select
    or
      repeat
        $"string"$ ?let relativePath
        $->$
        $"string"$ ?let destinationFile
        outPythonUtilityToolList += !relativePath !destinationFile
      while
        $,$
      end
    end
  }

  #·····················································································································

  rule <section_specification> !@sectionImplementationScheme outSectionImplementation {
    <key> !"SECTION"
    select
      $"string"$ ?let sectionHandler
      $;$
      $integer$ ?let sectionPushedRegisterByteSize
      $;$
      $"string"$ ?let sectionDispatcherHeader
      $;$
      $"string"$ ?let sectionDispatcherEntry
      $;$
      $"string"$ ?let sectionDispatcherInvocation
      outSectionImplementation = .svc{
        !sectionPushedRegisterByteSize:sectionPushedRegisterByteSize
        !sectionHandler:sectionHandler
        !sectionDispatcherEntry:sectionDispatcherEntry
        !sectionDispatcherHeader:sectionDispatcherHeader
        !sectionDispatcherInvocation:sectionDispatcherInvocation
      }
    or
      $"string"$ ?let sectionDisableInterrupt
      $;$
      $"string"$ ?let sectionEnableInterrupt
      outSectionImplementation = .function {
        !disableInterruptInLLVM:sectionDisableInterrupt
        !enableInterruptInLLVM:sectionEnableInterrupt
      }    
    end
  }

  #·····················································································································

  rule <configuration_start_symbol>
    ?!@ast ioAST
    !importClauseList:@lstringlist outImportedFileList
    !endOfSourceFile:@location outEndOfSourceFile
  {
    <python_utility_tool_list> ?let python_utilityToolList
    <key> !"PYTHON_BUILD"
    $"string"$ ?let python_build
    <key> !"LINKER_SCRIPT"
    $"string"$ ?let linkerScript
    <key> !"PANIC"
    $\$type$ ?let panicCodeTypeName 
    $;$
    $\$type$ ?let panicLineTypeName
    $;$
    $"string"$ ?let targetPanic_LL_filePath
    <key> !"POINTER_BIT_COUNT"
    $integer$ ?let pointerSize
    <key> !"SYSTEM_STACK_SIZE"
    $integer$ ?let systemStackSize
    <key> !"NOP"
    $"string"$ ?let nopInstructionStringInLLVM
    <key> !"SERVICE"
    $"string"$ ?let serviceHandler
    $;$
    $integer$ ?let servicePushedRegisterByteSize
    $;$
    $"string"$ ?let serviceDispatcherHeader
    $;$
    $"string"$ ?let serviceDispatcherEntry
    $;$
    $"string"$ ?let serviceEntry
    <section_specification> ?let sectionImplementation
    <key> !"C_FILES"
    @lstringlist C_definitionFiles = {}
    repeat
      $"string"$ ?let fileRelativePath
      C_definitionFiles += !fileRelativePath
    while
      $,$
    end
    <key> !"S_FILES"
    @lstringlist S_definitionFiles = {}
    repeat
      $"string"$ ?let fileRelativePath
      S_definitionFiles += !fileRelativePath
    while
      $,$
    end
    <key> !"LL_FILES"
    @lstringlist LL_definitionFiles = {}
    repeat
      $"string"$ ?let fileRelativePath
      LL_definitionFiles += !fileRelativePath
    while
      $,$
    end
    outImportedFileList = {}
    <key> !"PLM_FILES"
    select
    or
      repeat
        $"string"$ ?let relativeFilePath
        outImportedFileList += !relativeFilePath
      while
        $,$
      end
    end
    <key> !"INTERRUPT_HANDLER"
    $"string"$ ?let xtrInterruptHandler
    $;$
    $integer$ ?let stackedUserRegisterOnInterruptByteSize
    $;$
    $"string"$ ?let undefinedInterruptHandler
    <interruptConfigList> ?let interruptionConfigurationList ?let interruptConstantList
     let parameters = @targetParameters.new {
      !python_utilityToolList
      !python_build
      !targetPanic_LL_filePath
      !linkerScript
      !pointerSize
      !systemStackSize
      !stackedUserRegisterOnInterruptByteSize
      !nopInstructionStringInLLVM
      !serviceHandler
      !servicePushedRegisterByteSize
      !sectionImplementation
      !C_definitionFiles
      !S_definitionFiles
      !LL_definitionFiles
      !xtrInterruptHandler
      !undefinedInterruptHandler
      !serviceDispatcherEntry
      !serviceDispatcherHeader
      !serviceEntry
    }
   ioAST.mDeclarationListAST += !@configurationDeclarationAST.new {
      !panicCodeTypeName
      !panicLineTypeName
      !parameters
      !interruptionConfigurationList
    }
    outEndOfSourceFile = .here
    ioAST.mDeclarationListAST += !@enumerationDeclaration.new {
      !.new {!isrSlotTypeName () !xtrInterruptHandler.location}
      !interruptConstantList
    }
  }

 #·····················································································································

  rule <interruptConfigList>
    !@interruptionConfigurationList interruptionConfigurationList
    !@enumerationConstantList outEnumerationConstantList
  {
    interruptionConfigurationList = {}
    outEnumerationConstantList = {}
    <key> !"INTERRUPTS"
    select
    or
      repeat
        $identifier$ ?let interruptName
        @interruptionPanicCode interruptionPanicCode
        select
          interruptionPanicCode = .noCode
        or
          $->$
          $integer$ ?let panicCode
          interruptionPanicCode = .code {!value:panicCode}
          outEnumerationConstantList += !interruptName !panicCode
        end
        interruptionConfigurationList += !interruptName !interruptionPanicCode
      while
        $,$
      end
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @configurationDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once configurationNodeNameForPrecedenceGraph -> @string {
  result = "config"
}

#·······················································································································

func %once isrSlotTypeName -> @string {
  result = "isrSlot"
}

#·······················································································································

override method @configurationDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let rootNode =  @lstring.new {!configurationNodeNameForPrecedenceGraph () !mPanicCodeTypeName.location}
  [!?ioGraph addNode !rootNode !self]
  let panicCodeTypeName = llvmRegularTypeMangledNameFromName (!mPanicCodeTypeName)
  [!?ioGraph addEdge !rootNode !panicCodeTypeName]
  let panicLineTypeName = llvmRegularTypeMangledNameFromName (!mPanicLineTypeName)
  [!?ioGraph addEdge !rootNode !panicLineTypeName]
}

#·······················································································································

override getter @configurationDeclarationAST location -> @location outLocation {
  outLocation = mPanicCodeTypeName.location
}

#·······················································································································

override getter @configurationDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = configurationNodeNameForPrecedenceGraph ()
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# Duplicate configuration is detected in noteTypesInPrecedenceGraph

override method @configurationDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  if ioContext.mPointerSize != 0 then
    error mTargetParameters.mPointerSize : "duplicate configuration"
  elsif mTargetParameters.mPointerSize.bigint == 0G then
    error mTargetParameters.mPointerSize : "zero size pointer not allowed"
  else
    ioContext.mPointerSize = [mTargetParameters.mPointerSize.bigint uint]
  end
  ioContext.mTargetParameters = mTargetParameters
#--- Panic code type
  ioContext.mPanicCodeType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mPanicCodeTypeName}
  if [[[ioContext.mPanicCodeType type] mKind] isInteger] then
    [[[ioContext.mPanicCodeType type] mKind] integer ?2* ?unsigned:let unsigned ?2*]
    if not unsigned then
      error mPanicCodeTypeName : "this type should be an unsigned integer type"
    end
  else
    error mPanicCodeTypeName : "this type should be an unsigned integer type"
  end
#--- Panic line type
  ioContext.mPanicLineType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mPanicLineTypeName}
  if [[[ioContext.mPanicLineType type] mKind] isInteger] then
    [[[ioContext.mPanicLineType type] mKind] integer ?2* ?unsigned:let unsigned ?2*]
    if not unsigned then
      error mPanicLineTypeName : "this type should be an unsigned integer type"
    end
  else
    error mPanicLineTypeName : "this type should be an unsigned integer type"
  end
#--------------------------------- Interrupt panic codes
  @stringset panicCodeSet = {}
  for (name panicCode) in mInterruptionConfigurationList do
    [!?ioContext.mAvailableInterruptMap insertKey !name !panicCode]
    switch panicCode
    case noCode :
    case code (value) :
      let s = [value.bigint string]
      if [panicCodeSet hasKey !s] then
        error value : "duplicate interrupt code"
      end
      panicCodeSet += !s
    end
  end
#--------------------------------- Generate @isrSlot enumeration
#  if hasInterruptCode && ok then
#    @constantMap enumConstantMap = {}
#    let isrSlotTypeName = isrSlotTypeName ()
#    for (interruptName interruptCode) in mInterruptionConfigurationList do
#      switch interruptCode
#      case noCode :
#      case code (@lbigint value) :
#        [!?enumConstantMap insertKey !interruptName !value.bigint !isrSlotTypeName]
#      end
#    end
#    [!?ioContext.mTypeMap insertType
#      !lkey:isrSlotTypeName
#      !type:.enumeration {!constantMap:enumConstantMap !plmTypeName:isrSlotTypeName}
#      !index:[ioContext.mTypeMap count]
#    ]
#  #--- Infix operators
#    enterEnumerationComparisonOperators (!typeName:isrSlotTypeName !?context:ioContext)
#  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @configurationDeclarationAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @configurationDeclarationAST generateLLVMcode ?!@string unused ioLLVMcode {
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
