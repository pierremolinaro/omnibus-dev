#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @interruptionPanicCode {
  case noPanicCode
  case panicCode (@lbigint value)
}

#·······················································································································

list @interruptionConfigurationList {
  @lstring mInterruptName
  @interruptionPanicCode mInterruptionPanicCode
}

#·······················································································································

struct @targetParameters {
  @lbigint mSystemStackSize
  @lbigint mStackedUserRegisterOnInterruptByteSize
  @lbigint mServicePushedRegisterByteSize
  @lbigint mSectionPushedRegisterByteSize
}

#·······················································································································

list @configurationDeclarationList {
  @lbigint mPointerSize
  @lstring mPanicCodeTypeName
  @lstring mPanicLineTypeName
  @targetParameters mTargetParameters
  @interruptionConfigurationList mInterruptionConfigurationList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_target_specific_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $configuration$
    $integer$ ?let pointerSize
    $:$
    $typeName$ ?let panicCodeTypeName 
    $:$
    $typeName$ ?let panicLineTypeName
    $:$
    $integer$ ?let systemStackSize
    $:$
    $integer$ ?let stackedUserRegisterOnInterruptByteSize
    $:$
    $integer$ ?let servicePushedRegisterByteSize
    $:$
    $integer$ ?let sectionPushedRegisterByteSize
    ${$
    let parameters = @targetParameters.new {
      !systemStackSize
      !stackedUserRegisterOnInterruptByteSize
      !servicePushedRegisterByteSize
      !sectionPushedRegisterByteSize
    }
    @interruptionConfigurationList interruptionConfigurationList = {}
    repeat
    while
      $identifier$ ?let interruptName
      @interruptionPanicCode interruptionPanicCode
      select
        interruptionPanicCode = .noPanicCode
      or
        $:$
        $integer$ ?let panicCode
        interruptionPanicCode = .panicCode {!value:panicCode}
      end
      interruptionConfigurationList += !interruptName !interruptionPanicCode
    end
    $}$
    ioAST.mConfigurationDeclarationList +=
      !pointerSize
      !panicCodeTypeName
      !panicLineTypeName
      !parameters
      !interruptionConfigurationList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @configurationDeclarationList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  var first = true
  for config in self do
    if first then
      first = false
      let panicCodeTypeName = @lstring.new {!"$" + config.mPanicCodeTypeName !config.mPanicCodeTypeName.location}
      [!?ioGraph noteNode !panicCodeTypeName]
      let panicLineTypeName = @lstring.new {!"$" + config.mPanicLineTypeName !config.mPanicLineTypeName.location}
      [!?ioGraph noteNode !panicLineTypeName]
    else
      error config.mPointerSize : "duplicate configuration"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# Duplicate configuration is detected in noteTypesInPrecedenceGraph

method @configurationDeclarationList enterInContext ?!context:@semanticContext ioContext {
  @stringset panicCodeSet = {}
  for config in self do
    if config.mPointerSize.bigint == 0G then
      error config.mPointerSize : "zero size pointer not allowed"
    else
      ioContext.mPointerSize = [config.mPointerSize.bigint uint]
    end
    ioContext.mTargetParameters = config.mTargetParameters
    ioContext.mPanicCodeType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !config.mPanicCodeTypeName}
    ioContext.mPanicLineType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !config.mPanicLineTypeName}
    for (name panicCode) in config.mInterruptionConfigurationList do
      [!?ioContext.mAvailableInterruptMap insertKey !name !panicCode]
      switch panicCode
      case noPanicCode :
      case panicCode (value) :
        let s = [value.bigint string]
        if [panicCodeSet hasKey !s] then
          error value : "duplicate panic code"
        end
        panicCodeSet += !s
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
