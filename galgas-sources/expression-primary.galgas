#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @primaryInExpressionAccessAST {
  case property (@lstring name)
  case integerSlice (@lbigint low @lbigint high)
  case arrayAccess (@expressionAST index @location endOfIndex)
  case funcCall (@lstring methodName @effectiveArgumentListAST arguments @location endOfArguments)
}

#·······················································································································

list @primaryInExpressionAccessListAST {
  @primaryInExpressionAccessAST mAccess
}

#·······················································································································

class @primaryInExpressionAST : @expressionAST {
  @lstring mReceiverName
  @primaryInExpressionAccessListAST mAccessList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    @lstring receiver
  #--- Self or identifier ?
    select
      $identifier$ ?receiver
    or
      $self$
      receiver = ["" here]
    end
  #--- Properties and access
    <expression_access_list> !?ioAST ?let accessList
  #--- AST
    outExpression = @primaryInExpressionAST.new {!receiver !accessList}
  }

  #·····················································································································

  rule <expression_access_list> ?!@ast ioAST !@primaryInExpressionAccessListAST outAccessList {
     outAccessList = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      outAccessList += !.property {!name:propertyName}
    while
      $[$
      $integer$ ?let low
      $...$
      $integer$ ?let high
      $]$
      outAccessList += !.integerSlice {!low:low !high:high}
    while
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      outAccessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    while
      $.$
      $identifier$ ?let methodName
      <effective_parameters> !?ioAST ?let arguments ?let endOfArguments
      outAccessList += !.funcCall {!methodName:methodName !arguments:arguments !endOfArguments:endOfArguments}
    end
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  if mReceiverName.string != "" then
    [!?ioGraph addEdge !inConstantName !mReceiverName]
  end
  for (access) in mAccessList do
    switch access
    case integerSlice (2*) :
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !typeName]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case integerSlice (@lbigint low @lbigint high) :
      if high.bigint >= low.bigint then
        [!?ioGraph noteUINTType ![high.bigint - low.bigint + 1G uint] !low.location]
      end
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !typeName]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with ou without self
  if mReceiverName.string != "" then
    if [inRoutineAttributes guard] then
      error mReceiverName : "in guard, only 'self' properties may be accessed" : outResult
    else 
      [self analyzePrimaryExpressionNoSelf
        !self: inSelfType
        !routineAttributes:inRoutineAttributes
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        ?result: outResult
      ]
    end
  elsif inSelfType.kind == .void then
    error mReceiverName : "'self' is not available in this context" : outResult
  else
    [self analyzePrimaryExpressionWithSelf
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      ?result: outResult
    ]
  end
}

#·······················································································································

method @primaryInExpressionAST analyzePrimaryExpressionNoSelf
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [ioUniversalMap searchEntity !mReceiverName ?let entity]
  switch entity
  case task (type) :
    outResult = .reference {!type: type !llvmName:llvmNameForGlobalVariable (!mReceiverName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case driver (type instancied) :
    if not instancied then
      error mReceiverName : "the driver should be instancied"
    end
    outResult = .reference {!type: type !llvmName:llvmNameForGlobalVariable (!mReceiverName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case registerGroup (2*) :
    error mReceiverName : "control register is not accessible in this context" : outResult
  case globalConstant (@objectIR objectIR) :
    outResult = objectIR
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case localConstant (@PLMType type @lstring plmName *) :
    [!?ioUniversalMap readAccess !mReceiverName]
    outResult = .reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case localVariable (@PLMType type @lstring plmName) :
    outResult = .reference {!type: type !llvmName:llvmNameForLocalVariable (!plmName)}
    [!?ioUniversalMap readAccess !mReceiverName]
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case globalSyncInstance (@PLMType type @lstring plmName) :
    outResult = .reference {!type: type !llvmName:llvmNameForGlobalSyncInstance (!plmName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  end
}

#·······················································································································

proc procAnalyzeAccesListInExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @primaryInExpressionAccessListAST inAccessList
  ?!result:@objectIR ioResult
{
#--- Access list
  for (access) in inAccessList do
    switch access
    case integerSlice (@lbigint low @lbigint high) :
      handleSliceInExpression (
        !context: inContext
        !?ioResult
        !low
        !high
        !?temporary: ioTemporaries
        !?instructionListIR: ioInstructionGenerationList
      )
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?ioResult
        !propertyName
        !?temporary:ioTemporaries
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?ioResult
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !routineAttributes:inRoutineAttributes
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inMode
        !?temporary:ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@lstring methodName @effectiveArgumentListAST arguments @location errorLocation) :
      if [inRoutineAttributes guard] then
        error errorLocation : "a method cannot be called in guard" : ioResult
      else
        handleFunctionCallInExpression (
          !methodName
          !?ioResult
          !self:inSelfType
          !context:inContext
          !mode:inMode
          !routineAttributes:inRoutineAttributes
          !?temporary:ioTemporaries
          !?staticEntityMap:ioStaticEntityMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !arguments 
          !?ioInstructionGenerationList
        )
      end
    end
  end
}

#·······················································································································

method @primaryInExpressionAST analyzePrimaryExpressionWithSelf
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with self
  outResult = .reference {!type:inSelfType !llvmName:llvmNameForSelf ()}
#--- Access list
  for (access) in mAccessList do
    switch access
    case integerSlice (@lbigint low @lbigint high) :
      handleSliceInExpression (
        !context: inContext
        !?outResult
        !low
        !high
        !?temporary: ioTemporaries
        !?instructionListIR: ioInstructionGenerationList
      )
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?outResult
        !propertyName
        !?temporary:ioTemporaries
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?outResult
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !routineAttributes:inRoutineAttributes
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inMode
        !?temporary:ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@lstring methodName @effectiveArgumentListAST arguments @location errorLocation) :
      if [inRoutineAttributes guard] then
        error errorLocation : "a method cannot be called in guard" : outResult
      else
        handleFunctionCallInExpression (
          !methodName
          !?outResult
          !self:inSelfType
          !context:inContext
          !mode:inMode
          !routineAttributes:inRoutineAttributes
          !?temporary:ioTemporaries
          !?staticEntityMap:ioStaticEntityMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !arguments 
          !?ioInstructionGenerationList
        )
      end
    end
  end
}

#·······················································································································

proc handleSliceInExpression
  ?context:let @semanticContext inContext
  ?!@objectIR ioResult
  ?let @lbigint inLow
  ?let @lbigint inHigh
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  if inLow.bigint > inHigh.bigint then
    error inLow : "low bound should be lower or equal to high bound" : ioResult
  elsif not ([[ioResult type].kind isInteger] || [[ioResult type].kind isStaticInteger]) then
    error inLow : "Invalid, receiver is not an integer" : ioResult
  else
  #--- Shift source value
    [!?ioInstructionGenerationList appendLogicalShiftRight !?ioResult ![inLow.bigint uint] !?ioTemporaries]
  #--- Truncate source value
    let resultIntegerName = @lstring.new {!"$uint" + (inHigh.bigint - inLow.bigint + 1G) !inLow.location}
    [inContext.mTypeMap searchKey !lkey:resultIntegerName ?type:let sliceType ?2*]
    [!?ioInstructionGenerationList appendTrunc !sliceType !?ioResult !?ioTemporaries]
  end
}

#·······················································································································

proc handlePropertyAccessInExpression
  ?!@objectIR ioResult
  ?let @lstring inPropertyName
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  let type = [ioResult type]
  let @propertyMap propertyMap = type.propertyMap
  [propertyMap searchKey !inPropertyName ?* ?let @propertyAccessKind accessKind]
  switch accessKind
  case nonVirtualMethod (*) :
    error inPropertyName : "a method cannot be used in this context" : ioResult
  case constantProperty (@objectIR value) :
    ioResult = value
  case singleton  (object *) :
    ioResult = object
  case indexed (@PLMType propertyType @uint propertyIndex) :
    [!?ioTemporaries newTempLLVMVar ?let property_llvmName]
    [!?ioInstructionGenerationList appendGetUniversalPropertyReference
      ![ioResult type]
      ![ioResult llvmName]
      !property_llvmName
      !propertyIndex
      !inPropertyName
    ]
    ioResult = .reference {!type:propertyType !llvmName:property_llvmName}
  end
}

#·······················································································································

private proc handleArrayAccessInExpression
  ?!@objectIR ioResult
  ?let @expressionAST inIndexExpression
  ?let @location inEndOfIndex
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Check current object is an array
  if [[ioResult type].kind isArrayType] then
    [[ioResult type].kind arrayType ?elementType:let elementType ?size:let @bigint arraySize]
    handleArraySubscriptNew (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !inIndexExpression 
      !inEndOfIndex
      !arraySize:arraySize
      !elementType:elementType
      !?ioInstructionGenerationList
      ?let @objectIR indexIR
    )
    [!?ioInstructionGenerationList appendGetArrayElementReference
      !?temporary: ioTemporaries
      !arrayReference:ioResult
      !index:indexIR
      ?elementPtr:let result
    ]
    ioResult = result      
  else
    error inEndOfIndex : "the receiver is not an array and does not accept subscripting"
  end
}

#·······················································································································

private proc handleFunctionCallInExpression
  ?let @lstring inMethodName
  ?!@objectIR ioObjectIR
  ?self:let @PLMType inSelfType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments 
  ?!@instructionListIR ioInstructionGenerationList
{
  let receiverType = [ioObjectIR type]
#--- Searck routine in receiver type routine map
  let @routineMapCTXT routineMap = [receiverType routineMap]
  let methodMangledName = [inArguments mangledName !inMethodName]
  [routineMap searchKey
    !methodMangledName
    ?let unused implementedPublic
    ?let formalSignature
    ?let formalReturnTypeProxy # null if no returned value
    ?let implementedModeDictionary
    ?let implementedIsSafe
    ?let unused implementedIsExported
    ?let unused implementedMode
  ]
#--- Check modes
  @string functionLLVMName
  if [implementedModeDictionary hasKey !inMode] then
    [implementedModeDictionary searchKey !inMode ?functionLLVMName]
  elsif [implementedModeDictionary hasKey !.anyMode] then
    [implementedModeDictionary searchKey !.anyMode ?functionLLVMName]
  else
    error inMethodName : "this function cannot be invoked in " + inMode + " mode" : functionLLVMName
  end
#--- Check safety
  if not [inRoutineAttributes panicAllowed] && not implementedIsSafe then
    error inMethodName : "an unsafe routine cannot call a safe routine"
  end
#--- Check routine is actually a function
  if [formalReturnTypeProxy type].kind == .void then
    error inMethodName : "not a function (returns no value)" : ioObjectIR
  else
  #--- If receiver is a value, create a reference
    [!?ioInstructionGenerationList referenceFromPossibleValue !?ioTemporaries !?ioAllocaList !?ioObjectIR]
  #--- Add receiver as first parameter
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    effectiveParameterListIR += !.outputInput !ioObjectIR # Add receiver as first argument
  #--- Analyze effective parameters
    analyzeEffectiveParameters (
      !self:inSelfType
      !routineAttributes:inRoutineAttributes
      !formal:formalSignature
      !effective:inArguments
      !errorLocation:inMethodName.location
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempValue (![formalReturnTypeProxy type] !?ioTemporaries ?let callReturnedResult)
  #--- Generate call
    let routineMangledName = routineMangledNameFromCall (![ioObjectIR type].llvmBaseTypeName !inMethodName !inArguments)
    ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
      !callReturnedResult
      !routineMangledName
      !functionLLVMName
      !effectiveParameterListIR
    }
  #---
    ioObjectIR = callReturnedResult
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
