#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @primaryInExpressionAccessAST {
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
  case funcCall (@lstring methodName @effectiveArgumentListAST arguments @location endOfArguments)
}

#·······················································································································

list @primaryInExpressionAccessListAST {
  @primaryInExpressionAccessAST mAccess
}

#·······················································································································

class @primaryInExpressionAST : @expressionAST {
  @lstring mReceiverName
  @primaryInExpressionAccessListAST mAccessList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    @lstring receiver
  #--- Self or identifier ?
    select
      $identifier$ ?receiver
    or
      $self$
      receiver = ["" here]
    end
  #--- Properties and access
    <expression_access_list> ?let accessList
  #--- AST
    outExpression = @primaryInExpressionAST.new {!receiver !accessList}
  }

  #·····················································································································

  rule <expression_access_list> !@primaryInExpressionAccessListAST outAccessList {
     outAccessList = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      outAccessList += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      outAccessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    while
      $.$
      $identifier$ ?let methodName
      <effective_parameters> ?let arguments ?let endOfArguments
      outAccessList += !.funcCall {!methodName:methodName !arguments:arguments !endOfArguments:endOfArguments}
    end
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  if mReceiverName.string != "" then
    [!?ioGraph addEdge !inConstantName !mReceiverName]
  end
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (* @effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmTypeNameFromPLMname (!typeName)]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with ou without self
  if mReceiverName.string != "" then
    if inGuard then
      error mReceiverName : "in guard, only 'self' properties may be accessed" : outResult
    else 
      [self analyzePrimaryExpressionNoSelf
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        ?result: outResult
      ]
    end
  elsif inSelfType.kind == .void then
    error mReceiverName : "'self' is not available in this context" : outResult
  else
    [self analyzePrimaryExpressionWithSelf
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      ?result: outResult
    ]
  end
}

#·······················································································································

method @primaryInExpressionAST analyzePrimaryExpressionNoSelf
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  [ioUniversalMap searchEntity !mReceiverName ?let entity]
  switch entity
  case module (type instancied) :
    if not instancied then
      error mReceiverName : "the module should be instancied"
    end
    outResult = .reference {!type: type !llvmName:llvmNameForGlobalVariable (!mReceiverName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case register (readable * type address sliceMap arraySize elementSize) :
    if not readable then
      error mReceiverName : "control register is not readable in this context" : outResult
    elsif inGuard then
      error mReceiverName : "control register is not readable in guard" : outResult
    else
      analyzeRegisterExpression (
        !self: inSelfType
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !type
        !address
        !sliceMap
        !arraySize # 0 if not an array
        !elementSize # 0 if not an array
        !mAccessList
        ?result: outResult
      )
    end
  case globalConstant (@objectIR objectIR) :
    outResult = objectIR
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case localConstant (@PLMType type @lstring plmName) :
    [!?ioUniversalMap readAccess !mReceiverName]
    outResult = .reference {!type:type !llvmName:llvmNameForLocalVariable (!plmName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case globalVariable (* @PLMType type) :
    [!?ioInstructionGenerationList appendNoteGlobalVariableAccess !mReceiverName]
    [!?ioUniversalMap readAccess !mReceiverName]
    outResult = .reference {!type: type !llvmName:llvmNameForGlobalVariable (!mReceiverName)}
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  case localVariable (@PLMType type @lstring plmName) :
    outResult = .reference {!type: type !llvmName:llvmNameForLocalVariable (!plmName)}
    [!?ioUniversalMap readAccess !mReceiverName]
    procAnalyzeAccesListInExpression (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !?result: outResult
    )
  end
}

#·······················································································································

proc procAnalyzeAccesListInExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @primaryInExpressionAccessListAST inAccessList
  ?!result:@objectIR ioResult
{
#--- Access list
  for (access) in inAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?ioResult
        !propertyName
        !?temporary:ioTemporaries
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?ioResult
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@lstring methodName @effectiveArgumentListAST arguments @location errorLocation) :
      if inGuard then
        error errorLocation : "a method cannot be called in guard" : ioResult
      else
        handleFunctionCallInExpression (
          !methodName
          !?ioResult
          !self:inSelfType
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !arguments 
          !?ioInstructionGenerationList
        )
      end
    end
  end
}

#·······················································································································

private proc analyzeRegisterExpression
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @PLMType inRegisterType
  ?let @bigint inRegisterAddress
  ?let @sliceMap inRegisterSliceMap
  ?let @uint inRegisterArraySize # 0 if not an array
  ?let @uint inRegisterElementSize # 0 if not an array
  ?let @primaryInExpressionAccessListAST inAccessList
  !result:@objectIR outResult
{
  if [inAccessList length] == 0 then # No subscript, no slice
    getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !inRegisterAddress]
  else
    var accessList = inAccessList
    if [[accessList mAccessAtIndex !0] isArrayAccess] then
      [!?accessList popFirst ?let first]
      [first arrayAccess ?index:let @expressionAST indexExpression ?endOfIndex:let @location endOfIndex]
      handleArraySubscriptNew (
         !self: inSelfType
         !inGuard: false
         !routineNameForInvocationGraph: inCallerNameForInvocationGraph
         !context: inContext
         !mode: inCurrentMode
         !?temporary: ioTemporaries
         !?staticStringMap: ioGlobalLiteralStringMap
         !?variableMap: ioUniversalMap
         !?alloca: ioAllocaList
         !indexExpression 
         !endOfIndex
         !arraySize:inRegisterArraySize
         !elementType:inRegisterType
         !? ioInstructionGenerationList
         ?let @objectIR indexIR
      )
      if [indexIR isLiteralInteger] then # subscript expression is constant
        [indexIR literalInteger ?1* ?value:let @bigint idx]
        let addr = inRegisterAddress + idx * inRegisterElementSize
        getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
        [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !addr]
      else
        getNewTempValue (!inRegisterType  !?ioTemporaries ?outResult)
        [!?ioInstructionGenerationList appendLoadVolatileRegisterWithSubscript
          !outResult
          !indexIR
          !inRegisterAddress
          !inRegisterElementSize
        ]
      end
    else
      getNewTempValue (!inRegisterType !?ioTemporaries ?outResult)
      [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !inRegisterAddress]
    end
  #--- Access list
    var currentSliceMap = inRegisterSliceMap
    var currentType = inRegisterType
    for (access) in accessList do
      switch access
      case property (@lstring propertyName) :
        [currentSliceMap searchKey
          !propertyName
          ?let @llvmBinaryOperation accessOperator
          ?let @bigint accessRightOperand
          ?let @sliceMap subMap
          ?let @PLMType resultType
        ]
        getNewTempValue (!resultType !?ioTemporaries ?let resultIR)
        [!?ioInstructionGenerationList appendBinaryOperation
          !resultIR
          ![outResult type]
          !propertyName.location
          !outResult
          !accessOperator
          !.literalInteger {!type:staticIntegerType () !value:accessRightOperand}
        ]
        currentSliceMap = subMap
        currentType = resultType
        outResult = resultIR
      case arrayAccess (* @location endOfIndex) :
        error endOfIndex : "receiver is a control register, subscripting is invalid here"
      case funcCall (* * errorLocation) :
        error errorLocation : "receiver is a control register, cannot be used as a function"
      end
    end
  end
}

#·······················································································································

method @primaryInExpressionAST analyzePrimaryExpressionWithSelf
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with self
  outResult = .reference {!type:inSelfType !llvmName:llvmNameForSelf ()}
#--- Access list
  for (access) in mAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?outResult
        !propertyName
        !?temporary:ioTemporaries
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?outResult
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@lstring methodName @effectiveArgumentListAST arguments @location errorLocation) :
      if inGuard then
        error errorLocation : "a method cannot be called in guard" : outResult
      else
        handleFunctionCallInExpression (
          !methodName
          !?outResult
          !self:inSelfType
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !arguments 
          !?ioInstructionGenerationList
        )
      end
    end
  end
}

#·······················································································································

proc handlePropertyAccessInExpression
  ?!@objectIR ioResult
  ?let @lstring inPropertyName
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  let type = [ioResult type]
  let @propertyMap propertyMap = type.propertyMap
  [propertyMap searchKey !inPropertyName ?* ?let @propertyAccessKind accessKind]
  switch accessKind
  case nonVirtualMethod (*) :
    error inPropertyName : "a method cannot be used in this context" : ioResult
  case constantProperty (@objectIR value) :
    ioResult = value
  case indexed (@PLMType propertyType @uint propertyIndex) :
    [!?ioTemporaries newTempLLVMVar ?let property_llvmName]
    [!?ioInstructionGenerationList appendGetUniversalPropertyReference
      ![ioResult type]
      ![ioResult llvmName]
      !propertyType
      !property_llvmName
      !propertyIndex
      !inPropertyName
    ]
    ioResult = .reference {!type:propertyType !llvmName:property_llvmName}
  end
}

#·······················································································································

private proc handleArrayAccessInExpression
  ?!@objectIR ioResult
  ?let @expressionAST inIndexExpression
  ?let @location inEndOfIndex
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Check current object is an array
  if [[ioResult type].kind isArrayType] then
    [[ioResult type].kind arrayType ?elementType:let elementType ?size:let @bigint arraySize]
    handleArraySubscript (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca: ioAllocaList
      !inIndexExpression 
      !inEndOfIndex
      !arraySize:arraySize
      !elementType:elementType
      !?ioInstructionGenerationList
      !?ioResult
   )
   getNewTempValue (![ioResult type] !?ioTemporaries ?let loadedObjectIR)
   [!?ioInstructionGenerationList appendLoadFromReference
     !loadedObjectIR
     ![ioResult llvmName]
   ]
  else
    error inEndOfIndex : "the receiver is not an array and does not accept subscripting"
  end
}

#·······················································································································

private proc handleFunctionCallInExpression
  ?let @lstring inMethodName
  ?!@objectIR ioObjectIR
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments 
  ?!@instructionListIR ioInstructionGenerationList
{
  let receiverType = [ioObjectIR type]
  let @propertyMap propertyMap = receiverType.propertyMap
  let key = routineMangledNameFromCall (!"" !inMethodName !inArguments)
  [propertyMap searchKey !key ?* ?let @propertyAccessKind propertyAccess]
  switch propertyAccess
  case constantProperty (*) :
    error inMethodName : "a constant cannot be used as method" : ioObjectIR
  case nonVirtualMethod (@routineDescriptor routineDescriptor) :
  #--- Check routine is actually a function
    if [routineDescriptor.returnTypeProxy type].kind == .void then
      error inMethodName : "not a function (returns no value)" : ioObjectIR
    else
    #--- Check modes
      let calleeKind = checkMode (
        !callerMode:inMode
        !calleeMode:[routineDescriptor.routineKind executionMode]
        !kind:routineDescriptor.routineKind
        !error:inMethodName.location
      )
    #--- If receiver is a value, create a reference
      [!?ioInstructionGenerationList referenceFromPossibleValue !?ioTemporaries !?ioAllocaList !?ioObjectIR]
    #--- Add receiver as first parameter
      @procCallEffectiveParameterListIR effectiveParameterListIR = {}
      effectiveParameterListIR += !.outputInput !ioObjectIR # Add receiver as first argument
    #--- Analyze effective parameters
      analyzeEffectiveParameters (
        !self:inSelfType
        !formal:routineDescriptor.signature
        !effective:inArguments
        !errorLocation:inMethodName.location
        !callerForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !requiredMode:inMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
        !?effectiveIR:effectiveParameterListIR
      )
    #--- New LLVM variable for function call result
      getNewTempValue (![routineDescriptor.returnTypeProxy type] !?ioTemporaries ?let callReturnedResult)
    #--- Generate call
      let routineMangledName = routineMangledNameFromCall (!llvmTypeStringFromPLMname (![ioObjectIR type].plmTypeName) !inMethodName !inArguments)
      ioInstructionGenerationList += !@staticRoutineCallIR.new {
        !""
        !callReturnedResult
        !routineMangledName
        !routineMangledName # LLVMInvocationRoutineName
        !calleeKind
        !effectiveParameterListIR
      }
    #--- Enter in invocation graph
      [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
    #---
      ioObjectIR = callReturnedResult
    end
  case indexed  (@PLMType propertyType @uint propertyIndex) :
    if not [propertyType.kind isFunction] then
      error inMethodName : "an indexed property cannot be used as method" : ioObjectIR
    else
      [propertyType.kind function ?descriptor:let descriptor]
    #--- Check routine is actually a function
      if descriptor.returnTypeProxy == .null then
        error inMethodName : "not a function (returns no value)" : ioObjectIR
      else
      #--- Check modes
#          let calleeKind = checkMode (
#            !callerMode:inMode
#            !calleeMode:mode
#            !kind:routineDescriptor.mRoutineKind
#            !error:inMethodName.location
#          )
      #--- Analyze effective parameters
        @procCallEffectiveParameterListIR effectiveParameterListIR = {}
        analyzeEffectiveParameters (
          !self:inSelfType
          !formal:descriptor.signature
          !effective:inArguments
          !errorLocation:inMethodName.location
          !callerForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !requiredMode:inMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !?instructionListIR:ioInstructionGenerationList
          !?effectiveIR:effectiveParameterListIR
        )
      #--- Load routine reference
        [!?ioTemporaries newTempLLVMVar ?let property_llvmName]
        [!?ioInstructionGenerationList appendGetUniversalPropertyReference
          ![ioObjectIR type]
          ![ioObjectIR llvmName]
          !propertyType
          !property_llvmName
          !propertyIndex
          !inMethodName
        ]
      #--- New LLVM variable for function call result
        getNewTempValue (![descriptor.returnTypeProxy type] !?ioTemporaries ?let callReturnedResult)
      #--- Code generation
        ioInstructionGenerationList += !@indirectRoutineCallIR.new {
          !.reference {!type:propertyType !llvmName:property_llvmName}
          !propertyType
          !callReturnedResult
          !effectiveParameterListIR
        }
        ioObjectIR = callReturnedResult
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
