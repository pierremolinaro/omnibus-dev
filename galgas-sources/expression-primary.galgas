#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @selfInExpressionAST {
  case noSelf
  case selfAt (@location location)
}

#·······················································································································

enum @primaryInExpressionAccessAST {
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
  case funcCall (@effectiveArgumentListAST arguments @location endOfArguments)
}

#·······················································································································

list @primaryInExpressionAccessListAST {
  @primaryInExpressionAccessAST mAccess
}

#·······················································································································

class @primaryInExpressionAST : @expressionAST {
  @selfInExpressionAST mSelf
  @lstring mObjectName
  @primaryInExpressionAccessListAST mAccessList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
  #--- Self ?
    @selfInExpressionAST selfInExpression
    select
      selfInExpression = .noSelf
    or
      $self$
      selfInExpression = .selfAt {!location:.here}
      $.$
    end
  #--- Object
    $identifier$ ?let objectName
  #--- Properties and access
    @primaryInExpressionAccessListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    while
#      $.$
#      $identifier$ ?let functionName
      <effective_parameters> ?let arguments ?let endOfArguments
      accessListAST += !.funcCall {!arguments:arguments !endOfArguments:endOfArguments}
    end
  #--- AST
    outExpression = @primaryInExpressionAST.new {!selfInExpression !objectName !accessListAST}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mObjectName]
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (@effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (@effectiveArgumentListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @internalRepresentation {
  case standAloneIdentifier (@lstring identifier)
  case structureMember (@lstring propertyName @objectIR currentPointerIR)
  case volatileAbsoluteReference (@PLMType type @uint address)
  case volatileIndirectReference (@PLMType type @string llvmName)
  case universalReference (@PLMType type @string llvmName)
}

#·······················································································································

override method @primaryInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with ou without self
  switch mSelf
  case noSelf :
    if inGuard then
      error mObjectName : "in guard, only 'self' properties may be accessed" : outResult
    else 
      [self analyzePrimaryExpressionNoSelf
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        ?result: outResult
      ]
    end
  case selfAt (selfLocation) :
    if inSelfType == .void then
      error selfLocation : "'self' is not available in this context" : outResult
    elsif [inSelfType isStructure] then
      [self analyzePrimaryExpressionWithSelf
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        ?result: outResult
      ]
    else
      error selfLocation : "'self' should be a structure instance" : outResult
    end
  end
}

#·······················································································································

method @primaryInExpressionAST analyzePrimaryExpressionNoSelf
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
  if mObjectName.string == "" then # Receiver is self
    analyzePrimaryExpressionWithSelf (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !optionalTargetType: inOptionalTargetType
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      !mAccessList
      !mObjectName.location
      ?result:outResult
    )
  else
    [ioUniversalMap searchEntity !mObjectName ?let entity]
    switch entity
    case module (@PLMType unused type) :
      analyzePrimaryExpression (
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !mObjectName
        !mAccessList
        ?result: outResult
      )
    case register (readable * type address sliceMap arraySize elementSize) :
      if not readable then
        error mObjectName : "control register is not readable in this context" : outResult
      elsif inGuard then
        error mObjectName : "control register is not readable in guard" : outResult
      else
        analyzeRegisterExpression (
          !self: inSelfType
          !routineNameForInvocationGraph: inCallerNameForInvocationGraph
          !context: inContext
          !mode: inCurrentMode
          !?temporary: ioTemporaries
          !?staticStringMap: ioGlobalLiteralStringMap
          !?variableMap: ioUniversalMap
          !?alloca: ioAllocaList
          !?instructionListIR: ioInstructionGenerationList
          !mObjectName
          !type
          !address
          !sliceMap
          !arraySize # 0 if not an array
          !elementSize # 0 if not an array
          !mAccessList
          ?result: outResult
        )
      end
    case globalConstant (@objectIR objectIR) :
      outResult = objectIR
    case localConstant (@PLMType unused type @lstring unused plmName) :
      analyzePrimaryExpression (
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !mObjectName
        !mAccessList
        ?result: outResult
      )
    case globalVariable (@bool unused writable @PLMType unused type) :
      analyzePrimaryExpression (
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !mObjectName
        !mAccessList
        ?result: outResult
      )
    case localVariable (@PLMType unused type @lstring unused plmName) :
      analyzePrimaryExpression (
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !mObjectName
        !mAccessList
        ?result: outResult
      )
    case undefined :
      analyzePrimaryExpression (
        !self: inSelfType
        !inGuard: inGuard
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !optionalTargetType: inOptionalTargetType
        !context: inContext
        !mode: inCurrentMode
        !?temporary: ioTemporaries
        !?staticStringMap: ioGlobalLiteralStringMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !mObjectName
        !mAccessList
        ?result: outResult
      )
    end
  end
}

#·······················································································································

private proc analyzePrimaryExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @lstring inObjectName
  ?let @primaryInExpressionAccessListAST inAccessList
  !result:@objectIR outResult
{
  @internalRepresentation internalRepresentation = .standAloneIdentifier {!identifier:inObjectName}
#--- Access list
  for (access) in inAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?internalRepresentation
        !propertyName
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?internalRepresentation
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@effectiveArgumentListAST arguments @location errorLocation) :
      handleFunctionCallInExpression (
        !?internalRepresentation
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !arguments 
        !errorLocation
        !?ioInstructionGenerationList
      )
    end
  end
#--- Analyze current internal representation, in order to get result as @objectIR
  switch internalRepresentation
  case standAloneIdentifier (identifier) :
    [!?ioUniversalMap searchValuedObjectForReadAccess !identifier ?outResult]
  case structureMember (propertyName @objectIR currentPointer) :
    if [[currentPointer type] isStructure] then
      [[currentPointer type] structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
      [propertyMap searchKey !propertyName ?2* ?let type ?*]
      let newObject = @objectIR.llvmReference {
         !type:type
         !llvmName:"%temp." + ioTemporaries.mTemporaryIndex
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !newObject
        !currentPointer
        !propertyName
      ]
      outResult = newObject
    else
      error [currentPointer location] : "this should be a structure instance" : outResult
    end
  case volatileAbsoluteReference (@PLMType unused type @uint unused address) :
    error inObjectName : "llvmReference 1" : outResult
  case volatileIndirectReference (@PLMType unused type @string unused llvmName) :
    error inObjectName : "volatileIndirectReference 1": outResult
  case universalReference (@PLMType type @string llvmName) :
    outResult = .llvmTemporaryValue {!type:type !llvmName:[llvmName nowhere]}
  end
}

#·······················································································································

private proc analyzeRegisterExpression
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @lstring inRegisterName
  ?let @PLMType inRegisterType
  ?let @bigint inRegisterAddress
  ?let @sliceMap inRegisterSliceMap
  ?let @uint inRegisterArraySize # 0 if not an array
  ?let @uint inRegisterElementSize # 0 if not an array
  ?let @primaryInExpressionAccessListAST inAccessList
  !result:@objectIR outResult
{
  if [inAccessList length] == 0 then # No subscript, no slice
    getNewTempVariable (!inRegisterType !inRegisterName.location !?ioTemporaries ?outResult)
    [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !inRegisterAddress]
  else
    var accessList = inAccessList
    if [[accessList mAccessAtIndex !0] isArrayAccess] then
      [!?accessList popFirst ?let first]
      [first arrayAccess ?index:let @expressionAST indexExpression ?endOfIndex:let @location endOfIndex]
      handleArraySubscriptNew (
         !self: inSelfType
         !inGuard: false
         !routineNameForInvocationGraph: inCallerNameForInvocationGraph
         !context: inContext
         !mode: inCurrentMode
         !?temporary: ioTemporaries
         !?staticStringMap: ioGlobalLiteralStringMap
         !?variableMap: ioUniversalMap
         !?alloca: ioAllocaList
         !indexExpression 
         !endOfIndex
         !arraySize:inRegisterArraySize
         !elementType:inRegisterType
         !? ioInstructionGenerationList
         ?let @objectIR indexIR
      )
      if [indexIR isLiteralInteger] then # subscript expression is constant
        [indexIR literalInteger ?1* ?value:let @bigint idx]
        let addr = inRegisterAddress + idx * inRegisterElementSize
        getNewTempVariable (!inRegisterType !inRegisterName.location !?ioTemporaries ?outResult)
        [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !addr]
      else
        getNewTempVariable (!inRegisterType !inRegisterName.location !?ioTemporaries ?outResult)
        [!?ioInstructionGenerationList appendLoadVolatileRegisterWithSubscript
          !outResult
          !indexIR
          !inRegisterAddress
          !inRegisterElementSize
        ]
      end
    else
      getNewTempVariable (!inRegisterType !inRegisterName.location !?ioTemporaries ?outResult)
      [!?ioInstructionGenerationList appendLoadVolatileRegister !outResult !inRegisterAddress]
    end
  #--- Access list
    var currentSliceMap = inRegisterSliceMap
    var currentType = inRegisterType
    for (access) in accessList do
      switch access
      case property (@lstring propertyName) :
        [currentSliceMap searchKey
          !propertyName
          ?let @llvmBinaryOperation accessOperator
          ?let @bigint accessRightOperand
          ?let @sliceMap subMap
          ?let @PLMType resultType
        ]
        getNewTempVariable (!resultType !propertyName.location !?ioTemporaries ?let resultIR)
        [!?ioInstructionGenerationList appendBinaryOperation
          !resultIR
          ![outResult type]
          !propertyName.location
          !outResult
          !accessOperator
          !.literalInteger {!type:.staticInteger !value:accessRightOperand}
        ]
        currentSliceMap = subMap
        currentType = resultType
        outResult = resultIR
      case arrayAccess (* @location endOfIndex) :
        error endOfIndex : "receiver is a control register, subscripting is invalid here"
      case funcCall (* errorLocation) :
        error errorLocation : "receiver is a control register, cannot be used as a function"
      end
    end
  end
}

#·······················································································································

method @primaryInExpressionAST analyzePrimaryExpressionWithSelf
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with self
  @internalRepresentation internalRepresentation= .structureMember {
    !propertyName:mObjectName
    !currentPointerIR:.llvmReference {!type:inSelfType !llvmName:llvmNameForSelf ()}
  }
#--- Access list
  for (access) in mAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?internalRepresentation
        !propertyName
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?internalRepresentation
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@effectiveArgumentListAST arguments @location errorLocation) :
      handleFunctionCallInExpression (
        !?internalRepresentation
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !arguments 
        !errorLocation
        !?ioInstructionGenerationList
      )
    end
  end
#--- Analyze current internal representation, in order to get result as @objectIR
  switch internalRepresentation
  case standAloneIdentifier (identifier) :
    [!?ioUniversalMap searchValuedObjectForReadAccess !identifier ?outResult]
  case structureMember (propertyName @objectIR currentPointer) :
    if [[currentPointer type] isStructure] then
      [[currentPointer type] structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
      [propertyMap searchKey !propertyName ?* ?let @objectIR masterPropertyIR ?2*]
      let newObject = @objectIR.llvmReference {
         !type:[masterPropertyIR type]
         !llvmName:"%temp." + ioTemporaries.mTemporaryIndex
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !newObject
        !currentPointer
        !propertyName
      ]
      outResult = newObject
    else
      error [currentPointer location] : "this should be a structure instance" : outResult
    end
  case volatileAbsoluteReference (@PLMType unused type @uint unused address) :
    error mObjectName : "volatileAbsoluteReference 2" : outResult
  case volatileIndirectReference (@PLMType unused type @string unused llvmName) :
    error mObjectName : "volatileIndirectReference 2": outResult
  case universalReference (@PLMType type @string llvmName) :
    outResult = .llvmTemporaryValue {!type:type !llvmName:[llvmName nowhere]}
  end
}

#·······················································································································

private proc analyzePrimaryExpressionWithSelf
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @primaryInExpressionAccessListAST inAccessList
  ?let @location inSelfLocation
  !result:@objectIR outResult
{
#--- object access, with self
  @internalRepresentation internalRepresentation= .universalReference {
    !type:inSelfType
    !llvmName:llvmNameForSelf ()
  }
#--- Access list
  for (access) in inAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyAccessInExpression (
        !?internalRepresentation
        !propertyName
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleArrayAccessInExpression (
        !?internalRepresentation
        !indexExpression
        !endOfIndex
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:inOptionalTargetType
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
    case funcCall (@effectiveArgumentListAST arguments @location errorLocation) :
      handleFunctionCallInExpression (
        !?internalRepresentation
        !self:inSelfType
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !arguments 
        !errorLocation
        !?ioInstructionGenerationList
      )
    end
  end
#--- Analyze current internal representation, in order to get result as @objectIR
  switch internalRepresentation
  case standAloneIdentifier (identifier) :
    [!?ioUniversalMap searchValuedObjectForReadAccess !identifier ?outResult]
  case structureMember (propertyName @objectIR currentPointer) :
    if [[currentPointer type] isStructure] then
      [[currentPointer type] structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
      [propertyMap searchKey !propertyName ?* ?let @objectIR masterPropertyIR ?2*]
      let newObject = @objectIR.llvmReference {
         !type:[masterPropertyIR type]
         !llvmName:"%temp." + ioTemporaries.mTemporaryIndex
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !newObject
        !currentPointer
        !propertyName
      ]
      outResult = newObject
    else
      error [currentPointer location] : "this should be a structure instance" : outResult
    end
  case volatileAbsoluteReference (@PLMType unused type @uint unused address) :
    error inSelfLocation : "volatileAbsoluteReference 2" : outResult
  case volatileIndirectReference (@PLMType unused type @string unused llvmName) :
    error inSelfLocation : "volatileIndirectReference 2": outResult
  case universalReference (@PLMType type @string llvmName) :
    outResult = .llvmReference {!type:type !llvmName:[llvmName nowhere]}
  end
}

#·······················································································································

private proc handlePropertyAccessInExpression
  ?!@internalRepresentation ioInternalRepresentation
  ?let @lstring inPropertyName
  ?routineNameForInvocationGraph:let @lstring unused inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext unused inContext
  ?mode:let @mode unused inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList unused ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  switch ioInternalRepresentation
  case standAloneIdentifier (identifier) :
    [!?ioUniversalMap searchValuedObjectForReadAccess !identifier ?let @objectIR objectIR]
    switch objectIR
    case globalVariableRef (type *) :
      if [type isStructure] then
        ioInternalRepresentation = .structureMember {!propertyName:inPropertyName !currentPointerIR:objectIR}
      else
        error identifier : "this should be a structure instance" : ioInternalRepresentation
      end
    case null :
    case llvmReference (type llvmName) :
      if [type isStructure] then
        let objectIR = @objectIR.llvmTemporaryValue {
          !type:type
          !llvmName:[llvmName nowhere]
        }
        ioInternalRepresentation = .structureMember {!propertyName:inPropertyName !currentPointerIR:objectIR}
      else
        error identifier : "this should be a structure instance" : ioInternalRepresentation
      end
    case propertyRef (* * *) :
      error identifier : "«property» invalid here" : ioInternalRepresentation
    case llvmTemporaryValue (* *) :
      error identifier : "«llvmTemporaryValue» invalid here" : ioInternalRepresentation
    case literalInteger  (* *) :
      error identifier : "«literalInteger» invalid here" : ioInternalRepresentation
    case llvmStructureConstant (* *) :
       error identifier : "«llvmStructureConstant» invalid here" : ioInternalRepresentation
    case literalString  (* *) :
       error identifier : "a global string constant is invalid here" : ioInternalRepresentation
    case zero (*) :
      error identifier : "«zero» invalid here" : ioInternalRepresentation
    end
  case structureMember (masterPropertyName currentPointer) :
    if [[currentPointer type] isStructure] then
      [[currentPointer type] structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
      [propertyMap searchKey !masterPropertyName ?* ?let @objectIR masterPropertyIR ?2*]
      let newObject = @objectIR.llvmReference {
         !type:[masterPropertyIR type]
         !llvmName:"%temp." + ioTemporaries.mTemporaryIndex
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !newObject
        !currentPointer
        !masterPropertyName
      ]
      ioInternalRepresentation = .structureMember {!propertyName:inPropertyName !currentPointerIR:newObject}
    else
      error masterPropertyName : "'" + masterPropertyName + "' should be a structure" : ioInternalRepresentation
    end
   case volatileAbsoluteReference (@PLMType unused type @uint unused address) :
    error inPropertyName : "volatileAbsoluteReference 3" : ioInternalRepresentation
  case volatileIndirectReference (@PLMType unused type @string unused llvmName) :
    error inPropertyName : "volatileIndirectReference 3": ioInternalRepresentation
  case universalReference (@PLMType type @string unused llvmName) :
    if [type isStructure] then
      [type structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
      [propertyMap searchKey !inPropertyName ?2* ?let propertyType ?let propertyAccess]
      switch propertyAccess
      case constant (@string unused llvmValue) :
        error inPropertyName : "constant property no handled yet" : ioInternalRepresentation
      case indexed (@uint index) :
        [!?ioTemporaries newTempLLVMVar ?let llvmPropertyName]
        [ioInternalRepresentation universalReference ?type:let currentType ?llvmName:let currentLLVMName]
        [!?ioInstructionGenerationList appendGetUniversalPropertyReference
          !currentType
          !currentLLVMName
          !propertyType
          !llvmPropertyName
          !index
          !inPropertyName
        ]
        ioInternalRepresentation = .universalReference {!type:propertyType !llvmName:llvmPropertyName}
      end
    else
      error inPropertyName : "'" + inPropertyName + "' should be a structure" : ioInternalRepresentation
     end
  end
}

#·······················································································································

private proc handleArrayAccessInExpression
  ?!@internalRepresentation ioInternalRepresentation
  ?let @expressionAST inIndexExpression
  ?let @location inEndOfIndex
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  @objectIR variableIR
  @location errorLocation
  switch ioInternalRepresentation
  case standAloneIdentifier (@lstring identifier) :
    errorLocation = identifier
    [!?ioUniversalMap searchValuedObjectForReadAccess !identifier ?variableIR]
  case structureMember (@lstring propertyName @objectIR currentPointerIR) :
    if [[currentPointerIR type] isStructure] then
      errorLocation = propertyName
      [[currentPointerIR type] structure ?1* ?propertyMap:let @propertyMap propertyMap ?3*]
      [propertyMap searchKey !propertyName ?* ?let @objectIR masterPropertyIR ?2*]
      variableIR = @objectIR.llvmReference {
         !type:[masterPropertyIR type]
         !llvmName:"%temp." + ioTemporaries.mTemporaryIndex
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !variableIR
        !currentPointerIR
        !propertyName
      ]
    else
      error [currentPointerIR location] : "this should be a structure instance" : variableIR, errorLocation
    end
  case volatileAbsoluteReference (@PLMType unused type @uint unused address) :
    error inEndOfIndex : "volatileAbsoluteReference 4" : variableIR, errorLocation
  case volatileIndirectReference (@PLMType unused type @string unused llvmName) :
    error inEndOfIndex : "volatileIndirectReference 4": variableIR, errorLocation
  case universalReference (@PLMType type @string llvmName) :
    variableIR = @objectIR.llvmReference {!type:type !llvmName:[llvmName nowhere]}
    errorLocation = .nowhere
#    error inEndOfIndex : "indirectReference 4": variableIR, errorLocation
  end
#--- Check current object is an array
  if [[variableIR type] isArrayType] then
    [[variableIR type] arrayType ?1* ?elementType:let elementType ?size:let @bigint arraySize ?3*]
    handleArraySubscript (
      !self: inSelfType
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !context: inContext
      !mode: inCurrentMode
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca: ioAllocaList
      !inIndexExpression 
      !inEndOfIndex
      !arraySize:arraySize
      !elementType:elementType
      !?ioInstructionGenerationList
      !?variableIR
   )
   getNewTempVariable (![variableIR type] ![variableIR location] !?ioTemporaries ?let loadedObjectIR)
   [!?ioInstructionGenerationList appendLoadFromTemporaryReference
     !loadedObjectIR
     ![variableIR llvmName]
   ]
   ioInternalRepresentation = .universalReference {!type:[loadedObjectIR type] !llvmName:[loadedObjectIR name]}
  else
    error errorLocation : "the receiver is not an array and does not accept subscripting"
  end
}

#·······················································································································

private proc handleFunctionCallInExpression
  ?!@internalRepresentation ioInternalRepresentation
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments 
  ?let @location inErrorLocation
  ?!@instructionListIR ioInstructionGenerationList
{
#--- Cannot call a function in guard
  if inGuard then
    error inErrorLocation : "a routine cannot be called in guard"
  end
#--- Get function name and map containing the function definition
  switch ioInternalRepresentation
   case volatileAbsoluteReference (@PLMType unused type @uint unused address) :
    error inErrorLocation : "volatileAbsoluteReference 5"
  case volatileIndirectReference (@PLMType unused type @string unused llvmName) :
    error inErrorLocation : "volatileIndirectReference 5"
  case universalReference (@PLMType unused type @string unused llvmName) :
    error inErrorLocation : "indirectReference 5"
  case standAloneIdentifier (@lstring identifier) : # This a call idf (....)
    handleStandAloneFunctionCallInExpression (
      !?ioInternalRepresentation
      !identifier
      !self:inSelfType
      !inGuard:inGuard
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !mode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !inArguments 
      !inErrorLocation
      !?ioInstructionGenerationList
    )
  case structureMember (@lstring propertyName @objectIR currentPointerIR) :
    if [[currentPointerIR type] isStructure] then
      handleMethodCallInExpression (
        !propertyName
        !currentPointerIR
        !self:inSelfType
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !inArguments 
        !?ioInstructionGenerationList
        ?let @objectIR callReturnedResult
      )
      ioInternalRepresentation = .universalReference {!type:[callReturnedResult type] !llvmName:[callReturnedResult name]}
    else
      error [currentPointerIR location] : "this object should be a structure" : ioInternalRepresentation
    end
  end
}

#·······················································································································

private proc handleMethodCallInExpression
  ?let @lstring inMethodName
  ?let @objectIR inCurrentPointerIR
  ?self:let @PLMType inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments 
  ?!@instructionListIR ioInstructionGenerationList
  !@objectIR outCallReturnedResult
{
  let routineMangledName = routineMangledNameFromCall (!"$" + [[inCurrentPointerIR type] key] !inMethodName !inArguments)
#--- Get called function signature
  let signature = [inArguments routineSignature !inMethodName.location]
#--- Search function in map
  [inContext.mRoutineMapForContext searchKey
    !inMethodName
    !signature
    ?let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
    ?* # let @location outKeyLocation
  ]
#--- Check routine is actually a function
  if [routineDescriptor.mReturnTypeProxy type] == .void then
    error inMethodName : "not a function (returns no value)" : routineDescriptor, outCallReturnedResult
  else
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:inMode
      !calleeMode:[routineDescriptor.mRoutineKind executionMode]
      !kind:routineDescriptor.mRoutineKind
      !error:inMethodName.location
    )
  #--- Add receiver as first parameter ?
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    switch routineDescriptor.mRoutineCallingScheme
    case staticCall :
      effectiveParameterListIR += !.outputInput !inCurrentPointerIR # Add receiver as first argument
    case propertyIndirectCall (*) :
    end
  #--- Analyze effective parameters
    analyzeEffectiveParameters (
      !self:inSelfType
      !formal:routineDescriptor.mSignature
      !effective:inArguments
      !errorLocation:inMethodName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempVariable (![routineDescriptor.mReturnTypeProxy type] !routineMangledName !?ioTemporaries ?outCallReturnedResult)
  #--- Generate call
    switch routineDescriptor.mRoutineCallingScheme
    case staticCall :
    #--- Code generation
      ioInstructionGenerationList += !@staticRoutineCallIR.new {
        !"" # globalVariableReceiverName
        !outCallReturnedResult
        !routineMangledName
        !LLVMInvocationRoutineName
        !calleeKind
        !effectiveParameterListIR
      }
    #--- Enter in invocation graph
      [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
    case propertyIndirectCall (type) :
      let propertyReference = @objectIR.llvmReference {
         !type:type
         !llvmName:"%temp." + ioTemporaries.mTemporaryIndex
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetPropertyReference
        !propertyReference
        !inCurrentPointerIR
        !inMethodName
      ]
    #--- Code generation
      ioInstructionGenerationList += !@indirectRoutineCallIR.new {
        !propertyReference
        !type
        !outCallReturnedResult
        !effectiveParameterListIR
      }
    end
  end
}

#·······················································································································

private proc handleStandAloneFunctionCallInExpression
  ?!@internalRepresentation ioInternalRepresentation
  ?let @lstring inFunctionName
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveArgumentListAST inArguments 
  ?let @location inErrorLocation
  ?!@instructionListIR ioInstructionGenerationList
{
#--- Cannot call a function in guard
  if inGuard then
    error inErrorLocation : "a routine cannot be called in guard"
  end
#--- Get function name and map containing the function definition
  let routineMangledName = routineMangledNameFromCall (!"" !inFunctionName !inArguments)
#--- Get called function signature
  let signature = [inArguments routineSignature !inFunctionName.location]
#--- Search function in map
  [inContext.mRoutineMapForContext searchKey
    !inFunctionName
    !signature
    ?let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
    ?* # let @location outKeyLocation
  ]
#  let isPublic = routineDescriptor.mIsPublic
  let routineKind = routineDescriptor.mRoutineKind
  let calleeMode = [routineKind executionMode]
  let formalSignature = routineDescriptor.mSignature
#--- Check routine is actually a function
  if [routineDescriptor.mReturnTypeProxy type] == .void then
    error inFunctionName : "not a function (returns no value)" : routineDescriptor
  else
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:inMode
      !calleeMode:calleeMode
      !kind:routineKind
      !error:inFunctionName.location
    )
  #--- Analyze effective parameters
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    analyzeEffectiveParameters (
      !self:inSelfType
      !formal:formalSignature
      !effective:inArguments
      !errorLocation:inFunctionName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempVariable (![routineDescriptor.mReturnTypeProxy type] !routineMangledName !?ioTemporaries ?let functionResult)
  #--- Code generation
    ioInstructionGenerationList += !@staticRoutineCallIR.new {
      !"" # globalVariableReceiverName
      !functionResult
      !routineMangledName
      !LLVMInvocationRoutineName
      !calleeKind
      !effectiveParameterListIR
    }
  #--- Enter in invocation graph
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
  #---
    ioInternalRepresentation = .universalReference {!type:[functionResult type] !llvmName:[functionResult name]}
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
