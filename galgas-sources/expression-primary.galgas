#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @primaryInExpressionSelfAccessAST {
  case noSelfAccess
  case selfAccess (@location selfLocation)
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @primaryInExpressionAccessAST {
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
  case funcCall (@effectiveParameterListAST arguments)
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @primaryInExpressionAccessListAST {
  @primaryInExpressionAccessAST mAccess
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @primaryInExpressionAST : @expressionAST {
  @primaryInExpressionSelfAccessAST mSelfAccess 
  @lstring mObjectName
  @primaryInExpressionAccessListAST mAccessList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $azerty$
  #--- Self ?
    @primaryInExpressionSelfAccessAST selfAccess
    select
      selfAccess = .noSelfAccess
    or
      $self$
      selfAccess = .selfAccess {!selfLocation:.here}
      $.$
    end
  #--- Object
    $identifier$ ?let objectName
  #--- Properties and access
    @primaryInExpressionAccessListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    while
      <effective_parameters> ?let arguments
      accessListAST += !.funcCall {!arguments:arguments}
    end
  #--- AST
    outExpression = @primaryInExpressionAST.new {!selfAccess !objectName !accessListAST}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (@effectiveParameterListAST arguments) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (@effectiveParameterListAST arguments) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@valueIR outResult
{
#--- object access, with ou without self
  @objectInMemoryIR currentPointer
  switch mSelfAccess
  case noSelfAccess :
    if inGuard then
      error mObjectName : "in guard, only 'self' properties may be accessed" : currentPointer
    else
      if [ioLocalVariableMap hasKey !mObjectName] then
        [!?ioLocalVariableMap searchForReadAccess !mObjectName]
      end
      [!?ioVariableMap searchForReadAccess !lkey:mObjectName ?5*]
      [ioNamedObjectMap searchKey
        !mObjectName
        ?currentPointer
      ]
      [currentPointer checkReadable]
    end
  case selfAccess (@location selfLocation) :
    if inSelfType == .null then
      error selfLocation : "'self' is not available in this context" : currentPointer
    elsif [[inSelfType kind] isStructure] then
      [[inSelfType kind] structure ?objectMap:let @namedObjectMap structureObjectMap ?2*]
      [structureObjectMap searchKey
        !mObjectName
        ?let object
      ]
      handleSelfAccessInExpression (
        !inSelfType
        !object
        !?ioTemporaries
        !?ioInstructionGenerationList
        ?currentPointer
      )
    else
      error selfLocation : "'self' should be a structure instance" : currentPointer
    end
  end
#--- Access list
  for (access) in mAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyInExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !modes:inModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?localVariableMap: ioLocalVariableMap
        !?namedObjectMap: ioNamedObjectMap
        !?alloca:ioAllocaList
        !propertyName
        !?ioInstructionGenerationList
        !?currentPointer
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleSubscriptInExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !modes:inModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?localVariableMap: ioLocalVariableMap
        !?namedObjectMap: ioNamedObjectMap
        !?alloca:ioAllocaList
        !indexExpression
        !endOfIndex
        !?ioInstructionGenerationList
        !?currentPointer
      )
    case funcCall (@effectiveParameterListAST arguments) :

    end
  end

#--- Load from memory  
  [!?ioInstructionGenerationList appendLoadFromMemory
    !?ioTemporaries
    !mObjectName.location
    !currentPointer
    ?outResult
  ]  

  
#  if not inDirectAccessToPropertiesAllowed then
#    error mSelfLocation : "for accessing properties, the function should be declared with @" + userAccessAttribute () + " attribute"
#  end
#  analyzeSelfAccess (
#    !fieldList:mFieldList
#    !self:inSelfType
#    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
#    !inGuard:inGuard
#    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#    !optionalTargetType:.null
#    !context:inContext
#    !modes:inModeSet
#    !allowPanic:inAllowPanic
#    !?temporary:ioTemporaries
#    !?staticStringMap:ioGlobalLiteralStringMap
#    !?variableMap:ioVariableMap
#    !?localVariableMap: ioLocalVariableMap
#    !?namedObjectMap: ioNamedObjectMap
#    !?alloca:ioAllocaList
#    !?instructionListIR:ioInstructionGenerationList
#    ?resultPtr:let @objectInMemoryIR resultPtr
#  )
#  if not [[resultPtr type] copyable] then
#    error mSelfLocation : "an $" + [[resultPtr type] key] + " instance is not copyable"
#  end
#  [!?ioInstructionGenerationList appendLoadFromMemory !?ioTemporaries !resultPtr ?outResult]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleSelfAccessInExpression
  ?let @unifiedTypeMap-proxy inSelfType
  ?let @objectInMemoryIR inObject
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  !@objectInMemoryIR outObjectPtr
{
  if [inObject isProperty] then
    [inObject property ?type:let type ?name:let name ?index:let index]
    outObjectPtr = .localVariable {!type:type !name:"temp." + ioTemporaries.mTemporaryIndex !volatile:false}
    ioTemporaries.mTemporaryIndex ++
    [!?ioInstructionGenerationList appendGetElementPtrFromSelf
      !outObjectPtr
      !inSelfType
      !{!.absolute {!index:index} !name}
    ]
  else
    error .nowhere : "<<getNewTemporarySelfObjectPtr>>" : outObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handlePropertyAccessInExpression
  ?!@objectInMemoryIR ioObject
  ?let @location inErrorLocation
  ?let @objectInMemoryIR inProperty
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
{
  if [inProperty isProperty] then
    [inProperty property ?type:let type ?name:let name ?index:let index]
    let newObject = @objectInMemoryIR.localVariable {
      !type:type
      !name:"temp." + ioTemporaries.mTemporaryIndex
      !volatile:false
    }
    ioTemporaries.mTemporaryIndex ++
    [!?ioInstructionGenerationList appendGetElementPtr
      !newObject
      !ioObject
      !{!.absolute {!index:index} !name}
    ]
    ioObject = newObject
  else
    error inErrorLocation : "<<getNewTemporarySelfObjectPtr>>" : ioObject
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleSubscriptInExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList

  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectInMemoryIR ioObjectPtr
{
  if [[[ioObjectPtr type] kind] isArrayType] then
    handleVariableSubscriptInExpression (
      !self: inSelfType
      !directAccessToPropertiesAllowed: inDirectAccessToPropertiesAllowed
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !context: inContext
      !modes: inModeSet
      !allowPanic: inAllowPanic
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioVariableMap
      !?localVariableMap: ioLocalVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca: ioAllocaList
      !inIndexExpression 
      !inErrorLocation
      !?ioInstructionGenerationList
      !?ioObjectPtr
   )
  elsif [ioObjectPtr isRegister] then
    handleRegisterArraySubscriptInExpression (
      !self: inSelfType
      !directAccessToPropertiesAllowed: inDirectAccessToPropertiesAllowed
      !inGuard: inGuard
      !routineNameForInvocationGraph: inCallerNameForInvocationGraph
      !context: inContext
      !modes: inModeSet
      !allowPanic: inAllowPanic
      !?temporary: ioTemporaries
      !?staticStringMap: ioGlobalLiteralStringMap
      !?variableMap: ioVariableMap
      !?localVariableMap: ioLocalVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca: ioAllocaList
      !inIndexExpression 
      !inErrorLocation
      !?ioInstructionGenerationList
      !?ioObjectPtr
   )
  else
    error inErrorLocation : "the receiver is not an array and does not accept subscripting" : ioObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleVariableSubscriptInExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectInMemoryIR ioObjectPtr
{
#--- Analyze array type
  [[[ioObjectPtr type] kind] arrayType ?elementType:let type ?size:let @bigint arraySize]
#--- Analyze index expression
  [inIndexExpression analyzeExpression
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.null
    !context:inContext
    !modes:inModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?localVariableMap: ioLocalVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @valueIR indexResult
  ]
  if [indexResult isLiteralInteger] then # Static expression
    [indexResult literalInteger ?1* ?value:let @bigint indexValue]
    if (indexValue < 0G) || (indexValue >= arraySize) then
      error inErrorLocation : "static index should be positive and < " + arraySize : ioObjectPtr
    else
      let result = @objectInMemoryIR.localVariable {
        !type:type
        !name:"temp." + ioTemporaries.mTemporaryIndex
        !volatile:false
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetElementPtr
        !result
        !ioObjectPtr
        !{!.absolute {!index:[indexValue uint]} !"[" + indexValue + "]"}
      ]
      ioObjectPtr = result      
    end
  elsif [[indexResult kind] isInteger] then
    if not [option plm_options.noPanicGeneration value] then
      [!?ioInstructionGenerationList testArrayIndex
        !indexResult
        !inErrorLocation
        !arraySize
        ?let @bool generatePanicInstruction
      ]
      if generatePanicInstruction && not inAllowPanic then
        error inErrorLocation : "index computation can generate panic" : ioObjectPtr
      end
    end
      let result = @objectInMemoryIR.localVariable {
        !type:type
        !name:"temp." + ioTemporaries.mTemporaryIndex
        !volatile:false
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetElementPtr
        !result
        !ioObjectPtr
        !{!.indirect {!index:indexResult} !"[" + [indexResult name] + "]"}
      ]
      ioObjectPtr = result      
  else
    error inErrorLocation : "index expression is not an integer" : ioObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleRegisterArraySubscriptInExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectInMemoryIR ioObjectPtr
{
  [ioObjectPtr register
    ?type:let registerType
    ?name:let registerName
    ?readable:let readable
    ?writable:let writable
    ?address:let @bigint registerAddress
    ?sliceMap:@controlRegisterBitSliceAccessMap registerBitSliceMap
    ?arraySize:let @uint arraySize # 0 if not an array
    ?elementSize:let @uint elementArraySize # 0 if not an array
  ]
  if arraySize == 0 then
    error inErrorLocation : "register is not an array and does not support subscripting" : ioObjectPtr
  elsif not readable then
    error inErrorLocation : "register cannot be read in this context" : ioObjectPtr
  else
    [inIndexExpression analyzeExpression
      !self:inSelfType
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !inGuard:inGuard
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !optionalTargetType:.null
      !context:inContext
      !modes:inModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?localVariableMap: ioLocalVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?result:let @valueIR indexResult
    ]
  #--- Static expression ?
    if [indexResult isLiteralInteger] then # Static expression
      [indexResult literalInteger ?1* ?value:let @bigint indexValue]
      if (indexValue < 0G) || (indexValue >= arraySize) then
        error inErrorLocation : "static index should be positive and < " + arraySize : ioObjectPtr
      else
        ioObjectPtr = .register {
          !type:registerType
          !name:registerName
          !readable:readable
          !writable:writable
          !address:registerAddress + indexValue * elementArraySize
          !sliceMap:registerBitSliceMap
          !arraySize:0
          !elementSize:0
        }
      end
    #--- Dynamic expression
    elsif [[indexResult kind] isInteger] then
      if not [option plm_options.noPanicGeneration value] then
        [!?ioInstructionGenerationList testArrayIndex
          !indexResult
          !inErrorLocation
          !arraySize
          ?let @bool generatePanicInstruction
        ]
        if generatePanicInstruction && not inAllowPanic then
          error inErrorLocation : "index computation can generated panic"
        end
      end
      let registerAddressObject = @objectInMemoryIR.localVariable {
        !type:registerType
        !name:"temp." + ioTemporaries.mTemporaryIndex
        !volatile:true
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendComputeVolatileRegisterAddressWithSubscript
        !registerAddressObject
        !indexResult
        !registerAddress
        !elementArraySize
      ]
      ioObjectPtr = registerAddressObject
    else
      error inErrorLocation : "index expression is not an integer" : ioObjectPtr
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handlePropertyInExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!localVariableMap:@localVariableMap ioLocalVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?let @lstring inPropertyName
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectInMemoryIR ioObjectPtr
{
#--- Structure
  if [[[ioObjectPtr type] kind] isStructure] then
    [[[ioObjectPtr type] kind] structure ?objectMap:let @namedObjectMap structureObjectMap ?2*]
    [structureObjectMap searchKey
      !inPropertyName
      ?@objectInMemoryIR property
    ]
    handlePropertyAccessInExpression (
      !?ioObjectPtr
      !inPropertyName.location
      !property
      !?ioTemporaries
      !?ioInstructionGenerationList
    )
  else
    error inPropertyName : "the current object has no property" : ioObjectPtr
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
