#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @primaryInExpressionSelfAccessAST {
  case noSelfAccess
  case selfAccess (@location selfLocation)
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @primaryInExpressionAccessAST {
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
  case funcCall (@effectiveParameterListAST arguments @location endOfArguments)
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @primaryInExpressionAccessListAST {
  @primaryInExpressionAccessAST mAccess
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @primaryInExpressionAST : @expressionAST {
  @primaryInExpressionSelfAccessAST mSelfAccess 
  @lstring mObjectName
  @primaryInExpressionAccessListAST mAccessList
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
  #--- Self ?
    @primaryInExpressionSelfAccessAST selfAccess
    select
      selfAccess = .noSelfAccess
    or
      $self$
      selfAccess = .selfAccess {!selfLocation:.here}
      $.$
    end
  #--- Object
    $identifier$ ?let objectName
  #--- Properties and access
    @primaryInExpressionAccessListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    while
      <effective_parameters> ?let arguments ?let endOfArguments
      accessListAST += !.funcCall {!arguments:arguments !endOfArguments:endOfArguments}
    end
  #--- AST
    outExpression = @primaryInExpressionAST.new {!selfAccess !objectName !accessListAST}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mObjectName]
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case funcCall (@effectiveParameterListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
          end
        case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (@lstring unused name) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case funcCall (@effectiveParameterListAST arguments *) :
      for () in arguments do
        switch mEffectiveParameterKind
        case input (*):
        case inputWithType (* @lstring typeName *) :
          if typeName.string != "" then
            [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
          end
        case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
        case outputInput (*) :
        case outputInputSelfVariable (*) :
        end 
      end
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primaryInExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- object access, with ou without self
  @objectIR currentPointer
  switch mSelfAccess
  case noSelfAccess :
    if inGuard then
      error mObjectName : "in guard, only 'self' properties may be accessed" : currentPointer
    elsif [ioVariableMap hasKey !mObjectName] then
      [!?ioVariableMap searchForReadAccess !lkey:mObjectName
        ?3*
        ?objectIR:currentPointer
        ?2*
      ]
      [currentPointer checkReadable]
    else # Stand alone function call ?
      currentPointer = .possibleFunction {!receiver:.null !functionName:mObjectName}
    end
  case selfAccess (@location selfLocation) :
    if inSelfType == .null then
      error selfLocation : "'self' is not available in this context" : currentPointer
    elsif [[inSelfType kind] isStructure] then
      [[inSelfType kind] structure ?objectMap:let @namedObjectMap structureObjectMap ?2*]
      if [structureObjectMap hasKey !mObjectName] then
        [structureObjectMap searchKey
          !mObjectName
          ?let object
        ]
        handleSelfAccessInExpression (
          !inSelfType
          !object
          !?ioTemporaries
          !?ioInstructionGenerationList
          ?currentPointer
        )
      else # Function call ?
        currentPointer = .possibleFunction {!receiver:.selfObject {!type:inSelfType} !functionName:mObjectName}
      end
    else
      error selfLocation : "'self' should be a structure instance" : currentPointer
    end
  end
#--- Access list
  for (access) in mAccessList do
    switch access
    case property (@lstring propertyName) :
      handlePropertyInExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !modes:inModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?namedObjectMap: ioNamedObjectMap
        !?alloca:ioAllocaList
        !propertyName
        !?ioInstructionGenerationList
        !?currentPointer
      )
    case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
      handleSubscriptInAssignmentAndExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !modes:inModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?namedObjectMap: ioNamedObjectMap
        !?alloca:ioAllocaList
        !indexExpression
        !endOfIndex
        !?ioInstructionGenerationList
        !?currentPointer
      )
    case funcCall (@effectiveParameterListAST arguments @location errorLocation) :
      handleFunctionCallInExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:inGuard
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !modes:inModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?namedObjectMap: ioNamedObjectMap
        !?alloca:ioAllocaList
        !arguments
        !errorLocation
        !?ioInstructionGenerationList
        !?currentPointer
      )
    end
  end

#--- Load from memory  
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !currentPointer
    !mObjectName.location
    ?outResult
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleSelfAccessInExpression
  ?let @unifiedTypeMap-proxy inSelfType
  ?let @objectIR inObject
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  !@objectIR outObjectPtr
{
  if [inObject isProperty] then
    [inObject property ?type:let type ?plmName:let name ?index:let index]
    outObjectPtr = .temporaryReference {
      !type:type
      !llvmName:"temp." + ioTemporaries.mTemporaryIndex
      !sliceMap:{}
      !volatile:false
    }
    ioTemporaries.mTemporaryIndex ++
    [!?ioInstructionGenerationList appendPropertyReferenceFromSelf
      !outObjectPtr
      !inSelfType
      !name
      !index
    ]
  else
    error .nowhere : "<<getNewTemporarySelfObjectPtr>>" : outObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handlePropertyAccessInExpression
  ?!@objectIR ioObject
  ?let @location inErrorLocation
  ?let @objectIR inProperty
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
{
  if [inProperty isProperty] then
    [inProperty property ?type:let type ?plmName:let name ?index:let index]
    let newObject = @objectIR.temporaryReference {
      !type:type
      !llvmName:"temp." + ioTemporaries.mTemporaryIndex
      !sliceMap:{}
      !volatile:false
    }
    ioTemporaries.mTemporaryIndex ++
    [!?ioInstructionGenerationList appendGetPropertyReference
      !newObject
      !ioObject
      !name
      !index
    ]
    ioObject = newObject
  else
    error inErrorLocation : "<<getNewTemporarySelfObjectPtr>>" : ioObject
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handlePropertyInExpression
  ?self:let @unifiedTypeMap-proxy unused inSelfType
  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool unused inGuard
  ?routineNameForInvocationGraph:let @lstring unused inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset unused inModeSet
  ?allowPanic:let @bool unused inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap unused ioVariableMap
  ?!namedObjectMap:@namedObjectMap unused ioNamedObjectMap
  ?!alloca:@allocaList unused ioAllocaList
  ?let @lstring inPropertyName
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectIR ioObjectPtr
{
#--- Structure
  if [[[ioObjectPtr type] kind] isStructure] then
    [[[ioObjectPtr type] kind] structure ?objectMap:let @namedObjectMap structureObjectMap ?2*]
    if [structureObjectMap hasKey !inPropertyName] then
      [structureObjectMap searchKey !inPropertyName ?@objectIR property]
      handlePropertyAccessInExpression (
        !?ioObjectPtr
        !inPropertyName.location
        !property
        !?ioTemporaries
        !?ioInstructionGenerationList
      )
    else # Function call ?
      ioObjectPtr = .possibleFunction {!receiver:ioObjectPtr !functionName:inPropertyName}
    end
#--- Integer slice
  elsif [[[ioObjectPtr type] kind] isInteger] then
    let sliceMap = [ioObjectPtr sliceMap !inPropertyName.location]
    [!?ioInstructionGenerationList appendLoadFromReference
      !?ioTemporaries
      !ioObjectPtr
      !inPropertyName.location
      ?let unused loadedRegisterValue
    ]
    [sliceMap searchKey
      !inPropertyName
      ?let @llvmBinaryOperation accessOperator
      ?let @bigint accessRightOperand
      ?let @sliceMap resultSliceMap
      ?let @unifiedTypeMap-proxy resultType
    ]
    let resultObject = @objectIR.llvmTemporaryValue {
      !type:resultType
      !llvmName:"temp." + ioTemporaries.mTemporaryIndex
      !sliceMap:resultSliceMap
    }
    ioTemporaries.mTemporaryIndex ++
    [!?ioInstructionGenerationList appendBinaryOperation
      !resultObject
      ![ioObjectPtr type]
      !inPropertyName.location
      !loadedRegisterValue
      !accessOperator
      !.literalInteger {!type: inContext.mLiteralIntegerType !value:accessRightOperand}
    ]
    ioObjectPtr = resultObject 
  else
    error inPropertyName : "the current object has no property" : ioObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc handleFunctionCallInExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?let @effectiveParameterListAST inArguments 
  ?let @location inErrorLocation
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectIR ioObjectPtr
{
  if not [ioObjectPtr isPossibleFunction] then
    error inErrorLocation : "object is not a function" : ioObjectPtr
  elsif inGuard then
    [ioObjectPtr possibleFunction ?1* ?functionName:let functionName]
    error functionName : "a function cannot be called in guard expression" : ioObjectPtr
  else
    [ioObjectPtr possibleFunction ?receiver:let receiver ?functionName:let functionName]
    analyzeFunctionCallInExpression (
      !self:inSelfType
      !propertiesAreMutable:false
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !receiver:receiver
      !routineName:functionName
      !effective:inArguments
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredModeSet:inModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
      ?routineKind:let @routineKindIR routineKind
      ?routineMangledName:let @lstring functionMangledName
      ?routineNameForGeneration:let @lstring functionNameForGeneration
      ?returnType:let @unifiedTypeMap-proxy returnedType
      ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
    )
    if returnedType == .null then
      error functionName : "the function cannot be called in expression: no return value"
    end
  #--- New LLVM variable for function call result
    getNewTempVariable (!returnedType !?ioTemporaries ?let functionResult)
  #--- Code generation
    ioInstructionGenerationList += !@functionCallIR.new {
      !functionResult
      !functionMangledName
      !functionNameForGeneration
      !routineKind
      !effectiveParameterListIR
      !appendFileAndLineArgumentForPanicLocation
    }
  #---
    ioObjectPtr = functionResult
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeFunctionCallInExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?receiver:let @objectIR inReceiver
  ?routineName:let @lstring inRoutineName
  ?effective:let @effectiveParameterListAST inEffectiveParameterList
  ?callerForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?requiredModeSet:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !effectiveIR:@procCallEffectiveParameterListIR outEffectiveParameterListIR
  !routineKind:@routineKindIR outRoutineKindIR
  !routineMangledName:@lstring outRoutineMangledName
  !routineNameForGeneration:@lstring outRoutineNameForGeneration
  !returnType:@unifiedTypeMap-proxy outReturnedType
  !appendFileAndLineArgumentForPanicLocation:@bool outAppendFileAndLineArgumentForPanicLocation
{
#---
  outEffectiveParameterListIR = {}
#--- Add receiver as first argument
  let receiverType = [inReceiver type]
  if receiverType != .null then
    outRoutineMangledName = .new {!"$" + [receiverType key] + "." + inRoutineName !inRoutineName.location}
    outEffectiveParameterListIR += !.outputInput !inReceiver
  else
    outRoutineMangledName = inRoutineName
  end
#--- Build LLVM mangled name
  outRoutineMangledName.string += "("
  for (passingMode selector) in inEffectiveParameterList do
    outRoutineMangledName.string += [passingMode matchingFormalArgument]
    outRoutineMangledName.string += selector.string
    outRoutineMangledName.string += ":"
  end
  outRoutineMangledName.string += ")"
  [inContext.mRoutineMapForContext searchKey
    !outRoutineMangledName
    ?outRoutineNameForGeneration
    ?let isPublic
    ?let modeMap
    ?let @procedureSignature formalSignature
    ?let @routineKind routineKind
    ?*
    ?outReturnedType
    ?outAppendFileAndLineArgumentForPanicLocation
    ?let unused canMutateProperties
    ?let unused canAccessPropertiesInUserMode
  ]
#--- Check accessibility
  if not isPublic then
    if receiverType == .null then # Standalone function
      let @string declarationFile = [[inContext.mRoutineMapForContext locationForKey !outRoutineMangledName.string] file]
      let invocationFile = [inRoutineName.location file]
      if invocationFile != declarationFile then
        error inRoutineName : "this routine is not public"
      end
    else
      error inRoutineName : "this routine is not public"
    end  
  end  
#--- Enter in invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !outRoutineMangledName]
#--- Check modes
  outRoutineKindIR = checkMode (
    !requiredModes:inRequiredModeSet
    !possibleModes:[modeMap keySet]
    !kind:routineKind
    !error:inRoutineName.location
  )
#--- Analyze effective parameters
  analyzeEffectiveParameters (
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !propertiesAreMutable:inRoutineCanMutateProperties
    !formal:formalSignature
    !effective:inEffectiveParameterList
    !errorLocation:inRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:outEffectiveParameterListIR
  )
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
