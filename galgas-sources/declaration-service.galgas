#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @serviceDeclarationListAST {
  @lstring mServiceName
  @lstring mServiceMode
  @lstringlist mServiceAttributeList
  @procFormalArgumentList mServiceFormalArgumentList
  @instructionListAST mServiceInstructionList
  @location mEndOfServiceLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <service> ?!@serviceDeclarationListAST ioServiceListAST {
    $service$
    $identifier$ ?let serviceName
    $modeName$ ?let modeName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let serviceFormalArgumentList
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioServiceListAST +=
      !serviceName
      !modeName
      !attributeList
      !serviceFormalArgumentList
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST serviceSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for service in self do
    routineSemanticAnalysis (
      !receiverType:inReceiverType
      !.service
      !{!service.mServiceMode}
      !service.mServiceName
 #     !service.mServiceAttributeList + @lstringlist {![globalAttribute () nowhere]}
      !service.mServiceFormalArgumentList
      !service.mServiceInstructionList
      !service.mEndOfServiceLocation
      !warnIfUnused:true
      !globalProcedure:true
      !weakProcedure:false
      !nullOnNoException:false
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR serviceCodeGeneration
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
{
#--- Generate service entries
  var idx = 0
  for service in self do
   if service.mKind == .service then
      let name = llvmNameForServiceCall (!service.lkey.string)
      var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-entry.s")
      s = [s stringByReplacingStringByString !"!ENTRY!" !name]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
      idx += 1
    end
  end
  ioAssemblerCode += getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-dispatcher-header.s")
  idx = 0
  for service in self do
    if service.mKind == .service then
      let serviceImplementationName = llvmNameForServiceImplementation (!service.lkey.string)
      var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-dispatcher-entry.s")
      s = [s stringByReplacingStringByString !"!ENTRY!" !serviceImplementationName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
      ioLLVMcode += llvmTitleComment (!serviceImplementationName)
      ioLLVMcode += "declare void @" + llvmNameForServiceCall (!service.lkey.string) + " ("
      let typeName = [service.lkey.string stringByDeletingPathExtension]
      var first = typeName == ""
      if not first then
        ioLLVMcode += "%" + typeName + "* %self"  
      end
      for () in service.mFormalArgumentListForGeneration do
        if first then first = false else ioLLVMcode += ", " end
        switch mFormalArgumentKind
        case input :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
        case output :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
       case inputOutput :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
        end
      end
      ioLLVMcode += ") nounwind \n\n"
      idx += 1
    end
  end
  ioAssemblerCode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

