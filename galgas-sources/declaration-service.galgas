#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @serviceDeclarationListAST {
  @lstring mServiceName
  @bool mPublic
  @lstringlist mServiceAttributeList
  @procFormalArgumentList mServiceFormalArgumentList
  @lstring mReturnTypeName
  @instructionListAST mServiceInstructionList
  @location mEndOfServiceLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <service> ?!@serviceDeclarationListAST ioServiceListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $service$
    $identifier$ ?let serviceName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let serviceFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      $typeName$ ?returnTypeName
    end
    ${$
    <instructionList> ?let instructionList !?*
    $}$
    ioServiceListAST +=
      !serviceName
      !public
      !attributeList
      !serviceFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST noteServiceTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mServiceFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mServiceInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for service in self do
  #--- Signature
    var routineMangledName = if inReceiverTypeName == "" then
      service.mServiceName
    else
      @lstring.new {!inReceiverTypeName + "." + service.mServiceName !service.mServiceName.location}
    end
    @procedureSignature signature = {}
    routineMangledName.string += "("
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in service.mServiceFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
      routineMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
    end
    routineMangledName.string += ")"
  #--- Mode map
    let @modeMap modeMap = {![userModeName () nowhere], ![serviceModeName () nowhere], ![kernelModeName () nowhere]}
  #--- Enter in context
    let returnType = if service.mReturnTypeName.string == "" then
      @unifiedTypeMap-proxy.null
    else
      @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !service.mReturnTypeName}
    end
    [!?ioContext.mRoutineMapForContext insertKey
      !routineMangledName
      !routineMangledName
      !service.mPublic
      !modeMap
      !signature
      !.service
      !false # Not weak
      !returnType
      !false # No appendFileAndLineArgumentForPanicLocation
      !true # Can mutate properties
      !true # canAccessPropertiesInUserMode
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST serviceSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for service in self do
    var warnIfUnused = true
    for (attribute) in service.mServiceAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicate @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      else
        error attribute : "unknown attribute; available attribute is @" + noUnusedWarningAttribute ()
      end
    end
    routineSemanticAnalysis (
      !receiverType:inReceiverType
      !.service
      !{![serviceModeName () nowhere], ![kernelModeName () nowhere]}
      !service.mServiceName
      !service.mServiceFormalArgumentList
      !returnTypeName:service.mReturnTypeName
      !service.mServiceInstructionList
      !service.mEndOfServiceLocation
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !warnIfUnused:warnIfUnused
      !globalFunction:true
      !weakFunction:false
      !registerAccess:.readWriteAccess
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR serviceCodeGeneration
  ?!@string ioLLVMcode
  ?!@2stringlist ioServiceList
{
  for service in self do
    if service.mKind == .service then
      let serviceImplementationName = llvmNameForServiceImplementation (!service.mRoutineNameForGeneration.string)
      let serviceCallName = llvmNameForServiceCall (!service.mRoutineNameForGeneration.string)
      ioServiceList += !serviceCallName !serviceImplementationName
      ioLLVMcode += llvmTitleComment (!serviceImplementationName)
      ioLLVMcode += "declare"
      if service.mReturnType == .null then
        ioLLVMcode += " void"
      else
        ioLLVMcode += " " + [service.mReturnType llvmTypeName]
      end
      ioLLVMcode += " @" + llvmNameForServiceCall (!service.lkey.string) + " ("
      let typeName = [service.lkey.string stringByDeletingPathExtension]
      var first = typeName == ""
      if not first then
        ioLLVMcode += "%" + [typeName assemblerRepresentation] + " * %self"  
      end
      for () in service.mFormalArgumentListForGeneration do
        if first then first = false else ioLLVMcode += ", " end
        switch mFormalArgumentKind
        case input :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
        case output :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + mFormalArgumentName
       case inputOutput :
          ioLLVMcode += [mFormalArgumentType llvmTypeName] + " * %" + mFormalArgumentName
        end
      end
      ioLLVMcode += ")" + llvmAttributeFunction () + "\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateServiceDispatcher
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?!@string ioAssemblerCode
  ?let @2stringlist inServiceList
{
  for (callName *) in inServiceList do (idx)
    var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-entry.s")
    s = [s stringByReplacingStringByString !"!ENTRY!" !callName]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
  ioAssemblerCode += getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-dispatcher-header.s")
  for (* implementationName) in inServiceList do (idx)
    var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-dispatcher-entry.s")
    s = [s stringByReplacingStringByString !"!ENTRY!" !implementationName]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
  ioAssemblerCode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

