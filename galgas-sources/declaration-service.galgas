#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @serviceDeclarationListAST {
  @lstring mServiceName
  @lstring mServiceMode
  @bool mMutating
  @lstringlist mServiceAttributeList
  @procFormalArgumentList mServiceFormalArgumentList
  @instructionListAST mServiceInstructionList
  @location mEndOfServiceLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <service> ?!@serviceDeclarationListAST ioServiceListAST {
    @bool mutating
    select
      mutating = false
    or
      $mutating$
      mutating = true
    end
    $service$
    $identifier$ ?let serviceName
    $modeName$ ?let modeName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let serviceFormalArgumentList
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioServiceListAST +=
      !serviceName
      !modeName
      !mutating
      !attributeList
      !serviceFormalArgumentList
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mServiceFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mServiceInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @serviceMap {
  @bool mMutating
  @procedureSignature mSignature

  insert insertKey error message "the '%K' service is already declared in %L"
  search searchKey error message "there is no '%K' service"
  remove removeKey error message "there is no '%K' service"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{

  for service in self do
    [service enterInContext !receiverType:inReceiverTypeName !?context:ioContext]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST-element enterInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
#--- Signature
  @procedureSignature signature = {}
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in mServiceFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
    signature += !formalArgumentPassingMode !selector.string !typeProxy
  end
#--- Enter in context
  let mangledServiceName = if inReceiverTypeName == "" then
    mServiceName
  else
    @lstring.new {!inReceiverTypeName + "." + mServiceName !mServiceName.location}
  end
  [!?ioContext.mServiceMap insertKey
    !mangledServiceName
    !mMutating
    !signature
  ]
  [!?ioContext.mSubProgramMap insertKey !mServiceName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST serviceSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for service in self do
    [service serviceSemanticAnalysis
      !receiverType:inReceiverType
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceDeclarationListAST-element serviceSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Attributes
  var warnIfUnused = true
  for (attribute) in mServiceAttributeList do
    if attribute.string == noWarningIfUnusedAttribute () then
      if not warnIfUnused then
        error attribute : "duplicate @" + noWarningIfUnusedAttribute () + " attribute"
      end
      warnIfUnused = false    
    else
      error attribute : "unknown attribute; available attribute is @" + noWarningIfUnusedAttribute ()
    end
  end
#--- Variable map
  let serviceNameForInvocationGraph = serviceNameForInvocationGraph (!inReceiverType !mServiceName)
  @variableMap variableMap = initialVariableMap (
    !routineNameForInvocation:serviceNameForInvocationGraph.string
    !context:inContext
    !userMode:false
    !globalsAreConstant:false
  )
#--- Analyse formal arguments
  @procFormalArgumentListForGeneration formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !mServiceFormalArgumentList
    !?variableMap
    !?formalArguments
  )
#--- Enter subprogram invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addNode
    !serviceNameForInvocationGraph
    !mServiceName
  ]
#--- Check mode
  if (mServiceMode.string != kernelModeName ()) && (mServiceMode.string != isrModeName ()) then
    error mServiceMode : "the mode should be `" + kernelModeName () + " or `" + isrModeName ()
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mServiceInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:serviceNameForInvocationGraph
    !context:inContext
    !modes:{!mServiceMode.string}
    !allowException:true
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfServiceLocation]
#--- Code generation
  let serviceMangledName = if inReceiverType == .null then
    mServiceName
  else
    @lstring.new {![inReceiverType key] + "." + mServiceName !mServiceName.location}
  end
  [!?ioIntermediateCodeStruct.mServiceMapIR insertKey
    !serviceMangledName
    !formalArguments
    !instructionGenerationList
    !warnIfUnused
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @serviceMapIR {
  @procFormalArgumentListForGeneration mFormalArgumentListForGeneration
  @instructionListIR mInstructionGenerationList
  @bool mWarnIfUnused
  insert insertKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceMapIR llvmCodeGeneration
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  for service in self do
    [service llvmCodeGeneration !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  end
#--- Generate service entries
  for service in self do (idx)
    let name = llvmNameForServiceCall (!service.lkey.string)
    var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-entry.s")
    s = [s stringByReplacingStringByString !"!ENTRY!" !name]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
  ioAssemblerCode += getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-dispatcher-header.s")
  for service in self do (idx)
    let name = llvmNameForServiceImplementation (!service.lkey.string)
    var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/service-dispatcher-entry.s")
    s = [s stringByReplacingStringByString !"!ENTRY!" !name]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let serviceImplementationName = llvmNameForServiceImplementation (!lkey.string)
  ioLLVMcode += llvmTitleComment (!serviceImplementationName)
  ioLLVMcode += "declare void @" + llvmNameForServiceCall (!lkey.string) + " ("
  let components = [lkey.string componentsSeparatedByString !"."]
  if [components length] == 2 then
    ioLLVMcode += "%struct." + [components mValueAtIndex !0] + "* %self"  
  end
  var first = [components length] != 2
  for () in mFormalArgumentListForGeneration do
    if first then first = false else ioLLVMcode += ", " end
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
    end
  end
  ioLLVMcode += ") nounwind \n\n"
  ioLLVMcode += "define void @" + serviceImplementationName + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ") nounwind {\n"
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  %" + mFormalArgumentName + " = alloca " + [mFormalArgumentType llvmTypeName] + "\n"
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + "* %" + mFormalArgumentName + "\n"
    case output, inputOutput :
    end
  end
#--- Instruction list
  [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Epilog
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

