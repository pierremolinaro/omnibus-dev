#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @operandIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @operandIR {
  @unifiedTypeMap-proxy mType
  @valueIR mValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @operandIRlist {
  @operandIR mOperand
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @valueIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @valueIR {
  case literalInteger  (@bigint value)
  case llvmLocalObject (@string name)
  case llvmStructureConstant (@operandIRList values)
  case literalString  (@uint size @uint index)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR llvmName -> @string outResult {
  switch self
  case literalInteger (@bigint value) : outResult = [value string]
  case llvmLocalObject (@string name) : outResult = "%" + name
  case llvmStructureConstant (@operandIRList inValues) :
    outResult = "{"
    for () in inValues
      do outResult += [mOperand.mType llvmTypeName] + " " + [mOperand.mValue llvmName]
      between outResult += ", "
    end
    outResult += "}"
  case literalString  (@uint size @uint index) :
    let sizeStr = [size string]
    outResult = "getelementptr inbounds ([" + sizeStr + " x i8], [" + sizeStr + " x i8]* "
    outResult += literalCharacterArrayName (!index) + ", i32 0, i32 0)"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR name -> @string outResult {
  switch self
  case literalInteger (@bigint value) : outResult = [value string]
  case llvmLocalObject (@string name) : outResult = name
  case llvmStructureConstant (*) : outResult = "{...}"
  case literalString  (* @uint index) : outResult = literalStringName (!index)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR isStatic -> @bool outResult {
  switch self
  case literalInteger (*) : outResult = true
  case llvmLocalObject (*) : outResult = false
  case llvmStructureConstant (*) : outResult = true
  case literalString  (* *) : outResult = true
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @objectInMemoryIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @objectInMemoryIR {
  case register (@unifiedTypeMap-proxy type @lstring name @bigint address)
  case globalVariable (@unifiedTypeMap-proxy type @string name @bool isVolatile)
  case localValue (@unifiedTypeMap-proxy type @string name)
  case globalConstant (@unifiedTypeMap-proxy type  @string name)

  case fieldAccess (@unifiedTypeMap-proxy objectType @string objectName @unifiedTypeMap-proxy fielfType @uint fieldIndex)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR name -> @string outName {
  switch self
  case register (* @lstring name *) :
    error name : "@objectInMemoryIR name" : outName
  case globalVariable (* @string name *) :
    outName = "@" + mangledNameForGlobalVariable (!name)
  case localValue (* @string name) :
    outName = "%" + mangledNameForLocalVariable (!name)
  case globalConstant (*  @string name) :
    outName = "%" + name
  case fieldAccess (@unifiedTypeMap-proxy unused objectType
                    @string unused objectName
                    @unifiedTypeMap-proxy unused fielfType
                    @uint unused fieldIndex) :
    error .nowhere : "@objectInMemoryIR name" : outName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR type -> @unifiedTypeMap-proxy outType {
  switch self
  case register (@unifiedTypeMap-proxy type * *) :
    outType = type
  case globalVariable (@unifiedTypeMap-proxy type * *) :
    outType = type
  case localValue (@unifiedTypeMap-proxy type *) :
    outType = type
  case globalConstant (@unifiedTypeMap-proxy type *) :
    outType = type
  case fieldAccess (@unifiedTypeMap-proxy unused objectType
                    @string unused objectName
                    @unifiedTypeMap-proxy unused fielfType
                    @uint unused fieldIndex) :
    error .nowhere : "@objectInMemoryIR name" : outType
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR address -> @operandIR outOperand {
  switch self
  case register (* * *) :
    error .nowhere : "@objectInMemoryIR address" : outOperand
  case globalVariable (* * *) :
    error .nowhere : "@objectInMemoryIR address" : outOperand
  case localValue (@unifiedTypeMap-proxy type @string name) :
    outOperand  = .new {!type !.llvmLocalObject {!name:mangledNameForLocalVariable (!name)}}
  case globalConstant (* *) :
    error .nowhere : "@objectInMemoryIR address" : outOperand
  case fieldAccess (@unifiedTypeMap-proxy unused objectType
                    @string unused objectName
                    @unifiedTypeMap-proxy unused fielfType
                    @uint unused fieldIndex) :
    error .nowhere : "@objectInMemoryIR address" : outOperand
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
