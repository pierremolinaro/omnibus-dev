#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @objectInMemoryIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @objectInMemoryIR {
  case registerAddress (@unifiedTypeMap-proxy type @string llvmName)
  case register (@unifiedTypeMap-proxy type
                 @lstring name
                 @bool readable
                 @bool writable
                 @bigint address
                 @controlRegisterBitSliceAccessMap sliceMap
                 @uint arraySize # 0 if not an array
                 @uint elementSize) # 0 if not an array
  case globalVariable (@unifiedTypeMap-proxy type @string name @bool volatile)
  case localVariable (@unifiedTypeMap-proxy type @string name)
  case staticConstant (@valueIR value @lstring name)
  case property (@unifiedTypeMap-proxy type @string name @uint index)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @objectInMemoryIR checkReadable {
  switch self
  case registerAddress (* *) :
  case register (* @lstring name @bool readable * * * * *) :
    if not readable then
      error name : "the control register cannot be read in current context"
    end
  case globalVariable (* * *) :
  case localVariable (* *) :
  case staticConstant (* *) :
  case property (* * *) :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @objectInMemoryIR checkWriteable {
  switch self
  case registerAddress (* @string unused llvmName) :
  case register (* @lstring unused name * @bool writable * * * *) :
    if not writable then
      error name : "the control register cannot be written in current context"
    end
  case globalVariable (* @string unused name *) :
  case localVariable (* @string unused name) :
  case staticConstant (*  @lstring name) :
    error name : "a constante cannot be modified"
  case property (* * *) :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR llvmName -> @string outName {
  switch self
  case registerAddress (* @string llvmName) :
    outName = llvmName
  case register (* @lstring name * * * * * *) :
    error name : "@objectInMemoryIR name" : outName
  case globalVariable (* @string name *) :
    outName = "@" + llvmNameForGlobalVariable (!name)
  case localVariable (* @string name) :
    outName = "%" + llvmNameForLocalVariable (!name)
  case staticConstant (*  @lstring name) :
    outName = "%" + name
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR llvmName>>" : outName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR name -> @string outName {
  switch self
  case registerAddress (* @string llvmName) :
    outName = llvmName
  case register (* @lstring name * * * * * *) :
    outName = name.string
  case globalVariable (* @string name *) :
    outName = name
  case localVariable (* @string name) :
    outName = name
  case staticConstant (*  @lstring name) :
    outName = name
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR name>>" : outName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR type -> @unifiedTypeMap-proxy outType {
  switch self
  case registerAddress (@unifiedTypeMap-proxy type *) :
    outType = type
  case register (@unifiedTypeMap-proxy type * * * * * * *) :
    outType = type
  case globalVariable (@unifiedTypeMap-proxy type * *) :
    outType = type
  case localVariable (@unifiedTypeMap-proxy type *) :
    outType = type
  case staticConstant (@valueIR value *) :
    outType = [value type]
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR type>>" : outType
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR address -> @valueIR outOperand {
  switch self
  case registerAddress (* *) :
    error .nowhere : "@objectInMemoryIR register address" : outOperand
  case register ( * ** * * * * *) :
    error .nowhere : "@objectInMemoryIR register address" : outOperand
  case globalVariable (@unifiedTypeMap-proxy type @string name *) :
    outOperand  = .llvmGlobalObject {!type: type !name:llvmNameForGlobalVariable (!name)}
  case localVariable (@unifiedTypeMap-proxy type @string name) :
    outOperand  = .llvmLocalObject {!type:type !name:llvmNameForLocalVariable (!name)}
  case staticConstant (* *) :
    error .nowhere : "@objectInMemoryIR globalConstantaddress" : outOperand
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR address>>" : outOperand
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @valueIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @valueIR {
  case selfObject (@unifiedTypeMap-proxy type)
  case literalInteger  (@unifiedTypeMap-proxy type @bigint value)
  case llvmLocalObject (@unifiedTypeMap-proxy type @string name)
  case llvmGlobalObject (@unifiedTypeMap-proxy type @string name)
  case llvmStructureConstant (@unifiedTypeMap-proxy type @operandIRList values)
  case literalString  (@unifiedTypeMap-proxy type @uint size @uint index)
  case zero (@unifiedTypeMap-proxy type)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR llvmName -> @string outResult {
  switch self
  case zero (*) : outResult = "zeroinitializer"
  case selfObject (*) : outResult = "%self"
  case literalInteger (* @bigint value) : outResult = [value string]
  case llvmLocalObject (* @string name) : outResult = "%" + name
  case llvmGlobalObject (* @string name) : outResult = "@" + name
  case llvmStructureConstant (* @operandIRList inValues) :
    outResult = "{"
    for () in inValues
      do outResult += [mOperand llvmTypeName] + " " + [mOperand llvmName]
      between outResult += ", "
    end
    outResult += "}"
  case literalString  (* @uint size @uint index) :
    let sizeStr = [size string]
    outResult = "getelementptr inbounds ([" + sizeStr + " x i8], [" + sizeStr + " x i8]* "
    outResult += literalCharacterArrayName (!index) + ", i32 0, i32 0)"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR type -> @unifiedTypeMap-proxy outResult {
  switch self
  case zero (type) : outResult = type
  case selfObject (type) : outResult = type
  case literalInteger (type *) : outResult = type
  case llvmLocalObject (type *) : outResult = type
  case llvmGlobalObject (type *) : outResult = type
  case llvmStructureConstant (type *) : outResult = type
  case literalString  (type * *) : outResult = type
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR llvmTypeName -> @string outResult {
  outResult = [[self type] llvmTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR key -> @string outResult {
  outResult = [[self type] key]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR kind -> @typeKind outResult {
  outResult = [[self type] kind]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR withType ?@unifiedTypeMap-proxy inType -> @valueIR outResult {
  switch self
  case literalInteger (* @bigint value) :
    outResult = .literalInteger {!type: inType !value: value}
  case llvmLocalObject (* @string name) :
    outResult = .llvmLocalObject {!type: inType !name: name}
  case zero (*) :
    outResult = .zero {!type: inType}
  case selfObject (*) :
    outResult = .selfObject {!type: inType}
  case llvmGlobalObject (* @string name) :
    outResult = .llvmGlobalObject {!type: inType !name: name}
  case llvmStructureConstant (* @operandIRList values) :
    outResult = .llvmStructureConstant {!type: inType !values: values}
  case literalString  (* @uint size @uint index) :
    outResult = .literalString {!type: inType !size: size !index: index}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR name -> @string outResult {
  switch self
  case zero (*) : outResult = "zeroinitializer"
  case selfObject (*) : outResult = "self"
  case literalInteger (* @bigint value) : outResult = [value string]
  case llvmLocalObject (* @string name) : outResult = name
  case llvmGlobalObject (* @string name) : outResult = name
  case llvmStructureConstant (* *) : outResult = "{...}"
  case literalString  (* * @uint index) : outResult = literalStringName (!index)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @valueIR isStatic -> @bool outResult {
  switch self
  case zero (*) : outResult = true
  case selfObject (*) : outResult = false
  case literalInteger (* *) : outResult = true
  case llvmLocalObject (* *) : outResult = false
  case llvmGlobalObject (* *) : outResult = false
  case llvmStructureConstant (* *) : outResult = true
  case literalString  (* * *) : outResult = true
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
