#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @objectInMemoryIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @objectInMemoryIR {
  case registerAddress (@unifiedTypeMap-proxy type @string llvmName)
  case register (@unifiedTypeMap-proxy type
                 @lstring plmName
                 @bool readable
                 @bool writable
                 @bigint address
                 @sliceMap sliceMap
                 @uint arraySize # 0 if not an array
                 @uint elementSize) # 0 if not an array
  case globalVariable (@unifiedTypeMap-proxy type @string name @bool volatile)
  case localVariable (@unifiedTypeMap-proxy type @string name @bool volatile)
  case staticConstant (@objectIR value @lstring name)
  case property (@unifiedTypeMap-proxy type @string name @uint index)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @objectInMemoryIR checkReadable {
  switch self
  case registerAddress (* *) :
  case register (* @lstring name @bool readable * * * * *) :
    if not readable then
      error name : "the control register cannot be read in current context"
    end
  case globalVariable (* * *) :
  case localVariable (* * *) :
  case staticConstant (* *) :
  case property (* * *) :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @objectInMemoryIR checkWriteable {
  switch self
  case registerAddress (* @string unused llvmName) :
  case register (* @lstring unused name * @bool writable * * * *) :
    if not writable then
      error name : "the control register cannot be written in current context"
    end
  case globalVariable (* @string unused name *) :
  case localVariable (* @string unused name *) :
  case staticConstant (*  @lstring name) :
    error name : "a constante cannot be modified"
  case property (* * *) :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR llvmName -> @string outName {
  switch self
  case registerAddress (* @string llvmName) :
    outName = llvmName
  case register (* @lstring name * * * * * *) :
    error name : "@objectInMemoryIR name" : outName
  case globalVariable (* @string name *) :
    outName = "@" + llvmNameForGlobalVariable (!name)
  case localVariable (* @string name *) :
    outName = "%" + llvmNameForLocalVariable (!name)
  case staticConstant (*  @lstring name) :
    outName = "%" + name
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR llvmName>>" : outName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR name -> @string outName {
  switch self
  case registerAddress (* @string llvmName) :
    outName = llvmName
  case register (* @lstring name * * * * * *) :
    outName = name.string
  case globalVariable (* @string name *) :
    outName = name
  case localVariable (* @string name *) :
    outName = name
  case staticConstant (*  @lstring name) :
    outName = name
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR name>>" : outName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR type -> @unifiedTypeMap-proxy outType {
  switch self
  case registerAddress (@unifiedTypeMap-proxy type *) :
    outType = type
  case register (@unifiedTypeMap-proxy type * * * * * * *) :
    outType = type
  case globalVariable (@unifiedTypeMap-proxy type * *) :
    outType = type
  case localVariable (@unifiedTypeMap-proxy type * *) :
    outType = type
  case staticConstant (@objectIR value *) :
    outType = [value type]
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR type>>" : outType
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR address -> @objectIR outOperand {
  switch self
  case registerAddress (* *) :
    error .nowhere : "@objectInMemoryIR register address" : outOperand
  case register ( * ** * * * * *) :
    error .nowhere : "@objectInMemoryIR register address" : outOperand
  case globalVariable (@unifiedTypeMap-proxy type @string name *) :
    outOperand  = .llvmGlobalObjectValue {!type: type !llvmName:llvmNameForGlobalVariable (!name)}
  case localVariable (@unifiedTypeMap-proxy type @string name *) :
    outOperand  = .llvmTemporaryValue {!type:type !llvmName:llvmNameForLocalVariable (!name) !sliceMap:{}}
  case staticConstant (* *) :
    error .nowhere : "@objectInMemoryIR globalConstantaddress" : outOperand
  case property (* * *) :
    error .nowhere : "<<@objectInMemoryIR address>>" : outOperand
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @objectIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @objectIR {
#--- Temporary ?
  case selfObject (@unifiedTypeMap-proxy type)
  case llvmGlobalObjectValue (@unifiedTypeMap-proxy type @string llvmName)
#--- References
  case globalVariableReference (@unifiedTypeMap-proxy type @string plmName)
  case localVariableReference (@unifiedTypeMap-proxy type @string plmName)
  case registerReference (@unifiedTypeMap-proxy type
                          @lstring plmName
                          @bool readable
                          @bool writable
                          @bigint address
                          @sliceMap sliceMap
                          @uint arraySize # 0 if not an array
                          @uint elementSize) # 0 if not an array
#--- Values
  case llvmTemporaryValue (@unifiedTypeMap-proxy type @string llvmName @sliceMap sliceMap)
  case literalInteger  (@unifiedTypeMap-proxy type @bigint value)
  case llvmStructureConstant (@unifiedTypeMap-proxy type @operandIRList values)
  case literalString  (@unifiedTypeMap-proxy type @uint size @uint index)
  case zero (@unifiedTypeMap-proxy type)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR llvmName -> @string outResult {
  switch self
  case globalVariableReference (**) : error .nowhere : "<<@objectIR llvmName>>" : outResult
  case localVariableReference (**) : error .nowhere : "<<@objectIR llvmName>>" : outResult
  case registerReference (********): error .nowhere : "<<@objectIR llvmName>>" : outResult
  case zero (*) : outResult = "zeroinitializer"
  case selfObject (*) : outResult = "%self"
  case literalInteger (* @bigint value) : outResult = [value string]
  case llvmTemporaryValue (* @string name *) : outResult = "%" + name
  case llvmGlobalObjectValue (* @string name) : outResult = "@" + name
  case llvmStructureConstant (* @operandIRList inValues) :
    outResult = "{"
    for () in inValues
      do outResult += [mOperand llvmTypeName] + " " + [mOperand llvmName]
      between outResult += ", "
    end
    outResult += "}"
  case literalString  (* @uint size @uint index) :
    let sizeStr = [size string]
    outResult = "getelementptr inbounds ([" + sizeStr + " x i8], [" + sizeStr + " x i8]* "
    outResult += literalCharacterArrayName (!index) + ", i32 0, i32 0)"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR type -> @unifiedTypeMap-proxy outResult {
  switch self
  case registerReference (type *******) : outResult = type
  case globalVariableReference (type *) : outResult = type
  case localVariableReference (type *) : outResult = type
  case zero (type) : outResult = type
  case selfObject (type) : outResult = type
  case literalInteger (type *) : outResult = type
  case llvmTemporaryValue (type * *) : outResult = type
  case llvmGlobalObjectValue (type *) : outResult = type
  case llvmStructureConstant (type *) : outResult = type
  case literalString  (type * *) : outResult = type
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR llvmTypeName -> @string outResult {
  outResult = [[self type] llvmTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR key -> @string outResult {
  outResult = [[self type] key]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR kind -> @typeKind outResult {
  outResult = [[self type] kind]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR withType ?@unifiedTypeMap-proxy inType -> @objectIR outResult {
  switch self
  case registerReference (* plmName readable writable address sliceMap arraySize elementSize) :
    outResult = .registerReference {
      !type: inType
      !plmName: plmName
      !readable: readable
      !writable: writable
      !address: address
      !sliceMap: sliceMap
      !arraySize: arraySize
      !elementSize: elementSize
    }
  case localVariableReference (* name) :
    outResult = .localVariableReference {!type: inType !plmName: name}
  case globalVariableReference (* name) :
    outResult = .globalVariableReference {!type: inType !plmName: name}
  case literalInteger (* @bigint value) :
    outResult = .literalInteger {!type: inType !value: value}
  case llvmTemporaryValue (* @string llvmName sliceMap) :
    outResult = .llvmTemporaryValue {!type: inType !llvmName:llvmName  !sliceMap:sliceMap}
  case zero (*) :
    outResult = .zero {!type: inType}
  case selfObject (*) :
    outResult = .selfObject {!type: inType}
  case llvmGlobalObjectValue (* @string llvmName) :
    outResult = .llvmGlobalObjectValue {!type: inType !llvmName: llvmName}
  case llvmStructureConstant (* @operandIRList values) :
    outResult = .llvmStructureConstant {!type: inType !values: values}
  case literalString  (* @uint size @uint index) :
    outResult = .literalString {!type: inType !size: size !index: index}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR name -> @string outResult {
  switch self
  case registerReference (* name ******) : outResult = name
  case localVariableReference (* name) : outResult = name
  case globalVariableReference (* name) : outResult = name
  case zero (*) : outResult = "zeroinitializer"
  case selfObject (*) : outResult = "self"
  case literalInteger (* @bigint value) : outResult = [value string]
  case llvmTemporaryValue (* @string name *) : outResult = name
  case llvmGlobalObjectValue (* @string name) : outResult = name
  case llvmStructureConstant (* *) : outResult = "{...}"
  case literalString  (* * @uint index) : outResult = literalStringName (!index)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR isStatic -> @bool outResult {
  switch self
  case registerReference (* *******) : outResult = false
  case localVariableReference (* *) : outResult = false
  case globalVariableReference (* *) : outResult = false
  case zero (*) : outResult = true
  case selfObject (*) : outResult = false
  case literalInteger (* *) : outResult = true
  case llvmTemporaryValue (* * *) : outResult = false
  case llvmGlobalObjectValue (* *) : outResult = false
  case llvmStructureConstant (* *) : outResult = true
  case literalString  (* * *) : outResult = true
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
