#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @objectIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#enum @objectIR {
##--- No object
#  case null
##--- References
#  case selfObject (@unifiedTypeMap-proxy type)
#  case globalVariableReference (@unifiedTypeMap-proxy type @lstring plmName)
#  case localVariableReference (@unifiedTypeMap-proxy type @lstring plmName)
#  case temporaryReference (@unifiedTypeMap-proxy type @lstring llvmName @sliceMap sliceMap @bool volatile)
#  case registerReference (@unifiedTypeMap-proxy type
#                          @lstring plmName
#                          @bool readable
#                          @bool writable
#                          @bigint address
#                          @sliceMap sliceMap
#                          @uint arraySize # 0 if not an array
#                          @uint elementSize) # 0 if not an array
##--- Structure property
#  case property (@unifiedTypeMap-proxy type @lstring plmName @uint index)
##--- Values
#  case llvmTemporaryValue (@unifiedTypeMap-proxy type @lstring llvmName @sliceMap sliceMap)
#  case literalInteger  (@unifiedTypeMap-proxy type @bigint value)
#  case llvmStructureConstant (@unifiedTypeMap-proxy type @operandIRList values)
#  case literalString  (@unifiedTypeMap-proxy type @uint size @uint index)
#  case zero (@unifiedTypeMap-proxy type)
##--- Function
#  case possibleFunction (@objectIR receiver @lstring functionName)
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR location -> @location {
#  switch self
#  case null :
#    error .nowhere : "<<@objectIR location null>>" : result
#  case possibleFunction (* functionName) :
#    result = functionName
#  case property (* plmName *) :
#    result = plmName
#  case globalVariableReference (* plmName) :
#    result = plmName
#  case localVariableReference (* plmName) :
#    result = plmName
#  case registerReference (* plmName ******):
#    result = plmName
#  case zero (*) :
#    error .nowhere : "<<@objectIR location zero>>" : result
#  case selfObject (*) :
#    error .nowhere : "<<@objectIR location selfObject>>" : result
#  case literalInteger (* *) :
#    error .nowhere : "<<@objectIR location literalInteger>>" : result
#  case llvmTemporaryValue (* llvmName *) :
#    result = llvmName
#  case temporaryReference (* llvmName * *) :
#    result = llvmName
#  case llvmStructureConstant (* *) :
#    error .nowhere : "<<@objectIR location llvmStructureConstant>>" : result
#  case literalString  (* * *) :
#    error .nowhere : "<<@objectIR location literalString>>" : result
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR isGlobalVariable -> @bool {
#  result = [self isGlobalVariableReference]
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR llvmName -> @string {
#  switch self
#  case null : error [self location] : "<<@objectIR llvmName null>>" : result
#  case possibleFunction (**) :
#    error [self location] : "<<@objectIR llvmName possibleFunction>>" : result
#  case property (***) : error [self location] : "<<@objectIR property llvmName>>" : result
#  case globalVariableReference (* plmName) : result = "@" + llvmNameForGlobalVariable (!plmName)
#  case localVariableReference (* plmName) : result = "%" + llvmNameForLocalVariable (!plmName)
#  case registerReference (********): error [self location] : "<<@objectIR llvmName>>" : result
#  case zero (*) : result = "zeroinitializer"
#  case selfObject (*) : result = "%self"
#  case literalInteger (* @bigint value) : result = [value string]
#  case llvmTemporaryValue (* llvmName *) : result = "%" + llvmName
#  case temporaryReference (* llvmName * *) : result = "%" + llvmName
#  case llvmStructureConstant (* @operandIRList inValues) :
#    result = "{"
#    for () in inValues
#      do result += [mOperand llvmTypeName] + " " + [mOperand llvmName]
#      between result += ", "
#    end
#    result += "}"
#  case literalString  (* @uint size @uint index) :
#    let sizeStr = [size string]
#    result = "getelementptr inbounds ([" + sizeStr + " x i8], [" + sizeStr + " x i8]* "
#    result += literalCharacterArrayName (!index) + ", i32 0, i32 0)"
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR sliceMap ?let @location inErrorLocation -> @sliceMap {
#  switch self
#  case null : error [self location] : "<<@objectIR sliceMap null>>" : result
#  case possibleFunction (**) :
#    error [self location] : "<<@objectIR sliceMap possibleFunction>>" : result
#  case property (***) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case globalVariableReference (**) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case localVariableReference (* *) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case registerReference (***** sliceMap **): result = sliceMap
#  case zero (*) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case selfObject (*) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case literalInteger (* *) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case llvmTemporaryValue (* * sliceMap) : result = sliceMap
#  case temporaryReference (* * sliceMap *) : result = sliceMap
#  case llvmStructureConstant (* *) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  case literalString  (* * *) : error inErrorLocation : "<<@objectIR sliceMap>>" : result
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR type -> @unifiedTypeMap-proxy {
#  switch self
#  case null : result = .null
#  case possibleFunction (**) :
#    error [self location] : "<<@objectIR type possibleFunction>>" : result
#  case temporaryReference (@unifiedTypeMap-proxy type * * *) : result = type
#  case property (type **) : result = type
#  case registerReference (type *******) : result = type
#  case globalVariableReference (type *) : result = type
#  case localVariableReference (type *) : result = type
#  case zero (type) : result = type
#  case selfObject (type) : result = type
#  case literalInteger (type *) : result = type
#  case llvmTemporaryValue (type * *) : result = type
#  case llvmStructureConstant (type *) : result = type
#  case literalString  (type * *) : result = type
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR llvmTypeName -> @string {
#  result = [[self kind] llvmTypeName]
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR key -> @string {
#  result = [[self type] key]
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR kind -> @typeKind {
#  switch self
#  case null :
#    error [self location] : "<<@objectIR kind null>>" : result
#  case possibleFunction (**) :
#    error [self location] : "<<@objectIR kind possibleFunction>>" : result
#  case temporaryReference (@unifiedTypeMap-proxy type * * *) : result = [type kind]
#  case property (type **) : result = [type kind]
#  case registerReference (type *******) : result = [type kind]
#  case globalVariableReference (type *) : result = [type kind]
#  case localVariableReference (type *) : result = [type kind]
#  case zero (type) : result = [type kind]
#  case selfObject (type) : result = [type kind]
#  case literalInteger (type *) : result = [type kind]
#  case llvmTemporaryValue (type * *) : result = [type kind]
#  case llvmStructureConstant (type *) : result = [type kind]
#  case literalString  (type * *) : result = [type kind]
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR withType ?let @unifiedTypeMap-proxy inType -> @objectIR {
#  switch self
#  case null : error [self location] : "<<@objectIR withType null>>" : result
#  case possibleFunction (**) :
#    error [self location] : "<<@objectIR withType possibleFunction>>" : result
#  case temporaryReference (* llvmName sliceMap volatile) :
#    result = .temporaryReference {!type:inType !llvmName:llvmName !sliceMap:sliceMap !volatile:volatile}
#  case property (* plmName index) :
#    result = .property {!type:inType !plmName:plmName !index:index}
#  case registerReference (* plmName readable writable address sliceMap arraySize elementSize) :
#    result = .registerReference {
#      !type: inType
#      !plmName: plmName
#      !readable: readable
#      !writable: writable
#      !address: address
#      !sliceMap: sliceMap
#      !arraySize: arraySize
#      !elementSize: elementSize
#    }
#  case localVariableReference (* name) :
#    result = .localVariableReference {!type: inType !plmName: name}
#  case globalVariableReference (* name) :
#    result = .globalVariableReference {!type: inType !plmName: name}
#  case literalInteger (* @bigint value) :
#    result = .literalInteger {!type: inType !value: value}
#  case llvmTemporaryValue (* llvmName sliceMap) :
#    result = .llvmTemporaryValue {!type: inType !llvmName:llvmName  !sliceMap:sliceMap}
#  case zero (*) :
#    result = .zero {!type: inType}
#  case selfObject (*) :
#    result = .selfObject {!type: inType}
#  case llvmStructureConstant (* @operandIRList values) :
#    result = .llvmStructureConstant {!type: inType !values: values}
#  case literalString  (* @uint size @uint index) :
#    result = .literalString {!type: inType !size: size !index: index}
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR name -> @string {
#  switch self
#  case null : error [self location] : "<<@objectIR name null>>" : result
#  case possibleFunction (**) :
#    error [self location] : "<<@objectIR name possibleFunction>>" : result
#  case temporaryReference (* llvmName **) : result = llvmName
#  case property (* name *) : result = name
#  case registerReference (* name ******) : result = name
#  case localVariableReference (* name) : result = name
#  case globalVariableReference (* name) : result = name
#  case zero (*) : result = "zeroinitializer"
#  case selfObject (*) : result = "self"
#  case literalInteger (* @bigint value) : result = [value string]
#  case llvmTemporaryValue (* name *) : result = name
#  case llvmStructureConstant (* *) : result = "{...}"
#  case literalString  (* * @uint index) : result = literalStringName (!index)
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#getter @objectIR isStatic -> @bool {
#  switch self
#  case null : error [self location] : "<<@objectIR isStatic null>>" : result
#  case possibleFunction (**) : result = false
#  case temporaryReference (****) : result = false
#  case property (***) : result = false
#  case registerReference (* *******) : result = false
#  case localVariableReference (* *) : result = false
#  case globalVariableReference (* *) : result = false
#  case zero (*) : result = true
#  case selfObject (*) : result = false
#  case literalInteger (* *) : result = true
#  case llvmTemporaryValue (* * *) : result = false
#  case llvmStructureConstant (* *) : result = true
#  case literalString  (* * *) : result = true
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
