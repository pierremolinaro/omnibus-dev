#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @objectIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @objectIR {
#--- References
  case selfObject (@unifiedTypeMap-proxy type)
  case globalVariableReference (@unifiedTypeMap-proxy type @lstring plmName)
  case localVariableReference (@unifiedTypeMap-proxy type @lstring plmName)
  case temporaryReference (@unifiedTypeMap-proxy type @lstring llvmName @sliceMap sliceMap @bool volatile)
  case registerReference (@unifiedTypeMap-proxy type
                          @lstring plmName
                          @bool readable
                          @bool writable
                          @bigint address
                          @sliceMap sliceMap
                          @uint arraySize # 0 if not an array
                          @uint elementSize) # 0 if not an array
#--- Structure property
  case property (@unifiedTypeMap-proxy type @lstring plmName @uint index)
#--- Values
  case llvmTemporaryValue (@unifiedTypeMap-proxy type @lstring llvmName @sliceMap sliceMap)
  case literalInteger  (@unifiedTypeMap-proxy type @bigint value)
  case llvmStructureConstant (@unifiedTypeMap-proxy type @operandIRList values)
  case literalString  (@unifiedTypeMap-proxy type @uint size @uint index)
  case zero (@unifiedTypeMap-proxy type)
#--- Function
  case possibleFunction (@objectIR receiver @lstring functionName)
  case null
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR location -> @location outResult {
  switch self
  case null :
    error .nowhere : "<<@objectIR location null>>" : outResult
  case possibleFunction (* functionName) :
    outResult = functionName
  case property (* plmName *) :
    outResult = plmName
  case globalVariableReference (* plmName) :
    outResult = plmName
  case localVariableReference (* plmName) :
    outResult = plmName
  case registerReference (* plmName ******):
    outResult = plmName
  case zero (*) :
    error .nowhere : "<<@objectIR location zero>>" : outResult
  case selfObject (*) :
    error .nowhere : "<<@objectIR location selfObject>>" : outResult
  case literalInteger (* *) :
    error .nowhere : "<<@objectIR location literalInteger>>" : outResult
  case llvmTemporaryValue (* llvmName *) :
    outResult = llvmName
  case temporaryReference (* llvmName * *) :
    outResult = llvmName
  case llvmStructureConstant (* *) :
    error .nowhere : "<<@objectIR location llvmStructureConstant>>" : outResult
  case literalString  (* * *) :
    error .nowhere : "<<@objectIR location literalString>>" : outResult
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR isGlobalVariable -> @bool outResult {
  outResult = [self isGlobalVariableReference]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR llvmName -> @string outResult {
  switch self
  case null : error [self location] : "<<@objectIR llvmName null>>" : outResult
  case possibleFunction (**) :
    error [self location] : "<<@objectIR llvmName possibleFunction>>" : outResult
  case property (***) : error [self location] : "<<@objectIR llvmName>>" : outResult
  case globalVariableReference (* plmName) : outResult = "@" + llvmNameForGlobalVariable (!plmName)
  case localVariableReference (* plmName) : outResult = "%" + llvmNameForLocalVariable (!plmName)
  case registerReference (********): error [self location] : "<<@objectIR llvmName>>" : outResult
  case zero (*) : outResult = "zeroinitializer"
  case selfObject (*) : outResult = "%self"
  case literalInteger (* @bigint value) : outResult = [value string]
  case llvmTemporaryValue (* llvmName *) : outResult = "%" + llvmName
  case temporaryReference (* llvmName * *) : outResult = "%" + llvmName
  case llvmStructureConstant (* @operandIRList inValues) :
    outResult = "{"
    for () in inValues
      do outResult += [mOperand llvmTypeName] + " " + [mOperand llvmName]
      between outResult += ", "
    end
    outResult += "}"
  case literalString  (* @uint size @uint index) :
    let sizeStr = [size string]
    outResult = "getelementptr inbounds ([" + sizeStr + " x i8], [" + sizeStr + " x i8]* "
    outResult += literalCharacterArrayName (!index) + ", i32 0, i32 0)"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR sliceMap ?let @location inErrorLocation -> @sliceMap outResult {
  switch self
  case null : error [self location] : "<<@objectIR sliceMap null>>" : outResult
  case possibleFunction (**) :
    error [self location] : "<<@objectIR sliceMap possibleFunction>>" : outResult
  case property (***) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case globalVariableReference (**) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case localVariableReference (* *) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case registerReference (***** sliceMap **): outResult = sliceMap
  case zero (*) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case selfObject (*) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case literalInteger (* *) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case llvmTemporaryValue (* * sliceMap) : outResult = sliceMap
  case temporaryReference (* * sliceMap *) : outResult = sliceMap
  case llvmStructureConstant (* *) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  case literalString  (* * *) : error inErrorLocation : "<<@objectIR sliceMap>>" : outResult
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR type -> @unifiedTypeMap-proxy outResult {
  switch self
  case null : outResult = .null
  case possibleFunction (**) :
    error [self location] : "<<@objectIR type possibleFunction>>" : outResult
  case temporaryReference (@unifiedTypeMap-proxy type * * *) : outResult = type
  case property (type **) : outResult = type
  case registerReference (type *******) : outResult = type
  case globalVariableReference (type *) : outResult = type
  case localVariableReference (type *) : outResult = type
  case zero (type) : outResult = type
  case selfObject (type) : outResult = type
  case literalInteger (type *) : outResult = type
  case llvmTemporaryValue (type * *) : outResult = type
  case llvmStructureConstant (type *) : outResult = type
  case literalString  (type * *) : outResult = type
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR llvmTypeName -> @string outResult {
  outResult = [[self type] llvmTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR key -> @string outResult {
  outResult = [[self type] key]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR kind -> @typeKind outResult {
  outResult = [[self type] kind]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR withType ?@unifiedTypeMap-proxy inType -> @objectIR outResult {
  switch self
  case null : error [self location] : "<<@objectIR withType null>>" : outResult
  case possibleFunction (**) :
    error [self location] : "<<@objectIR withType possibleFunction>>" : outResult
  case temporaryReference (* llvmName sliceMap volatile) :
    outResult = .temporaryReference {!type:inType !llvmName:llvmName !sliceMap:sliceMap !volatile:volatile}
  case property (* plmName index) :
    outResult = .property {!type:inType !plmName:plmName !index:index}
  case registerReference (* plmName readable writable address sliceMap arraySize elementSize) :
    outResult = .registerReference {
      !type: inType
      !plmName: plmName
      !readable: readable
      !writable: writable
      !address: address
      !sliceMap: sliceMap
      !arraySize: arraySize
      !elementSize: elementSize
    }
  case localVariableReference (* name) :
    outResult = .localVariableReference {!type: inType !plmName: name}
  case globalVariableReference (* name) :
    outResult = .globalVariableReference {!type: inType !plmName: name}
  case literalInteger (* @bigint value) :
    outResult = .literalInteger {!type: inType !value: value}
  case llvmTemporaryValue (* llvmName sliceMap) :
    outResult = .llvmTemporaryValue {!type: inType !llvmName:llvmName  !sliceMap:sliceMap}
  case zero (*) :
    outResult = .zero {!type: inType}
  case selfObject (*) :
    outResult = .selfObject {!type: inType}
  case llvmStructureConstant (* @operandIRList values) :
    outResult = .llvmStructureConstant {!type: inType !values: values}
  case literalString  (* @uint size @uint index) :
    outResult = .literalString {!type: inType !size: size !index: index}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR name -> @string outResult {
  switch self
  case null : error [self location] : "<<@objectIR name null>>" : outResult
  case possibleFunction (**) :
    error [self location] : "<<@objectIR name possibleFunction>>" : outResult
  case temporaryReference (* llvmName **) : outResult = llvmName
  case property (* name *) : outResult = name
  case registerReference (* name ******) : outResult = name
  case localVariableReference (* name) : outResult = name
  case globalVariableReference (* name) : outResult = name
  case zero (*) : outResult = "zeroinitializer"
  case selfObject (*) : outResult = "self"
  case literalInteger (* @bigint value) : outResult = [value string]
  case llvmTemporaryValue (* name *) : outResult = name
  case llvmStructureConstant (* *) : outResult = "{...}"
  case literalString  (* * @uint index) : outResult = literalStringName (!index)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectIR isStatic -> @bool outResult {
  switch self
  case null : error [self location] : "<<@objectIR isStatic null>>" : outResult
  case possibleFunction (**) : outResult = false
  case temporaryReference (****) : outResult = false
  case property (***) : outResult = false
  case registerReference (* *******) : outResult = false
  case localVariableReference (* *) : outResult = false
  case globalVariableReference (* *) : outResult = false
  case zero (*) : outResult = true
  case selfObject (*) : outResult = false
  case literalInteger (* *) : outResult = true
  case llvmTemporaryValue (* * *) : outResult = false
  case llvmStructureConstant (* *) : outResult = true
  case literalString  (* * *) : outResult = true
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
