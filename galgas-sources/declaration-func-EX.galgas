#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @mode mMode
  @bool mPublicFunction
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @routineFormalArgumentListAST mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    if mFunctionReturnTypeName.string != "" then
      [!?ioGraph noteNode !mFunctionReturnTypeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST enterStandaloneFunctionsInContext 
  ?!context:@semanticContext ioContext
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
{
  for function in self do
  #--- Signature
    routineTypedSignature (!?ioContext.mTypeMap !function.mFunctionFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !function.mFunctionReturnTypeName ?let returnTypeProxy]
  #--- Attributes
    var warnIfUnused = true
    var exportedFunction = false
    var canMutateProperties = false
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == exportedAttribute () then
        if exportedFunction then
          error attribute : "duplicated @" + exportedAttribute () + " attribute"
        end
        exportedFunction = true
      elsif attribute.string == mutatingAttribute () then
        if canMutateProperties then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        canMutateProperties = true
      else
        error attribute : "unknown attribute; available attributes are @"
          + noUnusedWarningAttribute () + ", @" + noUnusedWarningAttribute () + " and @" + exportedAttribute ()
      end
    end
  #--- Routine mangled name
    let functionLLVMName = routineMangledNameFromAST (
      !"" 
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
    )
  #--- Enter in routine map
    let routineLLVMNameDict = [function.mMode routineLLVMDictionaryForFunction !functionLLVMName]
    let routineMangledName = [signature mangledName !receiverTypeName: "" !functionName: function.mFunctionName]
    [!?ioContext.mRoutineMap insertKey
      !routineMangledName
      !function.mPublicFunction
      !signature
      !returnTypeProxy
      !routineLLVMNameDict
      !exportedFunction
      !function.mMode
    ]
  #---------------- Add decorated declaration
    ioDecoratedRoutineList +=
      !receiverTypeName: ["" nowhere]
      !mode:function.mMode
      !isRequired:[ioContext.mRequiredRoutineSet hasKey !functionLLVMName.string]
      !routineKind: .function
      !warnIfUnused: warnIfUnused
      !exportedRoutine: exportedFunction
      !routineAttributes: .none
      !routineMangledLLVMName: functionLLVMName
      !formalArgumentList: function.mFunctionFormalArgumentList
      !warningOnUnusedArgs: true
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !returnTypeName: function.mFunctionReturnTypeName
  end
}

#·······················································································································

method @functionDeclarationListAST enterFunctionsInPropertyMap
  ?receiverTypeName:let @lstring inReceiverTypeName # Empty string if standalone
  ?receiverLLVMBaseTypeName:let @string inReceiverLLVMBaseTypeName  # Empty string if standalone
  ?!context:@semanticContext ioContext
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
{
#----
  for function in self do
  #--- Attributes
    @stringset attributeSet = {}
    for attribute in function.mFunctionAttributeList do
      attributeSet += !attribute.mValue.string
    end
    let exportedFunction = [attributeSet hasKey !exportedAttribute ()]
  #--- Signature
    routineTypedSignature (!?ioContext.mTypeMap !function.mFunctionFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !function.mFunctionReturnTypeName ?let returnTypeProxy]
  #--- Routine LLVM Name name
    let functionLLVMName = routineMangledNameFromAST (
      !inReceiverLLVMBaseTypeName
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
    )
  #--- Prepare annalysis
    var warnIfUnused = true
    var functionAttributes = @routineAttributes.none
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == mutatingAttribute () then
        if [functionAttributes mutating] then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        functionAttributes = functionAttributes | .mutating    
      else
        error attribute : "unknown attribute; available attributes are @" + noUnusedWarningAttribute ()
          + " and @" + mutatingAttribute ()
      end
    end
  #--- Enter in routine map
    let routineLLVMNameDict = [function.mMode routineLLVMDictionaryForFunction !functionLLVMName]
    let routineMangledName = [signature mangledName !receiverTypeName: inReceiverTypeName !functionName: function.mFunctionName]
    [!?ioContext.mRoutineMap insertKey
      !routineMangledName
      !function.mPublicFunction
      !signature
      !returnTypeProxy
      !routineLLVMNameDict
      !exportedFunction
      !function.mMode
    ]
    ioDecoratedRoutineList +=
      !receiverTypeName: inReceiverTypeName
      !mode:function.mMode
      !isRequired: false
      !routineKind: .function
      !warnIfUnused: warnIfUnused
      !exportedRoutine: false
      !routineAttributes: functionAttributes
      !routineMangledLLVMName: functionLLVMName
      !formalArgumentList: function.mFunctionFormalArgumentList
      !warningOnUnusedArgs: true
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !returnTypeName: function.mFunctionReturnTypeName  # Empty string if no returned value
  end
}

