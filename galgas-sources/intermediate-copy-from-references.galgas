#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendCopyFromReferences
  ?!@semanticTemporariesStruct ioTemporaries
  ?errorLocation:let @location inErrorLocation
  ?source:let @objectIR inSourcePossibleReference
  ?target:let @LValueRepresentation inTargetReference
{
#--- Perform load / store, or call a copy routine ?
  let performLoadStore = [inTargetReference isVolatileAbsoluteReference]
   || [inTargetReference isVolatileIndirectReference]
   || not [inSourcePossibleReference isReference]
#---
  if performLoadStore then
    [!?self appendLoadWhenReference
      !?ioTemporaries
      !inSourcePossibleReference
      ?let loadedResultValue
    ]
    let result = checkAssignmentCompatibility (
      !source:loadedResultValue
      !targetAnnotationType:[inTargetReference type]
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
    switch inTargetReference
    case volatileAbsoluteReference (@PLMType type @uint address) :
      [!?self appendStoreVolatileRegister !type !address !result]
    case volatileIndirectReference (@PLMType type @string llvmName) :
      [!?self appendStoreIndirectVolatileRegister !type !llvmName !result]
    case universalReference (@PLMType type @string targetLLVMname) :
      [!?self appendStoreToUniversalReference !targetLLVMname !type !result]
    end
  else # Call a copy routine
    [inTargetReference universalReference ?type:let targetType ?llvmName: let targetLLVMName]
    [inSourcePossibleReference reference ?type:let sourceType ?llvmName:let sourceLLVMName]
    if sourceType != targetType then
      error inErrorLocation
      : "object of type $" + targetType.plmTypeName
        + " cannot be assigned from expression of type $" + sourceType.plmTypeName
    end
     self += !@copyFromReferencesIR.new {!sourceType !targetLLVMName !sourceLLVMName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @copyFromReferencesIR : @abstractInstructionIR {
  @PLMType mType
  @string mTargetLLVMName
  @string mSourceLLVMName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [mType llvmTypeName]
  ioLLVMcode += "  call void @plm.assign." + [mType.plmTypeName identifierRepresentation]
             + " (" + llvmType + "* " + mTargetLLVMName + ", " + llvmType + "* " + mSourceLLVMName + ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @PLMType generateCopyRoutine ?!@string ioLLVMCode ?!@generationAdds ioGenerationAdds {
  let typeName = [self llvmTypeName]
  var usesARC = false
  if [typeAttributes generateAssignmentRoutine] then
    let arcAssignmentList = [self arcList !{}]

    ioLLVMCode += llvmSeparatorLine () + "\n"
    ioLLVMCode += "define internal void @plm.assign." + [self.plmTypeName identifierRepresentation]
                + " (" + typeName + " * %inTarget, " + typeName + "* %inSource) nounwind optsize {\n"
    ioLLVMCode += ";--- Handle ARC properties\n"
    for (propertyName propertyType indexPath) in arcAssignmentList do
      usesARC = true
      let llvmVarName = "%arc.retain." + [propertyName assemblerRepresentation]
      ioLLVMCode += "  " + llvmVarName + " = getelementptr inbounds " + typeName + ", " + typeName + "* %inSource, i32 0"
      for (idx) in indexPath do
        ioLLVMCode += ", i32 " + idx
      end
      ioLLVMCode += " ; " + propertyName + "\n"
      let propertyTypeLLVMName = [propertyType llvmTypeName]
      let llvmLoadedVarName = "%arc.retain." + [propertyName assemblerRepresentation] + ".loaded"
      ioLLVMCode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
      ioLLVMCode += "  call void @" + [propertyType plmTypeName] + ".retain (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
    end
    for (propertyName propertyType indexPath) in arcAssignmentList do
      let llvmVarName = "%arc.release." + [propertyName assemblerRepresentation]
      ioLLVMCode += "  " + llvmVarName + " = getelementptr inbounds " + typeName + ", " + typeName + "* %inTarget, i32 0"
      for (idx) in indexPath do
        ioLLVMCode += ", i32 " + idx
      end
      ioLLVMCode += " ; " + propertyName + "\n"
      let propertyTypeLLVMName = [propertyType llvmTypeName]
      let llvmLoadedVarName = "%arc.release." + [propertyName assemblerRepresentation] + ".loaded"
      ioLLVMCode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
      ioLLVMCode += "  call void @" + [propertyType plmTypeName] + ".release (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
    end
    ioLLVMCode += ";--- Compute type size\n"
    ioLLVMCode += "  %sizeAsPtr = getelementptr inbounds " + typeName + ", " + typeName + "* null, i32 1\n"
    ioLLVMCode += "  %byteCount = ptrtoint " + typeName + "* %sizeAsPtr to i32\n"
    ioLLVMCode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
    ioLLVMCode += "  br i1 %useLoadStore, label %loadStore, label %copyBytesOrCopyWords\n"
    ioLLVMCode += ";--- Copy\n"
    ioLLVMCode += "loadStore:\n"
    ioLLVMCode += "  %v = load " + typeName + ", " + typeName + "* %inSource\n" 
    ioLLVMCode += "  store " + typeName + " %v, " + typeName + "* %inTarget\n" 
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copyBytesOrCopyWords:\n"
    ioLLVMCode += "  %byteCountAnd3 = and i32 %byteCount, 3\n"
    ioLLVMCode += "  %byteCountIsMutipleOf4 = icmp eq i32 %byteCountAnd3, 0\n"
    ioLLVMCode += "  br i1 %byteCountIsMutipleOf4, label %testTarget, label %copyBytes\n"
    ioLLVMCode += "testTarget:\n"
    ioLLVMCode += "  %targetAsUnsigned = ptrtoint " + typeName + "* %inTarget to i32\n"
    ioLLVMCode += "  %targetAsUnsignedAnd3 = and i32 %targetAsUnsigned, 3\n"
    ioLLVMCode += "  %targetAsUnsignedIsMutipleOf4 = icmp eq  i32%targetAsUnsignedAnd3, 0\n"
    ioLLVMCode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %testSource, label %copyBytes\n"
    ioLLVMCode += "testSource:\n"
    ioLLVMCode += "  %sourceAsUnsigned = ptrtoint " + typeName + "* %inSource to i32\n"
    ioLLVMCode += "  %sourceAsUnsignedAnd3 = and i32 %sourceAsUnsigned, 3\n"
    ioLLVMCode += "  %sourceAsUnsignedIsMutipleOf4 = icmp eq i32 %sourceAsUnsignedAnd3, 0\n"
    ioLLVMCode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %copyWords, label %copyBytes\n"
    ioLLVMCode += "copyWords:\n"
    ioLLVMCode += "  %target32 = bitcast " + typeName + "* %inTarget to i32*\n"
    ioLLVMCode += "  %source32 = bitcast " + typeName + "* %inSource to i32*\n"
    ioLLVMCode += "  %wordCount = udiv i32 %byteCount, 4\n"
    ioLLVMCode += "  br label %copyWords.loop\n"
    ioLLVMCode += "copyWords.loop:\n"
    ioLLVMCode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copyBytes:\n"
    ioLLVMCode += "  %target8 = bitcast " + typeName + "* %inTarget to i8*\n"
    ioLLVMCode += "  %source8 = bitcast " + typeName + "* %inSource to i8*\n"
    ioLLVMCode += "  call void @copy.byte.array (i8* %target8, i8* %source8, i32 %byteCount)\n"
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copy.end:\n"
    ioLLVMCode += "  ret void\n"
    ioLLVMCode += "}\n\n"
  elsif [typeAttributes arc] then
    usesARC = true
    ioLLVMCode += llvmSeparatorLine () + "\n"
    ioLLVMCode += "define internal void @plm.assign." + [self.plmTypeName identifierRepresentation]
                + " (" + typeName + " * %inTargetPtr, " + typeName + "* %inSourcePtr) nounwind optsize {\n"
    ioLLVMCode += "  %source = load " + typeName + ", " + typeName + "* %inSourcePtr\n" 
    ioLLVMCode += "  call void @" + [self plmTypeName] + ".retain (" + typeName + " %source)\n" 
    ioLLVMCode += "  %target = load " + typeName + ", " + typeName + "* %inTargetPtr\n" 
    ioLLVMCode += "  call void @" + plmTypeName + ".release (" + typeName + " %target)\n" 
    ioLLVMCode += "  store " + typeName + " %source, " + typeName + "* %inTargetPtr\n" 
    ioLLVMCode += "  ret void\n"
    ioLLVMCode += "}\n\n"
  end
  
  if usesARC then
    ioGenerationAdds.mExternFunctionDeclarationSet += !"void @" + [self plmTypeName] + ".retain (" + typeName + " %inPtr)"
    ioGenerationAdds.mExternFunctionDeclarationSet += !"void @" + [self plmTypeName] + ".release (" + typeName + " %inPtr)"
    ioGenerationAdds.mExternFunctionDeclarationSet += !"void @" + [self plmTypeName] + ".insulate (" + typeName + "* %ioPtr)"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
