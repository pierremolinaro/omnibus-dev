#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendCopyFromReferences
  ?!@semanticTemporariesStruct ioTemporaries
  ?errorLocation:let @location inErrorLocation
  ?source:let @objectIR inSourcePossibleReference
  ?target:let @LValueRepresentation inTargetReference
{
#--- Perform load / store, or call a copy routine ?
  let performLoadStore = [inTargetReference isVolatileAbsoluteReference]
   || [inTargetReference isVolatileIndirectReference]
   || not [inSourcePossibleReference isReference]
#---
  if performLoadStore then
    [!?self appendLoadWhenReference
      !?ioTemporaries
      !inSourcePossibleReference
      ?let loadedResultValue
    ]
    let result = checkAssignmentCompatibility (
      !source:loadedResultValue
      !targetAnnotationType:[inTargetReference type]
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
    switch inTargetReference
    case volatileAbsoluteReference (@PLMType type @uint address) :
      [!?self appendStoreVolatileRegister !type !address !result]
    case volatileIndirectReference (@PLMType type @string llvmName) :
      [!?self appendStoreIndirectVolatileRegister !type !llvmName !result]
    case universalReference (@PLMType type @string targetLLVMname) :
      [!?self appendStoreToUniversalReference !targetLLVMname !type !result]
    end
  else # Call a copy routine
    [inTargetReference universalReference ?type:let targetType ?llvmName: let targetLLVMName]
    [inSourcePossibleReference reference ?type:let sourceType ?llvmName:let sourceLLVMName]
    if sourceType != targetType then
      error inErrorLocation
      : "object of type $" + targetType.plmUserTypeName
        + " cannot be assigned from expression of type $" + sourceType.plmUserTypeName
    end
     self += !@copyFromReferencesIR.new {!sourceType !targetLLVMName !sourceLLVMName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @copyFromReferencesIR : @abstractInstructionIR {
  @PLMType mType
  @string mTargetLLVMName
  @string mSourceLLVMName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [mType llvmTypeName]
  ioLLVMcode += "  call void @plm.assign." + [mType.plmUserTypeName identifierRepresentation]
             + " (" + llvmType + "* " + mTargetLLVMName + ", " + llvmType + "* " + mSourceLLVMName + ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @PLMType generateCopyRoutine ?!@string ioLLVMCode ?!@generationAdds unused ioGenerationAdds {
  let typeName = [self llvmTypeName]
  if [typeAttributes generateAssignmentRoutine] then
    let arcAssignmentList = [self arcList !{}]

    ioLLVMCode += llvmSeparatorLine () + "\n"
    ioLLVMCode += "define internal void @plm.assign." + [self.plmUserTypeName identifierRepresentation]
                + " (" + typeName + " * %inTarget, " + typeName + "* %inSource)" + llvmAttributeFunction () +"{\n"
    ioLLVMCode += ";--- Handle ARC properties\n"
    for (propertyName propertyType indexPath) in arcAssignmentList do
      let propertyTypeLLVMName = [propertyType llvmTypeName]
      let llvmVarName = "%arc.retain." + [propertyName assemblerRepresentation]
      ioLLVMCode += "  " + llvmVarName + " = getelementptr inbounds " + typeName + ", " + typeName + "* %inSource, i32 0"
      for (idx) in indexPath do
        ioLLVMCode += ", i32 " + idx
      end
      ioLLVMCode += " ; " + propertyName + "\n"
      let llvmLoadedVarName = "%arc.retain." + [propertyName assemblerRepresentation] + ".loaded"
      ioLLVMCode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
      ioLLVMCode += "  call void @arc.retain (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
    end
    switch kind
    case void, boolean, literalString , staticInteger: # Nothing to do
    case enumeration (*) : # Nothing to do
    case structure (@propertyList propertyList) :
      for (propertyName propertyType) in propertyList do (idx)
        if [propertyType deinitNeeded] then
          ioLLVMCode += ";--- denit '" + propertyName + "' source object property\n"
          let propertyTypeLLVMName = [propertyType llvmTypeName]
          let llvmVarName = "%property.addr." + [propertyName assemblerRepresentation]
          ioLLVMCode += "  " + llvmVarName + " = getelementptr inbounds " + typeName + ", " + typeName
                     + "* %inTarget, i32 0, i32 " + idx + " ; " + propertyName + "\n"
#          ioLLVMCode += "  call void @arc.release (" + propertyTypeLLVMName + "* " + llvmVarName
#                     + ", void (i32)* " + [propertyType deinitFunctionLLVMName] + ")\n" 
          let deinitName = [propertyType deinitFunctionLLVMName]
          ioLLVMCode += "  call void " + deinitName + " (" + propertyTypeLLVMName + "* " + llvmVarName + ")\n"
        end
      end
    case syncTool (*) : # Nothing to do
    case integer (4*) : # Nothing to do
    case opaque (*) : # Nothing to do
    case arrayType (@PLMType unused elementType @bigint unused size) : # Nothing to do
    case dynamicArrayType (@PLMType unused elementType @bigint unused ptrSize) :
    case function (*) : # Nothing to do
    case pointer (*) : # Nothing to do
    end
    ioLLVMCode += ";--- Compute type size\n"
    ioLLVMCode += "  %sizeAsPtr = getelementptr inbounds " + typeName + ", " + typeName + "* null, i32 1\n"
    ioLLVMCode += "  %byteCount = ptrtoint " + typeName + "* %sizeAsPtr to i32\n"
    ioLLVMCode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
    ioLLVMCode += "  br i1 %useLoadStore, label %loadStore, label %copyBytesOrCopyWords\n"
    ioLLVMCode += ";--- Copy\n"
    ioLLVMCode += "loadStore:\n"
    ioLLVMCode += "  %v = load " + typeName + ", " + typeName + "* %inSource\n" 
    ioLLVMCode += "  store " + typeName + " %v, " + typeName + "* %inTarget\n" 
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copyBytesOrCopyWords:\n"
    ioLLVMCode += "  %byteCountAnd3 = and i32 %byteCount, 3\n"
    ioLLVMCode += "  %byteCountIsMutipleOf4 = icmp eq i32 %byteCountAnd3, 0\n"
    ioLLVMCode += "  br i1 %byteCountIsMutipleOf4, label %testTarget, label %copyBytes\n"
    ioLLVMCode += "testTarget:\n"
    ioLLVMCode += "  %targetAsUnsigned = ptrtoint " + typeName + "* %inTarget to i32\n"
    ioLLVMCode += "  %targetAsUnsignedAnd3 = and i32 %targetAsUnsigned, 3\n"
    ioLLVMCode += "  %targetAsUnsignedIsMutipleOf4 = icmp eq  i32%targetAsUnsignedAnd3, 0\n"
    ioLLVMCode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %testSource, label %copyBytes\n"
    ioLLVMCode += "testSource:\n"
    ioLLVMCode += "  %sourceAsUnsigned = ptrtoint " + typeName + "* %inSource to i32\n"
    ioLLVMCode += "  %sourceAsUnsignedAnd3 = and i32 %sourceAsUnsigned, 3\n"
    ioLLVMCode += "  %sourceAsUnsignedIsMutipleOf4 = icmp eq i32 %sourceAsUnsignedAnd3, 0\n"
    ioLLVMCode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %copyWords, label %copyBytes\n"
    ioLLVMCode += "copyWords:\n"
    ioLLVMCode += "  %target32 = bitcast " + typeName + "* %inTarget to i32*\n"
    ioLLVMCode += "  %source32 = bitcast " + typeName + "* %inSource to i32*\n"
    ioLLVMCode += "  %wordCount = udiv i32 %byteCount, 4\n"
    ioLLVMCode += "  br label %copyWords.loop\n"
    ioLLVMCode += "copyWords.loop:\n"
    ioLLVMCode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copyBytes:\n"
    ioLLVMCode += "  %target8 = bitcast " + typeName + "* %inTarget to i8*\n"
    ioLLVMCode += "  %source8 = bitcast " + typeName + "* %inSource to i8*\n"
    ioLLVMCode += "  call void @copy.byte.array (i8* %target8, i8* %source8, i32 %byteCount)\n"
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copy.end:\n"
    ioLLVMCode += "  ret void\n"
    ioLLVMCode += "}\n\n"
  elsif [typeAttributes arc] then
    ioLLVMCode += llvmSeparatorLine () + "\n"
    ioLLVMCode += "define internal void @plm.assign." + [self.plmUserTypeName identifierRepresentation]
                + " (" + typeName + " * %inTargetPtr, " + typeName + "* %inSourcePtr)" + llvmAttributeFunction () +"{\n"
    ioLLVMCode += ";--- Retain source\n"
    ioLLVMCode += "  %source = load " + typeName + ", " + typeName + "* %inSourcePtr\n" 
    ioLLVMCode += "  %source.ptr8 = bitcast " + typeName + " %source to %ptrtype\n"
    ioLLVMCode += "  call void @arc.retain (%ptrtype %source.ptr8)\n" 
    ioLLVMCode += ";--- Release target\n"
    ioLLVMCode += "  %target = load " + typeName + ", " + typeName + "* %inTargetPtr\n"
    ioLLVMCode += "  %function.deinit = bitcast void(" + [self llvmTypeName] + ")* " + [self deinitFunctionLLVMName] + " to void (%ptrtype)*\n"
    ioLLVMCode += "  %target.ptr8 = bitcast " + typeName + " %target to %ptrtype\n"
    ioLLVMCode += "  call void @arc.release (%ptrtype %target.ptr8, void (%ptrtype)* %function.deinit)\n" 
    ioLLVMCode += ";--- Copy\n"
    ioLLVMCode += "  store " + typeName + " %source, " + typeName + "* %inTargetPtr\n" 
    ioLLVMCode += ";--- Return\n"
    ioLLVMCode += "  ret void\n"
    ioLLVMCode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
