#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendCopyFromReferences
  ?!@semanticTemporariesStruct ioTemporaries
  ?errorLocation:let @location inErrorLocation
  ?source:let @objectIR inSourcePossibleReference
  ?target:let @LValueRepresentation inTargetReference
{
#---
  if not [inSourcePossibleReference isReference] then
    var loadedResultValue = inSourcePossibleReference
    [!?self appendLoadWhenReference
      !?ioTemporaries
      !?loadedResultValue
    ]
    let result = checkAssignmentCompatibility (
      !source:loadedResultValue
      !targetAnnotationType:[inTargetReference type]
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
    [!?self appendStoreToUniversalReference !inTargetReference.llvmName !inTargetReference.type !result]
  else # Call a copy routine
    [inSourcePossibleReference reference ?type:let sourceType ?llvmName:let sourceLLVMName]
    if sourceType.plmTypeDescriptionName != inTargetReference.type.plmTypeDescriptionName then
      error inErrorLocation
      : "object of type $" + inTargetReference.type.plmTypeDescriptionName
        + " cannot be assigned from expression of type $" + sourceType.plmTypeDescriptionName
    end
     self += !@copyFromReferencesIR.new {!sourceType !inTargetReference.llvmName !sourceLLVMName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @copyFromReferencesIR : @abstractInstructionIR {
  @PLMType mType
  @string mTargetLLVMName
  @string mSourceLLVMName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [mType llvmTypeName]
  ioLLVMcode += "  call void @plm.assign."
  ioLLVMcode += [mType.llvmBaseTypeName assemblerRepresentation]
  ioLLVMcode += "."
  ioLLVMcode += [mType.llvmBaseTypeName assemblerRepresentation]
  ioLLVMcode += " (" + llvmType + "* " + mTargetLLVMName + ", " + llvmType + "* " + mSourceLLVMName + ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @PLMType generateCopyRoutine ?!@string ioLLVMcode ?!@generationAdds ioGenerationAdds {
  if [attributes generateAssignmentRoutine] then
    let typeName = [self llvmTypeName]
    if [kind isDynamicArrayType] then
      ioLLVMcode += llvmSeparatorLine () + "\n"
      ioLLVMcode += "define internal void @plm.assign."
      ioLLVMcode += [self.llvmBaseTypeName assemblerRepresentation]
      ioLLVMcode += "."
      ioLLVMcode += [self.llvmBaseTypeName assemblerRepresentation]
      ioLLVMcode += " (" + typeName + " * %inTargetPtr, " + typeName + "* %inSourcePtr) nounwind optsize {\n"
      ioLLVMcode += "  %source = load " + typeName + ", " + typeName + "* %inSourcePtr\n" 
      ioLLVMcode += "  call void @arc.retain (" + typeName + " %source)\n" 
      ioLLVMcode += "  %target = load " + typeName + ", " + typeName + "* %inTargetPtr\n" 
      ioLLVMcode += "  call void @arc.release (" + typeName + " %target)\n" 
      ioLLVMcode += "  store " + typeName + " %source, " + typeName + "* %inTargetPtr\n" 
      ioLLVMcode += "  ret void\n"
      ioLLVMcode += "}\n\n"
    else
      let arcAssignmentList = [self arcList !{}]
  
      ioLLVMcode += llvmSeparatorLine () + "\n"
      ioLLVMcode += "define internal void @plm.assign."
      ioLLVMcode += [self.llvmBaseTypeName assemblerRepresentation]
      ioLLVMcode += "."
      ioLLVMcode += [self.llvmBaseTypeName assemblerRepresentation]
      ioLLVMcode += " (" + typeName + " * %inTarget, " + typeName + "* %inSource) nounwind optsize {\n"
      ioLLVMcode += ";--- Handle ARC properties\n"
      for (propertyName propertyType indexPath) in arcAssignmentList do
        let propertyTypeLLVMName = [propertyType llvmTypeName]
        let llvmVarName = "%arc.retain." + [propertyName assemblerRepresentation] + ioGenerationAdds.mUniqueIndex
        ioGenerationAdds.mUniqueIndex ++
        ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + typeName + ", " + typeName + "* %inSource, i32 0"
        for (idx) in indexPath do
          ioLLVMcode += ", i32 " + idx
        end
        ioLLVMcode += " ; " + propertyName + "\n"
        let llvmLoadedVarName = llvmVarName + ".loaded"
        ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
        ioLLVMcode += "  call void @arc.retain (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
      end
      for (propertyName propertyType indexPath) in arcAssignmentList do
        let llvmVarName = "%arc.release." + [propertyName assemblerRepresentation] + ioGenerationAdds.mUniqueIndex
        ioGenerationAdds.mUniqueIndex ++
        ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + typeName + ", " + typeName + "* %inTarget, i32 0"
        for (idx) in indexPath do
          ioLLVMcode += ", i32 " + idx
        end
        ioLLVMcode += " ; " + propertyName + "\n"
        let propertyTypeLLVMName = [propertyType llvmTypeName]
        let llvmLoadedVarName = llvmVarName + ".loaded"
        ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
        ioLLVMcode += "  call void @arc.release (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
      end
      ioLLVMcode += ";--- Compute type size\n"
      ioLLVMcode += "  %sizeAsPtr = getelementptr inbounds " + typeName + ", " + typeName + "* null, i32 1\n"
      ioLLVMcode += "  %byteCount = ptrtoint " + typeName + "* %sizeAsPtr to i32\n"
      ioLLVMcode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
      ioLLVMcode += "  br i1 %useLoadStore, label %loadStore, label %copyBytesOrCopyWords\n"
      ioLLVMcode += ";--- Copy\n"
      ioLLVMcode += "loadStore:\n"
      ioLLVMcode += "  %v = load " + typeName + ", " + typeName + "* %inSource\n" 
      ioLLVMcode += "  store " + typeName + " %v, " + typeName + "* %inTarget\n" 
      ioLLVMcode += "  br label %copy.end\n"
      ioLLVMcode += "copyBytesOrCopyWords:\n"
      ioLLVMcode += "  %byteCountAnd3 = and i32 %byteCount, 3\n"
      ioLLVMcode += "  %byteCountIsMutipleOf4 = icmp eq i32 %byteCountAnd3, 0\n"
      ioLLVMcode += "  br i1 %byteCountIsMutipleOf4, label %testTarget, label %copyBytes\n"
      ioLLVMcode += "testTarget:\n"
      ioLLVMcode += "  %targetAsUnsigned = ptrtoint " + typeName + "* %inTarget to i32\n"
      ioLLVMcode += "  %targetAsUnsignedAnd3 = and i32 %targetAsUnsigned, 3\n"
      ioLLVMcode += "  %targetAsUnsignedIsMutipleOf4 = icmp eq i32%targetAsUnsignedAnd3, 0\n"
      ioLLVMcode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %testSource, label %copyBytes\n"
      ioLLVMcode += "testSource:\n"
      ioLLVMcode += "  %sourceAsUnsigned = ptrtoint " + typeName + "* %inSource to i32\n"
      ioLLVMcode += "  %sourceAsUnsignedAnd3 = and i32 %sourceAsUnsigned, 3\n"
      ioLLVMcode += "  %sourceAsUnsignedIsMutipleOf4 = icmp eq i32 %sourceAsUnsignedAnd3, 0\n"
      ioLLVMcode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %copyWords, label %copyBytes\n"
      ioLLVMcode += "copyWords:\n"
      ioLLVMcode += "  %target32 = bitcast " + typeName + "* %inTarget to i32*\n"
      ioLLVMcode += "  %source32 = bitcast " + typeName + "* %inSource to i32*\n"
      ioLLVMcode += "  %wordCount = udiv i32 %byteCount, 4\n"
      ioLLVMcode += "  br label %copyWords.loop\n"
      ioLLVMcode += "copyWords.loop:\n"
      ioLLVMcode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
      ioLLVMcode += "  br label %copy.end\n"
      ioLLVMcode += "copyBytes:\n"
      ioLLVMcode += "  %target8 = bitcast " + typeName + "* %inTarget to i8*\n"
      ioLLVMcode += "  %source8 = bitcast " + typeName + "* %inSource to i8*\n"
      ioLLVMcode += "  call void @copy.byte.array (i8* %target8, i8* %source8, i32 %byteCount)\n"
      ioLLVMcode += "  br label %copy.end\n"
      ioLLVMcode += "copy.end:\n"
      ioLLVMcode += "  ret void\n"
      ioLLVMcode += "}\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
