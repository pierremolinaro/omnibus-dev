#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendCopyFromReferences
  ?!@semanticTemporariesStruct ioTemporaries
  ?errorLocation:let @location inErrorLocation
  ?source:let @objectIR inSourcePossibleReference
  ?target:let @LValueRepresentation inTargetReference
{
#--- Perform load / store, or call a copy routine ?
  let performLoadStore = [inTargetReference isVolatileAbsoluteReference]
   || [inTargetReference isVolatileIndirectReference]
   || not [inSourcePossibleReference isReference]
#---
  if performLoadStore then
    [!?self appendLoadWhenReference
      !?ioTemporaries
      !inSourcePossibleReference
      ?let loadedResultValue
    ]
    let result = checkAssignmentCompatibility (
      !source:loadedResultValue
      !targetAnnotationType:[inTargetReference type]
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
    switch inTargetReference
    case volatileAbsoluteReference (@PLMType type @uint address) :
      [!?self appendStoreVolatileRegister !type !address !result]
    case volatileIndirectReference (@PLMType type @string llvmName) :
      [!?self appendStoreIndirectVolatileRegister !type !llvmName !result]
    case universalReference (@PLMType type @string targetLLVMname) :
      [!?self appendStoreToUniversalReference !targetLLVMname !type !result]
    end
  else # Call a copy routine
    [inTargetReference universalReference ?type:let targetType ?llvmName: let targetLLVMName]
    [inSourcePossibleReference reference ?type:let sourceType ?llvmName:let sourceLLVMName]
    if sourceType != targetType then
      error inErrorLocation
      : "object of type $" + targetType.plmTypeName
        + " cannot be assigned from expression of type $" + sourceType.plmTypeName
    end
     self += !@copyFromReferencesIR.new {!sourceType !targetLLVMName !sourceLLVMName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @copyFromReferencesIR : @abstractInstructionIR {
  @PLMType mType
  @string mTargetLLVMName
  @string mSourceLLVMName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmType = [mType llvmTypeName]
  ioLLVMcode += "  call void @plm.assign." + [mType.plmTypeName identifierRepresentation]
              + " (" + llvmType + "* " + mTargetLLVMName + ", " + llvmType + "* " + mSourceLLVMName + ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @PLMType generateCopyRoutine ?!@string ioLLVMCode {
  if [typeAttributes generateAssignmentRoutine] then
    let typeName = [self llvmTypeName]
    ioLLVMCode += llvmSeparatorLine () + "\n"
    ioLLVMCode += "define internal void @plm.assign." + [self.plmTypeName identifierRepresentation]
                + " (" + typeName + " * %inTarget, " + typeName + "* %inSource) nounwind optsize {\n"
    ioLLVMCode += "entry:\n"
    ioLLVMCode += "  %sizeAsPtr = getelementptr inbounds " + typeName + ", " + typeName + "* null, i32 1\n"
    ioLLVMCode += "  %byteCount = ptrtoint " + typeName + "* %sizeAsPtr to i32\n"
    ioLLVMCode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
    ioLLVMCode += "  br i1 %useLoadStore, label %loadStore, label %copyBytesOrCopyWords\n"
    ioLLVMCode += "loadStore: ; Perform copy using load - store\n"
    ioLLVMCode += "  %v = load " + typeName + ", " + typeName + "* %inSource\n" 
    ioLLVMCode += "  store " + typeName + " %v, " + typeName + "* %inTarget\n" 
    ioLLVMCode += "  br label %copy.end\n"
    ioLLVMCode += "copyBytesOrCopyWords:\n"
    ioLLVMCode += "  %byteCountAnd3 = and i32 %byteCount, 3\n"
    ioLLVMCode += "  %byteCountIsMutipleOf4 = icmp eq i32 %byteCountAnd3, 0\n"
    ioLLVMCode += "  br i1 %byteCountIsMutipleOf4, label %testTarget, label %copyBytes\n"
    ioLLVMCode += "testTarget:\n"
    ioLLVMCode += "  %targetAsUnsigned = ptrtoint " + typeName + "* %inTarget to i32\n"
    ioLLVMCode += "  %targetAsUnsignedAnd3 = and i32 %targetAsUnsigned, 3\n"
    ioLLVMCode += "  %targetAsUnsignedIsMutipleOf4 = icmp eq  i32%targetAsUnsignedAnd3, 0\n"
    ioLLVMCode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %testSource, label %copyBytes\n"
    ioLLVMCode += "testSource:\n"
    ioLLVMCode += "  %sourceAsUnsigned = ptrtoint " + typeName + "* %inSource to i32\n"
    ioLLVMCode += "  %sourceAsUnsignedAnd3 = and i32 %sourceAsUnsigned, 3\n"
    ioLLVMCode += "  %sourceAsUnsignedIsMutipleOf4 = icmp eq i32 %sourceAsUnsignedAnd3, 0\n"
    ioLLVMCode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %copyWords, label %copyBytes\n"
    ioLLVMCode += "copyWords:\n"
    ioLLVMCode += "  %target32 = bitcast " + typeName + "* %inTarget to i32*\n"
    ioLLVMCode += "  %source32 = bitcast " + typeName + "* %inSource to i32*\n"
    ioLLVMCode += "  %wordCount = udiv i32 %byteCount, 4\n"
    ioLLVMCode += "  br label %copyWords.loop\n"
    ioLLVMCode += "copyWords.loop:\n"
    ioLLVMCode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
    ioLLVMCode += "  br label %copy.end\n"
#    ioLLVMCode += "  %target32.current = phi i32* [%target32, %copyWords], [%target32.next, %copyWords.loop]\n"
#    ioLLVMCode += "  %source32.current = phi i32* [%source32, %copyWords], [%source32.next, %copyWords.loop]\n"
#    ioLLVMCode += "  %wordCount.current = phi i32 [%wordCount, %copyWords], [%wordCount.next, %copyWords.loop]\n"
#    ioLLVMCode += "  %value32 = load i32, i32* %source32.current\n"
#    ioLLVMCode += "  store i32 %value32, i32* %target32.current\n"
#    ioLLVMCode += "  %target32.next = getelementptr inbounds i32, i32* %target32.current, i32 1\n"
#    ioLLVMCode += "  %source32.next = getelementptr inbounds i32, i32* %source32.current, i32 1\n"
#    ioLLVMCode += "  %wordCount.next = sub i32 %wordCount.current, 1\n"
#    ioLLVMCode += "  %wordCount.next.isZero = icmp eq i32 %wordCount.next, 0\n"
#    ioLLVMCode += "  br i1 %wordCount.next.isZero, label %copy.end, label %copyWords.loop\n"
    ioLLVMCode += "copyBytes:\n"
    ioLLVMCode += "  %target8 = bitcast " + typeName + "* %inTarget to i8*\n"
    ioLLVMCode += "  %source8 = bitcast " + typeName + "* %inSource to i8*\n"
    ioLLVMCode += "  call void @copy.byte.array (i8* %target8, i8* %source8, i32 %byteCount)\n"
    ioLLVMCode += "  br label %copy.end\n"
#    ioLLVMCode += "  br label %copyBytes.loop\n"
#    ioLLVMCode += "copyBytes.loop:\n"
#    ioLLVMCode += "  %target8.current = phi i8* [%target8, %copyBytes], [%target8.next, %copyBytes.loop]\n"
#    ioLLVMCode += "  %source8.current = phi i8* [%source8, %copyBytes], [%source8.next, %copyBytes.loop]\n"
#    ioLLVMCode += "  %byteCount.current = phi i32 [%byteCount, %copyBytes], [%byteCount.next, %copyBytes.loop]\n"
#    ioLLVMCode += "  %value8 = load i8, i8* %source8.current\n"
#    ioLLVMCode += "  store i8 %value8, i8* %target8.current\n"
#    ioLLVMCode += "  %target8.next = getelementptr inbounds i8, i8* %target8.current, i32 1\n"
#    ioLLVMCode += "  %source8.next = getelementptr inbounds i8, i8* %source8.current, i32 1\n"
#    ioLLVMCode += "  %byteCount.next = sub i32 %byteCount.current, 1\n"
#    ioLLVMCode += "  %byteCount.next.isZero = icmp eq i32 %byteCount.next, 0\n"
#    ioLLVMCode += "  br i1 %byteCount.next.isZero, label %copy.end, label %copyBytes.loop\n"
    ioLLVMCode += "copy.end:\n"
    ioLLVMCode += "  ret void\n"
    ioLLVMCode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
