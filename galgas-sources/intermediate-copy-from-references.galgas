#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendCopyFromReferences
  ?let @assignmentOperatorMap inAssignmentOperatorMap
  ?!@semanticTemporariesStruct ioTemporaries
  ?errorLocation:let @location inErrorLocation
  ?source:let @objectIR inSourcePossibleReference
  ?target:let @LValueRepresentation inTargetReference
{
#---
  if not [inSourcePossibleReference isReference] then
    var loadedResultValue = inSourcePossibleReference
    [!?self appendLoadWhenReference
      !?ioTemporaries
      !?loadedResultValue
    ]
    let result = checkAssignmentCompatibility (
      !inAssignmentOperatorMap
      !source:loadedResultValue
      !targetAnnotationType:[inTargetReference type]
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
    [!?self appendStoreToUniversalReference !inTargetReference.llvmName !inTargetReference.type !result]
  else # Call a copy routine
    [inSourcePossibleReference reference ?type:let sourceType ?llvmName:let sourceLLVMName]
    if sourceType.omnibusTypeDescriptionName != inTargetReference.type.omnibusTypeDescriptionName then
      error inErrorLocation
      : "object of type " + inTargetReference.type.omnibusTypeDescriptionName
        + " cannot be assigned from expression of type " + sourceType.omnibusTypeDescriptionName
    end
    self += !@copyFromReferencesIR.new {!inTargetReference !sourceLLVMName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @copyFromReferencesIR : @abstractInstructionIR {
  @LValueRepresentation mTarget
  @string mSourceLLVMName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let assignmentFunctionLLVMName = assignmentOperatorFuncName (![mTarget type] ![mTarget type])
  let llvmTypeName = [[mTarget type] llvmTypeName]
  ioLLVMcode += "  call void @" + [assignmentFunctionLLVMName assemblerRepresentation]
  ioLLVMcode += " (" + llvmTypeName + "* " + mTarget.llvmName + ", " + llvmTypeName + "* " + mSourceLLVMName + ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @copyFromReferencesIR enterAccessibleEntities 
  ?!@stringset ioInvokedRoutineSet
  ?!@uint unused ioMaxBranchOfOnInstructions
{
  let assignmentFunctionLLVMName = assignmentOperatorFuncName (![mTarget type] ![mTarget type])
  ioInvokedRoutineSet += !assignmentFunctionLLVMName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
