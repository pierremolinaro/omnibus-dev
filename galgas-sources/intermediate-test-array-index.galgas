
setter @instructionListIR testArrayIndex
  ?let @objectIR inIndex
  ?let @location inErrorLocation
  ?let @bigint inSize
  !@bool outGeneratePanicInstruction
{
  [[inIndex type].kind integer ?1* ?max:let max ?unsigned:let isUnsigned ?1*]
  outGeneratePanicInstruction = (not isUnsigned) || (max >= inSize)
  self += !@testArrayIndexIR.new {!inIndex !inErrorLocation !inSize}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @testArrayIndexIR : @abstractInstructionIR {
  @objectIR mIndex
  @location mErrorLocation
  @bigint mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @testArrayIndexIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
#  [!?ioGenerationAdds.mStaticEntityMap findOrAddStaticString
#    ![[[mErrorLocation file] lastPathComponent] stringByDeletingPathExtension]
#    ?let staticStringIndex
#  ]
  [[mIndex type].kind integer ?1* ?max:let max ?unsigned:let isUnsigned ?1*]
#--- Test index >= 0 (for signed index)
  if not isUnsigned then
    let testToZero = "%test.index.zero." + ioGenerationAdds.mUniqueIndex
    let testToZeroOk = "test.index.zero.ok." + ioGenerationAdds.mUniqueIndex
    let testToZeroFailure = "test.index.zero.fails." + ioGenerationAdds.mUniqueIndex
    ioGenerationAdds.mUniqueIndex ++
    ioLLVMcode += "  " + testToZero + " = icmp sge " + [[mIndex type] llvmTypeName] + " " + [mIndex llvmName] + ", 0\n"
    ioLLVMcode += "  br i1 " + testToZero + ", label %" + testToZeroOk + ", label %" + testToZeroFailure + "\n\n"
  
    ioLLVMcode += testToZeroFailure + ":\n"
    ioLLVMcode += "  call void @" + [panicRoutineNameForLocationFile (!mErrorLocation) assemblerRepresentation] + " ("
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " " + [mErrorLocation line] + ", "
    ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " " + panicCodeForNegativeArrayIndex () + ") noreturn \n"
    ioLLVMcode += "  unreachable\n\n"
  
    ioLLVMcode += testToZeroOk + ":\n"
  end
#--- Test index < size (only if index max value is >= size)
  if max >= mSize then
    let testToSize = "%test.index.size." + ioGenerationAdds.mUniqueIndex
    let testToSizeOk = "test.index.size.ok." + ioGenerationAdds.mUniqueIndex
    let testToSizeFailure = "test.index.size.fails." + ioGenerationAdds.mUniqueIndex
    ioLLVMcode += "  " + testToSize + " = icmp "
    ioLLVMcode += if isUnsigned then "ult" else "slt" end
    ioLLVMcode += " " + [[mIndex type] llvmTypeName] + " " + [mIndex llvmName] + ", " + mSize + "\n"
    ioLLVMcode += "  br i1 " + testToSize + ", label %" + testToSizeOk + ", label %" + testToSizeFailure + "\n\n"
  
    ioLLVMcode += testToSizeFailure + ":\n"
    ioLLVMcode += "  call void @" + [panicRoutineNameForLocationFile (!mErrorLocation) assemblerRepresentation] + " ("
    ioLLVMcode += [inGenerationContext.mPanicLineLLVMType llvmTypeName] + " " + [mErrorLocation line] + ", "
    ioLLVMcode += [inGenerationContext.mPanicCodeLLVMType llvmTypeName] + " " + panicCodeForTooLargeArrayIndex () + ") noreturn \n"
    ioLLVMcode += "  unreachable\n\n"
  
    ioLLVMcode += testToSizeOk + ":\n"
  end
#---
  ioGenerationAdds.mUniqueIndex ++
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @testArrayIndexIR enterAccessibleEntities
  ?!@stringset ioInvokedRoutineSet
  ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioInvokedRoutineSet += !panicRoutineNameForLocationFile (!mErrorLocation)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
