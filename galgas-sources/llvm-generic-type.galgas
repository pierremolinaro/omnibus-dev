#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @genericFormalParameter {
  case constant (@lstring name)
  case type (@lstring name)
}

#·······················································································································

list @genericFormalParameterList {
  @genericFormalParameter mParameter
}

#·······················································································································

enum @llvmStringDefinitionElement {
  case variable (@lstring name)
  case string (@lstring value)
}

#·······················································································································

list @llvmStringDefinition {
  @llvmStringDefinitionElement mElement
}

#·······················································································································

class @llvmGenericType : @abstractDeclarationAST {
  @lstring mTypeName
  @genericFormalParameterList mGenericFormalParameterList
  @ctExpressionAST mWhereClause
  @llvmStringDefinition mLLVMNativeTypeNameExpression
}

#·······················································································································

override getter @llvmGenericType locationForErrorSignaling -> @location outLocation {
  outLocation = mTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <llvm_string_definition> !@llvmStringDefinition outStringDefinition {
    outStringDefinition = {}
    repeat
      select
        $"string"$ ?let string
        outStringDefinition += !.string {!value: string}
      or
        $identifier$ ?let name
        outStringDefinition += !.variable {!name: name}
      end
    while
      $+$
    end
  }
  
  #·····················································································································

  rule <generic_formal_arguments> !@genericFormalParameterList outGenericFormalParameterList {
    outGenericFormalParameterList = {}
    select
    or
      $<$
      repeat
        select
          $identifier$ ?let constantName
          outGenericFormalParameterList += !.constant {!name: constantName}
        or
          $\$type$ ?let typeName
          outGenericFormalParameterList += !.type {!name: typeName}
        end
      while
        $,$
      end
      $>$
    end
  }

  #·····················································································································

  rule <generic_where_clause> !@ctExpressionAST outWhereClause {
    select
      outWhereClause = @ctTrueExpressionAST.new
    or
      $where$
      <compile_time_expression> ?outWhereClause
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $llvm$
    $\$type$ ?let typeName
    <generic_formal_arguments> ?let genericFormalParameterList
    <generic_where_clause> ?let whereClause
    ${$
    <llvm_string_definition> ?let llvmNativeTypeNameExpression
    $}$
    ioAST.mDeclarationListAST += !@llvmGenericType.new {
      !typeName
      !genericFormalParameterList
      !whereClause
      !llvmNativeTypeNameExpression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @llvmGenericType enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = mTypeName
  [!?ioGraph addNode !nodeName !self]
#  [!?ioGraph addEdge !nodeName !mReceiverTypeName]
}

#·······················································································································

override getter @llvmGenericType keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "Generic type " + mTypeName.string
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @genericFormalParameterList buildFormalGenericConstantMap ?!@ctCheckMap ioMap {
  for (element) in self do
    switch element 
    case type (*) :
    case constant (constantName) :
      [!?ioMap insertKey !constantName]
    end
  end
}

#·······················································································································

method @llvmStringDefinition checkCompileTimeExpression ?let @ctCheckMap inMap {
  for (element) in self do
    switch element 
    case string (*) :
    case variable (name) :
      [inMap searchKey !name]
    end
  end
}

#·······················································································································

override method @llvmGenericType enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Build formal generic constant parameter map
  @ctCheckMap formalGenericConstantParameterMap = {}
  [mGenericFormalParameterList buildFormalGenericConstantMap !?formalGenericConstantParameterMap]
#--- Check Where clause
  [mWhereClause checkCompileTimeExpression !formalGenericConstantParameterMap]
#--- Check native LLVM type expression
  [mLLVMNativeTypeNameExpression checkCompileTimeExpression !formalGenericConstantParameterMap]
#---
  let genericType = @omnibusType.new {
    !propertyGetterMap: {}
    !propertySetterMap: {}
    !classConstantMap:{}
    !constructorMap:{}
    !subscript:.noSubscript
    !assignmentSources: {}
    !attributes: .none
    !omnibusTypeDescriptionName: mTypeName
    !kind: .generic {!parameters: mGenericFormalParameterList !whereClause: mWhereClause !llvmNativeTypeNameExpression: mLLVMNativeTypeNameExpression}
    !llvmBaseTypeName: "" # Empty String, compile time type
  }
  [!?ioContext.mTypeMap insertType
    !lkey: mTypeName
    !type: genericType
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

