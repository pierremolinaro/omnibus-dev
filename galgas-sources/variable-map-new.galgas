#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    V A R I A B L E    M A P                                                                                           
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @namedObjectMap {
  @objectIR mObject

  insert insertKey error message "duplicated %K (already declared at %L)"
  search searchKey error message "%K does not exist"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc initialVariableMap
  ?routineNameForInvocation:let @string inRoutineNameForInvocation
  ?context:let @semanticContext inContext
  ?userMode:let @bool inAcceptUserMode
  ?registerAccess:let @accessKind inRegisterAccessKind
  ?globalsAreConstant:@bool inGlobalsAreConstant
  ?returnTypeName:let @lstring inReturnTypeName
  !@variableMap outVariableMap
  !@namedObjectMap outObjectMap
{
  outVariableMap = .emptyMap
  outObjectMap = {}
#------------------------------------------------------- Add modules
  for (moduleName) in inContext.mModuleMap do
    let moduleTypeName = @lstring.new {!moduleName.string + "$" !moduleName.location}
    let moduleType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName}
    [!?outVariableMap insertModule
      !lkey:moduleName
      !type:moduleType
      !readAccessAllowed:false
      !variableKind:.globalVariable {!type:moduleType !name:moduleName.string !volatile:false}
      !copyable:false
      !canBeUsedAsInputParameter:false # Cannot be used as input parameter
    ]
    let moduleAsVariable = @objectIR.globalVariableReference {
      !type:moduleType
      !plmName:moduleName
    }
    [!?outObjectMap insertKey
      !moduleName
      !moduleAsVariable
    ]
  end
#------------------------------------------------------- Add registers
  switch inRegisterAccessKind
  case noAccess :
    for () in inContext.mControlRegisterMap do
      let objectReference = @objectIR.registerReference {
        !type:mType
        !plmName:lkey
        !readable:false
        !writable:false
        !address:mAddress 
        !sliceMap:mRegisterFieldAccessMap
        !arraySize: mArraySize # 0 if not an array
        !elementSize: mElementArraySize # 0 if not an array
      }
      [!?outObjectMap insertKey !lkey !objectReference]
      let objectInMemory = @objectInMemoryIR.register {
        !type:mType
        !plmName:lkey
        !readable:false
        !writable:false
        !address:mAddress 
        !sliceMap:mRegisterFieldAccessMap
        !arraySize: mArraySize # 0 if not an array
        !elementSize: mElementArraySize # 0 if not an array
      }
      [!?outVariableMap insertInaccessibleControlRegister
        !lkey:lkey
        !type:mType
        !readAccessAllowed:false
        !variableKind:objectInMemory
        !copyable:false
        !canBeUsedAsInputParameter:false # Cannot be used as input parameter
      ]
    end
  case readAccess :
    for () in inContext.mControlRegisterMap do
      if inAcceptUserMode && not mIsAccessibleInUserMode then
        let objectReference = @objectIR.registerReference {
          !type:mType
          !plmName:lkey
          !readable:false
          !writable:false
          !address:mAddress 
          !sliceMap:mRegisterFieldAccessMap
          !arraySize: mArraySize # 0 if not an array
          !elementSize: mElementArraySize # 0 if not an array
        }
        [!?outObjectMap insertKey !lkey !objectReference]
        let objectInMemory = @objectInMemoryIR.register {
          !type:mType
          !plmName:lkey
          !readable:false
          !writable:false
          !address:mAddress 
          !sliceMap:mRegisterFieldAccessMap
          !arraySize: mArraySize # 0 if not an array
          !elementSize: mElementArraySize # 0 if not an array
        }
        [!?outVariableMap insertInaccessibleControlRegister
          !lkey:lkey
          !type:mType
          !readAccessAllowed:true
          !variableKind:objectInMemory
          !copyable:true
          !canBeUsedAsInputParameter:false # Cannot be used as input parameter
        ]
      elsif mIsReadOnly || inGlobalsAreConstant then
        let objectReference = @objectIR.registerReference {
          !type:mType
          !plmName:lkey
          !readable:true
          !writable:false
          !address:mAddress 
          !sliceMap:mRegisterFieldAccessMap
          !arraySize: mArraySize # 0 if not an array
          !elementSize: mElementArraySize # 0 if not an array
        }
        [!?outObjectMap insertKey !lkey !objectReference]
        let objectInMemory = @objectInMemoryIR.register {
          !type:mType
          !plmName:lkey
          !readable:true
          !writable:false
          !address:mAddress 
          !sliceMap:mRegisterFieldAccessMap
          !arraySize: mArraySize # 0 if not an array
          !elementSize: mElementArraySize # 0 if not an array
        }
        [!?outVariableMap insertUsedConstant
          !lkey:lkey
          !type:mType
          !readAccessAllowed:true
          !variableKind:objectInMemory
          !copyable:true
          !canBeUsedAsInputParameter:false # Cannot be used as input parameter
        ]
      end
    end
  case readWriteAccess :
    for () in inContext.mControlRegisterMap do
      let objectReference = @objectIR.registerReference {
        !type:mType
        !plmName:lkey
        !readable:true
        !writable:true
        !address:mAddress 
        !sliceMap:mRegisterFieldAccessMap
        !arraySize: mArraySize # 0 if not an array
        !elementSize: mElementArraySize # 0 if not an array
      }
      [!?outObjectMap insertKey !lkey !objectReference]
      let objectInMemory = @objectInMemoryIR.register {
        !type:mType
        !plmName:lkey
        !readable:true
        !writable:true
        !address:mAddress 
        !sliceMap:mRegisterFieldAccessMap
        !arraySize: mArraySize # 0 if not an array
        !elementSize: mElementArraySize # 0 if not an array
      }
      [!?outVariableMap insertDefinedVariable
        !lkey:lkey
        !type:mType
        !readAccessAllowed:true
        !variableKind:objectInMemory
        !copyable:true
        !canBeUsedAsInputParameter:false # Cannot be used as input parameter
      ]
    end
  end
#------------------------------------------------------- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outVariableMap insertUsedConstant
      !lkey:constantName
      !type:[constantValue type]
      !readAccessAllowed:true
      !variableKind:.staticConstant {!value:constantValue !name:constantName}
      !copyable:true
      !canBeUsedAsInputParameter:false # Cannot be used as input parameter
    ]
    [!?outObjectMap insertKey !constantName !constantValue]
  end
#------------------------------------------------------- Add global variables
  for variable in inContext.mGlobalVariableMap do
    var writeAccess = variable.allowedAccessToAll
    var allowedAccess = writeAccess
    if not writeAccess then
      allowedAccess = [variable.allowedRoutineMap hasKey !inRoutineNameForInvocation]
      if allowedAccess then
        writeAccess = [variable.allowedRoutineMap mHasWriteAccessForKey !inRoutineNameForInvocation]
      else
        allowedAccess = [variable.allowedISRMap hasKey !inRoutineNameForInvocation]
        if allowedAccess then
          writeAccess = [variable.allowedISRMap mHasWriteAccessForKey !inRoutineNameForInvocation]
        end
      end
    end
    if inGlobalsAreConstant || variable.isConstant || not writeAccess then
      let resultVariable = @objectIR.globalVariableReference {
        !type:variable.type
        !plmName:variable.lkey
      }
      [!?outObjectMap insertKey !variable.lkey !resultVariable]
      [!?outVariableMap insertUsedConstant
        !lkey:variable.lkey
        !type:variable.type
        !readAccessAllowed:allowedAccess
        !variableKind:.globalVariable {!type:variable.type !name:variable.lkey.string !volatile:[variable.executionModeSet count] > 1}
        !copyable:[variable.type copyable]
        !canBeUsedAsInputParameter:false
      ]
    else
      let resultVariable = @objectIR.globalVariableReference {
        !type:variable.type
        !plmName:variable.lkey
      }
      [!?outObjectMap insertKey !variable.lkey !resultVariable]
      [!?outVariableMap insertDefinedVariable
        !lkey:variable.lkey
        !type:variable.type
        !readAccessAllowed:allowedAccess
        !variableKind:.globalVariable {!type:variable.type !name:variable.lkey.string !volatile:[variable.executionModeSet count] > 1}
        !copyable:[variable.type copyable]
        !canBeUsedAsInputParameter:false
      ]
    end
  end
#------------------------------------------------------- Add result variable ?
  if inReturnTypeName.string != "" then
    let resultVarName = @lstring.new {!functionResultVariableName () !inReturnTypeName.location}
    let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName}
    [!?outVariableMap insertOutputFormalArgument
      !lkey:resultVarName
      !type:resultType
      !readAccessAllowed:true
      !variableKind:.localVariable {!type:resultType !name:resultVarName.string !volatile:false}
      !copyable:true
      !canBeUsedAsInputParameter:true
    ]
    let resultVariable = @objectIR.localVariableReference {
      !type:resultType
      !plmName:inReturnTypeName
    }
    [!?outObjectMap insertKey !resultVarName !resultVariable]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc variableMapWithConstants
  ?context:let @semanticContext inContext
  !@variableMap outVariableMap
  !@namedObjectMap outObjectMap
{
  outVariableMap = .emptyMap
  outObjectMap = {}
#--- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outVariableMap insertUsedConstant
      !lkey:constantName
      !type:[constantValue type]
      !readAccessAllowed:true
      !variableKind:.staticConstant {!value:constantValue !name:constantName}
      !copyable:true
      !canBeUsedAsInputParameter:false
    ]
    [!?outObjectMap insertKey !constantName !constantValue]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
