#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standaloneFunctionInExpressionAST : @expressionAST {
  @lstring mStandaloneFunctionName
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let standaloneFunctionName
    <effective_parameters> !?ioAST ?let arguments ?let endOfArguments
    outExpression = @standaloneFunctionInExpressionAST.new {!standaloneFunctionName !arguments !endOfArguments}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mStandaloneFunctionName]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST noteExpressionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST analyzeExpression
  ?self:let @omnibusType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @omnibusType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outFunctionCallReturnedValue
{
#--- Cannot call a function in guard
  if [inRoutineAttributes guard] then
    error mStandaloneFunctionName.location : "a routine cannot be called in guard"
  end
#--- Get function name and map containing the function definition
  let routineLLVMName = routineMangledNameFromCall (!"" !mStandaloneFunctionName !mArguments)
#--- Get called function signature
  let signature = [mArguments routineSignature !mStandaloneFunctionName.location]
#--- Search function in map
  let requiredFunctionMangledName = @lstring.new {!mStandaloneFunctionName.string + signature !mStandaloneFunctionName}
  if [inContext.mRoutineMap hasKey !requiredFunctionMangledName.string] then
    analyzeRegularFunctionCall (
      !self: inSelfType
      !mangledFunctionName: requiredFunctionMangledName
      !arguments: mArguments
      !routineLLVMName: routineLLVMName
      !routineAttributes: inRoutineAttributes
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap: ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      ?result: outFunctionCallReturnedValue
    )
  elsif [inContext.mTypeMap hasKey !mStandaloneFunctionName.string] then
    analyzeConstructorCall (
      !self: inSelfType
      !typeName: mStandaloneFunctionName
      !arguments: mArguments
      !routineAttributes: inRoutineAttributes
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap: ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !?instructionListIR: ioInstructionGenerationList
      ?result: outFunctionCallReturnedValue
    )
  else
    error requiredFunctionMangledName
    : "Undefined " + requiredFunctionMangledName + " function"
    : outFunctionCallReturnedValue
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeRegularFunctionCall
  ?self:let @omnibusType inSelfType
  ?mangledFunctionName: let @lstring inRequiredFunctionMangledName
  ?arguments: let   @effectiveArgumentListAST inArguments
  ?routineLLVMName: let @lstring inRoutineLLVMName
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outFunctionCallReturnedValue
{
#--- Cannot call a function in guard
  [inContext.mRoutineMap searchKey
    !inRequiredFunctionMangledName
    ?let unused implementedPublic
    ?let formalSignature
    ?let formalReturnTypeProxy # null if no returned value
    ?let implementedModeDictionary
    ?let unused isExported
    ?let unused implementedMode
  ]
#--- Check routine is actually a function
  if formalReturnTypeProxy == .null then
    error inRequiredFunctionMangledName : "this function does not return any value" : outFunctionCallReturnedValue
  else
  #--- Check modes
    let functionLLVMName = checkModeAndReturnsRoutineLLVMName (!implementedModeDictionary !inMode !inRequiredFunctionMangledName)
  #--- Analyze effective parameters
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    analyzeEffectiveParameters (
      !self:inSelfType
      !routineAttributes:inRoutineAttributes
      !formal:formalSignature
      !effective: inArguments
      !errorLocation:inRequiredFunctionMangledName.location
      !context:inContext
      !requiredMode:inMode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempValue (![formalReturnTypeProxy type] !?ioTemporaries ?outFunctionCallReturnedValue)
  #--- Code generation
    ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
      !outFunctionCallReturnedValue
      !inRoutineLLVMName
      !functionLLVMName
      !effectiveParameterListIR
    }
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeConstructorCall
  ?self:let @omnibusType inSelfType
  ?typeName: let @lstring inTypeName
  ?arguments: let @effectiveArgumentListAST inEffectiveArguments
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- A constructor accepts only input arguments
  @functionCallEffectiveParameterListAST parameterList = {}
  for (parameter selector) in inEffectiveArguments do
    switch parameter 
    case input (name) :
      error name : "a constructor call accpts only output effective parameter"
    case inputWithType (2* name) :
      error name : "a constructor call accpts only output effective parameter"
    case output (exp @location unused endOfExp) :
      parameterList += !selector !exp
    case outputInput (name) :
      error name : "a constructor call accpts only output effective parameter"
    case outputInputSelfVariable (name) :
      error name : "a constructor call accpts only output effective parameter"
    end
  end
#--- Analyze effective argument list
  var constructorKey = "("
  for (selector *) in parameterList do
    constructorKey += "!" + selector
  end
  constructorKey += ")"
#--- Analyze constructor signature and init value
  let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inTypeName} type]
  let constructorMap = resultType.constructorMap
  [constructorMap searchKey !.new {!constructorKey !inTypeName} ?let constructorSignature ?let initValue]
#--- Examine init value
  switch initValue
  case arrayValue (elementType size) :
    if constructorKey == "(!repeated)" then
      let expression = [parameterList mExpressionAtIndex !0]
      [expression analyzeExpression
        !self:inSelfType
        !routineAttributes:inRoutineAttributes
        !optionalTargetType:elementType
        !context:inContext
        !mode:inMode
        !?temporary:ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
        ?result:let @objectIR expressionResult
      ]
      let result = checkAssignmentCompatibility (
        !source:expressionResult
        !targetAnnotationType:elementType
        !errorLocation:[parameterList mSelectorAtIndex !0].location
        !staticTypeAllowed:false
      )
      if [result isStatic] then
        let idx = [ioStaticEntityMap.mGlobalStructuredConstantList  length]
        outResult = .llvmArrayRepeatedStaticValue {!type:resultType !arraySize:size !value:result !index:idx}
        @operandIRList operandIRList = {}
        for i in 0 ..< size do
          operandIRList += !result
        end
        ioStaticEntityMap.mGlobalStructuredConstantList += !resultType !operandIRList
      else
        outResult = .llvmArrayRepeatedDynamicValue {!type:resultType !arraySize:size !value:result}
      end
    else
      var individualConstructor = "("
      for i in 0 ..< size do
        individualConstructor += "!"
      end
      individualConstructor += ")"
      if constructorKey == individualConstructor then
        @operandIRList operandIRList = {}
        var resultIsStatic = true
        for () in parameterList do
          [mExpression analyzeExpression
            !self:inSelfType
            !routineAttributes:inRoutineAttributes
            !optionalTargetType:elementType
            !context:inContext
            !mode:inMode
            !?temporary:ioTemporaries
            !?staticEntityMap:ioStaticEntityMap
            !?variableMap:ioUniversalMap
            !?alloca:ioAllocaList
            !?instructionListIR:ioInstructionGenerationList
            ?result:let @objectIR expressionResult
          ]
          let result = checkAssignmentCompatibility (
            !source:expressionResult
            !targetAnnotationType:elementType
            !errorLocation:mSelector.location
            !staticTypeAllowed:false
          )
          operandIRList += !result
          resultIsStatic = resultIsStatic && [result isStatic]
        end
        if resultIsStatic then
          let idx = [ioStaticEntityMap.mGlobalStructuredConstantList  length]
          outResult = .llvmArrayStaticValues {!type:resultType !values:operandIRList !index:idx}
          ioStaticEntityMap.mGlobalStructuredConstantList += !resultType !operandIRList
        else
          outResult = .llvmArrayDynamicValues {!type:resultType !values:operandIRList}
        end
      else
        error inTypeName : "invalid constructor" : outResult
      end
    end
  case null :
    outResult = .null {!type: resultType}
  case simple (value) :
    if [parameterList length] != 0 then
      error inTypeName : resultType.omnibusTypeDescriptionName + " constructor should have no parameter" : outResult
    else
      outResult = .literalInteger {!type: resultType !value:value}
    end
  case structure (sortedOperandList) :
    var sortedOperandIRList = sortedOperandList
    if [parameterList length] != [constructorSignature length] then
      error inTypeName : "this constructor call should name " + [constructorSignature length] + " parameter"
        + if [constructorSignature length] > 1 then "s" else "" end
        + " instead of " + [parameterList length]
      : outResult
    else
      for () formal_ in constructorSignature, () effective_ in parameterList do
        if effective_mSelector.string != formal_mSelector  then
          error effective_mSelector : "the selector should be '!" + formal_mSelector + ":'"
        end
        [effective_mExpression analyzeExpression
          !self:inSelfType
          !routineAttributes:inRoutineAttributes
          !optionalTargetType:formal_mType
          !context:inContext
          !mode:inMode
          !?temporary:ioTemporaries
          !?staticEntityMap:ioStaticEntityMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !?instructionListIR:ioInstructionGenerationList
          ?result:let @objectIR expressionResult
        ]
        var result = checkAssignmentCompatibility (
          !source:expressionResult
          !targetAnnotationType:formal_mType
          !errorLocation:effective_mSelector.location
          !staticTypeAllowed:false
        )
        [!?ioInstructionGenerationList appendLoadWhenReference !?ioTemporaries !?result]
        sortedOperandIRList += !result !formal_mFieldIndex
      end
      outResult = .llvmStructureValue {!type:resultType !values:sortedOperandIRList}
    end
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
