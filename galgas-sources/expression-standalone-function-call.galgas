#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standaloneFunctionInExpressionAST : @expressionAST {
  @lstring mStandaloneFunctionName
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let standaloneFunctionName
    <effective_parameters> !?ioAST ?let arguments ?let endOfArguments
    outExpression = @standaloneFunctionInExpressionAST.new {!standaloneFunctionName !arguments !endOfArguments}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mStandaloneFunctionName]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST noteExpressionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outFunctionCallReturnedValue
{
#--- Cannot call a function in guard
  if [inRoutineAttributes guard] then
    error mStandaloneFunctionName.location : "a routine cannot be called in guard"
  end
#--- Get function name and map containing the function definition
  let routineLLVMName = routineMangledNameFromCall (!"" !mStandaloneFunctionName !mArguments)
#--- Get called function signature
  let signature = [mArguments routineSignature !mStandaloneFunctionName.location]
#--- Search function in map
  let requiredFunctionMangledName = mStandaloneFunctionName.string + signature
  [inContext.mRoutineMap searchKey
    !.new {!requiredFunctionMangledName !mStandaloneFunctionName}
    ?let unused implementedPublic
    ?let formalSignature
    ?let formalReturnTypeProxy # null if no returned value
    ?let implementedModeDictionary
    ?let unused implementedIsSafe
    ?let unused implementedIsExported
    ?let unused implementedMode
  ]
#--- Check routine is actually a function
  if formalReturnTypeProxy == .null then
    error mStandaloneFunctionName : "this function does not return any value" : outFunctionCallReturnedValue
  else
  #--- Check modes
    @string functionLLVMName
    if [implementedModeDictionary hasKey !inCurrentMode] then
      [implementedModeDictionary searchKey !inCurrentMode ?functionLLVMName]
    elsif [implementedModeDictionary hasKey !.anyMode] then
      [implementedModeDictionary searchKey !.anyMode ?functionLLVMName]
    else
      error mStandaloneFunctionName : "this function cannot be invoked in " + inCurrentMode + " mode" : functionLLVMName
    end
  #--- Analyze effective parameters
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    analyzeEffectiveParameters (
      !self:inSelfType
      !routineAttributes:inRoutineAttributes
      !formal:formalSignature
      !effective:mArguments
      !errorLocation:mStandaloneFunctionName.location
      !context:inContext
      !requiredMode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempValue (![formalReturnTypeProxy type] !?ioTemporaries ?outFunctionCallReturnedValue)
  #--- Code generation
    ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
      !"" # globalVariableReceiverName
      !outFunctionCallReturnedValue
      !routineLLVMName
      !functionLLVMName
      !.function # calleeKind
      !effectiveParameterListIR
    }
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
