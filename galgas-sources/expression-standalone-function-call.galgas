#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standaloneFunctionInExpressionAST : @expressionAST {
  @lstring mStandaloneFunctionName
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $identifier$ ?let standaloneFunctionName
    <effective_parameters> !?ioAST ?let arguments ?let endOfArguments
    outExpression = @standaloneFunctionInExpressionAST.new {!standaloneFunctionName !arguments !endOfArguments}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mStandaloneFunctionName]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST noteExpressionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !typeName]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outFunctionCallReturnedValue
{
#--- Cannot call a function in guard
  if [inRoutineAttributes guard] then
    error mStandaloneFunctionName.location : "a routine cannot be called in guard"
  end
#--- Get function name and map containing the function definition
  let routineMangledName = routineMangledNameFromCall (!"" !mStandaloneFunctionName !mArguments)
#--- Get called function signature
  let signature = [mArguments routineSignature !mStandaloneFunctionName.location]
#--- Search function in map
  [inContext.mRoutineMapForContextEX searchKey
    !""
    !mStandaloneFunctionName
    !signature
    ?* # let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
    ?*
  ]
#  let isPublic = routineDescriptor.mIsPublic
  let routineKind = routineDescriptor.routineKind
  let calleeMode = [routineKind executionMode]
  let formalSignature = routineDescriptor.signature
#--- Check routine is actually a function
  if routineDescriptor.returnTypeProxy == .null then
    error mStandaloneFunctionName : "not a function (returns no value)" : routineDescriptor, outFunctionCallReturnedValue
  else
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:inCurrentMode
      !calleeMode:calleeMode
      !kind:routineKind
      !error:mStandaloneFunctionName.location
    )
  #--- Analyze effective parameters
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    analyzeEffectiveParameters (
      !self:inSelfType
      !routineAttributes:inRoutineAttributes
      !formal:formalSignature
      !effective:mArguments
      !errorLocation:mStandaloneFunctionName.location
      !context:inContext
      !requiredMode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempValue (![routineDescriptor.returnTypeProxy type] !?ioTemporaries ?outFunctionCallReturnedValue)
  #--- Code generation
    ioInstructionGenerationList += !@standaloneRoutineCallIR.new {
      !"" # globalVariableReceiverName
      !outFunctionCallReturnedValue
      !routineMangledName
      !routineDescriptor.nameForLLVMGeneration # LLVMInvocationRoutineName
      !calleeKind
      !effectiveParameterListIR
    }
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
