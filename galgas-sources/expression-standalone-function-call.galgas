#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standaloneFunctionInExpressionAST : @expressionAST {
  @lstring mStandaloneFunctionName
  @effectiveArgumentListAST mArguments
  @location mEndOfArguments
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX                                                                                                               
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $identifier$ ?let standaloneFunctionName
    <effective_parameters> ?let arguments ?let endOfArguments
    outExpression = @standaloneFunctionInExpressionAST.new {!standaloneFunctionName !arguments !endOfArguments}
  }

  #·····················································································································

}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mStandaloneFunctionName]
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST noteExpressionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for () in mArguments do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !llvmRegularTypeMangledNameFromName (!typeName)]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS                                                                                                            
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneFunctionInExpressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outFunctionCallReturnedValue
{
#--- Cannot call a function in guard
  if inGuard then
    error mStandaloneFunctionName.location : "a routine cannot be called in guard"
  end
#--- Get function name and map containing the function definition
  let routineMangledName = routineMangledNameFromCall (!"" !mStandaloneFunctionName !mArguments)
#--- Get called function signature
  let signature = [mArguments routineSignature !mStandaloneFunctionName.location]
#--- Search function in map
  [inContext.mRoutineMapForContext searchKey
    !mStandaloneFunctionName
    !signature
    ?let @lstring LLVMInvocationRoutineName
    ?@routineDescriptor routineDescriptor
    ?*
  ]
#  let isPublic = routineDescriptor.mIsPublic
  let routineKind = routineDescriptor.mRoutineKind
  let calleeMode = [routineKind executionMode]
  let formalSignature = routineDescriptor.mSignature
#--- Check routine is actually a function
  if [[routineDescriptor.mReturnTypeProxy type] mKind] == .void then
    error mStandaloneFunctionName : "not a function (returns no value)" : routineDescriptor, outFunctionCallReturnedValue
  else
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:inCurrentMode
      !calleeMode:calleeMode
      !kind:routineKind
      !error:mStandaloneFunctionName.location
    )
  #--- Analyze effective parameters
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    analyzeEffectiveParameters (
      !self:inSelfType
      !formal:formalSignature
      !effective:mArguments
      !errorLocation:mStandaloneFunctionName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredMode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
  #--- New LLVM variable for function call result
    getNewTempValue (![routineDescriptor.mReturnTypeProxy type] !?ioTemporaries ?outFunctionCallReturnedValue)
  #--- Code generation
    ioInstructionGenerationList += !@staticRoutineCallIR.new {
      !"" # globalVariableReceiverName
      !outFunctionCallReturnedValue
      !routineMangledName
      !LLVMInvocationRoutineName
      !calleeKind
      !effectiveParameterListIR
    }
  #--- Enter in invocation graph
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineMangledName]
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
