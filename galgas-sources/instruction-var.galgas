#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @varInstructionWithAssignmentAST : @instructionAST {
  @lstring mVarName
  @lstring mOptionalTypeName
  @expressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @varInstructionAST : @instructionAST {
  @lstring mVarName
  @lstring mTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $var$
    $identifier$ ?let varName
    @lstring optionalTypeName
    select
      optionalTypeName = ["" nowhere]
    or
      $\$type$ ?optionalTypeName
    end
    $=$
    <expression> ?let @expressionAST expression
    ioInstructionList += !varName.location !@varInstructionWithAssignmentAST.new {
      !varName
      !optionalTypeName
      !expression
    }
  }

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $var$
    $identifier$ ?let varName
    $\$type$ ?let typeName
    ioInstructionList += !varName.location !@varInstructionAST.new {
      !varName
      !typeName
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @varInstructionWithAssignmentAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  if mOptionalTypeName.string != "" then
    let typeName = llvmRegularTypeMangledNameFromName (!mOptionalTypeName)
    [!?ioGraph noteNode !typeName]
  end
  [mSourceExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @varInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  let typeName = llvmRegularTypeMangledNameFromName (!mTypeName)
  [!?ioGraph noteNode !typeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @varInstructionWithAssignmentAST analyze
#  ?self:let @unifiedTypeMap-proxy inSelfType
#  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
#  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
#  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
#  ?context:let @semanticContext inContext
#  ?mode:let @mode inCurrentMode
#  ?!temporary:@semanticTemporariesStruct ioTemporaries
#  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
#  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
#  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
#  ?!alloca:@allocaList ioAllocaList
#  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
#{
#  @unifiedTypeMap-proxy targetType = if mOptionalTypeName.string == ""
#    then .null
#    else .searchKey {!inContext.mTypeMap !mOptionalTypeName}
#  end
##--- Analyze source expression
#  [mSourceExpression analyzeExpression
#    !self:inSelfType
#    !inGuard:false
#    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#    !optionalTargetType:targetType
#    !context:inContext
#    !mode:inCurrentMode
#    !?temporary:ioTemporaries
#    !?staticStringMap:ioGlobalLiteralStringMap
#    !?variableMap:ioUniversalMap
#    !?alloca:ioAllocaList
#    !?instructionListIR:ioInstructionGenerationList
#    ?result:let @objectIR sourcePossibleReference
#  ]
#  [!?ioInstructionGenerationList appendLoadFromReference
#    !?ioTemporaries
#    !sourcePossibleReference
#    !mVarName
#    ?let expressionResult
#  ]  
##--- Check type compatibility
#  if targetType == .null then
#    targetType = [expressionResult type]
#  end
#  let result = checkAssignmentCompatibility (
#    !source:expressionResult
#    !targetAnnotationType:targetType
#    !errorLocation:mVarName.location
#    !staticTypeAllowed:false
#  )
#  drop expressionResult, targetType
##--- Declare local variable
#  let varName = @lstring.new {!mVarName.string + "." + ioTemporaries.mTemporaryIndex !mVarName}
#  ioTemporaries.mTemporaryIndex ++
#  let objectIR = @objectIR.localVariableReference {!type:[result type] !plmName:varName}
#  [!?ioUniversalMap insertLocalVariable !mVarName !objectIR !.hasUnreadValue !false]
#  [!?ioVariableMap insertDefinedVariable
#    !lkey:mVarName
#    !type:[result type]
#    !readAccessAllowed:true
#    !objectIR:objectIR
#    !copyable:[[result type] copyable]
#    !canBeUsedAsInputParameter:true
#  ]
##--- Code generation
#  ioAllocaList += !varName ![[[result type] kind] llvmTypeName]
#  [!?ioInstructionGenerationList appendStoreLocalVariable
#    !varName
#    ![result type]
#    !result
#  ]
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @varInstructionAST analyze
#  ?self:let @unifiedTypeMap-proxy unused inSelfType
#  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
#  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
#  ?routineNameForInvocationGraph:let @lstring unused inCallerNameForInvocationGraph
#  ?context:let @semanticContext inContext
#  ?mode:let @mode unused inCurrentMode
#  ?!temporary:@semanticTemporariesStruct ioTemporaries
#  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
#  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
#  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
#  ?!alloca:@allocaList ioAllocaList
#  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
#{
#  let @unifiedTypeMap-proxy targetType = .searchKey {!inContext.mTypeMap !mTypeName}
##---
#  if not [[targetType kind] instanciable] then
#    error mVarName : "$" + [targetType key] + " type is not instanciable"
#  end
##--- Declare local variable
#  let varLLVMName = @lstring.new {!mVarName.string + "." + ioTemporaries.mTemporaryIndex !mVarName}
#  ioTemporaries.mTemporaryIndex ++
#  let objectIR = @objectIR.localVariableReference {!type:targetType !plmName:varLLVMName}
#  [!?ioUniversalMap insertLocalVariable !mVarName !objectIR !.noValue !true]
#  [!?ioVariableMap insertUndefinedVariable
#    !lkey:mVarName
#    !type:targetType
#    !readAccessAllowed:true
#    !objectIR:objectIR
#    !copyable:[targetType copyable]
#    !canBeUsedAsInputParameter:true
#  ]
##--- Code generation
#  ioAllocaList += !varLLVMName ![[targetType kind] llvmTypeName]
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
