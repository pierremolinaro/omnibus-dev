
setter @instructionListIR appendLogicalShiftRight
  ?!@objectIR ioResult
  ?let @uint inShiftAmount
  ?!@semanticTemporariesStruct ioTemporaries
{
  if [ioResult isLiteralInteger] then
    [ioResult literalInteger ?type:let @PLMType type ?value:let @bigint value]
    ioResult = .literalInteger {!type:type !value:value >> inShiftAmount}
  else
    [!?self appendLoadWhenReference !?ioTemporaries !?ioResult]
    let source = ioResult
    getNewTempValue (![source type] !?ioTemporaries ?ioResult)
    self += !@logicalRightShiftIR.new {!ioResult !source !inShiftAmount}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @logicalRightShiftIR : @abstractInstructionIR {
  @objectIR mResult
  @objectIR mSource
  @uint mShiftAmount
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @logicalRightShiftIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "  " + [mResult llvmName] + " = "
  ioLLVMcode += "lshr " + [mResult  llvmTypeName] + " " + [mSource llvmName] + ", " + mShiftAmount + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @logicalRightShiftIR enterAccessibleEntities
  ?!@stringset unused ioInvokedRoutineSet
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
