#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @extendStaticArrayExpressionAST {
  case expression (@expressionAST exp)
  case function (@lstring functionName @routineFormalArgumentList formalArgs)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @extendStaticArrayExpressionListAST {
  @extendStaticArrayExpressionAST mExpression
  @location mEndOfExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @extendStaticArrayDeclarationAST : @abstractDeclarationAST {
  @lstring mStaticlistName
  @extendStaticArrayExpressionListAST mExpressions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticArrayDeclarationAST location -> @location outLocation {
  outLocation = mStaticlistName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticArrayDeclarationAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticlistName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticArray$
    $identifier$ ?let staticListName
    $($
    repeat
      @extendStaticArrayExpressionListAST expressions = {}
      repeat
        <staticArray_exp> !?expressions
      while
        $,$
      end
      ioAST.mDeclarationListAST += !@extendStaticArrayDeclarationAST.new {!staticListName !expressions}
    while
      $;$
    end
    $)$
  }

  #·····················································································································

  rule <staticArray_exp> ?!@extendStaticArrayExpressionListAST ioExpressions {
    select
      <expression> ?let exp
      ioExpressions += !.expression {!exp:exp} !.here
    or
      $func$
      $identifier$ ?let functionName
      <procedure_formal_arguments> ?formalArguments:let formalArgs
      ioExpressions +=
        !.function {!functionName:functionName !formalArgs:formalArgs}
        !.here
    end
   }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Node name
  let nodeName = @lstring.new{!mStaticlistName.string + "." + [[ioGraph keyList] length] !mStaticlistName}
#--- Add 'constant name' node
  [!?ioGraph addNode !nodeName !self]
#--- Add dependency from static type declaration
  [!?ioGraph addEdge !nodeName !mStaticlistName]
#--- Add dependency from source expression
  for (operand *) in mExpressions do
    switch operand
    case expression (@expressionAST exp) :
      [exp addDependenceEdgeForStaticExpression !nodeName !?ioGraph]
    case function (* @routineFormalArgumentList formalArgs) :
      for (* * formalArgumentTypeName *) in formalArgs do
        let typeName = llvmRegularTypeMangledNameFromName (!formalArgumentTypeName)
        [!?ioGraph noteNode !typeName]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

listmap @staticlistValues_listMap (@stringlist)

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap ioStaticListValueMap
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  [ioContext.mStaticlistMap searchKey !mStaticlistName ?let staticArrayPropertyList]
  if [staticArrayPropertyList length] != [mExpressions length] then
    error mStaticlistName
    : [[staticArrayPropertyList length] string] + " expressions required, "
    + [[mExpressions length] string] + " provided"
  else
    var staticValue = "{"
    for (operand endOfExp) in mExpressions, (* type) in staticArrayPropertyList do
      switch operand
      case expression (@expressionAST exp) :
        if [type isFunction] then
          error endOfExp : "a function name is expected here"
        else
          initialVariableMap (
            !context:ioContext
            !mode:.bootMode
            !globalsAreConstant:true # Any value, there is no defined global variable at this stage
            !returnTypeName:["" nowhere]
            ?*
            ?@universalPropertyAndRoutineMapForContext universalMap
          )
          @semanticTemporariesStruct temporaries = .default
          @instructionListIR instructionGenerationList = {}
          @allocaList allocaList = {}
          [exp analyzeExpression
            !self:.void
            !inGuard:false
            !routineNameForInvocationGraph:["compiler" nowhere]
            !optionalTargetType:type
            !context:ioContext
            !mode:.bootMode
            !?temporary:temporaries
            !?staticStringMap:ioGlobalLiteralStringMap
            !?variableMap:universalMap
            !?alloca:allocaList
            !?instructionListIR:instructionGenerationList
            ?result:let @objectIR expressionResult
          ]
        #--- Check assignment compatibility
          let result = checkAssignmentCompatibility (
            !source:expressionResult
            !targetAnnotationType:type
            !errorLocation:endOfExp
            !staticTypeAllowed:false
          )
          if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [result isStatic] then
            error endOfExp : "source expression cannot be statically computed"
          end
        #--- Enter in static value
          staticValue += [type llvmTypeName] + " " + [expressionResult llvmName]
        end      
      case function (@lstring functionName @routineFormalArgumentList formalArgs) :
        if not [type isFunction] then
          error endOfExp : "a static expression is expected here"
        else
          [type function ?signature:let signature ?mode:let currentMode ?returnTypeProxy:let returnTypeProxy]
          let argumentSignature = [formalArgs routineSignature !functionName]
          [ioContext.mRoutineMapForContext searchKey
            !functionName
            !argumentSignature
            ?let @lstring candidateRoutineLLVMName
            ?let @routineDescriptor routineDescriptor
            ?let functionDefinitionLocation
          ]
          let candidateIsPublic = routineDescriptor.mIsPublic
          let candidateRoutineKind = routineDescriptor.mRoutineKind
          let candidateMode = [routineDescriptor.mRoutineKind executionMode] # routineDescriptor.mExecutionMode
          let candidateSignature = routineDescriptor.mSignature
          let candidateReturnTypeProxy = routineDescriptor.mReturnTypeProxy
        #--- Check accessibility
          if not candidateIsPublic then
            let declarationFile = [functionDefinitionLocation file]
            let invocationFile = [functionName.location file]
            if invocationFile != declarationFile then
              error functionName : "this function is not public"
            end
          end
          if not [candidateRoutineKind isFunction] then
            error functionName : "this routine is not a function"
          end
#          let currentMode = [functionDescriptor.mRoutineKind executionMode]
          if currentMode != candidateMode then
            error functionName : "this function runs in " + candidateMode + " mode, but " + currentMode + " is required"
          end
          if (returnTypeProxy == .null) && (candidateReturnTypeProxy != .null) then
            error functionName : "this function should return an $" + [candidateReturnTypeProxy key] + " object"
          elsif (returnTypeProxy != .null) && (candidateReturnTypeProxy == .null) then
            error functionName : "this function should return no object"
          end
          if [signature length] != [candidateSignature length] then
            error functionName
            : "this function has " + [candidateSignature length] + " argument(s) ("
            + [signature length] + " required)"
          else
            for required in signature, candidate in candidateSignature do
              if required.mTypeProxy != candidate.mTypeProxy then
                error candidate.mSelector : "argument type should be $" + [required.mTypeProxy key]
              end
            end
          end
          staticValue += [type llvmTypeName] + " @" + llvmNameForFunction (!candidateRoutineLLVMName)
        end
      end
    between
      staticValue += ", "
    end
    staticValue += "}"
    ioStaticListValueMap += !mStaticlistName !staticValue
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SOLVE ENTITIES                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST solveEntitiesForDeclarations
  ?context:let @semanticContext unused inSemanticContext
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticArrayMap {
  @stringset mInvokedFunctionSet
  
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @stringset invokedFunctionSet = {}
  for (operand endOfExp) in mExpressions do
    switch operand
    case expression (@expressionAST unused exp) :
    case function (@lstring functionName @routineFormalArgumentList formalArgs) :
    #--- Routine mangled name
      let routineMangledName = routineMangledNameFromAST (
        !"" 
        !functionName
        !formalArgs
      )
      invokedFunctionSet += !routineMangledName
    end
  end
  with mStaticlistName.string in !?ioTemporaries.mStaticArrayMap do
    mInvokedFunctionSet += invokedFunctionSet
  else
    [!?ioTemporaries.mStaticArrayMap insertKey !mStaticlistName !invokedFunctionSet]
  end
  with mStaticlistName.string in !?ioIntermediateCodeStruct.mStaticArrayMap do
    mInvokedFunctionSet += invokedFunctionSet
  else
    [!?ioIntermediateCodeStruct.mStaticArrayMap insertKey !mStaticlistName !invokedFunctionSet]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistValues_listMap generateLLVM ?let @staticArrayMap inUsefulStaticArrayMap ?!@string ioLLVMcode {
  var first = true
  for (key initList) in self do
    if [inUsefulStaticArrayMap hasKey !key] then
      if first then
        first = false
        ioLLVMcode += llvmTitleComment (!"Static Arraies")
      end
      ioLLVMcode += "@" + llvmNameForGlobalVariable (!key) + " = private unnamed_addr constant ["
      ioLLVMcode += [[initList length] string] + " x %$" + llvmNameForStaticListElementType (![key nowhere]) + "] [\n"
      for (value) in initList
      do
        ioLLVMcode += "  %$" + llvmNameForStaticListElementType (![key nowhere]) + " " + value
      between
        ioLLVMcode += ",\n"
      end
      ioLLVMcode += "\n]\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

