#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @extendStaticArrayExpressionAST {
  case expression (@expressionAST exp)
  case function (@mode mode @lstring functionName @procFormalArgumentList formalArgs @lstring returnTypeName)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @extendStaticArrayExpressionListAST {
  @extendStaticArrayExpressionAST mExpression
  @location mEndOfExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @extendStaticArrayDeclarationAST : @abstractDeclaration {
  @lstring mStaticlistName
  @extendStaticArrayExpressionListAST mExpressions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticArrayDeclarationAST location -> @location outLocation {
  outLocation = mStaticlistName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticArrayDeclarationAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticlistName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticArray$
    $identifier$ ?let staticListName
    $($
    @extendStaticArrayExpressionListAST expressions = {}
    repeat
      select
        <expression> ?let exp
        expressions += !.expression {!exp:exp} !.here
      or
        $func$
        <mode> ?let mode
        $identifier$ ?let functionName
        <procedure_formal_arguments> ?formalArguments:let formalArgs
        @lstring returnTypeName
        select
          returnTypeName = ["" here]
        or
          $->$
          $\$type$ ?returnTypeName
        end
        expressions +=
          !.function {!mode:mode !functionName:functionName !formalArgs:formalArgs !returnTypeName:returnTypeName}
          !.here
      end
    while
      $,$
    end
    $)$
    ioAST.mDeclarationListAST += !@extendStaticArrayDeclarationAST.new {!staticListName !expressions}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Node name
  let nodeName = @lstring.new{!mStaticlistName.string + "." + [[ioGraph keyList] length] !mStaticlistName}
#--- Add 'constant name' node
  [!?ioGraph addNode !nodeName !self]
#--- Add dependency from static type declaration
  [!?ioGraph addEdge !nodeName !mStaticlistName]
#--- Add dependency from source expression
  for (operand *) in mExpressions do
    switch operand
    case expression (@expressionAST exp) :
      [exp addDependenceEdgeForStaticExpression !nodeName !?ioGraph]
    case function (* * @procFormalArgumentList formalArgs @lstring returnTypeName) :
      for (* * formalArgumentTypeName *) in formalArgs do
        let typeName = llvmRegularTypeMangledNameFromName (!formalArgumentTypeName)
        [!?ioGraph noteNode !typeName]
      end
      if returnTypeName.string != "" then
        let typeName = llvmRegularTypeMangledNameFromName (!returnTypeName)
        [!?ioGraph noteNode !typeName]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

listmap @staticlistValues_listMap (@stringlist)

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap ioStaticListValueMap
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  [ioContext.mStaticlistMap searchKey !mStaticlistName ?let staticArrayPropertyList]
  if [staticArrayPropertyList length] != [mExpressions length] then
    error mStaticlistName
    : [[staticArrayPropertyList length] string] + " expressions required, "
    + [[mExpressions length] string] + " provided"
  else
    var staticValue = "{"
    for (operand endOfExp) in mExpressions, (* type) in staticArrayPropertyList do
      switch operand
      case expression (@expressionAST exp) :
        if [[type kind] isFunction] then
          error endOfExp : "a function name is expected here"
        else
          initialVariableMap (
            !context:ioContext
            !mode:.bootMode
            !globalsAreConstant:true # Any value, there is no defined global variable at this stage
            !returnTypeName:["" nowhere]
            ?@variableMap variableMap
          )
          @semanticTemporariesStruct temporaries = .default
          @instructionListIR instructionGenerationList = {}
          @allocaList allocaList = {}
          [exp analyzeExpression
            !self:.null
            !directAccessToPropertiesAllowed:false
            !inGuard:false
            !routineNameForInvocationGraph:["compiler" nowhere]
            !optionalTargetType:type
            !context:ioContext
            !mode:.bootMode
            !?temporary:temporaries
            !?staticStringMap:ioGlobalLiteralStringMap
            !?variableMap:variableMap
            !?alloca:allocaList
            !?instructionListIR:instructionGenerationList
            ?result:let @objectIR expressionResult
          ]
        #--- Check assignment compatibility
          let result = checkAssignmentCompatibility (
            !source:expressionResult
            !targetAnnotationType:type
            !errorLocation:endOfExp
            !staticTypeAllowed:false
          )
          if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [result isStatic] then
            error endOfExp : "source expression cannot be statically computed"
          end
        #--- Enter in static value
          staticValue += [[type kind] llvmTypeName] + " " + [expressionResult llvmName]
        end      
      case function (@mode mode @lstring functionName @procFormalArgumentList formalArgs @lstring returnTypeName) :
        if not [[type kind] isFunction] then
          error endOfExp : "a static expression is expected here"
        else
        #--- Compute function mangled name
          var routineMangledName = functionName.string
          routineMangledName += "("
          @procedureSignature signature = {}
          for (formalArgumentPassingMode selector formalArgumentTypeName *) in formalArgs do
            let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
            signature += !formalArgumentPassingMode !selector.string !typeProxy
            routineMangledName += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
          end
          routineMangledName += ")"
          let s = [ioContext.mRoutineMapForContext keyList]
          log s
          let lRoutineMangledName = @lstring.new {!routineMangledName !functionName.location}
          [ioContext.mRoutineMapForContext searchKey
            !lRoutineMangledName
            ?let @lstring candidateRoutineLLVMName
            ?let @bool candidateIsPublic
            ?let @bool candidateIsGlobal
            ?let @mode candidateMode
            ?let @procedureSignature candidateSignature
            ?let @routineKind candidateRoutineKind
            ?let @bool candidateWeak
            ?let @unifiedTypeMap-proxy candidateReturnType
            ?let @bool candidateAppendFileAndLineArgumentForPanicLocation
            ?let @bool candidateCanAccessProperties
            ?let @bool candidateCanMutateProperties
          ]
          staticValue += candidateRoutineLLVMName
        end
      end
    between
      staticValue += ", "
    end
    staticValue += "}"
    ioStaticListValueMap += !mStaticlistName !staticValue
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistValues_listMap generateLLVM ?!@string ioLLVMcode {
  if [self count] > 0 then
    ioLLVMcode += llvmTitleComment (!"Static Lists")
    for (key initList) in self do
      ioLLVMcode += "@" + llvmNameForGlobalVariable (!key) + " = private unnamed_addr constant ["
      ioLLVMcode += [[initList length] string] + " x %$" + llvmNameForStaticListElementType (![key nowhere]) + "] [\n"
      for (value) in initList
      do
        ioLLVMcode += "  %$" + llvmNameForStaticListElementType (![key nowhere]) + " " + value
      between
        ioLLVMcode += ",\n"
      end
      ioLLVMcode += "\n]\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

