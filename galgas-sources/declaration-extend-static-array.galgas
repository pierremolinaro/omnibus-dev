#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @extendStaticArrayExpressionAST {
  case expression (@expressionAST exp)
  case function (@lstring functionName @procFormalArgumentList formalArgs)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @extendStaticArrayExpressionListAST {
  @extendStaticArrayExpressionAST mExpression
  @location mEndOfExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @extendStaticArrayDeclarationAST : @abstractDeclaration {
  @lstring mStaticlistName
  @extendStaticArrayExpressionListAST mExpressions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticArrayDeclarationAST location -> @location outLocation {
  outLocation = mStaticlistName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extendStaticArrayDeclarationAST keyRepresentationForErrorSignaling -> @string {
  result = "staticlist " + mStaticlistName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $extend$
    $staticArray$
    $identifier$ ?let staticListName
    $($
    @extendStaticArrayExpressionListAST expressions = {}
    repeat
      select
        <expression> ?let exp
        expressions += !.expression {!exp:exp} !.here
      or
        $func$
        $identifier$ ?let functionName
        <procedure_formal_arguments> ?formalArguments:let formalArgs
        expressions +=
          !.function {!functionName:functionName !formalArgs:formalArgs}
          !.here
      end
    while
      $,$
    end
    $)$
    ioAST.mDeclarationListAST += !@extendStaticArrayDeclarationAST.new {!staticListName !expressions}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Node name
  let nodeName = @lstring.new{!mStaticlistName.string + "." + [[ioGraph keyList] length] !mStaticlistName}
#--- Add 'constant name' node
  [!?ioGraph addNode !nodeName !self]
#--- Add dependency from static type declaration
  [!?ioGraph addEdge !nodeName !mStaticlistName]
#--- Add dependency from source expression
  for (operand *) in mExpressions do
    switch operand
    case expression (@expressionAST exp) :
      [exp addDependenceEdgeForStaticExpression !nodeName !?ioGraph]
    case function (* @procFormalArgumentList formalArgs) :
      for (* * formalArgumentTypeName *) in formalArgs do
        let typeName = llvmRegularTypeMangledNameFromName (!formalArgumentTypeName)
        [!?ioGraph noteNode !typeName]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

listmap @staticlistValues_listMap (@stringlist)

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap ioStaticListValueMap
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
{
  [ioContext.mStaticlistMap searchKey !mStaticlistName ?let staticArrayPropertyList]
  if [staticArrayPropertyList length] != [mExpressions length] then
    error mStaticlistName
    : [[staticArrayPropertyList length] string] + " expressions required, "
    + [[mExpressions length] string] + " provided"
  else
    var staticValue = "{"
    for (operand endOfExp) in mExpressions, (* type) in staticArrayPropertyList do
      switch operand
      case expression (@expressionAST exp) :
        if [[type kind] isFunction] then
          error endOfExp : "a function name is expected here"
        else
          initialVariableMap (
            !context:ioContext
            !mode:.bootMode
            !globalsAreConstant:true # Any value, there is no defined global variable at this stage
            !returnTypeName:["" nowhere]
            ?@variableMap variableMap
          )
          @semanticTemporariesStruct temporaries = .default
          @instructionListIR instructionGenerationList = {}
          @allocaList allocaList = {}
          [exp analyzeExpression
            !self:.null
            !directAccessToPropertiesAllowed:false
            !inGuard:false
            !routineNameForInvocationGraph:["compiler" nowhere]
            !optionalTargetType:type
            !context:ioContext
            !mode:.bootMode
            !?temporary:temporaries
            !?staticStringMap:ioGlobalLiteralStringMap
            !?variableMap:variableMap
            !?alloca:allocaList
            !?instructionListIR:instructionGenerationList
            ?result:let @objectIR expressionResult
          ]
        #--- Check assignment compatibility
          let result = checkAssignmentCompatibility (
            !source:expressionResult
            !targetAnnotationType:type
            !errorLocation:endOfExp
            !staticTypeAllowed:false
          )
          if ([instructionGenerationList length] > 0) || ([allocaList length] > 0) || not [result isStatic] then
            error endOfExp : "source expression cannot be statically computed"
          end
        #--- Enter in static value
          staticValue += [[type kind] llvmTypeName] + " " + [expressionResult llvmName]
        end      
      case function (@lstring functionName @procFormalArgumentList formalArgs) :
        if not [[type kind] isFunction] then
          error endOfExp : "a static expression is expected here"
        else
          [[type kind] function ?descriptor:let functionDescriptor]
        #--- Routine mangled name
          let routineMangledName = routineMangledNameFromAST (
            !"" 
            !functionName
            !formalArgs
          )
          [ioContext.mRoutineMapForContext searchKey
            !routineMangledName
            ?*
            ?let @lstring candidateRoutineLLVMName
            ?let @routineDescriptor routineDescriptor
          ]
          let candidateIsPublic = routineDescriptor.mIsPublic
          let candidateRoutineKind = routineDescriptor.mRoutineKind
          let candidateMode = routineDescriptor.mMode
          let candidateSignature = routineDescriptor.mSignature
          let candidateReturnType = routineDescriptor.mReturnType
        #--- Check accessibility
          if not candidateIsPublic then
            let declarationFile = [[ioContext.mRoutineMapForContext locationForKey !routineMangledName] file]
            let invocationFile = [functionName.location file]
            if invocationFile != declarationFile then
              error functionName : "this function is not public"
            end
          end
          if not [candidateRoutineKind isFunction] then
            error functionName : "this routine is not a function"
          end
          if functionDescriptor.mMode != candidateMode then
            error functionName : "this function runs in " + candidateMode + " mode, but " + functionDescriptor.mMode + " is required"
          end
          if (functionDescriptor.mReturnType == .null) && (candidateReturnType != .null) then
            error functionName : "this function should return an $" + [candidateReturnType key] + " object"
          elsif (functionDescriptor.mReturnType != .null) && (candidateReturnType == .null) then
            error functionName : "this function should return no object"
          end
          if [functionDescriptor.mSignature length] != [candidateSignature length] then
            error functionName
            : "this function has " + [candidateSignature length] + " argument(s) ("
            + [functionDescriptor.mSignature length] + " required)"
          else
            for required in functionDescriptor.mSignature, candidate in candidateSignature do
              if required.mType != candidate.mType then
                error candidate.mSelector : "argument type should be $" + [required.mType key]
              end
            end
          end
          staticValue += [[type kind] llvmTypeName] + " @" + llvmNameForFunction (!candidateRoutineLLVMName)
        end
      end
    between
      staticValue += ", "
    end
    staticValue += "}"
    ioStaticListValueMap += !mStaticlistName !staticValue
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticArrayMap {
  @stringset mInvokedFunctionSet
  
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extendStaticArrayDeclarationAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @stringset invokedFunctionSet = {}
  for (operand endOfExp) in mExpressions do
    switch operand
    case expression (@expressionAST unused exp) :
    case function (@lstring functionName @procFormalArgumentList formalArgs) :
    #--- Routine mangled name
      let routineMangledName = routineMangledNameFromAST (
        !"" 
        !functionName
        !formalArgs
      )
      invokedFunctionSet += !routineMangledName
    end
  end
  with mStaticlistName.string in !?ioTemporaries.mStaticArrayMap do
    mInvokedFunctionSet += invokedFunctionSet
  else
    [!?ioTemporaries.mStaticArrayMap insertKey !mStaticlistName !invokedFunctionSet]
  end
  with mStaticlistName.string in !?ioIntermediateCodeStruct.mStaticArrayMap do
    mInvokedFunctionSet += invokedFunctionSet
  else
    [!?ioIntermediateCodeStruct.mStaticArrayMap insertKey !mStaticlistName !invokedFunctionSet]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @staticlistValues_listMap generateLLVM ?let @staticArrayMap inUsefulStaticArrayMap ?!@string ioLLVMcode {
#  log inUsefulStaticArrayMap
  var first = true
  for (key initList) in self do
    if [inUsefulStaticArrayMap hasKey !key] then
      if first then
        first = false
        ioLLVMcode += llvmTitleComment (!"Static Arraies")
      end
      ioLLVMcode += "@" + llvmNameForGlobalVariable (!key) + " = private unnamed_addr constant ["
      ioLLVMcode += [[initList length] string] + " x %$" + llvmNameForStaticListElementType (![key nowhere]) + "] [\n"
      for (value) in initList
      do
        ioLLVMcode += "  %$" + llvmNameForStaticListElementType (![key nowhere]) + " " + value
      between
        ioLLVMcode += ",\n"
      end
      ioLLVMcode += "\n]\n\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

