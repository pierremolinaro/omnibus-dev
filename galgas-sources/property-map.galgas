#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PROPERTY MAP                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @propertyAccessKind {
  case constantProperty (@objectIR value)
  case indexed  (@PLMType type @uint index)
  case singleton  (@objectIR object @location errorLocation)
  case nonVirtualMethod (@routineDescriptor descriptor)
}

#·······················································································································

map @propertyMap {
  @bool mIsPublic
  @propertyAccessKind mAccess
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#·······················································································································

setter @propertyMap addFunctionWithoutArgument
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @string inMethodName
  ?safe:let @bool inIsSafe
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  ?canMutateProperties:let @bool inCanMutateProperties
{
  let routineMangledName = routineMangledNameFromAST (
    !inLLVMBaseTypeName
    ![inMethodName nowhere]
    !{}
  )
  let @routineDescriptor descriptor = .new {
    !isPublic:true
    !exported:false
    !name:inLLVMBaseTypeName + "." + inMethodName
    !nameForLLVMGeneration:routineMangledName
    !routineKind:.function {!executionMode:.anyMode}
    !signature:{}
    !returnTypeProxy:inResultType # Return type 
    !canAccessProperties:false # Routine is declared with @access attribute
    !canMutateProperties:inCanMutateProperties # Routine is declared with @mutating attribute
    !safe:inIsSafe # Routine is declared with @safe attribute
  }
  [!?self insertKey
    !routineMangledName
    !true
    !.nonVirtualMethod {!descriptor:descriptor}
  ]
}

#·······················································································································

setter @propertyMap addFunctionWithInputArgument
  ?!context:@semanticContext ioContext
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @string inMethodName
  ?safe:let @bool inIsSafe
  ?inputArgumentSelector:let @string inInputSelector
  ?inputArgumentTypeProxy:let @unifiedTypeMap-proxy inInputArgumentTypeProxy
  ?inputArgumentName: let @string inInputArgumentName
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  ?canMutateProperties:let @bool inCanMutateProperties
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector nowhere]
    ![[inInputArgumentTypeProxy key] nowhere]
    ![inInputArgumentName nowhere]
  }
  routineTypedSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let routineMangledName = routineMangledNameFromAST (
    !inLLVMBaseTypeName
    !.new {!inMethodName !.nowhere}
    !argumentList
  )
  let @routineDescriptor descriptor = .new {
    !isPublic:true
    !exported:false
    !name:inMethodName
    !nameForLLVMGeneration:routineMangledName
    !routineKind:.function {!executionMode:.anyMode}
    !signature:signature
    !returnTypeProxy:inResultType # Return type 
    !canAccessProperties:false
    !canMutateProperties:inCanMutateProperties
    !safe:inIsSafe # Routine is declared with @safe attribute
  }
  [!?self insertKey
    !routineMangledName
    !true
    !.nonVirtualMethod {!descriptor:descriptor}
  ]
}

#·······················································································································

setter @propertyMap addFunctionWithTwoInputArguments
  ?!context:@semanticContext ioContext
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @string inMethodName
  ?safe:let @bool inIsSafe
  ?inputArgumentSelector1:let @string inInputSelector1
  ?inputArgumentTypeProxy1:let @unifiedTypeMap-proxy inInputArgumentTypeProxy1
  ?inputArgumentName1: let @string inInputArgumentName1
  ?inputArgumentSelector2:let @string inInputSelector2
  ?inputArgumentTypeProxy2:let @unifiedTypeMap-proxy inInputArgumentTypeProxy2
  ?inputArgumentName2: let @string inInputArgumentName2
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  ?canMutateProperties:let @bool inCanMutateProperties
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector1 nowhere]
    ![[inInputArgumentTypeProxy1 key] nowhere]
    ![inInputArgumentName1 nowhere]
  ,
    !.input
    ![inInputSelector2 nowhere]
    ![[inInputArgumentTypeProxy2 key] nowhere]
    ![inInputArgumentName2 nowhere]
  }
  let routineMangledName = routineMangledNameFromAST (
    !inLLVMBaseTypeName
    !.new {!inMethodName !.nowhere}
    !argumentList
  )
  routineTypedSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let @routineDescriptor descriptor = .new {
    !isPublic:true
    !exported:false
    !name:inMethodName
    !nameForLLVMGeneration:routineMangledName
    !routineKind:.function {!executionMode:.anyMode}
    !signature:signature
    !returnTypeProxy:inResultType # Return type 
    !canAccessProperties:false
    !canMutateProperties:inCanMutateProperties
    !safe:inIsSafe # Routine is declared with @safe attribute
  }
  [!?self insertKey
    !routineMangledName
    !true
    !.nonVirtualMethod {!descriptor:descriptor}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
