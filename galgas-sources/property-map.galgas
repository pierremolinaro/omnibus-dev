#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PROPERTY MAP                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @propertyAccessKind {
  case constantProperty (@objectIR value)
  case indexed  (@PLMType type @uint index)
  case nonVirtualMethod (@routineDescriptor descriptor)
}

#·······················································································································

map @propertyMap {
  @bool mIsPublic
  @propertyAccessKind mAccess
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#·······················································································································

setter @propertyMap addFunctionWithoutArgument
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?receiverTypeName:let @string inReceiverTypeName
  ?methodName:let @string inMethodName
  ?safe:let @bool inIsSafe
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
{
  let @routineDescriptor descriptor = .new {
    !isPublic:true
    !exported:false
    !routineKind:.function {!executionMode:.anyMode}
    !signature:{}
    !returnTypeProxy:inResultType # Return type 
    !canAccessProperties:false # Routine is declared with @access attribute
    !canMutateProperties:false # Routine is declared with @mutating attribute
    !safe:inIsSafe # Routine is declared with @safe attribute
  }
  [!?self insertKey
    ![inMethodName + "()" nowhere]
    !true
    !.nonVirtualMethod {!descriptor:descriptor}
  ]
#--- Routine mangled name
  let routineNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inReceiverTypeName)
    ![inMethodName nowhere]
    !{}
  )
  [!?ioSubprogramInvocationGraph addNode
    !routineNameForInvocationGraph
    !routineNameForInvocationGraph
  ]
}

#·······················································································································

setter @propertyMap addFunctionWithInputArgument
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?receiverTypeName:let @lstring inReceiverTypeName
  ?methodName:let @string inMethodName
  ?safe:let @bool inIsSafe
  ?inputArgumentSelector:let @string inInputSelector
  ?inputArgumentTypeName:let @string inInputArgumentTypeName
  ?inputArgumentName: let @string inInputArgumentName
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  ?canMutateProperties:let @bool inCanMutateProperties
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector nowhere]
    ![inInputArgumentTypeName nowhere]
    ![inInputArgumentName nowhere]
  }
  routineSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let @routineDescriptor descriptor = .new {
    !isPublic:true
    !exported:false
    !routineKind:.function {!executionMode:.anyMode}
    !signature:signature
    !returnTypeProxy:inResultType # Return type 
    !canAccessProperties:false
    !canMutateProperties:inCanMutateProperties
    !safe:inIsSafe # Routine is declared with @safe attribute
  }
  let methodMangledName = routineMangledNameFromAST (
    !""
    !.new {!inMethodName !inReceiverTypeName.location}
    !argumentList
  )
  [!?self insertKey
    !methodMangledName
    !true
    !.nonVirtualMethod {!descriptor:descriptor}
  ]
#--- Routine mangled name
  let routineNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inReceiverTypeName)
    ![inMethodName nowhere]
    !argumentList
  )
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
}

#·······················································································································

setter @propertyMap addFunctionWithTwoInputArguments
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?receiverTypeName:let @lstring inReceiverTypeName
  ?methodName:let @string inMethodName
  ?safe:let @bool inIsSafe
  ?inputArgumentSelector1:let @string inInputSelector1
  ?inputArgumentTypeName1:let @string inInputArgumentTypeName1
  ?inputArgumentName1: let @string inInputArgumentName1
  ?inputArgumentSelector2:let @string inInputSelector2
  ?inputArgumentTypeName2:let @string inInputArgumentTypeName2
  ?inputArgumentName2: let @string inInputArgumentName2
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  ?canMutateProperties:let @bool inCanMutateProperties
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector1 nowhere]
    ![inInputArgumentTypeName1 nowhere]
    ![inInputArgumentName1 nowhere]
  ,
    !.input
    ![inInputSelector2 nowhere]
    ![inInputArgumentTypeName2 nowhere]
    ![inInputArgumentName2 nowhere]
  }
  routineSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let @routineDescriptor descriptor = .new {
    !isPublic:true
    !exported:false
    !routineKind:.function {!executionMode:.anyMode}
    !signature:signature
    !returnTypeProxy:inResultType # Return type 
    !canAccessProperties:false
    !canMutateProperties:inCanMutateProperties
    !safe:inIsSafe # Routine is declared with @safe attribute
  }
  let methodMangledName = routineMangledNameFromAST (
    !""
    !.new {!inMethodName !inReceiverTypeName.location}
    !argumentList
  )
  [!?self insertKey
    !methodMangledName
    !true
    !.nonVirtualMethod {!descriptor:descriptor}
  ]
#--- Routine mangled name
  let routineNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inReceiverTypeName)
    ![inMethodName nowhere]
    !argumentList
  )
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
