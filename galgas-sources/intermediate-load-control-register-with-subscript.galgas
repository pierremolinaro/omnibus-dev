
setter @instructionListIR appendLoadVolatileRegisterWithSubscript
  ?let @operandIR inTargetValue
  ?let @string inRegisterName
  ?let @operandIR inIndexResult
  ?let @bigint inAddress
  ?let @bigint inElementArraySize
{
  self += !@loadRegisterWithSubscriptIR.new {!inTargetValue !inRegisterName !inIndexResult !inAddress !inElementArraySize}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @loadRegisterWithSubscriptIR : @abstractInstructionIR {
  @operandIR mTargetValue
  @string mRegisterName
  @operandIR mIndexResult
  @bigint mRegisterAddress
  @bigint mElementArraySize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @loadRegisterWithSubscriptIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let registerOffsetName = "%register.subscript." + ioGenerationAdds.mUniqueIndex
  let registerIndexName = "%register.index." + ioGenerationAdds.mUniqueIndex
  let scriptedRegisterAddressValueName = "%register.address.value." + ioGenerationAdds.mUniqueIndex
  let scriptedRegisterAddressName = "%register.address." + ioGenerationAdds.mUniqueIndex
  ioGenerationAdds.mUniqueIndex ++
#--- Needs to perm an extend to i32 ?
  [[mIndexResult.mType kind] integer ?min:* ?max:* ?unsigned:* ?bitCount:let bitCount]
  if bitCount < 32 then
    ioLLVMcode += "  " + registerIndexName + " = zext " + [mIndexResult.mType  llvmTypeName]
               + " " + [mIndexResult.mValue llvmName] + " to i32\n"
  end
  ioLLVMcode += "  " + registerOffsetName + " = mul i32 "
             + if bitCount < 32 then registerIndexName else [mIndexResult.mValue llvmName] end
             + ", " + mElementArraySize + " ; " + [mElementArraySize hexString] + "\n"
  ioLLVMcode += "  " + scriptedRegisterAddressValueName + " = add i32 " + registerOffsetName
             + ", " + mRegisterAddress + " ; " + [mRegisterAddress hexString] + "\n"
  let llvmType = [mTargetValue.mType llvmTypeName]
  ioLLVMcode += "  " + scriptedRegisterAddressName + " = inttoptr i32 " + scriptedRegisterAddressValueName
             + " to " + llvmType + " *\n"
  ioLLVMcode += "  " + [mTargetValue.mValue llvmName] + " = load volatile " + llvmType + ", " + llvmType
             + " * " + scriptedRegisterAddressName + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @loadRegisterWithSubscriptIR enterAccessibleEntities 
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioAccessibleEntities.mAccessibleRegisterSet += !mRegisterName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
