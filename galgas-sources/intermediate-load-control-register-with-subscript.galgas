
setter @instructionListIR appendComputeVolatileRegisterAddressWithSubscript
  ?let @objectInMemoryIR inTarget
  ?let @valueIR inIndexResult
  ?let @bigint inAddress
  ?let @bigint inElementArraySize
{
  self += !@ComputeRegisterAddressWithSubscriptIR.new {!inTarget !inIndexResult !inAddress !inElementArraySize}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @ComputeRegisterAddressWithSubscriptIR : @abstractInstructionIR {
  @objectInMemoryIR mTarget
  @valueIR mIndexResult
  @bigint mRegisterAddress
  @bigint mElementArraySize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @ComputeRegisterAddressWithSubscriptIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let registerOffsetName = "%register.subscript." + ioGenerationAdds.mUniqueIndex
  let registerIndexName = "%register.index." + ioGenerationAdds.mUniqueIndex
  let scriptedRegisterAddressValueName = "%register.address.value." + ioGenerationAdds.mUniqueIndex
#  let scriptedRegisterAddressName = "%register.address." + ioGenerationAdds.mUniqueIndex
  ioGenerationAdds.mUniqueIndex ++
#--- Needs to perm an extend to i32 ?
  [[mIndexResult kind] integer ?min:* ?max:* ?unsigned:* ?bitCount:let bitCount ?1*]
  if bitCount < 32 then
    ioLLVMcode += "  " + registerIndexName + " = zext " + [mIndexResult  llvmTypeName]
               + " " + [mIndexResult llvmName] + " to i32\n"
  end
  ioLLVMcode += "  " + registerOffsetName + " = mul i32 "
             + if bitCount < 32 then registerIndexName else [mIndexResult llvmName] end
             + ", " + mElementArraySize + " ; " + [mElementArraySize hexString] + "\n"
  ioLLVMcode += "  " + scriptedRegisterAddressValueName + " = add i32 " + registerOffsetName
             + ", " + mRegisterAddress + " ; " + [mRegisterAddress hexString] + "\n"
  let llvmType = [[mTarget type] llvmTypeName]
  ioLLVMcode += "  " + [mTarget llvmName] + " = inttoptr i32 " + scriptedRegisterAddressValueName
             + " to " + llvmType + " *\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @ComputeRegisterAddressWithSubscriptIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendLoadVolatileRegisterWithSubscript
  ?let @valueIR inTargetValue
  ?let @valueIR inIndexResult
  ?let @bigint inAddress
  ?let @bigint inElementArraySize
{
  self += !@loadRegisterWithSubscriptIR.new {!inTargetValue !inIndexResult !inAddress !inElementArraySize}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @loadRegisterWithSubscriptIR : @abstractInstructionIR {
  @valueIR mTargetValue
  @valueIR mIndexResult
  @bigint mRegisterAddress
  @bigint mElementArraySize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @loadRegisterWithSubscriptIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let registerOffsetName = "%register.subscript." + ioGenerationAdds.mUniqueIndex
  let registerIndexName = "%register.index." + ioGenerationAdds.mUniqueIndex
  let scriptedRegisterAddressValueName = "%register.address.value." + ioGenerationAdds.mUniqueIndex
  let scriptedRegisterAddressName = "%register.address." + ioGenerationAdds.mUniqueIndex
  ioGenerationAdds.mUniqueIndex ++
#--- Needs to perm an extend to i32 ?
  [[mIndexResult kind] integer ?min:* ?max:* ?unsigned:* ?bitCount:let bitCount ?1*]
  if bitCount < 32 then
    ioLLVMcode += "  " + registerIndexName + " = zext " + [mIndexResult  llvmTypeName]
               + " " + [mIndexResult llvmName] + " to i32\n"
  end
  ioLLVMcode += "  " + registerOffsetName + " = mul i32 "
             + if bitCount < 32 then registerIndexName else [mIndexResult llvmName] end
             + ", " + mElementArraySize + " ; " + [mElementArraySize hexString] + "\n"
  ioLLVMcode += "  " + scriptedRegisterAddressValueName + " = add i32 " + registerOffsetName
             + ", " + mRegisterAddress + " ; " + [mRegisterAddress hexString] + "\n"
  let llvmType = [mTargetValue llvmTypeName]
  ioLLVMcode += "  " + scriptedRegisterAddressName + " = inttoptr i32 " + scriptedRegisterAddressValueName
             + " to " + llvmType + " *\n"
  ioLLVMcode += "  " + [mTargetValue llvmName] + " = load volatile " + llvmType + ", " + llvmType
             + " * " + scriptedRegisterAddressName + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @loadRegisterWithSubscriptIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
