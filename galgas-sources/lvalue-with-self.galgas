#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @LValueSelfAST {
  @lstring mIdentifier
  @accessInAssignmentListAST mAccessList
  @location mSelfLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <lvalue_with_self> !@LValueSelfAST outAssignmentTargetAST {
  #--- Self
    $self$
    let selfLocation = @location.here
    $.$
  #--- Property name
    $identifier$ ?let identifier
  #--- Properties and subscript
    @accessInAssignmentListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = .new {!identifier !accessListAST !selfLocation}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST type
  ?self:let @PLMType inSelfType
  !@PLMType outType
{
  if [inSelfType isStructure] then
    [inSelfType structure ?typeName:* ?propertyMap:let structureObjectMap ?4*]
    [structureObjectMap searchKey !mIdentifier ?* ?let object]
    outType = [object type]
  else
    error mSelfLocation : "'self' not available in this context" : outType
  end
  for (access) in mAccessList do
    switch access
    case property (@lstring propertyName) :
      if [outType isStructure] then
        [outType structure ?1* ?propertyMap:let propertyMap ?4*]
        [propertyMap searchKey !propertyName ?* ?let propertyObject]
        outType = [propertyObject type]
      else
        error propertyName : "receiver has no property" : outType
      end
    case arrayAccess (* *) :
      if [outType isArrayType] then
        [outType arrayType ?1* ?elementType:outType ?4*]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST analyzeAssignmentTarget
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind unused inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
#  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
#  ?!variableMap:@unifiedSymbolMapEx ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
#  !@objectIR outCurrentObject
  !@internalRepresentation outInternalRepresentation
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
  outGlobalVariableReceiverName = "" # Receiver is not a global variable
  if [inSelfType isStructure] then
    [inSelfType structure ?typeName:* ?propertyMap:let structureObjectMap ?4*]
    if [structureObjectMap hasKey !mIdentifier] then
      outInternalRepresentation = .structureMember {
        !propertyName:mIdentifier
        !currentPointerIR:.selfObject {!type:inSelfType}
      }
#---
#      [structureObjectMap searchKey
#        !mIdentifier
#        ?*
#        ?let object
#      ]
#      handleSelfAccessInAssignment (
#        !inSelfType
#        !object
#        !?ioTemporaries
#        !?ioInstructionGenerationList
#        ?outCurrentObject
#      )
#---
    else # Function call ?
#      outCurrentObject = .possibleFunction {!receiver:.selfObject {!type:inSelfType} !functionName:mIdentifier}
      outInternalRepresentation = .standAloneIdentifier {!identifier:mIdentifier}
    end
  else
    error mIdentifier
      : "'self' should be a structure instance"
      :outGlobalVariableReceiverName, outInternalRepresentation #, outCurrentObject
  end
#--- Analyze properties, subscripts
  for (access) in mAccessList do
    switch access
    case property (propertyName) :
      handlePropertyAccessInExpression (
        !?outInternalRepresentation
        !propertyName
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:.void
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
#      handlePropertyAccessInAssignmentEX (
#        !?outCurrentObject
#        !propertyName
#        !?ioTemporaries
#        !?ioInstructionGenerationList
#      )
    case arrayAccess (indexExpression endOfExpression) :
      handleArrayAccessInExpression (
        !?outInternalRepresentation
        !indexExpression
        !endOfExpression
        !self:inSelfType
        !inGuard:false
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:.void
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
      )
#      handleSubscriptInAssignmentAndExpressionEX (
#        !self:inSelfType
#        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
#        !inGuard:false
#        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
#        !context:inContext
#        !mode:inCurrentMode
#        !?temporary:ioTemporaries
#        !?staticStringMap:ioGlobalLiteralStringMap
#        !?variableMap:ioVariableMap
#        !?variableMap:ioUniversalMap
#        !?alloca:ioAllocaList
#        !indexExpression
#        !endOfExpression
#        !?ioInstructionGenerationList
#        !?outCurrentObject
#      )
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc handleSelfAccessInAssignment
#  ?let @PLMType inSelfType
#  ?let @objectIR inObject
#  ?!@semanticTemporariesStruct ioTemporaries
#  ?!@instructionListIR ioInstructionGenerationList
#  !@objectIR outObjectPtr
#{
#  if [inObject isProperty] then
#    [inObject property ?type:let type ?plmName:let name ?access:*]
#    outObjectPtr = .temporaryReference {
#      !type:type
#      !llvmName:.new {!"temp." + ioTemporaries.mTemporaryIndex !name}
#      !sliceMap:{}
#      !volatile:false
#    }
#    ioTemporaries.mTemporaryIndex ++
#    [!?ioInstructionGenerationList appendPropertyReferenceFromSelf
#      !outObjectPtr
#      !inSelfType
#      !name
#    ]
#  else
#    error [inObject location] : "<<getNewTemporarySelfObjectPtr>>" : outObjectPtr
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
