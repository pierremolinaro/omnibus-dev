#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @LValueSelfAST {
  @lstring mIdentifier
  @accessInAssignmentListAST mAccessList
  @location mSelfLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <lvalue_with_self> !@LValueSelfAST outAssignmentTargetAST {
  #--- Self
    $self$
    let selfLocation = @location.here
    $.$
  #--- Property name
    $identifier$ ?let identifier
  #--- Properties and subscript
    @accessInAssignmentListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = .new {!identifier !accessListAST !selfLocation}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST type
  ?self:let @PLMType inSelfType
  !@PLMType outType
{
  if [inSelfType isStructure] then
    [inSelfType structure ?1* ?propertyMap:let @propertyMap propertyMap ?4*]
    [propertyMap searchKey !mIdentifier ?2* ?let type ?*]
    outType = type
  else
    error mSelfLocation : "'self' not available in this context" : outType
  end
  for (access) in mAccessList do
    switch access
    case property (@lstring propertyName) :
      if [outType isStructure] then
        [outType structure ?1* ?propertyMap:let @propertyMap propertyMap ?4*]
        [propertyMap searchKey !propertyName ?2* ?let type ?*]
        outType = type
      else
        error propertyName : "receiver has no property" : outType
      end
    case arrayAccess (* *) :
      if [outType isArrayType] then
        [outType arrayType ?1* ?elementType:outType ?4*]
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueSelfAST analyzeAssignmentTarget
  ?self:let @PLMType inSelfType
  ?targetAccessKind:let @targetAccessKind unused inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@internalRepresentation outInternalRepresentation
{
  if not [inSelfType isStructure] then
    error mIdentifier : "'self' should be a structure instance" : outInternalRepresentation
  else
    [inSelfType structure ?typeName:* ?propertyMap:let @propertyMap propertyMap ?4*]
    [propertyMap searchKey !mIdentifier ?2* ?let propertyType ?let propertyAccess]
    switch propertyAccess
    case constant (*) :
      error mIdentifier : "a constant property cannot be modified" : outInternalRepresentation
    case indexed (@uint propertyIndex) :
      [!?ioTemporaries newTempLLVMVar ?let newLLVMPropertyVar]
      [!?ioInstructionGenerationList appendGetUniversalPropertyReference
        !inSelfType
        !"%self"
        !propertyType
        !newLLVMPropertyVar
        !propertyIndex
        !mIdentifier
      ]
      var currentType = propertyType
      var currentLLVMName = newLLVMPropertyVar
      for (access) in mAccessList do
        switch access
        case property (@lstring propertyName) :
          if [currentType isStructure] then
            [currentType structure ?1* ?propertyMap:let @propertyMap propertyMap ?4*]
            [propertyMap searchKey !propertyName ?2* ?let @PLMType propertyType ?let @propertyAccessKind propertyAccess]
            switch propertyAccess
            case constant (*) :
              error propertyName : "a constant property cannot be written" : currentType, currentLLVMName
            case indexed (@uint index) :
              [!?ioTemporaries newTempLLVMVar ?let newLLVMvariable]
              [!?ioInstructionGenerationList appendGetUniversalPropertyReference
                !currentType
                !currentLLVMName
                !propertyType
                !newLLVMvariable
                !index
                !propertyName
              ]
              currentType = propertyType
              currentLLVMName = newLLVMvariable
            end
          else
            error propertyName : "this should be a structure instance"
          end
        case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
          if [currentType isArrayType] then
            [currentType arrayType ?1* ?elementType:let elementType ?size:let @bigint arraySize ?3*]
            handleArraySubscriptNew (
              !self: inSelfType
              !inGuard: false
              !routineNameForInvocationGraph: inCallerNameForInvocationGraph
              !context: inContext
              !mode: inCurrentMode
              !?temporary: ioTemporaries
              !?staticStringMap: ioGlobalLiteralStringMap
              !?variableMap:ioUniversalMap
              !?alloca: ioAllocaList
              !indexExpression 
              !endOfIndex
              !arraySize:arraySize
              !elementType:elementType
              !?ioInstructionGenerationList
              ?let @objectIR indexIR
           )
           [!?ioTemporaries newTempLLVMVar ?let newLLVMvariable]
           [!?ioInstructionGenerationList appendGetUniversalArrayElementReference
             !currentType
             !currentLLVMName
             !elementType
             !newLLVMvariable
             !indexIR
           ]
           currentType = elementType
           currentLLVMName = newLLVMvariable
          else
            error endOfIndex : "cannot subscript, not an array" : currentType, currentLLVMName
          end
        end
      end
      outInternalRepresentation = .universalReference {!type:currentType !llvmName:currentLLVMName}
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
