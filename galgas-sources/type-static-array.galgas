#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @staticArrayTypeDeclarationAST : @abstractDeclarationAST {
  @lstring mArrayTypeName
  @lstring mElementTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <type_definition> ?!@ast ioAST !@lstring outTypeName {
    $[$
    <expression> !?ioAST ?let sizeExpression
    $•$
    <type_definition> !?ioAST ?let elementTypeName
    let sizeExpressionLocation = @location.here
    $]$
    outTypeName = ["anonymous." + ioAST.mTypeDeclarationIndex here]
    ioAST.mTypeDeclarationIndex ++
    ioAST.mDeclarationListAST += !@staticArrayTypeDeclarationAST.new {
      !outTypeName
      !elementTypeName
      !sizeExpression
      !sizeExpressionLocation
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayTypeDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [!?ioGraph addNode !mArrayTypeName !self]
  [!?ioGraph addEdge !mArrayTypeName !mElementTypeName]
  [mSizeExpression addDependenceEdgeForStaticExpression !mArrayTypeName !?ioGraph]
  let rootNode = @lstring.new {!configurationNodeNameForPrecedenceGraph () !mArrayTypeName.location}
  [!?ioGraph addEdge !mArrayTypeName !rootNode]
}

#·······················································································································

override getter @staticArrayTypeDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "anonymous $" + mArrayTypeName 
}

#·······················································································································

override getter @staticArrayTypeDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mArrayTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @staticArrayTypeDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
#--- Get element type
  [ioContext.mTypeMap searchKey !lkey:mElementTypeName ?type:let elementType ?2*]
  if not [elementType copyable] then
    error mElementTypeName : "an array element should be copyable"
  end
  if not [elementType instanciable] then
    error mElementTypeName : "an array element should be instanciable"
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  [mSizeExpression analyzeExpression
    !self:voidType ()
    !routineAttributes:.none
    !routineNameForInvocationGraph:.new {!mArrayTypeName.string + " init" !mArrayTypeName.location}
    !optionalTargetType:voidType ()
    !context:ioContext
    !mode:.bootMode
    !?temporary:temporaries
    !?staticEntityMap:*
    !?variableMap:ioContext.mValuedObjectMap
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:let @objectIR sizeExpressionIR
  ]
  if not [sizeExpressionIR isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR literalInteger ?1* ?value:let arraySize]
  #-------------------------------------------- Original type name
    let plmTypeDescriptionName = @lstring.new {!"[" + arraySize + " • " + elementType.plmTypeDescriptionName + "]" !mArrayTypeName}
    let llvmBaseTypeName = @lstring.new {!elementType.llvmBaseTypeName + "-" + arraySize !mArrayTypeName}
    if [ioContext.mTypeMap hasKey !plmTypeDescriptionName] then
      [ioContext.mTypeMap searchKey !lkey:plmTypeDescriptionName ?type:var type ?2*]
      [!?ioContext.mTypeMap insertType
        !lkey:mArrayTypeName
        !type:type
        !index:[ioContext.mTypeMap count]
        !generate:false
      ]
    else
    #-------------------------------------------- Class method map : add "count" constructor
      @classConstantMap classConstantMap = {}
     [!?classConstantMap insertKey !.new {!"count" !mArrayTypeName} !arraySize ![staticIntegerTypeName () nowhere]]
    #-------------------------------------------- Property map
      @propertyMap arrayTypePropertyMap = {}
      [!?arrayTypePropertyMap insertKey # "count" property
        !.new {!"count" !plmTypeDescriptionName.location}
        !true # public
        !.constantProperty {!value:.literalInteger {!type:staticIntegerType () !value:arraySize}}
      ]
    #-------------------------------------------- Constructor map
      @constructorMap constructorMap = {}
    #--- Constructor (!repeated)
      [!?constructorMap insertKey !["(!repeated)" nowhere] !{} !.arrayValue {!elementType:elementType !size:arraySize}]
    #--- Constructor (!!!!)
      var constructorName = "("
      for i in 0 ..< [arraySize uint] do
        constructorName += "!"
      end
      constructorName += ")"
      [!?constructorMap insertKey ![constructorName nowhere] !{} !.arrayValue {!elementType:elementType !size:arraySize}]
    #-------------------------------------------- Type attributes
      @PLMTypeAttributes typeAttributes = .instanciable | .copyable
    #-------------------------------------------- Enter in type map
      let arrayType = @PLMType.new {
        !propertyMap:arrayTypePropertyMap
        !classConstantMap:classConstantMap
        !constructorMap:constructorMap
        !guardMap:{}
        !attributes:typeAttributes
        !plmTypeDescriptionName:plmTypeDescriptionName
        !kind:.arrayType {!elementType:elementType !size:arraySize}
        !llvmBaseTypeName:llvmBaseTypeName
      }
      [!?ioContext.mTypeMap insertType
        !lkey:mArrayTypeName
        !type:arrayType
        !index:[ioContext.mTypeMap count]
        !generate:false
      ]
      [!?ioContext.mTypeMap insertType
        !lkey:plmTypeDescriptionName
        !type:arrayType
        !index:[ioContext.mTypeMap count]
        !generate:true
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateLLVMCodeForStaticArrayType
  ?!@string ioLLVMcode
  ?!@generationAdds ioGenerationAdds
  ?let @PLMType inStaticArrayTypeName
  ?let @bigint inSize
{
  let llvmBaseTypeName = [[inStaticArrayTypeName llvmBaseTypeName] assemblerRepresentation]
  let llvmTypeName = [inStaticArrayTypeName llvmTypeName]
  let routineMangledName = routineMangledNameFromAST (
    !llvmBaseTypeName
    !["count" nowhere]
    !{}
  )
  let arcAssignmentList = [inStaticArrayTypeName arcList !{}]
  let routineLLVMName = llvmNameForFunction (!routineMangledName.string)
  ioLLVMcode += llvmTitleComment (!routineMangledName)
  ioLLVMcode += "define internal i32  @" + routineLLVMName + " (%"
  ioLLVMcode += llvmBaseTypeName + "* %inUnusedValue) nounwind {\n"
  ioLLVMcode += "  ret i32 " + inSize + "\n"
  ioLLVMcode += "}\n\n"
  ioLLVMcode += llvmSeparatorLine () + "\n"
  ioLLVMcode += "define internal void @plm.assign."
  ioLLVMcode += llvmBaseTypeName
  ioLLVMcode += "."
  ioLLVMcode += llvmBaseTypeName
  ioLLVMcode += " (" + llvmTypeName + " * %inTarget, " + llvmTypeName + "* %inSource) nounwind optsize {\n"
  ioLLVMcode += ";--- Handle ARC properties\n"
  for (propertyName propertyType indexPath) in arcAssignmentList do
    let propertyTypeLLVMName = [propertyType llvmTypeName]
    let llvmVarName = "%arc.retain." + [propertyName assemblerRepresentation] + ioGenerationAdds.mUniqueIndex
    ioGenerationAdds.mUniqueIndex ++
    ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* %inSource, i32 0"
    for (idx) in indexPath do
      ioLLVMcode += ", i32 " + idx
    end
    ioLLVMcode += " ; " + propertyName + "\n"
    let llvmLoadedVarName = llvmVarName + ".loaded"
    ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
    ioLLVMcode += "  call void @arc.retain (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
  end
  for (propertyName propertyType indexPath) in arcAssignmentList do
    let llvmVarName = "%arc.release." + [propertyName assemblerRepresentation] + ioGenerationAdds.mUniqueIndex
    ioGenerationAdds.mUniqueIndex ++
    ioLLVMcode += "  " + llvmVarName + " = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* %inTarget, i32 0"
    for (idx) in indexPath do
      ioLLVMcode += ", i32 " + idx
    end
    ioLLVMcode += " ; " + propertyName + "\n"
    let propertyTypeLLVMName = [propertyType llvmTypeName]
    let llvmLoadedVarName = llvmVarName + ".loaded"
    ioLLVMcode += "  " + llvmLoadedVarName + " = load " + propertyTypeLLVMName + ", " + propertyTypeLLVMName + "* " + llvmVarName + "\n" 
    ioLLVMcode += "  call void @arc.release (" + propertyTypeLLVMName + " " + llvmLoadedVarName + ")\n" 
  end
  ioLLVMcode += ";--- Compute type size\n"
  ioLLVMcode += "  %sizeAsPtr = getelementptr inbounds " + llvmTypeName + ", " + llvmTypeName + "* null, i32 1\n"
  ioLLVMcode += "  %byteCount = ptrtoint " + llvmTypeName + "* %sizeAsPtr to i32\n"
  ioLLVMcode += "  %useLoadStore = icmp ule i32 %byteCount, 12\n"
  ioLLVMcode += "  br i1 %useLoadStore, label %loadStore, label %copyBytesOrCopyWords\n"
  ioLLVMcode += ";--- Copy\n"
  ioLLVMcode += "loadStore:\n"
  ioLLVMcode += "  %v = load " + llvmTypeName + ", " + llvmTypeName + "* %inSource\n" 
  ioLLVMcode += "  store " + llvmTypeName + " %v, " + llvmTypeName + "* %inTarget\n" 
  ioLLVMcode += "  br label %copy.end\n"
  ioLLVMcode += "copyBytesOrCopyWords:\n"
  ioLLVMcode += "  %byteCountAnd3 = and i32 %byteCount, 3\n"
  ioLLVMcode += "  %byteCountIsMutipleOf4 = icmp eq i32 %byteCountAnd3, 0\n"
  ioLLVMcode += "  br i1 %byteCountIsMutipleOf4, label %testTarget, label %copyBytes\n"
  ioLLVMcode += "testTarget:\n"
  ioLLVMcode += "  %targetAsUnsigned = ptrtoint " + llvmTypeName + "* %inTarget to i32\n"
  ioLLVMcode += "  %targetAsUnsignedAnd3 = and i32 %targetAsUnsigned, 3\n"
  ioLLVMcode += "  %targetAsUnsignedIsMutipleOf4 = icmp eq i32%targetAsUnsignedAnd3, 0\n"
  ioLLVMcode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %testSource, label %copyBytes\n"
  ioLLVMcode += "testSource:\n"
  ioLLVMcode += "  %sourceAsUnsigned = ptrtoint " + llvmTypeName + "* %inSource to i32\n"
  ioLLVMcode += "  %sourceAsUnsignedAnd3 = and i32 %sourceAsUnsigned, 3\n"
  ioLLVMcode += "  %sourceAsUnsignedIsMutipleOf4 = icmp eq i32 %sourceAsUnsignedAnd3, 0\n"
  ioLLVMcode += "  br i1 %targetAsUnsignedIsMutipleOf4, label %copyWords, label %copyBytes\n"
  ioLLVMcode += "copyWords:\n"
  ioLLVMcode += "  %target32 = bitcast " + llvmTypeName + "* %inTarget to i32*\n"
  ioLLVMcode += "  %source32 = bitcast " + llvmTypeName + "* %inSource to i32*\n"
  ioLLVMcode += "  %wordCount = udiv i32 %byteCount, 4\n"
  ioLLVMcode += "  br label %copyWords.loop\n"
  ioLLVMcode += "copyWords.loop:\n"
  ioLLVMcode += "  call void @copy.word.array (i32* %target32, i32* %source32, i32 %wordCount)\n"
  ioLLVMcode += "  br label %copy.end\n"
  ioLLVMcode += "copyBytes:\n"
  ioLLVMcode += "  %target8 = bitcast " + llvmTypeName + "* %inTarget to i8*\n"
  ioLLVMcode += "  %source8 = bitcast " + llvmTypeName + "* %inSource to i8*\n"
  ioLLVMcode += "  call void @copy.byte.array (i8* %target8, i8* %source8, i32 %byteCount)\n"
  ioLLVMcode += "  br label %copy.end\n"
  ioLLVMcode += "copy.end:\n"
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
