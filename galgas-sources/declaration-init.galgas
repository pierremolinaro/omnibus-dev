#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @initAST : @abstractDeclarationAST {
  @lstring mModuleName # "" if no module name
  @instructionListAST mInstructionList
  @location mEndOfInitLocation
  @lbigint mPriority
}

#·······················································································································

list @initListAST {
  @initAST mInit
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <declaration_init> ?let init !["" here]
    ioAST.mDeclarationListAST += !init
  }
  
  #·····················································································································

  rule <declaration_init> !@initAST outInit ?let @lstring inModuleName {
    $init$
    $integer$ ?let @lbigint priority
    ${$
    <instructionList> ?let instructionList
    let endOfInit = @location.here
    $}$
    outInit = .new {
      !inModuleName
      !instructionList
      !endOfInit
      !priority
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @initAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @initAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {!"init " + mModuleName + " " + mPriority.bigint !mPriority.location}
 [!?ioGraph addNode !nodeName !self]
}

#·······················································································································

override getter @initAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "init " + mModuleName + " " +  + mPriority.bigint 
}

#·······················································································································

override getter @initAST location -> @location outLocation {
  outLocation = mPriority.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @initAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @initRoutineMap {
  insert insertKey error message "the '%%%K' init routine is already declared"
  search searchKey error message "there is no '%%%K' init routine"
}

#·······················································································································

override method @initAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [!?ioContext.mInitRoutineMap insertKey !.new {![mPriority string] !mPriority.location}]
#----------------
  @lstring routineNameForInvocationGraph 
  if mModuleName.string == "" then
    routineNameForInvocationGraph = initNameForInvocationGraph (!"" !mPriority)
  else
    routineNameForInvocationGraph = initNameForInvocationGraph (!llvmModuleNameFromName (!mModuleName) !mPriority)
  end
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedInitRoutine.new {
    !mModuleName
    !mInstructionList
    !mEndOfInitLocation
    !mPriority
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @initRoutinePriorityMap {
  insert insertKey error message "an init routine with priority %K has been already declared"
}

#·······················································································································

class @decoratedInitRoutine : @abstractDecoratedDeclaration {
  @lstring mModuleName
  @instructionListAST mInstructionList
  @location mEndOfInitLocation
  @lbigint mPriority
}

#·······················································································································

override method @decoratedInitRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let @PLMType selfType = if mModuleName.string == "" then
    voidType ()
  else
    [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !llvmModuleNameFromName (!mModuleName)} type]
  end
  initSemanticAnalysis (
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
    !selfType:selfType
    !priority:mPriority
    !mode:.initMode
    !instructionList:mInstructionList
    !endOfDeclaration:mEndOfInitLocation
    ?let @allocaList allocaList
    ?let @instructionListIR instructionGenerationList
  )
#--- Code generation
  ioIntermediateCodeStruct.mInitList +=
    !selfType
    !mModuleName
    !mPriority.bigint
    !allocaList
    !instructionGenerationList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc initSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  ?selfType:let @PLMType inSelfType
  ?priority:let @lbigint inPriority
  ?mode:let @mode inCurrentMode
  ?instructionList:let @instructionListAST inInstructionListAST
  ?endOfDeclaration:let @location unused inEndOfInitDeclaration
  !@allocaList outAllocaList
  !@instructionListIR outInstructionGenerationList
{
#--- Check init routine is unique
  let routineNameForInvocationGraph = initNameForInvocationGraph (!inSelfType.mPLMTypeName !inPriority)
  [!?ioTemporaries.mInitRoutinePriorityMap insertKey !routineNameForInvocationGraph]
#---
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
  end
#--- Variable map
  initialVariableMap (
    !context:inContext
    !mode:inCurrentMode
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
    ?@universalValuedObjectMapForContext universalMap
  )
#--- Analyze instruction list
  outInstructionGenerationList = {}
  outAllocaList = {}
  [inInstructionListAST analyzeRoutineInstructionList
    !self:inSelfType
    !directAccessToPropertiesAllowed:true
    !propertiesAreMutable:true
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:universalMap
    !?alloca:outAllocaList
    !?generatedCode:outInstructionGenerationList
  ]
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [universalMap checkLocalVariableFinalState]
#  [variableMap checkAutomatonStates !inEndOfInitDeclaration]
#  drop variableMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @initListIR {
  @PLMType mSelfType
  @string mGlobalVariable # "" if mSelfType is null
  @bigint mPriority
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @initListIR generateLLVMinitCode
  ?!@string ioLLVMcode
  ?let @routineMapIR unused inProcedureMapIR
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Init")
  ioLLVMcode += "define internal void @init ()" + llvmAttributeFunction () + "{\n"
  for init in self do
    ioLLVMcode += "  call void @init." + init.mPriority + " ("
    if [init.mSelfType mKind] != .void then
      ioLLVMcode += [init.mSelfType llvmTypeName] + " * " + llvmNameForGlobalVariable (!init.mGlobalVariable)
    end
    ioLLVMcode += ")\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
  for init in self do
    ioLLVMcode += llvmSeparatorLine () + "\n"
    ioLLVMcode += "define internal void @init." + init.mPriority + " ("
    if [init.mSelfType mKind] != .void then
      ioLLVMcode += [init.mSelfType llvmTypeName] + " * %self"
    end
    ioLLVMcode += ")" + llvmAttributeFunction () + "{\n"
    for (variable llvmTypeName) in init.mAllocaList do
      ioLLVMcode += "  " + variable + " = alloca " + llvmTypeName + "\n"
    end
    [init.mInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
}