#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @initList {
  @location mInitLocation
  @2lstringlist mRequiredByProcList # Type, name
  @instructionListAST mInstructionList
  @location mEndOfInitLocation
  @lbigint mPriority
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <declaration_init> !?ioAST.mInitList
  }
  
  #·····················································································································

  rule <declaration_init> ?!@initList ioInitList {
    $init$
    $integer$ ?let @lbigint priority
    ${$
    <instructionList> ?let instructionList !?*
    let endOfInit = @location.here
    $}$
    ioInitList +=
      !priority.location
      !{}
      !instructionList
      !endOfInit
      !priority
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @initList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @initRoutineMap {
  insert insertKey error message "the '%%%K' init routine is already declared"
  search searchKey error message "there is no '%%%K' init routine"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @initList-element enterInContext
  ?!context:@semanticContext ioContext
{
  [!?ioContext.mInitRoutineMap insertKey !.new {![mPriority string] !mPriority.location}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @initRoutinePriorityMap {
  insert insertKey error message "an init routine with priority %K has been already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @initList-element initSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  initSemanticAnalysis (
    !context:inContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
    !selfType:.null
    !priority:mPriority
    !modes:{!initModeName ()}
    !requiredBy:mRequiredByProcList
    !instructionList:mInstructionList
    !endOfDeclaration:mEndOfInitLocation
    ?let @allocaList allocaList
    ?let @instructionListIR instructionGenerationList
  )
#--- Code generation
  ioIntermediateCodeStruct.mInitList +=
    !mRequiredByProcList
    !mInitLocation
    !allocaList
    !instructionGenerationList
    !mEndOfInitLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc initSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  ?selfType:let @unifiedTypeMap-proxy inSelfType
  ?priority:let @lbigint inPriority
  ?modes:let @stringset inModeSet
  ?requiredBy:let @2lstringlist inRequiredByProcList
  ?instructionList:let @instructionListAST inInstructionListAST
  ?endOfDeclaration:let @location inEndOfInitDeclaration
  !@allocaList outAllocaList
  !@instructionListIR outInstructionGenerationList
{
#--- Check init routine is unique
  let routineNameForInvocationGraph = initNameForInvocationGraph (!inSelfType !inPriority)
  [!?ioTemporaries.mInitRoutinePriorityMap insertKey !routineNameForInvocationGraph]
#---
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
  for (typeName funcName) in inRequiredByProcList do
    let t = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !typeName}
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge
      !procNameForInvocationGraph (!t !funcName)
      !routineNameForInvocationGraph
    ]
  end
#--- Check "requiredBy" routines are defined
  for (typeName funcName) in inRequiredByProcList do
    let lkey = @lstring.new {!"$" + typeName + "." + funcName !funcName.location}
    [inContext.mRoutineMapForContext searchKey !lkey ?6*]
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineNameForInvocation:routineNameForInvocationGraph.string
    !context:inContext
    !userMode:false
    !registerAccess:.readWriteAccess
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
  )
#--- Analyze instruction list
  outInstructionGenerationList = {}
  outAllocaList = {}
  [inInstructionListAST analyzeRoutineInstructionList
    !self:inSelfType
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !modes:inModeSet
    !allowPanic:true
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?alloca:outAllocaList
    !?generatedCode:outInstructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !inEndOfInitDeclaration]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @initListIR {
  @2lstringlist mInitRequiredByProcList
  @location mInitLocation
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @initListIR generateLLVMinitCode
  ?!@string ioLLVMcode
  ?let @routineMapIR inProcedureMapIR
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Init")
  ioLLVMcode += "define internal void @init ()" + llvmAttributeFunction () + "{\n"
  for init in self do
    for (variable type) in init.mAllocaList do
      ioLLVMcode += "  %" + llvmNameForLocalVariable (!variable) + " = alloca " + [type llvmTypeName] + "\n"
    end
  end
  for init in self do
    @bool generate 
    if [init.mInitRequiredByProcList length] == 0 then
      generate = true
    else
      generate = false
      for (typeName funcName) in init.mInitRequiredByProcList while not generate do
        generate = [inProcedureMapIR hasKey !"$" + typeName + "." + funcName.string]
      end
    end
    if generate then
      [init.mInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    end
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}