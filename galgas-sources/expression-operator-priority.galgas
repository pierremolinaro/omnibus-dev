#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @expressionAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <expression> !@expressionAST outExpression {
    <expression_logical_xor> ?outExpression
    repeat
    while
      $or$
      let operatorLocation = @location.here
      <expression_logical_xor> ?let rightExpression
    #--- x or y equivalent to not (not x and not y)
      let andExpression = @booleanShortCircuitAndOperatorExpressionAST.new {
        !@prefixOperatorExpressionAST.new {!operatorLocation !.notOperator !outExpression}
        !operatorLocation
        !@prefixOperatorExpressionAST.new {!operatorLocation !.notOperator !rightExpression}
      }
      outExpression = @prefixOperatorExpressionAST.new {
        !operatorLocation
        !.notOperator
        !andExpression
      }
    end
  }

  #·····················································································································

  rule <expression_logical_xor> !@expressionAST outExpression {
    <expression_logical_and> ?outExpression
    repeat
    while
      $xor$
      let operatorLocation = @location.here
      <expression_logical_and> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.booleanXorOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_logical_and> !@expressionAST outExpression {
    <expression_bitwise_or> ?outExpression
    repeat
    while
      $and$
      let operatorLocation = @location.here
      <expression_bitwise_or> ?let rightExpression
      outExpression = @booleanShortCircuitAndOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_bitwise_or> !@expressionAST outExpression {
    <expression_bitwise_xor> ?outExpression
    repeat
    while
      $|$
      let operatorLocation = @location.here
      <expression_bitwise_xor> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.orOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_bitwise_xor> !@expressionAST outExpression {
    <expression_bitwise_and> ?outExpression
    repeat
    while
      $^$
      let operatorLocation = @location.here
      <expression_bitwise_and> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.xorOp
        !rightExpression
      }
    end
   }

  #·····················································································································

  rule <expression_bitwise_and> !@expressionAST outExpression {
    <expression_equality> ?outExpression
    repeat
    while
      $&$
      let operatorLocation = @location.here
      <expression_equality> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.andOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_equality> !@expressionAST outExpression {
    <expression_comparison> ?outExpression
    select
    or
      $==$
      let operatorLocation = @location.here
      <expression_comparison> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.equal
        !rightExpression
      }
    or
      $!=$
      let operatorLocation = @location.here
      <expression_comparison> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.nonEqual
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_comparison> !@expressionAST outExpression {
    <expression_shift> ?outExpression
    select
    or
      $<=$
      let operatorLocation = @location.here
      <expression_shift> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.infEqual
        !rightExpression
      }
    or
      $>=$
      let operatorLocation = @location.here
      <expression_shift> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.supEqual
        !rightExpression
      }
    or
      $<$
      let operatorLocation = @location.here
      <expression_shift> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictInf
        !rightExpression
      }
    or
      $>$
      let operatorLocation = @location.here
      <expression_shift> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictSup
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_shift> !@expressionAST outExpression {
    <expression_addition> ?outExpression
    repeat
    while
      $<<$
      let operatorLocation = @location.here
      <expression_addition> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.leftShiftOp
        !rightExpression
      }
    while
      $>>$
      let operatorLocation = @location.here
      <expression_addition> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.rightShiftOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_addition> !@expressionAST outExpression {
    <expression_product> ?outExpression
    repeat
    while
      $+$
      let operatorLocation = @location.here
      <expression_product> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOp
        !rightExpression
      }
    while
      $+%$
      let operatorLocation = @location.here
      <expression_product> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOpNoOvf
        !rightExpression
      }
    while
      $-$
      let operatorLocation = @location.here
      <expression_product> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOp
        !rightExpression
      }
    while
      $-%$
      let operatorLocation = @location.here
      <expression_product> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOpNoOvf
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_product> !@expressionAST outExpression {
    <primary> ?outExpression
    repeat
    while
      $*$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOp
        !rightExpression
      }
    while
      $*%$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOpNoOvf
        !rightExpression
      }
    while
      $%$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOp
        !rightExpression
      }
    while
      $!%$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOpNoOvf
        !rightExpression
      }
    while
      $/$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOp
        !rightExpression
      }
    while
      $!/$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOpNoOvf
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $~$
    let operatorLocation = @location.here
    <primary> ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.unsignedComplement
      !expression
    }
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $not$
    let operatorLocation = @location.here
    <primary> ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.notOperator
      !expression
    }
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $-$
    let operatorLocation = @location.here
    <primary> ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.minus
      !expression
    }
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $-%$
    let operatorLocation = @location.here
    <primary> ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.minusNoOvf
      !expression
    }
  }

  #·····················································································································

  rule <primary> !@expressionAST outExpression {
    $($
    <expression> ?outExpression
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SOLVE ENTITIES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @expressionSE {
}

#·······················································································································

abstract method @expressionAST solveEntities
  ?context:let @semanticContext inSemanticContext
  !@expressionSE outExpression

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @PLMType inTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @expressionAST analyzeStaticExpression
  ?errorLocation:let @location inErrorLocation
  ?context:let @semanticContext inContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  !result:@objectIR outResult
{
  @instructionListIR instructionGenerationList = {}
  @allocaList allocaList = {}
  [self analyzeExpression
    !self:.void
    !inGuard:false
    !routineNameForInvocationGraph:["compiler" nowhere]
    !optionalTargetType:.void
    !context:inContext
    !mode:.bootMode
    !?temporary:*
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:*
    !?alloca:allocaList
    !?instructionListIR:instructionGenerationList
    ?result:outResult
  ]
  if ([allocaList length] > 0) || ([instructionGenerationList length] > 0) || not [outResult isStatic] then
    error inErrorLocation : "this expression should be a static expression" : outResult
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
