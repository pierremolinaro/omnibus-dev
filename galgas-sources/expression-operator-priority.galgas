#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @expressionAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <expression> ?!@ast ioAST !@expressionAST outExpression {
    <expression_logical_xor> !?ioAST ?outExpression
    repeat
    while
      $or$
      let operatorLocation = @location.here
      <expression_logical_xor> !?ioAST ?let rightExpression
    #--- x or y equivalent to not (not x and not y)
      let andExpression = @booleanShortCircuitAndOperatorExpressionAST.new {
        !@prefixOperatorExpressionAST.new {!operatorLocation !.notOperator !outExpression}
        !operatorLocation
        !@prefixOperatorExpressionAST.new {!operatorLocation !.notOperator !rightExpression}
      }
      outExpression = @prefixOperatorExpressionAST.new {
        !operatorLocation
        !.notOperator
        !andExpression
      }
    end
  }

  #·····················································································································

  rule <expression_logical_xor> ?!@ast ioAST !@expressionAST outExpression {
    <expression_logical_and> !?ioAST ?outExpression
    repeat
    while
      $xor$
      let operatorLocation = @location.here
      <expression_logical_and> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.booleanXorOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_logical_and> ?!@ast ioAST !@expressionAST outExpression {
    <expression_bitwise_or> !?ioAST ?outExpression
    repeat
    while
      $and$
      let operatorLocation = @location.here
      <expression_bitwise_or> !?ioAST ?let rightExpression
      outExpression = @booleanShortCircuitAndOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_bitwise_or> ?!@ast ioAST !@expressionAST outExpression {
    <expression_bitwise_xor> !?ioAST ?outExpression
    repeat
    while
      $|$
      let operatorLocation = @location.here
      <expression_bitwise_xor> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.orOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_bitwise_xor> ?!@ast ioAST !@expressionAST outExpression {
    <expression_bitwise_and> !?ioAST ?outExpression
    repeat
    while
      $^$
      let operatorLocation = @location.here
      <expression_bitwise_and> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.xorOp
        !rightExpression
      }
    end
   }

  #·····················································································································

  rule <expression_bitwise_and> ?!@ast ioAST !@expressionAST outExpression {
    <expression_equality> !?ioAST ?outExpression
    repeat
    while
      $&$
      let operatorLocation = @location.here
      <expression_equality> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.andOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_equality> ?!@ast ioAST !@expressionAST outExpression {
    <expression_comparison> !?ioAST ?outExpression
    select
    or
      $==$
      let operatorLocation = @location.here
      <expression_comparison> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.equal
        !rightExpression
      }
    or
      $≠$
      let operatorLocation = @location.here
      <expression_comparison> !?ioAST ?let rightExpression
      let expression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.equal
        !rightExpression
      }
      outExpression = @prefixOperatorExpressionAST.new {
        !operatorLocation
        !.notOperator
        !expression
      }
    end
  }

  #·····················································································································

  rule <expression_comparison> ?!@ast ioAST !@expressionAST outExpression {
    <expression_shift> !?ioAST ?outExpression
    select
    or
      $≤$
      let operatorLocation = @location.here
      <expression_shift> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.infEqual
        !rightExpression
      }
    or
      $≥$
      let operatorLocation = @location.here
      <expression_shift> !?ioAST ?let rightExpression
      let expression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictInf
        !rightExpression
      }
      outExpression = @prefixOperatorExpressionAST.new {
        !operatorLocation
        !.notOperator
        !expression
      }
    or
      $<$
      let operatorLocation = @location.here
      <expression_shift> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictInf
        !rightExpression
      }
    or
      $>$
      let operatorLocation = @location.here
      <expression_shift> !?ioAST ?let rightExpression
      let expression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.infEqual
        !rightExpression
      }
      outExpression = @prefixOperatorExpressionAST.new {
        !operatorLocation
        !.notOperator
        !expression
      }
    end
  }

  #·····················································································································

  rule <expression_shift> ?!@ast ioAST !@expressionAST outExpression {
    <expression_addition> !?ioAST ?outExpression
    repeat
    while
      $<<$
      let operatorLocation = @location.here
      <expression_addition> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.leftShiftOp
        !rightExpression
      }
    while
      $>>$
      let operatorLocation = @location.here
      <expression_addition> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.rightShiftOp
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_addition> ?!@ast ioAST !@expressionAST outExpression {
    <expression_product> !?ioAST ?outExpression
    repeat
    while
      $+$
      let operatorLocation = @location.here
      <expression_product> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOp
        !rightExpression
      }
    while
      $+%$
      let operatorLocation = @location.here
      <expression_product> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOpNoOvf
        !rightExpression
      }
    while
      $-$
      let operatorLocation = @location.here
      <expression_product> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOp
        !rightExpression
      }
    while
      $-%$
      let operatorLocation = @location.here
      <expression_product> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOpNoOvf
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <expression_product> ?!@ast ioAST !@expressionAST outExpression {
    <primary> !?ioAST ?outExpression
    repeat
    while
      $*$
      let operatorLocation = @location.here
      <primary> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOp
        !rightExpression
      }
    while
      $*%$
      let operatorLocation = @location.here
      <primary> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOpNoOvf
        !rightExpression
      }
    while
      $%$
      let operatorLocation = @location.here
      <primary> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOp
        !rightExpression
      }
    while
      $!%$
      let operatorLocation = @location.here
      <primary> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOpNoOvf
        !rightExpression
      }
    while
      $/$
      let operatorLocation = @location.here
      <primary> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOp
        !rightExpression
      }
    while
      $!/$
      let operatorLocation = @location.here
      <primary> !?ioAST ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOpNoOvf
        !rightExpression
      }
    end
  }

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $~$
    let operatorLocation = @location.here
    <primary> !?ioAST ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.unsignedComplement
      !expression
    }
  }

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $not$
    let operatorLocation = @location.here
    <primary> !?ioAST ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.notOperator
      !expression
    }
  }

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $-$
    let operatorLocation = @location.here
    <primary> !?ioAST ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.minus
      !expression
    }
  }

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $-%$
    let operatorLocation = @location.here
    <primary> !?ioAST ?let expression
    outExpression = @prefixOperatorExpressionAST.new {
      !operatorLocation
      !.minusNoOvf
      !expression
    }
  }

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    $($
    <expression> !?ioAST ?outExpression
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @expressionAST analyzeExpression
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @PLMType inTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
