#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntAST : @abstractDeclarationAST {
}

#·······················································································································

override getter @compileTimeIntAST locationForErrorSignaling -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compileTimeIntAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = [ctIntegerTypeName () nowhere]
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName ![ctBoolTypeName () nowhere]]
}

#·······················································································································

override getter @compileTimeIntAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = ctIntegerTypeName ()
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once ctIntegerTypeName ->@string {
  result = "ctInt"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compileTimeIntAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
  let ctIntegerTypeName = [ctIntegerTypeName () nowhere]
  let ctInt = compileTimeIntegerType ()
 #--- Enter type
  [!?ioContext.mTypeMap insertType !lkey: ctIntegerTypeName !type: ctInt]
 #--- Enter ~ prefix operator
  var key = prefixOperatorMapKey (!ctInt !.bitWiseComplement !.nowhere)
  [!?ioContext.mPrefixOperatorMap insertKey !key !ctInt !ctInt !@compileTimeIntComplementOperator.new]
 #--- Enter - prefix operator
  key = prefixOperatorMapKey (!ctInt !.minusOp !.nowhere)
  [!?ioContext.mPrefixOperatorMap insertKey !key !ctInt !ctInt !@compileTimeIntMinusOperator.new]
 #--- Enter -% prefix operator
  key = prefixOperatorMapKey (!ctInt !.minusNoOvf !.nowhere)
  [!?ioContext.mPrefixOperatorMap insertKey !key !ctInt !ctInt !@compileTimeIntMinusOperator.new]
 #--- Enter & infix operator
  key = infixOperatorMapKey (!ctInt !.bitWiseAndOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntBitWiseAndOperator.new]
 #--- Enter | infix operator
  key = infixOperatorMapKey (!ctInt !.bitWiseOrOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntBitWiseOrOperator.new]
 #--- Enter ^ infix operator
  key = infixOperatorMapKey (!ctInt !.bitWiseXorOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntXorOperator.new]
 #--- Enter + infix operator
  key = infixOperatorMapKey (!ctInt !.addOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntAddOperator.new]
 #--- Enter +% infix operator
  key = infixOperatorMapKey (!ctInt !.addOpNoOvf !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntAddOperator.new]
 #--- Enter - infix operator
  key = infixOperatorMapKey (!ctInt !.subOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntSubtractOperator.new]
 #--- Enter -% infix operator
  key = infixOperatorMapKey (!ctInt !.subOpNoOvf !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntSubtractOperator.new]
 #--- Enter * infix operator
  key = infixOperatorMapKey (!ctInt !.mulOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntMultiplyOperator.new]
 #--- Enter / infix operator
  key = infixOperatorMapKey (!ctInt !.divOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntDivideOperator.new]
 #--- Enter !/ infix operator
  key = infixOperatorMapKey (!ctInt !.divOpNoOvf !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntDivideZeroOperator.new]
 #--- Enter % infix operator
  key = infixOperatorMapKey (!ctInt !.modOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntModuloOperator.new]
 #--- Enter !% infix operator
  key = infixOperatorMapKey (!ctInt !.modOpNoOvf !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntModuloZeroOperator.new]
 #--- Enter == infix operator
  let ctBoolType = compileTimeBoolType ()
  key = infixOperatorMapKey (!ctInt !.equal !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctBoolType !@compileTimeIntEqualOperator.new]
 #--- Enter < infix operator
  key = infixOperatorMapKey (!ctInt !.lessThan !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctBoolType !@compileTimeIntLessThanOperator.new]
 #--- Enter ≤ infix operator
  key = infixOperatorMapKey (!ctInt !.infEqual !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctBoolType !@compileTimeIntLowerOrEqualOperator.new]
 #--- Enter << infix operator
  key = infixOperatorMapKey (!ctInt !.leftShiftOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntShiftLeftOperator.new]
 #--- Enter >> infix operator
  key = infixOperatorMapKey (!ctInt !.rightShiftOp !.nowhere !ctInt)
  [!?ioContext.mInfixOperatorMap insertKey !key !ctInt !@compileTimeIntShiftRightOperator.new]
#--- Enter OLD integer operators
#  enterLiteralIntegerOperators (!?context: ioContext)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  COMPILE TIME INFIX OPERATORS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntModuloOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntModuloOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  if rightValue == 0G then
    error inOperatorLocation : "compile time divide by zero" : outResultValue
  else
    [inLeftOperand literalInteger ?1* ?value: let leftValue]
    outResultValue = .literalInteger {!type: inResultType !value: leftValue mod rightValue}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntModuloZeroOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntModuloZeroOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  if rightValue == 0G then
    outResultValue = .literalInteger {!type: inResultType !value: 0G}
  else
    [inLeftOperand literalInteger ?1* ?value: let leftValue]
    outResultValue = .literalInteger {!type: inResultType !value: leftValue mod rightValue}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntDivideOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntDivideOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  if rightValue == 0G then
    error inOperatorLocation : "compile time divide by zero" : outResultValue
  else
    [inLeftOperand literalInteger ?1* ?value: let leftValue]
    outResultValue = .literalInteger {!type: inResultType !value: leftValue / rightValue}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntDivideZeroOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntDivideZeroOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  if rightValue == 0G then
    outResultValue = .literalInteger {!type: inResultType !value: 0G}
  else
    [inLeftOperand literalInteger ?1* ?value: let leftValue]
    outResultValue = .literalInteger {!type: inResultType !value: leftValue / rightValue}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntMultiplyOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntMultiplyOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue * rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntSubtractOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntSubtractOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue - rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntEqualOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntEqualOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue == rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntAddOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntAddOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue + rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntBitWiseAndOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntBitWiseAndOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue & rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntShiftLeftOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntShiftLeftOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  if rightValue < 0G then
    error inOperatorLocation : "compile time left shift right operand should be ≥ 0" : outResultValue
  else
    [inLeftOperand literalInteger ?1* ?value: let leftValue]
    outResultValue = .literalInteger {!type: inResultType !value: leftValue << rightValue}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntShiftRightOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntShiftRightOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  if rightValue < 0G then
    error inOperatorLocation : "compile time right shift right operand should be ≥ 0" : outResultValue
  else
    [inLeftOperand literalInteger ?1* ?value: let leftValue]
    outResultValue = .literalInteger {!type: inResultType !value: leftValue >> rightValue}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntLessThanOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntLessThanOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue < rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntLowerOrEqualOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntLowerOrEqualOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue <= rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntXorOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntXorOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue ^ rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntBitWiseOrOperator : @omnibusInfixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntBitWiseOrOperator generateCode
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @omnibusType inResultType
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@allocaList unused ioAllocaList
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inLeftOperand literalInteger ?1* ?value: let leftValue]
  [inRightOperand literalInteger ?1* ?value: let rightValue]
  outResultValue = .literalInteger {!type: inResultType !value: leftValue | rightValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  COMPILE TIME PREFIX OPERATOR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntMinusOperator : @prefixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntMinusOperator generateCode
  ?let @objectIR inReceiverOperand
  ?let @location unused inOperatorLocation
  ?let @omnibusType inResultType
  ?noPanicCode: let @bool unused inDoNotGeneratePanicCode
  ?safeMode: let @bool unused inSafeMode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inReceiverOperand literalInteger ?1* ?value: let receiverValue]
  outResultValue = .literalInteger {!type: inResultType !value: - receiverValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

shared class @compileTimeIntComplementOperator : @prefixOperatorUsage {
}

#·······················································································································

override method @compileTimeIntComplementOperator generateCode
  ?let @objectIR inReceiverOperand
  ?let @location unused inOperatorLocation
  ?let @omnibusType inResultType
  ?noPanicCode: let @bool unused inDoNotGeneratePanicCode
  ?safeMode: let @bool unused inSafeMode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inReceiverOperand literalInteger ?1* ?value: let receiverValue]
  outResultValue = .literalInteger {!type: inResultType !value: ~ receiverValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
