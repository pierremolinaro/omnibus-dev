#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @booleanDeclarationAST : @abstractDeclarationAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @booleanDeclarationAST location -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let boolBaseTypeName = llvmTypeNameFromPLMname (![boolBaseTypeName () nowhere])
  [!?ioGraph addNode !boolBaseTypeName !self]
  let uint1TypeName = llvmTypeNameFromPLMname (!.new{!"uint1" ![boolBaseTypeName () nowhere].location})
  [!?ioGraph noteNode !uint1TypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @booleanDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "bool " + llvmTypeNameFromPLMname (![boolBaseTypeName () nowhere])
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!globalVariables:@globalVariableIRList unused ioGlobalVariableIRList
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
{
#---------- Property map
  @propertyMap propertyMap = {}
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap ![boolBaseTypeName () nowhere] ?let boolTypeProxy]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !.new {!"uint1" ![boolBaseTypeName () nowhere]} ?let uint1TypeProxy]
#--- Add uint1 accessor
  [!?propertyMap addFunctionWithoutArgument
    !?ioSubprogramInvocationGraph
    !receiverTypeProxy:boolTypeProxy
    !methodName:"uint1"
    !safe:true
    !resultTypeProxy:uint1TypeProxy
    !canMutateProperties:false
  ]
#---------- Define boolean type composition
  let booleanType = @PLMType.new {
    !propertyMap:propertyMap
    !classConstantMap:{}
    !constructorMap:{}
    !guardMap:{}
    !attributes:.instanciable | .equatable | .copyable | .generateAssignmentRoutine
    !plmTypeDescriptionName:boolTypeDescriptionName ()
    !kind:.boolean
    !llvmBaseTypeName:boolBaseTypeName ()
  }
#---------- Enter in type map
  [!?ioContext.mTypeMap insertType !lkey:[boolBaseTypeName () nowhere] !type:booleanType !index:[ioContext.mTypeMap count]]
#---------- Enter boolean operators
  enterBooleanOperators (!?context:ioContext)
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@boolDecoratedDeclaration.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enterBooleanOperators
  ?!context:@semanticContext ioContext
{
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap ![boolBaseTypeName () nowhere]} type]
  let boolBoolOp = combineTypeNamesForInfixOperator (!boolTypeDescriptionName () !boolTypeDescriptionName ())
  [!?ioContext.mEqualOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ult}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ule}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.icmp_ugt}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.icmp_uge}
  ]
  [!?ioContext.mBooleanXorOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.xor}
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.ior}
  ]
  [!?ioContext.mAndOperatorMap insertKey
    !boolBoolOp
    !selfType
    !@infixObjectObjectOperatorDescription.new {!.and}
  ]
  [!?ioContext.mNotOperatorMap insertKey
    ![boolTypeDescriptionName () nowhere]
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @boolDecoratedDeclaration : @abstractDecoratedDeclaration {
}

#·······················································································································

override method @boolDecoratedDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  ioIntermediateCodeStruct.mGenerationListIR += !@boolIR.new
}

#·······················································································································

override method @boolDecoratedDeclaration routineSemanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @boolIR : @abstractGenerationIR {
}

#·······················································································································

override method @boolIR generateLLVMcode ?!@string ioLLVMcode ?!@generationAdds unused ioGenerationAdds {
#---------- Generate $bool to $uint1 conversion function
  let routineMangledName = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!boolBaseTypeName ())
    !["uint1" nowhere]
    !{}
  )
  let functionName = llvmNameForFunction (!routineMangledName)
  ioLLVMcode += "define internal i1 @" + functionName + " (i1* %inValue) {\n"
  ioLLVMcode += "  %value = load i1, i1* %inValue\n"
  ioLLVMcode += "  ret i1 %value\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

