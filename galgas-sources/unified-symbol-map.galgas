#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    V A R I A B L E    M A P                                                                                           
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc initialVariableMap
  ?context:let @semanticContext inContext
  ?mode:let @mode inRequiredMode
  ?globalsAreConstant:@bool inGlobalsAreConstant
  ?returnTypeName:let @lstring inReturnTypeName
  !@universalPropertyAndRoutineMapForContext outUniversalMap
{
  outUniversalMap = .default
#------------------------------------------------------- Add modules
  for (moduleName) in inContext.mModuleMap do
    let moduleTypeName = moduleMangledNameFromModuleName (!moduleName)
    let moduleType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName} type]
    [!?outUniversalMap insertModule !moduleName !moduleType]
  end
#------------------------------------------------------- Add registers
  for register in inContext.mControlRegisterMap do
    let registerIsReadable = [inRequiredMode controlRegisterAccess !register.mIsAccessibleInUserMode]
    let registerIsWritable = registerIsReadable && not register.mIsReadOnly && not inGlobalsAreConstant
    let objectReference = @objectIR.registerReference {
      !type:register.mType
      !plmName:register.lkey
      !readable:registerIsReadable
      !writable:registerIsWritable
      !address:register.mAddress 
      !sliceMap:register.mRegisterFieldAccessMap
      !arraySize:register.mArraySize # 0 if not an array
      !elementSize:register.mElementArraySize # 0 if not an array
    }
    [!?outUniversalMap insertRegister
      !register.lkey
      !readable:registerIsReadable
      !writable:registerIsWritable
      !objectReference
    ]
  end
#------------------------------------------------------- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outUniversalMap insertGlobalConstant !constantName !constantValue]
  end
#------------------------------------------------------- Add global variables
  for variable in inContext.mGlobalVariableMap do
#    let objectIR = @objectIR.globalVariableReference {!type:variable.type !plmName:variable.lkey}
    [!?outUniversalMap insertGlobalVariable !variable.lkey !variable.type !not inGlobalsAreConstant]
    var writeAccess = variable.allowedAccessToAll
    var allowedAccess = writeAccess
  end
#------------------------------------------------------- Add stand-alone routines
  for routines in inContext.mRoutineMapForContext.mInternalRoutineMapForContext do
    for signature in routines.mRoutineArgumentSignatureMapForContext do
      [!?outUniversalMap insertRoutine
        !routines.lkey
        !signature.lkey
        !signature.mRoutineLLVMName
        !signature.mDescriptor
       ]
     end
  end
#------------------------------------------------------- Add result variable ?
  if inReturnTypeName.string != "" then
    let resultVarName = @lstring.new {!functionResultVariableName () !inReturnTypeName.location}
    let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName} type]
    [!?outUniversalMap insertLocalVariable !resultVarName !resultType !.noValue !true]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc variableMapWithConstants
  ?context:let @semanticContext inContext
  !@universalPropertyAndRoutineMapForContext outUniversalMap
{
  outUniversalMap = .default
#--- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outUniversalMap insertGlobalConstant !constantName !constantValue]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc getNewTempVariable
  ?let @PLMType inType
  ?@location inErrorLocation
  ?!@semanticTemporariesStruct ioTemporaries
  !@objectIR outTempVariable
{
  if inType == .void then
    outTempVariable = .null
  else
    outTempVariable = .llvmTemporaryValue {
      !type: inType
      !llvmName:.new {!"temp." + ioTemporaries.mTemporaryIndex !inErrorLocation}
      !sliceMap:{}
    }
    ioTemporaries.mTemporaryIndex ++
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
