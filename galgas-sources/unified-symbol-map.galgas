#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    V A R I A B L E    M A P                                                                                           
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc initialVariableMap
  ?context:let @semanticContext inContext
  ?mode:let @mode inRequiredMode
  ?globalsAreConstant:@bool inGlobalsAreConstant
  ?returnTypeName:let @lstring inReturnTypeName
  !@universalPropertyAndRoutineMapForContext outUniversalMap
{
  outUniversalMap = .default
#------------------------------------------------------- Add modules
  for (moduleName) in inContext.mModuleMap do
    let moduleTypeName = moduleMangledNameFromModuleName (!moduleName)
    let moduleType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName} type]
    [!?outUniversalMap insertModule !moduleName !moduleType]
  end
#------------------------------------------------------- Add registers
  for register in inContext.mControlRegisterMap do
    let registerIsReadable = [inRequiredMode controlRegisterAccess !register.mIsAccessibleInUserMode]
    let registerIsWritable = registerIsReadable && not register.mIsReadOnly && not inGlobalsAreConstant
    [!?outUniversalMap insertRegister
      !register.lkey
      !readable:registerIsReadable
      !writable:registerIsWritable
      !type:register.mType
      !address:register.mAddress 
      !sliceMap:register.mRegisterFieldAccessMap
      !arraySize:register.mArraySize # 0 if not an array
      !elementSize:register.mElementArraySize # 0 if not an array
    ]
  end
#------------------------------------------------------- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outUniversalMap insertGlobalConstant !constantName !constantValue]
  end
#------------------------------------------------------- Add global variables
  for variable in inContext.mGlobalVariableMap do
    [!?outUniversalMap insertGlobalVariable !variable.lkey !variable.type !not inGlobalsAreConstant]
    var writeAccess = variable.allowedAccessToAll
    var allowedAccess = writeAccess
  end
#------------------------------------------------------- Add result variable ?
  if inReturnTypeName.string != "" then
    let resultVarName = @lstring.new {!functionResultVariableName () !inReturnTypeName.location}
    let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !inReturnTypeName} type]
    [!?outUniversalMap insertLocalVariable !resultVarName !resultType !resultVarName !.noValue !true]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc variableMapWithConstants
  ?context:let @semanticContext inContext
  !@universalPropertyAndRoutineMapForContext outUniversalMap
{
  outUniversalMap = .default
#--- Add global constants
  for (constantName constantValue) in inContext.mGlobalConstantMap do
    [!?outUniversalMap insertGlobalConstant !constantName !constantValue]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc getNewTempVariable
  ?let @PLMType inType
  ?!@semanticTemporariesStruct ioTemporaries
  !@objectIR outTempVariable
{
  if inType == .void then
    outTempVariable = .null
  else
    [!?ioTemporaries newTempLLVMVar ?let llvmName]
    outTempVariable = .llvmTemporaryValue {!type: inType !llvmName:llvmName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
