#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @modulePropertyListAST {
  @lstring mPropertyName
  @bool mIsConstant # true if declared with "let"
  @lstring mTypeName # Empty string if no type annotation
  @structurePropertyInitOptionalExpressionAST mOptionalExpression
}

#·······················································································································

struct @moduleDeclarationAST {
  @lstring mModuleName
  @modulePropertyListAST mModulePropertyListAST
  @functionDeclarationListAST mModuleFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mModuleSystemRoutineListAST
  @guardDeclarationListAST mModuleGuardListAST
  @initListAST mModuleInitListAST
}

#·······················································································································

list @moduleDeclarationListAST {
  @moduleDeclarationAST mModule
}

#·······················································································································

list @moduleInstanciationArgumentListAST {
  @lstring mSelector
  @expressionAST mExpression
}

#·······················································································································

list @moduleInstanciationListAST {
  @lstring mModuleName
  @moduleInstanciationArgumentListAST mModuleInstanciationArgumentList
}

#·······················································································································

class @implementedModuleAST : @abstractDeclarationAST {
  @lstring mModuleName
  @bool mIsInstancied
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <module_property> ?!@modulePropertyListAST ioPropertyList {
    @bool constant
    select
      $var$
      constant = false
    or
      $let$
      constant = true
    end
    $identifier$ ?let fieldName
    select
      <type_definition> ?let typeName
      select
        ioPropertyList += !fieldName !constant !typeName !.noExpression
      or
        $=$
        <expression> ?let initExpression
        ioPropertyList += !fieldName !constant !typeName !.expression {!initExpression:initExpression}
      end
    or
      $=$
      <expression> ?let initExpression
      ioPropertyList += !fieldName !constant !["" nowhere] !.expression {!initExpression:initExpression}
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @modulePropertyListAST modulePropertyListAST = {}
    @guardDeclarationListAST guardListAST = {}
    @systemRoutineDeclarationListAST svcListAST = {}
    @initListAST initList = {}
    repeat
    while
      <declaration_init> ?let init !moduleName
      initList += !init
    while
      <isr> !?ioAST.mISRDeclarationListAST !moduleName
    while
      <module_property> !?modulePropertyListAST
    while
      <function> !?functionDeclarationListAST
    while
     <system_routine> !?svcListAST
    while
      <guard> !?guardListAST
    while
      $;$
    end
    $}$
  #--- Declare module
    ioAST.mModuleDeclarationListAST += !@moduleDeclarationAST.new {
      !moduleName
      !modulePropertyListAST
      !functionDeclarationListAST
      !svcListAST
      !guardListAST
      !initList
    }
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    $($
    @moduleInstanciationArgumentListAST moduleInstanciationArgumentList = {}
    repeat
    while
      $!selector:$ ?let selector
      <expression> ?let expression
      moduleInstanciationArgumentList += !selector !expression
    end
    $)$
    ioAST.mRequiredModuleListAST += !moduleName !moduleInstanciationArgumentList
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedModuleAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mModuleName !self]
  let moduleTypeName = llvmTypeNameFromPLMname (!llvmModuleNameFromName (!mModuleName))
 [!?ioGraph addEdge !mModuleName !moduleTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @implementedModuleAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "module " + mModuleName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @implementedModuleAST location -> @location outLocation {
  outLocation = mModuleName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedModuleAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  RETAIN REQUIRED MODULES IN DECLARATION LIST AST                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleInstanciationArgumentMap {
  @expressionAST mExpression
  insert insertKey error message "duplicated '%K' selector"
  search searchKey error message "uninitialized '%K' property"
}

#·······················································································································

map @instanciedModuleMap {
  @moduleInstanciationArgumentMap mModuleInstanciationArgumentMap
  insert insertKey error message "the '%K' module is already instancied in %L"
  search searchKey error message "internal error %K"
}

#·······················································································································

proc retainRequiredModules ?!@ast ioAST {
  @instanciedModuleMap instanciedModuleMap = {}
  @stringset validModuleNames = {} # For checking all required modules have been declared
  for (moduleName args) in ioAST.mRequiredModuleListAST do
     @moduleInstanciationArgumentMap moduleInstanciationArgumentMap = {}
     for (selector expression) in args do
       [!?moduleInstanciationArgumentMap insertKey !selector !expression]
     end
    [!?instanciedModuleMap insertKey !moduleName !moduleInstanciationArgumentMap]
  end
#--- Append required modules to declaration list AST (and init list AST)
  for (declaration) in ioAST.mModuleDeclarationListAST do
    validModuleNames += !declaration.mModuleName.string
    let moduleIsInstancied = [instanciedModuleMap hasKey !declaration.mModuleName.string]
  #--- Build module instanciation property list
    @structurePropertyListAST modulePropertyListAST = {}
    if moduleIsInstancied then
      [instanciedModuleMap searchKey !declaration.mModuleName ?let moduleInstanciationArgumentMap]
    #--- Build module property list, adding init expression
      @stringset validArgumentSet = {}
      for (propertyName constant optionalPropertyTypeName optionalInitExpression) in declaration.mModulePropertyListAST do
        @expressionAST initExpression
        switch optionalInitExpression 
        case noExpression :
          [moduleInstanciationArgumentMap searchKey !propertyName ?initExpression]
          validArgumentSet += !propertyName.string
        case expression (expression) :
          initExpression = expression
        end
        modulePropertyListAST += 
         !propertyName
         !constant
         !false
         !optionalPropertyTypeName
         !.expression{!initExpression:initExpression}
      end
    #--- Check all arguments of module instanciation have been used
      for (unusedSelector) in [moduleInstanciationArgumentMap keySet] - validArgumentSet do
        error [moduleInstanciationArgumentMap locationForKey !unusedSelector] : "invalid selector"
      end
    end
  #---
    let moduleTypeName = llvmModuleNameFromName (!declaration.mModuleName)
    ioAST.mDeclarationListAST += !@implementedModuleAST.new {!declaration.mModuleName !moduleIsInstancied}
    ioAST.mDeclarationListAST += !@structureDeclarationAST.new {
      !moduleTypeName
      !{}
      !false # Do not generate assignment routine
      !modulePropertyListAST
      !declaration.mModuleFunctionDeclarationListAST
      !declaration.mModuleSystemRoutineListAST
      !declaration.mModuleGuardListAST
    }
    for (init) in declaration.mModuleInitListAST do
      ioAST.mDeclarationListAST += !init
    end
  end
  ioAST.mModuleDeclarationListAST = {}
#--- Check all modules named in instanciation constructs have been implemented
  for (unusedModuleName) in [instanciedModuleMap keySet] - validModuleNames do
    error [instanciedModuleMap locationForKey !unusedModuleName] : "undefined module"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleMap {
  @bool mIsInstancied
  insert insertKey error message "the '%K' module is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @implementedModuleAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [!?ioContext.mModuleMap insertKey !mModuleName !mIsInstancied]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedRequiredModule.new {!mModuleName}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedRequiredModule : @abstractDecoratedDeclaration {
  @lstring mModuleName
}

#·······················································································································

override method @decoratedRequiredModule semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let moduleTypeName = llvmModuleNameFromName (!mModuleName)
  let moduleTypeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName}
  let constructorMap = [moduleTypeProxy type].mConstructorMap
  [constructorMap  searchKey !.new {!"()" !moduleTypeName.location} ?* ?let constructorValue]
  [constructorValue structure ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mModuleList += 
    !mModuleName.string
    !moduleTypeProxy
    !initialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @moduleListIR {
  @string mModuleName
  @unifiedTypeMap-proxy mType
  @operandIRList mInitialValueList
}

#·······················································································································

method @moduleListIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalVariable (!mModuleName) + " = internal global "
  ioLLVMcode += [[mType type] llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmName]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
