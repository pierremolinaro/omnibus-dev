#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @moduleDeclarationAST : @abstractDeclaration {
  @lstring mModuleName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <module_variable> ?!@structureFieldListAST ioPropertyList {
    $var$
    $identifier$ ?let fieldName
    @lstring typeName
    select
      $\$type$ ?typeName
    or
      typeName = ["" nowhere]
    end
    $=$
    <expression> ?let initExpression
    ioPropertyList += !fieldName !false !typeName !.expression{!initExpression:initExpression}
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    let moduleTypeName = @lstring.new {!moduleName.string + "$" !moduleName.location}
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @structureFieldListAST fieldList = {}
    @serviceDeclarationListAST serviceListAST = {}
    @primitiveDeclarationListAST primitiveListAST = {}
    @guardDeclarationListAST guardListAST = {}
    @sectionDeclarationListAST sectionListAST = {}
    @initList initList = {}
    repeat
    while
      <declaration_init> !?initList
    while
      <isr> !?ioAST.mISRDeclarationListAST !moduleTypeName !moduleName.string
    while
      <module_variable> !?fieldList
    while
      <procedure> !?functionDeclarationListAST
    while
      <service> !?serviceListAST
    while
     <section> !?sectionListAST
    while
      <guard> !?guardListAST
    while
      <primitive> !?primitiveListAST
    while
      $;$
    end
    $}$
  #--- Declare init list
    @lstringlist requiredByList = {}
    for function in functionDeclarationListAST do
      if function.mPublicFunction then
        var routineMangledName = @lstring.new {
          !"$" + moduleTypeName + "." + function.mFunctionName
          !function.mFunctionName.location
        }
        routineMangledName.string += "("
        for (passingMode selector * *) in function.mFunctionFormalArgumentList do
          routineMangledName.string += [passingMode formalPassingModeString]
          routineMangledName.string += selector.string
          routineMangledName.string += ":"
        end
        routineMangledName.string += ")"
        requiredByList += !routineMangledName
      end
    end
    for service in serviceListAST do
      var routineMangledName = @lstring.new {
        !"$" + moduleTypeName + "." + service.mServiceName
        !service.mServiceName.location
      }
      routineMangledName.string += "("
      for (passingMode selector * *) in service.mServiceFormalArgumentList do
        routineMangledName.string += [passingMode formalPassingModeString]
        routineMangledName.string += selector.string
        routineMangledName.string += ":"
      end
      routineMangledName.string += ")"
      requiredByList += !routineMangledName
    end
    for guard in guardListAST do
      var routineMangledName = @lstring.new {
        !"$" + moduleTypeName + "." + guard.mGuardName
        !guard.mGuardName.location
      }
      routineMangledName.string += "("
      for (passingMode selector * *) in guard.mGuardFormalArgumentList do
        routineMangledName.string += [passingMode formalPassingModeString]
        routineMangledName.string += selector.string
        routineMangledName.string += ":"
      end
      routineMangledName.string += ")"
      requiredByList += !routineMangledName
    end
    for primitive in primitiveListAST do
      var routineMangledName = @lstring.new {
        !"$" + moduleTypeName + "." + primitive.mPrimitiveName
        !primitive.mPrimitiveName.location
      }
      routineMangledName.string += "("
      for (passingMode selector * *) in primitive.mPrimitiveFormalArgumentList do
        routineMangledName.string += [passingMode formalPassingModeString]
        routineMangledName.string += selector.string
        routineMangledName.string += ":"
      end
      routineMangledName.string += ")"
      requiredByList += !routineMangledName
    end
    for init in initList do
      ioAST.mInitList +=
       !init.mInitLocation
       !moduleTypeName
       !moduleName.string
       !requiredByList
       !init.mInstructionList
       !init.mEndOfInitLocation
       !init.mPriority
    end
  #--- Declare structure
    ioAST.mDeclarationList += !@structureDeclaration.new {
      !moduleTypeName
      !{}
      !fieldList
      !functionDeclarationListAST
      !serviceListAST
      !sectionListAST
      !primitiveListAST
      !guardListAST
    }
  #--- Declare module
    ioAST.mDeclarationList += !@moduleDeclarationAST.new {!moduleName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mModuleName !self]
  let moduleTypeName = @lstring.new {!"$" + mModuleName + "$" !mModuleName.location}
 [!?ioGraph addEdge !mModuleName !moduleTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @moduleDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "module " + mModuleName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @moduleDeclarationAST location -> @location outLocation {
  outLocation = mModuleName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleMap {
  insert insertKey error message "the '%K' module is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [!?ioContext.mModuleMap insertKey !mModuleName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @moduleListIR {
  @string mModuleName
  @unifiedTypeMap-proxy mType
  @operandIRList mInitialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let moduleTypeName = @lstring.new {!mModuleName.string + "$" !mModuleName.location}
  let moduleType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName}
  [inContext.mConstructorMap searchKey !moduleTypeName ?let constructorValue]
  [constructorValue structure ?constructorSignature:* ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mModuleList += 
    !mModuleName.string
    !moduleType
    !initialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @moduleListIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += "@" + llvmNameForGlobalVariable (!mModuleName) + " = internal global "
  ioLLVMcode += [mType llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmName]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
