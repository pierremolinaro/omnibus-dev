#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @moduleDeclarationAST : @structureDeclaration {
  @lstring mModuleName
  @initList mModuleInitListAST
}

#·······················································································································

list @moduleDeclarationListAST {
  @moduleDeclarationAST mModule
}

#·······················································································································

class @requiredModuleAST : @abstractDeclaration {
  @lstring mModuleName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <module_variable> ?!@structurePropertyListAST ioPropertyList {
    $var$
    $identifier$ ?let fieldName
    @lstring typeName
    select
      $\$type$ ?typeName
    or
      typeName = ["" nowhere]
    end
    $=$
    <expression> ?let initExpression
    ioPropertyList += !fieldName !false !typeName !.expression{!initExpression:initExpression}
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    let moduleTypeName = moduleMangledNameFromModuleName (!moduleName)
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @structurePropertyListAST fieldList = {}
    @guardDeclarationListAST guardListAST = {}
    @systemRoutineDeclarationListAST svcListAST = {}
    @initList initList = {}
    repeat
    while
      <declaration_init> !?initList
    while
      <isr> !?ioAST.mISRDeclarationListAST !moduleTypeName !moduleName.string
    while
      <module_variable> !?fieldList
    while
      <function> !?functionDeclarationListAST
    while
     <system_routine> !?svcListAST
    while
      <guard> !?guardListAST
    while
      $;$
    end
    $}$
  #--- Declare module
    ioAST.mModuleDeclarationListAST += !@moduleDeclarationAST.new {
      !moduleTypeName
      !{}
      !fieldList
      !functionDeclarationListAST
      !svcListAST
      !guardListAST
      !moduleName
      !initList
    }
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    $($
    $)$
    ioAST.mRequiredModuleListAST += !moduleName
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mModuleName !self]
  let moduleTypeName = llvmRegularTypeMangledNameFromName (!moduleMangledNameFromModuleName (!mModuleName))
 [!?ioGraph addEdge !mModuleName !moduleTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @requiredModuleAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "module " + mModuleName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @requiredModuleAST location -> @location outLocation {
  outLocation = mModuleName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  RETAIN REQUIRED MODULES IN DECLARATION LIST AST                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc retainRequiredModules ?!@ast ioAST {
  @stringset instanciedModuleSet = {}
  for (moduleName) in ioAST.mRequiredModuleListAST do
    if [instanciedModuleSet hasKey !moduleName.string] then
      error moduleName : "this module is instancied more than once"
    end
    instanciedModuleSet += !moduleName.string
  end
#--- Tranfer required modules in declaration list AST (and init list AST)
  for (declaration) in ioAST.mModuleDeclarationListAST do
    if [instanciedModuleSet hasKey !declaration.mModuleName.string] then
      ioAST.mDeclarationListAST += !declaration
      ioAST.mDeclarationListAST += !@requiredModuleAST.new {!declaration.mModuleName}
      for init in declaration.mModuleInitListAST do
        ioAST.mInitListAST +=
         !init.mInitLocation
         !declaration.mStructureName
         !declaration.mModuleName
         !init.mInstructionList
         !init.mEndOfInitLocation
         !init.mPriority
      end
    end
  end
  ioAST.mModuleDeclarationListAST = {}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleMap {
  insert insertKey error message "the '%K' module is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [!?ioContext.mModuleMap insertKey !mModuleName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @moduleListIR {
  @string mModuleName
  @unifiedTypeMap-proxy mType
  @operandIRList mInitialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let moduleTypeName = moduleMangledNameFromModuleName (!mModuleName)
  let moduleType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName}
  [inContext.mConstructorMap searchKey !moduleTypeName ?let constructorValue]
  [constructorValue structure ?constructorSignature:* ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mModuleList += 
    !mModuleName.string
    !moduleType
    !initialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @moduleListIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += "@" + llvmNameForGlobalVariable (!mModuleName) + " = internal global "
  ioLLVMcode += [[mType kind] llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmName]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
