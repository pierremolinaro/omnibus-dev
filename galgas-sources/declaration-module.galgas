#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @moduleDeclarationAST : @abstractDeclaration {
  @lstring mModuleName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <module_variable> ?!@structurePropertyListAST ioPropertyList {
    $var$
    $identifier$ ?let fieldName
    @lstring typeName
    select
      $\$type$ ?typeName
    or
      typeName = ["" nowhere]
    end
    $=$
    <expression> ?let initExpression
    ioPropertyList += !fieldName !false !typeName !.expression{!initExpression:initExpression}
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    let moduleTypeName = moduleMangledNameFromModuleName (!moduleName)
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @structurePropertyListAST fieldList = {}
    @guardDeclarationListAST guardListAST = {}
    @systemRoutineDeclarationListAST svcListAST = {}
    @initList initList = {}
    repeat
    while
      <declaration_init> !?initList
    while
      <isr> !?ioAST.mISRDeclarationListAST !moduleTypeName !moduleName.string
    while
      <module_variable> !?fieldList
    while
      <function> !?functionDeclarationListAST
    while
     <system_routine> !?svcListAST
    while
      <guard> !?guardListAST
    while
      $;$
    end
    $}$
  #--- Declare init list
    @lstringlist requiredByList = {}
    for function in functionDeclarationListAST do
      if function.mPublicFunction then
        let routineMangledName = routineMangledNameFromAST (
          !"$" + moduleTypeName 
          !function.mFunctionName
          !function.mFunctionFormalArgumentList
        )
        requiredByList += !routineMangledName
      end
    end
#    for service in serviceListAST do
#      var routineMangledName = @lstring.new {
#        !"$" + moduleTypeName + "." + service.mServiceName
#        !service.mServiceName.location
#      }
#      routineMangledName.string += "("
#      for (passingMode selector * *) in service.mServiceFormalArgumentList do
#        routineMangledName.string += [passingMode formalPassingModeString]
#        routineMangledName.string += selector.string
#        routineMangledName.string += ":"
#      end
#      routineMangledName.string += ")"
#      requiredByList += !routineMangledName
#    end
    for guard in guardListAST do
      let routineMangledName = routineMangledNameFromAST (
        !"$" + moduleTypeName 
        !guard.mGuardName
        !guard.mGuardFormalArgumentList
      )
      requiredByList += !routineMangledName
    end
    for init in initList do
      ioAST.mInitListAST +=
       !init.mInitLocation
       !moduleTypeName
       !moduleName.string
       !requiredByList
       !init.mInstructionList
       !init.mEndOfInitLocation
       !init.mPriority
    end
  #--- Declare structure
    ioAST.mDeclarationListAST += !@structureDeclaration.new {
      !moduleTypeName
      !{}
      !fieldList
      !functionDeclarationListAST
      !svcListAST
      !guardListAST
    }
  #--- Declare module
    ioAST.mDeclarationListAST += !@moduleDeclarationAST.new {!moduleName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mModuleName !self]
  let moduleTypeName = llvmRegularTypeMangledNameFromName (!moduleMangledNameFromModuleName (!mModuleName))
 [!?ioGraph addEdge !mModuleName !moduleTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @moduleDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "module " + mModuleName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @moduleDeclarationAST location -> @location outLocation {
  outLocation = mModuleName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleMap {
  insert insertKey error message "the '%K' module is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [!?ioContext.mModuleMap insertKey !mModuleName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @moduleListIR {
  @string mModuleName
  @unifiedTypeMap-proxy mType
  @operandIRList mInitialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @moduleDeclarationAST semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let moduleTypeName = moduleMangledNameFromModuleName (!mModuleName)
  let moduleType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName}
  [inContext.mConstructorMap searchKey !moduleTypeName ?let constructorValue]
  [constructorValue structure ?constructorSignature:* ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mModuleList += 
    !mModuleName.string
    !moduleType
    !initialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @moduleListIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += "@" + llvmNameForGlobalVariable (!mModuleName) + " = internal global "
  ioLLVMcode += [[mType kind] llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmName]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
