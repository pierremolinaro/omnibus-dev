#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @modulePropertyListAST {
  @lstring mPropertyName
  @bool mIsConstant # true if declared with "let"
  @lstring mTypeName # Empty string if no type annotation
  @structurePropertyInitOptionalExpressionAST mOptionalExpression
}

#·······················································································································

struct @moduleDeclarationAST {
  @lstring mModuleName
  @modulePropertyListAST mPropertyListAST
  @functionDeclarationListAST mFunctionDeclarationListAST
  @systemRoutineDeclarationListAST mSystemRoutineListAST
  @guardDeclarationListAST mGuardListAST
  @initList mModuleInitListAST
}

#·······················································································································

list @moduleDeclarationListAST {
  @moduleDeclarationAST mModule
}

#·······················································································································

list @moduleInstanciationArgumentListAST {
  @lstring mSelector
  @expressionAST mExpression
}

#·······················································································································

list @moduleInstanciationListAST {
  @lstring mModuleName
  @moduleInstanciationArgumentListAST mModuleInstanciationArgumentList
}

#·······················································································································

class @requiredModuleAST : @abstractDeclarationAST {
  @lstring mModuleName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <module_property> ?!@modulePropertyListAST ioPropertyList {
    @bool constant
    select
      $var$
      constant = false
    or
      $let$
      constant = true
    end
    $identifier$ ?let fieldName
    select
      $\$type$ ?let typeName
      select
        ioPropertyList += !fieldName !constant !typeName !.noExpression
      or
        $=$
        <expression> ?let initExpression
        ioPropertyList += !fieldName !constant !typeName !.expression {!initExpression:initExpression}
      end
    or
      $=$
      <expression> ?let initExpression
      ioPropertyList += !fieldName !constant !["" nowhere] !.expression {!initExpression:initExpression}
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    ${$
    @functionDeclarationListAST functionDeclarationListAST = {}
    @modulePropertyListAST modulePropertyListAST = {}
    @guardDeclarationListAST guardListAST = {}
    @systemRoutineDeclarationListAST svcListAST = {}
    @initList initList = {}
    repeat
    while
      <declaration_init> !?initList
    while
      <isr> !?ioAST.mISRDeclarationListAST !moduleName
    while
      <module_property> !?modulePropertyListAST
    while
      <function> !?functionDeclarationListAST
    while
     <system_routine> !?svcListAST
    while
      <guard> !?guardListAST
    while
      $;$
    end
    $}$
  #--- Declare module
    ioAST.mModuleDeclarationListAST += !@moduleDeclarationAST.new {
      !moduleName
      !modulePropertyListAST
      !functionDeclarationListAST
      !svcListAST
      !guardListAST
      !initList
    }
  }

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $module$
    $identifier$ ?let moduleName
    $($
    @moduleInstanciationArgumentListAST moduleInstanciationArgumentList = {}
    repeat
    while
      $!selector:$ ?let selector
      <expression> ?let expression
      moduleInstanciationArgumentList += !selector !expression
    end
    $)$
    ioAST.mRequiredModuleListAST += !moduleName !moduleInstanciationArgumentList
  }
 
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 [!?ioGraph addNode !mModuleName !self]
  let moduleTypeName = llvmRegularTypeMangledNameFromName (!moduleMangledNameFromModuleName (!mModuleName))
 [!?ioGraph addEdge !mModuleName !moduleTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @requiredModuleAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "module " + mModuleName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @requiredModuleAST location -> @location outLocation {
  outLocation = mModuleName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  RETAIN REQUIRED MODULES IN DECLARATION LIST AST                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleInstanciationArgumentMap {
  @expressionAST mExpression
  insert insertKey error message "duplicated '%K' selector"
  search searchKey error message "uninitialized '%K' property"
}

#·······················································································································

map @instanciedModuleMap {
  @moduleInstanciationArgumentMap mModuleInstanciationArgumentMap
  insert insertKey error message "the '%K' module is already instancied in %L"
  search searchKey error message "internal error %K"
}

#·······················································································································

proc retainRequiredModules ?!@ast ioAST {
  @instanciedModuleMap instanciedModuleMap = {}
  @stringset validModuleNames = {} # For checking alk required modules have been declared
  for (moduleName args) in ioAST.mRequiredModuleListAST do
     @moduleInstanciationArgumentMap moduleInstanciationArgumentMap = {}
     for (selector expression) in args do
       [!?moduleInstanciationArgumentMap insertKey !selector !expression]
     end
    [!?instanciedModuleMap insertKey !moduleName !moduleInstanciationArgumentMap]
  end
#--- Append required modules to declaration list AST (and init list AST)
  for (declaration) in ioAST.mModuleDeclarationListAST do
    if [instanciedModuleMap hasKey !declaration.mModuleName.string] then
      validModuleNames += !declaration.mModuleName.string
      [instanciedModuleMap searchKey !declaration.mModuleName ?let moduleInstanciationArgumentMap]
    #--- Build module property list, adding init expression
      @stringset validArgumentSet = {}
      @structurePropertyListAST modulePropertyListAST = {}
      for (propertyName constant optionalPropertyTypeName optionalInitExpression) in declaration.mPropertyListAST do
        @expressionAST initExpression
        switch optionalInitExpression 
        case noExpression :
          [moduleInstanciationArgumentMap searchKey !propertyName ?initExpression]
          validArgumentSet += !propertyName.string
        case expression (expression) :
          initExpression = expression
        end
        modulePropertyListAST += 
         !propertyName
         !constant
         !false
         !optionalPropertyTypeName
         !.expression{!initExpression:initExpression}
      end
    #--- Check all arguments of module instanciation have been used
      for (unusedSelector) in [moduleInstanciationArgumentMap keySet] - validArgumentSet do
        error [moduleInstanciationArgumentMap locationForKey !unusedSelector] : "invalid selector"
      end
    #---
      let moduleTypeName = moduleMangledNameFromModuleName (!declaration.mModuleName)
      ioAST.mDeclarationListAST += !@requiredModuleAST.new {!declaration.mModuleName}
      ioAST.mDeclarationListAST += !@structureDeclarationAST.new {
        !moduleTypeName
        !{}
        !modulePropertyListAST
        !declaration.mFunctionDeclarationListAST
        !declaration.mSystemRoutineListAST
        !declaration.mGuardListAST
      }
      for init in declaration.mModuleInitListAST do
        ioAST.mInitListAST +=
         !init.mInitLocation
         !moduleTypeName
         !declaration.mModuleName
         !init.mInstructionList
         !init.mEndOfInitLocation
         !init.mPriority
      end
    end
  end
  ioAST.mModuleDeclarationListAST = {}
#--- Check all modules named in instanciation constructs have been implemented
  for (unusedModuleName) in [instanciedModuleMap keySet] - validModuleNames do
    error [instanciedModuleMap locationForKey !unusedModuleName] : "undefined module"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @moduleMap {
  insert insertKey error message "the '%K' module is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph unused ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  [!?ioContext.mModuleMap insertKey !mModuleName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @moduleListIR {
  @string mModuleName
  @unifiedTypeMap-proxy mType
  @operandIRList mInitialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @requiredModuleAST semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let moduleTypeName = moduleMangledNameFromModuleName (!mModuleName)
  let moduleTypeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !moduleTypeName}
  let constructorMap = [[moduleTypeProxy type] constructorMap]
  [constructorMap  searchKey !.new {!"()" !moduleTypeName.location} ?* ?let constructorValue]
  [constructorValue structure ?sortedOperandList:let sortedOperandList]
  @operandIRList initialValueList = {}
  for (initialValue *) in sortedOperandList do
    initialValueList += !initialValue
  end
  ioIntermediateCodeStruct.mModuleList += 
    !mModuleName.string
    !moduleTypeProxy
    !initialValueList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @requiredModuleAST generateLLVMcode ?!@string unused ioLLVMcode {
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @moduleListIR-element generateLLVM ?!@string ioLLVMcode {
  ioLLVMcode += llvmNameForGlobalVariable (!mModuleName) + " = internal global "
  ioLLVMcode += [[mType type] llvmTypeName] + " {"
  for (value) in mInitialValueList
    do ioLLVMcode += [value llvmTypeName] + " " + [value llvmName]
    between ioLLVMcode += ", "  
  end
  ioLLVMcode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
