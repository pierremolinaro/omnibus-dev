#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @llvmGenerationInstructionElement {
  case string (@string string)
  case constant (@lstring name)
  case type (@lstring name)
}

#·······················································································································

list @llvmGenerationInstructionElementList {
  @llvmGenerationInstructionElement mElement
}

#·······················································································································

abstract class @abstractLLVMInstruction {
}

#·······················································································································

class @llvmGenerationInstruction : @abstractLLVMInstruction {
  @llvmGenerationInstructionElementList mGenerationList
}

#·······················································································································

class @llvmVarInstruction : @abstractLLVMInstruction {
  @lstring mVariableName
}

#·······················································································································

list @llvmGenerationInstructionList {
  @abstractLLVMInstruction mInstruction
}

#·······················································································································

class @llvmAssignmentOperatorDeclaractionAST : @abstractDeclarationAST {
  @location mOperatorLocation
  @lstring mTargetVariableName
  @lstring mTargetTypeName
  @genericFormalParameterList mTargetGenericFormalParameterList
  @lstring mSourceVariableName
  @lstring mSourceTypeName
  @genericFormalParameterList mSourceGenericFormalParameterList
  @ctExpressionAST mWhereClause
  @llvmGenerationInstructionList mInstructionList
}

#·······················································································································

override getter @llvmAssignmentOperatorDeclaractionAST locationForErrorSignaling -> @location outLocation {
  outLocation = mOperatorLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <llvm_instruction_list> !@llvmGenerationInstructionList outInstructionList {
    outInstructionList = {}
    repeat
    while
      <llvm_instruction> ?let instruction
      outInstructionList += !instruction
    end
  }

  #·····················································································································

  rule <llvm_instruction> !@abstractLLVMInstruction outInstruction {
    $var$
    $identifier$ ?let name
    outInstruction = @llvmVarInstruction.new {!name}
  }
  
  #·····················································································································

  rule <llvm_instruction> !@abstractLLVMInstruction outInstruction {
    $llvm$
    @llvmGenerationInstructionElementList elementList = {}
    repeat
      select
        $"string"$ ?let string
        elementList += !.string {!string: string}
      or
        $identifier$ ?let name
        elementList += !.constant {!name: name}
      or
        $\$type$ ?let typeName
        elementList += !.type {!name: typeName}
      end
    while
     $+$
    end
    outInstruction = @llvmGenerationInstruction.new {!elementList}
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $llvm$
    $func$
    $($
    $identifier$ ?let targetVariableName
    $\$type$ ?let targetTypeName
    <generic_formal_arguments> ?let targetGenericFormalParameterList
    $)$
    let operatorLocation = @location.here
    $=$
    $($
    $identifier$ ?let sourceVariableName
    $\$type$ ?let sourceTypeName
    <generic_formal_arguments> ?let sourceGenericFormalParameterList
    $)$
    <generic_where_clause> ?let whereClause
    ${$
    <llvm_instruction_list> ?let instructionList
    $}$
    ioAST.mDeclarationListAST += !@llvmAssignmentOperatorDeclaractionAST.new {
      !operatorLocation
      !targetVariableName
      !targetTypeName
      !targetGenericFormalParameterList
      !sourceVariableName
      !sourceTypeName
      !sourceGenericFormalParameterList
      !whereClause
      !instructionList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @llvmAssignmentOperatorDeclaractionAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = @lstring.new {!mTargetTypeName.string + " = " + mSourceTypeName !mOperatorLocation}
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName !mTargetTypeName]
  [!?ioGraph addEdge !nodeName !mSourceTypeName]
}

#·······················································································································

override getter @llvmAssignmentOperatorDeclaractionAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "Assignment " + mTargetTypeName + " = " + mSourceTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @llvmGenerationInstructionList checkInstructionList  ?let @ctCheckMap inMap {
  var currentMap = inMap
  for (instruction) in self do
    [instruction checkInstructionList !?currentMap]
  end
}

#·······················································································································

abstract method @abstractLLVMInstruction checkInstructionList ?!@ctCheckMap ioMap

#·······················································································································

override method @llvmVarInstruction checkInstructionList  ?!@ctCheckMap ioMap {
  [!?ioMap insertKey !mVariableName]
}

#·······················································································································

override method @llvmGenerationInstruction checkInstructionList ?!@ctCheckMap ioMap {
  for (element) in mGenerationList do
    switch element
    case string (*) :
    case constant (name) :
      [ioMap searchKey !name]
    case type (name) :
      [ioMap searchKey !name]
    end
  end
}

#·······················································································································

map @assignmentOperatorMap {
  @omnibusType mTargetType
  @lstring mTargetVarName
  @genericFormalParameterList mTargetGenericFormalParameterList
  @omnibusType mSourceTpe
  @lstring mSourceVarName
  @genericFormalParameterList mSourceGenericFormalParameterList
  @ctExpressionAST mWhereClause
  @llvmGenerationInstructionList mInstructionList
  insert insertKey error message "the '%K' assignment is already declared in %L"
  search searchKey error message "there is no '%K' assignment"
}

#·······················································································································

override method @llvmAssignmentOperatorDeclaractionAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Build formal generic constant parameter map
  @ctCheckMap formalGenericConstantParameterMap = {}
  [mTargetGenericFormalParameterList buildFormalGenericConstantMap !?formalGenericConstantParameterMap]
  [mSourceGenericFormalParameterList buildFormalGenericConstantMap !?formalGenericConstantParameterMap]
#--- Check Where clause
  [mWhereClause checkCompileTimeExpression !formalGenericConstantParameterMap]
#--- Check instruction list
  [!?formalGenericConstantParameterMap insertKey !mTargetVariableName]
  [!?formalGenericConstantParameterMap insertKey !mSourceVariableName]
  [mInstructionList checkInstructionList !formalGenericConstantParameterMap]
#--- Types
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mTargetTypeName ?let targetType]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mSourceTypeName ?let sourceType]
#---
  let key = @lstring.new {
    ![[targetType type] omnibusTypeDescriptionName] + " = " + [[sourceType type] omnibusTypeDescriptionName]
    !mOperatorLocation
  }
  [!?ioContext.mAssignmentOperatorMap insertKey
    !key 
    ![targetType type]
    !mTargetVariableName
    !mTargetGenericFormalParameterList
    ![sourceType type]
    !mSourceVariableName
    !mSourceGenericFormalParameterList
    !mWhereClause
    !mInstructionList
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @assignmentGenerationVarMap {
  @string mValue
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#·······················································································································

method @llvmGenerationInstructionList generateIRCode
    ?let @assignmentGenerationVarMap inVarMap
    ?let @assignmentGenerationVarMap inTypeMap
    ?!@instructionListIR ioInstructionListIR
    ?!@semanticTemporariesStruct ioTemporaries
    ?!@allocaList ioAllocaList
{
  var varMap = inVarMap
  var typeMap = inTypeMap
  for (instruction) in self do
    [instruction generateIRCode !?varMap !?typeMap !?ioInstructionListIR !?ioTemporaries !?ioAllocaList]
  end
}

#·······················································································································

abstract method @abstractLLVMInstruction generateIRCode
    ?!@assignmentGenerationVarMap ioVarMap
    ?!@assignmentGenerationVarMap ioTypeMap
    ?!@instructionListIR ioInstructionListIR
    ?!@semanticTemporariesStruct ioTemporaries
    ?!@allocaList unused ioAllocaList

#·······················································································································

override method @llvmGenerationInstruction generateIRCode
    ?!@assignmentGenerationVarMap ioVarMap
    ?!@assignmentGenerationVarMap ioTypeMap
    ?!@instructionListIR ioInstructionListIR
    ?!@semanticTemporariesStruct unused ioTemporaries
    ?!@allocaList unused ioAllocaList
{
   var s = ""
   for (element) in mGenerationList do
     switch element 
     case string (value) :
       s += value
     case constant (name) :
       [ioVarMap searchKey !name ?let value]
       s += value
     case type (name) :
       [ioTypeMap searchKey !name ?let value]
       s += value
     end
   end
   s += " ; Assignment"
   [!?ioInstructionListIR appendInstructionAsFreeString! s]
}

#·······················································································································

override method @llvmVarInstruction generateIRCode
    ?!@assignmentGenerationVarMap ioVarMap
    ?!@assignmentGenerationVarMap unused ioTypeMap
    ?!@instructionListIR unused ioInstructionListIR
    ?!@semanticTemporariesStruct ioTemporaries
    ?!@allocaList unused ioAllocaList
{
  let newTemporaryVariable = "%temp" + ioTemporaries.mTemporaryIndex
  ioTemporaries.mTemporaryIndex ++
  [!?ioVarMap insertKey !mVariableName !newTemporaryVariable]
}

#·······················································································································

method @assignmentOperatorMap appendAssignment
    ?!@semanticTemporariesStruct ioTemporaries
    ?!@instructionListIR ioInstructionListIR
    ?!@allocaList ioAllocaList
    ?let @LValueRepresentation inTarget
    ?let @objectIR inSourcePossibleReference
    ?let @location inErrorLocation
{
  let key = @lstring.new {
   !inTarget.type.omnibusTypeDescriptionName + " = " + [inSourcePossibleReference type].omnibusTypeDescriptionName
   !inErrorLocation
  }
  [self searchKey !key ?* ?let targetVarName ?2* ?let sourceVarName ?2* ?let instructionList]
  let srcTypeLLVMName = [[inSourcePossibleReference type] llvmTypeName]
  var srcLLVMName = [inSourcePossibleReference llvmName]
  if not [inSourcePossibleReference isReference] then
    let result = checkAssignmentCompatibility (
      !source:inSourcePossibleReference # loadedResultValue
      !targetAnnotationType:[inTarget type]
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
   [!?ioInstructionListIR appendStoreToUniversalReference !inTarget.llvmName ![inTarget type] !result]
  else
    @assignmentGenerationVarMap varMap = {}
    [!?varMap insertKey !targetVarName !inTarget.llvmName]
    [!?varMap insertKey !sourceVarName !srcLLVMName]
    @assignmentGenerationVarMap typeMap = {}
    [!?typeMap insertKey !targetVarName ![[inTarget type] llvmTypeName]]
    [!?typeMap insertKey !sourceVarName !srcTypeLLVMName]
    [instructionList generateIRCode !varMap !typeMap !?ioInstructionListIR !?ioTemporaries !?ioAllocaList]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

