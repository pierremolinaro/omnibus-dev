#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @llvmAssignmentOperatorDeclarationAST : @abstractDeclarationAST {
  @location mOperatorLocation
  @lstring mTargetVariableName
  @lstring mTargetTypeName
  @genericFormalParameterList mTargetGenericFormalParameterList
  @lstring mSourceVariableName
  @lstring mSourceTypeName
  @genericFormalParameterList mSourceGenericFormalParameterList
  @ctExpressionAST mWhereClause
  @llvmGenerationInstructionList mLLVMInstructionList
}

#·······················································································································

override getter @llvmAssignmentOperatorDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mOperatorLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func buildAssignmentOperatorDeclaration ?let @string inTypeName -> @abstractDeclarationAST {
  @llvmGenerationInstructionList llvmInstructionList = {}
  llvmInstructionList += !@llvmVarInstruction.new {!["LOADED" nowhere]}
  @llvmGenerationInstructionElementList instructionElements = {}
  instructionElements += !.symbol {!name: ["LOADED" nowhere]}
  instructionElements += !.string {!string: " = load "}
  instructionElements += !.type {!name: ["SRC" nowhere]}
  instructionElements += !.string {!string: ", "}
  instructionElements += !.type {!name: ["SRC" nowhere]}
  instructionElements += !.string {!string: "* "}
  instructionElements += !.symbol {!name: ["SRC" nowhere]}
  llvmInstructionList += !@llvmGenerationInstruction.new {!{instructionElements}}
  instructionElements = {}
  instructionElements += !.string {!string: "store "}
  instructionElements += !.type {!name: ["SRC" nowhere]}
  instructionElements += !.string {!string: " "}
  instructionElements += !.symbol {!name: ["LOADED" nowhere]}
  instructionElements += !.string {!string: ", "}
  instructionElements += !.type {!name: ["TGT" nowhere]}
  instructionElements += !.string {!string: "* "}
  instructionElements += !.symbol {!name: ["TGT" nowhere]}
  llvmInstructionList += !@llvmGenerationInstruction.new {!{instructionElements}}
  result = @llvmAssignmentOperatorDeclarationAST.new {
    !["" nowhere]
    !["TGT" nowhere]
    ![inTypeName nowhere]
    !{}
    !["SRC" nowhere]
    ![inTypeName nowhere]
    !{}
    !@ctTrueExpressionAST.new
    !llvmInstructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func buildAssignmentOperatorFrom_ctInt ?let @string inTypeName -> @abstractDeclarationAST {
  @llvmGenerationInstructionList llvmInstructionList = {}
  @llvmGenerationInstructionElementList instructionElements = {}
  instructionElements += !.string {!string: "store "}
  instructionElements += !.type {!name: ["TGT" nowhere]}
  instructionElements += !.string {!string: " "}
  instructionElements += !.symbol {!name: ["SRC" nowhere]}
  instructionElements += !.string {!string: ", "}
  instructionElements += !.type {!name: ["TGT" nowhere]}
  instructionElements += !.string {!string: "* "}
  instructionElements += !.symbol {!name: ["TGT" nowhere]}
  llvmInstructionList += !@llvmGenerationInstruction.new {!{instructionElements}}
  result = @llvmAssignmentOperatorDeclarationAST.new {
    !["" nowhere]
    !["TGT" nowhere]
    ![inTypeName nowhere]
    !{}
    !["SRC" nowhere]
    ![ctIntegerTypeName () nowhere]
    !{}
    !@ctTrueExpressionAST.new
    !llvmInstructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <llvm_function_header>
    !@lstring outTargetVariableName
    !@lstring outTargetTypeName
    !@genericFormalParameterList outTargetGenericFormalParameterList
  {
    $llvm$
    $func$
    $($
    $identifier$ ?outTargetVariableName
    $\$type$ ?outTargetTypeName
    <generic_formal_arguments> ?outTargetGenericFormalParameterList
    $)$
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    <llvm_function_header> ?let targetVariableName ?let targetTypeName ?let targetGenericFormalParameterList
    let operatorLocation = @location.here
    $=$
    $($
    $identifier$ ?let sourceVariableName
    $\$type$ ?let sourceTypeName
    <generic_formal_arguments> ?let sourceGenericFormalParameterList
    $)$
    <generic_where_clause> ?let whereClause
    ${$
    <llvm_instruction_list> ?let instructionList
    $}$
    ioAST.mDeclarationListAST += !@llvmAssignmentOperatorDeclarationAST.new {
      !operatorLocation
      !targetVariableName
      !targetTypeName
      !targetGenericFormalParameterList
      !sourceVariableName
      !sourceTypeName
      !sourceGenericFormalParameterList
      !whereClause
      !instructionList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @llvmAssignmentOperatorDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = @lstring.new {!mTargetTypeName.string + " = " + mSourceTypeName !mOperatorLocation}
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName !mTargetTypeName]
  [!?ioGraph addEdge !nodeName !mSourceTypeName]
}

#·······················································································································

override getter @llvmAssignmentOperatorDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "Assignment " + mTargetTypeName + " = " + mSourceTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @assignmentOperatorMap {
  @omnibusType mTargetType
  @lstring mTargetVarName
  @genericFormalParameterList mTargetGenericFormalParameterList
  @omnibusType mSourceTpe
  @lstring mSourceVarName
  @genericFormalParameterList mSourceGenericFormalParameterList
  @ctExpressionAST mWhereClause
  @llvmGenerationInstructionList mInstructionList
  insert insertKey error message "the '%K' assignment is already declared in %L"
  search searchKey error message "there is no '%K' assignment"
}

#·······················································································································

list @omnibusTypeList {
  @omnibusType mType
}

#·······················································································································

listmap @assignableTypesFromCompileTimeType_Map (@omnibusTypeList)

#·······················································································································

override method @llvmAssignmentOperatorDeclarationAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Build formal generic constant parameter map
  @ctCheckMap formalGenericConstantParameterMap = {}
  [mTargetGenericFormalParameterList buildFormalGenericConstantMap !?formalGenericConstantParameterMap]
  [mSourceGenericFormalParameterList buildFormalGenericConstantMap !?formalGenericConstantParameterMap]
#--- Check Where clause
  [mWhereClause checkCompileTimeExpression !formalGenericConstantParameterMap]
#--- Check instruction list
  [!?formalGenericConstantParameterMap insertKey !mTargetVariableName]
  [!?formalGenericConstantParameterMap insertKey !mSourceVariableName]
  [mLLVMInstructionList checkInstructionList !formalGenericConstantParameterMap]
#--- Types
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mTargetTypeName ?let targetTypeProxy]
  let targetType = [targetTypeProxy type]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mSourceTypeName ?let sourceTypeProxy]
  let sourceType = [sourceTypeProxy type]
#---
  let key = @lstring.new {
    ![targetType omnibusTypeDescriptionName] + " = " + [sourceType omnibusTypeDescriptionName]
    !mOperatorLocation
  }
  [!?ioContext.mAssignmentOperatorMap insertKey
    !key 
    !targetType
    !mTargetVariableName
    !mTargetGenericFormalParameterList
    !sourceType
    !mSourceVariableName
    !mSourceGenericFormalParameterList
    !mWhereClause
    !mLLVMInstructionList
  ]
#--- Generate function if
#       - none type is generic
#       - source type is not a compile time type
  if ([mTargetGenericFormalParameterList length] == 0)
   && ([mSourceGenericFormalParameterList length] == 0)
   && not [sourceType.kind isCompileTimeInteger]
   && not [sourceType.kind isCompileTimeBool] then
    @assignmentGenerationVarMap varMap = {}
    [!?varMap insertKey !mTargetVariableName !"%" + mTargetVariableName]
    [!?varMap insertKey !mSourceVariableName !"%" + mSourceVariableName]
    @assignmentGenerationVarMap typeMap = {}
    [!?typeMap insertKey !mTargetVariableName ![targetType llvmTypeName]]
    [!?typeMap insertKey !mSourceVariableName ![sourceType llvmTypeName]]
    @stringlist generatedInstructions = {}
    @allocaList allocaList = {}
    @uint temporaryIndex = 0
    [mLLVMInstructionList generateIRCode !varMap !typeMap !?generatedInstructions !?temporaryIndex !?allocaList]
    let routine = @assignmentRoutineIR.new {
      !.new {!assignmentOperatorFuncName (!targetType !sourceType) !mOperatorLocation}
      !isRequired: false
      !warnsIfUnused: false
      !targetType
      !mTargetVariableName.string
      !sourceType
      !mSourceVariableName.string
      !generatedInstructions
      !allocaList
    }
    ioRoutineListIR += !routine
  end
#--- 
  if [sourceType.kind isCompileTimeBool] | [sourceType.kind isCompileTimeInteger] then
    ioContext.mAssignableTypesFromCompileTimeType_Map += !sourceType.omnibusTypeDescriptionName !targetType
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @instructionListIR appendAssignmentIR
    ?!@semanticTemporariesStruct ioTemporaries
    ?let @assignmentOperatorMap inAssignmentOperatorMap
    ?!@allocaList ioAllocaList
    ?let @omnibusType inTargetType
    ?let @string inTargetLLVMName
    ?let @objectIR inSourcePossibleReference
    ?let @location inErrorLocation
{
  if not [inSourcePossibleReference isReference] then
    let result = checkAssignmentCompatibility (
      !source:inSourcePossibleReference # loadedResultValue
      !targetAnnotationType:inTargetType
      !errorLocation:inErrorLocation
      !staticTypeAllowed:false
    )
   [!?self appendStoreToUniversalReference !inTargetLLVMName !inTargetType !result]
  else
    let key = @lstring.new {
     !inTargetType.omnibusTypeDescriptionName + " = " + [inSourcePossibleReference type].omnibusTypeDescriptionName
     !inErrorLocation
    }
    [inAssignmentOperatorMap searchKey
      !key
      ?*
      ?let targetVarName
      ?let targetGenericFormalParameterList
      ?*
      ?let sourceVarName
      ?let sourceGenericFormalParameterList
      ?*
      ?let llvmInstructionList
    ]
    if ([targetGenericFormalParameterList length] == 0)
    && ([sourceGenericFormalParameterList length] == 0)
    && not [[inSourcePossibleReference type].kind isCompileTimeInteger]
    && not [[inSourcePossibleReference type].kind isCompileTimeBool] then
      let llvmRoutineName = assignmentOperatorFuncName (!inTargetType ![inSourcePossibleReference type])
      var s = "call void @" + [llvmRoutineName assemblerRepresentation]
            + " (" + [inTargetType llvmTypeName] + "* " + inTargetLLVMName
            + ", " + [[inSourcePossibleReference type] llvmTypeName] + "* " + [inSourcePossibleReference llvmName] + ")"
      [!?self appendInstructionAsFreeString !s !{!llvmRoutineName}]
    else
    [inSourcePossibleReference reference ?type:let sourceType ?llvmName: let srcLLVMName]
    @assignmentGenerationVarMap varMap = {}
    [!?varMap insertKey !targetVarName !inTargetLLVMName]
    [!?varMap insertKey !sourceVarName !srcLLVMName]
    @assignmentGenerationVarMap typeMap = {}
    [!?typeMap insertKey !targetVarName ![inTargetType llvmTypeName]]
    [!?typeMap insertKey !sourceVarName ! [sourceType llvmTypeName]]
    @stringlist generatedInstructions = {}
    [llvmInstructionList generateIRCode !varMap !typeMap !?generatedInstructions !?ioTemporaries.mTemporaryIndex !?ioAllocaList]
    for (str) in generatedInstructions do
     [!?self appendInstructionAsFreeString !str !{}]
    end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @assignmentRoutineIR : @abstractRoutineIR {
  @omnibusType mTargetType
  @string mTargetVarName
  @omnibusType mSourceType
  @string mSourceVarName
  @stringlist mGeneratedInstructions
  @allocaList mAllocaList
}

#·······················································································································

override method @assignmentRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "define internal void @" + [mRoutineMangledName assemblerRepresentation]
  ioLLVMcode += " (" + [mTargetType llvmTypeName] + "* %" + mTargetVarName
             + ", " + [mSourceType llvmTypeName] + "* %" + mSourceVarName + ") nounwind {\n"
  [mAllocaList generateAllocaList !?ioLLVMcode]
  for (instruction) in mGeneratedInstructions do
    ioLLVMcode += "  " + instruction + "\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
