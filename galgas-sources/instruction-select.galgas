#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardedCommand {
  case synchronization (@lstring optionalReceiverName @lstring guardName @effectiveParameterListAST effectiveParameterListAST)
  case boolean (@expressionAST expression @location endOfExpression)
  case boolAndSync (@expressionAST expression @location endOfExpression @lstring optionalReceiverName @lstring guardName @effectiveParameterListAST effectiveParameterListAST)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @onInstructionBranchList {
  @guardedCommand mGuardedCommand
  @instructionListAST mInstructionList
  @location mEndOfBranch
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @onInstructionAST : @instructionAST {
  @location mStartOf_on_instruction
  @onInstructionBranchList mBranchList
  @location mEndOf_on_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <guarded_command> !@guardedCommand outGuardedCommand {
    select
     $when$
     <expression> ?let @expressionAST expression
     let endOfExp = @location.here
     select
       outGuardedCommand = .boolean {!expression:expression !endOfExpression:endOfExp}
      or
        $upon$
        $identifier$ ?let guardName
        <effective_parameters> ?let effectiveParameterList
        outGuardedCommand = .boolAndSync {
          !expression:expression
          !endOfExpression:endOfExp
          !optionalReceiverName:["" here]
          !guardName:guardName
          !effectiveParameterListAST:effectiveParameterList
        }
      or
        $upon$
        $identifier$ ?let receiverName
        $.$
        $identifier$ ?let guardName
        <effective_parameters> ?let effectiveParameterList
        outGuardedCommand = .boolAndSync {
          !expression:expression
          !endOfExpression:endOfExp
          !optionalReceiverName:receiverName
          !guardName:guardName
          !effectiveParameterListAST:effectiveParameterList
        }
      end
    or
      $upon$
      $identifier$ ?let guardName
      <effective_parameters> ?let effectiveParameterList
      outGuardedCommand = .synchronization {
        !optionalReceiverName:["" here]
        !guardName:guardName
        !effectiveParameterListAST:effectiveParameterList
      }
    or
      $upon$
      $identifier$ ?let receiverName
      $.$
      $identifier$ ?let guardName
      <effective_parameters> ?let effectiveParameterList
      outGuardedCommand = .synchronization {
        !optionalReceiverName:receiverName
        !guardName:guardName
        !effectiveParameterListAST:effectiveParameterList
      }
    end
  }
  
 #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap ioLabelMap {
    $select$
    let startLocation = @location.here
    @lstring startLabel
    select
      startLabel = .new {!"" !.here}
    or
      $attribute$ ?startLabel
      [!?ioLabelMap insertKey !startLabel]
    end
    @onInstructionBranchList onInstructionBranchList = {}
    repeat
      <guarded_command> ?let @guardedCommand guardedCommand
      $:$
      <instructionList> ?let instructionList !?ioLabelMap
      onInstructionBranchList += !guardedCommand !instructionList !.here
    while
    end
    ioInstructionList += !@onInstructionAST.new {!startLocation !onInstructionBranchList !.here}
    $end$
    @lstring endLabel
    select
      endLabel = .new {!"" !.here}
    or
      $attribute$ ?endLabel
    end
    if startLabel.string != endLabel.string then
      error endLabel : "'end' label does not match 'on' label, it should be "
         + (if startLabel.string != "" then "@" + startLabel.string else "empty" end)
    end 
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (* instructionList *) in mBranchList do
    [instructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  @onInstructionBranchListIR onInstructionBranchListIR = {}
  for (guardedCommand instructionList endOfBranch) in mBranchList do
    [!?ioVariableMap openOverrideForSelectBlock]
  #--- Guard
    @guardedCommandIR guardedCommandIR
    switch guardedCommand
    case synchronization (optionalReceiverName guardName effectiveParameterList) :
     @instructionListIR guardInstructionGenerationList = {}
     analyzeGuardCall (
        !self:inSelfType
        !receiverName:optionalReceiverName
        !routineName:guardName
        !effective:effectiveParameterList
        !callerForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !requiredModeSet:inRequiredModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?alloca:ioAllocaList
        !?instructionListIR:guardInstructionGenerationList
        ?effectiveIR:let @procCallEffectiveParameterListIR guardEffectiveParameterListIR
        ?guardMangledName:let @lstring guardMangledName
      )
      guardedCommandIR = .synchronization {
        !guardMangledName:guardMangledName.string
        !globalVarName:optionalReceiverName.string
        !guardInstructionGenerationList:guardInstructionGenerationList
        !effectiveParameterListIR:guardEffectiveParameterListIR
      }
    case boolean (expression endOfExpression) :
      @instructionListIR guardInstructionGenerationList = {}
      [expression analyzeExpression
        !self:inSelfType
        !inGuard:true
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:.null
        !context:inContext
        !modes:inRequiredModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?alloca:ioAllocaList
        !?instructionListIR:guardInstructionGenerationList
        ?result:@operandIR sourceOperand
      ]
      if [sourceOperand.mType key] != boolTypeName () then
        error endOfExpression : "guarded expression should be boolean"
      elsif [sourceOperand.mValue isStatic] then
        warning endOfExpression : "guarded expression is static"
      end
      guardedCommandIR = .booleanGuard {
        !instructionGenerationList:guardInstructionGenerationList
        !result:sourceOperand
      }
    case boolAndSync (expression endOfExpression optionalReceiverName guardName effectiveParameterList) :
      @instructionListIR boolExpInstructionGenerationList = {}
      [expression analyzeExpression
        !self:inSelfType
        !inGuard:true
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:.null
        !context:inContext
        !modes:inRequiredModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?alloca:ioAllocaList
        !?instructionListIR:boolExpInstructionGenerationList
        ?result:let @operandIR boolExpressionResult
      ]
      if [boolExpressionResult.mType key] != boolTypeName () then
        error endOfExpression : "guarded expression should be boolean"
      elsif [boolExpressionResult.mValue isStatic] then
        warning endOfExpression : "guarded expression is static"
      end
     @instructionListIR guardInstructionGenerationList = {}
     analyzeGuardCall (
        !self:inSelfType
        !receiverName:optionalReceiverName
        !routineName:guardName
        !effective:effectiveParameterList
        !callerForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !requiredModeSet:inRequiredModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?alloca:ioAllocaList
        !?instructionListIR:guardInstructionGenerationList
        ?effectiveIR:let @procCallEffectiveParameterListIR guardEffectiveParameterListIR
        ?guardMangledName:let @lstring guardMangledName
      )
      guardedCommandIR = .boolAndSync {
        !boolExpInstructionGenerationList:boolExpInstructionGenerationList
        !boolExpResult:boolExpressionResult
        !guardMangledName:guardMangledName.string
        !globalVarName:optionalReceiverName.string
        !guardInstructionGenerationList:guardInstructionGenerationList
        !effectiveParameterListIR:guardEffectiveParameterListIR
      }
    end
  #--- Instruction list
    @instructionListIR branchInstructionGenerationList = {}
    [instructionList analyzeBranchInstructionList
      !self:inSelfType
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !endOfInstructionList:endOfBranch
      !context:inContext
      !modes:inRequiredModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?alloca:ioAllocaList
      !?instructionListIR:branchInstructionGenerationList
    ]
    [!?ioVariableMap closeOverride !endOfBranch]
  #---
    onInstructionBranchListIR +=
      !guardedCommandIR
      !branchInstructionGenerationList
  end
#--- Code generation
  ioInstructionGenerationList += !@onInstructionIR.new {!mStartOf_on_instruction !onInstructionBranchListIR}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeGuardCall
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?receiverName:let @lstring inReceiverName
  ?routineName:let @lstring inGuardName
  ?effective:let @effectiveParameterListAST inEffectiveParameterList
  ?callerForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?requiredModeSet:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !effectiveIR:@procCallEffectiveParameterListIR outEffectiveParameterListIR
  !guardMangledName:@lstring outGuardMangledName
{
  outEffectiveParameterListIR = {}
  @unifiedTypeMap-proxy receiverType
  if inReceiverName.string != "" then
    [!?ioVariableMap searchForReadAccess
      !lkey:inReceiverName
      ?type:receiverType
      ?1*
      ?variableKind:@objectInMemoryIR variableKind
      ?4*
    ]
    outGuardMangledName = .new {!"$" + [receiverType key] + "." + inGuardName !inGuardName.location}
    outEffectiveParameterListIR += !.outputInput ![variableKind address] #--- add "load receiver" as first argument
  else
    outGuardMangledName = .new {!"." + inGuardName !inGuardName.location}
    receiverType = .null
  end
  [inContext.mGuardMapForContext searchKey
    !outGuardMangledName
    ?let isPublic
    ?let @procedureSignature formalSignature
  ]
#--- Check accessibility
  if not isPublic then
    if inReceiverName.string == "" then # Standalone function
      let @string declarationFile = [[inContext.mGuardMapForContext locationForKey !outGuardMangledName.string] file]
      let invocationFile = [inGuardName.location file]
      if invocationFile != declarationFile then
        error inGuardName : "this guard is not public"
      end
    else
      error inGuardName : "this guard is not public"
    end  
  end  
#--- Enter in invocation graph
  let routineNameForInvocationGraph = guardNameForInvocationGraph (!receiverType !inGuardName)
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForInvocationGraph]
#--- Analyze effective parameters
  analyzeEffectiveParameters (
    !self:inSelfType
    !formal:formalSignature
    !effective:inEffectiveParameterList
    !errorLocation:inGuardName.location
    !callerForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:outEffectiveParameterListIR
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @guardedCommandIR {
  case synchronization (@string guardMangledName
                        @string globalVarName # "" if not global var
                        @instructionListIR guardInstructionGenerationList
                        @procCallEffectiveParameterListIR effectiveParameterListIR)

  case booleanGuard (@instructionListIR instructionGenerationList @operandIR result)

  case boolAndSync (@instructionListIR boolExpInstructionGenerationList
                    @operandIR boolExpResult
                    @string guardMangledName
                    @string globalVarName # "" if not global var
                    @instructionListIR guardInstructionGenerationList
                    @procCallEffectiveParameterListIR effectiveParameterListIR)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @onInstructionBranchListIR {
  @guardedCommandIR mGuardedCommand
  @instructionListIR mInstructionGenerationList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @onInstructionIR : @abstractInstructionIR {
  @location mSelectInstructionLocation
  @onInstructionBranchListIR mOnInstructionBranchListIR
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioGenerationAdds.mUsesGuards = true
  let startLabel = "select." + ioGenerationAdds.mUniqueIndex
  ioGenerationAdds.mUniqueIndex ++
#---
  ioLLVMcode += "  br label %" + startLabel + ".start\n\n"
  let startLabelName = startLabel + ".start" 
  ioLLVMcode += startLabelName + ":\n"
  let exitLabelName = startLabel + ".exit"
  let selectLabelName = startLabel + ".select"
  let errorLabelName = startLabel + ".error"
  var currentStartBranchLabel = startLabelName
  for branch in mOnInstructionBranchListIR do (idx)
    let acceptanceVarName = "%" + startLabel + ".accept." + idx 
    switch branch.mGuardedCommand
    case synchronization (guardMangledName * guardInstructionGenerationList effectiveParameterListIR) :
      [guardInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
      ioLLVMcode += "  " + acceptanceVarName + " = call i1 @" + llvmNameForGuardCall (!guardMangledName)
      ioLLVMcode += " ("
      for () in effectiveParameterListIR do
        switch mEffectiveParameterPassingMode
        case input:
          ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
        case output:
          ioLLVMcode += [mParameter.mType llvmTypeName] + " " + [mParameter.mValue llvmName]
        case outputInput:
          ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
        end
      between
        ioLLVMcode += ", "
      end
      ioLLVMcode += ")\n"
    case booleanGuard (instructionGenerationList @operandIR result) :
      [instructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
      let acceptedLabelName = startLabel + "." + idx + ".true"
      let rejectedLabelName = startLabel + "." + idx + ".false"
      ioLLVMcode += "  br i1 " + [result.mValue llvmName] + ", label %" + acceptedLabelName + ", label %" + rejectedLabelName + "\n\n"
      ioLLVMcode += acceptedLabelName + ":\n"
      ioLLVMcode += "  call void @noteGuardHasBeenAccepted ()\n"
      ioLLVMcode += "  br label %" + rejectedLabelName + "\n\n"
      ioLLVMcode += rejectedLabelName + ":\n"
      ioLLVMcode += "  " + acceptanceVarName + " = or i1 " + [result.mValue llvmName] + ", 0 ; assignment\n"
    case boolAndSync (ExpInstructionList expResult guardMangledName * guardInstructionList effectiveParameterList) :
      [ExpInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
      let testOkLabelName = startLabel + "." + idx + ".boolexp.true"
      let testExitLabelName = startLabel + "." + idx + ".test.exit"
      ioLLVMcode += "  br i1 " + [expResult.mValue llvmName] + ", label %" + testOkLabelName + ", label %" + testExitLabelName + "\n\n"
      ioLLVMcode += testOkLabelName + ":\n"
      [guardInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
      let guardAcceptationLabelName = startLabel + "." + idx + ".guard.acceptation"
      ioLLVMcode += "  %" + guardAcceptationLabelName + " = call i1 @" + llvmNameForGuardCall (!guardMangledName)
      ioLLVMcode += " ("
      for () in effectiveParameterList do
        switch mEffectiveParameterPassingMode
        case input:
          ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
        case output:
          ioLLVMcode += [mParameter.mType llvmTypeName] + " " + [mParameter.mValue llvmName]
        case outputInput:
          ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
        end
      between
        ioLLVMcode += ", "
      end
      ioLLVMcode += ")\n"
      ioLLVMcode += "  br label %" + testExitLabelName + "\n\n"
      ioLLVMcode += testExitLabelName + ":\n"
      ioLLVMcode += "  " + acceptanceVarName + " = phi i1 "
      ioLLVMcode += "[%" + guardAcceptationLabelName + ", %" + testOkLabelName + "], "
      ioLLVMcode += "[false, %" + currentStartBranchLabel + "]\n"
    end
    let acceptedLabelName = startLabel + ".accepted." + idx
    let rejectedLabelName = startLabel + ".rejected." + idx
    ioLLVMcode += "  br i1 " + acceptanceVarName + ", label %" + acceptedLabelName + ", label %" + rejectedLabelName + "\n\n"
    ioLLVMcode += acceptedLabelName + ":\n"
    [branch.mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  br label %" + exitLabelName + "\n\n"
    ioLLVMcode += rejectedLabelName + ":\n"
    currentStartBranchLabel = rejectedLabelName
  end
  ioLLVMcode += "  %" + selectLabelName + " = call i1 @" + llvmNameForServiceCall (!waitForGuardChangeFunctionName ()) + " ()\n"
  ioLLVMcode += "  br i1 %" + selectLabelName + ", label %" + startLabelName + ", label %" + errorLabelName + "\n\n"
  ioLLVMcode += errorLabelName + ":\n" # Error, all guards are closed
  if [option plm_options.noPanicGeneration value] then
    ioLLVMcode += "  br label %" + exitLabelName + "\n\n" # No panic generation, pass instruction
  else
    let panicCode = 255  # Panic generation, raise panic 255
    [!?ioGenerationAdds.mStaticStringMap findOrAddStaticString
      ![[[mSelectInstructionLocation file] lastPathComponent] stringByDeletingPathExtension]
      ?let staticStringIndex
    ]
    ioLLVMcode += "  call void @raise_panic." + staticStringIndex + " ("
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " " + [mSelectInstructionLocation line] + ", "
    ioLLVMcode += inGenerationContext.mPanicCodeLLVMType + " " + panicCode + ")\n"
    ioLLVMcode += "  unreachable\n\n"
  end
  ioLLVMcode += exitLabelName + ":\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onInstructionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  let branchCount = [mOnInstructionBranchListIR length]
  if ioMaxBranchOfOnInstructions < branchCount then
    ioMaxBranchOfOnInstructions = branchCount
  end
  for branch in mOnInstructionBranchListIR do
    [branch.mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
    switch branch.mGuardedCommand
    case synchronization (guardMangledName optionalReceiverName guardInstructionGenerationList *) :
      [guardInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
      ioAccessibleEntities.mGuardSet += !guardMangledName
      if optionalReceiverName != "" then
        ioAccessibleEntities.mGlobalVariableSet += !optionalReceiverName
      end
    case booleanGuard (instructionGenerationList *) :
      [instructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
    case boolAndSync (instructionGenerationList * guardMangledName optionalReceiverName guardInstructionGenerationList *) :
      [instructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
      [guardInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
      ioAccessibleEntities.mGuardSet += !guardMangledName
      if optionalReceiverName != "" then
        ioAccessibleEntities.mGlobalVariableSet += !optionalReceiverName
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
