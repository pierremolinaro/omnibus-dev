#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @integerSliceFieldListAST {
  @lstring mSliceWidth
  @expressionAST mExpression
  @location mExpressionLocation
}

#·······················································································································

class @integerSliceExpressionAST : @expressionAST {
  @lstring mTypeName
  @integerSliceFieldListAST mSliceValues
  @location mLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <primary> ?!@ast ioAST !@expressionAST outExpression {
    ${$
    $\$type$ ?let typeName
    @integerSliceFieldListAST integerFieldValues = {}
    repeat
      $!selector:$ ?let sliceWidth
      <expression> !?ioAST ?let expression
      integerFieldValues += !sliceWidth !expression !.here
      ioAST.mSliceSelectorSet += !sliceWidth.string
    while
    end
    if [integerFieldValues length] < 2 then
      error .here : "this expression should contain two bit slices or more" : outExpression
    else
      outExpression = @integerSliceExpressionAST.new {!typeName !integerFieldValues !.here}
    end
    $}$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerSliceExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (sliceWidthStr expression expressionLocation) in mSliceValues do
    [expression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerSliceExpressionAST noteExpressionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph noteNode !mTypeName]
  for (sliceWidthStr expression expressionLocation) in mSliceValues do
    [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @integerSliceExpressionAST analyzeExpression
  ?self:let @omnibusType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?optionalTargetType:let @omnibusType unused inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Search Type
  let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mTypeName} type]
#--- Check type is an unsigned integer type
  if not [resultType.kind isInteger] then
    error mTypeName: "this type should be an unsigned integer type" :outResult
  else
    [resultType.kind integer ?2* ?unsigned:let unsigned ?bitCount:let bitCount]
    if not unsigned then
      error mTypeName: "this type should be an unsigned integer type" :outResult
    else
    #------------------------------------------------------ Valuated fields
      var leftShiftAmount = bitCount
      @bigint accumulatedFieldStaticValues = 0G
      @operandIRList operandList = {}
      for (sliceWidthStr expression expressionLocation) in mSliceValues do
        [inContext.mSliceTypeMap searchKey !sliceWidthStr ?let targetType ?let sliceWidth]
        if leftShiftAmount >= sliceWidth then
          leftShiftAmount = leftShiftAmount - sliceWidth
        else
          let specifiedBitCount = bitCount + sliceWidth - leftShiftAmount
          error sliceWidthStr : "bit slice overflow: " + specifiedBitCount + " bits, should be " + bitCount
          leftShiftAmount = 0
        end
      #--- Analyze expression
        [expression analyzeExpression
          !self:inSelfType
          !routineAttributes: inRoutineAttributes
          !optionalTargetType: targetType
          !context:inContext
          !mode:inMode
          !?temporary:ioTemporaries
          !?staticEntityMap:ioStaticEntityMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !?instructionListIR:ioInstructionGenerationList
          ?result:@objectIR expressionResult
        ]
        [!?ioTemporaries newTempLLVMVar ?let targetReference_llvmName]
        ioAllocaList += !targetReference_llvmName !targetType !false
      #--- Source 
        [!?ioInstructionGenerationList appendAssignmentIR
          !?ioTemporaries
          !inContext.mAssignmentOperatorMap
          !?ioAllocaList
          !targetType
          !targetReference_llvmName
          !expressionResult
          !sliceWidthStr.location
        ]
        var resultRef = @objectIR.reference {!type: targetType !llvmName: targetReference_llvmName}
        [!?ioInstructionGenerationList appendLoadWhenReference !?ioTemporaries !?resultRef]
      #--- Perform an bit extend to result type
        getNewTempValue (!resultType !?ioTemporaries ?let extendedResult)
        [!?ioInstructionGenerationList appendExtend !extendedResult !resultRef]
      #--- Perform left shift
        getNewTempValue (!resultType !?ioTemporaries ?let shiftedResult)
        [!?ioInstructionGenerationList appendShiftLeft !shiftedResult !extendedResult !leftShiftAmount]
      #---- Accumulate 
        operandList += !shiftedResult
      end
      if leftShiftAmount != 0 then
        error mLocation : [bitCount string] + " bits required, " + (bitCount - leftShiftAmount) + " bits defined"
      end
    #------------------------------------------------------ Result
      outResult = .literalInteger {!type: resultType !value: accumulatedFieldStaticValues}
      for (operand) in operandList do
        getNewTempValue (!resultType !?ioTemporaries ?let newResult)
        [!?ioInstructionGenerationList appendBinaryOperation
          !newResult
          ![newResult type]
          !.here
          !outResult
          !.ior
          !operand
        ] 
        outResult = newResult
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
