#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedRoutine : @abstractDecoratedDeclaration {
  @lstring mReceiverTypeName # Empty string if standalone function
  @mode mMode
  @routineKind mRoutineKind
  @bool mWarnIfUnused
  @bool mExportedRoutine
  @routineAttributes mRoutineAttributes
  @lstring mRoutineName
  @routineFormalArgumentListAST mRoutineFormalArgumentList
  @instructionListAST mRoutineInstructionList
  @location mEndOfRoutineDeclaration
  @lstring mReturnTypeName  # Empty string if no returned value
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @decoratedRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Reset temporaries index
  ioTemporaries.mTemporaryIndex = 0
#--- Receiver type
  let receiverType = if mReceiverTypeName.string == ""
    then voidType ()
    else [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mReceiverTypeName} type]
    end
#--- Mangled routine name
  let routineMangledName = routineMangledNameFromAST (
    !if receiverType.kind == .void then "" else receiverType.llvmBaseTypeName end
    !mRoutineName
    !mRoutineFormalArgumentList
  )
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
#--- Return value ?
  if mReturnTypeName.string != "" then
    let resultVarName = @lstring.new {!functionResultVariableName () !mReturnTypeName.location}
    let resultType = [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mReturnTypeName} type]
    [!?universalMap insertLocalVariable !resultVarName !resultType !resultVarName !.noValue !true]
  end
#--- Analyse formal arguments
  @routineFormalArgumentListIR formalArguments = {}
  enterFormalArguments (
    !context:inContext
    !mRoutineFormalArgumentList
    !?universalMap
    !?formalArguments
  )
#--- Enter subprogram invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addNode !routineMangledName !routineMangledName]
#--- Analyze instruction list
  @allocaList allocaList = {}
  @instructionListIR instructionGenerationList = {}
  [mRoutineInstructionList analyzeRoutineInstructionList
    !self:receiverType
    !routineAttributes:mRoutineAttributes
    !routineNameForInvocationGraph:routineMangledName
    !context:inContext
    !mode:mMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioIntermediateCodeStruct.mStaticEntityMap
    !?variableMap:universalMap
    !?alloca:allocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState !?instructionGenerationList]
  [!?universalMap closeBranch !mEndOfRoutineDeclaration]
  [!?universalMap closeOverride !mEndOfRoutineDeclaration]
#--- Code generation
  let returnType = if mReturnTypeName.string == "" then
    voidType ()
  else
    [@unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mReturnTypeName} type]
  end
  [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey
    !routineMangledName
    !receiverType
    !routineMangledName
    !formalArguments
    !allocaList
    !instructionGenerationList
    ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
    !mWarnIfUnused
    !mExportedRoutine
    !mRoutineKind
    !returnType
    !false
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
