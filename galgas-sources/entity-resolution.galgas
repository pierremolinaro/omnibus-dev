#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S O L V E   E N T I T I E S
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc solveEntities
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
{
#--------------------------------------------- Build register map
#  @registerMapSE registerMapSE = {}
#  for registerDeclaration in inAST.mControlRegisterDeclarationListAST do
#    for register in registerDeclaration.mRegisterNameList do
#      [!?registerMapSE insertKey !register.mRegisterName ! [register.mControlRegisterKind isRegisterArray]]
#    end
#  end
#--------------------------------------------- Build global variable map
#  @globalVariableMap globalVariableMapSE = {}
#  for globalVar in inAST.mGlobalVarDeclarationListAST do
#    [!?globalVariableMapSE insertKey !globalVar.mVarName]
#    if [inSemanticContext.mControlRegisterMap hasKey !globalVar.mVarName.string] then
#      error globalVar.mVarName : "name collision with a control register"
#    end
#  end
#---------------------------------------------
  [inAST.mStandAloneFunctionDeclarationListAST solveEntities
    !globalConstants:inSemanticContext.mGlobalConstantMap
    !registers:inSemanticContext.mControlRegisterMap
    !globalVars:inSemanticContext.mGlobalVariableMap
  ]
#  @semanticTemporariesStruct temporaries = .default
#  for (declaration) in inAST.mDeclarationListAST do
#    [declaration semanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#     ]
#  end
#  [inAST.mProcedureListAST resolveEntitiesInProcedures
#    !receiverType:.null
#    !context:inSemanticContext
#  ]
#  [inAST.mTaskListAST semanticAnalysis
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mStandAloneSystemRoutineListAST systemRoutineSemanticAnalysis
#    !receiverType:.null
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mGuardListAST guardSemanticAnalysis
#    !receiverType:.null
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mExternProcListAST externProcedureSemanticAnalysis
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mISRDeclarationListAST isrSemanticAnalysis
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  for boot in inAST.mBootListAST do
#    [boot bootSemanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#    ]
#  end
#  for init in inAST.mInitListAST do
#    [init initSemanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#    ]
#  end
##--- Generate panic clauses
#  for panic in inAST.mPanicClauseListAST do
#    [panic panicSemanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#    ]
#  end
##--- Check required procedure are defined
#  checkRequiredProcedures (
#    !ast:inAST
#    !context:inSemanticContext
#    !endOfSourceFile:inEndOfSourceFile
#  )
##--- Print procedure invocation graph
#  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
#    let s = [temporaries.mSubprogramInvocationGraph graphviz]
#    let filePath = [inSourceFile stringByDeletingPathExtension] + ".routineInvocation.dot"
#    [s writeToFileWhenDifferentContents !filePath ?*]
#  end
##--- Check procedure invocation graph
#  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
#    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
#    if [undefinedNodeKeyList length] > 0 then
#        var s = "subprogram invocation graph error, undefined nodes:"
#        for (str) in undefinedNodeKeyList do
#          s += "\n - " + str
#        end
#        error inEndOfSourceFile : s
#    else
#      [temporaries.mSubprogramInvocationGraph circularities
#         ?let @lstringlist unused unsortedInformationList
#         ?let @lstringlist unsortedLKeyList
#      ]
#      if [unsortedLKeyList length] > 0 then
#        var s = "the following routines are recursive:"
#        for (str) in unsortedLKeyList do
#          s += "\n - " + str
#        end
#        error inEndOfSourceFile : s
#      end
#    end
#  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
