#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#proc resolveEntities
#  ?ast:let @ast inAST
#  ?context:let @semanticContext inSemanticContext
#{
#  outIntermediateCodeStruct = .default
#  outIntermediateCodeStruct.mTargetParameters = inSemanticContext.mTargetParameters
#  outIntermediateCodeStruct.mStaticStringMap = inGlobalLiteralStringMap
#  outIntermediateCodeStruct.mGlobalTaskVariableList = inSemanticContext.mGlobalTaskVariableList
#  for requiredProc in inAST.mRequiredProcListAST do
#    let requiredProcedureMangledName = routineMangledNameFromAST (!"" !requiredProc.mName !requiredProc.mFormalArgumentList)
#    outIntermediateCodeStruct.mRequiredProcedureSet += !requiredProcedureMangledName.string
#  end 
##--- Global variables
#  for globalVar in inAST.mGlobalVarDeclarationListAST do
#    [globalVar semanticAnalysis
#      !context:inSemanticContext
#      !?intermediateCode:outIntermediateCodeStruct
#     ]
#  end
##---
#  @semanticTemporariesStruct temporaries = .default
#  for (declaration) in inAST.mDeclarationListAST do
#    [declaration semanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#     ]
#  end
#  [inAST.mProcedureListAST resolveEntitiesInProcedures
#    !receiverType:.null
#    !context:inSemanticContext
#  ]
#  [inAST.mTaskListAST semanticAnalysis
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mStandAloneSystemRoutineListAST systemRoutineSemanticAnalysis
#    !receiverType:.null
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mGuardListAST guardSemanticAnalysis
#    !receiverType:.null
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mExternProcListAST externProcedureSemanticAnalysis
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  [inAST.mISRDeclarationListAST isrSemanticAnalysis
#    !context:inSemanticContext
#    !?temporary:temporaries
#    !?intermediateCode:outIntermediateCodeStruct
#  ]
#  for boot in inAST.mBootListAST do
#    [boot bootSemanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#    ]
#  end
#  for init in inAST.mInitListAST do
#    [init initSemanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#    ]
#  end
##--- Generate panic clauses
#  for panic in inAST.mPanicClauseListAST do
#    [panic panicSemanticAnalysis
#      !context:inSemanticContext
#      !?temporary:temporaries
#      !?intermediateCode:outIntermediateCodeStruct
#    ]
#  end
##--- Check required procedure are defined
#  checkRequiredProcedures (
#    !ast:inAST
#    !context:inSemanticContext
#    !endOfSourceFile:inEndOfSourceFile
#  )
##--- Print procedure invocation graph
#  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
#    let s = [temporaries.mSubprogramInvocationGraph graphviz]
#    let filePath = [inSourceFile stringByDeletingPathExtension] + ".routineInvocation.dot"
#    [s writeToFileWhenDifferentContents !filePath ?*]
#  end
##--- Check procedure invocation graph
#  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
#    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
#    if [undefinedNodeKeyList length] > 0 then
#        var s = "subprogram invocation graph error, undefined nodes:"
#        for (str) in undefinedNodeKeyList do
#          s += "\n - " + str
#        end
#        error inEndOfSourceFile : s
#    else
#      [temporaries.mSubprogramInvocationGraph circularities
#         ?let @lstringlist unused unsortedInformationList
#         ?let @lstringlist unsortedLKeyList
#      ]
#      if [unsortedLKeyList length] > 0 then
#        var s = "the following routines are recursive:"
#        for (str) in unsortedLKeyList do
#          s += "\n - " + str
#        end
#        error inEndOfSourceFile : s
#      end
#    end
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
