#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @selfMutatingMethodCallInstructionAST : @instructionAST {
  @lstring mMethodName
  @procEffectiveParameterListAST mEffectiveParameterList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $[$
    $!?$ ? let selector
    if selector.string != "" then
      error selector : "the selector should be '!?'"
    end
    $self$
    $identifier$ ?let methodName
    @procEffectiveParameterListAST effectiveParameterList = {}
    repeat
    while
      $!$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.output{!name:effectiveParameterName} !selector
    while
      $!?$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.outputInput{!name:effectiveParameterName} !selector
    while
      $?$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.input{!name:effectiveParameterName} !selector
    end
    $]$
    ioInstructionList += !@selfMutatingMethodCallInstructionAST.new {
      !methodName
      !effectiveParameterList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @selfMutatingMethodCallInstructionAST analyze
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext unused inContext
  ?mode:let @string inMode
  ?!temporary:@uint unused ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
{
#--- Analyze self as receiver variable
  @unifiedTypeMap-proxy receiverType
  @string targetVar
  switch inReceiverType
  case noReceiver :
    error mMethodName : "'self' cannot be used outside a method" : receiverType, targetVar
  case receiver (type receiverValue) :
    receiverType = type
    targetVar = receiverValue
  case mutatingReceiver (type receiverPointer) :
    receiverType = type
    targetVar = receiverPointer
  end
#--- Check parameters
  @procEffectiveParameterList parameterList = {}
  @string procMangledName = mMethodName.string
  for () in mEffectiveParameterList do
    procMangledName += " "
    switch mEffectiveParameterKind 
    case input (@lstring name) :
      procMangledName += "!" ;
      [!?ioVariableMap searchForWriteAccess
        !name
        ?let type
        ?let acceptedModeSet
        ?let @string valueAccess
        ?let unused variableKind
        ?let isCopiable
      ]
    #--- Check mode
      if not [acceptedModeSet hasKey !inMode] then
        error name : "this variable cannot be used in `" + inMode + " mode"
      end
      if not isCopiable then
        error name : "the '" + name + "' variable is not copiable"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type !"& (" + valueAccess + ")"
    case output (@lstring name) :
      procMangledName += "?" ;
      [!?ioVariableMap searchForReadAccess
        !name
        ?let type
        ?let acceptedModeSet
        ?let valueAccess
        ?let unused variableKind
        ?*
      ]
    #--- Check mode
      if not [acceptedModeSet hasKey !inMode] then
        error name : "this variable cannot be used in " + inMode + " mode"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type !valueAccess
    case outputInput (@lstring name) :
      procMangledName += "?!" ;
      [!?ioVariableMap searchForReadWriteAccess
        !name
        ?let type
        ?let acceptedModeSet
        ?let valueAccess
        ?let unused variableKind
        ?*
      ]
    #--- Check mode
      if not [acceptedModeSet hasKey !inMode] then
        error name : "this variable cannot be used in `" + inMode + " mode"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type !"& (" + valueAccess + ")"
    end
    procMangledName += mSelector.string
  end
#--- Search proc in proc map
  let receiverTypeProcedureMap = [receiverType procedureMap]
  [receiverTypeProcedureMap searchKey
    !.new {!procMangledName !mMethodName.location}
    ?let calledProcIsMutating
    ?let procedureMode
    ?let @procedureSignature calledProcSignature
  ]
#--- Check mode
  if procedureMode.string != inMode then
    error mMethodName : "this variable cannot be used in `" + inMode + " mode"
  end
#--- called method is not a mutating method
  switch inReceiverType
  case noReceiver :
    if calledProcIsMutating then
      error mMethodName : "a mutating method cannot be called from a non mutating procedure"
    end
  case receiver (* *) :
    if calledProcIsMutating then
      error mMethodName : "a mutating method cannot be called from a non mutating method"
    end
  case mutatingReceiver (* *) :
  end
#--- Check parameter list
  if [calledProcSignature length] != [parameterList length] then
    error mMethodName: "this proc requires " + [calledProcSignature length] + " argument(s), this call names "
      + [parameterList length] + " argument(s)"
  else
    for () formal_ in calledProcSignature, () actual_ in parameterList do
      if [formal_mType key] != [actual_mParameterType key] then
        error actual_mSelector : "the actual parameter type is '" + [actual_mParameterType key] +
           "', and is incompatible with the formal type '" + [formal_mType key] + "'"
      end
      let requiredPassingMode = [formal_mFormalArgumentPassingMode requiredActualPassingModeForSelector !formal_mSelector]
      let testedPassingMode = [actual_mEffectiveParameterPassingMode passingModeForActualSelector !actual_mSelector]
      if requiredPassingMode != testedPassingMode then
        error actual_mSelector : "the required selector is '" + requiredPassingMode + "'"
      end
    end  
  end
#--- Code generation
#  if calledProcIsMutating then
#    [!?parameterList insertAtIndex
#      !.outputInput
#      !["" nowhere]
#      !receiverType
#      !targetVar
#      !0
#    ]
#  else
#    [!?parameterList insertAtIndex
#      !.output
#      !["" nowhere]
#      !receiverType
#      !"* " + targetVar
#      !0
#    ]
#  end
  error mMethodName : "internal error: no code generation"
#  ioInstructionGenerationList += !@procCallInstructionGeneration.new {
#    ![receiverType key] + "_" + procMangledName
#    !parameterList
#  }
}

#----------------------------------------------------------------------------------------------------------------------*
