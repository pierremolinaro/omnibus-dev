#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @sectionDeclarationListAST {
  @lstring mSectionName
  @lstringlist mSectionAttributeList
  @procFormalArgumentList mSectionFormalArgumentList
  @instructionListAST mSectionInstructionList
  @location mEndOfSectionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <section> ?!@sectionDeclarationListAST ioSectionListAST {
    $section$
    $identifier$ ?let sectionName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:let sectionFormalArgumentList
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioSectionListAST +=
      !sectionName
      !attributeList
      !sectionFormalArgumentList
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @sectionMap {
  @bool mMutating
  @procedureSignature mSignature

  insert insertKey error message "the '%K' section is already declared in %L"
  search searchKey error message "there is no '%K' section"
  remove removeKey error message "there is no '%K' section"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @sectionDeclarationListAST sectionSemanticAnalysis
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for section in self do
    routineSemanticAnalysis (
      !receiverType:.null
      !.section
      !{!.new {!sectionModeName () !section.mSectionName.location}}
      !section.mSectionName
      !section.mSectionFormalArgumentList
      !section.mSectionInstructionList
      !section.mEndOfSectionLocation
      !warnIfUnused:true
      !globalProcedure:true
      !weakProcedure:false
      !nullOnNoException:false
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR sectionCodeGeneration
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
{
#--- Generation section handler ?
  if [self count] > 0 then
    var idx = 0
    for section in self do
      if section.mKind == .section then
        let sectionCallName = llvmNameForSectionCall (!section.lkey.string)
        var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/section-entry.s")
        s = [s stringByReplacingStringByString !"!ENTRY!" !sectionCallName]
        s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
        ioAssemblerCode += s
        idx += 1
        ioLLVMcode += llvmTitleComment (!sectionCallName)
        ioLLVMcode += "declare void @" + sectionCallName + " ("
        for () in section.mFormalArgumentListForGeneration
        do
          switch mFormalArgumentKind
          case input :
            ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
          case output :
            ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
         case inputOutput :
            ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
          end
        between
          ioLLVMcode += ", "
        end
        ioLLVMcode += ") nounwind \n\n"
      end
    end
    ioAssemblerCode += getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/section-dispatcher-header.s")
    idx = 0
    for section in self do
      if section.mKind == .section then
        let sectionImplementationName = llvmNameForSectionImplementation (!section.lkey.string)
        var s = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/section-dispatcher-entry.s")
        s = [s stringByReplacingStringByString !"!ENTRY!" !sectionImplementationName]
        s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
        ioAssemblerCode += s
        idx += 1
      end
    end
    let sectionAssemblyCode = getTargetTextFile (!currentDir:inCurrentDirectory !from:inTargetName + "/section-code.s")
    ioAssemblerCode += [sectionAssemblyCode stringByReplacingStringByString !"!PROC!" !llvmNameForProcedure (!".")]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

