#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @accessInAssignmentAST {
  case register (@lstring name)
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
}

#·······················································································································

list @accessInAssignmentListAST {
  @accessInAssignmentAST mAccess
}

#·······················································································································

enum @LValueKindAST {
  case regular (@accessInAssignmentListAST accessList)
  case register (@lstring registerName  @registerIndexAST index)
}

#·······················································································································

struct @LValueAST {
  @lstring mIdentifier
  @LValueKindAST mKind
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <lvalue> ?!@ast ioAST !@LValueAST outAssignmentTargetAST {
    $identifier$ ?let registerGroupName
    $:$
    $identifier$ ?let registerName
    @registerIndexAST registerIndexAST 
    select
      registerIndexAST = .noIndex
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      registerIndexAST = .index {!index:expression !endOfIndex:endOfIndex}
#      accessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = .new {!registerGroupName !.register {!registerName:registerName !index:registerIndexAST}}
  }

  #·····················································································································

  rule <lvalue> ?!@ast ioAST !@LValueAST outAssignmentTargetAST {
    @lstring receiver
  #--- Receiver
    select
      $identifier$ ?receiver
    or
      $self$
      receiver = ["" here]
    end
  #--- Properties and subscript
    @accessInAssignmentListAST accessList = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessList += !.property {!name:propertyName}
    while
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      accessList += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = .new {!receiver !.regular {!accessList:accessList}}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @LValueAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  switch mKind
  case regular (@accessInAssignmentListAST accessList) :
    for (access) in accessList do
      switch access
      case register (*) :
      case property (*) :
      case arrayAccess (@expressionAST indexExpression *) :
        [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
      end
    end
  case register (* index) :
    switch index
    case noIndex :
    case index (indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @LValueRepresentation {
  case volatileAbsoluteReference (@PLMType type @uint address)
  case volatileIndirectReference (@PLMType type @string llvmName)
  case universalReference (@PLMType type @string llvmName)
}

#·······················································································································

getter @LValueRepresentation type -> @PLMType {
  switch self
  case volatileAbsoluteReference (@PLMType type *) :
    result = type
  case volatileIndirectReference (@PLMType type *) :
    result = type
  case universalReference (@PLMType type *) :
    result = type
  end
}

#·······················································································································

method @LValueAST analyzeLValue
  ?self:let @PLMType inSelfType
  ?readAccess:let @bool inIsReadAccess # If false, write access
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@LValueRepresentation outInternalRepresentation
{
  if mIdentifier.string == "" then # Receiver is "self"
    if inSelfType.kind == .void then
      error mIdentifier : "self is not available in this context" : outInternalRepresentation
    elsif not [inRoutineAttributes mutating] && not inIsReadAccess then
      error mIdentifier
      : "cannot mutate properties, current method is not declared with @" + mutatingAttribute () + " attribute"
      : outInternalRepresentation
    else
      analyzeSelfAssignmentTarget (
        !self:inSelfType
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !mIdentifier.location
        !mKind
        ?outInternalRepresentation
      )
    end
  else
    [ioUniversalMap searchEntity !mIdentifier ?let @valuedObject entity]
    switch entity
    case task (*) :
      error mIdentifier : "a task has no value" : outInternalRepresentation
    case driver (* *) :
      error mIdentifier : "a driver has no value" : outInternalRepresentation
    case registerGroup (registerMap) :
      analyzeControlRegisterInLValue (
        !self: inSelfType
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !registerGroupName: mIdentifier
        !registerMap: registerMap
        !mKind
        ?outInternalRepresentation
      )
    case globalConstant (*) :
      error mIdentifier : "a global constant cannot be written" : outInternalRepresentation
    case localConstant (3*) :
      error mIdentifier : "a local constant cannot be written" : outInternalRepresentation
    case globalSyncInstance (2*) :
      error mIdentifier : "a global sync instance is not allowed here" : outInternalRepresentation
    case localVariable (@PLMType variableType @lstring plmName) :
      analyzeVariableInLValue (
        !self: inSelfType
        !readAccess:inIsReadAccess
        !routineAttributes:inRoutineAttributes
        !routineNameForInvocationGraph: inCallerNameForInvocationGraph
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !?instructionListIR: ioInstructionGenerationList
        !variableName: mIdentifier
        !llvmName:llvmNameForLocalVariable (!plmName)
        !type: variableType
        !mKind
        ?outInternalRepresentation
      )
    end
  end
}

#·······················································································································

private proc analyzeControlRegisterInLValue
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?registerGroupName:let @lstring inRegisterGroupName
  ?registerMap:let @controlRegisterMap inControlRegisterMap
  ?let @LValueKindAST inKind
  !@LValueRepresentation outInternalRepresentation
{
  if not [inKind isRegister] then # No subscript, no slice
    error inRegisterGroupName : "the \":\" access is reserved for control register" : outInternalRepresentation
  else
    [inKind register ?registerName:let registerName ?index:let registerIndex]
    [inControlRegisterMap searchKey
      !registerName
      ?let @PLMType inRegisterType
      ?let @bool readOnly
      ?let @bool userAccess
      ?let @sliceMap unused inRegisterSliceMap
      ?let @controlRegisterFieldMap unused mRegisterFieldMap
      ?let @controlRegisterGroupKind controlRegisterGroupKind
      ?let @controlRegisterFieldList unused mControlRegisterFieldList # Used for HTML file
      ?let @uint unused mRegisterBitCount
      ?let @uint inRegisterArraySize # 0 if not an array
      ?let @uint inRegisterElementSize # 0 if not an array
    ]
    switch controlRegisterGroupKind
    case single (registerAddress) :
      if readOnly then
        error registerName
          : "this control register cannot be modified (declared with @ro attribute)" : outInternalRepresentation
      elsif not userAccess && ([inMode isUserMode] || [inMode isAnyMode]) then
        error registerName : "this control register is not accessible in user mode" : outInternalRepresentation
      elsif [registerIndex isNoIndex] then # Simple access to a control register for writing
        if inRegisterArraySize == 0 then
          outInternalRepresentation = .volatileAbsoluteReference {!type:inRegisterType !address:registerAddress}
        else
          error registerName : "the control register is an array" : outInternalRepresentation
        end
      else # Simple access to a control register for writing
        [registerIndex index ?index:let indexExpression ?endOfIndex:let endOfIndex]
        handleArraySubscriptNew (
          !self: inSelfType
          !routineAttributes:inRoutineAttributes
          !routineNameForInvocationGraph: inCallerNameForInvocationGraph
          !context: inContext
          !mode: inMode
          !?temporary: ioTemporaries
          !?staticEntityMap:ioStaticEntityMap
          !?variableMap: ioUniversalMap
          !?alloca: ioAllocaList
          !indexExpression 
          !endOfIndex
          !arraySize:inRegisterArraySize
          !elementType:inRegisterType
          !?ioInstructionGenerationList
          ?let @objectIR indexIR
        )
        if [indexIR isLiteralInteger] then # subscript expression is constant
           [indexIR literalInteger ?1* ?value:let @bigint idx]
           let addr = registerAddress + idx * inRegisterElementSize
           outInternalRepresentation = .volatileAbsoluteReference {!type:inRegisterType !address:addr}      
        else
          [!?ioTemporaries newTempLLVMVar ?let llvmName]
          [!?ioInstructionGenerationList appendComputeSubscriptedVolatileRegisterAddress
            !llvmName
            !indexIR
            !registerAddress
            !inRegisterElementSize
          ]
          outInternalRepresentation = .volatileIndirectReference {!type:inRegisterType !llvmName:llvmName}      
        end
      end
    end
  end
}

#·······················································································································

private proc analyzeVariableInLValue
  ?self:let @PLMType inSelfType
  ?readAccess:let @bool inIsReadAccess # If false, write access
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?variableName:let @lstring inVariableName
  ?llvmName:let @string inLLVMName
  ?type:let @PLMType inVariableType
  ?let @LValueKindAST inKind
  !@LValueRepresentation outInternalRepresentation
{
  if not [inKind isRegular] then
    error inVariableName : "the \":\" access is reserved for control register" : outInternalRepresentation
  else
    [inKind regular ?accessList:let accessList]
    var currentType = inVariableType
    var currentLLVMName = inLLVMName
    if [accessList length] == 0 then
      if inIsReadAccess then
        [!?ioUniversalMap searchValuedObjectForReadAccess !inVariableName ?*]
      else
        [!?ioUniversalMap searchValuedObjectForWriteAccess !inVariableName ?*]
      end
    else
      if inIsReadAccess then
        [!?ioUniversalMap searchValuedObjectForReadAccess !inVariableName ?*]
      else
        [!?ioUniversalMap searchValuedObjectForReadWriteAccess !inVariableName ?*]
      end
      for (access) in accessList do
        switch access
        case register (@lstring registerName) :
          error registerName : "invalid register access, receiver is not a register group"
        case property (@lstring propertyName) :
          let @propertyMap propertyMap = currentType.propertyMap
          [propertyMap searchKey !propertyName ?* ?let @propertyAccessKind propertyAccess]
          switch propertyAccess
          case nonVirtualMethod (*) :
             error propertyName : "a method cannot be written" : currentType, currentLLVMName
          case singleton  (@objectIR object *) :
            currentType = [object type]
            currentLLVMName = [object llvmName]
          case constantProperty (*) :
            error propertyName : "a constant property cannot be written" : currentType, currentLLVMName
          case indexed (@PLMType propertyType @uint index) :
            [!?ioTemporaries newTempLLVMVar ?let newLLVMvariable]
            [!?ioInstructionGenerationList appendGetUniversalPropertyReference
              !currentType
              !currentLLVMName
              !newLLVMvariable
              !index
              !propertyName
            ]
            currentType = propertyType
            currentLLVMName = newLLVMvariable
          end
        case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
          if [currentType.kind isArrayType] then
            [currentType.kind arrayType ?elementType:let elementType ?size:let @bigint arraySize]
            handleArraySubscriptNew (
              !self: inSelfType
              !routineAttributes:inRoutineAttributes
              !routineNameForInvocationGraph: inCallerNameForInvocationGraph
              !context: inContext
              !mode: inMode
              !?temporary: ioTemporaries
              !?staticEntityMap:ioStaticEntityMap
              !?variableMap:ioUniversalMap
              !?alloca: ioAllocaList
              !indexExpression 
              !endOfIndex
              !arraySize:arraySize
              !elementType:elementType
              !?ioInstructionGenerationList
              ?let @objectIR indexIR
           )
           [!?ioTemporaries newTempLLVMVar ?let newLLVMvariable]
           [!?ioInstructionGenerationList appendGetUniversalArrayElementReference
             !currentType
             !currentLLVMName
             !elementType
             !newLLVMvariable
             !indexIR
           ]
           currentType = elementType
           currentLLVMName = newLLVMvariable
          else
            error endOfIndex : "cannot subscript, not an array" : currentType, currentLLVMName
          end
        end
      end
    end
    outInternalRepresentation = .universalReference {!type:currentType !llvmName:currentLLVMName}
  end
 }

#·······················································································································

private proc analyzeSelfAssignmentTarget
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?let @location inSelfLocation
  ?let @LValueKindAST inKind
  !@LValueRepresentation outInternalRepresentation
{
  if not ([inSelfType.kind isStructure] || [inSelfType.kind isSyncTool]) then
    error inSelfLocation : "'self' is not available in this context" : outInternalRepresentation
  elsif not [inKind isRegular] then
    error inSelfLocation : "'self' is not available in this context" : outInternalRepresentation
  else
    [inKind regular ?accessList:let accessList]
    var currentType = inSelfType
    var currentLLVMName = llvmNameForSelf ()
    for (access) in accessList do
      switch access
      case register (@lstring registerName) :
        error registerName : "invalid register access, receiver is not a register group"
      case property (@lstring propertyName) :
        let @propertyMap propertyMap = currentType.propertyMap
        [propertyMap searchKey !propertyName ?* ?let @propertyAccessKind propertyAccess]
        switch propertyAccess
        case nonVirtualMethod (*) :
           error propertyName : "a method cannot be written" : currentType, currentLLVMName
        case constantProperty (*) :
          error propertyName : "a constant property cannot be written" : currentType, currentLLVMName
        case singleton  (@objectIR object *) :
          currentType = [object type]
          currentLLVMName = [object llvmName]
        case indexed (@PLMType propertyType @uint index) :
          [!?ioTemporaries newTempLLVMVar ?let newLLVMvariable]
          [!?ioInstructionGenerationList appendGetUniversalPropertyReference
            !currentType
            !currentLLVMName
            !newLLVMvariable
            !index
            !propertyName
          ]
          currentType = propertyType
          currentLLVMName = newLLVMvariable
        end
      case arrayAccess (@expressionAST indexExpression @location endOfIndex) :
        if [currentType.kind isArrayType] then
          [currentType.kind arrayType ?elementType:let elementType ?size:let @bigint arraySize]
          handleArraySubscriptNew (
            !self: inSelfType
            !routineAttributes:inRoutineAttributes
            !routineNameForInvocationGraph: inCallerNameForInvocationGraph
            !context: inContext
            !mode: inMode
            !?temporary: ioTemporaries
            !?staticEntityMap:ioStaticEntityMap
            !?variableMap:ioUniversalMap
            !?alloca: ioAllocaList
            !indexExpression 
            !endOfIndex
            !arraySize:arraySize
            !elementType:elementType
            !?ioInstructionGenerationList
            ?let @objectIR indexIR
         )
         [!?ioTemporaries newTempLLVMVar ?let newLLVMvariable]
         [!?ioInstructionGenerationList appendGetUniversalArrayElementReference
           !currentType
           !currentLLVMName
           !elementType
           !newLLVMvariable
           !indexIR
         ]
         currentType = elementType
         currentLLVMName = newLLVMvariable
        else
          error endOfIndex : "cannot subscript, not an array" : currentType, currentLLVMName
        end
      end
    end
    outInternalRepresentation = .universalReference {!type:currentType !llvmName:currentLLVMName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
