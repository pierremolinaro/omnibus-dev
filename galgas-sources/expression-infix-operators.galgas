#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case andOp
  case andShortCircuitOp
  case orOp
  case orShortCircuitOp
  case xorOp
  case addOp
  case addOpNoOvf
  case subOp
  case subOpNoOvf
  case mulOp
  case mulOpNoOvf
  case divOp
  case divOpNoOvf
  case modOp
  case leftShiftOp
  case rightShiftOp
}

#----------------------------------------------------------------------------------------------------------------------*

class @infixOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @infixOperator mOp
  @expressionAST mRightExpression
}

#----------------------------------------------------------------------------------------------------------------------*

class @asExpressionAST : @expressionAST {
  @expressionAST mExpression
  @lstring mTypeName
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <comparison> !@expressionAST outExpression {
    <additive_expression> ?outExpression
    select
    or
      $as$
      $identifier$ ?let typeIdentifier
      outExpression = @asExpressionAST.new {
        !outExpression
        !typeIdentifier
      }
    or
      $==$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.equal
        !rightExpression
      }
    or
      $!=$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.nonEqual
        !rightExpression
      }
    or
      $<=$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.infEqual
        !rightExpression
      }
    or
      $>=$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.supEqual
        !rightExpression
      }
    or
      $<$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictInf
        !rightExpression
      }
    or
      $>$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictSup
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <additive_expression> !@expressionAST outExpression {
    <multiplicative_expression> ?outExpression
    repeat
    while
      $|$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.orOp
        !rightExpression
      }
    while
      $^$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.xorOp
        !rightExpression
      }
    while
      $+$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOp
        !rightExpression
      }
    while
      $&+$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOpNoOvf
        !rightExpression
      }
    while
      $-$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOp
        !rightExpression
      }
    while
      $&-$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOpNoOvf
        !rightExpression
      }
    while
      $||$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.orShortCircuitOp
        !rightExpression
      }
    while
      $<<$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.leftShiftOp
        !rightExpression
      }
    while
      $>>$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.rightShiftOp
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <multiplicative_expression> !@expressionAST outExpression {
    <primary> ?outExpression
    repeat
    while
      $&$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.andOp
        !rightExpression
      }
    while
      $*$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOp
        !rightExpression
      }
    while
      $&*$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOpNoOvf
        !rightExpression
      }
    while
      $%$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOp
        !rightExpression
      }
    while
      $/$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOp
        !rightExpression
      }
    while
      $&/$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOpNoOvf
        !rightExpression
      }
    while
      $&&$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.andShortCircuitOp
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @asExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

method @infixOperatorMap checkWith
  ?leftType:let @unifiedTypeMap-proxy inLeftType
  ?rightType:let @unifiedTypeMap-proxy inRightType
  ?operatorLocation:let @location inOperatorLocation
  !resultType: @unifiedTypeMap-proxy outResultType
{
  let lkey = @lstring.new {![inLeftType key] + "." + [inRightType key] !inOperatorLocation}
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType]
  else
    error inOperatorLocation
      : "infix operation between '" + [inLeftType key] + " and " + [inRightType key] + "' is not defined"
      : outResultType
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST analyzeExpression
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @string inMode
  ?!temporary:@uint ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResult
{
#--- Analyze left expression
  [mLeftExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let leftExpressionType
    ?result:@variableKindIR leftResult
  ]
#--- Analyze right expression
  [mRightExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:leftExpressionType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let rightExpressionType
    ?result:@variableKindIR rightResult
  ]
#--- Check left type
  @infixOperatorMap operatorMap
  @infixOperatorIR infixOperatorIR
  switch mOp 
  case equal :
    operatorMap = inContext.mEqualOperatorMap
    infixOperatorIR = .infix {!infixOperator:"=="}
  case nonEqual :
    operatorMap = inContext.mNonEqualOperatorMap
    infixOperatorIR = .infix {!infixOperator:"!="}
  case strictInf :
    operatorMap = inContext.mStrictInfOperatorMap
    infixOperatorIR = .infix {!infixOperator:"<"}
  case infEqual :
    operatorMap = inContext.mInfEqualOperatorMap
    infixOperatorIR = .infix {!infixOperator:"<="}
  case strictSup :
    operatorMap = inContext.mStrictSupOperatorMap
    infixOperatorIR = .infix {!infixOperator:">"}
  case supEqual :
    operatorMap = inContext.mSupEqualOperatorMap
    infixOperatorIR = .infix {!infixOperator:">="}
  case andOp :
    operatorMap = inContext.mAndOperatorMap
    infixOperatorIR = .infix {!infixOperator:"&"}
  case andShortCircuitOp :
    operatorMap = inContext.mAndShortCircuitOperatorMap
    infixOperatorIR = .infix {!infixOperator:"&&"}
  case orOp :
    operatorMap = inContext.mOrOperatorMap
    infixOperatorIR = .infix {!infixOperator:"|"}
  case orShortCircuitOp :
    operatorMap = inContext.mOrShortCircuitOperatorMap
    infixOperatorIR = .infix {!infixOperator:"||"}
  case xorOp :
    operatorMap = inContext.mXorOperatorMap
    infixOperatorIR = .infix {!infixOperator:"^"}
  case addOp :
    operatorMap = inContext.mAddOperatorMap
    infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_add_overflow" !code:3}
  case addOpNoOvf :
    operatorMap = inContext.mAddNoOvfOperatorMap
    infixOperatorIR = .infix {!infixOperator:"+"}
  case subOpNoOvf :
    operatorMap = inContext.mSubNoOvfOperatorMap
    infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_sub_overflow" !code:4}
  case subOp :
    operatorMap = inContext.mSubOperatorMap
    infixOperatorIR = .infix {!infixOperator:"-"}
  case mulOp :
    operatorMap = inContext.mMulOperatorMap
    infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_mul_overflow" !code:5}
  case mulOpNoOvf :
    operatorMap = inContext.mMulNoOvfOperatorMap
    infixOperatorIR = .infix {!infixOperator:"*"}
  case divOp :
    operatorMap = inContext.mDivOperatorMap
    infixOperatorIR = .infixUnsignedDivide{!code:6}
  case divOpNoOvf :
    operatorMap = inContext.mDivNoOvfOperatorMap
    infixOperatorIR = .infix {!infixOperator:"/"}
  case modOp :
    operatorMap = inContext.mModOperatorMap
    infixOperatorIR = .infix {!infixOperator:"%"}
  case leftShiftOp :
    operatorMap = inContext.mLeftShiftOperatorMap
    infixOperatorIR = .infix {!infixOperator:"<<"}
  case rightShiftOp :
    operatorMap = inContext.mRightShiftOperatorMap
    infixOperatorIR = .infix {!infixOperator:">>"}
  end
  [operatorMap checkWith
    !leftType:leftExpressionType
    !rightType:rightExpressionType
    !operatorLocation:mOperatorLocation
    ?resultType:outExpressionType
  ]
#---
  if [leftResult isLiteralUnsignedInteger] && [rightResult isLiteralUnsignedInteger] then
    [leftResult literalUnsignedInteger ?type:* ?value:let @luint64 leftValue]
    [rightResult literalUnsignedInteger ?type:* ?value:let @luint64 rightValue]
    @uint64 result
    switch mOp 
    case equal : result = [leftValue.uint64 == rightValue.uint64 uint64]
    case nonEqual : result = [leftValue.uint64 != rightValue.uint64 uint64]
    case strictInf : result = [leftValue.uint64 < rightValue.uint64 uint64]
    case infEqual : result = [leftValue.uint64 <= rightValue.uint64 uint64]
    case strictSup : result = [leftValue.uint64 > rightValue.uint64 uint64]
    case supEqual : result = [leftValue.uint64 >= rightValue.uint64 uint64]
    case andOp : result = leftValue.uint64 & rightValue.uint64
    case andShortCircuitOp : result = [(leftValue.uint64 != 0L) && (rightValue.uint64 != 0L) uint64]
    case orOp : result = leftValue.uint64 | rightValue.uint64
    case orShortCircuitOp : result = [(leftValue.uint64 != 0L) && (rightValue.uint64 != 0L) uint64]
    case xorOp : result = leftValue.uint64 ^ rightValue.uint64
    case addOp : result = leftValue.uint64 &+ rightValue.uint64
    case addOpNoOvf : result = leftValue.uint64 + rightValue.uint64
    case subOp : result = leftValue.uint64 - rightValue.uint64
    case subOpNoOvf : result = leftValue.uint64 &- rightValue.uint64
    case mulOp : result = leftValue.uint64 * rightValue.uint64
    case mulOpNoOvf : result = leftValue.uint64 &* rightValue.uint64
    case divOp : result = leftValue.uint64 / rightValue.uint64
    case divOpNoOvf : result = leftValue.uint64 &/ rightValue.uint64
    case modOp : result = leftValue.uint64 mod rightValue.uint64
    case leftShiftOp  : result = leftValue.uint64 << [rightValue.uint64 uint]
    case rightShiftOp : result = leftValue.uint64 >> [rightValue.uint64 uint]
    end
    outResult = .literalUnsignedInteger {!type:outExpressionType !value:.new{!result !mOperatorLocation}}
  else
  #--- Temp var
    getNewTempVariable (!?ioTemporaryIndex !mOperatorLocation ?outResult)
  #--- Generate code
    ioInstructionGenerationList += !@operatorInfixExpressionIR.new {
      !outExpressionType
      !outResult
      !leftResult
      !infixOperatorIR
      !rightResult
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! @asExpressionAST

override method @asExpressionAST analyzeExpression
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @string inMode
  ?!temporary:@uint ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let unused expressionType
    ?result:@variableKindIR expressionResult
  ]
#--- Analyze type
  outExpressionType = .searchKey {!inContext.mTypeMap !mTypeName}
#--- Temp var
  getNewTempVariable (!?ioTemporaryIndex !mTypeName.location ?outResult)
#--- Generate code
  ioInstructionGenerationList += !@asOperatorInstructionIR.new {
    !outExpressionType
    !outResult
    !expressionResult
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @asOperatorInstructionIR
#----------------------------------------------------------------------------------------------------------------------*

class @asOperatorInstructionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mTemporaryResultVariable
  @variableKindIR mOperand
}

#----------------------------------------------------------------------------------------------------------------------*

override method @asOperatorInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @asOperatorInstructionIR instructionCode -> @string outCode {
  outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mTemporaryResultVariable mangledName]
  outCode += " = ((" + mangledNameForType (!name:[mTargetType key]) + ") " + [mOperand mangledName] + ") ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*
#! @operatorInfixExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperatorIR {
  case infix (@string infixOperator)
  case infixOvf (@string builtinFunction @uint code)
  case infixUnsignedDivide (@uint code)
}

#----------------------------------------------------------------------------------------------------------------------*

class @operatorInfixExpressionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mResult
  @variableKindIR mLeftOperand
  @infixOperatorIR mOperator
  @variableKindIR mRighOperand
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @operatorInfixExpressionIR instructionCode -> @string outCode {
  switch mOperator 
  case infix (@string infixOperator) :
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mLeftOperand mangledName] + " " + infixOperator + " " + [mRighOperand mangledName] + " ;\n"
  case infixOvf (@string builtinFunction @uint code) :
    let ovfVar = "ovf" + [[mResult location] locationIndex]
    outCode = mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName] + " ;\n"
    outCode += "const bool " + ovfVar + " = " + builtinFunction + " ("
      +  [mLeftOperand mangledName] + ", "
      + [mRighOperand mangledName]
      + ", &" + [mResult mangledName] + ") ;\n"
    outCode += "if (" + ovfVar + ") {\n"
    outCode += "  raise_exception (" + code + ", " + [[[[mResult location] file] lastPathComponent] utf8Representation] + ", " + [[mResult location] line] + ") ;\n"
    outCode += "}\n" 
  case infixUnsignedDivide (@uint code) :
    outCode  = "if (0 == " +  [mRighOperand mangledName] + ") {\n"
    outCode += "  raise_exception (" + code + ", " + [[[[mResult location] file] lastPathComponent] utf8Representation] + ", " + [[mResult location] line] + ") ;\n"
    outCode += "}\n" 
    outCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mLeftOperand mangledName] + " / " + [mRighOperand mangledName] + " ;\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @operatorInfixExpressionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mLeftOperand enterAccessibleEntities !?ioAccessibleEntities]
  [mRighOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
