#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case andOp
  case booleanAnd
  case orOp
  case booleanOrOp
  case xorOp
  case booleanXorOp
  case addOp
  case addOpNoOvf
  case subOp
  case subOpNoOvf
  case mulOp
  case mulOpNoOvf
  case divOp
  case divOpNoOvf
  case modOp
  case modOpNoOvf
  case leftShiftOp
  case rightShiftOp
}

#----------------------------------------------------------------------------------------------------------------------*

class @infixOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @infixOperator mOp
  @expressionAST mRightExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <comparison> !@expressionAST outExpression {
    <conversion> ?outExpression
    select
    or
      $==$
      let operatorLocation = @location.here
      <conversion> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.equal
        !rightExpression
      }
    or
      $!=$
      let operatorLocation = @location.here
      <conversion> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.nonEqual
        !rightExpression
      }
    or
      $<=$
      let operatorLocation = @location.here
      <conversion> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.infEqual
        !rightExpression
      }
    or
      $>=$
      let operatorLocation = @location.here
      <conversion> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.supEqual
        !rightExpression
      }
    or
      $<$
      let operatorLocation = @location.here
      <conversion> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictInf
        !rightExpression
      }
    or
      $>$
      let operatorLocation = @location.here
      <conversion> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.strictSup
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <shift_expression> !@expressionAST outExpression {
    <additive_expression> ?outExpression
    repeat
    while
      $<<$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.leftShiftOp
        !rightExpression
      }
    while
      $>>$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.rightShiftOp
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <additive_expression> !@expressionAST outExpression {
    <multiplicative_expression> ?outExpression
    repeat
    while
      $|$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.orOp
        !rightExpression
      }
    while
      $^$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.xorOp
        !rightExpression
      }
    while
      $xor$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.booleanXorOp
        !rightExpression
      }
    while
      $+$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOp
        !rightExpression
      }
    while
      $&+$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.addOpNoOvf
        !rightExpression
      }
    while
      $-$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOp
        !rightExpression
      }
    while
      $&-$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.subOpNoOvf
        !rightExpression
      }
    while
      $or$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.booleanOrOp
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <multiplicative_expression> !@expressionAST outExpression {
    <primary> ?outExpression
    repeat
    while
      $&$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.andOp
        !rightExpression
      }
    while
      $*$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOp
        !rightExpression
      }
    while
      $&*$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.mulOpNoOvf
        !rightExpression
      }
    while
      $%$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOp
        !rightExpression
      }
    while
      $&%$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.modOpNoOvf
        !rightExpression
      }
    while
      $/$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOp
        !rightExpression
      }
    while
      $&/$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.divOpNoOvf
        !rightExpression
      }
    while
      $and$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !operatorLocation
        !.booleanAnd
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

method @infixOperatorMap checkWith
  ?leftType:let @unifiedTypeMap-proxy inLeftType
  ?rightType:let @unifiedTypeMap-proxy inRightType
  ?operatorLocation:let @location inOperatorLocation
  !resultType: @unifiedTypeMap-proxy outResultType
{
  let lkey = @lstring.new {![inLeftType key] + "." + [inRightType key] !inOperatorLocation}
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType]
  else
    error inOperatorLocation
      : "infix operation between '" + [inLeftType key] + " and " + [inRightType key] + "' is not defined"
      : outResultType
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST analyzeExpression
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
  !result:@variableKindIR outResult
{
#--- Analyze left expression
  [mLeftExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let leftExpressionType
    ?result:@variableKindIR leftResult
  ]
#--- Analyze right expression
  [mRightExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:leftExpressionType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let rightExpressionType
    ?result:@variableKindIR rightResult
  ]
#--- Check left type
  @infixOperatorMap operatorMap
  @infixOperatorIR infixOperatorIR
  switch mOp 
  case equal :
    operatorMap = inContext.mEqualOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"=="}
  case nonEqual :
    operatorMap = inContext.mNonEqualOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"!="}
  case strictInf :
    operatorMap = inContext.mStrictInfOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"<"}
  case infEqual :
    operatorMap = inContext.mInfEqualOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"<="}
  case strictSup :
    operatorMap = inContext.mStrictSupOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:">"}
  case supEqual :
    operatorMap = inContext.mSupEqualOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:">="}
  case andOp :
    operatorMap = inContext.mAndOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"&"}
  case booleanAnd :
    operatorMap = inContext.mBooleanAndOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"&&"}
  case orOp :
    operatorMap = inContext.mOrOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"|"}
  case booleanOrOp :
    operatorMap = inContext.mBooleanOrOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"||"}
  case xorOp :
    operatorMap = inContext.mXorOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"^"}
  case booleanXorOp :
    operatorMap = inContext.mBooleanXorOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"^"}
  case addOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mAddOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      infixOperatorIR = .infixNoOvf {!infixOperator:"+"}
    else
      infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_add_overflow" !code:10}
    end
  case addOpNoOvf :
    operatorMap = inContext.mAddNoOvfOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"+"}
  case subOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mSubNoOvfOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      infixOperatorIR = .infixNoOvf {!infixOperator:"-"}
    else
      infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_sub_overflow" !code:11}
    end
  case subOpNoOvf :
    operatorMap = inContext.mSubOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"-"}
  case mulOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mMulOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      infixOperatorIR = .infixNoOvf {!infixOperator:"*"}
    else
      infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_mul_overflow" !code:12}
    end
  case mulOpNoOvf :
    operatorMap = inContext.mMulNoOvfOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"*"}
  case divOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mDivOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      infixOperatorIR = .infixNoOvf {!infixOperator:"/"}
    else
      infixOperatorIR = .infixUnsignedDivide{!code:13}
    end
  case divOpNoOvf :
    operatorMap = inContext.mDivNoOvfOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"/"}
  case modOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mModOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      infixOperatorIR = .infixNoOvf {!infixOperator:"%"}
    else
      infixOperatorIR = .infixModulo{!code:14}
    end
  case modOpNoOvf :
    operatorMap = inContext.mModOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"%"}
  case leftShiftOp :
    operatorMap = inContext.mLeftShiftOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:"<<"}
  case rightShiftOp :
    operatorMap = inContext.mRightShiftOperatorMap
    infixOperatorIR = .infixNoOvf {!infixOperator:">>"}
  end
  [operatorMap checkWith
    !leftType:leftExpressionType
    !rightType:rightExpressionType
    !operatorLocation:mOperatorLocation
    ?resultType:outExpressionType
  ]
#---
  if [leftResult isLiteralUnsignedInteger] && [rightResult isLiteralUnsignedInteger] then
    [leftResult literalUnsignedInteger ?value:let @uint64 leftValue]
    [rightResult literalUnsignedInteger ?value:let @uint64 rightValue]
    @uint64 result
    switch mOp 
    case equal : result = [leftValue == rightValue uint64]
    case nonEqual : result = [leftValue != rightValue uint64]
    case strictInf : result = [leftValue < rightValue uint64]
    case infEqual : result = [leftValue <= rightValue uint64]
    case strictSup : result = [leftValue > rightValue uint64]
    case supEqual : result = [leftValue >= rightValue uint64]
    case andOp : result = leftValue & rightValue
    case booleanAnd : result = [(leftValue != 0L) && (rightValue != 0L) uint64]
    case orOp : result = leftValue | rightValue
    case booleanOrOp : result = [(leftValue != 0L) || (rightValue != 0L) uint64]
    case xorOp, booleanXorOp : result = leftValue ^ rightValue
    case addOp : result = leftValue &+ rightValue
    case addOpNoOvf : result = leftValue + rightValue
    case subOp : result = leftValue - rightValue
    case subOpNoOvf : result = leftValue &- rightValue
    case mulOp : result = leftValue * rightValue
    case mulOpNoOvf : result = leftValue &* rightValue
    case divOp : result = leftValue / rightValue
    case divOpNoOvf : result = leftValue &/ rightValue
    case modOp : result = leftValue mod rightValue
    case modOpNoOvf : result = leftValue mod rightValue
    case leftShiftOp  : result = leftValue << [rightValue uint]
    case rightShiftOp : result = leftValue >> [rightValue uint]
    end
    outResult = .literalUnsignedInteger {!value:result}
  else
  #--- Temp var
    getNewTempVariable (!?ioTemporaries ?outResult)
  #--- Generate code
    ioInstructionGenerationList += !@operatorInfixExpressionIR.new {
      !outExpressionType
      !outResult
      !leftResult
      !infixOperatorIR
      !rightResult
      !mOperatorLocation
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @operatorInfixExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperatorIR {
  case infixNoOvf (@string infixOperator)
  case infixOvf (@string builtinFunction @uint code)
  case infixUnsignedDivide (@uint code)
  case infixModulo (@uint code)
}

#----------------------------------------------------------------------------------------------------------------------*

class @operatorInfixExpressionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mResult
  @variableKindIR mLeftOperand
  @infixOperatorIR mOperator
  @variableKindIR mRighOperand
  @location mOperatorLocation
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @operatorInfixExpressionIR instructionCode -> @string outCode {
  switch mOperator 
  case infixNoOvf (@string infixOperator) :
    outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mLeftOperand mangledName] + " " + infixOperator + " " + [mRighOperand mangledName] + " ;\n"
  case infixOvf (@string builtinFunction @uint code) :
    let ovfVar = "ovf" + [mOperatorLocation locationIndex]
    outCode = mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName] + " ;\n"
    outCode += "const bool " + ovfVar + " = " + builtinFunction + " ("
      +  [mLeftOperand mangledName] + ", "
      + [mRighOperand mangledName]
      + ", &" + [mResult mangledName] + ") ;\n"
    outCode += "if (" + ovfVar + ") {\n"
    outCode += "  raise_exception (" + code
       + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
       + ", " + [mOperatorLocation line] + ") ;\n"
    outCode += "}\n" 
  case infixUnsignedDivide (@uint code) :
    outCode  = "if (0 == " +  [mRighOperand mangledName] + ") {\n"
    outCode += "  raise_exception (" + code
      + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
      + ", " + [mOperatorLocation line] + ") ;\n"
    outCode += "}\n"
    outCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mLeftOperand mangledName] + " / " + [mRighOperand mangledName] + " ;\n"
  case infixModulo (@uint code) :
    outCode  = "if (0 == " +  [mRighOperand mangledName] + ") {\n"
    outCode += "  raise_exception (" + code
      + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
      + ", " + [mOperatorLocation line] + ") ;\n"
    outCode += "}\n"
    outCode += "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
    outCode += " = " +  [mLeftOperand mangledName] + " % " + [mRighOperand mangledName] + " ;\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @operatorInfixExpressionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mLeftOperand enterAccessibleEntities !?ioAccessibleEntities]
  [mRighOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
