#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @infixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case andOp
  case orOp
  case xorOp
  case booleanXorOp
  case addOp
  case addOpNoOvf
  case subOp
  case subOpNoOvf
  case mulOp
  case mulOpNoOvf
  case divOp
  case divOpNoOvf
  case modOp
  case modOpNoOvf
  case leftShiftOp
  case rightShiftOp
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @infixOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @infixOperator mOp
  @expressionAST mRightExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @booleanShortCircuitAndOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @expressionAST mRightExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanShortCircuitAndOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixOperatorExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mLeftExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [mRightExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanShortCircuitAndOperatorExpressionAST noteExpressionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mLeftExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  [mRightExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @infixOperatorMap checkBinaryOperationWith
  ?leftType:let @unifiedTypeMap-proxy inLeftType
  ?rightType:let @unifiedTypeMap-proxy inRightType
  ?operatorLocation:let @location inOperatorLocation
  !resultType: @unifiedTypeMap-proxy outResultType
  !op:@infixOperatorDescription outOperation
{
  if inLeftType == .null then
    error inOperatorLocation : "left type is null"
  end
  if inRightType == .null then
    error inOperatorLocation : "right type is null"
  end
  let lkey = combineTypeNamesForInfixOperator (![inLeftType key] ![inRightType key])
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType ?outOperation]
  else
    error inOperatorLocation
      : "infix operation between $" + [inLeftType key] + " and $" + [inRightType key] + " is not defined"
      : outResultType, outOperation
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @infixOperatorExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#------------------- Analyze left expression
  [mLeftExpression analyzeExpression
    !self:inSelfType
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @objectIR leftOperandPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !leftOperandPossibleReference
    !mOperatorLocation
    ?let leftOperand
  ]  
#------------------- Analyze right expression
  [mRightExpression analyzeExpression
    !self:inSelfType
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:[leftOperand type]
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @objectIR rightOperandPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !rightOperandPossibleReference
    !mOperatorLocation
    ?let rightOperand
  ]  
#------------------- Get operator map
  let operatorMap = getInfixOperatorMap (!mOp !context:inContext !mode:inCurrentMode !mOperatorLocation)
#------------------- Check operand types
  [operatorMap checkBinaryOperationWith
    !leftType:[leftOperand type]
    !rightType:[rightOperand type]
    !operatorLocation:mOperatorLocation
    ?resultType:let resultType
    ?op:let @infixOperatorDescription binaryOperator
  ]
#------------------- Generate code
  [binaryOperator generateInfixOperatorCode
    !?ioTemporaries
    !?ioInstructionGenerationList
    !leftOperand
    !mOperatorLocation
    !rightOperand
    !resultType
    ?outResult
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func getInfixOperatorMap
  ?let @infixOperator inOp
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?let @location inOperatorLocation
  -> @infixOperatorMap outOperatorMap
{
  switch inOp 
  case equal :
    outOperatorMap = inContext.mEqualOperatorMap
  case nonEqual :
    outOperatorMap = inContext.mNonEqualOperatorMap
  case strictInf :
    outOperatorMap = inContext.mStrictInfOperatorMap
  case infEqual :
    outOperatorMap = inContext.mInfEqualOperatorMap
  case strictSup :
    outOperatorMap = inContext.mStrictSupOperatorMap
  case supEqual :
    outOperatorMap = inContext.mSupEqualOperatorMap
  case andOp :
    outOperatorMap = inContext.mAndOperatorMap
  case orOp :
    outOperatorMap = inContext.mOrOperatorMap
  case xorOp :
    outOperatorMap = inContext.mXorOperatorMap
  case booleanXorOp :
    outOperatorMap = inContext.mBooleanXorOperatorMap
  case addOp :
    if inCurrentMode == .panicMode then
      error inOperatorLocation : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
    end
    if [option plm_options.noPanicGeneration value] then
      outOperatorMap = inContext.mAddNoOvfOperatorMap
    else
      outOperatorMap = inContext.mAddOperatorMap
    end
  case addOpNoOvf :
    outOperatorMap = inContext.mAddNoOvfOperatorMap
  case subOp :
    if inCurrentMode == .panicMode then
      error inOperatorLocation : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
    end
    if [option plm_options.noPanicGeneration value] then
      outOperatorMap = inContext.mSubNoOvfOperatorMap
    else
      outOperatorMap = inContext.mSubOperatorMap
    end
  case subOpNoOvf :
    outOperatorMap = inContext.mSubNoOvfOperatorMap
  case mulOp :
    if inCurrentMode == .panicMode then
      error inOperatorLocation : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
    end
    if [option plm_options.noPanicGeneration value] then
      outOperatorMap = inContext.mMulNoOvfOperatorMap
    else
      outOperatorMap = inContext.mMulOperatorMap
    end
  case mulOpNoOvf :
    outOperatorMap = inContext.mMulNoOvfOperatorMap
  case divOp :
    if inCurrentMode == .panicMode then
      error inOperatorLocation : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
    end
    if [option plm_options.noPanicGeneration value] then
      outOperatorMap = inContext.mDivNoOvfOperatorMap
    else
      outOperatorMap = inContext.mDivOperatorMap
    end
  case divOpNoOvf :
    outOperatorMap = inContext.mDivNoOvfOperatorMap
  case modOp :
    if inCurrentMode == .panicMode then
      error inOperatorLocation : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
    end
    if [option plm_options.noPanicGeneration value] then
      outOperatorMap = inContext.mModNoOvfOperatorMap
    else
      outOperatorMap = inContext.mModOperatorMap
    end
  case modOpNoOvf :
    outOperatorMap = inContext.mModNoOvfOperatorMap
  case leftShiftOp :
    outOperatorMap = inContext.mLeftShiftOperatorMap
  case rightShiftOp :
    outOperatorMap = inContext.mRightShiftOperatorMap
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @booleanShortCircuitAndOperatorExpressionAST analyzeExpression
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !result:@objectIR outResult
{
#--- Analyze left expression
  @instructionListIR leftInstructionGenerationList = {}
  [mLeftExpression analyzeExpression
    !self:inSelfType
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:leftInstructionGenerationList
    ?result:let @objectIR leftOperandPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !leftOperandPossibleReference
    !mOperatorLocation
    ?let leftOperand
  ]  
#--- Analyze right expression
  @instructionListIR rightInstructionGenerationList = {}
  [mRightExpression analyzeExpression
    !self:inSelfType
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:[leftOperand type]
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:rightInstructionGenerationList
    ?result:let @objectIR rightOperandPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !rightOperandPossibleReference
    !mOperatorLocation
    ?let rightOperand
  ]  
#--- Check left type is boolean
  if [leftOperand kind] != .boolean then
    error mOperatorLocation : "left operand should be boolean"
  end
#--- Check right type is boolean
  if [rightOperand kind] != .boolean then
    error mOperatorLocation : "left operand should be boolean"
  end
#--- Result type : bool 
  getNewTempVariable (!inContext.mBooleanType !mOperatorLocation !?ioTemporaries ?outResult)
#--- Generate code
  [!?ioInstructionGenerationList appendShortCircuitAndOperation
    !outResult
    !leftOperand
    !leftInstructionGenerationList
    !rightOperand
    !rightInstructionGenerationList
    !mOperatorLocation
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @infixOperatorDescription {
  @llvmBinaryOperation mOperator
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @infixOperatorDescription generateInfixOperatorCode
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@objectIR outResultValue

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @infixOperatorDescription performStaticOperation
  ?let @bigint inLeft
  ?let @bigint inRight
  -> @bigint outResult
{
  switch mOperator
  case addNoOVF : outResult = inLeft + inRight
  case subNoOVF : outResult = inLeft - inRight
  case mulNoOVF : outResult = inLeft * inRight
  case udivNoOVF : outResult = inLeft / inRight
  case sdivNoOVF : outResult = inLeft / inRight
  case uremNoOVF : outResult = inLeft mod inRight
  case sremNoOVF : outResult = inLeft mod inRight

  case uaddOVF : outResult = inLeft + inRight
  case saddOVF : outResult = inLeft + inRight
  case usubOVF : outResult = inLeft - inRight
  case ssubOVF : outResult = inLeft - inRight
  case umulOVF : outResult = inLeft * inRight
  case smulOVF : outResult = inLeft * inRight
  case udivOVF : outResult = inLeft / inRight
  case sdivOVF : outResult = inLeft / inRight
  case uremOVF : outResult = inLeft mod inRight
  case sremOVF : outResult = inLeft mod inRight

  case and : outResult = inLeft & inRight
  case ior : outResult = inLeft | inRight
  case xor : outResult = inLeft ^ inRight
  case shl : outResult = inLeft << [inRight uint]
  case ashr : outResult = inLeft >> [inRight uint]
  case lshr : outResult = inLeft >> [inRight uint]
  
  case icmp_eq : outResult = [inLeft == inRight bigint]
  case icmp_ne : outResult = [inLeft != inRight bigint]
  case icmp_ult : outResult = [inLeft < inRight bigint]
  case icmp_ule : outResult = [inLeft <= inRight bigint]
  case icmp_ugt : outResult = [inLeft > inRight bigint]
  case icmp_uge : outResult = [inLeft >= inRight bigint]
  case icmp_slt : outResult = [inLeft < inRight bigint]
  case icmp_sle : outResult = [inLeft <= inRight bigint]
  case icmp_sgt : outResult = [inLeft > inRight bigint]
  case icmp_sge : outResult = [inLeft >= inRight bigint]


  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
