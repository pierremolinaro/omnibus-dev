#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case andOp
  case booleanAnd
  case orOp
  case booleanOrOp
  case xorOp
  case booleanXorOp
  case addOp
  case addOpNoOvf
  case subOp
  case subOpNoOvf
  case mulOp
  case mulOpNoOvf
  case divOp
  case divOpNoOvf
  case modOp
  case modOpNoOvf
  case leftShiftOp
  case rightShiftOp
}

#----------------------------------------------------------------------------------------------------------------------*

class @infixOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @infixOperator mOp
  @expressionAST mRightExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

method @infixOperatorMap checkWith
  ?leftType:let @unifiedTypeMap-proxy inLeftType
  ?rightType:let @unifiedTypeMap-proxy inRightType
  ?operatorLocation:let @location inOperatorLocation
  !resultType: @unifiedTypeMap-proxy outResultType
{
  let lkey = @lstring.new {![inLeftType key] + "." + [inRightType key] !inOperatorLocation}
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType]
  else
    error inOperatorLocation
      : "infix operation between '" + [inLeftType key] + " and " + [inRightType key] + "' is not defined"
      : outResultType
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !type:@unifiedTypeMap-proxy outResultType
  !result:@operandIR outResultValue
{
#--- Analyze left expression
  [mLeftExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?type:let @unifiedTypeMap-proxy leftType
    ?result:let @operandIR leftOperandValue
  ]
#--- Analyze right expression
  [mRightExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:leftType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?type:let @unifiedTypeMap-proxy rightType
    ?result:let @operandIR rightOperandValue
  ]
#  log leftOperandValue, rightOperandValue
#--- Check left type
  @infixOperatorMap operatorMap
  @string binaryOperator
  switch mOp 
  case equal :
    operatorMap = inContext.mEqualOperatorMap
    binaryOperator = "icmp eq"
  case nonEqual :
    operatorMap = inContext.mNonEqualOperatorMap
    binaryOperator = "icmp ne"
  case strictInf :
    operatorMap = inContext.mStrictInfOperatorMap
    binaryOperator = "icmp ult"
  case infEqual :
    operatorMap = inContext.mInfEqualOperatorMap
    binaryOperator = "icmp ule"
  case strictSup :
    operatorMap = inContext.mStrictSupOperatorMap
    binaryOperator = "icmp ugt"
  case supEqual :
    operatorMap = inContext.mSupEqualOperatorMap
    binaryOperator = "icmp uge"
  case andOp :
    operatorMap = inContext.mAndOperatorMap
    binaryOperator = "and"
  case booleanAnd :
    operatorMap = inContext.mBooleanAndOperatorMap
    binaryOperator = "&&"
  case orOp :
    operatorMap = inContext.mOrOperatorMap
    binaryOperator = "or"
  case booleanOrOp :
    operatorMap = inContext.mBooleanOrOperatorMap
    binaryOperator = "||"
  case xorOp :
    operatorMap = inContext.mXorOperatorMap
    binaryOperator = "xor"
  case booleanXorOp :
    operatorMap = inContext.mBooleanXorOperatorMap
    binaryOperator = "xor"
  case addOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mAddOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      binaryOperator = "add"
    else
#      infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_add_overflow" !code:10}
      binaryOperator = "+OVF+"
    end
  case addOpNoOvf :
    operatorMap = inContext.mAddNoOvfOperatorMap
    binaryOperator = "add"
  case subOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mSubNoOvfOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      binaryOperator = "sub"
    else
#      infixOperatorIR = .infixOvf {!builtinFunction:"__builtin_sub_overflow" !code:11}
      binaryOperator = "-OVF-"
    end
  case subOpNoOvf :
    operatorMap = inContext.mSubOperatorMap
    binaryOperator = "sub"
  case mulOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mMulOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      binaryOperator = "mul"
    else
      binaryOperator = "*OVF*"
    end
  case mulOpNoOvf :
    operatorMap = inContext.mMulNoOvfOperatorMap
      binaryOperator = "mul"
  case divOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mDivOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      binaryOperator = "/"
    else
      binaryOperator = "/OVF/"
    end
  case divOpNoOvf :
    operatorMap = inContext.mDivNoOvfOperatorMap
    binaryOperator = "/"
  case modOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    operatorMap = inContext.mModOperatorMap
    if [option plm_options.noExceptionGeneration value] then
      binaryOperator = "%"
    else
#      infixOperatorIR = .infixModulo{!code:14}
      binaryOperator = "%OVF%"
    end
  case modOpNoOvf :
    operatorMap = inContext.mModOperatorMap
    binaryOperator = "%"
  case leftShiftOp :
    operatorMap = inContext.mLeftShiftOperatorMap
    binaryOperator = "shl"
  case rightShiftOp :
    operatorMap = inContext.mRightShiftOperatorMap
    binaryOperator = ">>"
  end
  [operatorMap checkWith
    !leftType:leftType
    !rightType:rightType
    !operatorLocation:mOperatorLocation
    ?resultType:outResultType
  ]
#---
  if [leftOperandValue isLiteralInteger] && [rightOperandValue isLiteralInteger] then
    [leftOperandValue literalInteger ?value:let @bigint leftValue]
    [rightOperandValue literalInteger ?value:let @bigint rightValue]
    @bigint result
    switch mOp 
    case equal : result = [leftValue == rightValue bigint]
    case nonEqual : result = [leftValue != rightValue bigint]
    case strictInf : result = [leftValue < rightValue bigint]
    case infEqual : result = [leftValue <= rightValue bigint]
    case strictSup : result = [leftValue > rightValue bigint]
    case supEqual : result = [leftValue >= rightValue bigint]
    case andOp : result = leftValue & rightValue
    case booleanAnd : result = [(leftValue != 0G) && (rightValue != 0G) bigint]
    case orOp : result = leftValue | rightValue
    case booleanOrOp : result = [(leftValue != 0G) || (rightValue != 0G) bigint]
    case xorOp, booleanXorOp : result = leftValue ^ rightValue
    case addOp : result = leftValue + rightValue
    case addOpNoOvf : result = leftValue + rightValue
    case subOp : result = leftValue - rightValue
    case subOpNoOvf : result = leftValue - rightValue
    case mulOp : result = leftValue * rightValue
    case mulOpNoOvf : result = leftValue * rightValue
    case divOp : result = leftValue / rightValue
    case divOpNoOvf : result = leftValue / rightValue
    case modOp : result = leftValue mod rightValue
    case modOpNoOvf : result = leftValue mod rightValue
    case leftShiftOp  : result = leftValue << [rightValue uint]
    case rightShiftOp : result = leftValue >> [rightValue uint]
    end
    outResultValue = .literalInteger {!value:result}
  else
  #--- Temp var
    getNewTempVariable (!?ioTemporaries ?outResultValue)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResultValue
      !leftType
      !leftOperandValue
      !binaryOperator
      !rightOperandValue
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @operatorInfixExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperatorIR {
  case infixNoOvf (@string infixOperator)
  case infixOvf (@string builtinFunction @uint code)
  case infixUnsignedDivide (@uint code)
  case infixModulo (@uint code)
}

#----------------------------------------------------------------------------------------------------------------------*

#class @operatorInfixExpressionIR : @abstractInstructionIR {
#  @unifiedTypeMap-proxy mResultType
#  @operandIR mResult
#  @operandIR mLeftOperand
#  @infixOperatorIR mOperator
#  @operandIR mRighOperand
#  @location mOperatorLocation
#}
#
##----------------------------------------------------------------------------------------------------------------------*
#
#override method @operatorInfixExpressionIR llvmInstructionCode ?!@string ioCode {
#  switch mOperator 
#  case infixNoOvf (@string infixOperator) :
#    ioCode += ";--- const " + mangledNameForType (!name:[mResultType key]) + " " + mResult
#    ioCode += " = " +  mLeftOperand + " " + infixOperator + " " + mRighOperand + " ;\n"
#    ioCode += "  <<@operatorInfixExpressionIR llvmInstructionCode>>\n"
#  case infixOvf (@string builtinFunction @uint code) :
#    let ovfVar = "ovf" + [mOperatorLocation locationIndex]
#    ioCode += mangledNameForType (!name:[mResultType key]) + " " + mResult + " ;\n"
#    ioCode += "const bool " + ovfVar + " = " + builtinFunction + " ("
#      +  mLeftOperand + ", "
#      + mRighOperand
#      + ", &" + mResult + ") ;\n"
#    ioCode += "if (" + ovfVar + ") {\n"
#    ioCode += "  raise_exception (" + code
#       + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
#       + ", " + [mOperatorLocation line] + ") ;\n"
#    ioCode += "}\n" 
#  case infixUnsignedDivide (@uint code) :
#    ioCode += "if (0 == " +  mRighOperand + ") {\n"
#    ioCode += "  raise_exception (" + code
#      + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
#      + ", " + [mOperatorLocation line] + ") ;\n"
#    ioCode += "}\n"
#    ioCode += "const " + mangledNameForType (!name:[mResultType key]) + " " + mResult
#    ioCode += " = " +  mLeftOperand + " / " + mRighOperand + " ;\n"
#  case infixModulo (@uint code) :
#    ioCode += "if (0 == " +  mRighOperand + ") {\n"
#    ioCode += "  raise_exception (" + code
#      + ", " + [[[mOperatorLocation file] lastPathComponent] utf8Representation]
#      + ", " + [mOperatorLocation line] + ") ;\n"
#    ioCode += "}\n"
#    ioCode += "const " + mangledNameForType (!name:[mResultType key]) + " " + mResult
#    ioCode += " = " +  mLeftOperand + " % " + mRighOperand + " ;\n"
#  end
#}
#
##----------------------------------------------------------------------------------------------------------------------*
#
#override method @operatorInfixExpressionIR enterAccessibleEntities ?!@accessibleEntities unused ioAccessibleEntities {
##  [mLeftOperand enterAccessibleEntities !?ioAccessibleEntities]
##  [mRighOperand enterAccessibleEntities !?ioAccessibleEntities]
#}

#----------------------------------------------------------------------------------------------------------------------*
