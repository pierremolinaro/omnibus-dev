#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case andOp
  case orOp
  case xorOp
  case booleanXorOp
  case addOp
  case addOpNoOvf
  case subOp
  case subOpNoOvf
  case mulOp
  case mulOpNoOvf
  case divOp
  case divOpNoOvf
  case modOp
  case modOpNoOvf
  case leftShiftOp
  case rightShiftOp
}

#----------------------------------------------------------------------------------------------------------------------*

class @infixOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @infixOperator mOp
  @expressionAST mRightExpression
}

#----------------------------------------------------------------------------------------------------------------------*

class @booleanShortCircuitAndOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @location mOperatorLocation
  @expressionAST mRightExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @booleanShortCircuitAndOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

method @infixOperatorMap checkWith
  ?leftType:let @unifiedTypeMap-proxy inLeftType
  ?rightType:let @unifiedTypeMap-proxy inRightType
  ?operatorLocation:let @location inOperatorLocation
  !resultType: @unifiedTypeMap-proxy outResultType
  !op:@llvmBinaryOperation outOperation
{
  let lkey = @lstring.new {![inLeftType key] + "." + [inRightType key] !inOperatorLocation}
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType ?outOperation]
  else
    error inOperatorLocation
      : "infix operation between '" + [inLeftType key] + " and " + [inRightType key] + "' is not defined"
      : outResultType, outOperation
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !type:@unifiedTypeMap-proxy outResultType
  !result:@operandIR outResultValue
{
#--- Analyze left expression
  [mLeftExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?type:let @unifiedTypeMap-proxy leftType
    ?result:let @operandIR leftOperandValue
  ]
#--- Analyze right expression
  [mRightExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:leftType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?type:let @unifiedTypeMap-proxy rightType
    ?result:let @operandIR rightOperandValue
  ]
#--- Check left type
  @infixOperatorMap operatorMap
  switch mOp 
  case equal :
    operatorMap = inContext.mEqualOperatorMap
  case nonEqual :
    operatorMap = inContext.mNonEqualOperatorMap
  case strictInf :
    operatorMap = inContext.mStrictInfOperatorMap
  case infEqual :
    operatorMap = inContext.mInfEqualOperatorMap
  case strictSup :
    operatorMap = inContext.mStrictSupOperatorMap
  case supEqual :
    operatorMap = inContext.mSupEqualOperatorMap
  case andOp :
    operatorMap = inContext.mAndOperatorMap
  case orOp :
    operatorMap = inContext.mOrOperatorMap
  case xorOp :
    operatorMap = inContext.mXorOperatorMap
  case booleanXorOp :
    operatorMap = inContext.mBooleanXorOperatorMap
  case addOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    if [option plm_options.noExceptionGeneration value] then
      operatorMap = inContext.mAddNoOvfOperatorMap
    else
      operatorMap = inContext.mAddOperatorMap
    end
  case addOpNoOvf :
    operatorMap = inContext.mAddNoOvfOperatorMap
  case subOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    if [option plm_options.noExceptionGeneration value] then
      operatorMap = inContext.mSubNoOvfOperatorMap
    else
      operatorMap = inContext.mSubOperatorMap
    end
  case subOpNoOvf :
    operatorMap = inContext.mSubOperatorMap
  case mulOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    if [option plm_options.noExceptionGeneration value] then
      operatorMap = inContext.mMulNoOvfOperatorMap
    else
      operatorMap = inContext.mMulOperatorMap
    end
  case mulOpNoOvf :
    operatorMap = inContext.mMulNoOvfOperatorMap
  case divOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    if [option plm_options.noExceptionGeneration value] then
      operatorMap = inContext.mDivNoOvfOperatorMap
    else
      operatorMap = inContext.mDivOperatorMap
    end
  case divOpNoOvf :
    operatorMap = inContext.mDivNoOvfOperatorMap
  case modOp :
    if [inModeSet hasKey !exceptionModeName ()] then
      error mOperatorLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
    end
    if [option plm_options.noExceptionGeneration value] then
      operatorMap = inContext.mModNoOvfOperatorMap
    else
      operatorMap = inContext.mModOperatorMap
    end
  case modOpNoOvf :
    operatorMap = inContext.mModNoOvfOperatorMap
  case leftShiftOp :
    operatorMap = inContext.mLeftShiftOperatorMap
  case rightShiftOp :
    operatorMap = inContext.mRightShiftOperatorMap
  end
  [operatorMap checkWith
    !leftType:leftType
    !rightType:rightType
    !operatorLocation:mOperatorLocation
    ?resultType:outResultType
    ?op:let @llvmBinaryOperation binaryOperator
  ]
#---
  if [leftOperandValue isLiteralInteger] && [rightOperandValue isLiteralInteger] then
    [leftOperandValue literalInteger ?value:let @bigint leftValue]
    [rightOperandValue literalInteger ?value:let @bigint rightValue]
    @bigint result
    switch mOp 
    case equal : result = [leftValue == rightValue bigint]
    case nonEqual : result = [leftValue != rightValue bigint]
    case strictInf : result = [leftValue < rightValue bigint]
    case infEqual : result = [leftValue <= rightValue bigint]
    case strictSup : result = [leftValue > rightValue bigint]
    case supEqual : result = [leftValue >= rightValue bigint]
    case andOp : result = leftValue & rightValue
    case orOp : result = leftValue | rightValue
    case xorOp, booleanXorOp : result = leftValue ^ rightValue
    case addOp : result = leftValue + rightValue
    case addOpNoOvf : result = leftValue + rightValue
    case subOp : result = leftValue - rightValue
    case subOpNoOvf : result = leftValue - rightValue
    case mulOp : result = leftValue * rightValue
    case mulOpNoOvf : result = leftValue * rightValue
    case divOp : result = leftValue / rightValue
    case divOpNoOvf : result = leftValue / rightValue
    case modOp : result = leftValue mod rightValue
    case modOpNoOvf : result = leftValue mod rightValue
    case leftShiftOp  : result = leftValue << [rightValue uint]
    case rightShiftOp : result = leftValue >> [rightValue uint]
    end
    outResultValue = .literalInteger {!value:result}
  else
  #--- Temp var
    getNewTempVariable (!?ioTemporaries ?outResultValue)
  #--- Generate code
    [!?ioInstructionGenerationList appendBinaryOperation
      !outResultValue
      !leftType
      !leftOperandValue
      !binaryOperator
      !rightOperandValue
      !mOperatorLocation
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @booleanShortCircuitAndOperatorExpressionAST analyzeExpression
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !type:@unifiedTypeMap-proxy outResultType
  !result:@operandIR outResultValue
{
#--- Analyze left expression
  @instructionListIR leftInstructionGenerationList = {}
  [mLeftExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:leftInstructionGenerationList
    ?type:let @unifiedTypeMap-proxy leftType
    ?result:let @operandIR leftOperandValue
  ]
#--- Analyze right expression
  @instructionListIR rightInstructionGenerationList = {}
  [mRightExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:leftType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:rightInstructionGenerationList
    ?type:let @unifiedTypeMap-proxy rightType
    ?result:let @operandIR rightOperandValue
  ]
#--- Check left type is boolean
  if [leftType kind] != .boolean then
    error mOperatorLocation : "left operand should be boolean"
  end
#--- Check right type is boolean
  if [rightType kind] != .boolean then
    error mOperatorLocation : "left operand should be boolean"
  end
#--- Temp var
  getNewTempVariable (!?ioTemporaries ?outResultValue)
#--- Generate code
  [!?ioInstructionGenerationList appendShortCircuitAndOperation
    !outResultValue
    !leftOperandValue
    !leftInstructionGenerationList
    !rightOperandValue
    !rightInstructionGenerationList
    !mOperatorLocation
  ]
#--- Result type : bool 
  outResultType = inContext.mBooleanType
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @operatorInfixExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperatorIR {
  case infixNoOvf (@string infixOperator)
  case infixOvf (@string builtinFunction @uint code)
  case infixUnsignedDivide (@uint code)
  case infixModulo (@uint code)
}

#----------------------------------------------------------------------------------------------------------------------*
