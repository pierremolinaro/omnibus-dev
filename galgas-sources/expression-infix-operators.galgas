#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @infixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case andOp
  case andShortCircuitOp
  case orOp
  case orShortCircuitOp
  case xorOp
  case addOp
  case subOp
  case mulOp
  case divOp
  case modOp
  case leftShiftOp
  case rightShiftOp
}

#----------------------------------------------------------------------------------------------------------------------*

class @infixOperatorExpressionAST : @expressionAST {
  @expressionAST mLeftExpression
  @lstring mOperator
  @infixOperator mOp
  @expressionAST mRightExpression
}

#----------------------------------------------------------------------------------------------------------------------*

class @asExpressionAST : @expressionAST {
  @expressionAST mExpression
  @lstring mTypeName
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <comparison> !@expressionAST outExpression {
    <multiplicative_expression> ?outExpression
    select
    or
      $as$
      $identifier$ ?let typeIdentifier
      outExpression = @asExpressionAST.new {
        !outExpression
        !typeIdentifier
      }
    or
      $==$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"==" !operatorLocation}
        !.equal
        !rightExpression
      }
    or
      $!=$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"!=" !operatorLocation}
        !.nonEqual
        !rightExpression
      }
    or
      $<=$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"<=" !operatorLocation}
        !.infEqual
        !rightExpression
      }
    or
      $>=$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!">=" !operatorLocation}
        !.supEqual
        !rightExpression
      }
    or
      $<$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"<" !operatorLocation}
        !.strictInf
        !rightExpression
      }
    or
      $>$
      let operatorLocation = @location.here
      <multiplicative_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!">" !operatorLocation}
        !.strictSup
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <multiplicative_expression> !@expressionAST outExpression {
    <additive_expression> ?outExpression
    repeat
    while
      $&$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"&" !operatorLocation}
        !.andOp
        !rightExpression
      }
    while
      $*$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"*" !operatorLocation}
        !.mulOp
        !rightExpression
      }
    while
      $%$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"%" !operatorLocation}
        !.modOp
        !rightExpression
      }
    while
      $/$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"*" !operatorLocation}
        !.divOp
        !rightExpression
      }
    while
      $&&$
      let operatorLocation = @location.here
      <additive_expression> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"&&" !operatorLocation}
        !.andShortCircuitOp
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <additive_expression> !@expressionAST outExpression {
    <primary> ?outExpression
    repeat
    while
      $|$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"|" !operatorLocation}
        !.orOp
        !rightExpression
      }
    while
      $^$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"^" !operatorLocation}
        !.xorOp
        !rightExpression
      }
    while
      $+$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"+" !operatorLocation}
        !.addOp
        !rightExpression
      }
    while
      $-$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"-" !operatorLocation}
        !.subOp
        !rightExpression
      }
    while
      $||$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"||" !operatorLocation}
        !.orShortCircuitOp
        !rightExpression
      }
    while
      $<<$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!"<<" !operatorLocation}
        !.leftShiftOp
        !rightExpression
      }
    while
      $>>$
      let operatorLocation = @location.here
      <primary> ?let rightExpression
      outExpression = @infixOperatorExpressionAST.new {
        !outExpression
        !.new {!">>" !operatorLocation}
        !.rightShiftOp
        !rightExpression
      }
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH FROM EXPRESSION                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mLeftExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  [mRightExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @asExpressionAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [mExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

method @infixOperatorMap checkWith
  ?leftType:let @unifiedTypeMap-proxy inLeftType
  ?rightType:let @unifiedTypeMap-proxy inRightType
  ?operator:let @lstring inOperator
  !resultType: @unifiedTypeMap-proxy outResultType
  !opString:@abstractInfixOperatorGeneration outOpString
{
  let lkey = @lstring.new {![inLeftType key] + "." + [inRightType key] !inOperator.location}
  if [self hasKey !lkey.string] then
    [self searchKey !lkey ?outResultType ?outOpString]
  else
    error inOperator
      : "infix operation '" + [inLeftType key] + " " + inOperator + " " + [inRightType key] + "' is not defined"
      : outResultType, outOpString
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @infixOperatorExpressionAST analyzeExpression
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @string inMode
  ?!temporary:@uint ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
#  !generatedCode:@abstractExpressionGeneration outGeneratedCode
  !result:@variableKindIR outResult
{
#--- Analyze left expression
  [mLeftExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let leftExpressionType
#    ?generatedCode:let leftExpressionGeneratedCode
    ?result:@variableKindIR leftResult
  ]
#--- Analyze right expression
  [mRightExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:leftExpressionType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let rightExpressionType
#    ?generatedCode:let rightExpressionGeneratedCode
    ?result:@variableKindIR rightResult
  ]
#--- Check left type
  @abstractInfixOperatorGeneration resultOperator
  @infixOperatorMap operatorMap
  switch mOp 
  case equal : operatorMap = inContext.mEqualOperatorMap
  case nonEqual : operatorMap = inContext.mNonEqualOperatorMap
  case strictInf : operatorMap = inContext.mStrictInfOperatorMap
  case infEqual : operatorMap = inContext.mInfEqualOperatorMap
  case strictSup : operatorMap = inContext.mStrictSupOperatorMap
  case supEqual : operatorMap = inContext.mSupEqualOperatorMap
  case andOp : operatorMap = inContext.mAndOperatorMap
  case andShortCircuitOp : operatorMap = inContext.mAndShortCircuitOperatorMap
  case orOp : operatorMap = inContext.mOrOperatorMap
  case orShortCircuitOp : operatorMap = inContext.mOrShortCircuitOperatorMap
  case xorOp : operatorMap = inContext.mXorOperatorMap
  case addOp : operatorMap = inContext.mAddOperatorMap
  case subOp : operatorMap = inContext.mSubOperatorMap
  case mulOp : operatorMap = inContext.mMulOperatorMap
  case divOp : operatorMap = inContext.mDivOperatorMap
  case modOp : operatorMap = inContext.mModOperatorMap
  case leftShiftOp  : operatorMap = inContext.mLeftShiftOperatorMap
  case rightShiftOp : operatorMap = inContext.mRightShiftOperatorMap
  end
  [operatorMap checkWith
    !leftType:leftExpressionType
    !rightType:rightExpressionType
    !operator:mOperator
    ?resultType:outExpressionType
    ?opString:resultOperator
  ]
#---
#  if [leftResult isLiteralUnsignedInteger] && [rightResult isLiteralUnsignedInteger] then
#    [leftResult literalUnsignedInteger ?type:let @unifiedTypeMap-proxy leftType ?value:let @luint64 leftValue]
#    [rightResult literalUnsignedInteger ?type:let @unifiedTypeMap-proxy rightType ?value:let @luint64 rihgtValue]
#  else
  #--- Temp var
    getNewTempVariable (!?ioTemporaryIndex ?outResult)
  #--- Generate code
#    outGeneratedCode = @operatorInfixExpressionGeneration.new {
#      !leftExpressionGeneratedCode
#      !resultOperator
#      !rightExpressionGeneratedCode
#    }
    ioInstructionGenerationList += !@operatorInfixExpressionIR.new {
      !outExpressionType
      !outResult
      !leftResult
      !resultOperator
      !rightResult
    }
#  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! @asExpressionAST

override method @asExpressionAST analyzeExpression
  ?optionalReceiverType:let @receiverType inReceiverType
  ?optionalTargetType:let @unifiedTypeMap-proxy inOptionalTargetType
  ?context:let @semanticContext inContext
  ?mode:let @string inMode
  ?!temporary:@uint ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !expressionType:@unifiedTypeMap-proxy outExpressionType
#  !generatedCode:@abstractExpressionGeneration outGeneratedCode
  !result:@variableKindIR outResult
{
#--- Analyze expression
  [mExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inOptionalTargetType
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let unused expressionType
#    ?generatedCode:let expressionGeneratedCode
    ?result:@variableKindIR expressionResult
  ]
#--- Analyze type
  outExpressionType = .searchKey {!inContext.mTypeMap !mTypeName}
#--- Temp var
  getNewTempVariable (!?ioTemporaryIndex ?outResult)
#--- Generate code
#  outGeneratedCode = @asOperatorInfixGeneration.new {
#    !expressionGeneratedCode
#    !outExpressionType
#  }
  ioInstructionGenerationList += !@asOperatorInstructionIR.new {
    !outExpressionType
    !outResult
    !expressionResult
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*
#! @asOperatorInstructionIR
#----------------------------------------------------------------------------------------------------------------------*

class @asOperatorInstructionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mTemporaryResultVariable
  @variableKindIR mOperand
}

#----------------------------------------------------------------------------------------------------------------------*

override method @asOperatorInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @asOperatorInstructionIR instructionCode -> @string outCode {
  outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mTemporaryResultVariable mangledName]
  outCode += " = ((" + mangledNameForType (!name:[mTargetType key]) + ") " + [mOperand mangledName] + ") ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*
#! @operatorInfixExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

class @operatorInfixExpressionIR : @abstractInstructionIR {
  @unifiedTypeMap-proxy mTargetType
  @variableKindIR mResult
  @variableKindIR mLeftOperand
  @abstractInfixOperatorGeneration mOperator
  @variableKindIR mRighOperand
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @operatorInfixExpressionIR instructionCode -> @string outCode {
  outCode = "const " + mangledNameForType (!name:[mTargetType key]) + " " + [mResult mangledName]
  outCode += " = " +  [mOperator generateCode !mLeftOperand !mRighOperand] + " ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @operatorInfixExpressionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mLeftOperand enterAccessibleEntities !?ioAccessibleEntities]
  [mRighOperand enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractInfixOperatorGeneration
#----------------------------------------------------------------------------------------------------------------------*

abstract getter @abstractInfixOperatorGeneration generateCode
  ?@variableKindIR inleft
  ?@variableKindIR inRight
  -> @string outCode

##----------------------------------------------------------------------------------------------------------------------*
#
#abstract getter @abstractInfixOperatorGeneration generateInfixExpression
#  ?@abstractExpressionGeneration inleft
#  ?@abstractExpressionGeneration inRight
#  -> @string outCode

#----------------------------------------------------------------------------------------------------------------------*
#! @standardInfixOperatorGeneration
#----------------------------------------------------------------------------------------------------------------------*

#override getter @standardInfixOperatorGeneration generateInfixExpression
#  ?@abstractExpressionGeneration inleft
#  ?@abstractExpressionGeneration inRight
#  -> @string outCode
#{
#  outCode = "(" + [inleft expressionCode] + ") " + mInfixOperator + " (" + [inRight expressionCode] + ")"
#}

#----------------------------------------------------------------------------------------------------------------------*

override getter @standardInfixOperatorGeneration generateCode
  ?@variableKindIR inleft
  ?@variableKindIR inRight
  -> @string outCode
{
  outCode = [inleft mangledName] + " " + mInfixOperator + " " + [inRight mangledName]
}

#----------------------------------------------------------------------------------------------------------------------*
#! @operatorInfixExpressionGeneration
#----------------------------------------------------------------------------------------------------------------------*

#class @operatorInfixExpressionGeneration : @abstractExpressionGeneration {
#  @abstractExpressionGeneration mLeftExpression
#  @abstractInfixOperatorGeneration mOperator
#  @abstractExpressionGeneration mRightExpression
#}
#
##----------------------------------------------------------------------------------------------------------------------*
#
#override getter @operatorInfixExpressionGeneration expressionCode -> @string outCode {
#  outCode =  [mOperator generateInfixExpression !mLeftExpression !mRightExpression]
#}

#----------------------------------------------------------------------------------------------------------------------*
#! @asOperatorInfixGeneration
#----------------------------------------------------------------------------------------------------------------------*

#class @asOperatorInfixGeneration : @abstractExpressionGeneration {
#  @abstractExpressionGeneration mExpression
#  @unifiedTypeMap-proxy mType
#}
#
##----------------------------------------------------------------------------------------------------------------------*
#
#override getter @asOperatorInfixGeneration expressionCode -> @string outCode {
#  outCode = "((" + mangledNameForType (!name:[mType key]) + ") " + [mExpression expressionCode] + ")"
#}

#----------------------------------------------------------------------------------------------------------------------*
