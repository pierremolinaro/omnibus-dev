#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @procFormalArgumentPassingMode {
  case input
  case output
  case inputOutput
}

#----------------------------------------------------------------------------------------------------------------------*

list @procFormalArgumentList {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

getter @procFormalArgumentPassingMode requiredActualPassingModeForSelector ?@string inSelector -> @string outResult {
  switch self
  case input : outResult = "!"
  case output : outResult = "?"
  case inputOutput : outResult = "!?"
  end
  if inSelector != "" then
    outResult += inSelector + ":"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

enum @procedureKindAST {
  case standAloneProc
  case structureProc (@lstring structureTypeName @bool mutating)
}

#----------------------------------------------------------------------------------------------------------------------*

list @procedureDeclarationListAST {
  @procedureKindAST mProcedureKind
  @lstringlist mProcedureModeList
  @lstring mProcedureName
  @lstringlist mProcedureAttributeList
  @procFormalArgumentList mProcFormalArgumentList
  @instructionListAST mInstructionList
  @location mEndOfProcLocation
}

#----------------------------------------------------------------------------------------------------------------------*

map @labelMap {
  insert insertKey error message "the '%K' label is already declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <procedure>
    ?procedureKind:let @procedureKindAST inProcedureKind
    ?!@procedureDeclarationListAST ioProcListAST
  {
    <procedure_header>
      ?procModes:let procModeList
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioProcListAST +=
      !inProcedureKind
      !procModeList
      !procName
      !attributeList
      !procFormalArgumentList
      !instructionList
      !.here
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <procedure_header>
    !procModes:@lstringlist outProcModeList
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@procFormalArgumentList outProcFormalArgumentList
  {
    $proc$
    $identifier$ ?outProcName
    outProcModeList = {}
    repeat
      $modeName$ ?let procMode
      outProcModeList += !procMode
    while
    end
    outAttributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:outProcFormalArgumentList
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <procedure_formal_arguments>
    !formalArguments:@procFormalArgumentList outProcFormalArgumentList
  {
    outProcFormalArgumentList = {}
    $($
    repeat
    while
      $!$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.output
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?!$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.inputOutput
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.input
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

method @procedureDeclarationListAST-element enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
#--- Enter only stand alone procedures
  switch mProcedureKind
  case standAloneProc :
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
  case structureProc (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

map @procedureMap {
  @bool mMutating
  @modeMap mProcedureModeMap
  @procedureSignature mSignature
  @bool mWeakProcedure

  insert insertKey error message "the '%K' proc is already declared in %L"
  search searchKey error message "there is no '%K' proc"
  remove removeKey error message "there is no '%K' proc"
}

#----------------------------------------------------------------------------------------------------------------------*

func mangledName
  ?forProcedureKind:let @procedureKindAST inProcedureKind
  ?procedureName:let @lstring inProcedureName
  ?formalArgumentList:@procFormalArgumentList inProcFormalArgumentList
  -> @lstring outMangledName
{
  var mangledName = ""
  switch inProcedureKind
  case standAloneProc :
  case structureProc (structureTypeName *) :
    mangledName += structureTypeName.string + "_"
  end
  mangledName += inProcedureName.string
  for (formalArgument selector * *) in inProcFormalArgumentList do
    switch formalArgument
    case input : mangledName += "?"
    case output : mangledName += "!"
    case inputOutput : mangledName += "?!"
    end
    mangledName += selector.string + ":"
  end
  outMangledName = .new {!mangledName !inProcedureName.location}
}

#----------------------------------------------------------------------------------------------------------------------*

getter @procedureDeclarationListAST-element mangledName -> @lstring outMangledName {
  outMangledName = mangledName (
    !forProcedureKind:mProcedureKind
    !procedureName:mProcedureName
    !formalArgumentList:mProcFormalArgumentList
  )
}

#----------------------------------------------------------------------------------------------------------------------*

method @procedureDeclarationListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
#--- Enter only stand alone procedures
  switch mProcedureKind
  case standAloneProc :
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in mProcFormalArgumentList do
      [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
      signature += !formalArgumentPassingMode !selector.string !typeProxy
    end
  #--- Mode map
    @modeMap procedureModeMap = {}
    for () in mProcedureModeList do
      [!?procedureModeMap insertKey !mValue] ;
    end
  #--- Weak procedure ?
    var weakProcedure = false
    for (attribute) in mProcedureAttributeList while not weakProcedure do
      weakProcedure = attribute.string == weakAttribute ()
    end
  #--- Enter in context
    let mangledName = [self mangledName]
    if [ioContext.mProcedureMap hasKey !mangledName.string] then
      let weak = [ioContext.mProcedureMap mWeakProcedureForKey !mangledName.string]
      if weakProcedure && not weak then
        # redefined weak procedure is ignored
      elsif weakProcedure && weak then
        error mProcedureName : "this weak procedure overrides a weak procedure"
      elsif (not weakProcedure) && weak then
        [!?ioContext.mProcedureMap removeKey !mangledName ?4*] # Remove weak routine
        [!?ioContext.mProcedureMap insertKey # Insert routine
          !mangledName
          !false # not mutating
          !procedureModeMap
          !signature
          !weakProcedure
        ]
      else # (not weakProcedure) && (not weak)
        [!?ioContext.mProcedureMap insertKey # Raises a redefinition error
          !mangledName
          !false # not mutating
          !procedureModeMap
          !signature
          !weakProcedure
        ]
      end
    else
      [!?ioContext.mProcedureMap insertKey
        !mangledName
        !false # not mutating
        !procedureModeMap
        !signature
        !weakProcedure
      ]
    end
  case structureProc (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

list @procFormalArgumentListForGeneration {
  @procFormalArgumentPassingMode mFormalArgumentKind
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

graph @subprogramInvocationGraph (@lstringlist) {
  insert addNode error message "the '%K' subprogram is already declared at %L"
}

#----------------------------------------------------------------------------------------------------------------------*

method @procedureDeclarationListAST-element procedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check modes
  @stringset procedureModeSet = {}
  for mode in mProcedureModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    procedureModeSet += !mode.mValue.string
  end
#--- Attribues
  var warnIfUnused = true
  var weakProcedure = false
  var nullOnNoException = false
  for (attribute) in mProcedureAttributeList do
    if attribute.string == noWarningIfUnusedAttribute () then
      if not warnIfUnused then
        error attribute : "duplicate @" + noWarningIfUnusedAttribute () + " attribute"
      end
      warnIfUnused = false    
    elsif attribute.string == weakAttribute () then
      if weakProcedure then
        error attribute : "duplicate @" + weakAttribute () + " attribute"
      end
      weakProcedure = true    
    elsif attribute.string == nullWhenPanicDisabledAttribute () then
      if nullOnNoException then
        error attribute : "duplicate @" + nullWhenPanicDisabledAttribute () + " attribute"
      end
      nullOnNoException = true    
    else
      error attribute : "unknown attribute; available attributes are @"
        + noWarningIfUnusedAttribute ()
        + ", @" + weakAttribute ()
    end
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineMangledName:"proc " + [self mangledName]
    !context:inContext
    !globalsAreConstant:false
  )
#--- Add receiver properties, and receiver as first argument
  @procFormalArgumentListForGeneration formalArguments = {}
  @receiverType receiverType
  switch mProcedureKind
  case standAloneProc :
    receiverType = .noReceiver
  case structureProc (structureTypeName mutating) :
    let type = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !structureTypeName}
    @propertyMap propertyMap
    switch [type kind]
    case structure (* propMap *) : propertyMap = propMap
    case enumeration (*) : propertyMap = {}
    case integer (* * * *) : propertyMap = {}
    case literalInteger : propertyMap = {}
    case boolean : propertyMap = {}
    case boolset : propertyMap = {}
    case literalString : propertyMap = {}
    end
    if mutating then
      receiverType = .mutatingReceiver {
        !type:type
        !receiverPointer:receiverPtrName ()
      }
      for (propertyName propertyType idx) in propertyMap do
        [!?variableMap insertDefinedLocalVariable
          !propertyName
          !propertyType
          !true
          !.fieldAccess {
            !objectType:type
            !objectName:""
            !fielfType:propertyType
            !fieldIndex:idx
          }
          ![propertyType copiable]
          !{}
          !true
          !false # Is not constant
        ]
      end
      formalArguments += !.inputOutput !type !receiverPtrName ()
    else
      receiverType = .receiver {
        !type:type
        !receiverValue:receiverName ()
      }
      for (propertyName propertyType idx) in propertyMap do
        [!?variableMap insertUsedLocalConstant
          !propertyName
          !propertyType
          !true
          !.fieldAccess {
            !objectType:type
            !objectName:""
            !fielfType:propertyType
            !fieldIndex:idx
          }
          ![propertyType copiable]
          !{}
          !true
          !true # Is constant
        ]
      end
      formalArguments += !.input !type !receiverName ()
    end%if
  end
#--- Analyse formal arguments
  for (argumentKind selector formalArgumentTypeName formalArgumentName) in mProcFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    switch argumentKind
    case input :
      [!?variableMap insertConstantInputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !true
        !true # Is constant
      ]
      formalArguments += !argumentKind !typeProxy !mangledNameForLocalVariable (!formalArgumentName.string)
    case inputOutput :
      [!?variableMap insertInputOutputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !true
        !false # Is not constant
      ]
      formalArguments += !argumentKind !typeProxy !mangledNameForLocalVariable (!formalArgumentName.string)
    case output :
      [!?variableMap insertOutputFormalArgument
        !formalArgumentName
        !typeProxy
        !true
        !.localValue {!type:typeProxy !name:formalArgumentName.string}
        ![typeProxy copiable]
        !{}
        !true
        !false # Is not constant
      ]
      formalArguments += !argumentKind !typeProxy !mangledNameForLocalVariable (!formalArgumentName.string)
    end
  end
#--- Enter subprogram invocation graph
  let procNameForInvocationGraph = @lstring.new {!"proc " + [self mangledName] !mProcedureName.location}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !procNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !procNameForInvocationGraph
      !mProcedureName
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:procNameForInvocationGraph
    !optionalReceiverType:receiverType
    !context:inContext
    !modes:procedureModeSet
    !allowException:not [procedureModeSet hasKey !panicModeName ()]
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfProcLocation]
#--- Code generation
  if [ioIntermediateCodeStruct.mProcedureMapIR hasKey !mProcedureName.string] then
    let weak = [ioIntermediateCodeStruct.mProcedureMapIR mWeakForKey !mProcedureName.string]
    if weakProcedure && not weak then
      # redefined weak procedure is ignored
    elsif weakProcedure && weak then
      error mProcedureName : "this weak procedure overrides a weak procedure"
    elsif (not weakProcedure) && weak then
      [!?ioIntermediateCodeStruct.mProcedureMapIR removeKey !mProcedureName ?6*] # Remove weak routine
      [!?ioIntermediateCodeStruct.mProcedureMapIR insertKey
        !mProcedureName
        !formalArguments
        !instructionGenerationList
        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !mProcedureName.string]
        !warnIfUnused
        !weakProcedure
        !nullOnNoException
      ]  
    else # (not weakProcedure) && (not weak)
      [!?ioIntermediateCodeStruct.mProcedureMapIR insertKey # Raises a redefinition error
        !mProcedureName
        !formalArguments
        !instructionGenerationList
        ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !mProcedureName.string]
        !warnIfUnused
        !weakProcedure
        !nullOnNoException
      ]
    end
  else
    [!?ioIntermediateCodeStruct.mProcedureMapIR insertKey
      !mProcedureName
      !formalArguments
      !instructionGenerationList
      ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !mProcedureName.string]
      !warnIfUnused
      !weakProcedure
      !nullOnNoException
    ]  
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

method @procedureMapIR-element llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?!@string ioAssemblerCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let procName = mangledNameForProcedure (!lkey.string)
  if [option plm_options.noPanicGeneration value] && mNullOnNoException then
  #--- Generate in assembly code routine pointer as NULL value
    ioAssemblerCode += asSeparatorLine ()
    ioAssemblerCode += "  .global " + procName + "\n"
    ioAssemblerCode += "  " + procName + " = 0\n\n"
  #--- In LLVM, declare routine as extern
    ioLLVMcode += llvmTitleComment (!"proc " + procName)
    ioLLVMcode += "declare void @" + procName + " ("
    for () in mFormalArgumentListForGeneration
    do
      switch mFormalArgumentKind
      case input :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
      case output :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
     case inputOutput :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ") nounwind ; NULL in assembly code\n\n"
  else
    ioLLVMcode += llvmTitleComment (!"proc " + procName)
    ioLLVMcode += "define internal void @" + procName + " ("
    for () in mFormalArgumentListForGeneration
    do
      switch mFormalArgumentKind
      case input :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
      case output :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
     case inputOutput :
        ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
      end
    between
      ioLLVMcode += ", "
    end
    ioLLVMcode += ") nounwind {\n"
  #--- Store input arguments in memory
    for () in mFormalArgumentListForGeneration do
      switch mFormalArgumentKind
      case input :
        let llvmType = [mFormalArgumentType llvmTypeName]
        ioLLVMcode += "  %" + mFormalArgumentName + " = alloca " + [mFormalArgumentType llvmTypeName] + "\n"
        ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + "* %" + mFormalArgumentName + "\n"
      case output, inputOutput :
      end
    end
   
  #--- Instruction list
    [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
  #--- Epilog
    ioLLVMcode += ";--- return\n"
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

