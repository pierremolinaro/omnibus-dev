#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

enum @procFormalArgumentPassingMode {
  case input
  case output
  case inputOutput
}

#----------------------------------------------------------------------------------------------------------------------*

getter @procFormalArgumentPassingMode requiredActualPassingModeForSelector ?@lstring inSelector -> @string outResult {
  switch self
  case input : outResult = "!"
  case output : outResult = "?"
  case inputOutput : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

list @procFormalArgumentList {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

enum @procedureKindAST {
  case standAloneProc
  case structureProc (@lstring structureTypeName @bool mutating)
}

#----------------------------------------------------------------------------------------------------------------------*

list @procedureDeclarationListAST {
  @procedureKindAST mProcedureKind
  @lstring mProcedureMode
  @lstring mProcedureName
  @procFormalArgumentList mProcFormalArgumentList
  @instructionListAST mInstructionList
  @location mEndOfProcLocation
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <procedure>
    ?procedureKind:let @procedureKindAST inProcedureKind
    ?!@procedureDeclarationListAST ioProcListAST
  {
    <procedure_header>
      ?procMode:let procMode
      ?name:let procName
      ?formalArguments:let procFormalArgumentList
    ${$
    <instructionList> ?let instructionList
    $}$
    ioProcListAST += !inProcedureKind !procMode !procName !procFormalArgumentList !instructionList !.here
  }

  #--------------------------------------------------------------------------------------------------------------------*

  rule <procedure_header>
    !procMode:@lstring outProcMode
    !name:@lstring outProcName
    !formalArguments:@procFormalArgumentList outProcFormalArgumentList
  {
    $proc$
    select
      outProcMode = .new {!"" !.here}
    or
      $modeName$ ?outProcMode
    end
    $identifier$ ?outProcName
    outProcFormalArgumentList = {}
    $($
    repeat
    while
      $!$ ?let selector
      $identifier$ ?let formalArgumentName
      $:$
      $identifier$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.output
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?!$ ?let selector
      $identifier$ ?let formalArgumentName
      $:$
      $identifier$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.inputOutput
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $:$
      $identifier$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.input
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

method @procedureDeclarationListAST-element enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
#--- Enter only stand alone procedures
  switch mProcedureKind
  case standAloneProc :
    for (* * formalArgumentTypeName *) in mProcFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
  case structureProc (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

list @procedureSignature {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @unifiedTypeMap-proxy mType
}

#----------------------------------------------------------------------------------------------------------------------*

map @procedureMap {
  @bool mMutating
  @lstring mProcedureMode
  @procedureSignature mSignature

  insert insertKey error message "the '%K' proc is already declared in %L"
  search searchKey error message "there is no '%K' proc"
}

#----------------------------------------------------------------------------------------------------------------------*

func mangledName
  ?forProcedureKind:let @procedureKindAST inProcedureKind
  ?procedureName:let @string inProcedureName
  ?formalArgumentList:@procFormalArgumentList inProcFormalArgumentList
  -> @string outMangledName
{
  outMangledName = ""
  switch inProcedureKind
  case standAloneProc :
  case structureProc (structureTypeName *) :
    outMangledName += structureTypeName.string + "_"
  end
  outMangledName += inProcedureName
  for (formalArgument selector * *) in inProcFormalArgumentList do
    outMangledName += " "
    switch formalArgument
    case input : outMangledName += "?"
    case output : outMangledName += "!"
    case inputOutput : outMangledName += "?!"
    end
    outMangledName += selector.string
  end
}

#----------------------------------------------------------------------------------------------------------------------*

getter @procedureDeclarationListAST-element mangledName -> @string outMangledName {
  outMangledName = mangledName (
    !forProcedureKind:mProcedureKind
    !procedureName:mProcedureName.string
    !formalArgumentList:mProcFormalArgumentList
  )
}

#----------------------------------------------------------------------------------------------------------------------*

method @procedureDeclarationListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
#--- Enter only stand alone procedures
  switch mProcedureKind
  case standAloneProc :
  #--- Signature
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in mProcFormalArgumentList do
      [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
      signature += !formalArgumentPassingMode !selector !typeProxy
    end
  #--- Enter in context
    [!?ioContext.mProcedureMap insertKey
      !.new {
        ![self mangledName]
        !mProcedureName.location
      }
      !false # not mutating
      !mProcedureMode
      !signature
    ]
  case structureProc (* *) :
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

list @procFormalArgumentListForGeneration {
  @procFormalArgumentPassingMode mFormalArgumentKind
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

method @procedureDeclarationListAST-element procedureSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@uint ioTemporaryIndex
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check mode
  if mProcedureMode.string != "" then
    [inContext.mModeMap searchKey !mProcedureMode]
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (!context:inContext !globalsAreConstant:false)
#--- Add receiver properties, and receiver as first argument
  @procFormalArgumentListForGeneration formalArguments = {}
  @receiverType receiverType
  switch mProcedureKind
  case standAloneProc :
    receiverType = .noReceiver
  case structureProc (structureTypeName mutating) :
    let type = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !structureTypeName}
    @propertyList propertyList
    switch [type kind]
    case structure (propList) : propertyList = propList
    case enumeration (*) : propertyList = {}
    case integer (* *) : propertyList = {}
    case boolean : propertyList = {}
    case boolset : propertyList = {}
    case literalString : propertyList = {}
    end
    if mutating then
      receiverType = .mutatingReceiver {
        !type:type
        !receiverPointer:receiverPtrName ()
      }
      for (propertyType propertyName) in propertyList do
        [!?variableMap insertDefinedLocalVariable
          !propertyName
          !propertyType
          !{!mProcedureMode.string}
          !receiverPtrName () + "->" + mangledNameForProperty (!name:propertyName.string)
          !.localAccess {!access:receiverPtrName () + "->" + mangledNameForProperty (!name:propertyName.string)}
          ![propertyType copiable]
        ]
      end
      formalArguments += !.inputOutput !type !receiverPtrName ()
    else
      receiverType = .receiver {
        !type:type
        !receiverValue:receiverName ()
      }
      for (propertyType propertyName) in propertyList do
        [!?variableMap insertUsedLocalConstant
          !propertyName
          !propertyType
          !{!mProcedureMode.string}
          !receiverName () + "." + mangledNameForProperty (!name:propertyName.string)
          !.localAccess {!access:receiverName () + "." + mangledNameForProperty (!name:propertyName.string)}
          ![propertyType copiable]
        ]
      end
      formalArguments += !.input !type !receiverName ()
    end%if
  end
#--- Analyse formal arguments
  for (argumentKind * formalArgumentTypeName formalArgumentName) in mProcFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    switch argumentKind
    case input :
      [!?variableMap insertConstantInputFormalArgument
        !formalArgumentName
        !typeProxy
        !{!mProcedureMode.string}
        !mangledNameForInArgument (!name:formalArgumentName.string)
        !.inArgument {!name:formalArgumentName.string}
        ![typeProxy copiable]
      ]
      formalArguments += !argumentKind !typeProxy !mangledNameForInArgument (!name:formalArgumentName.string)
    case inputOutput :
      [!?variableMap insertInputOutputFormalArgument
        !formalArgumentName
        !typeProxy
        !{!mProcedureMode.string}
        !"*" + mangledNameForInOutArgument (!name:formalArgumentName.string)
        !.inOutArgument {!name:formalArgumentName.string}
        ![typeProxy copiable]
      ]
      formalArguments += !argumentKind !typeProxy !mangledNameForInOutArgument (!name:formalArgumentName.string)
    case output :
      [!?variableMap insertOutputFormalArgument
        !formalArgumentName
        !typeProxy
        !{!mProcedureMode.string}
        !"*" + mangledNameForOutArgument (!name:formalArgumentName.string)
        !.outArgument {!name:formalArgumentName.string}
        ![typeProxy copiable]
      ]
      formalArguments += !argumentKind !typeProxy !mangledNameForOutArgument (!name:formalArgumentName.string)
    end
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !optionalReceiverType:receiverType
    !context:inContext
    !mode:mProcedureMode.string
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioIntermediateCodeStruct.mGlobalLiteralStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfProcLocation]
#--- Code generation
  [!?ioIntermediateCodeStruct.mProcedureMapIR insertKey
    !mProcedureName
    !formalArguments
    !instructionGenerationList
    ![ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !mProcedureName.string]
  ]  
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper procedureGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "procedure-declaration.galgasTemplate"
    ?@string PROCEDURE_MANGLED_NAME
    ?@procFormalArgumentListForGeneration FORMAL_ARGUMENT_LIST

  template implementation "procedure-implementation.galgasTemplate"
    ?@string PROCEDURE_MANGLED_NAME
    ?@procFormalArgumentListForGeneration FORMAL_ARGUMENT_LIST
    ?@instructionListIR INSTRUCTION_GENERATION_LIST
}

#----------------------------------------------------------------------------------------------------------------------*

getter @procedureMapIR-element headerCodeGeneration -> @string outCode {
  outCode = [filewrapper procedureGenerationTemplate.declaration
    !mangledNameForProcedure (!name:lkey.string) # mProcedureMangledName
    !mFormalArgumentListForGeneration
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

getter @procedureMapIR-element implementationCodeGeneration -> @string outCode {
  outCode = [filewrapper procedureGenerationTemplate.implementation
    !mangledNameForProcedure (!name:lkey.string) # mProcedureMangledName
    !mFormalArgumentListForGeneration
    !mInstructionGenerationList
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

