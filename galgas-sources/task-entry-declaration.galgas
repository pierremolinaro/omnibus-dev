#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @taskEntryListAST {
  @lstring mEntryName
  @routineFormalArgumentListAST mEntryFormalArgumentList
  @lstring mEntryReturnTypeName
  @lstringlist mEntryPath
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <task_entry_declaration> ?!@ast ioAST ?!@taskEntryListAST ioTaskEntryListAST {
    $entry$
    $identifier$ ?let entryName
    warning entryName : "obsolete"
    $:$
    $self$
    $.$
    @lstringlist entryPath = {}
    repeat
      $identifier$ ?let propertyName
      entryPath += !propertyName
    while
      $.$
    end
    <procedure_formal_arguments> !?ioAST ?let @routineFormalArgumentListAST formalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition> !?ioAST ?returnTypeName
    end
    ioTaskEntryListAST += !entryName !formalArgumentList !returnTypeName !entryPath
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskEntryListAST-element enterInContext
  ?taskName:let @lstring inTaskName
  ?!context:@semanticContext ioContext
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!@decoratedTaskEntryList ioDecoratedTaskEntryList 
  ?!@propertyMap ioTaskPropertyMap
{
#--- Attributes
  let exportedRoutine = true # [attributeSet hasKey !exportedAttribute ()]
  let canMutateProperties = true # [attributeSet hasKey !mutatingAttribute ()]
#--- Entry mangled name
  let entryMangledName = routineMangledNameFromAST (!"" !mEntryName !mEntryFormalArgumentList)
#--- Entry signature
  routineSignature (!?ioContext.mTypeMap !mEntryFormalArgumentList ?let entrySignature)
#--- Return type
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !mEntryReturnTypeName ?let returnTypeProxy]
#--- Routine descriptor
  let descriptor = @routineDescriptor.new {
    !isPublic:true
    !exported:exportedRoutine
    !routineKind:.function {!executionMode:.userMode}
    !signature:entrySignature
    !returnTypeProxy:returnTypeProxy
    !canAccessProperties:true
    !canMutateProperties:canMutateProperties
  }
#--- Enter in structure map
  [!?ioTaskPropertyMap insertKey !entryMangledName !true !.nonVirtualMethod {!descriptor:descriptor}]
#--- Extract method name
   var propertyAccessPath = mEntryPath
   [!?propertyAccessPath popLast ?let methodName]
#--- Enter in decorated entry list
  ioDecoratedTaskEntryList +=
    !mEntryName
    !mEntryFormalArgumentList
    !entrySignature
    !returnTypeProxy
    !propertyAccessPath
    !methodName
#--- Invocation graph
  let entryMangledNameForInvocationGraph = routineMangledNameFromAST (
    !llvmTypeStringFromPLMname (!inTaskName)
    !mEntryName
    !mEntryFormalArgumentList
  )
  [!?ioSubprogramInvocationGraph addNode !entryMangledNameForInvocationGraph !entryMangledNameForInvocationGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @decoratedTaskEntryList {
  @lstring mEntryName
  @routineFormalArgumentListAST mEntryFormalArgumentList
  @routineTypedSignature mEntrySignature
  @unifiedTypeMap-proxy mEntryReturnTypeProxy
  @lstringlist mEntryPath
  @lstring mInvokedMethodName
}

#·······················································································································

method @decoratedTaskEntryList-element taskEntrySemanticAnalysis
  ?taskType:let @PLMType inTaskType
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Analyze property path
  @instructionListIR instructionGenerationList = {}
  var currentType = inTaskType
  var currentLLVMName = llvmNameForSelf ()
  for (propertyName) in mEntryPath do
    [currentType.propertyMap searchKey !propertyName ?let @bool unused isPublic ?let propertyAccessKind]
    switch propertyAccessKind
    case constantProperty (*) :
      error propertyName : "a constant property is not allowed here"
    case indexed (@PLMType type @uint index) :
      if [type copyable] then
        error propertyName : "the property type $" + type.plmTypeName + " is copyable"
      end
      [!?ioTemporaries newTempLLVMVar ?let llvmName]
      [!?instructionGenerationList appendGetUniversalPropertyReference
        !currentType
        !currentLLVMName
        !llvmName
        !index
        !propertyName
      ]
      currentType = type
      currentLLVMName = llvmName
    case nonVirtualMethod (*) :
      error propertyName : "a non virtual method is not allowed here"
    end
  end
#--- Invoked method mangled name
  let invokedMethodMangledName = routineMangledNameFromAST (!"" !mInvokedMethodName !mEntryFormalArgumentList)
#--- Analyze invoked method
  [currentType.propertyMap searchKey !invokedMethodMangledName ?let @bool unused isPublic ?let methodAccessKind]
  switch methodAccessKind
  case constantProperty (*) :
    error mInvokedMethodName : "a constant property is not allowed here"
  case indexed (* *) :
    error mInvokedMethodName : "a property is not allowed here"
  case nonVirtualMethod (@routineDescriptor descriptor) :
    if mEntryReturnTypeProxy != descriptor.returnTypeProxy then
      error mEntryName
      : "entry return type does not conform to invoked method return type"
    end
  #--- Invocation graph
    let entryMangledNameForInvocationGraph = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (!inTaskType.plmTypeName) # mTaskName)
      !mEntryName
      !mEntryFormalArgumentList
    )
    let returnType = if mEntryReturnTypeProxy == .null then
      voidType ()
    else
      [mEntryReturnTypeProxy type]
    end
    let invokedMethodMangledNameForInvocationGraph = routineMangledNameFromAST (
      !llvmTypeStringFromPLMname (!currentType.plmTypeName)
      !mInvokedMethodName
      !mEntryFormalArgumentList
    )
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge
      !entryMangledNameForInvocationGraph
      !invokedMethodMangledNameForInvocationGraph
    ]
  #--- Analyse formal arguments
    @routineFormalArgumentListIR formalArguments = {}
    enterFormalArguments (
      !context:inContext
      !mEntryFormalArgumentList
      !?*
      !?formalArguments
    )
  #--- Check modes
    let calleeKind = checkMode (
      !callerMode:.userMode
      !calleeMode:.userMode
      !kind:descriptor.routineKind
      !error:mInvokedMethodName.location
    )
  #--- Build arguments
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    effectiveParameterListIR += !.outputInput !.reference {!type:currentType !llvmName:currentLLVMName}
    for (kind type name) in formalArguments do
      switch kind
      case input :
        effectiveParameterListIR += !.output !.reference {!type:type !llvmName:"%in." + name}
      case output :
         effectiveParameterListIR += !.input !.llvmValue {!type:type !llvmName:"%var." + name}
     case inputOutput :
        effectiveParameterListIR += !.outputInput !.reference {!type:type !llvmName:"%var." + name}
      end
    end
  #--- Generate call instruction
    instructionGenerationList += !@standaloneRoutineCallIR.new {
      !mInvokedMethodName
      !.null # No result
      !invokedMethodMangledNameForInvocationGraph
      !invokedMethodMangledNameForInvocationGraph # LLVMInvocationRoutineName
      !calleeKind
      !effectiveParameterListIR
    }
    [!?ioIntermediateCodeStruct.mRoutineMapIR insertKey # Raises a redefinition error
      !entryMangledNameForInvocationGraph
      !inTaskType
      !entryMangledNameForInvocationGraph
      !formalArguments
      !{} # allocaList
      !instructionGenerationList
      !false # [ioIntermediateCodeStruct.mRequiredProcedureSet hasKey !routineMangledName.string]
      !true # inWarnIfUnused
      !false # inGlobalFunction
      !.function {!executionMode:.userMode}
      !returnType
      !false
    ]

  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
