#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @bootList {
  @location mBootLocation
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
  @bigint mPriority
  @location mPriorityLocation
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $boot$
    $integer$ ?let @lbigint priority
    ${$
    <instructionList> ?let instructionList
    let endOfInit = @location.here
    $}$
    ioAST.mBootListAST +=
      !priority.location
      !instructionList
      !endOfInit
      !priority.bigint
      !priority.location
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @bootRoutinePriorityMap {
  insert insertKey error message "a boot routine with priority %K has been already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootList-element bootSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [!?ioTemporaries.mBootRoutinePriorityMap insertKey !.new{![mPriority string] !mPriorityLocation}]
#---
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mPriority !mPriorityLocation}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Variable map
  initialVariableMap (
    !context:inContext
    !mode:.bootMode
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
#    ?*
    ?@universalPropertyAndRoutineMapForContext universalMap
  )
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList bootAllocaList = {}
  [mInstructionList analyzeRoutineInstructionList
    !self:.void
    !directAccessToPropertiesAllowed:false
    !propertiesAreMutable:false
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.bootMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
#    !?variableMap:variableMap
    !?variableMap:universalMap
    !?alloca:bootAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
#  [variableMap deinitTopLevelVariables]
  [universalMap checkLocalVariableFinalState]
#  [variableMap checkAutomatonStates !mEndOfBootLocation]
#  drop variableMap
#--- Code generation
  ioIntermediateCodeStruct.mBootList +=
    !mPriority
    !mBootLocation
    !bootAllocaList
    !instructionGenerationList
    !mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @bootListIR {
  @bigint mBootIndex
  @location mInitLocation
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

