#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @bootList {
  @location mBootLocation
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
  @lbigint mPriority
}{
  mPriority <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $boot$
    $integer$ ?let @lbigint priority
    ${$
    <instructionList> ?let instructionList
    let endOfInit = @location.here
    $}$
    ioAST.mBootListAST +=
      !priority.location
      !instructionList
      !endOfInit
      !priority
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootList noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootList enterInContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
{
#---------------- Add decorated declaration
  for boot in self do
    ioDecoratedDeclarationList += !@decoratedBootRoutine.new {
      !boot.mBootLocation
      !boot.mInstructionList
      !boot.mEndOfBootLocation
      !boot.mPriority
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @bootRoutinePriorityMap {
  insert insertKey error message "a boot routine with priority %K has been already declared"
}

#·······················································································································

class @decoratedBootRoutine : @abstractDecoratedDeclaration {
  @location mBootLocation
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
  @lbigint mPriority
}

#·······················································································································

override method @decoratedBootRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [!?ioTemporaries.mBootRoutinePriorityMap insertKey !.new{![mPriority.bigint string] !mPriority.location}]
#---
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mPriority.bigint !mPriority.location}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Variable map
  initialVariableMap (
    !context:inContext
    !mode:.bootMode
    !globalsAreConstant:false
    !returnTypeName:["" nowhere]
    ?@universalValuedObjectMapForContext universalMap
  )
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList bootAllocaList = {}
  [mInstructionList analyzeRoutineInstructionList
    !self:voidType ()
    !directAccessToPropertiesAllowed:false
    !propertiesAreMutable:false
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.bootMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:universalMap
    !?alloca:bootAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState]
#--- Code generation
  ioIntermediateCodeStruct.mBootList +=
    !mPriority
    !mBootLocation
    !bootAllocaList
    !instructionGenerationList
    !mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @bootListIR {
  @bigint mBootIndex
  @location mInitLocation
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

