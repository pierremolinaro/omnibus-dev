#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @bootAST : @abstractDeclarationAST {
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
  @lbigint mPriority
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $boot$
    $integer$ ?let @lbigint priority
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfInit = @location.here
    $}$
    ioAST.mDeclarationListAST += !@bootAST.new {
      !instructionList
      !endOfInit
      !priority
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @bootAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {!"boot " + mPriority.bigint !mPriority.location}
 [!?ioGraph addNode !nodeName !self]
}

#·······················································································································

override getter @bootAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "boot " + mPriority.bigint 
}

#·······················································································································

override getter @bootAST location -> @location outLocation {
  outLocation = mPriority.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @bootAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @bootAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Enter in invocation graph
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mPriority.bigint !mPriority.location}
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedBootRoutine.new {
    !mInstructionList
    !mEndOfBootLocation
    !mPriority
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @bootRoutinePriorityMap {
  insert insertKey error message "a boot routine with priority %K has been already declared"
}

#·······················································································································

class @decoratedBootRoutine : @abstractDecoratedDeclaration {
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
  @lbigint mPriority
}

#·······················································································································

override method @decoratedBootRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  [!?ioTemporaries.mBootRoutinePriorityMap insertKey !.new{![mPriority.bigint string] !mPriority.location}]
#---
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mPriority.bigint !mPriority.location}
#--- Variable map
  var universalMap = inContext.mValuedObjectMapForContext
#  initialVariableMap (
#    !context:inContext
##    !mode:.bootMode
##    !globalsAreConstant:false
##    !returnTypeName:["" nowhere]
#    ?@universalValuedObjectMapForContext universalMap
#  )
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList bootAllocaList = {}
  [mInstructionList analyzeRoutineInstructionList
    !self:voidType ()
    !instructionAttributes:.none
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.bootMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:universalMap
    !?alloca:bootAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState]
  [!?universalMap closeBranch !mEndOfBootLocation]
  [!?universalMap closeOverride !mEndOfBootLocation]
#--- Code generation
  ioIntermediateCodeStruct.mBootList +=
    !mPriority.bigint
    !mPriority.location
    !bootAllocaList
    !instructionGenerationList
    !mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @bootListIR {
  @bigint mBootIndex
  @location mInitLocation
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}{
  mBootIndex <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootListIR generateCode 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Boot routines")
  ioLLVMcode += "define internal void @boot ()" + llvmAttributeFunction () + "{\n"
  for boot in self do
    ioLLVMcode += "  call void @boot." + boot.mBootIndex + " ()\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
  for boot in self do
    ioLLVMcode += llvmSeparatorLine () + "\n"
    ioLLVMcode += "define internal void @boot." + boot.mBootIndex + " ()" + llvmAttributeFunction () + "{\n"
    for (variable LLVMTypeName) in boot.mAllocaList do
      ioLLVMcode += "  " + variable + " = alloca " + LLVMTypeName + "\n"
    end
    [boot.mInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

