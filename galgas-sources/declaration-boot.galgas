#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @bootAST : @abstractDeclarationAST {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @location mBootLocation
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration_boot> ?!@ast ioAST ?let @lstring inDriverName  ?let @lstringlist inDependanceList !@bootAST outBoot {
    $boot$
    let bootLocation = @location.here
    ${$
    <instructionList> !?ioAST ?let instructionList
    let endOfInit = @location.here
    $}$
    outBoot = .new {
      !inDriverName
      !inDependanceList
      !bootLocation
      !instructionList
      !endOfInit
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @bootAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
 let nodeName = @lstring.new {!"boot " + mDriverName !mDriverName.location}
 [!?ioGraph addNode !nodeName !self]
 [!?ioGraph addEdge !nodeName !mDriverName]
 for (dependanceDriverName) in mDriverDependanceList do
   let dependanceNodeName = @lstring.new {!"boot " + dependanceDriverName !dependanceDriverName}
   [!?ioGraph addEdge !nodeName !dependanceNodeName]
 end
}

#·······················································································································

override getter @bootAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "boot " + mDriverName 
}

#·······················································································································

override getter @bootAST location -> @location outLocation {
  outLocation = mBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @bootAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @bootAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#--- Enter in invocation graph
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mDriverName !mDriverName}
  [!?ioSubprogramInvocationGraph addNode !routineNameForInvocationGraph !routineNameForInvocationGraph]
#---------------- Add decorated declaration
  ioDecoratedDeclarationList += !@decoratedBootRoutine.new {
    !mDriverName
    !mDriverDependanceList
    !mBootLocation
    !mInstructionList
    !mEndOfBootLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @bootRoutinePriorityMap {
  insert insertKey error message "a boot routine with priority %K has been already declared"
}

#·······················································································································

class @decoratedBootRoutine : @abstractDecoratedDeclaration {
  @lstring mDriverName
  @lstringlist mDriverDependanceList
  @location mBootLocation
  @instructionListAST mInstructionList
  @location mEndOfBootLocation
}

#·······················································································································

override method @decoratedBootRoutine semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#---
  let routineNameForInvocationGraph = @lstring.new  {!"boot " + mDriverName !mDriverName.location}
  [!?ioTemporaries.mBootRoutinePriorityMap insertKey !routineNameForInvocationGraph]
#--- Variable map
  var universalMap = inContext.mValuedObjectMap
  [!?universalMap openOverrideForSelectBlock]
  [!?universalMap openBranch]
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  @allocaList bootAllocaList = {}
  [mInstructionList analyzeRoutineInstructionList
    !self:voidType ()
    !routineAttributes:.boot | .controlRegisterReadable
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !mode:.bootMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:universalMap
    !?alloca:bootAllocaList
    !?generatedCode:instructionGenerationList
  ]
#--- End of variableMap
  [universalMap checkLocalVariableFinalState]
  [!?universalMap closeBranch !mEndOfBootLocation]
  [!?universalMap closeOverride !mEndOfBootLocation]
#--- Code generation
  ioIntermediateCodeStruct.mBootList +=
    !mDriverName.string
    !bootAllocaList
    !instructionGenerationList
    !mEndOfBootLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @bootListIR {
  @string mDriverName
  @allocaList mAllocaList
  @instructionListIR mInstructionListIR
  @location mEndOfInitLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @bootListIR generateCode 
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"Boot routines")
  ioLLVMcode += "define internal void @boot ()" + llvmAttributeFunction () + "{\n"
  for boot in self do
    ioLLVMcode += "  call void @boot." + boot.mDriverName + " ()\n"
  end
  ioLLVMcode += "  ret void\n"
  ioLLVMcode += "}\n\n"
  for boot in self do
    ioLLVMcode += llvmSeparatorLine () + "\n"
    ioLLVMcode += "define internal void @boot." + boot.mDriverName + " ()" + llvmAttributeFunction () + "{\n"
    for (variable LLVMTypeName) in boot.mAllocaList do
      ioLLVMcode += "  " + variable + " = alloca " + LLVMTypeName + "\n"
    end
    [boot.mInstructionListIR instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  ret void\n"
    ioLLVMcode += "}\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

