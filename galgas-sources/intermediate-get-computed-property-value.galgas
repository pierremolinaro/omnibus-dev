
setter @instructionListIR appendGetComputedPropertyValue
  ?!@semanticTemporariesStruct ioTemporaries
  ?let @objectIR inReceiverIR
  ?let @string inProperyName
  ?let @PLMType inResultType
  !@objectIR outResultValueIR
{
 [!?ioTemporaries newTempLLVMVar ?let result_llvmName]
 outResultValueIR = .llvmValue {!type:inResultType !llvmName:result_llvmName}
  self += !@getComputedPropertyValueIR.new {!inReceiverIR !inProperyName !outResultValueIR}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @getComputedPropertyValueIR : @abstractInstructionIR {
  @objectIR mReceiverIR
  @string mPropertyName
  @objectIR mResultValueIR
}

#·······················································································································

override method @getComputedPropertyValueIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  let llvmRoutineName = "get." + [[mReceiverIR type] llvmBaseTypeName] + "." + mPropertyName
  ioLLVMcode += "  " + [mResultValueIR llvmName] + " = call " + [[mResultValueIR type] llvmTypeName]
  ioLLVMcode += " @" + [llvmRoutineName assemblerRepresentation] 
  ioLLVMcode += " (" + [[mReceiverIR type] llvmTypeName] + "* " + [mReceiverIR llvmName] + ")\n"
}

#·······················································································································

override method @getComputedPropertyValueIR enterAccessibleEntities
  ?!@stringset ioInvokedRoutineSet
  ?!@uint unused ioMaxBranchOfOnInstructions
{
  let llvmRoutineName = "get." + [[mReceiverIR type] llvmBaseTypeName] + "." + mPropertyName
  ioInvokedRoutineSet += !llvmRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
