#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @assertInstructionAST : @instructionAST {
  @location mAssertInstructionLocation
  @expressionAST mExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList  ?!@labelMap unused ioLabelMap{
    $assert$
    let loc = @location.here
    <expression> ?let @expressionAST expression
    ioInstructionList += !@assertInstructionAST.new {
      !loc
      !expression
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @assertInstructionAST analyze
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  if [inModeSet hasKey !exceptionModeName ()] then
    error mAssertInstructionLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
  end
#--- Analyze expression
  @instructionListIR instructionGenerationList = {}
  [mExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:.null
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:instructionGenerationList
    ?type:let expressionType
    ?result:@operandIR expressionValueName
  ]
#--- Check inferred type
  if not [[expressionType kind] isBoolean] then
    error mAssertInstructionLocation : "expression is not boolean"
  end
#--- Check expression is not static
  if [expressionValueName isStatic] then
    error mAssertInstructionLocation : "expression is static: use check directive"
  end
#--- Code generation
  if not [option plm_options.noExceptionGeneration value] then
    ioInstructionGenerationList += !@assertInstructionIR.new {
      !mAssertInstructionLocation
      !instructionGenerationList
      !expressionValueName
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @assertInstructionIR : @abstractInstructionIR {
  @location mAssertInstructionLocation
  @instructionListIR mInstructionList
  @operandIR mExpressionValue
}

#----------------------------------------------------------------------------------------------------------------------*

override method @assertInstructionIR llvmInstructionCode ?!@string ioCode {
  [mInstructionList instructionListLLVMCode !?ioCode]
  ioCode += "if (!" + mExpressionValue + ") {\n"
  ioCode += "  raise_exception (20"
     + ", " + [[[mAssertInstructionLocation file] lastPathComponent] utf8Representation]
     + ", " + [mAssertInstructionLocation line] + ") ;\n"
  ioCode += "}\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @assertInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionList enterAccessibleEntities !?ioAccessibleEntities]
#  [mExpressionValue enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*
