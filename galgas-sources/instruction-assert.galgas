#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @assertInstructionAST : @instructionAST {
  @location mAssertInstructionLocation
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $assert$
    let loc = @location.here
    <expression> ?let @expressionAST expression
    ioInstructionList += !loc !@assertInstructionAST.new {
      !loc
      !expression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assertInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assertInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx unused ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  if inCurrentMode == .panicMode then
    error mAssertInstructionLocation : "operations that can generate panic are not allowed in `" + panicModeName () + " mode"
  end
#--- Analyze expression
  @instructionListIR instructionGenerationList = {}
  [mExpression analyzeExpression
    !self:inSelfType
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.null
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:instructionGenerationList
    ?result:let @objectIR expressionValue
  ]
#--- Check inferred type
  if not [[expressionValue kind] isBoolean] then
    error mAssertInstructionLocation : "expression is not boolean"
  end
#--- Check expression is not static
  if [expressionValue isStatic] then
    error mAssertInstructionLocation : "expression is static: use check directive"
  end
#--- Code generation
  if not [option plm_options.noPanicGeneration value] then
    ioInstructionGenerationList += !@assertInstructionIR.new {
      !mAssertInstructionLocation
      !instructionGenerationList
      !expressionValue
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @assertInstructionIR : @abstractInstructionIR {
  @location mAssertInstructionLocation
  @instructionListIR mInstructionList
  @objectIR mExpressionValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assertInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  [mInstructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext!?ioGenerationAdds]
  ioLLVMcode += "if (!" + [mExpressionValue llvmName] + ") {\n"
  ioLLVMcode += "  raise_exception (" + panicCodeForAssertViolation ()
     + ", " + [[[mAssertInstructionLocation file] lastPathComponent] utf8Representation]
     + ", " + [mAssertInstructionLocation line] + ") ;\n"
  ioLLVMcode += "}\n" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assertInstructionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mInstructionList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
