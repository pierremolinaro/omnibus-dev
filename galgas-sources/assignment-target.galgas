#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @accessInAssignmentAST {
  case property (@lstring name)
  case arrayAccess (@expressionAST index @location endOfIndex)
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @accessInAssignmentListAST {
  @accessInAssignmentAST mAccess
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @assignmentTargetAST {
  @lstring mIdentifier
  @accessInAssignmentListAST mAccessList
}

#·······················································································································

class @assignmentTargetNoSelfAST : @assignmentTargetAST {
}

#·······················································································································

class @assignmentTargetSelfAST : @assignmentTargetAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <assignment_target_noself> !@assignmentTargetNoSelfAST outAssignmentTargetAST {
  #--- Object
    $identifier$ ?let identifier
  #--- Properties and subscript
    @accessInAssignmentListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = @assignmentTargetNoSelfAST.new {!identifier !accessListAST}
  }

  #·····················································································································

  rule <assignment_target_self> !@assignmentTargetSelfAST outAssignmentTargetAST {
  #--- Self
    $self$
    $.$
  #--- Object
    $identifier$ ?let identifier
  #--- Properties and subscript
    @accessInAssignmentListAST accessListAST = {}
    repeat
    while
      $.$
      $identifier$ ?let propertyName
      accessListAST += !.property {!name:propertyName}
    while
      $[$
      <expression> ?let expression
      let endOfIndex = @location.here
      $]$
      accessListAST += !.arrayAccess {!index:expression !endOfIndex:endOfIndex}
    end
    outAssignmentTargetAST = .new {!identifier !accessListAST}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @assignmentTargetAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for (access) in mAccessList do
    switch access
    case property (*) :
    case arrayAccess (@expressionAST indexExpression *) :
      [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @targetAccessKind {
  case read
  case write
  case readWrite
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @assignmentTargetAST analyzeAssignmentTarget
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?targetAccessKind:let @targetAccessKind inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMap ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assignmentTargetNoSelfAST analyzeAssignmentTarget
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?targetAccessKind:let @targetAccessKind inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMap ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
#    [!?ioUniversalMap searchValuedObjectForWriteAccess !mIdentifier ?let isPublic ?let currentObject]
  if [ioVariableMap hasKey !mIdentifier] then
    switch inSelfAccessKind
    case read :
      [!?ioVariableMap searchForReadAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case write :
      [!?ioVariableMap searchForWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    case readWrite :
      [!?ioVariableMap searchForReadWriteAccess !lkey:mIdentifier ?2* ?objectIR:outCurrentObject ?2*]
    end
    outGlobalVariableReceiverName = if [outCurrentObject isGlobalVariableReference] then mIdentifier.string else "" end
  else # Stand alone function call ?
    outCurrentObject = .possibleFunction {!receiver:.null !functionName:mIdentifier}
    outGlobalVariableReceiverName = ""
  end
#--- Analyze properties, subscripts
  if [mAccessList length] == 0 then # 
    [ioUniversalMap searchValuedObject !mIdentifier ?let unused isPublic ?outCurrentObject]
    [!?ioUniversalMap checkValuedObjectIsWritable !mIdentifier]
  else
    for (access) in mAccessList do
      switch access
      case property (propertyName) :
        handlePropertyAccessInAssignment (
          !?outCurrentObject
          !propertyName
          !?ioTemporaries
          !?ioInstructionGenerationList
        )
      case arrayAccess (indexExpression endOfExpression) :
        handleSubscriptInAssignmentAndExpression (
          !self:inSelfType
          !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
          !inGuard:false
          !routineNameForInvocationGraph:inCallerNameForInvocationGraph
          !context:inContext
          !mode:inCurrentMode
          !?temporary:ioTemporaries
          !?staticStringMap:ioGlobalLiteralStringMap
          !?variableMap:ioVariableMap
          !?variableMap:ioUniversalMap
          !?alloca:ioAllocaList
          !indexExpression
          !endOfExpression
          !?ioInstructionGenerationList
          !?outCurrentObject
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assignmentTargetSelfAST analyzeAssignmentTarget
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?targetAccessKind:let @targetAccessKind unused inSelfAccessKind
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMap ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !@objectIR outCurrentObject
  !globalVariableReceiverName:@string outGlobalVariableReceiverName
{
#--- object access, with ou without self
  outGlobalVariableReceiverName = "" # Receiver is not a global variable
  if inSelfType == .null then
    error mIdentifier : "'self' is not available in this context" : outCurrentObject
  elsif [[inSelfType kind] isStructure] then
    [[inSelfType kind] structure ?typeName:* ?propertyMap:let structureObjectMap ?universalMap:let unused universalMap ?2*]
 ##     [universalMap searchProperty !mIdentifier ?* ?let object]
    if [structureObjectMap hasKey !mIdentifier] then
      [structureObjectMap searchKey
        !mIdentifier
        ?*
        ?let object
      ]
      handleSelfAccessInAssignment (
        !inSelfType
        !object
        !?ioTemporaries
        !?ioInstructionGenerationList
        ?outCurrentObject
      )
    else # Function call ?
      outCurrentObject = .possibleFunction {!receiver:.selfObject {!type:inSelfType} !functionName:mIdentifier}
    end
  else
    error mIdentifier : "'self' should be a structure instance" : outCurrentObject, outGlobalVariableReceiverName
  end
#--- Analyze properties, subscripts
  for (access) in mAccessList do
    switch access
    case property (propertyName) :
      handlePropertyAccessInAssignment (
        !?outCurrentObject
        !propertyName
        !?ioTemporaries
        !?ioInstructionGenerationList
      )
    case arrayAccess (indexExpression endOfExpression) :
      handleSubscriptInAssignmentAndExpression (
        !self:inSelfType
        !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
        !inGuard:false
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !context:inContext
        !mode:inCurrentMode
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?variableMap:ioUniversalMap
        !?alloca:ioAllocaList
        !indexExpression
        !endOfExpression
        !?ioInstructionGenerationList
        !?outCurrentObject
      )
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handleSelfAccessInAssignment
  ?let @unifiedTypeMap-proxy inSelfType
  ?let @objectIR inObject
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
  !@objectIR outObjectPtr
{
  if [inObject isProperty] then
    [inObject property ?type:let type ?plmName:let name ?index:let index]
    outObjectPtr = .temporaryReference {
      !type:type
      !llvmName:.new {!"temp." + ioTemporaries.mTemporaryIndex !name}
      !sliceMap:{}
      !volatile:false
    }
    ioTemporaries.mTemporaryIndex ++
    [!?ioInstructionGenerationList appendPropertyReferenceFromSelf
      !outObjectPtr
      !inSelfType
      !name
      !index
    ]
  else
    error .nowhere : "<<getNewTemporarySelfObjectPtr>>" : outObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handlePropertyAccessInAssignment
  ?!@objectIR ioObject
  ?let @lstring inPropertyName
  ?!@semanticTemporariesStruct ioTemporaries
  ?!@instructionListIR ioInstructionGenerationList
{
  if [[[ioObject type] kind] isStructure] then
    [[[ioObject type] kind] structure ?typeName:* ?propertyMap:let structureObjectMap ?universalMap:let unused universalMap ?2*]
    if [structureObjectMap hasKey !inPropertyName] then
      [structureObjectMap searchKey !inPropertyName ?* ?@objectIR property]
      if [property isProperty] then
       [property property ?type:let type ?plmName:let name ?index:let index]
        let newObject = @objectIR.temporaryReference {
          !type:type
          !llvmName:.new {!"temp." + ioTemporaries.mTemporaryIndex !inPropertyName}
          !sliceMap:{}
          !volatile:false
        }
        ioTemporaries.mTemporaryIndex ++
        [!?ioInstructionGenerationList appendGetPropertyReference
          !newObject
          !ioObject
          !name
          !index
        ]
        ioObject = newObject
      else
        error inPropertyName : "<<getNewTemporarySelfObjectPtr>>" : ioObject
      end
    else
      ioObject = .possibleFunction {!receiver:ioObject !functionName:inPropertyName}
    end
  else
    error inPropertyName : "the current object has no property" : ioObject
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
