#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

abstract class @instructionAST {
}

#----------------------------------------------------------------------------------------------------------------------*

list @instructionListAST {
  @instructionAST mInstruction
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instructionList> !@instructionListAST outInstructionList {
    outInstructionList = {}
    repeat
    while
      <instruction> !?outInstructionList
    while
      $;$
    end
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @instructionAST analyze
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList

#----------------------------------------------------------------------------------------------------------------------*

method @instructionListAST analyzeBranchInstructionList
  ?endOfInstructionList:@location inEndOfInstructionList
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Begin branch
  [!?ioVariableMap openBranch]
  for () in self do
    [mInstruction analyze 
      !optionalReceiverType:inReceiverType
      !context:inContext
      !modes:inModeSet
      !allowException:inAllowExceptions
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?instructionListIR:ioInstructionGenerationList
    ]
  end
#--- End branch
  [!?ioVariableMap closeBranch !inEndOfInstructionList]
}

#----------------------------------------------------------------------------------------------------------------------*

method @instructionListAST analyzeRoutineInstructionList
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!generatedCode:@instructionListIR ioInstructionGenerationList
{
  for () in self do
    [mInstruction analyze 
      !optionalReceiverType:inReceiverType
      !context:inContext
      !modes:inModeSet
      !allowException:inAllowExceptions
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?instructionListIR:ioInstructionGenerationList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

getter @instructionListIR instructionListCode -> @string outCode {
  outCode = ""
  [!?outCode incIndentation !2]
  for () in self do
    outCode += [mInstructionGeneration instructionCode]
  end
  [!?outCode decIndentation !2]
}

#----------------------------------------------------------------------------------------------------------------------*
