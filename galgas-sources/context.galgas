#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    C O N T E X T                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractDecoratedDeclaration {
}

#·······················································································································

list @declarationDecorationList {
  @abstractDecoratedDeclaration mDeclaration
}

#·······················································································································

map @infixOperatorMap {
  @PLMType mResultType
  @infixOperatorDescription mOperation
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
}

#·······················································································································

map @prefixOperatorMap {
  insert insertKey error message "** internal error **"
  search searchKey error message "prefix operation is not defined for $%K type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @staticEntityMap
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @staticEntityMap {
  @staticStringMap mStaticStringMap
  @globalStructuredConstantList mGlobalStructuredConstantList
}

#·······················································································································

list @globalStructuredConstantList {
  @PLMType mType
  @operandIRList mOperandIRList
}

#·······················································································································

map @staticStringMap {
  @uint mIndex
  insert insertKey error message "-- internal error --"
  search searchKey error message "-- internal error --"
}

#·······················································································································

setter @staticEntityMap findOrAddStaticString ?@string inString !@uint outIndex {
  if [mStaticStringMap hasKey !inString]  then
    [mStaticStringMap searchKey ![inString nowhere] ?outIndex]
  else
    outIndex = [mStaticStringMap count]
    [!?mStaticStringMap insertKey ![inString nowhere] !outIndex]
  end
}

#·······················································································································

map @globalConstantMap {
  @objectIR mValue
  insert insertKey error message "the '%K' constant is already declared in %L"
  search searchKey error message "there is no '%K' constant"
}

#·······················································································································

list @operandIRList {
  @objectIR mOperand
}

#·······················································································································

map @availableInterruptMap {
  @interruptionPanicCode mInterruptionPanicCode
  insert insertKey error message "interrupt '%K' is already defined"
  search searchKey error message "interrupt '%K' is not defined"
}

#·······················································································································

struct @semanticContext {
  @targetParameters mTargetParameters

  @unifiedTypeMap-proxy mPanicCodeType
  @unifiedTypeMap-proxy mPanicLineType
  @panicRoutinePriorityMap mPanicSetupRoutinePriorityMap 
  @panicRoutinePriorityMap mPanicLoopRoutinePriorityMap 

  @routineMapForContext mRoutineMapForContext
  @guardMapForContext mGuardMapForContext
  @controlRegisterGroupMap mControlRegisterGroupMap
  @globalConstantMap mGlobalConstantMap
  @globalSyncInstanceMap mGlobalSyncInstanceMap
  @driverMap mDriverMap
  @staticlistMap mStaticListMap

#--- Types
  @unifiedTypeMap mTypeMap

#--- Interrupts
  @stringset mDefinedInterruptSet
  @availableInterruptMap mAvailableInterruptMap

#--- Operators
  @infixOperatorMap mEqualOperatorMap           # ==
  @infixOperatorMap mNonEqualOperatorMap        # !=
  @infixOperatorMap mStrictInfOperatorMap       # <
  @infixOperatorMap mInfEqualOperatorMap        # <=
  @infixOperatorMap mStrictSupOperatorMap       # >
  @infixOperatorMap mSupEqualOperatorMap        # >=
  @infixOperatorMap mAndOperatorMap             # &
  @infixOperatorMap mOrOperatorMap              # |
  @infixOperatorMap mXorOperatorMap             # ^
  @infixOperatorMap mBooleanXorOperatorMap      # xor
  @infixOperatorMap mAddOperatorMap             # +
  @infixOperatorMap mAddNoOvfOperatorMap        # &+
  @infixOperatorMap mSubOperatorMap             # -
  @infixOperatorMap mSubNoOvfOperatorMap        # &-
  @infixOperatorMap mMulOperatorMap             # *
  @infixOperatorMap mMulNoOvfOperatorMap        # &*
  @infixOperatorMap mDivOperatorMap             # /
  @infixOperatorMap mDivNoOvfOperatorMap        # &/
  @infixOperatorMap mModOperatorMap             # %
  @infixOperatorMap mModNoOvfOperatorMap        # &%
  @infixOperatorMap mLeftShiftOperatorMap       # <<
  @infixOperatorMap mRightShiftOperatorMap      # >>
  @prefixOperatorMap mUnaryMinusOperatorMap     # - and &-
  @prefixOperatorMap mNotOperatorMap            # not
  @prefixOperatorMap mUnsignedComplementOperatorMap # ~

#--- Tasks
  @taskMap mTaskMap
  @globalTaskVariableList mGlobalTaskVariableList

#--- Entity map
  @universalValuedObjectMap mValuedObjectMap
}

#·······················································································································

getter @semanticContext booleanType -> @PLMType {
  [mTypeMap searchKey !lkey:[boolTypeName () nowhere] ?type:result ?1*]
#  @propertyMap propertyMap = {}
#  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mBooleanTypeName ?let boolTypeProxy]
#  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !.new {!"uint1" !mBooleanTypeName} ?let uint1TypeProxy]
##--- Add uint1 accessor
#  [!?propertyMap addFunctionWithoutArgument
#    !?ioSubprogramInvocationGraph
#    !receiverTypeProxy:boolTypeProxy
#    !methodName:"uint1"
#    !safe:true
#    !resultTypeProxy:uint1TypeProxy
#    !canMutateProperties:false
#  ]
##---------- Define boolean type composition
#  result = .new {
#    !propertyMap:propertyMap
#    !classConstantMap:{}
#    !constructorMap:{}
#    !guardMap:{}
#    !attributes:.instanciable | .equatable | .copyable | .generateAssignmentRoutine
#    !plmOriginalTypeName:boolTypeName ()
#    !kind:.boolean
#    !plmAliasedTypeName:boolTypeName ()
#  }
}

#·······················································································································

abstract method @abstractDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@subprogramInvocationGraph ioSubprogramInvocationGraph
  ?!staticlistValues:@staticListInitializationMap ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap

#·······················································································································

proc buildSemanticContext
  ?sourceFile:let @lstring inSourceFile
  ?ast:let @ast inAST
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!staticlistValues:@staticListInitializationMap ioStaticListValueMap
  !context:@semanticContext outSemanticContext
  !@subprogramInvocationGraph outSubprogramInvocationGraph
  !@declarationDecorationList outDecoratedDeclarationList
{
  outSemanticContext = .default
  outDecoratedDeclarationList = {}
#--- Enter standalone procedures, functions, sections, services, guards in context
  [inAST.mISRDeclarationListAST enterInContext !?outSemanticContext !?outDecoratedDeclarationList]
  [inAST.mStandAloneFunctionDeclarationListAST enterFunctionInContext
     !selfTypeName:"" 
     !?context:outSemanticContext
     !?outDecoratedDeclarationList
   ]
  [inAST.mExternProcListAST enterExternProcInContext !?context: outSemanticContext]
  [inAST.mStandAloneSystemRoutineListAST enterSystemRoutineInContext !receiverType:"" !?context: outSemanticContext]
#---
  outSubprogramInvocationGraph = .emptyGraph
  for (declaration) in inAST.mDeclarationListAST do
    [declaration enterInContext
      !procedureDeclarationList:inAST.mStandAloneFunctionDeclarationListAST
      !?context:outSemanticContext
      !?outDecoratedDeclarationList
      !?outSubprogramInvocationGraph
      !?staticlistValues:ioStaticListValueMap
      !?staticEntityMap:ioStaticEntityMap
    ]
  end
#--- Build an HTML containing all global constants
  buildGlobalConstantMapHTMLFile (
    !outSemanticContext.mGlobalConstantMap
    !sourceFile:inSourceFile
  )
#--- Build an HTML containing all types
  buildTypeMapHTMLFile (
    !outSemanticContext.mTypeMap
    !sourceFile:inSourceFile
  )
#--- Enter control registers in context
  buildControlRegisterMapHTMLFile (
    !outSemanticContext.mControlRegisterGroupMap
    !sourceFile:inSourceFile
  )
#--- Enter tasks
  [inAST.mTaskListAST enterInContext
     !?context: outSemanticContext
     !?outDecoratedDeclarationList
     !?outSubprogramInvocationGraph
     !?staticEntityMap:ioStaticEntityMap
   ]
}

#·······················································································································

func combineTypeNamesForInfixOperator ?let @string inLeftTypeName ?let @string inRightTypeName -> @lstring {
  result = ["{" + inLeftTypeName + ", " + inRightTypeName + "}" nowhere]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
