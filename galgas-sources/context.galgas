#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    C O N T E X T                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @semanticContext {
  @targetParameters mTargetParameters

  @omnibusType mPanicCodeType
  @omnibusType mPanicLineType
  @panicRoutinePriorityMap mPanicSetupRoutinePriorityMap 
  @panicRoutinePriorityMap mPanicLoopRoutinePriorityMap 

  @routineMapForContext mRoutineMap
  @guardMapForContext mGuardMap
  
  @controlRegisterGroupMap mControlRegisterGroupMap
  @globalConstantMap mGlobalConstantMap
  @globalSyncInstanceMap mGlobalSyncInstanceMap
  @staticlistMap mStaticListMap

  @stringset mRequiredRoutineSet

#--- Types
  @unifiedTypeMap mTypeMap

#--- Interrupts
  @availableInterruptMap mAvailableInterruptMap

#--- Operators
  @infixOperatorMap_EX mEqualOperatorMap           # ==
  @infixOperatorMap_EX mStrictInfOperatorMap       # <
  @infixOperatorMap_EX mInfEqualOperatorMap        # <=
  @infixOperatorMap_EX mAndOperatorMap             # &
  @infixOperatorMap_EX mOrOperatorMap              # |
  @infixOperatorMap_EX mXorOperatorMap             # ^
  @infixOperatorMap_EX mBooleanXorOperatorMap      # xor
  @infixOperatorMap_EX mAddOperatorMap             # +
  @infixOperatorMap_EX mAddNoOvfOperatorMap        # &+
  @infixOperatorMap_EX mSubOperatorMap             # -
  @infixOperatorMap_EX mSubNoOvfOperatorMap        # &-
  @infixOperatorMap_EX mMulOperatorMap             # *
  @infixOperatorMap_EX mMulNoOvfOperatorMap        # &*
  @infixOperatorMap_EX mDivOperatorMap             # /
  @infixOperatorMap_EX mDivNoOvfOperatorMap        # &/
  @infixOperatorMap_EX mModOperatorMap             # %
  @infixOperatorMap_EX mModNoOvfOperatorMap        # &%
  @infixOperatorMap_EX mLeftShiftOperatorMap       # <<
  @infixOperatorMap_EX mRightShiftOperatorMap      # >>
  
  @infixOperatorMap mInfixOperatorMap
  @prefixOperatorMap mPrefixOperatorMap
  @assignmentOperatorMap mAssignmentOperatorMap
  
  @implicitConversionToBooleanMap mImplicitConversionToBooleanMap

#--- Tasks
  @taskMap mTaskMap
  @globalTaskVariableList mGlobalTaskVariableList

#--- Entity map
  @universalValuedObjectMap mValuedObjectMap
}

#·······················································································································

abstract class @abstractDecoratedDeclaration {
}

#·······················································································································

list @declarationDecorationList {
  @abstractDecoratedDeclaration mDeclaration
}

#·······················································································································

map @infixOperatorMap_EX {
  @omnibusType mResultType
  @omnibusInfixOperatorDescription mOperation
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @staticEntityMap
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @staticEntityMap {
  @staticStringMap mStaticStringMap
  @globalStructuredConstantList mGlobalStructuredConstantList
}

#·······················································································································

list @globalStructuredConstantList {
  @omnibusType mType
  @operandIRList mOperandIRList
}

#·······················································································································

map @staticStringMap {
  @uint mIndex
  insert insertKey error message "-- internal error --"
  search searchKey error message "-- internal error --"
}

#·······················································································································

setter @staticEntityMap findOrAddStaticString ?@string inString !@uint outIndex {
  if [mStaticStringMap hasKey !inString]  then
    [mStaticStringMap searchKey ![inString nowhere] ?outIndex]
  else
    outIndex = [mStaticStringMap count]
    [!?mStaticStringMap insertKey ![inString nowhere] !outIndex]
  end
}

#·······················································································································

map @globalConstantMap {
  @objectIR mValue
  insert insertKey error message "the '%K' constant is already declared in %L"
  search searchKey error message "there is no '%K' constant"
}

#·······················································································································

list @operandIRList {
  @objectIR mOperand
}

#·······················································································································

map @availableInterruptMap {
  @interruptionPanicCode mInterruptionPanicCode
  insert insertKey error message "interrupt '%K' is already defined"
  search searchKey error message "interrupt '%K' is not defined"
}

#·······················································································································

getter @semanticContext booleanType ?let @location unused inErrorLocation -> @omnibusType {
  [mTypeMap searchKey !lkey:[boolTypeName () nowhere] ?type:result]
#  let acceptableTypeList = [mAssignableTypesFromCompileTimeType_Map listForKey !ctBoolTypeName ()]
#  if [acceptableTypeList length] == 0 then
#    error inErrorLocation : "There is no type assignable from compile time bool type" : result
#  elsif [acceptableTypeList length] == 1 then
#    [acceptableTypeList first ?result]
#  else
#    error inErrorLocation : "There are several types assignable from compile time bool type" : result
#  end
}

#·······················································································································

abstract method @abstractDeclarationAST enterInContext
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR ioUserLLVMTypeDefinitionListIR

#·······················································································································

proc buildSemanticContext
  ?sourceFile:let @lstring inSourceFile
  ?ast:let @ast inAST
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!staticlistValues:@staticListInitializationMap ioStaticListValueMap
  !context:@semanticContext outSemanticContext
  !@declarationDecorationList outDecoratedDeclarationList
  !@decoratedRegularRoutineList outDecoratedRoutineList
  !@routineListIR outRoutineListIR
  !@userLLVMTypeDefinitionListIR outUserLLVMTypeDefinitionListIR
{
  outSemanticContext = .default
  outDecoratedDeclarationList = {}
  outDecoratedRoutineList = {}
  outRoutineListIR = {}
  outUserLLVMTypeDefinitionListIR = {}
#--- Enter required routines
  for requiredProc in inAST.mRequiredFunctionListAST do
    let procedureMangledName = routineMangledNameFromAST (
      !""
      !requiredProc.mName
      !requiredProc.mFormalArgumentList
    )
    outSemanticContext.mRequiredRoutineSet += !procedureMangledName.string
  end 
  [inAST.mExternFunctionListAST enterExternProcInContext
    !?context: outSemanticContext
  ]
#---
  var controlRegisterUserAccesMapAST = inAST.mControlRegisterUserAccesMapAST
  for (declaration) in inAST.mDeclarationListAST do
    [declaration enterInContext
      !?context:outSemanticContext
      !?outDecoratedDeclarationList
      !?outDecoratedRoutineList
      !?outRoutineListIR
      !?staticlistValues:ioStaticListValueMap
      !?staticEntityMap:ioStaticEntityMap
      !?registerUserAccess:controlRegisterUserAccesMapAST
      !?userDefinedTypes: outUserLLVMTypeDefinitionListIR
    ]
  end
#--- Check all registers declared as @user are actually defined
  for (lkey) in controlRegisterUserAccesMapAST do
    error lkey : "this control register is not defined"
  end
#--- Build an HTML containing all global constants
  buildGlobalConstantMapHTMLFile (
    !outSemanticContext.mGlobalConstantMap
    !sourceFile:inSourceFile
  )
#--- Build an HTML containing all types
  buildTypeMapHTMLFile (
    !outSemanticContext.mTypeMap
    !outSemanticContext.mRoutineMap
    !outSemanticContext.mInfixOperatorMap
    !outSemanticContext.mPrefixOperatorMap
    !outSemanticContext.mAssignmentOperatorMap
    !sourceFile:inSourceFile
  )
#--- Enter control registers in context
  buildControlRegisterMapHTMLFile (
    !outSemanticContext.mControlRegisterGroupMap
    !sourceFile:inSourceFile
  )
#--- Enter tasks
  [inAST.mTaskListAST enterInContext
     !?context: outSemanticContext
     !?outDecoratedDeclarationList
     !?outDecoratedRoutineList
     !?outRoutineListIR
     !?staticEntityMap:ioStaticEntityMap
     !?userDefinedTypes: outUserLLVMTypeDefinitionListIR
   ]
}

#·······················································································································

func combineTypeNamesForInfixOperator ?let @string inLeftTypeName ?let @string inRightTypeName -> @lstring {
  result = [inLeftTypeName + "," + inRightTypeName nowhere]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
