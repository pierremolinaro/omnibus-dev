#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    C O N T E X T                                                                      
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @routineDescriptor {
  @mode mMode
  @procedureSignature mSignature
  @unifiedTypeMap-proxy mReturnType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @typeKind {
  case boolean
  case literalString
  case enumeration (@enumConstantMap constantMap @classConstantMap classConstantMap)
  case structure (@lstring typeName @propertyMap propertyMap @propertyList propertyList @uint flags)
  case integer (@bigint min @bigint max @bool unsigned @uint bitCount)
  case staticInteger
  case opaque (@bigint bitCount @uint flags)
  case arrayType (@lstring typeName
                  @unifiedTypeMap-proxy elementType
                  @bigint size
                  @classConstantMap classConstantMap
                  @uint flags)
  case function (@routineDescriptor descriptor)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @infixOperatorMap {
  @unifiedTypeMap-proxy mResultType
  @infixOperatorDescription mOperation
  insert insertKey error message "** internal error **"
  search searchKey error message "** internal error **"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @prefixOperatorMap {
  insert insertKey error message "** internal error **"
  search searchKey error message "prefix operation is not defined for $%K type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @staticStringMap
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @staticStringMap {
  @uint mIndex
  insert insertKey error message "-- internal error --"
  search searchKey error message "-- internal error --"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @staticStringMap findOrAddStaticString ?@string inString !@uint outIndex {
  if [self hasKey !inString]  then
    [self searchKey ![inString nowhere] ?outIndex]
  else
    outIndex = [self count]
    [!?self insertKey ![inString nowhere] !outIndex]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @globalConstantMap {
  @objectIR mValue
  insert insertKey error message "the '%K' constant is already declared in %L"
  search searchKey error message "there is no '%K' constant"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @allowedGuardMap {
  insert insertKey error message "the '%K' guard is already declared in %L"
  search searchKey error message "there is no '%K' guard"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @globalVariableMap %selectors {
  @unifiedTypeMap-proxy type
  @stringset executionModeSet
#  @allowedRoutineMap allowedRoutineMap
  @allowedGuardMap allowedGuardMap
#  @allowedISRMap allowedISRMap
#  @allowedTaskMap allowedTaskMap
  @objectIR initialValue
  @bool isConstant
  @bool allowedAccessToAll

  insert insertKey error message "the '%K' global variable is already declared in %L"
  search searchKey error message "there is no '%K' global variable"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sharedmap @unifiedTypeMap %selectors {
  @typeKind kind

  insert insertType error message "the '%K' type is already declared in %L"
  search searchKey error message "there is no '%K' type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#func %once comparableFlag   -> @uint { result = 1 << 1 }

getter @unifiedTypeMap-proxy equatable -> @bool {
  result = [[self kind] equatable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind equatable -> @bool {
  switch self
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* *) :
    result = true
  case structure (* * * @uint flags) :
    result = (flags & equatableFlag ()) != 0
  case integer (* * * *) :
    result = true
  case opaque (* @uint flags) :
    result = (flags & equatableFlag ()) != 0
  case arrayType (* * * * @uint flags) :
    result = (flags & equatableFlag ()) != 0
  case function (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy instanciable -> @bool {
  result = [[self kind] instanciable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind instanciable -> @bool {
  switch self
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* *) :
    result = true
  case structure (* * * @uint flags) :
    result = (flags & instanciableFlag ()) != 0
  case integer (* * * *) :
    result = true
  case opaque (* @uint flags) :
    result = (flags & instanciableFlag ()) != 0
  case arrayType (* * * * @uint flags) :
    result = (flags & instanciableFlag ()) != 0
  case function (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy copyable -> @bool {
  result = [[self kind] copyable]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind copyable -> @bool {
  switch self
  case boolean :
    result = true
  case literalString, staticInteger :
    result = true
  case enumeration (* *) :
    result = true
  case structure (* * * @uint flags) :
    result = (flags & copyableFlag ()) != 0
  case integer (* * * *) :
    result = true
  case opaque (* @uint flags) :
    result = (flags & copyableFlag ()) != 0
  case arrayType (* * * * @uint flags) :
    result = (flags & copyableFlag ()) != 0
  case function (*) :
    result = false
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap-proxy classConstantMap -> @classConstantMap {
  switch [self kind]
  case boolean, literalString, staticInteger :
    result = {}
  case enumeration (* @classConstantMap classConstantMap) :
    result = classConstantMap
  case structure (* * * *) :
    result = {}
  case integer (* * * *) :
    result = {}
  case opaque (* *) :
    result = {}
  case arrayType (* * * @classConstantMap classConstantMap *) :
    result = classConstantMap
  case function (*) :
    result = {}
  end  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @typeKind llvmTypeName -> @string {
  switch self
  case boolean :
    result = "i1"
  case literalString :
    result = "i8*"
  case enumeration (@enumConstantMap constantMap *) :
    result = "i" + [[constantMap count] - 1 significantBitCount]
  case structure (@lstring typeName * * *) :
    result = "%" + [llvmRegularTypeMangledNameFromName (!typeName) assemblerRepresentation]
  case integer (@bigint unused min @bigint unused max @bool unused unsigned @uint bitCount) :
    result = "i" + bitCount
  case staticInteger :
    error .nowhere : "INTERNAL ERROR" : result
  case opaque (@bigint bitCount *) :
    result = "i" + bitCount
  case arrayType (@lstring typeName * * * *) :
    result = "%" + [typeName assemblerRepresentation]
  case function (descriptor) :
    if descriptor.mReturnType == .null then
      result = "void"
    else
      result = [[descriptor.mReturnType kind] llvmTypeName]
    end
    result += "("
    for () in descriptor.mSignature 
    do
      result += [[mType kind] llvmTypeName]
      switch mFormalArgumentPassingMode
      case inputOutput, output : result += "*"
      case input :
      end
    between result += ", "
    end
    result += ")*"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @operandList {
  @objectIR mOperand
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @classConstantMap {
  @objectIR mValue
  insert insertKey error message "the '%K' class constant is already declared in %L"
  search searchKey error message "there is no '%K' class constant"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @operandIRList {
  @objectIR mOperand
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @constructorValue {
  case zero
  case simple (@bigint value)
  case structure (@constructorSignature constructorSignature @sortedOperandIRList sortedOperandList)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @constructorMap {
  @constructorValue mInitValue
  insert insertKey error message "-- internal error --"
  search searchKey error message "-- internal error --"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @availableInterruptMap {
  @interruptionPanicCode mInterruptionPanicCode
  insert insertKey error message "interrupt '%K' is already defined"
  search searchKey error message "interrupt '%K' is not defined"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @globalTaskVariableList {
  @string mTaskName
  @string mTaskTypeName
  @objectIR mInitialValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @semanticContext {
  @targetParameters mTargetParameters
  @uint mPointerSize # in bit count
  @unifiedTypeMap-proxy mBooleanType
  @unifiedTypeMap-proxy mLiteralIntegerType
  @unifiedTypeMap-proxy mPanicCodeType
  @unifiedTypeMap-proxy mPanicLineType
  @unifiedTypeMap-proxy mUnsignedIntegerType
  @unifiedTypeMap mTypeMap
  @routineMapForContext mRoutineMapForContext
  @guardMapForContext mGuardMapForContext
  @initRoutineMap mInitRoutineMap
  @panicRoutinePriorityMap mPanicSetupRoutinePriorityMap 
  @panicRoutinePriorityMap mPanicLoopRoutinePriorityMap 
  @controlRegisterMap mControlRegisterMap
  @globalConstantMap mGlobalConstantMap
  @globalVariableMap mGlobalVariableMap
  @moduleMap mModuleMap
  @constructorMap mConstructorMap
  @staticlistMap mStaticlistMap
#--- Interrupts
  @stringset mDefinedInterruptSet
  @availableInterruptMap mAvailableInterruptMap
#--- Operator
  @infixOperatorMap mEqualOperatorMap           # ==
  @infixOperatorMap mNonEqualOperatorMap        # !=
  @infixOperatorMap mStrictInfOperatorMap       # <
  @infixOperatorMap mInfEqualOperatorMap        # <=
  @infixOperatorMap mStrictSupOperatorMap       # >
  @infixOperatorMap mSupEqualOperatorMap        # >=
  @infixOperatorMap mAndOperatorMap             # &
  @infixOperatorMap mOrOperatorMap              # |
  @infixOperatorMap mXorOperatorMap             # ^
  @infixOperatorMap mBooleanXorOperatorMap      # xor
  @infixOperatorMap mAddOperatorMap             # +
  @infixOperatorMap mAddNoOvfOperatorMap        # &+
  @infixOperatorMap mSubOperatorMap             # -
  @infixOperatorMap mSubNoOvfOperatorMap        # &-
  @infixOperatorMap mMulOperatorMap             # *
  @infixOperatorMap mMulNoOvfOperatorMap        # &*
  @infixOperatorMap mDivOperatorMap             # /
  @infixOperatorMap mDivNoOvfOperatorMap        # &/
  @infixOperatorMap mModOperatorMap             # %
  @infixOperatorMap mModNoOvfOperatorMap        # &%
  @infixOperatorMap mLeftShiftOperatorMap       # <<
  @infixOperatorMap mRightShiftOperatorMap      # >>
  @prefixOperatorMap mUnaryMinusOperatorMap     # - and &-
  @prefixOperatorMap mNotOperatorMap            # not
  @prefixOperatorMap mUnsignedComplementOperatorMap # ~
#--- Tasks
  @taskMap mTaskMap
  @globalTaskVariableList mGlobalTaskVariableList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclaration enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap ioStaticListValueMap
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildSemanticContext
  ?orderedDeclarationList:let @declarationListAST inDeclarationListAST
  ?sourceFile:let @lstring inSourceFile
  ?ast:let @ast inAST
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!staticlistValues:@staticlistValues_listMap ioStaticListValueMap
  !context:@semanticContext outSemanticContext
{
  outSemanticContext = .default
#--- Enter init routines
  for initRoutine in inAST.mInitListAST do
    [initRoutine enterInContext !?context:outSemanticContext]
  end
#--- Enter panic routines
  for panicRoutine in inAST.mPanicClauseListAST do
    [panicRoutine enterInContext !?context:outSemanticContext]
  end
#--- Enter procedures, functions, sections, services, guards in context
  [inAST.mISRDeclarationListAST enterInContext !?outSemanticContext]
  [inAST.mProcedureListAST enterFunctionInContext !selfTypeName:"" !?context:outSemanticContext]
  [inAST.mExternProcListAST enterExternProcInContext !?context: outSemanticContext]
  [inAST.mStandAloneSVCListAST enterInContext !receiverType:"" !?context: outSemanticContext]
  [inAST.mGuardListAST enterInContext !receiverType:"" !?context: outSemanticContext]
#---
  for (declaration) in inDeclarationListAST do
    [declaration enterInContext
      !procedureDeclarationList:inAST.mProcedureListAST
      !?context:outSemanticContext
      !?staticlistValues:ioStaticListValueMap
      !?staticStringMap:ioGlobalLiteralStringMap
    ]
  end
#--- Build an HTML containing all global constants
  buildGlobalConstantMapHTMLFile (
    !outSemanticContext.mGlobalConstantMap
    !sourceFile:inSourceFile
  )
#--- Enter control registers in context
  enterControlRegistersInContext (
    !inAST.mControlRegisterDeclarationListAST
    !?context: outSemanticContext
    !?staticStringMap:ioGlobalLiteralStringMap
  )
  buildControlRegisterMapHTMLFile (
    !outSemanticContext.mControlRegisterMap
    !sourceFile:inSourceFile
  )
#--- Enter tasks
  [inAST.mTaskListAST enterInContext !?context: outSemanticContext !?staticStringMap:ioGlobalLiteralStringMap]
#---
  for (declaration) in inDeclarationListAST do
    [declaration enterRoutinesInContext
      !procedureDeclarationList:inAST.mProcedureListAST
      !?context:outSemanticContext
      !?staticStringMap:ioGlobalLiteralStringMap
    ]
  end
#--- Enter static lists in constant map
  for (key stringValueList) in ioStaticListValueMap do
    let lkey = @lstring.new {!key !.nowhere}
    let elementTypePLMName = plmNameForStaticListElementType (!lkey)
    let elementType = @unifiedTypeMap-proxy.searchKey {!outSemanticContext.mTypeMap !elementTypePLMName}
    [!?outSemanticContext.mTypeMap insertType
      !lkey:plmNameForStaticListType (!lkey)
      !kind:.arrayType {
        !typeName:[llvmNameForStaticListType (!key) nowhere]
        !elementType:elementType
        !size:[stringValueList length]
        !classConstantMap: {}
        !flags:0
      }
    ]
    let staticListType = @unifiedTypeMap-proxy.searchKey {!outSemanticContext.mTypeMap !plmNameForStaticListType (!lkey)}
    [!?outSemanticContext.mGlobalConstantMap insertKey
      !lkey
      !.globalVariableReference {!type:staticListType !plmName:lkey}
    ]
  end
#--- Check global var declaration
  if @uint.errorCount == 0 then
    for globalVar in inAST.mGlobalVarDeclarationListAST do
      [globalVar enterInContext
        !?context:outSemanticContext
        !?staticStringMap:ioGlobalLiteralStringMap
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func combineTypeNamesForInfixOperator ?let @string inLeftTypeName ?let @string inRightTypeName -> @lstring outResult {
  outResult = ["{" + inLeftTypeName + ", " + inRightTypeName + "}" nowhere]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
