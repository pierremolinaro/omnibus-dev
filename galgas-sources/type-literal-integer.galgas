#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @literalIntegerDeclaration : @abstractDeclaration {
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @literalIntegerDeclaration location -> @location outLocation {
  outLocation = .nowhere
}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let literalIntegerTypeName = [literalIntegerTypeName () nowhere]
  [!?ioGraph addNode !literalIntegerTypeName !self]
  [!?ioGraph addEdge !literalIntegerTypeName ![boolTypeName () nowhere]]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @literalIntegerDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = literalIntegerTypeName () 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  let integerTypeName = [literalIntegerTypeName () nowhere]
 #---
  [!?ioContext.mTypeMap insertKey
    !lkey:integerTypeName
    !kind:.literalInteger
    !typedConstantMap:{}
    !procedureMap:{}
    !copiable:true
    !equatable:true
    !comparable:true
    !enumerationType:.null # Not enumerable
  ]
#--- Enter integer operators
  enterLiteralIntegerOperators (
    !integerTypeName:integerTypeName
    !?context:ioContext
  )
}

#----------------------------------------------------------------------------------------------------------------------*

private proc enterLiteralIntegerOperators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !inIntegerTypeName.string)
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !inIntegerTypeName ?let selfTypeProxy]
  ioContext.mLiteralIntegerType = selfTypeProxy
#--- Comparison infix operator
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.equal}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.nonEqual}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.strictInf}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.infEqual}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.strictSup}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.supEqual}
  ]
#--- Bit Wise operators (for unsigned integers)
  [!?ioContext.mAndOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.and}
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.ior}
  ]
  [!?ioContext.mXorOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.xor}
  ]
  [!?ioContext.mUnsignedComplementOperatorMap insertKey
    !inIntegerTypeName
    !selfTypeProxy
  ]
#--- Negate operator
  [!?ioContext.mUnaryMinusOperatorMap insertKey
    !inIntegerTypeName
    !selfTypeProxy
  ]
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.add}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.add}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.sub}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.sub}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.mul}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.mul}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.div}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.div}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.rem}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.rem}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.leftShift}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.rightShift}
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration initAnalysis ?!context:@semanticContext unused ioContext { }

#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#----------------------------------------------------------------------------------------------------------------------*
#  INFIX OPERATIONS                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

enum @literalIntegerInfixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case and
  case ior
  case xor
  case add
  case sub
  case mul
  case div
  case rem
  case leftShift
  case rightShift
}
#----------------------------------------------------------------------------------------------------------------------*

class @literal_literal_integerInfixOperation : @infixOperatorDescription {
  @literalIntegerInfixOperator mOperator
}

#----------------------------------------------------------------------------------------------------------------------*

override method @literal_literal_integerInfixOperation generateInfixOperatorCode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @operandIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@operandIR outResult
{
  [inLeftOperand.mValue  literalInteger ?value:let @bigint leftValue]
  [inRightOperand.mValue literalInteger ?value:let @bigint rightValue]
  @bigint result
  switch mOperator 
  case equal : result = [leftValue == rightValue bigint]
  case nonEqual : result = [leftValue != rightValue bigint]
  case strictInf : result = [leftValue < rightValue bigint]
  case infEqual : result = [leftValue <= rightValue bigint]
  case strictSup : result = [leftValue > rightValue bigint]
  case supEqual : result = [leftValue >= rightValue bigint]
  case and : result = leftValue & rightValue
  case ior : result = leftValue | rightValue
  case xor : result = leftValue ^ rightValue
  case add : result = leftValue + rightValue
  case sub : result = leftValue - rightValue
  case mul : result = leftValue * rightValue
  case div : result = leftValue / rightValue
  case rem : result = leftValue mod rightValue
  case leftShift  : result = leftValue << [rightValue uint]
  case rightShift : result = leftValue >> [rightValue uint]
  end
  outResult = .new {!inResultType !.literalInteger {!value:result}}
}

#----------------------------------------------------------------------------------------------------------------------*

