#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literalIntegerDeclarationAST : @abstractDeclarationAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @literalIntegerDeclarationAST location -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  ?!@extendStaticArrayDeclarationAST unused ioExtendStaticArrayDeclarationAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let staticIntegerTypeName = llvmRegularTypeMangledNameFromName (![staticIntegerTypeName () nowhere])
  [!?ioGraph addNode !staticIntegerTypeName !self]
  [!?ioGraph addEdge !staticIntegerTypeName !llvmRegularTypeMangledNameFromName (![boolTypeName () nowhere])]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @literalIntegerDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = staticIntegerTypeName () 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  let integerTypeName = [staticIntegerTypeName () nowhere]
 #---
  [!?ioContext.mTypeMap insertType
    !lkey:integerTypeName
    !type:.staticInteger
    !index:[ioContext.mTypeMap count]
  ]
#--- Enter integer operators
  enterLiteralIntegerOperators (
    !?context:ioContext
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enterLiteralIntegerOperators
  ?!context:@semanticContext ioContext
{
  let literalIntegerTypeName = [staticIntegerTypeName () nowhere]
#--- Infix operators
  let intIntOp = combineTypeNamesForInfixOperator (!literalIntegerTypeName.string !literalIntegerTypeName.string)
  let selfType = [@unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !literalIntegerTypeName} type]
#  ioContext.mLiteralIntegerType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !literalIntegerTypeName}
#--- Comparison infix operator
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !.boolean
    !@literal_literal_integerInfixOperation.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intIntOp
    !.boolean
    !@literal_literal_integerInfixOperation.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !.boolean
    !@literal_literal_integerInfixOperation.new {!.icmp_slt}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !.boolean
    !@literal_literal_integerInfixOperation.new {!.icmp_sle}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !.boolean
    !@literal_literal_integerInfixOperation.new {!.icmp_sgt}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !.boolean
    !@literal_literal_integerInfixOperation.new {!.icmp_sge}
  ]
#--- Bit Wise operators (for unsigned integers)
  [!?ioContext.mAndOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.and}
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.ior}
  ]
  [!?ioContext.mXorOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.xor}
  ]
  [!?ioContext.mUnsignedComplementOperatorMap insertKey
    !literalIntegerTypeName
  ]
#--- Negate operator
  [!?ioContext.mUnaryMinusOperatorMap insertKey
    !literalIntegerTypeName
  ]
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.saddOVF}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.ssubOVF}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.smulOVF}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sdivOVF}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sdivNoOVF}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sremOVF}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.sremNoOVF}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfType
    !@literal_literal_integerInfixOperation.new {!.lshr}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclarationAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INFIX OPERATIONS                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_literal_integerInfixOperation : @infixOperatorDescription {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_literal_integerInfixOperation generateInfixOperatorCode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  ?let @objectIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @objectIR inRightOperand
  ?let @PLMType inResultType
  !@objectIR outResult
{
  [inLeftOperand  literalInteger ?1* ?value:let @bigint leftValue]
  [inRightOperand literalInteger ?1* ?value:let @bigint rightValue]
  let result = [self performStaticOperation !leftValue !rightValue]
  outResult = .literalInteger {!type: inResultType !value:result}
#  message "LITERAL LITERAL " + leftValue + " " + rightValue + " -> " + result + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

