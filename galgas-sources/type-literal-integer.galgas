#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @literalIntegerDeclaration : @abstractDeclaration {
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @literalIntegerDeclaration location -> @location outLocation {
  outLocation = .nowhere
}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let literalIntegerTypeName = [literalIntegerTypeName () nowhere]
  [!?ioGraph addNode !literalIntegerTypeName !self]
  [!?ioGraph addEdge !literalIntegerTypeName ![boolTypeName () nowhere]]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @literalIntegerDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = literalIntegerTypeName () 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
  let integerTypeName = [literalIntegerTypeName () nowhere]
 #---
  [!?ioContext.mTypeMap insertKey
    !lkey:integerTypeName
    !kind:.literalInteger
    !constructorMap:{}
    !procedureMap:{}
    !copiable:true
    !equatable:true
    !comparable:true
  ]
#--- Enter integer operators
  enterLiteralIntegerOperators (
    !integerTypeName:integerTypeName
    !?context:ioContext
  )
}

#----------------------------------------------------------------------------------------------------------------------*

private proc enterLiteralIntegerOperators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !inIntegerTypeName.string)
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !inIntegerTypeName ?let selfTypeProxy]
  ioContext.mLiteralIntegerType = selfTypeProxy
#--- Comparison infix operator
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.equal}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.nonEqual}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.strictInf}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.infEqual}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.strictSup}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.supEqual}
  ]
#--- Bit Wise operators (for unsigned integers)
  [!?ioContext.mAndOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.and}
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.ior}
  ]
  [!?ioContext.mXorOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.xor}
  ]
  [!?ioContext.mUnsignedComplementOperatorMap insertKey
    !inIntegerTypeName
    !selfTypeProxy
  ]
#--- Negate operator
  [!?ioContext.mUnaryMinusOperatorMap insertKey
    !inIntegerTypeName
    !selfTypeProxy
  ]
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.add}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.sub}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.mul}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.div}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.rem}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.leftShift}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@infixLiteralIntLiteralIntOperatorDescription.new {!.rightShift}
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration initAnalysis ?!context:@semanticContext unused ioContext { }

#----------------------------------------------------------------------------------------------------------------------*

override method @literalIntegerDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#----------------------------------------------------------------------------------------------------------------------*
#  INFIX OPERATIONS                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

enum @literalIntegerInfixOperator {
  case equal
  case nonEqual
  case strictInf
  case strictSup
  case infEqual
  case supEqual
  case and
  case ior
  case xor
  case add
  case sub
  case mul
  case div
  case rem
  case leftShift
  case rightShift
}
#----------------------------------------------------------------------------------------------------------------------*

class @infixLiteralIntLiteralIntOperatorDescription : @infixOperatorDescription {
  @literalIntegerInfixOperator mOperator
}

#----------------------------------------------------------------------------------------------------------------------*

override method @infixLiteralIntLiteralIntOperatorDescription generateCode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @unifiedTypeMap-proxy unused inLeftType
  ?let @operandIR inRightOperand
  ?let @location unused inOperatorLocation
  !@operandIR outResultValue
{
  [inLeftOperand literalInteger ?value:let @bigint leftValue]
  [inRightOperand literalInteger ?value:let @bigint rightValue]
  @bigint result
  switch mOperator 
  case equal : result = [leftValue == rightValue bigint]
  case nonEqual : result = [leftValue != rightValue bigint]
  case strictInf : result = [leftValue < rightValue bigint]
  case infEqual : result = [leftValue <= rightValue bigint]
  case strictSup : result = [leftValue > rightValue bigint]
  case supEqual : result = [leftValue >= rightValue bigint]
  case and : result = leftValue & rightValue
  case ior : result = leftValue | rightValue
  case xor : result = leftValue ^ rightValue
  case add : result = leftValue + rightValue
  case sub : result = leftValue - rightValue
  case mul : result = leftValue * rightValue
  case div : result = leftValue / rightValue
  case rem : result = leftValue mod rightValue
  case leftShift  : result = leftValue << [rightValue uint]
  case rightShift : result = leftValue >> [rightValue uint]
  end
  outResultValue = .literalInteger {!value:result}
}

#----------------------------------------------------------------------------------------------------------------------*

