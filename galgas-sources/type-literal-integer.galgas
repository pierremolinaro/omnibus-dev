#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literalIntegerDeclaration : @abstractDeclaration {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @literalIntegerDeclaration location -> @location outLocation {
  outLocation = .nowhere
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let staticIntegerTypeName = ["$" + staticIntegerTypeName () nowhere]
  [!?ioGraph addNode !staticIntegerTypeName !self]
  [!?ioGraph addEdge !staticIntegerTypeName !["$" + boolTypeName () nowhere]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @literalIntegerDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = staticIntegerTypeName () 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
  let integerTypeName = [staticIntegerTypeName () nowhere]
 #---
  [!?ioContext.mTypeMap insertKey
    !lkey:integerTypeName
    !llvmTypeName:"<<literal integer>>"
    !kind:.staticInteger
    !typedConstantMap:{}
    !functionMap:{}
    !instanciable:true
    !copyable:true
    !equatable:true
    !comparable:true
    !enumerationType:.null # Not enumerable
  ]
#--- Enter integer operators
  enterLiteralIntegerOperators (
    !integerTypeName:integerTypeName
    !?context:ioContext
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc enterLiteralIntegerOperators
  ?integerTypeName:let @lstring inIntegerTypeName
  ?!context:@semanticContext ioContext
{
#--- Infix operators
  let intIntOp = combineTypeNamesForInfixOperator (!inIntegerTypeName.string !inIntegerTypeName.string)
  let selfTypeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !inIntegerTypeName}
  ioContext.mLiteralIntegerType = selfTypeProxy
#--- Comparison infix operator
  [!?ioContext.mEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_eq}
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_ne}
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_slt}
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_sle}
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_sgt}
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !intIntOp
    !ioContext.mBooleanType
    !@literal_literal_integerInfixOperation.new {!.icmp_sge}
  ]
#--- Bit Wise operators (for unsigned integers)
  [!?ioContext.mAndOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.and}
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.ior}
  ]
  [!?ioContext.mXorOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.xor}
  ]
  [!?ioContext.mUnsignedComplementOperatorMap insertKey
    !inIntegerTypeName
#    !selfTypeProxy
  ]
#--- Negate operator
  [!?ioContext.mUnaryMinusOperatorMap insertKey
    !inIntegerTypeName
#    !selfTypeProxy
  ]
#--- Arithmetic operators
  [!?ioContext.mAddOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.saddOVF}
  ]
  [!?ioContext.mAddNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.addNoOVF}
  ]
  [!?ioContext.mSubOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.ssubOVF}
  ]
  [!?ioContext.mSubNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.subNoOVF}
  ]
  [!?ioContext.mMulOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.smulOVF}
  ]
  [!?ioContext.mMulNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.mulNoOVF}
  ]
  [!?ioContext.mDivOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.sdivOVF}
  ]
  [!?ioContext.mDivNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.sdivNoOVF}
  ]
  [!?ioContext.mModOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.sremOVF}
  ]
  [!?ioContext.mModNoOvfOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.sremNoOVF}
  ]
#--- Shift operators
  [!?ioContext.mLeftShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.shl}
  ]
  [!?ioContext.mRightShiftOperatorMap insertKey
    !intIntOp
    !selfTypeProxy
    !@literal_literal_integerInfixOperation.new {!.lshr}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literalIntegerDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  INFIX OPERATIONS                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#enum @literalIntegerInfixOperator {
#  case equal
#  case nonEqual
#  case strictInf
#  case strictSup
#  case infEqual
#  case supEqual
#  case and
#  case ior
#  case xor
#  case add
#  case sub
#  case mul
#  case div
#  case rem
#  case leftShift
#  case rightShift
#}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @literal_literal_integerInfixOperation : @infixOperatorDescription {
#  @literalIntegerInfixOperator mOperator
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @literal_literal_integerInfixOperation generateInfixOperatorCode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  ?let @operandIR inLeftOperand
  ?let @location unused inOperatorLocation
  ?let @operandIR inRightOperand
  ?let @unifiedTypeMap-proxy inResultType
  !@operandIR outResult
{
  [inLeftOperand.mValue  literalInteger ?value:let @bigint leftValue]
  [inRightOperand.mValue literalInteger ?value:let @bigint rightValue]
  let result = [self performStaticOperation !leftValue !rightValue]
#  switch mOperator 
#  case equal : result = [leftValue == rightValue bigint]
#  case nonEqual : result = [leftValue != rightValue bigint]
#  case strictInf : result = [leftValue < rightValue bigint]
#  case infEqual : result = [leftValue <= rightValue bigint]
#  case strictSup : result = [leftValue > rightValue bigint]
#  case supEqual : result = [leftValue >= rightValue bigint]
#  case and : result = leftValue & rightValue
#  case ior : result = leftValue | rightValue
#  case xor : result = leftValue ^ rightValue
#  case add : result = leftValue + rightValue
#  case sub : result = leftValue - rightValue
#  case mul : result = leftValue * rightValue
#  case div : result = leftValue / rightValue
#  case rem : result = leftValue mod rightValue
#  case leftShift  : result = leftValue << [rightValue uint]
#  case rightShift : result = leftValue >> [rightValue uint]
#  end
  outResult = .new {!inResultType !.literalInteger {!value:result}}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

