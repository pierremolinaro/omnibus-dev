#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handleArraySubscriptNew
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?arraySize:let @bigint inArraySize
  ?elementType:let @PLMType inElementType
  ?!@instructionListIR ioInstructionGenerationList
  !@objectIR outIndexIR
{
#--- Analyze index expression
  [inIndexExpression analyzeExpression
    !self:inSelfType
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.void
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @objectIR indexResultPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !indexResultPossibleReference
    ?let indexResult
  ]  
  if [indexResult isLiteralInteger] then # Static expression
    [indexResult literalInteger ?1* ?value:let @bigint indexValue]
    if (indexValue < 0G) || (indexValue >= inArraySize) then
      error inErrorLocation : "static index should be positive and < " + inArraySize : outIndexIR
    else
      outIndexIR = @objectIR.literalInteger {!type:inElementType !value:indexValue}
    end
  elsif [[indexResult type] isInteger] then
    if not [option plm_options.noPanicGeneration value] then
      [!?ioInstructionGenerationList testArrayIndex
        !indexResult
        !inErrorLocation
        !inArraySize
        ?let @bool generatePanicInstruction
      ]
      if generatePanicInstruction && not [inCurrentMode panicAllowed] then
        error inErrorLocation : "index computation can generate panic"
      end
    end
    outIndexIR = indexResult
  else
    error inErrorLocation : "index expression is not an integer" : outIndexIR
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handleArraySubscript
  ?self:let @PLMType inSelfType
  ?inGuard:let @bool inGuard
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?arraySize:let @bigint inArraySize
  ?elementType:let @PLMType inElementType
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectIR ioObjectPtr
{
#--- Analyze index expression
  [inIndexExpression analyzeExpression
    !self:inSelfType
    !inGuard:inGuard
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.void
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:let @objectIR indexResultPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadFromReference
    !?ioTemporaries
    !indexResultPossibleReference
    ?let indexResult
  ]  
  if [indexResult isLiteralInteger] then # Static expression
    [indexResult literalInteger ?1* ?value:let @bigint indexValue]
    if (indexValue < 0G) || (indexValue >= inArraySize) then
      error inErrorLocation : "static index should be positive and < " + inArraySize : ioObjectPtr
    else
      let result = @objectIR.llvmReference {
        !type:inElementType
        !llvmName:.new {!"%temp." + ioTemporaries.mTemporaryIndex !inErrorLocation}
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetArrayElementReference
        !result
        !ioObjectPtr
        ![indexValue uint]
      ]
      ioObjectPtr = result      
    end
  elsif [[indexResult type] isInteger] then
    if not [option plm_options.noPanicGeneration value] then
      [!?ioInstructionGenerationList testArrayIndex
        !indexResult
        !inErrorLocation
        !inArraySize
        ?let @bool generatePanicInstruction
      ]
      if generatePanicInstruction && not [inCurrentMode panicAllowed] then
        error inErrorLocation : "index computation can generate panic" : ioObjectPtr
      end
    end
      let result = @objectIR.llvmReference {
        !type:inElementType
        !llvmName:.new {!"%temp." + ioTemporaries.mTemporaryIndex !inErrorLocation}
      }
      ioTemporaries.mTemporaryIndex ++
      [!?ioInstructionGenerationList appendGetArrayElementReference
        !result
        !ioObjectPtr
        ![indexResult llvmName]
      ]
      ioObjectPtr = result      
  else
    error inErrorLocation : "index expression is not an integer" : ioObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
