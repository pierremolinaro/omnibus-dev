#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handleArraySubscriptNew
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?arraySize:let @bigint inArraySize
  ?elementType:let @PLMType inElementType
  ?!@instructionListIR ioInstructionGenerationList
  !@objectIR outIndexIR
{
#--- Analyze index expression
  [inIndexExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:voidType ()
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR indexResult
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?indexResult
  ]  
  if [indexResult isLiteralInteger] then # Static expression
    [indexResult literalInteger ?1* ?value:let @bigint indexValue]
    if (indexValue < 0G) || (indexValue >= inArraySize) then
      error inErrorLocation : "static index should be positive and < " + inArraySize : outIndexIR
    else
      outIndexIR = @objectIR.literalInteger {!type:inElementType !value:indexValue}
    end
  elsif [[indexResult type].kind isInteger] then
    if not [option plm_options.noPanicGeneration value] then
      [!?ioInstructionGenerationList testArrayIndex
        !indexResult
        !inErrorLocation
        !inArraySize
        ?let @bool generatePanicInstruction
      ]
      if generatePanicInstruction && not [inRoutineAttributes panicAllowed] then
        error inErrorLocation : "index computation can generate panic"
      end
    end
    outIndexIR = indexResult
  else
    error inErrorLocation : "index expression is not an integer" : outIndexIR
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc handleArraySubscript
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?let @expressionAST inIndexExpression 
  ?let @location inErrorLocation
  ?arraySize:let @bigint inArraySize
  ?elementType:let @PLMType inElementType
  ?!@instructionListIR ioInstructionGenerationList
  ?!@objectIR ioObjectPtr
{
#--- Analyze index expression
  [inIndexExpression analyzeExpression
    !self:inSelfType
    !routineAttributes:inRoutineAttributes
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:voidType ()
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticEntityMap:ioStaticEntityMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?result:@objectIR indexResult
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !?indexResult
  ]  
  if [indexResult isLiteralInteger] then # Static expression
    [indexResult literalInteger ?1* ?value:let @bigint indexValue]
    if (indexValue < 0G) || (indexValue >= inArraySize) then
      error inErrorLocation : "static index should be positive and < " + inArraySize : ioObjectPtr
    else
      [!?ioTemporaries newTempLLVMVar ?let llvmName]
      let result = @objectIR.reference {!type:inElementType !llvmName:llvmName}
      [!?ioInstructionGenerationList appendGetArrayElementReference
        !result
        !ioObjectPtr
        !indexResult
      ]
      ioObjectPtr = result      
    end
  elsif [[indexResult type].kind isInteger] then
    if not [option plm_options.noPanicGeneration value] then
      [!?ioInstructionGenerationList testArrayIndex
        !indexResult
        !inErrorLocation
        !inArraySize
        ?let @bool generatePanicInstruction
      ]
      if generatePanicInstruction && not [inRoutineAttributes panicAllowed] then
        error inErrorLocation : "index computation can generate panic" : ioObjectPtr
      end
    end
      [!?ioTemporaries newTempLLVMVar ?let llvmName]
      let result = @objectIR.reference {!type:inElementType !llvmName:llvmName}
      [!?ioInstructionGenerationList appendGetArrayElementReference
        !result
        !ioObjectPtr
        !indexResult
      ]
      ioObjectPtr = result      
  else
    error inErrorLocation : "index expression is not an integer" : ioObjectPtr
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
