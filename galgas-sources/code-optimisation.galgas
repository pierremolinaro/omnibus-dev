#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    C O D E    O P T I M I S A T I O N                                                                                 
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @accessibleEntities {
  @stringset mAccessibleRegisterSet
  @stringset mProcedureSet
  @stringset mFunctionSet
  @stringset mSectionSet
  @stringset mServiceSet
  @stringset mGlobalVariableSet
  @stringset mTaskProcedureSet
  @stringset mTaskVariableSet
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @objectInMemoryIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  switch self
  case register (* @lstring name *) :
    ioAccessibleEntities.mAccessibleRegisterSet += !name.string
  case globalVariable (* @string name *) :
    ioAccessibleEntities.mGlobalVariableSet += !name
  case taskVariable (* @string taskName @string name) :
    ioAccessibleEntities.mTaskVariableSet += !taskName + "." + name
  case localValue (* @string unused name) :
  case globalConstant (* @string name) :
    ioAccessibleEntities.mGlobalVariableSet += !name
  case fieldAccess (@unifiedTypeMap-proxy unused objectType
                    @string unused objectName
                    @unifiedTypeMap-proxy unused fielfType
                    @uint unused fieldIndex) :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @instructionListIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  for (instruction) in self do
    [instruction enterAccessibleEntities !?ioAccessibleEntities]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @sectionMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @serviceMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @taskProcedureMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc codeOptimisation
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let initialProcedureMap = ioIntermediateCodeStruct.mRoutineMapIR
  let initialFunctionMap = ioIntermediateCodeStruct.mFunctionMapIR
  @uint pass = 0
  @bool optimizing = true
  loop ([ioIntermediateCodeStruct.mRoutineMapIR count] + [ioIntermediateCodeStruct.mFunctionMapIR count] + 1)
  while optimizing do
    optimizing = false
    pass ++
  #--- Display
    if [option plm_options.optimization_displayDeadCodeElimination value] then
      var s = "Optimisation pass " + pass + "\n"
      s += "  " + [ioIntermediateCodeStruct.mControlRegisterMap count] + " registers\n"
      s += "  " + [ioIntermediateCodeStruct.mStaticStringMap count] + " static strings\n"
      s += "  " + [ioIntermediateCodeStruct.mGlobalConstantMap count] + " global constants\n"
      s += "  " + [ioIntermediateCodeStruct.mGlobalVariableMap count] + " global variables\n"
      s += "  " + [ioIntermediateCodeStruct.mRoutineMapIR count] + " routines\n"
      s += "  " + [ioIntermediateCodeStruct.mFunctionMapIR count] + " functions\n"
      message s
    end
  #------------------------------------------- loop through sub programs
    suppressInaccessibleSubprograms (
      !?intermediateCode:ioIntermediateCodeStruct
      ?@accessibleEntities accessibleEntities
      !?optimizing
    )
  #--- Suppress unused registers
    @controlRegisterMapIR usedRegisterMap = {}
    for (@lstring lkey @string registerTypeName @bigint registerAddress) in ioIntermediateCodeStruct.mControlRegisterMap do
      if [accessibleEntities.mAccessibleRegisterSet hasKey !lkey.string] then
        [!?usedRegisterMap insertKey !lkey !registerTypeName !registerAddress]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mControlRegisterMap = usedRegisterMap
  #--- Suppress global constant
    @globalConstantMapIR globalConstantMap = {}
    for constant in ioIntermediateCodeStruct.mGlobalConstantMap do
      if [accessibleEntities.mGlobalVariableSet hasKey !constant.lkey.string] then
        [!?globalConstantMap insertKey !constant.lkey !constant.mType !constant.mSourceExpression]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mGlobalConstantMap = globalConstantMap
  #--- Suppress unused global variables
    @globalVariableMapIR globalVariableMap = {}
    for globalVariable in ioIntermediateCodeStruct.mGlobalVariableMap do
      if [accessibleEntities.mGlobalVariableSet hasKey !globalVariable.lkey.string] then
        [!?globalVariableMap insertKey
          !globalVariable.lkey
          !globalVariable.mType
          !globalVariable.mGenerateVolatile
          !globalVariable.mInitialValue
        ]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mGlobalVariableMap = globalVariableMap
  end
#--- Warn on unused procedures
  for () in initialProcedureMap do
    if (not [ioIntermediateCodeStruct.mRoutineMapIR hasKey !lkey.string]) && mWarnIfUnused then
      warning lkey: "unused procedure; use @" + noWarningIfUnusedAttribute () + " attribute for removing this warning"
    end
  end
#--- Warn on unused function
  for () in initialFunctionMap do
    if (not [ioIntermediateCodeStruct.mFunctionMapIR hasKey !lkey.string]) && mWarnIfUnused then
      warning lkey: "unused function; use @" + noWarningIfUnusedAttribute () + " attribute for removing this warning"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc suppressInaccessibleSubprograms
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  !@accessibleEntities outAccessibleEntities
  ?!@bool ioOptimizing
{
  outAccessibleEntities = .default
  @routineMapIR accessibleProcedureMap = {}
  @routineMapIR nonExploredProcedureMap = {}
#--- First, required procedures
  for procedure in ioIntermediateCodeStruct.mRoutineMapIR do
    if procedure.mIsRequired then
      [!?accessibleProcedureMap insertKey
        !procedure.lkey
        !procedure.mFormalArgumentListForGeneration
        !procedure.mInstructionGenerationList
        !procedure.mIsRequired
        !procedure.mWarnIfUnused
        !procedure.mWeak
        !procedure.mNullOnNoException
        !procedure.mGlobal
        !procedure.mKind
      ]        
      [procedure enterAccessibleEntities !?outAccessibleEntities]
      outAccessibleEntities.mProcedureSet += !procedure.lkey.string
    else
      [!?nonExploredProcedureMap insertKey
        !procedure.lkey
        !procedure.mFormalArgumentListForGeneration
        !procedure.mInstructionGenerationList
        !procedure.mIsRequired
        !procedure.mWarnIfUnused
        !procedure.mWeak
        !procedure.mNullOnNoException
        !procedure.mGlobal
        !procedure.mKind
      ]        
    end
  end
#--- Then, boot and init clauses
  for boot in ioIntermediateCodeStruct.mBootList do
    [boot.mInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
  end
  for init in ioIntermediateCodeStruct.mInitList do
    [init.mInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
  end
#--- Tasks (setup and loop)
  for task in ioIntermediateCodeStruct.mTaskMapIR do
    outAccessibleEntities.mTaskProcedureSet += !task.lkey.string + ".setup"
    outAccessibleEntities.mTaskProcedureSet += !task.lkey.string + ".loop"
  end
#--- Panic clauses (if exception code is generated)
  if not [option plm_options.noPanicGeneration value] then
    [ioIntermediateCodeStruct.mPanicSetupInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
    [ioIntermediateCodeStruct.mPanicLoopInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
  end
#--- Explore routines
  @functionMapIR accessibleFunctionMap  = {}
  @functionMapIR nonExploredFunctionMap = ioIntermediateCodeStruct.mFunctionMapIR
  @sectionMapIR  accessibleSectionMap   = {}
  @sectionMapIR  nonExploredSectionMap  = ioIntermediateCodeStruct.mSectionMapIR
  @serviceMapIR  accessibleServiceMap   = {}
  @serviceMapIR  nonExploredServiceMap  = ioIntermediateCodeStruct.mServiceMapIR
  @taskProcedureMapIR  accessibleTaskProcMap   = {}
  @taskProcedureMapIR  nonExploredTaskProcMap  = ioIntermediateCodeStruct.mTaskProcedureMap
  var continues = true
  let bound = [ioIntermediateCodeStruct.mRoutineMapIR count]
    + [ioIntermediateCodeStruct.mFunctionMapIR count]
    + [ioIntermediateCodeStruct.mSectionMapIR count]
    + [ioIntermediateCodeStruct.mServiceMapIR count]
  loop (bound + 1) while continues do
    continues = false
    exploreProcs (!?accessibleProcedureMap !?outAccessibleEntities !?nonExploredProcedureMap !?continues)
    exploreFunctions (!?accessibleFunctionMap !?outAccessibleEntities !?nonExploredFunctionMap !?continues)
    exploreSections (!?accessibleSectionMap !?outAccessibleEntities !?nonExploredSectionMap !?continues)
    exploreServices (!?accessibleServiceMap !?outAccessibleEntities !?nonExploredServiceMap !?continues)
    exploreTaskProcs (!?accessibleTaskProcMap !?outAccessibleEntities !?nonExploredTaskProcMap !?continues)
  end
  if ioIntermediateCodeStruct.mRoutineMapIR != accessibleProcedureMap then
    ioIntermediateCodeStruct.mRoutineMapIR = accessibleProcedureMap
    ioOptimizing = true
  end
  if ioIntermediateCodeStruct.mFunctionMapIR != accessibleFunctionMap then
    ioIntermediateCodeStruct.mFunctionMapIR = accessibleFunctionMap
    ioOptimizing = true
  end
  if ioIntermediateCodeStruct.mSectionMapIR != accessibleSectionMap then
    ioIntermediateCodeStruct.mSectionMapIR = accessibleSectionMap
    ioOptimizing = true
  end
  if ioIntermediateCodeStruct.mServiceMapIR != accessibleServiceMap then
    ioIntermediateCodeStruct.mServiceMapIR = accessibleServiceMap
    ioOptimizing = true
  end
  if ioIntermediateCodeStruct.mTaskProcedureMap != accessibleTaskProcMap then
    ioIntermediateCodeStruct.mTaskProcedureMap = accessibleTaskProcMap
    ioOptimizing = true
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc exploreProcs
  ?!@routineMapIR ioAccessibleProcedureMap
  ?!@accessibleEntities ioAccessibleEntities
  ?!@routineMapIR ioNonExploredProcedureMap
  ?!@bool ioContinueExploreRoutines
{
  let @routineMapIR exNonExploredProcedureMap = ioNonExploredProcedureMap
  ioNonExploredProcedureMap = {}
  for procedure in exNonExploredProcedureMap do
    if [ioAccessibleEntities.mProcedureSet hasKey !procedure.lkey.string] then
      [!?ioAccessibleProcedureMap insertKey
        !procedure.lkey
        !procedure.mFormalArgumentListForGeneration
        !procedure.mInstructionGenerationList
        !procedure.mIsRequired
        !procedure.mWarnIfUnused
        !procedure.mWeak
        !procedure.mNullOnNoException
        !procedure.mGlobal
        !procedure.mKind
      ]        
      [procedure enterAccessibleEntities !?ioAccessibleEntities]
      ioContinueExploreRoutines = true
    else
      [!?ioNonExploredProcedureMap insertKey
        !procedure.lkey
        !procedure.mFormalArgumentListForGeneration
        !procedure.mInstructionGenerationList
        !procedure.mIsRequired
        !procedure.mWarnIfUnused
        !procedure.mWeak
        !procedure.mNullOnNoException
        !procedure.mGlobal
        !procedure.mKind
    ]        
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc exploreFunctions
  ?!@functionMapIR ioAccessibleFunctionMap
  ?!@accessibleEntities ioAccessibleEntities
  ?!@functionMapIR ioNonExploredFunctionMap
  ?!@bool ioContinueExploreRoutines
{
  let @functionMapIR exNonExploredFunctionMap = ioNonExploredFunctionMap
  ioNonExploredFunctionMap = {}
  for function in exNonExploredFunctionMap do
    if [ioAccessibleEntities.mFunctionSet hasKey !function.lkey.string] then
      [!?ioAccessibleFunctionMap insertKey
        !function.lkey
        !function.mFormalArgumentListForGeneration
        !function.mInstructionGenerationList
        !function.mResultType
        !function.mResultVarName
        !function.mWarnIfUnused
      ]        
      [function enterAccessibleEntities !?ioAccessibleEntities]
      ioContinueExploreRoutines = true
    else
      [!?ioNonExploredFunctionMap insertKey
        !function.lkey
        !function.mFormalArgumentListForGeneration
        !function.mInstructionGenerationList
        !function.mResultType
        !function.mResultVarName
        !function.mWarnIfUnused
      ]        
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc exploreSections
  ?!@sectionMapIR ioAccessibleSectionMap
  ?!@accessibleEntities ioAccessibleEntities
  ?!@sectionMapIR ioNonExploredSectionMap
  ?!@bool ioContinueExploreRoutines
{
  let @sectionMapIR exNonExploredServiceMap = ioNonExploredSectionMap
  ioNonExploredSectionMap = {}
  for section in exNonExploredServiceMap do
    if [ioAccessibleEntities.mSectionSet hasKey !section.lkey.string] then
      [!?ioAccessibleSectionMap insertKey
        !section.lkey
        !section.mFormalArgumentListForGeneration
        !section.mInstructionGenerationList
        !section.mWarnIfUnused
      ]        
      [section enterAccessibleEntities !?ioAccessibleEntities]
      ioContinueExploreRoutines = true
    else
      [!?ioNonExploredSectionMap insertKey
        !section.lkey
        !section.mFormalArgumentListForGeneration
        !section.mInstructionGenerationList
        !section.mWarnIfUnused
      ]        
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc exploreServices
  ?!@serviceMapIR ioAccessibleServiceMap
  ?!@accessibleEntities ioAccessibleEntities
  ?!@serviceMapIR ioNonExploredServiceMap
  ?!@bool ioContinueExploreRoutines
{
  let @serviceMapIR exNonExploredServiceMap = ioNonExploredServiceMap
  ioNonExploredServiceMap = {}
  for service in exNonExploredServiceMap do
    if [ioAccessibleEntities.mServiceSet hasKey !service.lkey.string] then
      [!?ioAccessibleServiceMap insertKey
        !service.lkey
        !service.mFormalArgumentListForGeneration
        !service.mInstructionGenerationList
        !service.mWarnIfUnused
      ]        
      [service enterAccessibleEntities !?ioAccessibleEntities]
      ioContinueExploreRoutines = true
    else
      [!?ioNonExploredServiceMap insertKey
        !service.lkey
        !service.mFormalArgumentListForGeneration
        !service.mInstructionGenerationList
        !service.mWarnIfUnused
      ]        
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc exploreTaskProcs
  ?!@taskProcedureMapIR ioAccessibleTaskProcMap
  ?!@accessibleEntities ioAccessibleEntities
  ?!@taskProcedureMapIR ioNonExploredTaskProcMap
  ?!@bool ioContinueExploreRoutines
{
  let @taskProcedureMapIR exNonExploredTaskProcMap = ioNonExploredTaskProcMap
  ioNonExploredTaskProcMap = {}
  for taskProc in exNonExploredTaskProcMap do
    if [ioAccessibleEntities.mTaskProcedureSet hasKey !taskProc.lkey.string] then
      [!?ioAccessibleTaskProcMap insertKey
        !taskProc.lkey
        !taskProc.mInstructionGenerationList
        !taskProc.mWarnIfUnused
      ]        
      [taskProc enterAccessibleEntities !?ioAccessibleEntities]
      ioContinueExploreRoutines = true
    else
      [!?ioNonExploredTaskProcMap insertKey
        !taskProc.lkey
        !taskProc.mInstructionGenerationList
        !taskProc.mWarnIfUnused
      ]        
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

