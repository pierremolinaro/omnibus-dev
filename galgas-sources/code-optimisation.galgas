#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C O D E    O P T I M I S A T I O N                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

struct @accessibleEntities {
  @stringset mAccessibleRegisterSet
  @stringset mStaticStringSet
  @stringset mGlobalConstantSet
  @stringset mProcedureSet
  @stringset mFunctionSet
  @stringset mGlobalVariableSet
}

#----------------------------------------------------------------------------------------------------------------------*

method @variableKindIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  switch self
  case register (@string name) :
    ioAccessibleEntities.mAccessibleRegisterSet += !name
  case globalConstant (@string name) :
    ioAccessibleEntities.mGlobalConstantSet += !name
  case globalVariable (@string name) :
    ioAccessibleEntities.mGlobalVariableSet += !name
  case localVariable (@string unused name) :
  case inArgument (@string unused name) :
  case inOutArgument (@string unused name) :
  case outArgument (@string unused name) :
  case localConstant (@string unused name) :
  case temporaryConstant (@uint unused idx) :
  case localAccess (@string unused access) :
  case literalUnsignedInteger (*) :
  case literalSignedInteger (*) :
  case literalString (@string value @string unused name) :
    ioAccessibleEntities.mStaticStringSet += !value
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities

#----------------------------------------------------------------------------------------------------------------------*

method @instructionListIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  for (instruction) in self do
    [instruction enterAccessibleEntities !?ioAccessibleEntities]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @procedureMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*

method @functionMapIR-element enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  [mInstructionGenerationList enterAccessibleEntities !?ioAccessibleEntities]
}

#----------------------------------------------------------------------------------------------------------------------*

proc codeOptimisation
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let initialProcedureMap = ioIntermediateCodeStruct.mProcedureMapIR
  @uint pass = 0
  @bool optimizing = true
  loop ([ioIntermediateCodeStruct.mProcedureMapIR count] + [ioIntermediateCodeStruct.mFunctionMapIR count] + 1)
  while optimizing do
    optimizing = false
    pass ++
  #--- Display
    var s = "Optimisation pass " + pass + "\n"
    s += "  " + [ioIntermediateCodeStruct.mRegisterMap count] + " registers\n"
    s += "  " + [ioIntermediateCodeStruct.mGlobalLiteralStringMap count] + " static strings\n"
    s += "  " + [ioIntermediateCodeStruct.mGlobalConstantMap count] + " global constants\n"
    s += "  " + [ioIntermediateCodeStruct.mGlobalVariableMap count] + " global variables\n"
    s += "  " + [ioIntermediateCodeStruct.mProcedureMapIR count] + " procedures\n"
    s += "  " + [ioIntermediateCodeStruct.mFunctionMapIR count] + " functions\n"
    message s
  #------------------------------------------- loop through sub programs
    suppressInaccessibleSubprograms (
      !?intermediateCode:ioIntermediateCodeStruct
      ?@accessibleEntities accessibleEntities
      !?optimizing
    )
  #--- Suppress unused registers
    @registerMapIR usedRegisterMap = {}
    for (@lstring lkey @string registerTypeName @uint64 registerAddress) in ioIntermediateCodeStruct.mRegisterMap do
      if [accessibleEntities.mAccessibleRegisterSet hasKey !lkey.string] then
        [!?usedRegisterMap insertKey !lkey !registerTypeName !registerAddress]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mRegisterMap = usedRegisterMap
  #--- Suppress global constant
    @globalConstantMapIR globalConstantMap = {}
    for constant in ioIntermediateCodeStruct.mGlobalConstantMap do
      if [accessibleEntities.mGlobalConstantSet hasKey !constant.lkey.string] then
        [!?globalConstantMap insertKey !constant.lkey !constant.mValueExpressionGeneration]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mGlobalConstantMap = globalConstantMap
  #--- Suppress static strings
    @globalLiteralStringMap staticStringMap = {}
    for (@lstring lkey
         @string literalStringCname)
    in ioIntermediateCodeStruct.mGlobalLiteralStringMap do
      if [accessibleEntities.mStaticStringSet hasKey !lkey.string] then
        [!?staticStringMap insertKey !lkey !literalStringCname]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mGlobalLiteralStringMap = staticStringMap
  #--- Suppress unused global variables
    @globalVariableMapIR globalVariableMap = {}
    for globalVariable in ioIntermediateCodeStruct.mGlobalVariableMap do
      if [accessibleEntities.mGlobalVariableSet hasKey !globalVariable.lkey.string] then
        [!?globalVariableMap insertKey
          !globalVariable.lkey
          !globalVariable.mActualTypeName
          !globalVariable.mGenerateVolatile
          !globalVariable.mInitialValue
        ]
      else
        optimizing = true
      end
    end
    ioIntermediateCodeStruct.mGlobalVariableMap = globalVariableMap
  end
#--- Warn on unused procedures
  for () in initialProcedureMap do
    if (not [ioIntermediateCodeStruct.mProcedureMapIR hasKey !lkey.string]) && mWarnIfUnused then
      warning lkey: "unused procedure; use @" + noWarningIfUnusedAttribute () + " attribute for removing this warning"
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

private proc suppressInaccessibleSubprograms
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
  !@accessibleEntities outAccessibleEntities
  ?!@bool ioOptimizing
{
  outAccessibleEntities = .default
  @procedureMapIR accessibleProcedureMap = {}
  @procedureMapIR nonExploredProcedureMap = {}
#--- First, required procedures
  for procedure in ioIntermediateCodeStruct.mProcedureMapIR do
    if procedure.mIsRequired then
      [!?accessibleProcedureMap insertKey
        !procedure.lkey
        !procedure.mFormalArgumentListForGeneration
        !procedure.mInstructionGenerationList
        !procedure.mIsRequired
        !procedure.mWarnIfUnused
        !procedure.mWeak
      ]        
      [procedure enterAccessibleEntities !?outAccessibleEntities]
      outAccessibleEntities.mProcedureSet += !procedure.lkey.string
    else
      [!?nonExploredProcedureMap insertKey
        !procedure.lkey
        !procedure.mFormalArgumentListForGeneration
        !procedure.mInstructionGenerationList
        !procedure.mIsRequired
        !procedure.mWarnIfUnused
        !procedure.mWeak
      ]        
    end
  end
#--- Then, init clauses
  for init in ioIntermediateCodeStruct.mInitList do
    [init.mInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
  end
#--- Exception clause (if exception code is generated)
  if not [option plm_options.noExceptionGeneration value] then
    [ioIntermediateCodeStruct.mExceptionSetupInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
    [ioIntermediateCodeStruct.mExceptionLoopInstructionListIR enterAccessibleEntities !?outAccessibleEntities]
  end
#--- Explore procedures and functions
  @functionMapIR accessibleFunctionMap = {}
  @functionMapIR nonExploredFunctionMap = ioIntermediateCodeStruct.mFunctionMapIR
  var exploreProceduresAndFunctions = true
  loop ([ioIntermediateCodeStruct.mProcedureMapIR count] + [ioIntermediateCodeStruct.mFunctionMapIR count] + 1)
  while exploreProceduresAndFunctions do
    exploreProceduresAndFunctions = false
    let @procedureMapIR exNonExploredProcedureMap = nonExploredProcedureMap
    nonExploredProcedureMap = {}
    for procedure in exNonExploredProcedureMap do
      if [outAccessibleEntities.mProcedureSet hasKey !procedure.lkey.string] then
        [!?accessibleProcedureMap insertKey
          !procedure.lkey
          !procedure.mFormalArgumentListForGeneration
          !procedure.mInstructionGenerationList
          !procedure.mIsRequired
          !procedure.mWarnIfUnused
          !procedure.mWeak
        ]        
        [procedure enterAccessibleEntities !?outAccessibleEntities]
        exploreProceduresAndFunctions = true
      else
        [!?nonExploredProcedureMap insertKey
          !procedure.lkey
          !procedure.mFormalArgumentListForGeneration
          !procedure.mInstructionGenerationList
          !procedure.mIsRequired
          !procedure.mWarnIfUnused
          !procedure.mWeak
        ]        
      end
    end
    let @functionMapIR exNonExploredFunctionMap = nonExploredFunctionMap
    nonExploredFunctionMap = {}
    for function in exNonExploredFunctionMap do
      if [outAccessibleEntities.mFunctionSet hasKey !function.lkey.string] then
        [!?accessibleFunctionMap insertKey
          !function.lkey
          !function.mFormalArgumentListForGeneration
          !function.mInstructionGenerationList
          !function.mResultType
          !function.mResultVarName
        ]        
        [function enterAccessibleEntities !?outAccessibleEntities]
        exploreProceduresAndFunctions = true
      else
        [!?nonExploredFunctionMap insertKey
          !function.lkey
          !function.mFormalArgumentListForGeneration
          !function.mInstructionGenerationList
          !function.mResultType
          !function.mResultVarName
        ]        
      end
    end
  end
  if ioIntermediateCodeStruct.mProcedureMapIR != accessibleProcedureMap then
    ioIntermediateCodeStruct.mProcedureMapIR = accessibleProcedureMap
    ioOptimizing = true
  end
  if ioIntermediateCodeStruct.mFunctionMapIR != accessibleFunctionMap then
    ioIntermediateCodeStruct.mFunctionMapIR = accessibleFunctionMap
    ioOptimizing = true
  end
}

#----------------------------------------------------------------------------------------------------------------------*

