#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#                                                                                                                       
#    C O D E    O P T I M I Z A T I O N                                                                                 
#                                                                                                                       
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

abstract method @abstractInstructionIR enterAccessibleEntities
  ?!@stringset ioInvokedRoutineSet
  ?!@uint ioMaxBranchOfOnInstructions

#Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·

method @instructionListIR enterAccessibleEntities ?!@stringset ioInvokedRoutineSet ?!@uint ioMaxBranchOfOnInstructions {
  for (instruction) in self do
    [instruction enterAccessibleEntities !?ioInvokedRoutineSet !?ioMaxBranchOfOnInstructions]
  end
}

#Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·

list @routineAccessibilityIR {
  @abstractRoutineIR mRoutine
  @stringset mAccessibleRoutineSet
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

proc codeOptimization
 ?let @string inSourceFile
 ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  @uint maxBranchOfOnInstructions = 0
  @routineAccessibilityIR routineAccessibilityIR = {}
#--- Compute accessiblity graph
  @stringset exploreRoutineSet = {}
  for routine in ioIntermediateCodeStruct.mRoutineListIR do
    @stringset accessibleRoutineSet = {}
    [routine.mRoutine enterAccessibleEntities !?accessibleRoutineSet !?maxBranchOfOnInstructions]
    routineAccessibilityIR += !routine.mRoutine !accessibleRoutineSet
    if routine.mRoutine.mIsRequired then
      exploreRoutineSet += !routine.mRoutine.mRoutineMangledName
    end
  end
  if [option plm_options.optimization_displayDeadCodeElimination value] |true then
    var m = "Dead Code Elimination\n"
    m += "  " + [[ioIntermediateCodeStruct.mRoutineListIR length] string] + " routines, "
    m += [[exploreRoutineSet count] string] + " root routines.\n"
    message m
  end
#--- Compute useful routines
  @stringset usefulRoutineSet = {}
  loop ([ioIntermediateCodeStruct.mRoutineListIR length] + 1) while [exploreRoutineSet count] > 0 do
    let currentSet = exploreRoutineSet
    exploreRoutineSet = {}
    for routine in routineAccessibilityIR do
      let routineMangledName = routine.mRoutine.mRoutineMangledName
      if [currentSet hasKey !routineMangledName] & not [usefulRoutineSet hasKey !routineMangledName] then
        usefulRoutineSet += !routineMangledName
        exploreRoutineSet += routine.mAccessibleRoutineSet
      end
    end
  end
  if [option plm_options.optimization_displayDeadCodeElimination value] |true then
    var m = "  " + [[usefulRoutineSet count] string] + " useful routines.\n"
#    for (r) in usefulRoutineSet do
#      m += "    - " + r + "\n"
#    end
    message m
  end
#--- Eliminate useless routines
#  ioIntermediateCodeStruct.mRoutineListIR = {}
#  for (routine *) in routineAccessibilityIR do
#    if [usefulRoutineSet hasKey !routine.mRoutineMangledName] then
#      ioIntermediateCodeStruct.mRoutineListIR += !routine
#    end
#  end
#--- Display invocation graph
  let filePath = inSourceFile + ".routineInvocation.dot"
  if [option plm_options.emitRoutineInvocationGraphFile value] |true then
    displayInvocationGraph (!ioIntermediateCodeStruct.mRoutineListIR !filePath)
  else
    [@string deleteFileIfExists !filePath]
  end
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

private proc displayInvocationGraph
  ?let @routineListIR inRoutineListIR
  ?let @string inFilePath
{
  var s = "digraph G {\n"
#--- Build graph
  @stringset definedRoutines = {}
  @stringset allRoutines = {}
  for (routine) in inRoutineListIR do
    definedRoutines += !routine.mRoutineMangledName
    allRoutines += !routine.mRoutineMangledName
    @stringset accessibleRoutineSet = {}
    [routine enterAccessibleEntities !?accessibleRoutineSet !?*]
    allRoutines += accessibleRoutineSet
    s += "  \"" + routine.mRoutineMangledName + "\" [shape=rectangle"
    if routine.mIsRequired then
      s += ", color=blue" # Required routines are blue
    end
    s += "] ;\n"
    for accessible in accessibleRoutineSet do
      s += "  \"" + routine.mRoutineMangledName + "\" -> \"" + accessible + "\" ;\n"
    end
  end
#--- For undefined routines, create red nodes
  let undefinedRoutineSet = allRoutines - definedRoutines
  for undefined in undefinedRoutineSet do
    s += "  \"" + undefined + "\" [shape=rectangle, color=red] ;\n"  
  end
  s += "}\n"
  [s writeToFileWhenDifferentContents !inFilePath ?*]
  if [undefinedRoutineSet count] > 0 then
    error .nowhere : [[undefinedRoutineSet count] string] + " undefined routine(s) in routine invocation graph"
  end
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
