#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @throwInstructionAST : @instructionAST {
  @location mThrowLocation
  @expressionAST mCodeExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
    $throw$
    let loc = @location.here
    <expression> ?let @expressionAST codeExpression
    ioInstructionList += !@throwInstructionAST.new {!loc !codeExpression}
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @throwInstructionAST analyze
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Exception allowed ?
  if [inModeSet hasKey !exceptionModeName ()] then
    error mThrowLocation : "operations that can generate exceptions are not allowed in $" + exceptionModeName () + " mode"
  end
#--- Analyze expression
  @instructionListIR unusedInstructionListIR = {}
  [mCodeExpression analyzeExpression
    !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
    !optionalReceiverType:inReceiverType
    !optionalTargetType:inContext.mExceptionCodeType
    !context:inContext
    !modes:inModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:unusedInstructionListIR
    ?result:@operandIR result
  ]
#--- Expression type check
  if [result.mType key] != [inContext.mExceptionCodeType key] then
    error mThrowLocation
    : "throw expression type is " + [result.mType key] + ", required type is " + [inContext.mExceptionCodeType key]
  end
#--- Expression is static ?
  if ([unusedInstructionListIR length] > 0) || not [result.mValue isStatic] then
    error mThrowLocation : "throw expression cannot be statically computed"
  end
#--- Code generation
  if not [option plm_options.noExceptionGeneration value] then
    ioInstructionGenerationList += !@throwInstructionIR.new {
      !mThrowLocation
      !result
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @throwInstructionIR : @abstractInstructionIR {
  @location mThrowInstructionLocation
  @operandIR mCode
}

#----------------------------------------------------------------------------------------------------------------------*

override method @throwInstructionIR llvmInstructionCode
  ?!@string ioCode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioCode += "raise_exception (" + mCode.mValue
     + ", " + [[[mThrowInstructionLocation file] lastPathComponent] utf8Representation]
     + ", " + [mThrowInstructionLocation line] + ") ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @throwInstructionIR enterAccessibleEntities ?!@accessibleEntities unused ioAccessibleEntities {
}

#----------------------------------------------------------------------------------------------------------------------*
