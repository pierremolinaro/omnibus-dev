#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @throwInstructionAST : @instructionAST {
  @luint64 mThrowInstructionCode
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $throw$
    $integer$ ?let @luint64 throwCode
    ioInstructionList += !@throwInstructionAST.new {!throwCode}
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @throwInstructionAST analyze
  ?optionalReceiverType:let @receiverType unused inReceiverType
  ?context:let @semanticContext unused inContext
  ?modes:let @stringset inModeSet
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@uint unused ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
  ?!variableMap:@variableMap unused ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  if [inModeSet hasKey !exceptionModeName ()] then
    error mThrowInstructionCode : "operations that can generate exception are not allowed in $" + exceptionModeName () + " mode"
  end
  @uint code
  if mThrowInstructionCode.uint64 <= [@uint.max uint64] then
    code = [mThrowInstructionCode.uint64 uint]
  else
    error mThrowInstructionCode: "throw code should be <= " + @uint.max : code
  end
#--- Code generation
  if not [option plm_options.noExceptionGeneration value] then
    ioInstructionGenerationList += !@throwInstructionIR.new {
      !mThrowInstructionCode.location
      !code
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @throwInstructionIR : @abstractInstructionIR {
  @location mThrowInstructionLocation
  @uint mCode
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @throwInstructionIR instructionCode -> @string outCode {
  outCode = "raise_exception (" + mCode
     + ", " + [[[mThrowInstructionLocation file] lastPathComponent] utf8Representation]
     + ", " + [mThrowInstructionLocation line] + ") ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @throwInstructionIR enterAccessibleEntities ?!@accessibleEntities unused ioAccessibleEntities {
}

#----------------------------------------------------------------------------------------------------------------------*
