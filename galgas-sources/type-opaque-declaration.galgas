#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @typeOpaqueDeclarationAST : @abstractDeclarationAST {
  @lstring mOpaqueTypeName
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
  @lstringlist mAttributeList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $opaque$
    $\$type$ ?let opaqueTypeName
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    ${$
    <expression> !?ioAST ?let sizeExpression
    let sizeExpressionLocation = @location.here
    $}$
    ioAST.mDeclarationListAST += !@typeOpaqueDeclarationAST.new {
      !opaqueTypeName
      !sizeExpression
      !sizeExpressionLocation
      !attributeList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @typeOpaqueDeclarationAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [!?ioGraph noteNode !mOpaqueTypeName]
  [mSizeExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#·······················································································································

override method @typeOpaqueDeclarationAST enterInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
#--- Add structure type name as node
  [!?ioGraph addNode !mOpaqueTypeName !self]
#--- Add size expression
  [mSizeExpression addDependenceEdgeForStaticExpression !mOpaqueTypeName !?ioGraph]
}

#·······················································································································

override getter @typeOpaqueDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "opaque " + mOpaqueTypeName 
}

#·······················································································································

override getter @typeOpaqueDeclarationAST locationForErrorSignaling -> @location outLocation {
  outLocation = mOpaqueTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeOpaqueDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues:@staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!registerUserAccess:@controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes:@userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
  @omnibusTypeAttributes opaqueTypeAttributes = .none
  var copyable = false
  for (attribute) in mAttributeList do
    if attribute.string == instantiableAttribute () then
      if [opaqueTypeAttributes instanciable] then
        error attribute : "duplicated attribute"
      else
        opaqueTypeAttributes = opaqueTypeAttributes | .instanciable
      end
    elsif attribute.string == copyableAttribute () then
      if copyable then
        error attribute : "duplicated attribute"
      else
        copyable = true
        opaqueTypeAttributes = opaqueTypeAttributes | .copyable
      end
    else
      error attribute
      : "only @" + copyableAttribute () + " and @" + instantiableAttribute ()
        + " attributes are allowed here"
    end
  end
#--- Compute array size
  computeStaticExpression (
    !?context: ioContext
    !?staticEntityMap:ioStaticEntityMap
    !expression:mSizeExpression
    !errorLocation:mSizeExpressionLocation
    !optionalContextualTypeName:["" nowhere]
    ?result:let @objectIR sizeExpressionIR
  )
  if not [sizeExpressionIR isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not a literal integer"
  else
    @constructorMap constructorMap = {}
    if [opaqueTypeAttributes instanciable] then
      [!?constructorMap insertKey !["()" nowhere] !{} !.simple {!value:0G}]
    end
    [sizeExpressionIR literalInteger ?1* ?value:let bitSize]
    let opaqueType = @omnibusType.new {
      !propertyGetterMap:{}
      !propertySetterMap: {}
      !routineMap: {}
      !classConstantMap:{}
      !constructorMap:constructorMap
      !guardMap:{}
      !subscript:.noSubscript
      !assignmentSources: if copyable then {!mOpaqueTypeName} else {} end
      !attributes:opaqueTypeAttributes
      !omnibusTypeDescriptionName:mOpaqueTypeName
      !kind:.opaque {!bitCount:bitSize}
      !llvmBaseTypeName:mOpaqueTypeName
    }
    [!?ioContext.mTypeMap insertType
      !lkey:mOpaqueTypeName
      !type:opaqueType
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
