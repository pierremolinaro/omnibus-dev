#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @opaqueTypeDeclarationAST : @abstractDeclarationAST {
  @lstring mOpaqueTypeName
  @lstringlist mAttributeList
  @expressionAST mSizeExpression
  @location mSizeExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @opaqueTypeDeclarationAST location -> @location outLocation {
  outLocation = mOpaqueTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <declaration_type> ?let @lstring inNewTypeName !@abstractDeclarationAST outDeclaration {
    $($
    $($
    <expression> ?let sizeExpression
    let sizeExpressionLocation = @location.here
    $)$
    $)$
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    outDeclaration = @opaqueTypeDeclarationAST.new {!inNewTypeName !attributeList !sizeExpression !sizeExpressionLocation}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclarationAST addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclarationAST outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclarationAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let typeName = llvmRegularTypeMangledNameFromName (!mOpaqueTypeName)
  [!?ioGraph addNode !typeName !self]
  [!?ioGraph addEdge !typeName !llvmRegularTypeMangledNameFromName (![staticIntegerTypeName () nowhere])]
  [mSizeExpression addDependenceEdgeForStaticExpression !typeName !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @opaqueTypeDeclarationAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "opaqueType $" + mOpaqueTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclarationAST enterInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticlistValues:@staticlistValues_listMap unused ioStaticListValueMap
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#---
  @uint flags = 0
  for (attribute) in mAttributeList do
    if attribute.string == "instantiable" then
      if (flags & instanciableFlag ()) != 0 then
        error attribute : "duplicated attribute"
      else
        flags = flags | instanciableFlag ()
      end
    elsif attribute.string == "copyable" then
      if (flags & copyableFlag ()) != 0 then
        error attribute : "duplicated attribute"
      else
        flags = flags | copyableFlag ()
      end
    else
      error attribute : "only @copyable and @instantiable attributes are allowed here"
    end
  end
#--- Compute array size
  @instructionListIR initInstructionGenerationList = {}
  @allocaList allocaList = {}
  @semanticTemporariesStruct temporaries = .default
  variableMapWithConstants (
    !context:ioContext
    ?@unifiedSymbolMapEx variableMap
    ?@universalPropertyAndRoutineMapForContext universalMap
  )
  [mSizeExpression analyzeExpression
    !self:.void
    !inGuard:false
    !routineNameForInvocationGraph:.new {!mOpaqueTypeName.string + " init" !mOpaqueTypeName.location}
    !optionalTargetType:.void
    !context:ioContext
    !mode:.bootMode
    !?temporary:temporaries
    !?staticStringMap:*
    !?variableMap:universalMap
    !?alloca:allocaList
    !?instructionListIR:initInstructionGenerationList
    ?result:let @objectIR sizeExpressionIR
  ]
  if (([allocaList length] + [initInstructionGenerationList length]) > 0) || not [sizeExpressionIR isLiteralInteger] then
    error mSizeExpressionLocation : "array size expression is not static"
  else
    [sizeExpressionIR literalInteger ?1* ?value:let bitSize]
    [!?ioContext.mTypeMap insertType
      !lkey:mOpaqueTypeName
      !type:.opaque {!bitCount:bitSize !flags:flags !plmTypeName:mOpaqueTypeName}
    ]
  #--- Constructor
    [!?ioContext.mConstructorMap insertKey
      !mOpaqueTypeName
      !.simple {!value:0G}
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclarationAST enterRoutinesInContext
  ?procedureDeclarationList:let @functionDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SOLVE ENTITIES                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclarationAST solveEntitiesForDeclarations
  ?context:let @semanticContext unused inSemanticContext
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclarationAST semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

