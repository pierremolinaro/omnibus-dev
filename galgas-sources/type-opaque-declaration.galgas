#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @opaqueTypeDeclaration : @abstractDeclaration {
  @lstring mOpaqueTypeName
  @lstringlist mAttributeList
  @lbigint mSize
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @opaqueTypeDeclaration location -> @location outLocation {
  outLocation = mOpaqueTypeName.location
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration_type> ?let @lstring inNewTypeName !@abstractDeclaration outDeclaration {
    $($
    $($
    $integer$ ?let bitSize
    $)$
    $)$
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end
    outDeclaration = @opaqueTypeDeclaration.new {!inNewTypeName !attributeList !bitSize}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ADD EXTENSION                                                                                                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclaration addExtension
  ?!@extensionDeclarationListAST unused ioExtensionDeclarationListAST
  !@abstractDeclaration outNewDeclaration
{
  outNewDeclaration = self
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let typeName = @lstring.new {!"$" + mOpaqueTypeName !mOpaqueTypeName.location}
  [!?ioGraph addNode !typeName !self]
  [!?ioGraph addEdge !typeName !["$" + staticIntegerTypeName () nowhere]]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @opaqueTypeDeclaration keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = "opaqueType $" + mOpaqueTypeName 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
#---
  var copyable = false ;
  var instantiable = false ;
  for (attribute) in mAttributeList do
    if attribute.string == "instantiable" then
      if instantiable then
        error attribute : "duplicated attribute"
      else
        instantiable = true
      end
    elsif attribute.string == "copyable" then
      if copyable then
        error attribute : "duplicated attribute"
      else
        copyable = true
      end
    else
      error attribute : "only @copyable and @instantiable attributes are allowed here"
    end
  end
#---
  if mSize.bigint == 0G then
    error mSize : "the opaque type size should be > 0"
  end
  [!?ioContext.mTypeMap insertKey
    !lkey:mOpaqueTypeName
    !llvmTypeName:"i" + mSize.bigint
    !kind:.opaque {!bitCount:mSize.bigint}
    !classMethodMap:{}
    !instantiable:instantiable
    !copyable:copyable
    !equatable:false
    !comparable:false
    !enumerationType:.null # Not enumerable
  ]
#--- Constructor
  [!?ioContext.mConstructorMap insertKey !mOpaqueTypeName !.simple {!value:0G}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclaration enterRoutinesInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext unused ioContext
  ?!staticStringMap:@staticStringMap unused ioGlobalLiteralStringMap
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @opaqueTypeDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

