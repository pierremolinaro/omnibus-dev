#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractCallInstructionAST : @instructionAST {
  @effectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @remoteRoutineCallInstructionAST : @abstractCallInstructionAST {
  @accessList mAccessList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
    <routine_call> ?let instructionLocation ?let @abstractCallInstructionAST call_instruction
    ioInstructionList += !instructionLocation !call_instruction
  }

  #·····················································································································

  rule <routine_call> !@location outInstructionLocation !@abstractCallInstructionAST outInstruction {
    <access> ?outInstructionLocation ?let @accessList accessList
    <effective_parameters> ?let effectiveParameterList ?*
    outInstruction = @remoteRoutineCallInstructionAST.new {
      !effectiveParameterList
      !accessList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeStandaloneRoutineCall
  ?routineName:let @lstring inRoutineName
  ?effectiveParameters:let @effectiveParameterListAST inEffectiveParameterList
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  analyzeRoutineCall (
    !self:inSelfType
    !propertiesAreMutable:inRoutineCanMutateProperties
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !receiverName:.new{!"" !inRoutineName.location}
    !routineName:inRoutineName
    !effective:inEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKindIR routineKindIR
    ?routineMangledName:let @lstring routineMangledName
    ?routineNameForGeneration:let @lstring routineNameForGeneration
    ?returnType:let @unifiedTypeMap-proxy returnedType
    ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
  )
  if returnedType != .null then
    error inRoutineName : "cannot be called in instruction: return value"
  end
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !"" # No receiver
    !routineMangledName
    !routineNameForGeneration
    !routineKindIR
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @remoteRoutineCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  @accessList accessList = mAccessList
  [!?accessList popLast ?let routineName ?let arrayElementAccess]
  if arrayElementAccess != .noAccess then
    error routineName : "array element access is not alowed here"
  end
  if [accessList length] == 0 then
    analyzeStandaloneRoutineCall (
      !routineName:routineName
      !effectiveParameters:mEffectiveParameterList
      !self:inSelfType
      !propertiesAreMutable:inRoutineCanMutateProperties
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !modes:inRequiredModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
    )
  else
  #---
    analyzeVariableAccess (
      !fieldList:accessList
      !self:inSelfType
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !inGuard:false
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !modes:inRequiredModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      ?resultPtr:let @objectInMemoryIR targetObjectPtr
    )
  #--- Extract base variable and access
    [accessList first ?let baseName ?*]
  #--- routine mangled name
    let receiverType = [targetObjectPtr type]
    var routineMangledName = @lstring.new {!"$" + [receiverType key] + "." + routineName !routineName.location}
    routineMangledName.string += "("
    for (passingMode selector) in mEffectiveParameterList do
      routineMangledName.string += [passingMode matchingFormalArgument]
      routineMangledName.string += selector.string
      routineMangledName.string += ":"
    end
    routineMangledName.string += ")"
  #--- Check target access
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    effectiveParameterListIR += !.outputInput ![targetObjectPtr address] #--- add "load receiver" as first argument
    [inContext.mRoutineMapForContext searchKey
      !routineMangledName
      ?let routineNameForGeneration
      ?let isPublic
      ?let modeMap
      ?let @procedureSignature formalSignature
      ?let @routineKind routineKind
      ?*
      ?let returnedType
      ?let appendFileAndLineArgumentForPanicLocation
      ?let unused canMutateProperties
      ?let unused canAccessPropertiesInUserMode
    ]
  #--- Check accessibility
    if not isPublic then
      error routineMangledName : "this routine is not public"
    end
    @objectIR objectIR
    if canMutateProperties then
      [!?ioVariableMap searchForMethodCall
        !lkey:baseName
        ?1*
        ?readAccessAllowed:*
        ?variableKin:*
        ?objectIR:objectIR
        ?copyable:*
        ?1*
      ]
    else
      [!?ioVariableMap searchForConstantMethodCall
        !lkey:baseName
        ?1*
        ?readAccessAllowed:*
        ?variableKin:*
        ?objectIR:objectIR
        ?copyable:*
        ?1*
      ]
    end
  #--- Enter in invocation graph
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForGeneration]
  #--- Check modes
    let routineKindIR = checkMode (
      !requiredModes:inRequiredModeSet
      !possibleModes:[modeMap keySet]
      !kind:routineKind
      !error:routineName.location
    )
  #--- Analyze effective parameters
    analyzeEffectiveParameters (
      !self:inSelfType
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !propertiesAreMutable:inRoutineCanMutateProperties
      !formal:formalSignature
      !effective:mEffectiveParameterList
      !errorLocation:routineName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredModeSet:inRequiredModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?namedObjectMap: ioNamedObjectMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
    if returnedType != .null then
      error routineName : "cannot be called in instruction: return value"
    end
  #--- Code generation
    let baseGlobalVariableName = if [objectIR isGlobalVariable] then baseName.string else "" end
    ioInstructionGenerationList += !@procCallInstructionIR.new {
      !baseGlobalVariableName
      !routineMangledName
      !routineNameForGeneration
      !routineKindIR
      !effectiveParameterListIR
      !appendFileAndLineArgumentForPanicLocation
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeRoutineCall
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?receiverName:let @lstring inReceiverName
  ?routineName:let @lstring inRoutineName
  ?effective:let @effectiveParameterListAST inEffectiveParameterList
  ?callerForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?requiredModeSet:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!namedObjectMap:@namedObjectMap ioNamedObjectMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !effectiveIR:@procCallEffectiveParameterListIR outEffectiveParameterListIR
  !routineKind:@routineKindIR outRoutineKindIR
  !routineMangledName:@lstring outRoutineMangledName
  !routineNameForGeneration:@lstring outRoutineNameForGeneration
  !returnType:@unifiedTypeMap-proxy outReturnedType
  !appendFileAndLineArgumentForPanicLocation:@bool outAppendFileAndLineArgumentForPanicLocation
{
#---
  outEffectiveParameterListIR = {}
  @unifiedTypeMap-proxy receiverType
  if inReceiverName.string != "" then
    [!?ioVariableMap searchForMethodCall
      !lkey:inReceiverName
      ?type:receiverType
      ?1*
      ?variableKin:*
      ?objectIR:let objectIR
      ?2*
    ]
    outRoutineMangledName = .new {!"$" + [receiverType key] + "." + inRoutineName !inRoutineName.location}
    outEffectiveParameterListIR += !.outputInput !objectIR
  else
    outRoutineMangledName = inRoutineName
    receiverType = .null
  end
#--- Build LLVM mangled name
  outRoutineMangledName.string += "("
  for (passingMode selector) in inEffectiveParameterList do
    outRoutineMangledName.string += [passingMode matchingFormalArgument]
    outRoutineMangledName.string += selector.string
    outRoutineMangledName.string += ":"
  end
  outRoutineMangledName.string += ")"
  [inContext.mRoutineMapForContext searchKey
    !outRoutineMangledName
    ?outRoutineNameForGeneration
    ?let isPublic
    ?let modeMap
    ?let @procedureSignature formalSignature
    ?let @routineKind routineKind
    ?*
    ?outReturnedType
    ?outAppendFileAndLineArgumentForPanicLocation
    ?let unused canMutateProperties
    ?let unused canAccessPropertiesInUserMode
  ]
#--- Check accessibility
  if not isPublic then
    if inReceiverName.string == "" then # Standalone function
      let @string declarationFile = [[inContext.mRoutineMapForContext locationForKey !outRoutineMangledName.string] file]
      let invocationFile = [inRoutineName.location file]
      if invocationFile != declarationFile then
        error inRoutineName : "this routine is not public"
      end
    else
      error inRoutineName : "this routine is not public"
    end  
  end  
#--- Enter in invocation graph
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !outRoutineMangledName]
#--- Check modes
  outRoutineKindIR = checkMode (
    !requiredModes:inRequiredModeSet
    !possibleModes:[modeMap keySet]
    !kind:routineKind
    !error:inRoutineName.location
  )
#--- Analyze effective parameters
  analyzeEffectiveParameters (
    !self:inSelfType
    !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
    !propertiesAreMutable:inRoutineCanMutateProperties
    !formal:formalSignature
    !effective:inEffectiveParameterList
    !errorLocation:inRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?namedObjectMap: ioNamedObjectMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:outEffectiveParameterListIR
  )
}

