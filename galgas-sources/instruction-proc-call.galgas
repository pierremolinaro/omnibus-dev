#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @effectiveParameterPassingModeAST {
  case input (@lstring name)
  case inputWithType (@bool constant @lstring typeName @lstring name)
  case output (@expressionAST exp @location endOfExp)
  case outputInput (@lstring name)
  case outputInputSelfVariable (@lstring name)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @effectiveParameterListAST {
  @effectiveParameterPassingModeAST mEffectiveParameterKind
  @lstring mSelector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractCallInstructionAST : @instructionAST {
  @effectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standaloneRoutineCallInstructionAST : @abstractCallInstructionAST {
  @lstring mRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @remoteRoutineCallInstructionAST : @abstractCallInstructionAST {
  @lstringlist mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @unifiedSelfCallInstructionAST : @abstractCallInstructionAST {
  @location mSelfLocation
  @lstringlist mPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
     <routine_call> ?let @abstractCallInstructionAST call_instruction
     ioInstructionList += !call_instruction
  }

  #·····················································································································

  rule <routine_call> !@abstractCallInstructionAST outInstruction {
    $self$
    let selfLocation = @location.here
    @lstringlist propertyList = {}
    repeat
      $.$
      $identifier$ ?let routineName
      propertyList += !routineName
    while
    end
    <effective_parameters> ?let effectiveParameterList
    outInstruction = @unifiedSelfCallInstructionAST.new {
      !effectiveParameterList
      !selfLocation
      !propertyList
    }
  }

  #·····················································································································

  rule <routine_call> !@abstractCallInstructionAST outInstruction {
    $identifier$ ?let receiverName
    @lstringlist propertyList = {!receiverName}
    repeat
      $.$
      $identifier$ ?let propertyName
      propertyList += !propertyName
    while
    end
    <effective_parameters> ?let effectiveParameterList
    outInstruction = @remoteRoutineCallInstructionAST.new {
      !effectiveParameterList
      !propertyList
    }
  }

  #·····················································································································

  rule <routine_call> !@abstractCallInstructionAST outInstruction {
    $identifier$ ?let standaloneRoutineName
    <effective_parameters> ?let effectiveParameterList
    outInstruction = @standaloneRoutineCallInstructionAST.new {
      !effectiveParameterList
      !standaloneRoutineName
    }
  }

  #·····················································································································

  rule <effective_parameters> !@effectiveParameterListAST outEffectiveParameterList {
    outEffectiveParameterList = {}
    $($
    repeat
    while
      $!$ ?let selector
      <expression> ?let expression
      outEffectiveParameterList += !.output{!exp:expression !endOfExp:.here} !selector
    while
      $!?$ ?let selector
      $identifier$ ?let effectiveParameterName
      outEffectiveParameterList += !.outputInput{!name:effectiveParameterName} !selector
    while
      $!?$ ?let selector
      $self$
      $.$
      $identifier$ ?let effectiveParameterName
      outEffectiveParameterList += !.outputInputSelfVariable{!name:effectiveParameterName} !selector
    while
      $?$ ?let selector
      $identifier$ ?let effectiveParameterName
      outEffectiveParameterList += !.input{!name:effectiveParameterName} !selector
    while
      $?$ ?let selector
      @bool constant
      select
        $var$
        constant = false
      or
        $let$
        constant = true
      end
      $identifier$ ?let effectiveParameterName
      @lstring typeName
      select
        typeName = ["" nowhere]
      or
        $typeName$ ?typeName
      end
      outEffectiveParameterList += !.inputWithType{!constant:constant !typeName:typeName !name:effectiveParameterName} !selector
    end
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case inputWithType (* @lstring typeName *) :
      if typeName.string != "" then
        [!?ioGraph noteNode !.new {!"$" + typeName !typeName.location}]
      end
    case output (expression *) : [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    case outputInputSelfVariable (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @effectiveParameterPassingModeAST passingModeForActualSelector ?@lstring inSelector -> @string outResult {
  switch self
  case input (*) : outResult = "?"
  case inputWithType (* * *) : outResult = "?"
  case output (* *) : outResult = "!"
  case outputInput (*) : outResult = "!?"
  case outputInputSelfVariable (*) : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procEffectiveParameterList {
  @effectiveParameterPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @unifiedTypeMap-proxy mParameterType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @unifiedSelfCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  if inSelfType == .null then
    error mSelfLocation : "'self' is not available in this context"
  else
    @unifiedTypeMap-proxy currentType = inSelfType
    @lstringlist propertyList = mPropertyList
    [!?propertyList popLast ?let @lstring methodName]
    @elementPtrList elementPtrList = {}
    var needsPublic = false
    for (propertyName) in propertyList do
      switch [currentType kind]
      case opaque (*) :
        error propertyName : "an opaque type does not handle field access" : currentType
      case arrayType (* * *) :
        error propertyName : "an array type does not handle field access" : currentType
      case boolean :
        error propertyName : "a boolean does not handle field access" : currentType
      case staticInteger :
        error propertyName : "an integer does not handle field access" : currentType
      case boolset :
        error propertyName : "a boolset does not handle field access" : currentType
      case literalString :
        error propertyName : "a literal string does not handle field access" : currentType
      case enumeration (*) :
        error propertyName : "an enumeration does not handle field access" : currentType
      case integer (* * * *) :
        error propertyName : "an integer does not handle field access" : currentType
      case structure (@propertyMap propertyMap *) :
        [propertyMap searchKey !propertyName ?let public ?let propertyType ?let idx]
        elementPtrList += !.absolute {!index:idx} !propertyName.string
        currentType = propertyType
        if needsPublic && not public then
          error propertyName : "this property is not public"
        end
        needsPublic = true
      end
    end     
    let routineMangledName = @lstring.new {!"$" + [currentType key] + "." + methodName !methodName.location}
    getLocalNameOfNewTempObjectInMemory (!currentType !?ioTemporaries ?let propertyAddressLLVMvar)
    [!?ioInstructionGenerationList appendGetElementPtrFromSelf
      !propertyAddressLLVMvar
      !inSelfType
      !elementPtrList
    ]
    @procCallEffectiveParameterListIR effectiveParameterListIR = {}
    effectiveParameterListIR += !.outputInput ![propertyAddressLLVMvar address] #--- add "load receiver" as first argument
    [inContext.mRoutineMapForContext searchKey
      !routineMangledName
      ?let isPublic
      ?let modeMap
      ?let @procedureSignature formalSignature
      ?let @routineKind routineKind
      ?*
      ?let returnedType
      ?let appendFileAndLineArgumentForPanicLocation
    ]
    if needsPublic && not isPublic then
      error routineMangledName : "this routine is not public"
    end
  #--- Enter in invocation graph
    @lstring routineNameForInvocationGraph
    switch routineKind
    case function :
      routineNameForInvocationGraph = procNameForInvocationGraph (!currentType !methodName)
    case section :
      routineNameForInvocationGraph = sectionNameForInvocationGraph (!currentType !methodName)
    case service :
      routineNameForInvocationGraph = serviceNameForInvocationGraph (!currentType !methodName)
    case primitive :
      routineNameForInvocationGraph = primitiveNameForInvocationGraph (!currentType !methodName)
    end
    [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForInvocationGraph]
  #--- Check modes
    let routineKindIR = checkMode (
      !requiredModes:inRequiredModeSet
      !possibleModes:[modeMap keySet]
      !kind:routineKind
      !error:methodName.location
    )
  #--- Analyze effective parameters
    analyzeEffectiveParameters (
      !self:inSelfType
      !formal:formalSignature
      !effective:mEffectiveParameterList
      !errorLocation:methodName.location
      !callerForInvocationGraph:inCallerNameForInvocationGraph
      !context:inContext
      !requiredModeSet:inRequiredModeSet
      !allowPanic:inAllowPanic
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioVariableMap
      !?alloca:ioAllocaList
      !?instructionListIR:ioInstructionGenerationList
      !?effectiveIR:effectiveParameterListIR
    )
    if returnedType != .null then
      error methodName : "cannot be called in instruction: return value"
    end
  #--- Code generation
    ioInstructionGenerationList += !@procCallInstructionIR.new {
      !"" # Receiver is self
      !routineMangledName
      !routineKindIR
      !effectiveParameterListIR
      !appendFileAndLineArgumentForPanicLocation
    }
  end
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneRoutineCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  analyzeRoutineCall (
    !self:inSelfType
    !receiverName:.new{!"" !mRoutineName.location}
    !routineName:mRoutineName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKindIR routineKindIR
    ?routineMangledName:let @lstring routineMangledName
    ?returnType:let @unifiedTypeMap-proxy returnedType
    ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
  )
  if returnedType != .null then
    error mRoutineName : "cannot be called in instruction: return value"
  end
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !"" # No receiver
    !routineMangledName
    !routineKindIR
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @remoteRoutineCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  @lstringlist propertyList = mPropertyList
  [!?propertyList popFirst ?let receiverName]
  [!?propertyList popLast ?let routineName]
  for (propertyName) in propertyList do
    error propertyName : "not handled yet (2)"
  end
#---
  analyzeRoutineCall (
    !self:inSelfType
    !receiverName:receiverName
    !routineName:routineName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKindIR routineKindIR
    ?routineMangledName:let @lstring routineMangledName
    ?returnType:let @unifiedTypeMap-proxy returnedType
    ?appendFileAndLineArgumentForPanicLocation:let appendFileAndLineArgumentForPanicLocation
  )
  if returnedType != .null then
    error routineName : "cannot be called in instruction: return value"
  end
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !receiverName.string
    !routineMangledName
    !routineKindIR
    !effectiveParameterListIR
    !appendFileAndLineArgumentForPanicLocation
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeRoutineCall
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?receiverName:let @lstring inReceiverName
  ?routineName:let @lstring inRoutineName
  ?effective:let @effectiveParameterListAST inEffectiveParameterList
  ?callerForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?requiredModeSet:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !effectiveIR:@procCallEffectiveParameterListIR outEffectiveParameterListIR
  !routineKind:@routineKindIR outRoutineKindIR
  !routineMangledName:@lstring outRoutineMangledName
  !returnType:@unifiedTypeMap-proxy outReturnedType
  !appendFileAndLineArgumentForPanicLocation:@bool outAppendFileAndLineArgumentForPanicLocation
{
  outEffectiveParameterListIR = {}
  @unifiedTypeMap-proxy receiverType
  if inReceiverName.string != "" then
    [!?ioVariableMap searchForReadAccess
      !lkey:inReceiverName
      ?type:receiverType
      ?1*
      ?variableKind:@objectInMemoryIR variableKind
      ?4*
    ]
    outRoutineMangledName = .new {!"$" + [receiverType key] + "." + inRoutineName !inRoutineName.location}
    outEffectiveParameterListIR += !.outputInput ![variableKind address] #--- add "load self" as first argument
  else
    outRoutineMangledName = .new {!"." + inRoutineName !inRoutineName.location}
    receiverType = .null
  end
  [inContext.mRoutineMapForContext searchKey
    !outRoutineMangledName
    ?let isPublic
    ?let modeMap
    ?let @procedureSignature formalSignature
    ?let @routineKind routineKind
    ?*
    ?outReturnedType
    ?outAppendFileAndLineArgumentForPanicLocation
  ]
#--- Check accessibility
  if not isPublic then
    if inReceiverName.string == "" then # Standalone function
      let @string declarationFile = [[inContext.mRoutineMapForContext locationForKey !outRoutineMangledName.string] file]
      let invocationFile = [inRoutineName.location file]
      if invocationFile != declarationFile then
        error inRoutineName : "this routine is not public"
      end
    else
      error inRoutineName : "this routine is not public"
    end  
  end  
#--- Enter in invocation graph
  @lstring routineNameForInvocationGraph
  switch routineKind
  case function :
    routineNameForInvocationGraph = procNameForInvocationGraph (!receiverType !inRoutineName)
  case section :
    routineNameForInvocationGraph = sectionNameForInvocationGraph (!receiverType !inRoutineName)
  case service :
    routineNameForInvocationGraph = serviceNameForInvocationGraph (!receiverType !inRoutineName)
  case primitive :
    routineNameForInvocationGraph = primitiveNameForInvocationGraph (!receiverType !inRoutineName)
  end
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForInvocationGraph]
#--- Check modes
  outRoutineKindIR = checkMode (
    !requiredModes:inRequiredModeSet
    !possibleModes:[modeMap keySet]
    !kind:routineKind
    !error:inRoutineName.location
  )
#--- Analyze effective parameters
  analyzeEffectiveParameters (
    !self:inSelfType
    !formal:formalSignature
    !effective:inEffectiveParameterList
    !errorLocation:inRoutineName.location
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowPanic:inAllowPanic
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?alloca:ioAllocaList
    !?instructionListIR:ioInstructionGenerationList
    !?effectiveIR:outEffectiveParameterListIR
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeEffectiveParameters
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?formal:let @procedureSignature inFormalSignature
  ?effective:let @effectiveParameterListAST inEffectiveParameterList
  ?errorLocation:let @location inErrorLocation
  ?callerForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?requiredModeSet:let @stringset inRequiredModeSet
  ?allowPanic:let @bool inAllowPanic
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  ?!effectiveIR:@procCallEffectiveParameterListIR ioEffectiveParameterListIR
{
#--- Analyze effective parameters
  @procEffectiveParameterList parameterList = {}
  for () formal_ in inFormalSignature, () effective_ in inEffectiveParameterList do
    switch effective_mEffectiveParameterKind 
    case inputWithType (@bool constant @lstring typeName @lstring name) :
      let type = if typeName.string == "" then
        formal_mType
      else
        @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !typeName}
      end
      let varLLVMName = name.string + "." + ioTemporaries.mTemporaryIndex
      ioTemporaries.mTemporaryIndex ++
      let targetVar = @objectInMemoryIR.localValue {!type:type !name:varLLVMName}
      if constant then
        [!?ioVariableMap insertLocalConstant
          !lkey:name
          !type:type
          !readAccessAllowed:true
          !variableKind:targetVar
          !copyable:true
          !fieldMap:{}
          !canBeUsedAsInputParameter:true
          !isConstant:false
        ]
      else
        [!?ioVariableMap insertDefinedLocalVariable
          !lkey:name
          !type:type
          !readAccessAllowed:true
          !variableKind:targetVar
          !copyable:true
          !fieldMap:{}
          !canBeUsedAsInputParameter:true
          !isConstant:false
        ]
      end
      ioAllocaList += !varLLVMName !type
      parameterList += !effective_mEffectiveParameterKind !effective_mSelector !type
      ioEffectiveParameterListIR +=
        !.input
        !.new{!type !.llvmLocalObject {!name:llvmNameForLocalVariable (!varLLVMName)}}
    case input (@lstring name) :
      [!?ioVariableMap searchForWriteAccess
        !lkey:name
        ?type:let type
        ?readAccessAllowed:let accessIsAllowed
        ?variableKind:let variableKind
        ?copyable:let isCopyable                                                 
        ?fieldMap:*
        ?canBeUsedAsInputParameter:let canBeUsedAsInputParameter
        ?isConstant:*
      ]
      if not accessIsAllowed then
        error name : "routine has no access right on the this variable"
      end
      if not canBeUsedAsInputParameter then
        error name : "this variable cannot be used as input parameter"
      end
      if not isCopyable then
        error name : "an $" + [type key] + " instance is not copyable"
      end
      parameterList += !effective_mEffectiveParameterKind !effective_mSelector !type
      ioEffectiveParameterListIR +=
        !.input
        !.new{!type !.llvmLocalObject {!name:llvmNameForLocalVariable (![variableKind name])}}
    case output (@expressionAST expression @location endOfExp) :
      [expression analyzeExpression
        !self:inSelfType
        !inGuard:false
        !routineNameForInvocationGraph:inCallerNameForInvocationGraph
        !optionalTargetType:formal_mType
        !context:inContext
        !modes:inRequiredModeSet
        !allowPanic:inAllowPanic
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?alloca:ioAllocaList
        !?instructionListIR:ioInstructionGenerationList
        ?result:let @operandIR expressionResult
      ]
      let result = checkAssignmentCompatibility (
        !source:expressionResult
        !targetAnnotationType:formal_mType
        !errorLocation:endOfExp
        !staticTypeAllowed:false
      )
      parameterList += !effective_mEffectiveParameterKind !effective_mSelector !formal_mType
      ioEffectiveParameterListIR += !.output !result
    case outputInput (@lstring name) :
     [!?ioVariableMap searchForReadWriteAccess
        !lkey:name
        ?type:let type
        ?readAccessAllowed:let accessIsAllowed
        ?variableKind:let variableKind
        ?2*
        ?canBeUsedAsInputParameter:let canBeUsedAsInputParameter
        ?isConstant:*
      ]
      if not canBeUsedAsInputParameter then
        error name : "this variable cannot be used as output/input parameter"
      end
      if not accessIsAllowed then
        error name : "routine has no access right on the this variable"
      end
      parameterList += !effective_mEffectiveParameterKind !effective_mSelector !type
      ioEffectiveParameterListIR +=
        !.outputInput
        !.new {!type !.llvmLocalObject {!name:llvmNameForLocalVariable (![variableKind llvmName])}}
    case outputInputSelfVariable (@lstring name) :
      if inSelfType == .null then
        error name : "'self' is not available in this context" :parameterList, ioEffectiveParameterListIR
      else
        switch [inSelfType kind]
        case opaque (*) :
          error name : "an opaque type does not handle field access" : parameterList, ioEffectiveParameterListIR
        case arrayType (* * *) :
          error name : "an array type does not handle field access" : parameterList, ioEffectiveParameterListIR
        case boolean :
          error name : "a boolean does not handle field access" : parameterList, ioEffectiveParameterListIR
        case staticInteger :
          error name : "an integer does not handle field access" : parameterList, ioEffectiveParameterListIR
        case boolset :
          error name : "a boolset does not handle field access" : parameterList, ioEffectiveParameterListIR
        case literalString :
          error name : "a literal string does not handle field access" : parameterList, ioEffectiveParameterListIR
        case enumeration (*) :
          error name : "an enumeration does not handle field access" : parameterList, ioEffectiveParameterListIR
        case integer (* * * *) :
          error name : "an integer does not handle field access" : parameterList, ioEffectiveParameterListIR
        case structure (@propertyMap propertyMap *) :
          [propertyMap searchKey !name ?let unused public ?let type ?let idx]
          getLocalNameOfNewTempObjectInMemory (!type !?ioTemporaries ?let fieldAddress)
          [!?ioInstructionGenerationList appendGetElementPtrFromSelf
            !fieldAddress
            !inSelfType
            !{!.absolute {!index:idx} !name.string}
          ]        
          parameterList += !effective_mEffectiveParameterKind !effective_mSelector !type
          ioEffectiveParameterListIR +=
            !.outputInput
            !.new {!type !.llvmLocalObject {!name:llvmNameForLocalVariable (![fieldAddress name])}}
        end    
      end
    end
  end
#--- Check parameters
  if [inFormalSignature length] != [inEffectiveParameterList length] then
    error inErrorLocation: "this routine requires " + [inFormalSignature length] + " argument(s), this call names "
      + [inEffectiveParameterList length] + " argument(s)"
  else
    for () formal_ in inFormalSignature, () actual_ in parameterList do
      if [formal_mType key] != [actual_mParameterType key] then
        error actual_mSelector : "the actual parameter type is '" + [actual_mParameterType key] +
           "', and is incompatible with the formal type '" + [formal_mType key] + "'"
      end
      let requiredPassingMode = [formal_mFormalArgumentPassingMode requiredActualPassingModeForSelector !formal_mSelector]
      let testedPassingMode = [actual_mEffectiveParameterPassingMode passingModeForActualSelector !actual_mSelector]
      if requiredPassingMode != testedPassingMode then
        error actual_mSelector : "the required selector is '" + requiredPassingMode + "'"
      end
    end  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @operandIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @routineKindIR {
  case function
  case primitiveInProcessorUserMode
  case sectionInProcessorUserMode
  case serviceInProcessorUserMode
  case primitiveInProcessorPrivilegedMode
  case sectionInProcessorPrivilegedMode
  case serviceInProcessorPrivilegedMode
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @procCallInstructionIR : @abstractInstructionIR {
  @string mGlobalVariableName # Receiver name, "" if not receiver
  @lstring mProcName
  @routineKindIR mKind
  @procCallEffectiveParameterListIR mParameters
  @bool mAppendFileAndLineArgumentForPanicLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procCallInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += "  call void @"
  switch mKind 
  case function : ioLLVMcode += llvmNameForFunction (!mProcName.string)
  case serviceInProcessorUserMode : ioLLVMcode += llvmNameForServiceCall (!mProcName.string)
  case serviceInProcessorPrivilegedMode : ioLLVMcode += llvmNameForServiceImplementation (!mProcName.string)
  case sectionInProcessorUserMode : ioLLVMcode += llvmNameForSectionCall (!mProcName.string)
  case sectionInProcessorPrivilegedMode : ioLLVMcode += llvmNameForSectionImplementation (!mProcName.string)
  case primitiveInProcessorUserMode : ioLLVMcode += llvmNameForPrimitiveCall (!mProcName.string)
  case primitiveInProcessorPrivilegedMode : ioLLVMcode += llvmNameForPrimitiveImplementation (!mProcName.string)
  end
  var first = true
  ioLLVMcode += " ("
  for () in mParameters do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mEffectiveParameterPassingMode
    case input:
      ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
    case output:
      ioLLVMcode += [mParameter.mType llvmTypeName] + " " + [mParameter.mValue llvmName]
    case outputInput:
      ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
    end
  end
  if not [option plm_options.noPanicGeneration value] && mAppendFileAndLineArgumentForPanicLocation then
    let sourceFileName = [[[mProcName.location file] lastPathComponent] stringByDeletingPathExtension]
    [!?ioGenerationAdds.mStaticStringMap findOrAddStaticString
      !sourceFileName
      ?let staticStringIndex
    ]
    if not first then
      ioLLVMcode += ", "
    end
    ioLLVMcode += inGenerationContext.mPanicLineLLVMType + " " + [mProcName.location line]
    let sourceFileNameSize = [sourceFileName length] + 1
    ioLLVMcode += ", i8* getelementptr inbounds ([" + sourceFileNameSize + " x i8], [" + sourceFileNameSize + " x i8]* @str.array." + staticStringIndex + ", i32 0, i32 0)"
 #   ioLLVMcode += ", i8* @string." + staticStringIndex
  end
  ioLLVMcode += ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procCallInstructionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioAccessibleEntities.mRoutineSet += !mProcName.string
  if mGlobalVariableName != "" then
    ioAccessibleEntities.mGlobalVariableSet += !mGlobalVariableName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
