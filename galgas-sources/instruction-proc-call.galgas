#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeAST {
  case input (@lstring name)
  case output (@expressionAST exp @location endOfExp)
  case outputInput (@lstring name)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procEffectiveParameterListAST {
  @procEffectiveParameterPassingModeAST mEffectiveParameterKind
  @lstring mSelector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractCallInstructionAST : @instructionAST {
  @procEffectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @standaloneRoutineCallInstructionAST : @abstractCallInstructionAST {
  @lstring mRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @selfRoutineCallInstructionAST : @abstractCallInstructionAST {
  @lstring mRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @remoteRoutineCallInstructionAST : @abstractCallInstructionAST {
  @lstring mReceiverName
  @lstring mRoutineName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
    $self$
    $.$
    $identifier$ ?let routineName
    <effective_parameters> ?let effectiveParameterList
    ioInstructionList += !@selfRoutineCallInstructionAST.new {
      !effectiveParameterList
      !routineName
    }
  }

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
    $identifier$ ?let receiverName
    $.$
    $identifier$ ?let routineName
    <effective_parameters> ?let effectiveParameterList
    ioInstructionList += !@remoteRoutineCallInstructionAST.new {
      !effectiveParameterList
      !receiverName
      !routineName
    }
  }

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
    $identifier$ ?let standaloneRoutineName
    <effective_parameters> ?let effectiveParameterList
    ioInstructionList += !@standaloneRoutineCallInstructionAST.new {
      !effectiveParameterList
      !standaloneRoutineName
    }
  }

  #·····················································································································

  rule <effective_parameters> !@procEffectiveParameterListAST outEffectiveParameterList {
    outEffectiveParameterList = {}
    $($
    repeat
    while
      $!$ ?let selector
      <expression> ?let expression
      outEffectiveParameterList += !.output{!exp:expression !endOfExp:.here} !selector
    while
      $!?$ ?let selector
      $identifier$ ?let effectiveParameterName
      outEffectiveParameterList += !.outputInput{!name:effectiveParameterName} !selector
    while
      $?$ ?let selector
      select
        $identifier$ ?let effectiveParameterName
        outEffectiveParameterList += !.input{!name:effectiveParameterName} !selector
      or
        $self$
        outEffectiveParameterList += !.input{!name:.new {!"self" !.here}} !selector
      end
    end
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @abstractCallInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in mEffectiveParameterList do
    switch mEffectiveParameterKind
    case input (*):
    case output (expression *) :
      [expression noteExpressionTypesInPrecedenceGraph !?ioGraph]
    case outputInput (*) :
    end 
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @procEffectiveParameterPassingModeAST passingModeForActualSelector ?@lstring inSelector -> @string outResult {
  switch self
  case input (*) : outResult = "?"
  case output (* *) : outResult = "!"
  case outputInput (*) : outResult = "!?"
  end
  if inSelector.string != "" then
    outResult += inSelector.string + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procEffectiveParameterList {
  @procEffectiveParameterPassingModeAST mEffectiveParameterPassingMode
  @lstring mSelector
  @unifiedTypeMap-proxy mParameterType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfRoutineCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  analyzeCall (
    !self:inSelfType
    !receiverName:.new{![inSelfType key] !mRoutineName.location}
    !routineName:mRoutineName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKind routineKind
    ?routineMangledName:let @lstring routineMangledName
  )
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !"" # Receiver is self
    !routineMangledName.string
    !routineKind
    !effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @standaloneRoutineCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  analyzeCall (
    !self:inSelfType
    !receiverName:.new{!"" !mRoutineName.location}
    !routineName:mRoutineName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKind routineKind
    ?routineMangledName:let @lstring routineMangledName
  )
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !"" # No receiver
    !routineMangledName.string
    !routineKind
    !effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @remoteRoutineCallInstructionAST analyze
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset inRequiredModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
  analyzeCall (
    !self:inSelfType
    !receiverName:mReceiverName
    !routineName:mRoutineName
    !effective:mEffectiveParameterList
    !callerForInvocationGraph:inCallerNameForInvocationGraph
    !context:inContext
    !requiredModeSet:inRequiredModeSet
    !allowException:inAllowExceptions
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?effectiveIR:let @procCallEffectiveParameterListIR effectiveParameterListIR
    ?routineKind:let @routineKind routineKind
    ?routineMangledName:let @lstring routineMangledName
  )
#--- Code generation
  ioInstructionGenerationList += !@procCallInstructionIR.new {
    !mReceiverName.string
    !routineMangledName.string
    !routineKind
    !effectiveParameterListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeCall
  ?self:let @unifiedTypeMap-proxy inSelfType
  ?receiverName:let @lstring inReceiverName
  ?routineName:let @lstring inRoutineName
  ?effective:let @procEffectiveParameterListAST inEffectiveParameterList
  ?callerForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?requiredModeSet:let @stringset inRequiredModeSet
  ?allowException:let @bool inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !effectiveIR:@procCallEffectiveParameterListIR outEffectiveParameterListIR
  !routineKind:@routineKind outRoutineKind
  !routineMangledName:@lstring outRoutineMangledName
{
  outEffectiveParameterListIR = {}
  @unifiedTypeMap-proxy receiverType
  if inReceiverName.string != "" then
    [!?ioVariableMap searchForReadAccess
      !inReceiverName
      ?receiverType
      ?*
      ?@objectInMemoryIR variableKind
      ?4*
    ]
    outRoutineMangledName = .new {!"$" + [receiverType key] + "." + inRoutineName !inRoutineName.location}
    outEffectiveParameterListIR += !.outputInput !["" nowhere] ![variableKind address] #--- add "load receiver" as first argument
  else
    outRoutineMangledName = .new {!"." + inRoutineName !inRoutineName.location}
    receiverType = .null
  end
  [inContext.mRoutineMapForContext searchKey
    !outRoutineMangledName
    ?let unused mutating
    ?let modeMap
    ?let formalSignature
    ?outRoutineKind
    ?*
  ]
#--- Enter in invocation graph
  @lstring routineNameForInvocationGraph
  switch outRoutineKind
  case procedure : routineNameForInvocationGraph = procNameForInvocationGraph (!receiverType !inRoutineName)
  case section : routineNameForInvocationGraph = sectionNameForInvocationGraph (!receiverType !inRoutineName)
  case service : routineNameForInvocationGraph = serviceNameForInvocationGraph (!receiverType !inRoutineName)
  end
  [!?ioTemporaries.mSubprogramInvocationGraph addEdge !inCallerNameForInvocationGraph !routineNameForInvocationGraph]
#--- Analyze effective parameters
  @procEffectiveParameterList parameterList = {}
  for () formal_ in formalSignature, () in inEffectiveParameterList do
    switch mEffectiveParameterKind 
    case input (@lstring name) :
      [!?ioVariableMap searchForWriteAccess
        !name
        ?let type
        ?let accessIsAllowed
        ?let unused parameterAccess
        ?let isCopiable
        ?*
        ?let canBeUsedAsInputParameter
        ?*
      ]
      if not accessIsAllowed then
        error name : "routine has no access right on the this variable"
      end
      if not canBeUsedAsInputParameter then
        error name : "this variable cannot be used as input parameter"
      end
      if not isCopiable then
        error name : "the '" + name + "' variable is not copiable"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type
      outEffectiveParameterListIR +=
        !.input
        !mSelector
        !.new{!type !.llvmLocalObject {!name:llvmNameForLocalVariable (!name.string)}}
    case output (@expressionAST expression @location endOfExp) :
      [expression analyzeExpression
        !self:inSelfType
        !routineNameForInvocationGraph:routineNameForInvocationGraph
        !optionalTargetType:formal_mType
        !context:inContext
        !modes:inRequiredModeSet
        !allowException:inAllowExceptions
        !?temporary:ioTemporaries
        !?staticStringMap:ioGlobalLiteralStringMap
        !?variableMap:ioVariableMap
        !?instructionListIR:ioInstructionGenerationList
        ?result:let @operandIR expressionResult
      ]
      let result = checkAssignmentCompatibility (
        !source:expressionResult
        !targetAnnotationType:formal_mType
        !errorLocation:endOfExp
        !staticTypeAllowed:false
      )
      parameterList += !mEffectiveParameterKind !mSelector !formal_mType
      outEffectiveParameterListIR += 
        !.output
        !mSelector
        !result
    case outputInput (@lstring name) :
      [!?ioVariableMap searchForReadWriteAccess
        !name
        ?let type
        ?let accessIsAllowed
        ?let unused parameterAccess
        ?2*
        ?let canBeUsedAsInputParameter
        ?*
      ]
      if not canBeUsedAsInputParameter then
        error name : "this variable cannot be used as output/input parameter"
      end
      if not accessIsAllowed then
        error name : "routine has no access right on the this variable"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type
      outEffectiveParameterListIR +=
        !.outputInput
        !mSelector
        !.new {!type !.llvmLocalObject {!name:llvmNameForLocalVariable (!name.string)}}
    end
  end
#--- Check mode
  checkMode (
    !requiredModes:inRequiredModeSet
    !possibleModes:[modeMap keySet]
    !error:inRoutineName.location
  )
#--- Check parameters
  if [formalSignature length] != [parameterList length] then
    error inRoutineName: "this routine requires " + [formalSignature length] + " argument(s), this call names "
      + [formalSignature length] + " argument(s)"
  else
    for () formal_ in formalSignature, () actual_ in parameterList do
      if [formal_mType key] != [actual_mParameterType key] then
        error actual_mSelector : "the actual parameter type is '" + [actual_mParameterType key] +
           "', and is incompatible with the formal type '" + [formal_mType key] + "'"
      end
      let requiredPassingMode = [formal_mFormalArgumentPassingMode requiredActualPassingModeForSelector !formal_mSelector]
      let testedPassingMode = [actual_mEffectiveParameterPassingMode passingModeForActualSelector !actual_mSelector]
      if requiredPassingMode != testedPassingMode then
        error actual_mSelector : "the required selector is '" + requiredPassingMode + "'"
      end
    end  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procEffectiveParameterPassingModeIR {
  case input
  case output
  case outputInput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procCallEffectiveParameterListIR {
  @procEffectiveParameterPassingModeIR mEffectiveParameterPassingMode
  @lstring mSelector
  @operandIR mParameter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @procCallInstructionIR : @abstractInstructionIR {
  @string mGlobalVariableName # Receiver name, "" if not receiver
  @string mProcName
  @routineKind mKind
  @procCallEffectiveParameterListIR mParameters
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procCallInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "  call void @"
  switch mKind 
  case procedure : ioLLVMcode += llvmNameForProcedure (!mProcName)
  case service : ioLLVMcode += llvmNameForServiceCall (!mProcName)
  case section : ioLLVMcode += llvmNameForSectionCall (!mProcName)
  end
  ioLLVMcode += " ("
  for () in mParameters do
    switch mEffectiveParameterPassingMode
    case input:
      ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
    case output:
      ioLLVMcode += [mParameter.mType llvmTypeName] + " " + [mParameter.mValue llvmName]
    case outputInput:
      ioLLVMcode += [mParameter.mType llvmTypeName] + "* " + [mParameter.mValue llvmName]
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procCallInstructionIR enterAccessibleEntities ?!@accessibleEntities ioAccessibleEntities {
  ioAccessibleEntities.mRoutineSet += !mProcName
  if mGlobalVariableName != "" then
    ioAccessibleEntities.mGlobalVariableSet += !mGlobalVariableName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
