#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @booleanDeclaration : @abstractDeclaration {
  @lstring mBooleanTypeName
  @lstringlist mAttributeList
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @booleanDeclaration location -> @location outLocation {
  outLocation = mBooleanTypeName.location
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $newBooleanType$
    $identifier$ ?let newBoolTypeName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end 
    ioAST.mDeclarationList += !@booleanDeclaration.new {
      !newBoolTypeName
      !attributeList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @booleanDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !mBooleanTypeName !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @booleanDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "bool " + mBooleanTypeName 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @booleanDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST unused inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
#---
  var copiable = true
  for (s) in mAttributeList do
    if s.string == "unique" then
      if not copiable then
        error s : "duplicated attribute"
      end
      copiable = false
    end
  end
#--- Constructors
  @constructorMap constructorMap = {}
  [!?constructorMap insertKey !["false" nowhere] !"(" + mangledNameForType (!name:mBooleanTypeName.string) + ") 0"]
  [!?constructorMap insertKey !["true" nowhere] !"(" + mangledNameForType (!name:mBooleanTypeName.string) + ") 1"]
#--- Enter in type map
  [!?ioContext.mTypeMap insertKey
    !lkey:mBooleanTypeName
    !kind:.boolean
    !constructorMap:constructorMap
    !procedureMap:{} # Procedure map
    !copiable:copiable
    !equatable:true
    !comparable:true
  ]
#--- Enter boolean operators
  enterBooleanOperators (
    !integerTypeName:mBooleanTypeName
    !?context:ioContext
  )
}

#----------------------------------------------------------------------------------------------------------------------*

proc enterBooleanOperators
  ?integerTypeName:@lstring inBooleanTypeName
  ?!context:@semanticContext ioContext
{
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !inBooleanTypeName ?let selfTypeProxy]
  [!?ioContext.mEqualOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mNonEqualOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mStrictInfOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mInfEqualOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mStrictSupOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mSupEqualOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mAndOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mAndShortCircuitOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mOrOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mOrShortCircuitOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mXorOperatorMap insertKey
    !.new {!inBooleanTypeName.string + "." + inBooleanTypeName !inBooleanTypeName.location}
    !selfTypeProxy
  ]
  [!?ioContext.mNotOperatorMap insertKey
    !inBooleanTypeName
    !selfTypeProxy
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @booleanDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Get C type
  var cType = "" # C type undefined
  for (s) in mAttributeList do
    if s.string == "unique" then
      # Nothing to do: handled in 'enterInContext'
    elsif cType != "" then
      error s : "base type already defined as '" + cType + "'"
    else
      [inContext.mTargetBaseTypeMap searchKey !s ?cType ?* ?*]
    end
  end
#---
  [!?ioIntermediateCodeStruct.mTypeMapIR insertKey
    !mBooleanTypeName
    !@booleanIR.new {!mBooleanTypeName.string !cType}
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @booleanIR : @abstractTypeIR {
  @string mBooleanTypeName
  @string mActualTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

private filewrapper booleanGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "boolean-declaration.galgasTemplate"
    ?@string ENUMERATION_NAME
    ?@string ACTUAL_TYPE_NAME
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @booleanIR headerCodeGenerationForType -> @string outCode {
  outCode = [filewrapper booleanGenerationTemplate.declaration
    !mBooleanTypeName
    !mActualTypeName
  ]
}

#----------------------------------------------------------------------------------------------------------------------*



