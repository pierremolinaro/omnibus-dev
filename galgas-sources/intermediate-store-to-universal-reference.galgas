
setter @instructionListIR appendStoreToUniversalReference
  ?let @string inLLVMVarName
  ?let @PLMType inTargetVarType
  ?let @objectIR inSourceValue
{
  self += !@storeToUniversalReferenceIR.new {!inLLVMVarName !inTargetVarType !inSourceValue}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @storeToUniversalReferenceIR : @abstractInstructionIR {
  @string mLLVMTargetVarName
  @PLMType mTargetVarType
  @objectIR mSourceValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @storeToUniversalReferenceIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  let llvmType = [mTargetVarType llvmTypeName]
  switch mSourceValue
  case void :
    ioLLVMcode += "<< ERROR @storeToUniversalReferenceIR llvmInstructionCode void >>\n"
  case null (*) :
    ioLLVMcode += "  store " +  llvmType + " null, " + llvmType + "* " + mLLVMTargetVarName + "\n"
  case reference (* *) :
    ioLLVMcode += "<< ERROR @storeToUniversalReferenceIR llvmInstructionCode reference >>\n"
  case llvmValue (* @string llvmName) :
    ioLLVMcode += "  store " +  llvmType + " " + llvmName + ", " + llvmType + "* " + mLLVMTargetVarName + "\n"
  case literalInteger  (* @bigint value) :
    ioLLVMcode += "  store " +  llvmType + " " + value + ", " + llvmType + "* " + mLLVMTargetVarName + "\n"
  case llvmStructureValue (* @sortedOperandIRList operands) :
    for (value index) in operands do
      let tempVar = "%temp.addr." + ioGenerationAdds.mUniqueIndex
      ioGenerationAdds.mUniqueIndex ++
      ioLLVMcode += "  " + tempVar + " = getelementptr inbounds " + llvmType + ", "
                 + llvmType + " * " + mLLVMTargetVarName + ", i32 0, i32 " + index + "\n"
      let valueType = [value llvmTypeName]
      ioLLVMcode += "  store " +  valueType + " " + [value llvmName] + ", " + valueType + "* " + tempVar + "\n"
    end
  case llvmArrayValue (* @operandIRList operands *) :
    for (value) in operands do (index)
      let tempVar = "%temp.addr." + ioGenerationAdds.mUniqueIndex
      ioGenerationAdds.mUniqueIndex ++
      ioLLVMcode += "  " + tempVar + " = getelementptr inbounds " + llvmType + ", "
                 + llvmType + " * " + mLLVMTargetVarName + ", i32 0, i32 " + index + "\n"
      let valueType = [value llvmTypeName]
      ioLLVMcode += "  store " +  valueType + " " + [value llvmName] + ", " + valueType + "* " + tempVar + "\n"
    end
  case literalString  (* *) :
  case zero (*) :
    ioLLVMcode += "  store " +  llvmType + " " + [mSourceValue llvmName] + ", " + llvmType + "* " + mLLVMTargetVarName + "\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @storeToUniversalReferenceIR enterAccessibleEntities 
  ?!@accessibleEntities unused ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
