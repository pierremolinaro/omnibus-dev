#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @registerGroupIndexAST {
  case noIndex
  case index (@expressionAST index @location endOfIndex)
}

#·······················································································································

enum @registerIndexAST {
  case noIndex
  case index (@expressionAST index @location endOfIndex)
}

#·······················································································································

struct @controlRegisterLValueAST {
  @lstring mRegisterGroupName
  @registerGroupIndexAST mGroupIndex
  @lstring mRegisterName
  @registerIndexAST mRegisterIndex
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <control_register_lvalue> ?!@ast ioAST !@controlRegisterLValueAST outRegisterLValue {
    $#groupName$ ?let registerGroupName
    @registerGroupIndexAST groupIndex
    select
      groupIndex = .noIndex
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      groupIndex = .index {!index:expression !endOfIndex:endOfIndex}
    end
    $:$
    $identifier$ ?let registerName
    @registerIndexAST registerIndex
    select
      registerIndex = .noIndex
    or
      $[$
      <expression> !?ioAST ?let expression
      let endOfIndex = @location.here
      $]$
      registerIndex = .index {!index:expression !endOfIndex:endOfIndex}
    end
    outRegisterLValue = .new {!registerGroupName !groupIndex !registerName !registerIndex}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @controlRegisterLValueAST noteExpressionTypesInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  switch mGroupIndex
  case noIndex :
  case index (indexExpression *) :
    [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
  switch mRegisterIndex
  case noIndex :
  case index (indexExpression *) :
    [indexExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  end
}

#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! PRECEDENCE GRAPH FROM EXPRESSION                                                                                     
#-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @controlRegisterLValueAST addDependenceEdgeForStaticExpression
  ?let @lstring inConstantName
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addEdge !inConstantName !mRegisterGroupName]
  switch mGroupIndex
  case noIndex :
  case index (@expressionAST indexExpression *) :
    [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
  switch mRegisterIndex
  case noIndex :
  case index (@expressionAST indexExpression *) :
    [indexExpression addDependenceEdgeForStaticExpression !inConstantName !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @controlRegisterLValueAST controlRegisterLValueSemanticAnalysis
  ?writeAccess:let @bool inWriteAccess
  ?self:let @PLMType inSelfType
  ?routineAttributes:let @routineAttributes inRoutineAttributes
  ?context:let @semanticContext inContext
  ?mode:let @mode inMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticEntityMap:@staticEntityMap ioStaticEntityMap
  ?!variableMap:@universalValuedObjectMap ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
  !registerType: @PLMType outRegisterType
  !registerBitCount:@uint outRegisterTypeBitCount
  !sliceMap:@sliceMap outSliceMap
  !llvmRegisterAddressName:@string outllvmRegisterAddressName
{
#-------------------- Search register group name in entity map
  [ioUniversalMap searchEntity !mRegisterGroupName ?let entity]
#-------------------- Search register name in register group map
  @controlRegisterMap registerMap
  @registerGroupKind groupKind
  switch entity
  case task (*) :
    error mRegisterGroupName : "the \":\" access is reserved to control register" : registerMap, groupKind
  case driver (2*) :
    error mRegisterGroupName : "the \":\" access is reserved to control register" : registerMap, groupKind
  case globalConstant (*) :
    error mRegisterGroupName : "the \":\" access is reserved to control register" : registerMap, groupKind
  case localConstant (3*) :
    error mRegisterGroupName : "the \":\" access is reserved to control register" : registerMap, groupKind
  case globalSyncInstance (2*) :
    error mRegisterGroupName : "the \":\" access is reserved to control register" : registerMap, groupKind
  case localVariable (2*) :
    error mRegisterGroupName : "the \":\" access is reserved to control register" : registerMap, groupKind
  case registerGroup (theRegisterMap theGroupKind) :
    registerMap = theRegisterMap
    groupKind = theGroupKind
  end
  [registerMap searchKey
    !mRegisterName
    ?outRegisterType
    ?let @bool readOnly
    ?let @bool userAccess
    ?outSliceMap
    ?*
    ?let @bigint addressOffset
    ?*
    ?outRegisterTypeBitCount
    ?let @uint registerArraySize # 0 if not an array
    ?let @uint registerElementSize # 0 if not an array
  ]
#-------------------- Check access
  if inWriteAccess & readOnly then
    error mRegisterName
      : "this control register cannot be modified (declared with @ro attribute)"
  elsif not userAccess && ([inMode isUserMode] || [inMode isAnyMode]) then
    error mRegisterName : "this control register is not accessible in user mode"
  end
#-------------------- Group index ?
  @string registerAddress
  switch groupKind
  case single (@bigint baseAddress) :
    if [mGroupIndex isIndex] then
      error mRegisterGroupName : "subscripting not allowed, group is not an array" : registerAddress
    else
      let regName = mRegisterGroupName.string + ":" + mRegisterName
      [!?ioInstructionGenerationList appendEnterRegisterAddress
         !?ioTemporaries
         ?registerAddress
         !baseAddress
         !addressOffset
         !regName
      ]
    end
  case arrayGroup (@lbigintlist baseAddresses) :
    switch mGroupIndex
    case noIndex :
      error mRegisterGroupName : "subscripting required, group is an array" : registerAddress
    case index (indexExpression endOfIndex) :
      handleArraySubscriptNew (
        !self: inSelfType
        !routineAttributes:inRoutineAttributes
        !context: inContext
        !mode: inMode
        !?temporary: ioTemporaries
        !?staticEntityMap:ioStaticEntityMap
        !?variableMap: ioUniversalMap
        !?alloca: ioAllocaList
        !indexExpression 
        !endOfIndex
        !arraySize:[baseAddresses length]
        !elementType:outRegisterType
        !?ioInstructionGenerationList
        ?let @objectIR groupIndexIR
      )
      [!?ioInstructionGenerationList appendEnterRegisterGroupSubscriptedAddress
        !?ioTemporaries
        ?registerAddress
        !mRegisterGroupName.string
        ![baseAddresses length]
        !groupIndexIR
      ]
    end
  end
#-------------------- Analyze control register target
  switch mRegisterIndex
  case noIndex :
    if registerArraySize == 0 then
      outllvmRegisterAddressName = registerAddress
    else
      error mRegisterName : "the control register is an array" : outllvmRegisterAddressName
    end
  case index (indexExpression endOfIndex) :
    handleArraySubscriptNew (
      !self: inSelfType
      !routineAttributes:inRoutineAttributes
      !context: inContext
      !mode: inMode
      !?temporary: ioTemporaries
      !?staticEntityMap:ioStaticEntityMap
      !?variableMap: ioUniversalMap
      !?alloca: ioAllocaList
      !indexExpression 
      !endOfIndex
      !arraySize:registerArraySize
      !elementType:outRegisterType
      !?ioInstructionGenerationList
      ?let @objectIR indexIR
    )
    [!?ioInstructionGenerationList appendComputeSubscriptedVolatileRegisterAddress
      !?ioTemporaries
      ?outllvmRegisterAddressName
      !indexIR
      !registerAddress
      !registerElementSize
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
