#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @compileTimePrefixOperatorEnumeration {
 case notOp   # not
 case minusOp # -
}

#·······················································································································

getter @compileTimePrefixOperatorEnumeration string -> @string {
  switch self
  case notOp   : result = "not"
  case minusOp : result = "-"
  end
}

#·······················································································································

getter @compileTimePrefixOperatorEnumeration prefixOperator -> @prefixOperator {
  switch self
  case notOp   : result = .notOp
  case minusOp : result = .minusOp
  end
}

#·······················································································································

class @compiletimePrefixOperatorAST : @abstractDeclarationAST {
  @compileTimePrefixOperatorEnumeration mPrefixOperator
  @location mPrefixOperatorLocation
  @lstring mReceiverName
  @lstring mReceiverTypeName
  @ctExpressionAST mExpression
  @lstring mResultTypeName
}

#·······················································································································

override getter @compiletimePrefixOperatorAST locationForErrorSignaling -> @location outLocation {
  outLocation = mPrefixOperatorLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension omnibus_syntax {

  #·····················································································································

  rule <compileTimePrefixOperator> !@compileTimePrefixOperatorEnumeration outOperator {
    select
      $not$
      outOperator = .notOp
    or
      $-%$
      outOperator = .minusOp
    end
  }
  
  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $compiletime$
    $func$
    let operationLocation = @location.here
    <compileTimePrefixOperator> ?let prefixOperator
    $($
    $identifier$ ?let receiverName
    $\$type$ ?let receiverType
    $)$
    $->$
    $\$type$ ?let resultType
    ${$
    <compile_time_expression> ?let @ctExpressionAST expression
    $}$
    ioAST.mDeclarationListAST += !@compiletimePrefixOperatorAST.new {
      !prefixOperator
      !operationLocation
      !receiverName
      !receiverType
      !expression
      !resultType
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compiletimePrefixOperatorAST enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  let nodeName = @lstring.new {![mPrefixOperator string] + "." + mReceiverTypeName !mPrefixOperatorLocation}
  [!?ioGraph addNode !nodeName !self]
  [!?ioGraph addEdge !nodeName !mReceiverTypeName]
  [!?ioGraph addEdge !nodeName !mResultTypeName]
  [!?ioGraph addEdge !compileTimeDeclarationBarrier () !nodeName ]
}

#·······················································································································

override getter @compiletimePrefixOperatorAST keyRepresentationForErrorSignaling -> @string outRepresentation {
  outRepresentation = [mPrefixOperator string] + " " + mReceiverTypeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @compiletimePrefixOperatorAST enterInContext
  ?!context: @semanticContext ioContext
  ?!@declarationDecorationList unused ioDecoratedDeclarationList
  ?!@decoratedRegularRoutineList unused ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
  ?!staticlistValues: @staticListInitializationMap unused ioStaticListValueMap
  ?!staticEntityMap: @staticEntityMap unused ioStaticEntityMap
  ?!registerUserAccess: @controlRegisterUserAccesMapAST unused ioControlRegisterUserAccesMapAST
  ?!userDefinedTypes: @userLLVMTypeDefinitionListIR unused ioUserLLVMTypeDefinitionListIR
{
#--- Check types
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mReceiverTypeName ?let receiverTypeProxy]
  let receiverType = [receiverTypeProxy type]
  [receiverType checkIsCompileTimeType !mReceiverTypeName.location]
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mResultTypeName ?let resultTypeProxy]
  let resultType = [resultTypeProxy type]
  [resultType checkIsCompileTimeType !mResultTypeName.location]
#--- Check native operator expression
  @ctCheckMap ctCheckMap = {}
  [!?ctCheckMap insertKey !mReceiverName]
  [mExpression checkCompileTimeExpression !ctCheckMap]
#--- Enter in infix operator map  
  let key = prefixOperatorMapKey (!receiverType !mPrefixOperator !mPrefixOperatorLocation)
  let definition = @compileTimePrefixOperatorUsage.new {
    !mPrefixOperatorLocation
    !mReceiverName
    !mExpression
  }
  [!?ioContext.mPrefixOperatorMap insertKey !key !receiverType !resultType !definition]
#--- Enter derived operators ?
  if mPrefixOperator == .minusOp then
    let minusNoOvf_key = prefixOperatorMapKey (!receiverType !.minusNoOvf !mPrefixOperatorLocation)
    [!?ioContext.mPrefixOperatorMap insertKey !minusNoOvf_key !receiverType !resultType !definition]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   PREFIX OPERATOR USAGE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @compileTimePrefixOperatorUsage : @prefixOperatorUsage {
  @location mPrefixOperatorLocation
  @lstring mReceiverOperandName
  @ctExpressionAST mExpression
}

#·······················································································································

override method @compileTimePrefixOperatorUsage generateCode
  ?let @objectIR inReceiverOperand
  ?let @location unused inOperatorLocation
  ?let @omnibusType inResultType
  ?noPanicCode: let @bool unused inDoNotGeneratePanicCode
  ?!@semanticTemporariesStruct unused ioTemporaries
  ?!@instructionListIR unused ioInstructionGenerationList
  !@objectIR outResultValue
{
  [inReceiverOperand literalInteger ?1* ?value: let receiverValue]
  @ctMap varMap = {}
  [!?varMap insertKey !mReceiverOperandName !receiverValue]
  [mExpression computeCompileTimeExpression !varMap ?result: let @bigint result]
  outResultValue = .literalInteger {!type: inResultType !value: result}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

