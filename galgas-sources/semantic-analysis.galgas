#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    A N A L Y S I S                                                                                 
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func checkAssignmentCompatibility
  ?source:let @objectIR inSourceValue
  ?targetAnnotationType:let @PLMType inOptionalTargetAnnotationType
  ?errorLocation:let @location inErrorLocation
  ?staticTypeAllowed:let @bool inStaticTypeAllowed
  -> @objectIR
{
  let sourceType = [inSourceValue type]
  if inOptionalTargetAnnotationType.plmOriginalTypeName == sourceType.plmOriginalTypeName then
    result = inSourceValue
  elsif [inOptionalTargetAnnotationType.kind isVoid] then
    result = inSourceValue
  elsif [sourceType.kind isStaticInteger] && [inOptionalTargetAnnotationType.kind isInteger] then
    [inSourceValue literalInteger ?1* ?value:let value]
    [inOptionalTargetAnnotationType.kind integer ?min:let minTarget ?max:let maxTarget ?2*]
    if (value < minTarget) || (maxTarget < value) then
      error inErrorLocation : "literal integer too large" : result
    else
      result = [inSourceValue withType !inOptionalTargetAnnotationType]
    end
  else
    error inErrorLocation
    : "object of type $" + inOptionalTargetAnnotationType.plmOriginalTypeName
      + " cannot be assigned from expression of type $" + [inSourceValue plmOriginalTypeName]
    : result
  end
  if not inStaticTypeAllowed then
    if [result plmOriginalTypeName] == staticIntegerTypeName () then
      error inErrorLocation : "the $" + staticIntegerTypeName () + " static type is not allowed here"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDecoratedDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @semanticTemporariesStruct {
  @uint mTemporaryIndex
  @panicRoutinePriorityMap mPanicSetupRoutinePriorityMap 
  @panicRoutinePriorityMap mPanicLoopRoutinePriorityMap 
  @subprogramInvocationGraph mSubprogramInvocationGraph
  @staticListInvokedFunctionSetMap mStaticArrayMapForTemporaries
  @stringset mInitializedDriverSet
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @semanticTemporariesStruct newTempLLVMVar !@string outTempLLVMVar {
  outTempLLVMVar = "%temp." + mTemporaryIndex
  mTemporaryIndex ++
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc getNewTempValue
  ?let @PLMType inType
  ?!@semanticTemporariesStruct ioTemporaries
  !@objectIR outTempVariable
{
  if inType.kind == .void then
    outTempVariable = .void
  else
    [!?ioTemporaries newTempLLVMVar ?let llvmName]
    outTempVariable = .llvmValue {!type: inType !llvmName:llvmName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc getNewTempReference
  ?let @PLMType inType
  ?!@semanticTemporariesStruct ioTemporaries
  !@objectIR outTempVariable
{
  if inType.kind == .void then
    outTempVariable = .void
  else
    [!?ioTemporaries newTempLLVMVar ?let llvmName]
    outTempVariable = .reference {!type: inType !llvmName:llvmName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc semanticAnalysis
  ?sourceFile:let @string inSourceFile
  ?ast:let @ast inAST
  ?decoratedDeclarationList:let @declarationDecorationList inDecoratedDeclarationList
  ?context:let @semanticContext inSemanticContext
  ?@subprogramInvocationGraph inSubprogramInvocationGraph
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?staticEntityMap:let @staticEntityMap inStaticEntityMap
  !intermediateCode:@intermediateCodeStruct outIntermediateCodeStruct
{
  outIntermediateCodeStruct = .default
  outIntermediateCodeStruct.mTargetParameters = inSemanticContext.mTargetParameters
  outIntermediateCodeStruct.mStaticEntityMap = inStaticEntityMap
  outIntermediateCodeStruct.mGlobalTaskVariableList = inSemanticContext.mGlobalTaskVariableList
  for requiredProc in inAST.mRequiredProcListAST do
    let procedureMangledName = routineMangledNameFromAST (!"" !requiredProc.mName !requiredProc.mFormalArgumentList)
    outIntermediateCodeStruct.mRequiredProcedureSet += !procedureMangledName.string
  end 
#---
  @semanticTemporariesStruct temporaries = .default
  temporaries.mSubprogramInvocationGraph = inSubprogramInvocationGraph
  for (declaration) in inDecoratedDeclarationList do
    [declaration semanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
  [inAST.mStandAloneSystemRoutineListAST systemRoutineSemanticAnalysis
    !receiverType:voidType ()
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mExternProcListAST externProcedureSemanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
#--- Check required procedure are defined
  checkRequiredProcedures (
    !ast:inAST
    !context:inSemanticContext
    !endOfSourceFile:inEndOfSourceFile
  )
#--- Print procedure invocation graph
  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
    let s = [temporaries.mSubprogramInvocationGraph graphviz]
    let filePath = [inSourceFile stringByDeletingPathExtension] + ".routineInvocation.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Check procedure invocation graph
  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
    if [undefinedNodeKeyList length] > 0 then
        var s = "subprogram invocation graph error, undefined nodes:"
        for (str) in undefinedNodeKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
    else
      [temporaries.mSubprogramInvocationGraph circularities
         ?let @lstringlist unused unsortedInformationList
         ?let @lstringlist unsortedLKeyList
      ]
      if [unsortedLKeyList length] > 0 then
        var s = "the following routines are recursive:"
        for (str) in unsortedLKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
