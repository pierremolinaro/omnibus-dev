#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    A N A L Y S I S                                                                                 
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func checkAssignmentCompatibility
  ?source:let @objectIR inSourceValue
  ?targetAnnotationType:let @unifiedTypeMap-proxy inTargetAnnotationType
  ?errorLocation:let @location inErrorLocation
  ?staticTypeAllowed:let @bool inStaticTypeAllowed
  -> @objectIR outResult
{
  if inTargetAnnotationType == .null then
    outResult = inSourceValue
  elsif inTargetAnnotationType == [inSourceValue type] then
    outResult = inSourceValue
  elsif [[[inSourceValue type] kind] isStaticInteger] && [[inTargetAnnotationType kind] isInteger] then
    [inSourceValue literalInteger ?1* ?value:let value]
    [[inTargetAnnotationType kind] integer ?min:let minTarget ?max:let maxTarget ?2*]
    if (value < minTarget) || (maxTarget < value) then
      error inErrorLocation : "literal integer too large" : outResult
    else
      outResult = [inSourceValue withType !inTargetAnnotationType]
    end
  else
    error inErrorLocation
    : "object of type $" + [inTargetAnnotationType key]
      + " cannot be assigned from expression of type $" + [[inSourceValue type] key]
    : outResult
  end
  if not inStaticTypeAllowed then
    if [[outResult type] key] == staticIntegerTypeName () then
      error inErrorLocation : "the $" + staticIntegerTypeName () + " static type is not allowed here"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @semanticTemporariesStruct {
  @uint mTemporaryIndex
  @panicRoutinePriorityMap mPanicSetupRoutinePriorityMap 
  @panicRoutinePriorityMap mPanicLoopRoutinePriorityMap 
  @initRoutinePriorityMap mInitRoutinePriorityMap
  @bootRoutinePriorityMap mBootRoutinePriorityMap
  @subprogramInvocationGraph mSubprogramInvocationGraph
  @staticArrayMap mStaticArrayMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc semanticAnalysis
  ?sourceFile:let @string inSourceFile
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?staticStringMap:let @staticStringMap inGlobalLiteralStringMap
  !intermediateCode:@intermediateCodeStruct outIntermediateCodeStruct
{
  outIntermediateCodeStruct = .default
  outIntermediateCodeStruct.mTargetParameters = inSemanticContext.mTargetParameters
  outIntermediateCodeStruct.mStaticStringMap = inGlobalLiteralStringMap
  outIntermediateCodeStruct.mGlobalTaskVariableList = inSemanticContext.mGlobalTaskVariableList
  for requiredProc in inAST.mRequiredProcListAST do
    outIntermediateCodeStruct.mRequiredProcedureSet += !requiredProc.mRequiredProcedureName.string
  end 
#--- Global variables
  for globalVar in inAST.mGlobalVarDeclarationListAST do
    [globalVar semanticAnalysis
      !context:inSemanticContext
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
#---
  @semanticTemporariesStruct temporaries = .default
  for (declaration) in inAST.mDeclarationListAST do
    [declaration semanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
  [inAST.mProcedureListAST procedureSemanticAnalysis
    !receiverType:.null
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mTaskListAST semanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mStandAloneSVCListAST svcSemanticAnalysis
    !receiverType:.null
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mGuardListAST guardSemanticAnalysis
    !receiverType:.null
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mExternProcListAST externProcedureSemanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mISRDeclarationListAST isrSemanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  for boot in inAST.mBootListAST do
    [boot bootSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for init in inAST.mInitListAST do
    [init initSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
#--- Generate panic clauses
  for panic in inAST.mPanicClauseListAST do
    [panic panicSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
#--- Check required procedure are defined
  checkRequiredProcedures (
    !ast:inAST
    !context:inSemanticContext
    !endOfSourceFile:inEndOfSourceFile
  )
#--- Print procedure invocation graph
  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
    let s = [temporaries.mSubprogramInvocationGraph graphviz]
    let filePath = [inSourceFile stringByDeletingPathExtension] + ".routineInvocation.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Check procedure invocation graph
  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
    if [undefinedNodeKeyList length] > 0 then
        var s = "subprogram invocation graph error, undefined nodes:"
        for (str) in undefinedNodeKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
    else
      [temporaries.mSubprogramInvocationGraph circularities
         ?let @lstringlist unused unsortedInformationList
         ?let @lstringlist unsortedLKeyList
      ]
      if [unsortedLKeyList length] > 0 then
        var s = "the following routines are recursive:"
        for (str) in unsortedLKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @functionCallIR : @abstractInstructionIR {
  @string mGlobalVariableName
  @objectIR mResult
  @lstring mFunctionMangledName
  @lstring mFunctionNameForGeneration
  @calleeKindIR mKind
  @procCallEffectiveParameterListIR mArgumentList
#  @bool mAppendFileAndLineArgumentForPanicLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += "  "
  if [mResult type] == .null then
    ioLLVMcode += "call void"
  else
    ioLLVMcode += [mResult llvmName] + " = call " + [mResult llvmTypeName]
  end
  ioLLVMcode += " @"
  switch mKind 
  case function :
    ioLLVMcode += llvmNameForFunction (!mFunctionNameForGeneration.string)
  case serviceFromProcessorUserMode :
    ioLLVMcode += llvmNameForServiceCall (!mFunctionNameForGeneration.string)
  case serviceFromProcessorPrivilegedMode :
    ioLLVMcode += llvmNameForServiceImplementation (!mFunctionNameForGeneration.string)
  case sectionFromProcessorUserMode :
    ioLLVMcode += llvmNameForSectionCall (!mFunctionNameForGeneration.string)
  case sectionFromProcessorPrivilegedMode :
    ioLLVMcode += llvmNameForSectionImplementation (!mFunctionNameForGeneration.string)
  case primitiveFromProcessorUserMode :
    ioLLVMcode += llvmNameForPrimitiveCall (!mFunctionNameForGeneration.string)
  case primitiveFromProcessorPrivilegedMode :
    ioLLVMcode += llvmNameForPrimitiveImplementation (!mFunctionNameForGeneration.string)
  case safeFromProcessorUserMode :
    ioLLVMcode += llvmNameForSafeCall (!mFunctionNameForGeneration.string)
  case safeFromProcessorPrivilegedMode :
    ioLLVMcode += llvmNameForSafeImplementation (!mFunctionNameForGeneration.string)
  end
  ioLLVMcode += " ("
  for () in mArgumentList do
    switch mEffectiveParameterPassingMode
    case input:
      ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
    case output:
      ioLLVMcode += [mParameter llvmTypeName] + " " + [mParameter llvmName]
    case outputInput:
      ioLLVMcode += [mParameter llvmTypeName] + " * " + [mParameter llvmName]
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ")\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionCallIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint unused ioMaxBranchOfOnInstructions
 {
  if mGlobalVariableName != "" then
    ioAccessibleEntities.mGlobalVariableSet += !mGlobalVariableName
  end
  ioAccessibleEntities.mRoutineSet += !mFunctionMangledName.string
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
