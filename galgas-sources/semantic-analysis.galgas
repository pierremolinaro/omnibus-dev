#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E M A N T I C    A N A L Y S I S                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc checkAssignmentCompatibility
  ?sourceType:let @unifiedTypeMap-proxy inSourceType
  ?targetType:let @unifiedTypeMap-proxy inTargetType
  ?errorLocation:let @location inErrorLocation
{
  if inTargetType != inSourceType then
    var ok = false
    if [[inSourceType kind] isBoolean] then
      ok = [[inTargetType kind] isInteger]    
    elsif [[inSourceType kind] isInteger] && [[inTargetType kind] isInteger] then
      [[inSourceType kind] integer ?min:let minSource ?max:let maxSource ?unsigned:* ?bitCount:*]
      [[inTargetType kind] integer ?min:let minTarget ?max:let maxTarget ?unsigned:* ?bitCount:*]
      ok = (minTarget <= minSource) && (maxTarget >= maxSource)
    end
    if not ok then
      error inErrorLocation
      : "object of type " + [inTargetType key] + " cannot be assigned from expression of type " + [inSourceType key]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct

#----------------------------------------------------------------------------------------------------------------------*

struct @semanticTemporariesStruct {
  @uint mTemporaryIndex
  @exceptionRoutinePriorityMap mExceptionSetupRoutinePriorityMap 
  @exceptionRoutinePriorityMap mExceptionLoopRoutinePriorityMap 
  @initRoutinePriorityMap mInitRoutinePriorityMap
  @bootRoutinePriorityMap mBootRoutinePriorityMap
  @subprogramInvocationGraph mSubprogramInvocationGraph
}

#----------------------------------------------------------------------------------------------------------------------*

proc semanticAnalysis
  ?sourceFile:let @string inSourceFile
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?staticStringMap:let @globalLiteralStringMap inGlobalLiteralStringMap
  !intermediateCode:@intermediateCodeStruct outIntermediateCodeStruct
{
  outIntermediateCodeStruct = .default
  outIntermediateCodeStruct.mGlobalLiteralStringMap = inGlobalLiteralStringMap
  for requiredProc in inAST.mRequiredProcList do
    outIntermediateCodeStruct.mRequiredProcedureSet += !requiredProc.mRequiredProcedureName.string
  end 
  for (declaration) in inAST.mDeclarationList do
    [declaration semanticAnalysis
      !context:inSemanticContext
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
  @semanticTemporariesStruct temporaries = .default
  for procedure in inAST.mProcedureListAST do
    [procedure procedureSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for function in inAST.mFunctionListAST do
    [function functionSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for boot in inAST.mBootList do
    [boot bootSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for init in inAST.mInitList do
    [init initSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for exception in inAST.mExceptionClauses do
    [exception exceptionSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
#--- Check required procedure are defined
  for requiredProc in inAST.mRequiredProcList do
    let requiredProcMangledName = mangledName (
      !forProcedureKind:.standAloneProc
      !procedureName:requiredProc.mRequiredProcedureName.string
      !formalArgumentList:requiredProc.mProcFormalArgumentList
    )
    if not [inSemanticContext.mProcedureMap hasKey !requiredProcMangledName] then
      var s = "the '" + requiredProc.mRequiredProcedureName + "' should be defined as: proc"
      for (mode) in requiredProc.mProcedureModeList do
        s += " $" + mode
      end
      s += " " + requiredProc.mRequiredProcedureName
      for arg in requiredProc.mProcFormalArgumentList do
        s += " "
        switch arg.mFormalArgumentPassingMode
        case input : s += "?"
        case output : s += "!"
        case inputOutput : s += "?!"
        end
        if arg.mSelector.string != "" then
          s += arg.mSelector.string + ":"
        end
        s += arg.mFormalArgumentTypeName.string
      end
      error inEndOfSourceFile : s
    else
      [inSemanticContext.mProcedureMap searchKey ![requiredProcMangledName nowhere] ?* ?let procModes ?2*]
      let actualProcModeSet = [procModes keySet]
      let requiredProcModeSet = @stringset.setWithLStringList{!requiredProc.mProcedureModeList}
      if actualProcModeSet != requiredProcModeSet then
        var s = "required modes:"
        for (mode) in requiredProcModeSet do
          s += " $" + mode
        end
        error [inSemanticContext.mProcedureMap locationForKey !requiredProcMangledName] : s
      end
    end
  end
#--- Print procedure invocation graph
  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
    let s = [temporaries.mSubprogramInvocationGraph graphviz]
    let filePath = [inSourceFile stringByDeletingPathExtension] + ".subprogramInvocation.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Check procedure invocation graph
  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
    if [undefinedNodeKeyList length] > 0 then
        var s = "subprogram invocation graph error, undefined nodes:"
        for (str) in undefinedNodeKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
    else
      [temporaries.mSubprogramInvocationGraph circularities
         ?let @lstringlist unused unsortedInformationList
         ?let @lstringlist unsortedLKeyList
      ]
      if [unsortedLKeyList length] > 0 then
        var s = "the following routines are recursive:"
        for (str) in unsortedLKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
