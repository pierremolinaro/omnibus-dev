#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    S E M A N T I C    A N A L Y S I S                                                                                 
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func checkAssignmentCompatibility
  ?source:let @operandIR inSourceValue
  ?targetAnnotationType:let @unifiedTypeMap-proxy inTargetAnnotationType
  ?errorLocation:let @location inErrorLocation
  ?staticTypeAllowed:let @bool inStaticTypeAllowed
  -> @operandIR outResult
{
  if inTargetAnnotationType == .null then
    outResult = inSourceValue
  elsif inTargetAnnotationType != inSourceValue.mType then
    if [[inSourceValue.mType kind] isStaticInteger] && [[inTargetAnnotationType kind] isInteger] then
      [inSourceValue.mValue literalInteger ?value:let value]
      [[inTargetAnnotationType kind] integer ?min:let minTarget ?max:let maxTarget ?unsigned:* ?bitCount:*]
      if (value < minTarget) || (maxTarget < value) then
        error inErrorLocation : "literal integer too large" : outResult
      else
        outResult = .new {!inTargetAnnotationType !inSourceValue.mValue}
      end
    else
      error inErrorLocation
      : "object of type $" + [inTargetAnnotationType key] + " cannot be assigned from expression of type $" + [inSourceValue.mType key]
      :outResult
    end
  else
    outResult = inSourceValue
  end
  if not inStaticTypeAllowed then
    if [outResult.mType key] == staticIntegerTypeName () then
      error inErrorLocation : "the $" + staticIntegerTypeName () + " static type is not allowed here"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @semanticTemporariesStruct {
  @uint mTemporaryIndex
  @exceptionRoutinePriorityMap mExceptionSetupRoutinePriorityMap 
  @exceptionRoutinePriorityMap mExceptionLoopRoutinePriorityMap 
  @initRoutinePriorityMap mInitRoutinePriorityMap
  @bootRoutinePriorityMap mBootRoutinePriorityMap
  @subprogramInvocationGraph mSubprogramInvocationGraph
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc semanticAnalysis
  ?sourceFile:let @string inSourceFile
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?staticStringMap:let @staticStringMap inGlobalLiteralStringMap
  !intermediateCode:@intermediateCodeStruct outIntermediateCodeStruct
{
  outIntermediateCodeStruct = .default
  outIntermediateCodeStruct.mTaskVariableMap = inSemanticContext.mTaskVariableMap
  outIntermediateCodeStruct.mStaticStringMap = inGlobalLiteralStringMap
  for requiredProc in inAST.mRequiredProcList do
    outIntermediateCodeStruct.mRequiredProcedureSet += !"." + requiredProc.mRequiredProcedureName.string
  end 
#--- Global variables
  for globalVar in inAST.mGlobalVarDeclarationList do
    [globalVar semanticAnalysis
      !context:inSemanticContext
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
#--- Control registers
  controlRegistersSemanticAnalysis (
    !inAST.mControlRegisterDeclarationListAST
    !context:inSemanticContext
    !?intermediateCode:outIntermediateCodeStruct
  )
#---
  @semanticTemporariesStruct temporaries = .default
  for (declaration) in inAST.mDeclarationList do
    [declaration semanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
  [inAST.mProcedureListAST procedureSemanticAnalysis
    !receiverType:.null
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mTaskList semanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mSectionListAST sectionSemanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mServiceListAST serviceSemanticAnalysis
    !receiverType:.null
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  [inAST.mExternProcList externProcedureSemanticAnalysis
    !context:inSemanticContext
    !?temporary:temporaries
    !?intermediateCode:outIntermediateCodeStruct
  ]
  for function in inAST.mFunctionListAST do
    [function functionSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for boot in inAST.mBootList do
    [boot bootSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for init in inAST.mInitList do
    [init initSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
#--- Generate panic clauses
  for exception in inAST.mExceptionClauses do
    [exception exceptionSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
#--- Check required procedure are defined
  checkRequiredProcedures (
    !ast:inAST
    !context:inSemanticContext
    !endOfSourceFile:inEndOfSourceFile
  )
#--- Print procedure invocation graph
  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
    let s = [temporaries.mSubprogramInvocationGraph graphviz]
    let filePath = [inSourceFile stringByDeletingPathExtension] + ".routineInvocation.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Check procedure invocation graph
  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
    if [undefinedNodeKeyList length] > 0 then
        var s = "subprogram invocation graph error, undefined nodes:"
        for (str) in undefinedNodeKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
    else
      [temporaries.mSubprogramInvocationGraph circularities
         ?let @lstringlist unused unsortedInformationList
         ?let @lstringlist unsortedLKeyList
      ]
      if [unsortedLKeyList length] > 0 then
        var s = "the following routines are recursive:"
        for (str) in unsortedLKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
