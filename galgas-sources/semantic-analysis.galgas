#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E M A N T I C    A N A L Y S I S                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc checkAssignmentCompatibility
  ?sourceType:let @unifiedTypeMap-proxy inSourceType
  ?targetType:let @unifiedTypeMap-proxy inTargetType
  ?errorLocation:let @location inErrorLocation
{
  if inTargetType != inSourceType then
    var ok = false
    if [[inSourceType kind] isBoolean] then
      ok = [[inTargetType kind] isInteger]    
    elsif [[inSourceType kind] isInteger] && [[inTargetType kind] isInteger] then
      [[inSourceType kind] integer ?min:let minSource ?max:let maxSource ?unsigned:* ?bitCount:*]
      [[inTargetType kind] integer ?min:let minTarget ?max:let maxTarget ?unsigned:* ?bitCount:*]
      ok = (minTarget <= minSource) && (maxTarget >= maxSource)
    end
    if not ok then
      error inErrorLocation
      : "object of type " + [inTargetType key] + " cannot be assigned from expression of type " + [inSourceType key]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct

#----------------------------------------------------------------------------------------------------------------------*

struct @semanticTemporariesStruct {
  @uint mTemporaryIndex
  @exceptionRoutinePriorityMap mExceptionSetupRoutinePriorityMap 
  @exceptionRoutinePriorityMap mExceptionLoopRoutinePriorityMap 
  @initRoutinePriorityMap mInitRoutinePriorityMap
  @bootRoutinePriorityMap mBootRoutinePriorityMap
  @subprogramInvocationGraph mSubprogramInvocationGraph
}

#----------------------------------------------------------------------------------------------------------------------*

proc semanticAnalysis
  ?sourceFile:let @string inSourceFile
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location inEndOfSourceFile
  ?staticStringMap:let @globalLiteralStringMap inGlobalLiteralStringMap
  !intermediateCode:@intermediateCodeStruct outIntermediateCodeStruct
{
  outIntermediateCodeStruct = .default
  outIntermediateCodeStruct.mGlobalLiteralStringMap = inGlobalLiteralStringMap
  for requiredProc in inAST.mRequiredProcList do
    outIntermediateCodeStruct.mRequiredProcedureSet += !requiredProc.mRequiredProcedureName.string
  end 
#--- Global variables
  for globalVar in inAST.mGlobalVarDeclarationList do
    [globalVar semanticAnalysis
      !context:inSemanticContext
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
  for (declaration) in inAST.mDeclarationList do
    [declaration semanticAnalysis
      !context:inSemanticContext
      !?intermediateCode:outIntermediateCodeStruct
     ]
  end
  @semanticTemporariesStruct temporaries = .default
  for procedure in inAST.mProcedureListAST do
    [procedure procedureSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for function in inAST.mFunctionListAST do
    [function functionSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for boot in inAST.mBootList do
    [boot bootSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for init in inAST.mInitList do
    [init initSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
  for exception in inAST.mExceptionClauses do
    [exception exceptionSemanticAnalysis
      !context:inSemanticContext
      !?temporary:temporaries
      !?intermediateCode:outIntermediateCodeStruct
    ]
  end
#--- Check required procedure are defined
  checkRequiredProcedures (
    !ast:inAST
    !context:inSemanticContext
    !endOfSourceFile:inEndOfSourceFile
  )
#--- Print procedure invocation graph
  if (@uint.errorCount == 0) && [option plm_options.writeRoutineInvocationGraphFile value] then
    let s = [temporaries.mSubprogramInvocationGraph graphviz]
    let filePath = [inSourceFile stringByDeletingPathExtension] + ".subprogramInvocation.dot"
    [s writeToFileWhenDifferentContents !filePath ?*]
  end
#--- Check procedure invocation graph
  if (@uint.errorCount == 0) && not [option plm_options.doNotDetectRecursiveCalls value] then
    let undefinedNodeKeyList = [temporaries.mSubprogramInvocationGraph undefinedNodeKeyList]
    if [undefinedNodeKeyList length] > 0 then
        var s = "subprogram invocation graph error, undefined nodes:"
        for (str) in undefinedNodeKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
    else
      [temporaries.mSubprogramInvocationGraph circularities
         ?let @lstringlist unused unsortedInformationList
         ?let @lstringlist unsortedLKeyList
      ]
      if [unsortedLKeyList length] > 0 then
        var s = "the following routines are recursive:"
        for (str) in unsortedLKeyList do
          s += "\n - " + str
        end
        error inEndOfSourceFile : s
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
