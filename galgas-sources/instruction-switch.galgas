#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @switchCaseListAST {
  @lstringlist mCaseIdentifiers
  @instructionListAST mCaseInstructionList
}

#·······················································································································

class @switchInstructionAST : @instructionAST {
  @expressionAST mSwitchExpression
  @location mEndOf_test_expression
  @switchCaseListAST mSwitchCaseList
  @location mEndOf_switch_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList  {
    $switch$
    let instructionLocation = @location.here
    <expression> ?let @expressionAST switchExpression
    let switchExpressionEndLocation = @location.here
    ${$
    @switchCaseListAST switchCaseList = {}
    repeat
      $case$
      @lstringlist caseIdentifiers = {}
      repeat
        $identifier$ ?let caseIdf
        caseIdentifiers += !caseIdf
      while
        $,$
      end
      $:$
      <instructionList> ?let instructionList
      switchCaseList += !caseIdentifiers !instructionList
    while
    end
    let endOfInstruction = @location.here
    $}$
    ioInstructionList += !@switchInstructionAST.new {
      !instructionLocation
      !switchExpression
      !switchExpressionEndLocation
      !switchCaseList
      !endOfInstruction
    }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mSwitchExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
  for (* instructionList) in mSwitchCaseList do
    [instructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@universalValuedObjectMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze test expression
  @instructionListIR switchExpressionGenerationList = {}
  [mSwitchExpression analyzeExpression
    !self:inSelfType
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:voidType ()
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:switchExpressionGenerationList
    ?result:let @objectIR switchValueIRPossibleReference
  ]
  [!?ioInstructionGenerationList appendLoadWhenReference
    !?ioTemporaries
    !switchValueIRPossibleReference
    ?let switchValueIR
  ]  
#--- Check inferred type
  @constantMap enumConstantMap
  if [[[switchValueIR type] mKind] isEnumeration] then
    [[[switchValueIR type] mKind] enumeration ?constantMap:enumConstantMap ?2*]
  else
    error mEndOf_test_expression
      : "test expression type is '" + [switchValueIR key] + "', it should be boolean"
      : enumConstantMap
  end
  if [switchValueIR isStatic] then
    error mEndOf_test_expression : "test expression type should not be static"
  end
#--- Analyse case list
  [!?ioUniversalMap openOverrideForSelectBlock]
  @stringset usedEnumerationValues = {}
  @switchCaseListIR switchCaseListIR = {}
  for (caseIdentifiers instructionList) in mSwitchCaseList do
    @uintlist caseIdentifierIndexList = {}
    for (caseIdf) in caseIdentifiers do
      [enumConstantMap searchKey !caseIdf ?let @bigint constantIdx ?*]
      caseIdentifierIndexList += !constantIdx
      if [usedEnumerationValues hasKey !caseIdf] then
        error caseIdf : "duplicated enumeration constant" fixit { remove }
      end
      usedEnumerationValues += !caseIdf
    end
    @instructionListIR instructionGenerationList = {}
    [instructionList analyzeBranchInstructionList
      !self:inSelfType
      !propertiesAreMutable:inRoutineCanMutateProperties
      !directAccessToPropertiesAllowed:inDirectAccessToPropertiesAllowed
      !routineNameForInvocationGraph:inCallerNameForInvocationGraph
      !endOfInstructionList:mEndOf_switch_instruction
      !context:inContext
      !mode:inCurrentMode
      !?temporary:ioTemporaries
      !?staticStringMap:ioGlobalLiteralStringMap
      !?variableMap:ioUniversalMap
      !?alloca:ioAllocaList
      !?instructionListIR:instructionGenerationList
    ]
    switchCaseListIR += !caseIdentifierIndexList !instructionGenerationList
  end  
  [!?ioUniversalMap closeOverride !mEndOf_switch_instruction]
#--- Check all enumeration values are named in switch instructions
  for (lkey * *) in enumConstantMap do
    if not [usedEnumerationValues hasKey !lkey] then
      error mEndOf_test_expression : "missing '" + lkey + "' enumeration constant"
    end  
  end 
#--- Code generation
  ioInstructionGenerationList += !@switchInstructionIR.new {
    ![mEndOf_test_expression locationIndex]
    !switchExpressionGenerationList
    !switchValueIR
    !switchCaseListIR
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @switchCaseListIR {
  @uintlist mCaseIdentifierIndexes
  @instructionListIR mCaseInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @switchInstructionIR : @abstractInstructionIR {
  @uint mLabelIndex
  @instructionListIR mSwitchExpressionGenerationList
  @objectIR mSwitchExpression
  @switchCaseListIR mCaseGenerationList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
#--- Generate instructions that compute switch expression
  [mSwitchExpressionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Generate switch instruction
  let labelOtherwise = "switch." + mLabelIndex + ".otherwise"
  ioLLVMcode += "  switch " + [mSwitchExpression llvmTypeName] + " " + [mSwitchExpression llvmName]
  ioLLVMcode += ", label %" + labelOtherwise + " [\n"
  for (caseIdentifierIndexes *) in mCaseGenerationList do (branchIdx)
    for (caseIdfIndex) in caseIdentifierIndexes do
      ioLLVMcode += "    " + [mSwitchExpression llvmTypeName] + " " + caseIdfIndex
      ioLLVMcode += ", label %switch." + mLabelIndex + ".branch." + branchIdx + "\n"
    end
  end
  ioLLVMcode += "  ]\n\n"
#--- Generate branches
  for (* instructionList) in mCaseGenerationList do (branchIdx)
    ioLLVMcode += "switch." + mLabelIndex + ".branch." + branchIdx + ":\n"
    [instructionList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
    ioLLVMcode += "  br label %" + labelOtherwise + "\n\n"
  end
#--- Otherwise label
  ioLLVMcode += labelOtherwise + ":\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionIR enterAccessibleEntities
  ?!@accessibleEntities ioAccessibleEntities
  ?!@uint ioMaxBranchOfOnInstructions
{
  [mSwitchExpressionGenerationList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
  for (* instructionList) in mCaseGenerationList do
    [instructionList enterAccessibleEntities !?ioAccessibleEntities !?ioMaxBranchOfOnInstructions]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
