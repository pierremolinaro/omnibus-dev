#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C O D E    G E N E R A T I O N                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

getter @variableKindIR mangledName -> @string outResult {
  switch self
  case register (@lstring name) :
    outResult = mangledNameForRegister (!name:name.string)
  case globalConstant (@lstring name) :
    outResult = mangledNameForConstant (!name:name.string)
  case globalVariable (@lstring name) :
    outResult = mangledNameForGlobalVariable (!name:name.string)
  case localVariable (@lstring name) :
    outResult = mangledNameForLocalVariable (!name:name.string)
  case inArgument (@lstring name) :
    outResult = mangledNameForInArgument (!name:name.string)
  case inOutArgument (@lstring name) :
    outResult = mangledNameForInOutArgument (!name:name.string)
  case outArgument (@lstring name) :
    outResult = "* " + mangledNameForOutArgument (!name:name.string)
  case localConstant (@lstring name) :
    outResult = mangledNameForConstant (!name:name.string)
  case temporaryConstant (@luint idx) :
    outResult = mangledNameForTemporaryConstant (!idx:idx.uint)
  case localAccess (@string access @location unused location) :
    outResult = access
  case literalUnsignedInteger (@unifiedTypeMap-proxy type @luint64 value) :
    outResult = "((" + mangledNameForType (!name:[type key]) + ") " + value.uint64 + ")"
  case literalSignedInteger (@unifiedTypeMap-proxy type @lsint64 value) :
    outResult = "((" + mangledNameForType (!name:[type key]) + ") " + value.sint64 + ")"
  case literalString (* @string name) :
    outResult = name
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

abstract class @abstractExpressionIR {
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractInstructionIR
#----------------------------------------------------------------------------------------------------------------------*

abstract class @abstractInstructionIR {
}

#----------------------------------------------------------------------------------------------------------------------*

abstract getter @abstractInstructionIR instructionCode -> @string outCode

#----------------------------------------------------------------------------------------------------------------------*
#! @instructionListIR
#----------------------------------------------------------------------------------------------------------------------*

list @instructionListIR {
  @abstractInstructionIR mInstructionGeneration
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractTypeIR
#----------------------------------------------------------------------------------------------------------------------*

abstract getter @abstractTypeIR headerCodeGenerationForType -> @string outCode

#----------------------------------------------------------------------------------------------------------------------*
#! codeGeneration
#----------------------------------------------------------------------------------------------------------------------*

func %once separatorLine -> @string outResult {
  outResult  = "//------------------------------------------------------------------------"
  outResult += "---------------------------------------------*\n"
}

#----------------------------------------------------------------------------------------------------------------------*

func titleComment ?@string inTitle -> @string outTitle {
  outTitle  = separatorLine ()
  outTitle += "//   " + [inTitle stringByRightPadding  !114!' '] + "*\n"
  outTitle += separatorLine () + "\n"
}

#----------------------------------------------------------------------------------------------------------------------*

proc codeGeneration
  ?outputFile:let @string inSourceFileName
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?target:let @lstring inTargetName
{
#--- Create source directory (if does not exist)
  let targetDirectory = [inSourceFileName stringByDeletingPathExtension]
  let sourceDirectory = targetDirectory + "/sources"
  [sourceDirectory makeDirectory] ;
#--- Generate target files
  generateTargets (
    !targetDirectory:targetDirectory
    !targetName:inTargetName
    ?filesToInclude:let @stringlist builtinFiles
  )
#--- Generate C file
  var code = ""
  code += "#include <stdint.h>\n"
  code += "#include <stdbool.h>\n"
  code += "#include <stddef.h>\n\n"
  for @typeMapIR-element type in inIntermediateCodeStruct.mTypeMapIR do
    code += [type.mType headerCodeGenerationForType]
  end
  code += titleComment (!"Init")
  code += "static void init (void) ;\n\n"
  code += titleComment (!"Exception")
  code += "uint32_t readIPSR (void) ;\n\n"
  code += "void raise_exception_internal (const uint32_t inCode,\n"
  code += "                               const char * inSourceFile,\n"
  code += "                               const uint32_t inSourceLine) ;\n\n"
  code += "void raise_exception_via_svc (const int32_t inCode,\n"
  code += "                                     const char * inSourceFile,\n"
  code += "                                     const int32_t inSourceLine) ;\n\n"
  code += "static void raise_exception (const int32_t inCode,\n"
  code += "                             const char * inSourceFile,\n"
  code += "                             const int32_t inSourceLine) {\n"
  code += "  uint32_t status ;\n"
  code += "  __asm__ (\"mrs %[reg], IPSR\" : [reg]\"=r\"(status));\n"
  code += "  if (0 == status) {\n"
  code += "    raise_exception_internal (inCode, inSourceFile, inSourceLine) ;\n"
  code += "  }else{\n"
  code += "    raise_exception_via_svc (inCode, inSourceFile, inSourceLine) ;\n"
  code += "  }\n"
  code += "}\n\n"
  code += titleComment (!"Static Strings")
  for () in inIntermediateCodeStruct.mGlobalLiteralStringMap do
    code += "static const char * " + mLiteralStringCname + " = " + [lkey.string utf8Representation] + " ;\n"
  end
  code += "\n"
  for register in inIntermediateCodeStruct.mRegisterMap do
    code += [register headerCodeGenerationForRegister]
  end
  for globalConstant in inIntermediateCodeStruct.mGlobalConstantMap do
    code += [globalConstant headerCodeGeneration]
  end
  for globalVariable in inIntermediateCodeStruct.mGlobalVariableMap do
    code += [globalVariable implementationCodeGeneration]
  end
  code += titleComment (!"Raise Exception internal")
  code += "void raise_exception_internal (const uint32_t in_CODE,\n"
  code += "                               const char * in_FILE,\n"
  code += "                               const uint32_t in_LINE) {\n"
  code += [inIntermediateCodeStruct.mExceptionInstructionListIR instructionListCode]
  code += "}\n\n"
  for function in inIntermediateCodeStruct.mFunctionMapIR do
    code += [function headerCodeGeneration]
  end
  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
    code += [procedure headerCodeGeneration]
  end
  code += titleComment (!"System code")
  for (file) in builtinFiles do
    code += "#include \"" + file + "\"\n"
  end
  code += "\n"
#--- Init
  code += titleComment (!"Init")
  code += "static void init (void) {\n"
  for init in inIntermediateCodeStruct.mInitList do
    code += [init.mInstructionListIR instructionListCode]
  end
  code += "}\n\n"
  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
    code += [procedure implementationCodeGeneration]
  end
  for function in inIntermediateCodeStruct.mFunctionMapIR do
    code += [function implementationCodeGeneration]
  end
  code += separatorLine ()
  [code writeToFileWhenDifferentContents !sourceDirectory + "/plm.c" ?*]
}

#----------------------------------------------------------------------------------------------------------------------*

