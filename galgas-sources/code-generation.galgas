#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                       
#    C O D E    G E N E R A T I O N                                                                                     
#                                                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @objectInMemoryIR mangledName -> @string outResult {
  switch self
  case register (* @lstring name *) :
    outResult = llvmNameForRegister (!name:name.string)
  case globalVariable (* @string name *) :
    outResult = llvmNameForGlobalVariable (!name)
  case localValue (* @string name) :
    outResult = llvmNameForLocalVariable (!name)
  case globalConstant (* @string name) :
    outResult = llvmNameForGlobalVariable (!name)
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @abstractExpressionIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractExpressionIR {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @generationAdds
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @generationAdds {
  @uint mUniqueIndex
  @stringset mExternFunctionDeclarationSet
  @staticStringMap mStaticStringMap
  @bool mUsesGuards
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @abstractInstructionIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @abstractInstructionIR {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @instructionListIR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @instructionListIR {
  @abstractInstructionIR mInstructionGeneration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! codeGeneration
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once llvmSeparatorLine -> @string outResult {
  outResult  = ";-------------------------------------------------------------------------"
  outResult += "---------------------------------------------*\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmTitleComment ?@string inTitle -> @string outTitle {
  outTitle  = llvmSeparatorLine ()
  outTitle += ";    " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += llvmSeparatorLine () + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once asSeparatorLine -> @string outResult {
  outResult  = "@-------------------------------------------------------------------------"
  outResult += "---------------------------------------------*\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func asTitleComment ?@string inTitle -> @string outTitle {
  outTitle  = asSeparatorLine ()
  outTitle += "@    " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += asSeparatorLine () + "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc codeGeneration
  ?currentDir:let @string inCurrentDirectory
  ?outputFile:let @string inSourceFileName
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?typeMap:let @unifiedTypeMap inTypeMap
  ?target:let @lstring inTargetName
  ?panicCodeType:let @unifiedTypeMap-proxy inPanicCodeType
  ?panicLineType:let @unifiedTypeMap-proxy inPanicLineType
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
{
  let homeDir = @string.homeDirectory + "/plm-products/"
#--- Create source directory (if does not exist)
  let productDirectory = homeDir
    + if [option plm_options.noPanicGeneration value] then "no-panic" else "" end
    + [[inSourceFileName stringByDeletingPathExtension] stringByReplacingStringByString !"/" !"+"]
  let sourceDirectory = productDirectory + "/sources"
  [sourceDirectory makeDirectory] ;
#--- Generate target files
  generateTarget (
    !currentDir:inCurrentDirectory
    !productDirectory:productDirectory
    !targetName:inTargetName
  )
#--- Generate LLVM file
  generateLLVMfile (
    !currentDir:inCurrentDirectory
    !productDir:productDirectory
    !eof:inEndOfSourceFileLocation
    !intermediateCode:inIntermediateCodeStruct
    !typeMap:inTypeMap
    !target:inTargetName
    !panicCodeType:inPanicCodeType
    !panicLineType:inPanicLineType
    !sourceFileSet:inSourceFileAbsolutePathSet
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @generationContext {
  @string mPanicCodeLLVMType
  @string mPanicLineLLVMType
  @globalTaskVariableList mGlobalTaskVariableList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc generateLLVMfile
  ?currentDir:let @string inCurrentDirectory
  ?productDir:let @string inProductDirectory
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?typeMap:let @unifiedTypeMap inTypeMap
  ?target:let @lstring inTargetName
  ?panicCodeType:let @unifiedTypeMap-proxy inPanicCodeType
  ?panicLineType:let @unifiedTypeMap-proxy inPanicLineType
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
{
  @generationAdds generationAdds = .default
  generationAdds.mStaticStringMap = inIntermediateCodeStruct.mStaticStringMap
  let @generationContext generationContext = .new {
    ![inPanicCodeType llvmTypeName]
    ![inPanicLineType llvmTypeName]
    !inIntermediateCodeStruct.mGlobalTaskVariableList
  }
  let sourceDirectory = inProductDirectory + "/sources"
#----------------------------------------- Include assembler specific file
  var asCode = asTitleComment (!"Target specific code")
  let asFileContents = getTargetTextFile (
     !currentDir:inCurrentDirectory
     !from:inTargetName.string + "/target.s"
  )
  asCode += [asFileContents stringByReplacingStringByString !"!FUNC!" !llvmNameForFunction (!".")]
  asCode += "\n"
#----------------------------------------- Include LLVM specific file
  var llvmCode = llvmTitleComment (!"Target specific code")
  let targetLLVMcode = getTargetTextFile (
     !currentDir:inCurrentDirectory
     !from:inTargetName.string + "/target.ll"
  )
  llvmCode += [targetLLVMcode stringByReplacingStringByString !"!FUNC!" !llvmNameForFunction (!".")]
  llvmCode += "\n"
#----------------------------------------- Structure types declaration
  declareLLVMTypes (!inTypeMap !?llvmCode)
#----------------------------------------- Global variables
  for globalVariable in inIntermediateCodeStruct.mGlobalVariableMap
    before llvmCode += llvmTitleComment (!"Global variables")
    do [globalVariable generateLLVM !?llvmCode]
    after llvmCode += "\n"
  end
#----------------------------------------- Boot
  llvmCode += llvmTitleComment (!"Boot")
  llvmCode += "define internal void @boot ()" + llvmAttributeFunction () + "{\n"
  for boot in inIntermediateCodeStruct.mBootList do
    [boot.mInstructionListIR instructionListLLVMCode !?llvmCode !generationContext !?generationAdds]
  end
  llvmCode += "  ret void\n"
  llvmCode += "}\n\n"
#----------------------------------------- Init
  [inIntermediateCodeStruct.mInitList generateLLVMinitCode
    !?llvmCode
    !inIntermediateCodeStruct.mRoutineMapIR
    !generationContext
    !?generationAdds
  ]
#----------------------------------------- Procedures
  [inIntermediateCodeStruct.mRoutineMapIR llvmCodeGeneration !?llvmCode !?asCode !generationContext !?generationAdds]
#----------------------------------------- Extern procedures
  [inIntermediateCodeStruct.mExternProcedureMapIR llvmPrototypeGeneration !?llvmCode]
  @2stringlist serviceList = {}
  @2stringlist sectionList = {}
#----------------------------------------- Use guards ?
  if generationAdds.mUsesGuards then
    let waitForGuardChange = waitForGuardChangeFunctionName ()
    serviceList += !llvmNameForServiceCall (!waitForGuardChange) !llvmNameForServiceImplementation (!waitForGuardChange)
    generationAdds.mExternFunctionDeclarationSet += !"declare void @" + llvmNameForServiceCall (!waitForGuardChange) + " ()\n"
  end
#----------------------------------------- Sections
  [inIntermediateCodeStruct.mRoutineMapIR sectionCodeGeneration
    !?llvmCode
    !?sectionList
  ]
#----------------------------------------- Services
  [inIntermediateCodeStruct.mRoutineMapIR serviceCodeGeneration
    !?llvmCode
    !?serviceList
  ]
#----------------------------------------- Guards
  [inIntermediateCodeStruct.mGuardMapIR guardCodeGeneration
    !?llvmCode
    !?serviceList
    !generationContext
    !?generationAdds
  ]
#----------------------------------------- Service dispatcher
  generateServiceDispatcher (
    !inCurrentDirectory
    !inTargetName.string
    !?asCode
    !serviceList
  )
#----------------------------------------- Section dispatcher
  generateSectionDispatcher (
    !inCurrentDirectory
    !inTargetName.string
    !?asCode
    !sectionList
  )
#----------------------------------------- Panic
  if not [option plm_options.noPanicGeneration value] then
    llvmCode += getTargetTextFile (
       !currentDir:inCurrentDirectory
       !from:inTargetName.string + "/target-panic.ll"
    )
    llvmCode += llvmTitleComment (!"Raise Panic internal")
    llvmCode += "define internal void @raise_panic_internal ("
    llvmCode += generationContext.mPanicLineLLVMType + " %in.LINE, "
    llvmCode += generationContext.mPanicCodeLLVMType + " %in.CODE, "
    llvmCode += "i8* %in.FILE)" + llvmAttributeFunction () + "noreturn {\n"
  #--- First argument: line
    llvmCode += "  %" + llvmNameForLocalVariable (!"LINE") + " = alloca "
    llvmCode += generationContext.mPanicLineLLVMType + "\n"
    llvmCode += "  store " + generationContext.mPanicLineLLVMType + " %in.LINE, "
    llvmCode += generationContext.mPanicLineLLVMType + "* %" + llvmNameForLocalVariable (!"LINE") + "\n"
  #--- Second argument : code
    llvmCode += "  %" + llvmNameForLocalVariable (!"CODE")
    llvmCode += " = alloca " + generationContext.mPanicCodeLLVMType + "\n"
    llvmCode += "  store " + generationContext.mPanicCodeLLVMType + " %in.CODE, "
    llvmCode += generationContext.mPanicCodeLLVMType + "* %" + llvmNameForLocalVariable (!"CODE") + "\n"
  #--- Third argument : file    
    llvmCode += "  %" + llvmNameForLocalVariable (!"FILE") + " = alloca i8*\n"
    llvmCode += "  store i8* %in.FILE, i8** %" + llvmNameForLocalVariable (!"FILE") + "\n"
    [inIntermediateCodeStruct.mPanicSetupInstructionListIR instructionListLLVMCode
      !?llvmCode
      !generationContext
      !?generationAdds
    ]
    llvmCode += "  br label %panic.loop\n\n"
    llvmCode += "panic.loop:\n"
    [inIntermediateCodeStruct.mPanicLoopInstructionListIR instructionListLLVMCode
      !?llvmCode
      !generationContext
      !?generationAdds
    ]
    llvmCode += "  br label %panic.loop\n"
    llvmCode += "}\n\n"
  #--- File specific routines
    for (filePath) in inSourceFileAbsolutePathSet do
      [!?generationAdds.mStaticStringMap findOrAddStaticString
        ![[filePath lastPathComponent] stringByDeletingPathExtension]
        ?let staticStringIndex
      ]
      let routineName = "@raise_panic." + staticStringIndex
      llvmCode += llvmTitleComment (!routineName + " (" + [filePath lastPathComponent] + ")")
      llvmCode += "define internal void " + routineName + " (i32 %inSourceLine, i32 %inCode)" + llvmAttributeFunction () + "noreturn {\n"
      llvmCode += "  %str.FILE = load i8*, i8** @string." + staticStringIndex + "\n"
      llvmCode += "  call void @raise_panic (i32 %inSourceLine, i32 %inCode, i8* %str.FILE)\n"
      llvmCode += "  unreachable\n"
      llvmCode += "}\n\n"
    end
  end
#----------------------------------------- tasks
  [inIntermediateCodeStruct.mTaskMapIR generateCode !?llvmCode !generationContext !?generationAdds]
#----------------------------------------- Intrinsics
  if [generationAdds.mExternFunctionDeclarationSet count] > 0 then
    llvmCode += llvmTitleComment (!"LLVM extern functions")
    for (s) in generationAdds.mExternFunctionDeclarationSet do
      llvmCode += s + "\n"
    end
    llvmCode += "\n"
  end
#----------------------------------------- Static Strings
  if [generationAdds.mStaticStringMap count] > 0 then
    llvmCode += llvmTitleComment (!"Static strings")
    for () in generationAdds.mStaticStringMap do
      let lgStr = [[lkey.string length] + 1 string]
      llvmCode += literalCharacterArrayName (!mIndex) + " = private unnamed_addr constant ["
      llvmCode += lgStr + " x i8] c\""
      llvmCode += [lkey.string utf8RepresentationWithoutDelimiters]
      llvmCode += "\\00\", align 1\n"
      llvmCode += literalStringName (!mIndex) + " = private constant i8* getelementptr inbounds (["
      llvmCode += lgStr + " x i8], [" + lgStr + " x i8]* "
      llvmCode += literalCharacterArrayName (!mIndex) + ", i32 0, i32 0), align 4\n\n"
    end
  end
#----------------------------------------- Write LLVM file
  llvmCode += llvmSeparatorLine ()
  [llvmCode writeToFileWhenDifferentContents !sourceDirectory + "/src.ll" ?*]
#----------------------------------------- Write assembler file
  asCode += asSeparatorLine ()
  [asCode writeToFileWhenDifferentContents !sourceDirectory + "/src.s" ?*]
#----------------------------------------- Write C file
  let cCode = getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName.string + "/target.c"
  )
  let s1 = [cCode stringByReplacingStringByString !"!TASKCOUNT!" ![[inIntermediateCodeStruct.mTaskMapIR count] string]]
  let s2 = [s1 stringByReplacingStringByString !"!GUARDCOUNT!" ![inIntermediateCodeStruct.mMaxBranchOfOnInstructions string]]
  let s3 = [s2 stringByReplacingStringByString !"!FUNC!" !llvmNameForFunction (!"")]
  [s3 writeToFileWhenDifferentContents !sourceDirectory + "/src.c" ?*]
#----------------------------------------- Perform compilation
  if (@uint.errorCount == 0) then # && not [option plm_options.compileOnly value] then
    let script = if [option plm_options.performFlashing value] then "run" else "build" end
    let fullScript = "python " + inProductDirectory + "/" + script + ".py"
    @sint result = [fullScript system]
    if result != 0S then
      error inEndOfSourceFileLocation: "error during LLVM compilation or flashing"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc declareLLVMTypes ?let @unifiedTypeMap inTypeMap ?!@string ioLLVMcode {
  ioLLVMcode += llvmTitleComment (!"Types")
  for () in inTypeMap do
    switch kind 
    case boolean :
    case boolset :
    case enumeration (*) :
    case integer (* * * *) :
    case structure (* propertyList) :
      ioLLVMcode += "%$" + lkey + " = type {"
      for () in propertyList
        do ioLLVMcode += [mType llvmTypeName]
        between ioLLVMcode += ", "
      end
      ioLLVMcode += "}\n"
    case literalString : 
    case staticInteger : 
    case opaque (*) :
    end
  end
  ioLLVMcode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

