#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C O D E    G E N E R A T I O N                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

getter @literalStructureList literalValue -> @string result {
  result = "{"
  for (ls) in self do
    switch ls
    case unsignedInteger (@bigint value) :
      result += [value string]
    case signedInteger (@bigint value) :
      result += [value string]
    case string (* @string name) :
      result += name
    case structure (@literalStructureList valueList) :
      result += [valueList literalValue]
    end
  between result += ", "
  end
  result += "}"
}

#----------------------------------------------------------------------------------------------------------------------*

getter @variableKindIR mangledName -> @string outResult {
  switch self
  case register (@lstring name *) :
    outResult = mangledNameForRegister (!name:name.string)
  case globalVariable (@lstring name) :
    outResult = mangledNameForGlobalVariable (!name:name.string)
  case localVariable (@lstring name) :
    outResult = mangledNameForLocalVariable (!name:name.string)
  case inArgument (@lstring name) :
    outResult = mangledNameForInArgument (!name:name.string)
  case inOutArgument (@lstring name) :
    outResult = mangledNameForInOutArgument (!name:name.string)
  case outArgument (@lstring name) :
    outResult = "* " + mangledNameForOutArgument (!name:name.string)
  case localConstant (@lstring name) :
    outResult = mangledNameForConstant (!name:name.string)
  case temporaryConstant (@uint idx) :
    outResult = mangledNameForTemporaryConstant (!idx:idx)
  case localAccess (@lstring access) :
    outResult = access.string
  case literalUnsignedInteger (@bigint value) :
    outResult = [value string]
  case literalSignedInteger (@bigint value) :
    outResult = [value string]
  case literalString (* @string name) :
    outResult = name
  case literalStructure (@literalStructureList s) :
    outResult = [s literalValue]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

getter @assignmentTargetIR mangledName -> @string outResult {
  switch self
  case register (@lstring name *) :
    outResult = mangledNameForRegister (!name:name.string)
  case globalVariable (@lstring name) :
    outResult = mangledNameForGlobalVariable (!name:name.string)
  case localVariable (@lstring name) :
    outResult = mangledNameForLocalVariable (!name:name.string)
  case inArgument (@lstring name) :
    outResult = mangledNameForInArgument (!name:name.string)
  case inOutArgument (@lstring name) :
    outResult = mangledNameForInOutArgument (!name:name.string)
  case outArgument (@lstring name) :
    outResult = "* " + mangledNameForOutArgument (!name:name.string)
  case localConstant (@lstring name) :
    outResult = mangledNameForConstant (!name:name.string)
  case temporaryConstant (@uint idx) :
    outResult = mangledNameForTemporaryConstant (!idx:idx)
  case localAccess (@lstring access) :
    outResult = access.string
  case literalStructure (@literalStructureList s) :
    outResult = [s literalValue]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

abstract class @abstractExpressionIR {
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractInstructionIR
#----------------------------------------------------------------------------------------------------------------------*

abstract class @abstractInstructionIR {
}

#----------------------------------------------------------------------------------------------------------------------*

abstract getter @abstractInstructionIR instructionCode -> @string outCode

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractInstructionIR llvmInstructionCode ?!@string ioCode

#----------------------------------------------------------------------------------------------------------------------*
#! @instructionListIR
#----------------------------------------------------------------------------------------------------------------------*

list @instructionListIR {
  @abstractInstructionIR mInstructionGeneration
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractTypeIR
#----------------------------------------------------------------------------------------------------------------------*

abstract getter @abstractTypeIR headerCodeGenerationForType -> @string outCode

#----------------------------------------------------------------------------------------------------------------------*
#! codeGeneration
#----------------------------------------------------------------------------------------------------------------------*

func %once separatorLine -> @string outResult {
  outResult  = "//------------------------------------------------------------------------"
  outResult += "---------------------------------------------*\n"
}

#----------------------------------------------------------------------------------------------------------------------*

func titleComment ?@string inTitle -> @string outTitle {
  outTitle  = separatorLine ()
  outTitle += "//   " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += separatorLine () + "\n"
}

#----------------------------------------------------------------------------------------------------------------------*

func %once llvmSeparatorLine -> @string outResult {
  outResult  = ";-------------------------------------------------------------------------"
  outResult += "---------------------------------------------*\n"
}

#----------------------------------------------------------------------------------------------------------------------*

func llvmTitleComment ?@string inTitle -> @string outTitle {
  outTitle  = llvmSeparatorLine ()
  outTitle += ";    " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += llvmSeparatorLine () + "\n"
}

#----------------------------------------------------------------------------------------------------------------------*

proc codeGeneration
  ?currentDir:let @string inCurrentDirectory
  ?outputFile:let @string inSourceFileName
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?target:let @lstring inTargetName
  ?exceptionCodeType:let @unifiedTypeMap-proxy inExceptionCodeType
  ?exceptionLineType:let @unifiedTypeMap-proxy inExceptionLineType
{
  let homeDir = @string.homeDirectory + "/plm-products/"
#--- Create source directory (if does not exist)
  let productDirectory = homeDir + [[inSourceFileName stringByDeletingPathExtension] stringByReplacingStringByString !"/" !"+"]
  let sourceDirectory = productDirectory + "/sources"
  [sourceDirectory makeDirectory] ;
#--- Generate target files
  generateTarget (
    !currentDir:inCurrentDirectory
    !productDirectory:productDirectory
    !targetName:inTargetName
  )
#--- Generate C file
  generateCfile (
    !currentDir:inCurrentDirectory
    !productDir:productDirectory
    !eof:inEndOfSourceFileLocation
    !intermediateCode:inIntermediateCodeStruct
    !target:inTargetName
    !exceptionCodeType:inExceptionCodeType
    !exceptionLineType:inExceptionLineType
  )
#--- Generate LLVM file
  generateLLVMfile (
    !currentDir:inCurrentDirectory
    !productDir:productDirectory
    !eof:inEndOfSourceFileLocation
    !intermediateCode:inIntermediateCodeStruct
    !target:inTargetName
    !exceptionCodeType:inExceptionCodeType
    !exceptionLineType:inExceptionLineType
  )
}

#----------------------------------------------------------------------------------------------------------------------*

proc generateCfile
  ?currentDir:let @string inCurrentDirectory
  ?productDir:let @string inProductDirectory
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?target:let @lstring inTargetName
  ?exceptionCodeType:let @unifiedTypeMap-proxy inExceptionCodeType
  ?exceptionLineType:let @unifiedTypeMap-proxy inExceptionLineType
{
  let sourceDirectory = inProductDirectory + "/sources"
  var code = ""
  code += "#include <stdint.h>\n"
  code += "#include <stdbool.h>\n"
  code += "#include <stddef.h>\n\n"
  for @typeMapIR-element type in inIntermediateCodeStruct.mTypeMapIR do
    code += [type.mType headerCodeGenerationForType]
  end
  code += titleComment (!"Boot")
  code += "static void boot (void) ;\n\n"
  code += titleComment (!"Init")
  code += "static void init (void) ;\n\n"
  if not [option plm_options.noExceptionGeneration value] then
    code += titleComment (!"Exception")
    code += "static void raise_exception_internal (const " + mangledNameForType (!name:[inExceptionCodeType key]) + " inCode,\n"
    code += "                                      const char * inSourceFile,\n"
    code += "                                      const " + mangledNameForType (!name:[inExceptionLineType key]) + " inSourceLine) ;\n\n"
  end
  code += titleComment (!"Static Strings")
  for () in inIntermediateCodeStruct.mGlobalLiteralStringMap do
    code += "static const char * " + mLiteralStringCname + " = " + [lkey.string utf8Representation] + " ;\n"
  end
  code += "\n"
  for register in inIntermediateCodeStruct.mRegisterMap do
    code += [register headerCodeGenerationForRegister]
  end
  for globalConstant in inIntermediateCodeStruct.mGlobalConstantMap do
    code += [globalConstant headerCodeGeneration]
  end
  for globalVariable in inIntermediateCodeStruct.mGlobalVariableMap do
    code += [globalVariable implementationCodeGeneration]
  end
  for function in inIntermediateCodeStruct.mFunctionMapIR do
    code += [function headerCodeGeneration]
  end
  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
    code += [procedure headerCodeGeneration]
  end
#--- Include target specific files
  code += titleComment (!"Target specific code")
  let targetSpecificFileContents = getTargetTextFile (
     !currentDir:inCurrentDirectory
     !from:inTargetName.string + "/target.c"
  )
  code += targetSpecificFileContents + "\n"
  if not [option plm_options.noExceptionGeneration value] then
    let targetExceptionSpecificFileContents = getTargetTextFile (
       !currentDir:inCurrentDirectory
       !from:inTargetName.string + "/target-exception.c"
    )
    code += titleComment (!"Target exception specific code")
    code += targetExceptionSpecificFileContents + "\n"
  end
#--- Boot
  code += titleComment (!"Boot")
  code += "static void boot (void) {\n"
  for boot in inIntermediateCodeStruct.mBootList do
    code += [boot.mInstructionListIR instructionListCode]
  end
  code += "}\n\n"
#--- Init
  code += titleComment (!"Init")
  code += "static void init (void) {\n"
  for init in inIntermediateCodeStruct.mInitList do
    code += [init.mInstructionListIR instructionListCode]
  end
  code += "}\n\n"
  if not [option plm_options.noExceptionGeneration value] then
    code += titleComment (!"Raise Exception internal")
    code += "static void raise_exception_internal (const int32_t in_CODE,\n"
    code += "                                      const char * in_FILE,\n"
    code += "                                      const uint32_t in_LINE) {\n"
    code += [inIntermediateCodeStruct.mExceptionSetupInstructionListIR instructionListCode]
    [!?code incIndentation !2]
    code += "while (1) {\n"
    code += [inIntermediateCodeStruct.mExceptionLoopInstructionListIR instructionListCode]
    code += "}\n"
    [!?code decIndentation !2]
    code += "}\n\n"
  end
  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
    code += [procedure implementationCodeGeneration]
  end
  for function in inIntermediateCodeStruct.mFunctionMapIR do
    code += [function implementationCodeGeneration]
  end
  code += separatorLine ()
  [code writeToFileWhenDifferentContents !sourceDirectory + "/plm.c" ?*]
#--- Perform C compilation
  if (@uint.errorCount == 0) && not [option plm_options.compileOnly value] then
    let script = if [option plm_options.performFlashing value] then "run" else "build" end
    let fullScript = "python " + inProductDirectory + "/" + script + ".py"
    @sint result = [fullScript system]
    if result != 0S then
      error inEndOfSourceFileLocation: "error during C compilation or flashing"
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc generateLLVMfile
  ?currentDir:let @string inCurrentDirectory
  ?productDir:let @string inProductDirectory
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?target:let @lstring inTargetName
  ?exceptionCodeType:let @unifiedTypeMap-proxy unused inExceptionCodeType
  ?exceptionLineType:let @unifiedTypeMap-proxy unused inExceptionLineType
{
  let sourceDirectory = inProductDirectory + "/sources"
  var code = ""
#--- Include target specific files
  code += llvmTitleComment (!"Target specific code")
  let targetSpecificFileContents = getTargetTextFile (
     !currentDir:inCurrentDirectory
     !from:inTargetName.string + "/target.ll"
  )
  code += targetSpecificFileContents + "\n"
#  if not [option plm_options.noExceptionGeneration value] then
#    let targetExceptionSpecificFileContents = getTargetTextFile (
#       !currentDir:inCurrentDirectory
#       !from:inTargetName.string + "/target-exception.c"
#    )
#    code += llvmTitleComment (!"Target exception specific code")
#    code += targetExceptionSpecificFileContents + "\n"
#  end
#  for @typeMapIR-element type in inIntermediateCodeStruct.mTypeMapIR do
#    code += [type.mType headerCodeGenerationForType]
#  end
#  code += titleComment (!"Boot")
#  code += "static void boot (void) ;\n\n"
#  code += titleComment (!"Init")
#  code += "static void init (void) ;\n\n"
#  if not [option plm_options.noExceptionGeneration value] then
#    code += titleComment (!"Exception")
#    code += "static void raise_exception_internal (const " + mangledNameForType (!name:[inExceptionCodeType key]) + " inCode,\n"
#    code += "                                      const char * inSourceFile,\n"
#    code += "                                      const " + mangledNameForType (!name:[inExceptionLineType key]) + " inSourceLine) ;\n\n"
#  end
  code += llvmTitleComment (!"Static Strings")
  for () in inIntermediateCodeStruct.mGlobalLiteralStringMap do
    code += "static const char * " + mLiteralStringCname + " = " + [lkey.string utf8Representation] + " ;\n"
  end
  code += "\n"
#  for register in inIntermediateCodeStruct.mRegisterMap do
#    code += [register headerCodeGenerationForRegister]
#  end
  for globalConstant in inIntermediateCodeStruct.mGlobalConstantMap do
    code += [globalConstant headerCodeGeneration]
  end
  for globalVariable in inIntermediateCodeStruct.mGlobalVariableMap do
    code += [globalVariable generateLLVM]
  end
#  for function in inIntermediateCodeStruct.mFunctionMapIR do
#    code += [function headerCodeGeneration]
#  end
#  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
#    code += [procedure headerCodeGeneration]
#  end
#----------------------------------------- Boot
  code += llvmTitleComment (!"Boot")
  code += "define internal void @boot () nounwind {\n"
  for boot in inIntermediateCodeStruct.mBootList do
    [boot.mInstructionListIR instructionListLLVMCode !?code]
  end
  code += ";---\n"
  code += "  ret void\n"
  code += "}\n\n"
#----------------------------------------- Init
  code += llvmTitleComment (!"Init")
  code += "define internal void @init () nounwind {\n"
  for init in inIntermediateCodeStruct.mInitList do
    [init.mInstructionListIR instructionListLLVMCode !?code]
  end
  code += ";---\n"
  code += "  ret void\n"
  code += "}\n\n"
#----------------------------------------- Exception
  if not [option plm_options.noExceptionGeneration value] then
    code += llvmTitleComment (!"Raise Exception internal")
    code += "static void raise_exception_internal (const int32_t in_CODE,\n"
    code += "                                      const char * in_FILE,\n"
    code += "                                      const uint32_t in_LINE) {\n"
    [inIntermediateCodeStruct.mExceptionSetupInstructionListIR instructionListLLVMCode !?code]
    [!?code incIndentation !2]
    code += "while (1) {\n"
    [inIntermediateCodeStruct.mExceptionLoopInstructionListIR instructionListLLVMCode !?code]
    code += "}\n"
    [!?code decIndentation !2]
    code += "}\n\n"
  end
#----------------------------------------- Procedures
  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
    code += [procedure llvmCodeGeneration]
  end
#----------------------------------------- Functions
  for function in inIntermediateCodeStruct.mFunctionMapIR do
    code += [function implementationCodeGeneration]
  end
#----------------------------------------- Write LLVM file
  code += separatorLine ()
  [code writeToFileWhenDifferentContents !sourceDirectory + "/plm.ll" ?*]
#----------------------------------------- Perform LLVM compilation
  if (@uint.errorCount == 0) && not [option plm_options.compileOnly value] then
    let script = if [option plm_options.performFlashing value] then "run" else "build" end
    let fullScript = "python " + inProductDirectory + "/" + script + ".py"
    @sint result = [fullScript system]
    if result != 0S then
      error inEndOfSourceFileLocation: "error during LLVM compilation or flashing"
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

