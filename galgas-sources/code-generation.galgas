#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#                                                                                                                       
#    C O D E    G E N E R A T I O N                                                                                     
#                                                                                                                       
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#! @generationAdds
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

struct @generationAdds {
  @uint mUniqueIndex
  @stringset mExternFunctionDeclarationSet
  @staticStringMap mStaticStringMap
  @bool mUsesGuards
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#! @abstractInstructionIR
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

abstract class @abstractInstructionIR {
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

abstract method @abstractInstructionIR llvmInstructionCode
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#! @abstractGenerationIR
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

abstract class @abstractGenerationIR {
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

abstract method @abstractGenerationIR generateLLVMcode ?!@string ioLLVMcode  ?!@generationAdds ioGenerationAdds

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

list @generationListIR {
  @abstractGenerationIR mGeneration
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#! @instructionListIR
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

list @instructionListIR {
  @abstractInstructionIR mInstructionGeneration
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#! codeGeneration
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

func %once llvmSeparatorLine -> @string {
  result  = ";-------------------------------------------------------------------------"
  result += "---------------------------------------------*\n"
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

func llvmTitleComment ?let @string inTitle -> @string outTitle {
  outTitle  = llvmSeparatorLine ()
  outTitle += ";    " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += llvmSeparatorLine () + "\n"
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

func %once asSeparatorLine -> @string {
  result  = "@-------------------------------------------------------------------------"
  result += "---------------------------------------------*\n"
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

func asTitleComment ?let @string inTitle -> @string outTitle {
  outTitle  = asSeparatorLine ()
  outTitle += "@    " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += asSeparatorLine () + "\n"
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

proc codeGeneration
  ?currentDir:let @string inCurrentDirectory
  ?outputFile:let @string inSourceFileName
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?typeMap:let @unifiedTypeMap inTypeMap
  ?target:let @lstring inTargetName
  ?panicCodeType:let @unifiedTypeMap-proxy inPanicCodeType
  ?panicLineType:let @unifiedTypeMap-proxy inPanicLineType
  ?interrupts:let @availableInterruptMap inAvailableInterruptMap
  ?staticlistValues:let @staticListInitializationMap inStaticListValueMap
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
  ?targetParameters:let @targetParameters inTargetParameters
{
  let homeDir = @string.homeDirectory + "/plm-products/"
#--- Create source directory (if does not exist)
  let productDirectory = homeDir
    + if [option plm_options.noPanicGeneration value] then "no-panic" else "" end
    + [[inSourceFileName stringByDeletingPathExtension] stringByReplacingStringByString !"/" !"+"]
  let sourceDirectory = productDirectory + "/sources"
  [sourceDirectory makeDirectory] ;
#--- Generate target files
  generateTarget (
    !currentDir:inCurrentDirectory
    !productDirectory:productDirectory
    !targetName:inTargetName
    !targetParameters:inIntermediateCodeStruct.mTargetParameters
  )
#--- Generate code files (LLVM, assembly)
  generateCodeFiles (
    !currentDir:inCurrentDirectory
    !productDir:productDirectory
    !eof:inEndOfSourceFileLocation
    !intermediateCode:inIntermediateCodeStruct
    !typeMap:inTypeMap
    !target:inTargetName
    !panicCodeType:inPanicCodeType
    !panicLineType:inPanicLineType
    !interrupts:inAvailableInterruptMap
    !staticlistValues:inStaticListValueMap
    !sourceFileSet:inSourceFileAbsolutePathSet
    !targetParameters:inTargetParameters
  )
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

struct @generationContext {
  @PLMType mPanicCodeLLVMType
  @PLMType mPanicLineLLVMType
  @string mNopInstructionInLLVM
  @globalTaskVariableList mGlobalTaskVariableList
  @availableInterruptMap mAvailableInterruptMap
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

private proc generateCodeFiles
  ?currentDir:let @string inCurrentDirectory
  ?productDir:let @string inProductDirectory
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?typeMap:let @unifiedTypeMap inTypeMap
  ?target:let @lstring inTargetName
  ?panicCodeType:let @unifiedTypeMap-proxy inPanicCodeType
  ?panicLineType:let @unifiedTypeMap-proxy inPanicLineType
  ?interrupts:let @availableInterruptMap inAvailableInterruptMap
  ?staticlistValues:let @staticListInitializationMap inStaticListValueMap
  ?sourceFileSet:let @stringset inSourceFileAbsolutePathSet
  ?targetParameters:let @targetParameters inTargetParameters
{
  @generationAdds generationAdds = .default
  generationAdds.mStaticStringMap = inIntermediateCodeStruct.mStaticStringMap
  let @generationContext generationContext = .new {
    ![inPanicCodeType type]
    ![inPanicLineType type]
    !inTargetParameters.mNopInstructionStringInLLVM.string
    !inIntermediateCodeStruct.mGlobalTaskVariableList
    !inAvailableInterruptMap
  }
  let sourceDirectory = inProductDirectory + "/sources"
#----------------------------------------- Include assembler specific file
  var asCode = asTitleComment (!"Target specific code")
  var asFileContents = ""
  for (relativePath) in inTargetParameters.m_S_definitionFiles do
    asFileContents += getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName.string + "/" + relativePath
    )
  end
  let x = [asFileContents stringByReplacingStringByString !"!FUNC!" !llvmNameForFunction (!".")]
  asCode += [x stringByReplacingStringByString !"!ISR!" !llvmNameForSectionOrSafeInterrupt (!"")]
  asCode += "\n"
#----------------------------------------- Include LLVM specific file
  var llvmCode = llvmTitleComment (!"Target specific code")
  var targetLLVMcode = ""
  for (relativePath) in inTargetParameters.m_LL_definitionFiles do
    targetLLVMcode += getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName.string + "/" + relativePath
    )
  end
  llvmCode += [targetLLVMcode stringByReplacingStringByString !"!FUNC!" !llvmNameForFunction (!".")]
  llvmCode += "\n"
#----------------------------------------- Structure types declaration
  declareLLVMTypes (!inTypeMap !?llvmCode)
#----------------------------------------- Static array type declaration
  [inStaticListValueMap generateLLVMForStaticLists !inIntermediateCodeStruct.mStaticArrayMapForIntermediate !?llvmCode]
#----------------------------------------- Global sync instances
  for globalSyncInstance in inIntermediateCodeStruct.mGlobalSyncInstanceMap
    before llvmCode += llvmTitleComment (!"Global synchronization tool instances")
    do [globalSyncInstance generateLLVM !?llvmCode]
    after llvmCode += "\n"
  end
#----------------------------------------- Modules
  for driver in inIntermediateCodeStruct.mDriverList
    before llvmCode += llvmTitleComment (!"Drivers")
    do [driver generateLLVM !?llvmCode]
    after llvmCode += "\n"
  end
#----------------------------------------- Boot
  [inIntermediateCodeStruct.mBootList generateCode !?llvmCode !generationContext !?generationAdds]
#----------------------------------------- Enumeration uint() methods
  for (generation) in inIntermediateCodeStruct.mGenerationListIR do
    [generation generateLLVMcode !?llvmCode !?generationAdds]
  end
#----------------------------------------- Init
  [inIntermediateCodeStruct.mInitList generateLLVMinitCode
    !?llvmCode
    !inIntermediateCodeStruct.mRoutineMapIR
    !generationContext
    !?generationAdds
  ]
#----------------------------------------- Routines
  [inIntermediateCodeStruct.mRoutineMapIR llvmCodeGeneration !?llvmCode !?asCode !generationContext !?generationAdds]
#----------------------------------------- Interrupts
  let undefinedInterruptString = getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName.string + "/" + inTargetParameters.mUndefinedInterruptHandler
  )
  let XTRInterruptHandlerString = getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName.string + "/" + inTargetParameters.mXtrInterruptHandler
  )
  [inIntermediateCodeStruct.mInterruptMapIR interruptCodeGeneration
    !?llvmCode
    !?asCode
    !undefinedInterruptString
    !XTRInterruptHandlerString
    !generationContext
    !?generationAdds
  ]
#----------------------------------------- Extern procedures
  [inIntermediateCodeStruct.mExternProcedureMapIR llvmPrototypeGeneration !?llvmCode]
  @2stringlist primitiveAndServiceList = {}
#----------------------------------------- Use guards ?
  if generationAdds.mUsesGuards then
    let waitForGuardChange = waitForGuardChangeFunctionName ()
    primitiveAndServiceList +=
      !llvmNameForServiceCall (!waitForGuardChange)
      !llvmNameForServiceImplementation (!waitForGuardChange)
    generationAdds.mExternFunctionDeclarationSet +=
      !"declare i1 @" + llvmNameForServiceCall (!waitForGuardChange) + " ()"
  end
#----------------------------------------- SVC
  @sectionIRlist sectionIRlist = {}
  [inIntermediateCodeStruct.mRoutineMapIR svcCodeGeneration
    !?llvmCode
    !?primitiveAndServiceList
    !?sectionIRlist
  ]
#----------------------------------------- Guards
  [inIntermediateCodeStruct.mGuardMapIR guardCodeGeneration
    !?llvmCode
    !?primitiveAndServiceList
    !generationContext
    !?generationAdds
  ]
#----------------------------------------- tasks
  [inIntermediateCodeStruct.mTaskMapIR generateCode
    !?llvmCode
    !generationContext
    !?generationAdds
    !?primitiveAndServiceList
  ]
#----------------------------------------- Primitive, service dispatcher
  generatePrimitiveAndServiceDispatcher (
    !inCurrentDirectory
    !inTargetName.string
    !?asCode
    !primitiveAndServiceList
    !targetParameters:inTargetParameters
  )
#----------------------------------------- Section, safe dispatcher
  generateSectionAndSafeDispatcher (
    !inCurrentDirectory
    !inTargetName.string
    !targetParameters:inTargetParameters
    !?asCode
    !?llvmCode
    !sectionIRlist
  )
#----------------------------------------- Panic
  generatePanicCode (
    !? llvmCode
    !currentDir: inCurrentDirectory
    !sourceFileSet: inSourceFileAbsolutePathSet
    !targetParameters: inTargetParameters
    !targetName: inTargetName
    !generationContext: generationContext
    !?generationAdds: generationAdds
    !setup: inIntermediateCodeStruct.mPanicSetupInstructionListIR
    !loop: inIntermediateCodeStruct.mPanicLoopInstructionListIR
  )
#----------------------------------------- Copy routines
  let keyList = [inTypeMap allKeyList]
  llvmCode += llvmTitleComment (!"PLM Copy Functions")
  llvmCode += "declare void @copy.byte.array (i8* %dest, i8* %src, i32 %byteCount)\n\n"
  llvmCode += llvmSeparatorLine () + "\n"
  llvmCode += "declare void @copy.word.array (i32* %dest, i32* %src, i32 %byteCount)\n\n"
  for (key) in keyList do
    [inTypeMap searchKey !lkey:key ?type:let type ?index:*]
    [type generateCopyRoutine !?llvmCode]
  end
#----------------------------------------- Intrinsics
  if [generationAdds.mExternFunctionDeclarationSet count] > 0 then
    llvmCode += llvmTitleComment (!"LLVM extern functions")
    for (s) in generationAdds.mExternFunctionDeclarationSet do
      llvmCode += s + "\n"
    end
    llvmCode += "\n"
  end
#----------------------------------------- Static Strings
  if [generationAdds.mStaticStringMap count] > 0 then
    llvmCode += llvmTitleComment (!"Static strings")
    for () in generationAdds.mStaticStringMap do
      let lgStr = [[lkey.string utf8Length] + 1 string]
      llvmCode += literalCharacterArrayName (!mIndex) + " = private unnamed_addr constant ["
      llvmCode += lgStr + " x i8] c\"" + lkey.string + "\\00\", align 1\n"
      llvmCode += literalStringName (!mIndex) + " = private constant i8* getelementptr inbounds (["
      llvmCode += lgStr + " x i8], [" + lgStr + " x i8]* "
      llvmCode += literalCharacterArrayName (!mIndex) + ", i32 0, i32 0), align 4\n\n"
    end
  end
#----------------------------------------- Write LLVM file
  llvmCode += llvmSeparatorLine ()
  [llvmCode writeToFileWhenDifferentContents !sourceDirectory + "/src.ll" ?*]
#----------------------------------------- Write assembler file
  asCode += asSeparatorLine ()
  [asCode writeToFileWhenDifferentContents !sourceDirectory + "/src.s" ?*]
#----------------------------------------- Write C file
  var cCode = ""
  for (relativePath) in inTargetParameters.m_C_definitionFiles do
    cCode += getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName.string + "/" + relativePath
    )
  end
  let s1 = [cCode stringByReplacingStringByString !"!TASKCOUNT!" ![[inIntermediateCodeStruct.mTaskMapIR count] string]]
  let s2 = [s1 stringByReplacingStringByString !"!GUARDCOUNT!" ![inIntermediateCodeStruct.mMaxBranchOfOnInstructions string]]
  let s3 = [s2 stringByReplacingStringByString !"!FUNC!" !llvmNameForFunction (!"")]
  let s4 = [s3 stringByReplacingStringByString !"!SERVICEIMPLEMENTATION!" !llvmNameForServiceImplementation (!"")]
  let s5 = [s4 stringByReplacingStringByString !"!SERVICECALL!" !llvmNameForServiceCall (!"")]
  [s5 writeToFileWhenDifferentContents !sourceDirectory + "/src.c" ?*]
#----------------------------------------- Write JSON file with stack features
  var json = "{\n"
#--- System stack size
  json += "  \"system-stack-size\" : " + inIntermediateCodeStruct.mTargetParameters.mSystemStackSize.bigint + ",\n"
  json += "  \"stacked-register-size-on-user-stack\" : "
       + inIntermediateCodeStruct.mTargetParameters.mStackedUserRegisterOnInterruptByteSize.bigint + ",\n"
  json += "  \"service-stack-needs\" : " + inIntermediateCodeStruct.mTargetParameters.mServicePushedRegisterByteSize.bigint + ",\n"
  json += "  \"section-stack-needs\" : " + [inIntermediateCodeStruct.mTargetParameters.mSectionImplementation sectionStackByteSize] + ",\n"
#--- Tasks
  json += "  \"tasks\" : {"
  for task in inIntermediateCodeStruct.mTaskMapIR
    do json += "\n    \"" + [task.lkey assemblerRepresentation] + "\" : " + task.mStackSize
    between json += ","
  end
  json += "\n"
  json += "  },\n"
#--- Services
  json += "  \"services\" : ["
  for (* serviceImplementation) in primitiveAndServiceList
    do json += "\n    \"" + serviceImplementation + "\""
    between json += ","
    after json += "\n"
  end
  json += "  ],\n"
#--- sections
  json += "  \"sections\" : ["
  for (* sectionImplementation * * *) in sectionIRlist
    do json += "\n    \"" + sectionImplementation + "\""
    between json += ","
    after json += "\n"
  end
  json += "  ],\n"
#--- isr
  json += "  \"isr\" : ["
  var first = true
  for (interruptName 4* mMode) in inIntermediateCodeStruct.mInterruptMapIR do
    if first then
      first = false
    else
      json += ","
    end
    let interruptImplementationName = if mMode == .serviceMode then
      llvmNameForServiceInterrupt (!interruptName).string
    else
      llvmNameForSectionOrSafeInterrupt (!interruptName.string)
    end
    json += "\n    \"" + interruptImplementationName + "\""
  end
  if not [option plm_options.noPanicGeneration value] then
    for (lkey panicCode) in inAvailableInterruptMap do
      if not [inIntermediateCodeStruct.mInterruptMapIR hasKey !lkey.string] then
        switch panicCode
        case noCode :
        case code (*) :
          if first then
            first = false
          else
            json += ","
          end
          json += "\n    \"" + llvmNameForSectionOrSafeInterrupt (!lkey.string) + "\""
        end
      end
    end
  end
  json += "\n  ]\n"
#--- Write file
  json += "}\n"
  [json writeToFileWhenDifferentContents !sourceDirectory + "/provided-stacks.json" ?*]
#----------------------------------------- Run compilation script
  if (@uint.errorCount == 0) then
    let script = if [option plm_options.performFlashing value] then "run" else "build" end
    let fullScript = "python " + inProductDirectory + "/" + script + ".py"
    @sint result = [fullScript system]
    if result != 0S then
      error inEndOfSourceFileLocation: "error during LLVM compilation or flashing"
    end
  end
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

sortedlist @orderedTypeList {
  @PLMType mType
  @uint mIndex
}{
  mIndex <
}

#Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·

proc declareLLVMTypes ?let @unifiedTypeMap inTypeMap ?!@string ioLLVMcode {
#--- Build ordered list
  @orderedTypeList orderedTypeList = {}
  for (* type index) in inTypeMap do
    orderedTypeList += !type !index
  end
#--- Generate LLVM type declarations
# Unsing forward type is allowed for pointers
  ioLLVMcode += llvmTitleComment (!"Types (structures and static arraies)")
  for (type *) in orderedTypeList do
    switch type.kind
    case void :
    case boolean :
    case enumeration (*) :
    case integer (* * * *) :
    case structure (propertyList) :
      ioLLVMcode += [type llvmTypeName] + " = type {"
      for () in propertyList
        do ioLLVMcode += [mType llvmTypeName]
        between ioLLVMcode += ", "
      end
      ioLLVMcode += "}\n"
    case syncTool (propertyList) :
      ioLLVMcode += [type llvmTypeName] + " = type {"
      for () in propertyList
        do ioLLVMcode += [mType llvmTypeName]
        between ioLLVMcode += ", "
      end
      ioLLVMcode += "}\n"
    case literalString : 
    case staticInteger : 
    case opaque (*) :
    case arrayType (elementType arraySize) :
      ioLLVMcode += [type llvmTypeName] + " = type [" + arraySize + " x " + [elementType llvmTypeName] + "]\n"
    case function (*) :
    case pointer (unused pointee) :
    end
  end
  ioLLVMcode += "\n"
}

#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

