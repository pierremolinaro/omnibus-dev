#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C O D E    G E N E R A T I O N                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

getter @objectInMemoryIR mangledName -> @string outResult {
  switch self
  case register (* @lstring name *) :
    outResult = mangledNameForRegister (!name:name.string)
  case globalVariable (* @string name *) :
    outResult = mangledNameForGlobalVariable (!name)
  case localValue (* @string name) :
    outResult = mangledNameForLocalVariable (!name)
  case globalConstant (* @string name) :
    outResult = mangledNameForGlobalVariable (!name)
  case localAccess (@lstring access) :
    outResult = access.string
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractExpressionIR
#----------------------------------------------------------------------------------------------------------------------*

abstract class @abstractExpressionIR {
}

#----------------------------------------------------------------------------------------------------------------------*
#! @generationAdds
#----------------------------------------------------------------------------------------------------------------------*

struct @generationAdds {
  @stringset mIntrinsicsDeclarationSet
  @staticStringMap mStaticStringMap
}

#----------------------------------------------------------------------------------------------------------------------*
#! @abstractInstructionIR
#----------------------------------------------------------------------------------------------------------------------*

abstract class @abstractInstructionIR {
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractInstructionIR llvmInstructionCode
  ?!@string ioCode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds

#----------------------------------------------------------------------------------------------------------------------*
#! @instructionListIR
#----------------------------------------------------------------------------------------------------------------------*

list @instructionListIR {
  @abstractInstructionIR mInstructionGeneration
}

#----------------------------------------------------------------------------------------------------------------------*
#! codeGeneration
#----------------------------------------------------------------------------------------------------------------------*

func %once llvmSeparatorLine -> @string outResult {
  outResult  = ";-------------------------------------------------------------------------"
  outResult += "---------------------------------------------*\n"
}

#----------------------------------------------------------------------------------------------------------------------*

func llvmTitleComment ?@string inTitle -> @string outTitle {
  outTitle  = llvmSeparatorLine ()
  outTitle += ";    " + [inTitle stringByRightPadding !114!' '] + "*\n"
  outTitle += llvmSeparatorLine () + "\n"
}

#----------------------------------------------------------------------------------------------------------------------*

proc codeGeneration
  ?currentDir:let @string inCurrentDirectory
  ?outputFile:let @string inSourceFileName
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?typeMap:let @unifiedTypeMap inTypeMap
  ?target:let @lstring inTargetName
  ?exceptionCodeType:let @unifiedTypeMap-proxy inExceptionCodeType
  ?exceptionLineType:let @unifiedTypeMap-proxy inExceptionLineType
{
  let homeDir = @string.homeDirectory + "/plm-products/"
#--- Create source directory (if does not exist)
  let productDirectory = homeDir + [[inSourceFileName stringByDeletingPathExtension] stringByReplacingStringByString !"/" !"+"]
  let sourceDirectory = productDirectory + "/sources"
  [sourceDirectory makeDirectory] ;
#--- Generate target files
  generateTarget (
    !currentDir:inCurrentDirectory
    !productDirectory:productDirectory
    !targetName:inTargetName
  )
#--- Generate LLVM file
  generateLLVMfile (
    !currentDir:inCurrentDirectory
    !productDir:productDirectory
    !eof:inEndOfSourceFileLocation
    !intermediateCode:inIntermediateCodeStruct
    !typeMap:inTypeMap
    !target:inTargetName
    !exceptionCodeType:inExceptionCodeType
    !exceptionLineType:inExceptionLineType
  )
}

#----------------------------------------------------------------------------------------------------------------------*

struct @generationContext {
  @string mExceptionCodeLLVMType
  @string mExceptionLineLLVMType
}

#----------------------------------------------------------------------------------------------------------------------*

proc generateLLVMfile
  ?currentDir:let @string inCurrentDirectory
  ?productDir:let @string inProductDirectory
  ?eof:let @location inEndOfSourceFileLocation
  ?intermediateCode:let @intermediateCodeStruct inIntermediateCodeStruct
  ?typeMap:let @unifiedTypeMap inTypeMap
  ?target:let @lstring inTargetName
  ?exceptionCodeType:let @unifiedTypeMap-proxy inExceptionCodeType
  ?exceptionLineType:let @unifiedTypeMap-proxy inExceptionLineType
{
  let @generationContext generationContext = .new {
    ![inExceptionCodeType llvmTypeName]
    ![inExceptionLineType llvmTypeName]
  }
  let sourceDirectory = inProductDirectory + "/sources"
  var code = ""
#----------------------------------------- Include target specific file
  code += llvmTitleComment (!"Target specific code")
  let targetSpecificFileContents = getTargetTextFile (
     !currentDir:inCurrentDirectory
     !from:inTargetName.string + "/target.ll"
  )
  code += targetSpecificFileContents
  code += "\n"
#----------------------------------------- Structure types
  code += llvmTitleComment (!"Structure types")
  declareLLVMstructures (!inTypeMap !?code)
  code += "\n"
#----------------------------------------- Global constants
  for globalConstant in inIntermediateCodeStruct.mGlobalConstantMap
    before code += llvmTitleComment (!"Global constants")
    do [globalConstant generateLLVM !?code]
    after code += "\n"
  end
#----------------------------------------- Global variables
  for globalVariable in inIntermediateCodeStruct.mGlobalVariableMap
    before code += llvmTitleComment (!"Global variables")
    do [globalVariable generateLLVM !?code]
    after code += "\n"
  end
#----------------------------------------- Boot
  @generationAdds generationAdds = .default
  generationAdds.mStaticStringMap = inIntermediateCodeStruct.mStaticStringMap
  code += llvmTitleComment (!"Boot")
  code += "define internal void @boot () nounwind {\n"
  for boot in inIntermediateCodeStruct.mBootList do
    [boot.mInstructionListIR instructionListLLVMCode !?code !generationContext !?generationAdds]
  end
  code += ";---\n"
  code += "  ret void\n"
  code += "}\n\n"
#----------------------------------------- Init
  code += llvmTitleComment (!"Init")
  code += "define internal void @init () nounwind {\n"
  for init in inIntermediateCodeStruct.mInitList do
    [init.mInstructionListIR instructionListLLVMCode !?code !generationContext !?generationAdds]
  end
  code += ";---\n"
  code += "  ret void\n"
  code += "}\n\n"
#----------------------------------------- Procedures
  for procedure in inIntermediateCodeStruct.mProcedureMapIR do
    [procedure llvmCodeGeneration !?code !generationContext !?generationAdds]
  end
#----------------------------------------- Functions
  for function in inIntermediateCodeStruct.mFunctionMapIR do
    [function implementationCodeGeneration !?code !generationContext !?generationAdds]
  end
#----------------------------------------- Exception
  if not [option plm_options.noExceptionGeneration value] then
    code += getTargetTextFile (
       !currentDir:inCurrentDirectory
       !from:inTargetName.string + "/target-exception.ll"
    )
    code += llvmTitleComment (!"Raise Exception internal")
    code += "define internal void @raise_exception_internal ("
    code += generationContext.mExceptionCodeLLVMType + " %in.CODE, "
    code += "i8* %in.FILE, "
    code += generationContext.mExceptionLineLLVMType + " %in.LINE) nounwind noreturn {\n"
    code += "  %" + mangledNameForLocalVariable (!"CODE") + " = alloca " + generationContext.mExceptionCodeLLVMType + "\n"
    code += "  store " + generationContext.mExceptionCodeLLVMType + " %in.CODE, "
         + generationContext.mExceptionCodeLLVMType + "* %" + mangledNameForLocalVariable (!"CODE") + "\n"
    code += "  %" + mangledNameForLocalVariable (!"LINE") + " = alloca " + generationContext.mExceptionLineLLVMType + "\n"
    code += "  store " + generationContext.mExceptionLineLLVMType + " %in.LINE, "
         + generationContext.mExceptionLineLLVMType + "* %" + mangledNameForLocalVariable (!"LINE") + "\n"
    [inIntermediateCodeStruct.mExceptionSetupInstructionListIR instructionListLLVMCode
      !?code
      !generationContext
      !?generationAdds
    ]
    code += "  br label %exception.loop\n\n"
    code += "exception.loop:\n"
    [inIntermediateCodeStruct.mExceptionLoopInstructionListIR instructionListLLVMCode
      !?code
      !generationContext
      !?generationAdds
    ]
    code += "  br label %exception.loop\n"
    code += "}\n\n"
  end
#----------------------------------------- Intrinsics
  if [generationAdds.mIntrinsicsDeclarationSet count] > 0 then
    code += llvmTitleComment (!"LLVM intrinsics")
    for (s) in generationAdds.mIntrinsicsDeclarationSet do
      code += s + "\n"
    end
    code += "\n"
  end
#----------------------------------------- Static Strings
  if [generationAdds.mStaticStringMap count] > 0 then
    code += llvmTitleComment (!"Static strings")
    for () in generationAdds.mStaticStringMap do
      let lgStr = [[lkey.string length] + 1 string]
      code += literalCharacterArrayName (!mIndex) + " = private unnamed_addr constant ["
      code += lgStr + " x i8] c\""
      code += [lkey.string utf8RepresentationWithoutDelimiters]
      code += "\\00\", align 1\n"
      code += literalStringName (!mIndex) + " = private constant i8* getelementptr inbounds (["
      code += lgStr + " x i8], [" + lgStr + " x i8]* "
      code += literalCharacterArrayName (!mIndex) + ", i32 0, i32 0), align 4\n\n"
    end
  end
#----------------------------------------- Write LLVM file
  code += llvmSeparatorLine ()
  [code writeToFileWhenDifferentContents !sourceDirectory + "/source-plm.ll" ?*]
#----------------------------------------- Perform LLVM compilation
  if (@uint.errorCount == 0) && not [option plm_options.compileOnly value] then
    let script = if [option plm_options.performFlashing value] then "run" else "build" end
    let fullScript = "python " + inProductDirectory + "/" + script + ".py"
    @sint result = [fullScript system]
    if result != 0S then
      error inEndOfSourceFileLocation: "error during LLVM compilation or flashing"
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

