#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @mode mMode
  @bool mPublicFunction
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @routineFormalArgumentListAST mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#·······················································································································

enum @procFormalArgumentPassingMode {
  case input
  case output
  case inputOutput
}

#·······················································································································

list @routineFormalArgumentListAST {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#·······················································································································

getter @procFormalArgumentPassingMode formalPassingModeString -> @string {
  switch self
  case input : result = "?"
  case output : result = "!"
  case inputOutput : result = "?!"
  end
}

#·······················································································································

getter @procFormalArgumentPassingMode requiredActualPassingModeForSelector ?let @string inSelector -> @string {
  switch self
  case input : result = "!"
  case output : result = "?"
  case inputOutput : result = "!?"
  end
  if inSelector != "" then
    result += inSelector + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <function> ?!@ast ioAST ?!@functionDeclarationListAST ioProcListAST {
  #--- Public ?
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition>!?ioAST  ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioProcListAST +=
      !mode
      !public
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
  }

  #·····················································································································

  rule <mode> !@mode outMode {
    select
      outMode = .anyMode
    or
      $user$
      outMode = .userMode
    or
      $panic$
      outMode = .panicMode
    or
      $boot$
      outMode = .bootMode
    or
      $startup$
      outMode = .startupMode
    or
      $section$
      outMode = .sectionMode
    or
      $service$
      outMode = .serviceMode
    or
      $primitive$
      outMode = .primitiveMode
    or
      $guard$
      outMode = .guardMode
    end
  }

  #·····················································································································

  rule <function_header>
    ?!@ast ioAST
    !mode:@mode outMode
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@routineFormalArgumentListAST outProcFormalArgumentList
  {
  #---
    $func$
    <mode> ?outMode
    $identifier$ ?outProcName
    outAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments>  !?ioAST ?outProcFormalArgumentList
  }

  #·····················································································································

  rule <procedure_formal_arguments> ?!@ast ioAST !@routineFormalArgumentListAST outProcFormalArgumentList {
    outProcFormalArgumentList = {}
    $($
    repeat
    while
      $!selector:$ ?let selector
      $identifier$ ?let formalArgumentName
      <type_definition> !?ioAST  ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.output
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?!selector:$ ?let selector
      $identifier$ ?let formalArgumentName
      <type_definition> !?ioAST ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.inputOutput
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?selector:$ ?let selector
      $identifier$ ?let formalArgumentName
      <type_definition> !?ioAST  ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.input
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    if mFunctionReturnTypeName.string != "" then
      [!?ioGraph noteNode !mFunctionReturnTypeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST enterFunctionInContext 
  ?selfTypeName:let @string inSelfTypeName
  ?!context:@semanticContext ioContext
  ?!@declarationDecorationList ioDecoratedDeclarationList
{
  for function in self do
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !function.mFunctionFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !function.mFunctionReturnTypeName ?let returnTypeProxy]
  #--- Attributes
    var warnIfUnused = true
    var globalFunction = false
    var canMutateProperties = false
    var isSafe = false
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == exportedAttribute () then
        if globalFunction then
          error attribute : "duplicated @" + exportedAttribute () + " attribute"
        end
        globalFunction = true
      elsif attribute.string == mutatingAttribute () then
        if canMutateProperties then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        canMutateProperties = true
      elsif attribute.string == safeAttribute () then
        if isSafe then
          error attribute : "duplicated attribute" fixit { remove }
        else
          isSafe = true
        end
      else
        error attribute : "unknown attribute; available attributes are @"
          + noUnusedWarningAttribute () + ", @" + noUnusedWarningAttribute () + ", @" + exportedAttribute ()+ ", @" + safeAttribute ()
      end
    end
    let canAccessProperties = function.mMode != .userMode
  #--- Routine mangled name
    let routineMangledName = routineMangledNameFromAST (
      !inSelfTypeName 
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
    )
  #--- Enter in context
    [!?ioContext.mRoutineMapForContext insertRoutine # Raises a redefinition error
      !inSelfTypeName 
      !function.mFunctionName
      ![function.mFunctionFormalArgumentList routineSignature !function.mFunctionName]
      !routineMangledName
      !.new{
        !isPublic:function.mPublicFunction
        !exported:globalFunction
        !name:function.mFunctionName
        !routineKind:.function {!executionMode:function.mMode}
        !signature:signature
        !returnTypeProxy:returnTypeProxy
        !canAccessProperties:canAccessProperties
        !canMutateProperties:canMutateProperties
        !safe:isSafe
      }
    ]
  #---------------- Add decorated declaration
    ioDecoratedDeclarationList += !@decoratedFunction.new {
      !inSelfTypeName
      !function.mMode
      !function.mPublicFunction
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
      !function.mFunctionReturnTypeName
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !warnIfUnused
      !globalFunction
      !isSafe
    }
  end
}

#·······················································································································

method @functionDeclarationListAST enterFunctionsInPropertyMap
  ?!context:@semanticContext ioContext
  ?!@propertyMap ioPropertyMap
{
#----
  for function in self do
  #--- Attributes
    @stringset attributeSet = {}
    for attribute in function.mFunctionAttributeList do
      attributeSet += !attribute.mValue.string
    end
    let exportedFunction = [attributeSet hasKey !exportedAttribute ()]
    let canMutateProperties = [attributeSet hasKey !mutatingAttribute ()]
    let safe = [attributeSet hasKey !safeAttribute ()]
    let canAccessProperties = function.mMode != .userMode
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !function.mFunctionFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !function.mFunctionReturnTypeName ?let returnTypeProxy]
  #--- Routine mangled name
    let routineMangledName = routineMangledNameFromAST (
      !""
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
    )
  #--- Routine descriptor
    let descriptor = @routineDescriptor.new {
      !isPublic:function.mPublicFunction
      !exported:exportedFunction
      !name:function.mFunctionName
      !routineKind:.function {!executionMode:function.mMode}
      !signature:signature
      !returnTypeProxy:returnTypeProxy
      !canAccessProperties:canAccessProperties
      !canMutateProperties:canMutateProperties
      !safe:safe
    }
  #--- Enter in structure map
    [!?ioPropertyMap insertKey !routineMangledName !function.mPublicFunction !.nonVirtualMethod {!descriptor:descriptor}]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @decoratedFunction : @abstractDecoratedDeclaration {
  @string mSelfTypeName
  @mode mMode
  @bool mPublicFunction
  @lstring mFunctionName
  @routineFormalArgumentListAST mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
  @bool mWarnIfUnused
  @bool mIsGlobalProcedure
  @bool mIsSafe
}

#·······················································································································

override method @decoratedFunction routineSemanticAnalysis
  ?context:let @semanticContext unused inSemanticContext
  ?!temporary:@semanticTemporariesStruct unused ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#·······················································································································

override method @decoratedFunction semanticAnalysis
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  let @PLMType receiverType = if mSelfTypeName == "" then
    voidType ()
  else
    [@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap ![mSelfTypeName nowhere]} type]
  end
  @routineAttributes attributes = .mutating | .directPropertyAccess | .controlRegisterReadable
  if not mIsSafe then
    attributes = attributes | .panicAllowed
  end
  routineSemanticAnalysis (
    !receiverType:receiverType
    !.function {!executionMode:mMode}
    !mMode
    !mFunctionName
    !mFunctionFormalArgumentList
    !returnTypeName:mFunctionReturnTypeName
    !mFunctionInstructionList
    !mEndOfFunctionDeclaration
    !routineAttributes:attributes
    !warnIfUnused:mWarnIfUnused
    !globalFunction:mIsGlobalProcedure
    !context:inSemanticContext
    !?temporary:ioTemporaries
    !?intermediateCode:ioIntermediateCodeStruct
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
