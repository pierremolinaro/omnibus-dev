#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @mode mMode
  @bool mPublicFunction
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @routineFormalArgumentListAST mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <function> ?!@ast ioAST ?!@functionDeclarationListAST ioProcListAST {
  #--- Public ?
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <function_header>
      !?ioAST
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition>!?ioAST  ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioProcListAST +=
      !mode
      !public
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
  }

  #·····················································································································

  rule <mode> !@mode outMode {
    select
      outMode = .anyMode
    or
      $user$
      outMode = .userMode
    or
      $panic$
      outMode = .panicMode
    or
      $boot$
      outMode = .bootMode
    or
      $startup$
      outMode = .startupMode
    or
      $section$
      outMode = .sectionMode
    or
      $service$
      outMode = .serviceMode
    or
      $primitive$
      outMode = .primitiveMode
    or
      $guard$
      outMode = .guardMode
    or
      $safe$
      select
        outMode = .anyMode
      or
        $user$
        outMode = .userMode
      or
        $panic$
        outMode = .panicMode
      or
        $boot$
        outMode = .bootMode
      or
        $startup$
        outMode = .startupMode
      or
        $section$
        outMode = .sectionMode
      or
        $service$
        outMode = .serviceMode
      or
        $primitive$
        outMode = .primitiveMode
      or
        $guard$
        outMode = .guardMode
      end
    end
  }

  #·····················································································································

  rule <function_header>
    ?!@ast ioAST
    !mode:@mode outMode
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@routineFormalArgumentListAST outProcFormalArgumentList
  {
    $func$
    $identifier$ ?outProcName
    <mode> ?outMode
    outAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?outProcFormalArgumentList
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
    if mFunctionReturnTypeName.string != "" then
      [!?ioGraph noteNode !mFunctionReturnTypeName]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST enterStandaloneFunctionsInContext 
  ?!context:@semanticContext ioContext
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
{
  for function in self do
  #--- Signature
    routineTypedSignature (!?ioContext.mTypeMap !function.mFunctionFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !function.mFunctionReturnTypeName ?let returnTypeProxy]
  #--- Attributes
    var warnIfUnused = true
    var exportedFunction = false
    var canMutateProperties = false
    var isSafe = false
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == exportedAttribute () then
        if exportedFunction then
          error attribute : "duplicated @" + exportedAttribute () + " attribute"
        end
        exportedFunction = true
      elsif attribute.string == mutatingAttribute () then
        if canMutateProperties then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        canMutateProperties = true
      elsif attribute.string == safeAttribute () then
        if isSafe then
          error attribute : "duplicated attribute" fixit { remove }
        else
          isSafe = true
        end
      else
        error attribute : "unknown attribute; available attributes are @"
          + noUnusedWarningAttribute () + ", @" + noUnusedWarningAttribute () + ", @" + exportedAttribute ()+ ", @" + safeAttribute ()
      end
    end
  #--- Routine mangled name
    let functionLLVMName = routineMangledNameFromAST (
      !"" 
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
    )
  #--- Enter in routine map
    let @routineLLVMNameDict routineLLVMNameDict = {!function.mMode !functionLLVMName}
    let routineMangledName = [signature mangledName !function.mFunctionName]
    [!?ioContext.mRoutineMap insertKey
      !routineMangledName
      !function.mPublicFunction
      !signature
      !returnTypeProxy
      !routineLLVMNameDict
      !safe:isSafe
      !exportedFunction
      !function.mMode
    ]
  #---------------- Add decorated declaration
    ioDecoratedRoutineList +=
      !receiverTypeName: ["" nowhere]
      !mode:function.mMode
      !safe: isSafe
      !isRequired:[ioContext.mRequiredRoutineSet hasKey !functionLLVMName.string]
      !.function
      !warnIfUnused: warnIfUnused
      !exportedRoutine: exportedFunction
      !.none
      !functionLLVMName
      !function.mFunctionFormalArgumentList
      !true # warningOnUnusedArgs
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !returnTypeName: function.mFunctionReturnTypeName
  end
}

#·······················································································································

method @functionDeclarationListAST enterFunctionsInPropertyMap
  ?receiverTypeName:let @lstring inReceiverTypeName # Empty string if standalone
  ?receiverLLVMBaseTypeName:let @string inReceiverLLVMBaseTypeName  # Empty string if standalone
  ?!routineMap: @routineMapCTXT ioRoutineMapCTXT
  ?!context:@semanticContext ioContext
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR unused ioRoutineListIR
{
#----
  for function in self do
  #--- Attributes
    @stringset attributeSet = {}
    for attribute in function.mFunctionAttributeList do
      attributeSet += !attribute.mValue.string
    end
    let exportedFunction = [attributeSet hasKey !exportedAttribute ()]
  #--- Signature
    routineTypedSignature (!?ioContext.mTypeMap !function.mFunctionFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !function.mFunctionReturnTypeName ?let returnTypeProxy]
  #--- Routine LLVM Name name
    let functionLLVMName = routineMangledNameFromAST (
      !inReceiverLLVMBaseTypeName
      !function.mFunctionName
      !function.mFunctionFormalArgumentList
    )
  #--- Prepare annalysis
    var warnIfUnused = true
    var safe = false
    var functionAttributes = @routineAttributes.controlRegisterReadable
    for (attribute) in function.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == safeAttribute () then
        if safe then
          error attribute : "duplicated @" + safeAttribute () + " attribute"
        end
        safe = true   
      elsif attribute.string == mutatingAttribute () then
        if [functionAttributes mutating] then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute"
        end
        functionAttributes = functionAttributes | .mutating    
      else
        error attribute : "unknown attribute; available attributes are @" + noUnusedWarningAttribute ()
          + " and @" + mutatingAttribute ()
      end
    end
  #--- Enter in routine map
    @routineLLVMNameDict routineLLVMNameDict = {!function.mMode !functionLLVMName}
    switch function.mMode
    case anyMode :
    case bootMode :
    case guardMode :
    case panicMode :
    case primitiveMode :
      routineLLVMNameDict += !.serviceMode !functionLLVMName
      routineLLVMNameDict += !.sectionMode !functionLLVMName
    case sectionMode :
    case serviceMode :
      routineLLVMNameDict += !.sectionMode !functionLLVMName
    case startupMode :
    case userMode :
    end
    let routineMangledName = [signature mangledName !function.mFunctionName]
    [!?ioRoutineMapCTXT insertKey
      !routineMangledName
      !function.mPublicFunction
      !signature
      !returnTypeProxy
      !routineLLVMNameDict
      !safe:if function.mMode == .panicMode then true else safe end
      !exportedFunction
      !function.mMode
    ]
    ioDecoratedRoutineList +=
      !receiverTypeName: inReceiverTypeName
      !mode:function.mMode
      !safe: safe
      !isRequired: false
      !.function
      !warnIfUnused: warnIfUnused
      !exportedRoutine: false
      !functionAttributes
      !functionLLVMName
      !function.mFunctionFormalArgumentList
      !true # warningOnUnusedArgs
      !function.mFunctionInstructionList
      !function.mEndOfFunctionDeclaration
      !returnTypeName: function.mFunctionReturnTypeName  # Empty string if no returned value
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ROUTINE MAP
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @routineMapCTXT {
  @bool mIsPublic
  @routineTypedSignature mSignature
  @unifiedTypeMap-proxy mReturnTypeProxy # null if no returned value
  @routineLLVMNameDict mModeDictionary
  @bool safe %selector
  @bool mIsExported
  @mode mMode

  insert insertKey error message "the '%K' function is already declared in %L"
  search searchKey error message "there is no '%K' function"
}

#·······················································································································

dict @routineLLVMNameDict : @mode {
  @string mRoutineLLVMName
}

#·······················································································································

setter @routineMapCTXT addFunctionWithoutArgument
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @lstring inMethodName
  ?mode:let @mode inMode
  ?safe:let @bool inIsSafe
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  !routineLLVMName:@lstring outRoutineLLVMName
{
  let @routineFormalArgumentListAST formalArguments = {}
  let routineMangledName = @lstring.new {
    !inMethodName.string + [formalArguments routineSignature !inMethodName]
    !inMethodName
  }
  outRoutineLLVMName = routineMangledNameFromAST (!inLLVMBaseTypeName !inMethodName !formalArguments)
  [!?self insertKey
    !routineMangledName
    !true
    !{}
    !inResultType
    !{!inMode !outRoutineLLVMName}
    !safe:if inMode == .panicMode then true else inIsSafe end
    !false
    !.anyMode
  ]
}

#·······················································································································

setter @routineMapCTXT addFunctionWithInputArgument
  ?!context:@semanticContext ioContext
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @lstring inMethodName
  ?mode:let @mode inMode
  ?safe:let @bool inIsSafe
  ?inputArgumentSelector:let @string inInputSelector
  ?inputArgumentTypeProxy:let @unifiedTypeMap-proxy inInputArgumentTypeProxy
  ?inputArgumentName: let @string inInputArgumentName
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  !routineLLVMName:@lstring outRoutineLLVMName
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector nowhere]
    ![[inInputArgumentTypeProxy key] nowhere]
    ![inInputArgumentName nowhere]
  }
  routineTypedSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let routineMangledName = @lstring.new {
    !inMethodName.string + [argumentList routineSignature !inMethodName]
    !inMethodName
  }
  outRoutineLLVMName = routineMangledNameFromAST (!inLLVMBaseTypeName !inMethodName !argumentList)
  [!?self insertKey
    !routineMangledName
    !true
    !signature
    !inResultType
    !{!inMode !outRoutineLLVMName}
    !safe:if inMode == .panicMode then true else inIsSafe end
    !false
    !.anyMode
  ]
}

#·······················································································································

setter @routineMapCTXT addFunctionWithTwoInputArguments
  ?!context:@semanticContext ioContext
  ?llvmBaseTypeName:let @string inLLVMBaseTypeName
  ?methodName:let @lstring inMethodName
  ?mode:let @mode inMode
  ?safe:let @bool inIsSafe
  ?inputArgumentSelector1:let @string inInputSelector1
  ?inputArgumentTypeProxy1:let @unifiedTypeMap-proxy inInputArgumentTypeProxy1
  ?inputArgumentName1: let @string inInputArgumentName1
  ?inputArgumentSelector2:let @string inInputSelector2
  ?inputArgumentTypeProxy2:let @unifiedTypeMap-proxy inInputArgumentTypeProxy2
  ?inputArgumentName2: let @string inInputArgumentName2
  ?resultTypeProxy:let @unifiedTypeMap-proxy inResultType
  !routineLLVMName:@lstring outRoutineLLVMName
{
  let argumentList = @routineFormalArgumentListAST {
    !.input
    ![inInputSelector1 nowhere]
    ![[inInputArgumentTypeProxy1 key] nowhere]
    ![inInputArgumentName1 nowhere]
  ,
    !.input
    ![inInputSelector2 nowhere]
    ![[inInputArgumentTypeProxy2 key] nowhere]
    ![inInputArgumentName2 nowhere]
  }
  outRoutineLLVMName = routineMangledNameFromAST (
    !inLLVMBaseTypeName
    !.new {!inMethodName !.nowhere}
    !argumentList
  )
  routineTypedSignature (!?ioContext.mTypeMap !argumentList ?let signature)
  let routineMangledName = @lstring.new {
    !inMethodName.string + [argumentList routineSignature !inMethodName]
    !inMethodName
  }
  [!?self insertKey
    !routineMangledName
    !true
    !signature
    !inResultType
    !{!inMode !outRoutineLLVMName}
    !safe:if inMode == .panicMode then true else inIsSafe end
    !false
    !.anyMode
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
