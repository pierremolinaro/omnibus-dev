#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @lstringlist mFunctionModeList
  @bool mPublicFunction
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @procFormalArgumentList mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procFormalArgumentPassingMode {
  case input
  case output
  case inputOutput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procFormalArgumentList {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @procFormalArgumentPassingMode requiredActualPassingModeForSelector ?@string inSelector -> @string outResult {
  switch self
  case input : outResult = "!"
  case output : outResult = "?"
  case inputOutput : outResult = "!?"
  end
  if inSelector != "" then
    outResult += inSelector + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @labelMap {
  insert insertKey error message "the '%K' label is already declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <procedure> ?!@functionDeclarationListAST ioProcListAST {
    <procedure_header>
      ?public:let public
      ?procModes:let procModeList
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      $typeName$ ?returnTypeName
    end
    ${$
    <instructionList> ?let instructionList !?*
    $}$
    ioProcListAST +=
      !procModeList
      !public
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
  }

  #·····················································································································

  rule <procedure_header>
    !public:@bool outPublic
    !procModes:@lstringlist outProcModeList
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@procFormalArgumentList outProcFormalArgumentList
  {
    select
      outPublic = false
    or
      $public$
      outPublic = true
    end
    $func$
    outProcModeList = {}
    repeat
      $modeName$ ?let procMode
      outProcModeList += !procMode
    while
    end
    $identifier$ ?outProcName
    outAttributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:outProcFormalArgumentList
  }

  #·····················································································································

  rule <procedure_formal_arguments> !formalArguments:@procFormalArgumentList outProcFormalArgumentList {
    outProcFormalArgumentList = {}
    $($
    repeat
    while
      $!$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.output
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?!$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.inputOutput
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.input
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST procedureSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for procedure in self do
    var warnIfUnused = true
    var globalProcedure = false
    var weakProcedure = false
    for (attribute) in procedure.mFunctionAttributeList do
      if attribute.string == noWarningIfUnusedAttribute () then
        if not warnIfUnused then
          error attribute : "duplicate @" + noWarningIfUnusedAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == globalAttribute () then
        if globalProcedure then
          error attribute : "duplicate @" + globalAttribute () + " attribute"
        end
        globalProcedure = true    
      elsif attribute.string == weakAttribute () then
        if weakProcedure then
          error attribute : "duplicate @" + weakAttribute () + " attribute"
        end
        weakProcedure = true    
      else
        error attribute : "unknown attribute; available attributes are @"
          + noWarningIfUnusedAttribute () + ", @" + weakAttribute () + ", @" + globalAttribute ()
      end
    end
    routineSemanticAnalysis (
      !receiverType:inReceiverType
      !.function
      !procedure.mFunctionModeList
      !procedure.mFunctionName
      !procedure.mFunctionFormalArgumentList
      !returnTypeName:procedure.mFunctionReturnTypeName
      !procedure.mFunctionInstructionList
      !procedure.mEndOfFunctionDeclaration
      !warnIfUnused:warnIfUnused
      !globalProcedure:globalProcedure
      !weakProcedure:weakProcedure
      !registerAccess:.readWriteAccess
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
