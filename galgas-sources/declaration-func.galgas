#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @mode mMode
  @bool mPublicFunction
  @lstring mFunctionName
  @lstringlist mFunctionAttributeList
  @procFormalArgumentList mFunctionFormalArgumentList
  @lstring mFunctionReturnTypeName # Empty string if no return value
  @instructionListAST mFunctionInstructionList
  @location mEndOfFunctionDeclaration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @procFormalArgumentPassingMode {
  case input
  case output
  case inputOutput
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @procFormalArgumentList {
  @procFormalArgumentPassingMode mFormalArgumentPassingMode
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @procFormalArgumentPassingMode formalPassingModeString -> @string outResult {
  switch self
  case input : outResult = "?"
  case output : outResult = "!"
  case inputOutput : outResult = "?!"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @procFormalArgumentPassingMode requiredActualPassingModeForSelector ?let @string inSelector -> @string outResult {
  switch self
  case input : outResult = "!"
  case output : outResult = "?"
  case inputOutput : outResult = "!?"
  end
  if inSelector != "" then
    outResult += inSelector + ":"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <function> ?!@functionDeclarationListAST ioProcListAST {
  #--- Public ?
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    <function_header>
      ?mode:let @mode mode
      ?name:let procName
      ?attributes:let attributeList
      ?formalArguments:let procFormalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      $\$type$ ?returnTypeName
    end
    ${$
    <instructionList> ?let instructionList
    $}$
    ioProcListAST +=
      !mode
      !public
      !procName
      !attributeList
      !procFormalArgumentList
      !returnTypeName
      !instructionList
      !.here
  }

  #·····················································································································

  rule <mode> !@mode outMode {
    select
      outMode = .anyMode
    or
      $user$
      outMode = .userMode
    or
      $panic$
      outMode = .panicMode
    or
      $boot$
      outMode = .bootMode
    or
      $init$
      outMode = .initMode
    or
      $section$
      outMode = .sectionMode
    or
      $service$
      outMode = .serviceMode
    or
      $primitive$
      outMode = .primitiveMode
    or
      $guard$
      outMode = .guardMode
    or
      $safe$
      outMode = .safeMode
    end
  }

  #·····················································································································

  rule <function_header>
    !mode:@mode outMode
    !name:@lstring outProcName
    !attributes:@lstringlist outAttributeList
    !formalArguments:@procFormalArgumentList outProcFormalArgumentList
  {
  #---
    $func$
    <mode> ?outMode
    $identifier$ ?outProcName
    outAttributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      outAttributeList += !attribute
    end
    <procedure_formal_arguments> ?formalArguments:outProcFormalArgumentList
  }

  #·····················································································································

  rule <procedure_formal_arguments> !formalArguments:@procFormalArgumentList outProcFormalArgumentList {
    outProcFormalArgumentList = {}
    $($
    repeat
    while
      $!$ ?let selector
      $identifier$ ?let formalArgumentName
      $\$type$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.output
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?!$ ?let selector
      $identifier$ ?let formalArgumentName
      $\$type$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.inputOutput
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $\$type$ ?let formalArgumentTypeName
      outProcFormalArgumentList +=
        !@procFormalArgumentPassingMode.input
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mFunctionFormalArgumentList do
      let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
      [!?ioGraph noteNode !typeName]
    end
    [mFunctionInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST enterFunctionInContext 
  ?selfTypeName:let @string inSelfTypeName
  ?!context:@semanticContext ioContext
{
  for procedure in self do
  #--- Signature
    var routineMangledName = if inSelfTypeName == "" then
      procedure.mFunctionName
    else
      @lstring.new {!inSelfTypeName + "." + procedure.mFunctionName !procedure.mFunctionName.location}
    end
    routineMangledName.string += "("
    @procedureSignature signature = {}
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in procedure.mFunctionFormalArgumentList do
      let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
      signature += !formalArgumentPassingMode !selector.string !typeProxy
      routineMangledName.string += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
    end
    routineMangledName.string += ")"
  #--- Return type
    let returnType = if procedure.mFunctionReturnTypeName.string == "" then
      @unifiedTypeMap-proxy.null
    else
      @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !procedure.mFunctionReturnTypeName}
    end
  #--- Attribute
    var weakProcedure = false
    var globalProcedure = false
    var canMutateProperties = false
    var canAccessProperties = false
    for (attribute) in procedure.mFunctionAttributeList while not weakProcedure do
      if attribute.string == weakAttribute () then
        weakProcedure = true
      end
      if attribute.string == globalAttribute () then
        globalProcedure = true
      end
      if attribute.string == mutatingAttribute () then
        canMutateProperties = true
      end
#      if attribute.string == userAccessAttribute () then
#        canAccessProperties = true
#        if canAccessProperties && not [procedureModeMap hasKey !userModeName ()] then
#          error attribute : "useless @" + attribute + " attribute: function is never executed in `" + userModeName () + " mode"
#        end
#      end
    end
    canAccessProperties = procedure.mMode != .userMode
#    if not [procedureModeMap hasKey !userModeName ()] then
#      canAccessProperties = true
#    end
  #--- Enter in context
    if [ioContext.mRoutineMapForContext hasKey !routineMangledName.string] then
      let weak = [ioContext.mRoutineMapForContext mWeakForKey !routineMangledName.string]
      if weakProcedure && not weak then
        # redefined weak procedure is ignored
      elsif weakProcedure && weak then
        error procedure.mFunctionName : "this weak procedure overrides a weak procedure"
      elsif (not weakProcedure) && weak then
        [!?ioContext.mRoutineMapForContext removeKey !routineMangledName ?11*] # Remove weak routine
        [!?ioContext.mRoutineMapForContext insertKey # Insert routine
          !routineMangledName
          !routineMangledName
          !procedure.mPublicFunction
          !globalProcedure
          !procedure.mMode
          !signature
          !.function
          !weakProcedure
          !returnType
          !false # No appendFileAndLineArgumentForPanicLocation
          !canMutateProperties
          !canAccessProperties
        ]
      else # (not weakProcedure) && (not weak)
        [!?ioContext.mRoutineMapForContext insertKey # Raises a redefinition error
          !routineMangledName
          !routineMangledName
          !procedure.mPublicFunction
          !globalProcedure
          !procedure.mMode
          !signature
          !.function
          !weakProcedure
          !returnType
          !false # No appendFileAndLineArgumentForPanicLocation
          !canMutateProperties
          !canAccessProperties
        ]
      end
    else
      [!?ioContext.mRoutineMapForContext insertKey
        !routineMangledName
        !routineMangledName
        !procedure.mPublicFunction
        !globalProcedure
        !procedure.mMode
        !signature
        !.function
        !weakProcedure
        !returnType
        !false # No appendFileAndLineArgumentForPanicLocation
        !canMutateProperties
        !canAccessProperties
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST procedureSemanticAnalysis
  ?receiverType:@unifiedTypeMap-proxy inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for procedure in self do
    var warnIfUnused = true
    var globalProcedure = false
    var weakProcedure = false
    for (attribute) in procedure.mFunctionAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if not warnIfUnused then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute"
        end
        warnIfUnused = false    
      elsif attribute.string == globalAttribute () then
        if globalProcedure then
          error attribute : "duplicated @" + globalAttribute () + " attribute"
        end
        globalProcedure = true    
      elsif attribute.string == weakAttribute () then
        if weakProcedure then
          error attribute : "duplicated @" + weakAttribute () + " attribute"
        end
        weakProcedure = true    
      else
        error attribute : "unknown attribute; available attributes are @"
          + noUnusedWarningAttribute () + ", @" + weakAttribute () + ", @" + globalAttribute ()
      end
    end
    routineSemanticAnalysis (
      !receiverType:inReceiverType
      !.function
      !procedure.mMode
      !procedure.mFunctionName
      !procedure.mFunctionFormalArgumentList
      !returnTypeName:procedure.mFunctionReturnTypeName
      !procedure.mFunctionInstructionList
      !procedure.mEndOfFunctionDeclaration
      !directAccessToPropertiesAllowed:true
      !propertiesAreMutable:true
      !warnIfUnused:warnIfUnused
      !globalFunction:globalProcedure
      !weakFunction:weakProcedure
#      !registerAccess:.readWriteAccess
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
