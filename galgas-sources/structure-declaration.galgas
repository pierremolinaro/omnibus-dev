#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @structureDeclaration : @abstractDeclaration {
  @lstring mStructureName
  @lstringlist mAttributeList
  @structureFieldListAST mStructureFieldListAST
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structureDeclaration location -> @location outLocation {
  outLocation = mStructureName.location
}

#----------------------------------------------------------------------------------------------------------------------*

list @structureFieldListAST {
  @lstring mFieldName
  @lstring mOptionalFieldType
  @expressionAST mInitExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $struct$
    $typeName$ ?let structureName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end 
    ${$
    @structureFieldListAST fieldList = {}
    repeat
    while
      $var$
      $identifier$ ?let fieldName
      @lstring optionalFieldType
#      select
#        optionalFieldType = .new {!"" !.here}
#      or
        $typeName$ ?optionalFieldType
#      end
      $=$
      <expression> ?let initExpression
      fieldList += !fieldName !optionalFieldType !initExpression
    while
      <procedure>
        !procedureKind:.structureProc {!structureTypeName:structureName !mutating:false}
        !?ioAST.mProcedureListAST
    while
      $mutating$
      <procedure>
        !procedureKind:.structureProc {!structureTypeName:structureName !mutating:true}
        !?ioAST.mProcedureListAST
    while
      $;$
    end
    $}$
    ioAST.mDeclarationList += !@structureDeclaration.new {
      !structureName
      !attributeList
      !fieldList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !mStructureName !self]
  for (* fieldTypeName *) in mStructureFieldListAST do
    if fieldTypeName.string != "" then
      [!?ioGraph addEdge !mStructureName !fieldTypeName]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structureDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "struct " + mStructureName 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

getter @procedureDeclarationListAST-element getMangledName -> @string outMangledName {
  outMangledName = mProcedureName.string
  for (formalArgument selector * *) in mProcFormalArgumentList do
    outMangledName += " "
    switch formalArgument
    case input : outMangledName += "?"
    case output : outMangledName += "!"
    case inputOutput : outMangledName += "?!"
    end
    outMangledName += selector.string
  end
}

#----------------------------------------------------------------------------------------------------------------------*

list @propertyList {
  @unifiedTypeMap-proxy mTypeProxy
  @lstring mPropertyName
}

#----------------------------------------------------------------------------------------------------------------------*

map @propertyMap {
  @unifiedTypeMap-proxy mTypeProxy
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
#--- Attribute "unique"
  var copiable = true
  for (s) in mAttributeList do
    if s.string == "unique" then
      if not copiable then
        error s : "duplicated attribute"
      end
      copiable = false
    else
      error s : "unknown attribute"
    end
  end
#--- Properties
  @literalStructureList structInitList = {}
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  for () in mStructureFieldListAST do
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mOptionalFieldType ?let fieldTypeNameProxy]
    propertyList += !fieldTypeNameProxy !mFieldName
    [!?propertyMap insertKey !mFieldName !fieldTypeNameProxy]
 #   structInitList += ![fieldTypeNameProxy initStaticValue]
  end
#--- Procedures
  @procedureMap procedureMap = {}
  for procedure in inProcedureListAST do
    switch procedure.mProcedureKind
    case standAloneProc :
    case structureProc (structureTypeName mutating) :
      if mStructureName.string == structureTypeName.string then
        @procedureSignature signature = {}
        for (formalArgumentPassingMode selector formalArgumentTypeName *) in procedure.mProcFormalArgumentList do
          [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
          signature += !formalArgumentPassingMode !selector !typeProxy
        end
        [!?procedureMap insertKey
          !.new {![procedure getMangledName] !procedure.mProcedureName.location}
          !mutating
          !{}
          !signature
          !false # not weak
        ]
      end
    end
  end
#--- Enter in type map
  [!?ioContext.mTypeMap insertKey
    !lkey:mStructureName
    !kind:.structure {!propertyMap:propertyMap}
    !constructorMap:{}
    !procedureMap:procedureMap
    !copiable:copiable
    !equatable:false
    !comparable:false
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  INIT ANALYSIS                                                                                                       *
#----------------------------------------------------------------------------------------------------------------------*

enum @literalStructure {
  case unsignedInteger (@bigint value)
  case signedInteger (@bigint value)
  case string (@string value @string name)
  case structure (@literalStructureList value)
}

#----------------------------------------------------------------------------------------------------------------------*

list @literalStructureList {
  @literalStructure mStructure
}

#----------------------------------------------------------------------------------------------------------------------*

map @instanciationMap {
  @literalStructureList mInstanciation
  insert insertKey error message "the '$%K' type instantiation is already declared in %L"
  search searchKey error message "the '$%K' type does not implement type instanciation"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration initAnalysis
  ?!context:@semanticContext ioContext
{
  @literalStructureList initStructureList = {}
  @globalLiteralStringMap globalLiteralStringMap = {} # Unused here
  for () in mStructureFieldListAST do
  #--- Field type
    let @unifiedTypeMap-proxy fieldType = if mOptionalFieldType.string == ""
      then .null
      else .searchKey {!ioContext.mTypeMap !mOptionalFieldType}
    end
  #--- Init expression
    @instructionListIR initInstructionGenerationList = {}
    @semanticTemporariesStruct temporaries = .default
    [mInitExpression analyzeExpression
      !routineNameForInvocationGraph:.new {!mStructureName.string + " init" !mStructureName.location}
      !optionalReceiverType:.noReceiver
      !optionalTargetType:fieldType
      !context:ioContext
      !modes:{}
      !allowException:false
      !?temporary:temporaries
      !?staticStringMap:globalLiteralStringMap
      !?variableMap:*
      !?instructionListIR:initInstructionGenerationList
      ?expressionType:let unused inferredType
      ?result:@variableKindIR expressionIR
    ]
    switch expressionIR
    case register (@lstring name) :
      error name : "a register cannot be used as field initial value"
    case globalVariable (@lstring name) :
      error name : "a global variable cannot be used as field initial value"
    case localVariable (@lstring name) :
      error name : "a local variable cannot be used as field initial value"
    case inArgument (@lstring name) :
      error name : "an in formal argument cannot be used as field initial value"
    case inOutArgument (@lstring name) :
      error name : "an in/out formal argument cannot be used as field initial value"
    case outArgument (@lstring name) :
      error name : "an out formal argument cannot be used as field initial value"
    case localConstant (@lstring name) :
      error name : "a local constant cannot be used as field initial value"
    case temporaryConstant (*) :
      error .nowhere : "a temporary constant cannot be used as field initial value"
    case localAccess (@lstring access) :
      error access : "a property cannot be used as field initial value"
    case literalUnsignedInteger (@bigint value) :
      initStructureList += !.unsignedInteger {!value:value}
    case literalSignedInteger (@bigint value) :
      initStructureList += !.signedInteger {!value:value}
    case literalString (@string value @string name) :
      initStructureList += !.string {!value:value !name:name}
    case literalStructure (@literalStructureList value) :
      initStructureList += !.structure {!value:value}
    end
  end
#---
  [!?ioContext.mInstanciationMap insertKey !mStructureName !initStructureList]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration semanticAnalysis
  ?context:let @semanticContext inContext
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Analyze field declaration
  @structureFieldListForGeneration structureFieldListForGeneration = {}
  @stringset fieldNameSet = {}
  for () in mStructureFieldListAST do
  #--- Field type
    let @unifiedTypeMap-proxy fieldType = if mOptionalFieldType.string == ""
      then .null
      else .searchKey {!inContext.mTypeMap !mOptionalFieldType}
    end
  #--- Field name
    if [fieldNameSet hasKey !mFieldName.string] then
      error mFieldName : "the '" + mFieldName + "' field is already declared"
    end
    fieldNameSet += !mFieldName.string
  #--- Init expression
    @instructionListIR initInstructionGenerationList = {}
    @semanticTemporariesStruct temporaries = .default
    [mInitExpression analyzeExpression
      !routineNameForInvocationGraph:.new {!mStructureName.string + " init" !mStructureName.location}
      !optionalReceiverType:.noReceiver
      !optionalTargetType:fieldType
      !context:inContext
      !modes:{}
      !allowException:false
      !?temporary:temporaries
      !?staticStringMap:ioIntermediateCodeStruct.mGlobalLiteralStringMap
      !?variableMap:*
      !?instructionListIR:initInstructionGenerationList
      ?expressionType:let inferredType
      ?result:@variableKindIR resultValueName
    ]
  #---
    structureFieldListForGeneration +=
      !inferredType
      !mFieldName.string
#      !initExpressionGeneratedCode
  end
#--- Generate code
  [!?ioIntermediateCodeStruct.mTypeMapIR insertKey
    !mStructureName
    !@structureIR.new {!mStructureName.string !structureFieldListForGeneration}
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

class @structureIR : @abstractTypeIR {
  @string mStructureName
  @structureFieldListForGeneration mStructureFieldListForGeneration
}

#----------------------------------------------------------------------------------------------------------------------*

list @structureFieldListForGeneration {
  @unifiedTypeMap-proxy mFieldType
  @string mFieldName
}

#----------------------------------------------------------------------------------------------------------------------*

private filewrapper structureGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "structure-declaration.galgasTemplate"
    ?@string STRUCTURE_NAME
    ?@structureFieldListForGeneration FIELD_LIST
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structureIR headerCodeGenerationForType -> @string outCode {
  outCode = [filewrapper structureGenerationTemplate.declaration
    !mStructureName
    !mStructureFieldListForGeneration
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

