#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @structureDeclaration : @abstractDeclaration {
  @lstring mStructureName
  @lstringlist mAttributeList
  @structureFieldListAST mStructureFieldListAST
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structureDeclaration location -> @location outLocation {
  outLocation = mStructureName.location
}

#----------------------------------------------------------------------------------------------------------------------*

list @structureFieldListAST {
  @lstring mFieldName
  @lstring mOptionalFieldType
  @expressionAST mInitExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $struct$
    $typeName$ ?let structureName
    @lstringlist attributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      attributeList += !attribute
    end 
    ${$
    @structureFieldListAST fieldList = {}
    repeat
    while
      $var$
      $identifier$ ?let fieldName
      @lstring optionalFieldType
#      select
#        optionalFieldType = .new {!"" !.here}
#      or
        $typeName$ ?optionalFieldType
#      end
      $=$
      <expression> ?let initExpression
      fieldList += !fieldName !optionalFieldType !initExpression
    while
      <procedure>
        !procedureKind:.structureProc {!structureTypeName:structureName !mutating:false}
        !?ioAST.mProcedureListAST
    while
      $mutating$
      <procedure>
        !procedureKind:.structureProc {!structureTypeName:structureName !mutating:true}
        !?ioAST.mProcedureListAST
    while
      $;$
    end
    $}$
    ioAST.mDeclarationList += !@structureDeclaration.new {
      !structureName
      !attributeList
      !fieldList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  [!?ioGraph addNode !mStructureName !self]
  for (* fieldTypeName *) in mStructureFieldListAST do
    if fieldTypeName.string != "" then
      [!?ioGraph addEdge !mStructureName !fieldTypeName]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structureDeclaration keyRepresentation -> @string outRepresentation {
  outRepresentation = "struct " + mStructureName 
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

getter @procedureDeclarationListAST-element getMangledName -> @string outMangledName {
  outMangledName = mProcedureName.string
  for (formalArgument selector * *) in mProcFormalArgumentList do
    outMangledName += " "
    switch formalArgument
    case input : outMangledName += "?"
    case output : outMangledName += "!"
    case inputOutput : outMangledName += "?!"
    end
    outMangledName += selector.string
  end
}

#----------------------------------------------------------------------------------------------------------------------*

list @propertyList {
  @string mPropertyName
  @unifiedTypeMap-proxy mType
}

#----------------------------------------------------------------------------------------------------------------------*

map @propertyMap {
  @unifiedTypeMap-proxy mTypeProxy
  @uint mIndex
  insert insertKey error message "the '%K' property is already declared"
  search searchKey error message "there is no '%K' property"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration enterInContext
  ?procedureDeclarationList:let @procedureDeclarationListAST inProcedureListAST
  ?!context:@semanticContext ioContext
  ?!staticStringMap:@globalLiteralStringMap unused ioGlobalLiteralStringMap
{
#--- Attribute "unique"
  var copiable = true
  for (s) in mAttributeList do
    if s.string == "unique" then
      if not copiable then
        error s : "duplicated attribute"
      end
      copiable = false
    else
      error s : "unknown attribute"
    end
  end
#--- Properties
  @propertyList propertyList = {}
  @propertyMap propertyMap = {}
  for () in mStructureFieldListAST do
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mOptionalFieldType ?let fieldTypeNameProxy]
    propertyList += !mFieldName.string !fieldTypeNameProxy
    [!?propertyMap insertKey !mFieldName !fieldTypeNameProxy ![propertyMap count]]
  end
#--- Procedures
  @procedureMap procedureMap = {}
  for procedure in inProcedureListAST do
    switch procedure.mProcedureKind
    case standAloneProc :
    case structureProc (structureTypeName mutating) :
      if mStructureName.string == structureTypeName.string then
        @procedureSignature signature = {}
        for (formalArgumentPassingMode selector formalArgumentTypeName *) in procedure.mProcFormalArgumentList do
          [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
          signature += !formalArgumentPassingMode !selector !typeProxy
        end
        [!?procedureMap insertKey
          !.new {![procedure getMangledName] !procedure.mProcedureName.location}
          !mutating
          !{}
          !signature
          !false # not weak
        ]
      end
    end
  end
#--- Enter in type map
  [!?ioContext.mTypeMap insertKey
    !lkey:mStructureName
    !kind:.structure {!name:mStructureName.string !propertyMap:propertyMap !propertyList:propertyList}
    !typedConstantMap:{}
    !procedureMap:procedureMap
    !copiable:copiable
    !equatable:false
    !comparable:false
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  INIT ANALYSIS                                                                                                       *
#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration initAnalysis
  ?!context:@semanticContext ioContext
{
  @globalLiteralStringMap globalLiteralStringMap = {} # Unused here
  @operandIRList operandIRList = {}
  for () in mStructureFieldListAST do
  #--- Field type
    let @unifiedTypeMap-proxy fieldType = if mOptionalFieldType.string == ""
      then .null
      else .searchKey {!ioContext.mTypeMap !mOptionalFieldType}
    end
  #--- Init expression
    @instructionListIR initInstructionGenerationList = {}
    @semanticTemporariesStruct temporaries = .default
    [mInitExpression analyzeExpression
      !routineNameForInvocationGraph:.new {!mStructureName.string + " init" !mStructureName.location}
      !optionalReceiverType:.noReceiver
      !optionalTargetType:fieldType
      !context:ioContext
      !modes:{}
      !allowException:false
      !?temporary:temporaries
      !?staticStringMap:globalLiteralStringMap
      !?variableMap:*
      !?instructionListIR:initInstructionGenerationList
      ?result:@operandIR expressionIR
    ]
    if not [expressionIR.mValue isStatic] then
      error mFieldName : "initialization expression cannot be computed statically"
    end
    @unifiedTypeMap-proxy type
    if fieldType != .null then
      type = fieldType
    else
      type = expressionIR.mType
    end
    operandIRList += !.new {!type !expressionIR.mValue}
  end
  [!?ioContext.mConstructorMap insertKey !mStructureName !operandIRList]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @structureDeclaration semanticAnalysis
  ?context:let @semanticContext unused inContext
  ?!intermediateCode:@intermediateCodeStruct unused ioIntermediateCodeStruct
{
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

proc declareLLVMstructures ?let @unifiedTypeMap inTypeMap ?!@string ioCode {
  for () in inTypeMap do
    if [kind isStructure] then
      [kind structure ?name:let name ?propertyMap:* ?propertyList:let propertyList]
      ioCode += "%" + name + " = type {"
      for () in propertyList
        do ioCode += [mType llvmTypeName]
        between ioCode += ", "
      end
      ioCode += "}\n"
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

