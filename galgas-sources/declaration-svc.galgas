#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#·······················································································································

list @systemRoutineDeclarationListAST {
  @lstring mName
  @routineKind mRoutineKind
  @bool mPublic
  @lstringlist mAttributeList
  @routineFormalArgumentListAST mFormalArgumentList
  @lstring mReturnTypeName
  @instructionListAST mInstructionList
  @location mEndOfInstructionListLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <system_routine_prefix> !@bool public {
    select
      public = false
    or
      $public$
      public = true
    end
    $system$
  }
  
  #·····················································································································

  rule <system_routine>?!@ast ioAST ?!@systemRoutineDeclarationListAST ioSVCListAST {
    <system_routine_prefix> ?let public
    $section$
    $identifier$ ?let name
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?let formalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition> !?ioAST ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    ioSVCListAST +=
      !name
      !.section
      !public
      !attributeList
      !formalArgumentList
      !returnTypeName
      !instructionList
      !.here
    $}$
  }

  #·····················································································································

  # A primitive or a service does not return any value

  rule <system_routine>?!@ast ioAST ?!@systemRoutineDeclarationListAST ioSVCListAST {
    <system_routine_prefix> ?let public
    @routineKind routineKind
    select
      $primitive$
      routineKind = .primitive
    or
      $service$
      routineKind = .service
    end
    $identifier$ ?let name
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?let formalArgumentList
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioSVCListAST +=
      !name
      !routineKind
      !public
      !attributeList
      !formalArgumentList
      !["" here]
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @systemRoutineDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mFormalArgumentList do
      let typeName = llvmTypeNameFromPLMname (!formalArgumentTypeName)
      [!?ioGraph noteNode !typeName]
    end
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @systemRoutineDeclarationListAST enterSystemRoutineInContext
  ?receiverType:let @string inReceiverTypeName
  ?!context:@semanticContext ioContext
{
  for svc in self do
  #--- Routine mangled name
    let routineMangledName = routineMangledNameFromAST (
      !inReceiverTypeName 
      !svc.mName
      !svc.mFormalArgumentList
    )
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !svc.mFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !svc.mReturnTypeName ?let returnTypeProxy]
  #--- Attributes
    var mutating = false
    var safe = false
    for (attribute) in svc.mAttributeList do
      if attribute.string == mutatingAttribute () then
        mutating = true    
      elsif attribute.string == safeAttribute () then
        safe = true    
      end
    end
  #--- Enter in context
    [!?ioContext.mRoutineMapForContext insertRoutine
      !svc.mName
      ![svc.mFormalArgumentList routineSignature !svc.mName]
      !routineMangledName
      !.new {
        !isPublic:svc.mPublic
        !exported:false
        !routineKind:svc.mRoutineKind
        !signature:signature
        !returnTypeProxy:returnTypeProxy
        !canAccessProperties:true
        !canMutateProperties:mutating
        !safe:safe
      }
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @systemRoutineDeclarationListAST systemRoutineSemanticAnalysis
  ?receiverType:@PLMType inReceiverType
  ?context:let @semanticContext inSemanticContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
  for svc in self do
    var mutating = false
    var noUnusedWarning = false
    var isSafe = false
    for (attribute) in svc.mAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if noUnusedWarning then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute" fixit { remove }
        end
        noUnusedWarning = true    
      elsif attribute.string == mutatingAttribute () then
        if mutating then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute" fixit { remove }
        end
        mutating = true    
      elsif attribute.string == safeAttribute () then
        if isSafe then
          error attribute : "duplicated @" + safeAttribute () + " attribute" fixit { remove }
        end
        isSafe = true    
      else
        error attribute 
        : "unknown attribute; available attributes are @" + mutatingAttribute () + ", @" + mutatingAttribute ()
        fixit { remove }
      end
    end
    @mode mode
    switch svc.mRoutineKind
    case section : mode = .sectionMode
    case primitive : mode = .primitiveMode
    case service : mode = .serviceMode
    case function (*) : error svc.mEndOfInstructionListLocation : "INTERNAL ERROR" : mode
    end
    @routineAttributes attributes = .mutating | .directPropertyAccess | .controlRegisterReadable
    if not isSafe then
      attributes = attributes | .panicAllowed
    end
    routineSemanticAnalysis (
      !receiverType:inReceiverType
      !svc.mRoutineKind
      !mode
      !svc.mName
      !svc.mFormalArgumentList
      !returnTypeName:svc.mReturnTypeName
      !svc.mInstructionList
      !svc.mEndOfInstructionListLocation
      !routineAttributes:attributes
      !warnIfUnused:not noUnusedWarning
      !globalFunction:true
      !context:inSemanticContext
      !?temporary:ioTemporaries
      !?intermediateCode:ioIntermediateCodeStruct
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @sectionIRlist {
  @string mSectionCallName
  @string mSectionImplementationName
  @PLMType mReceiverType # .void if standalone function
  @routineFormalArgumentListIR mFormalArgumentListForGeneration
  @PLMType mReturnType # .void if no return value
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @primitiveAndServiceIRlist {
  @string mCallName
  @string mImplementationName
  @bool mReturnValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmFunctionPrototype ?let @PLMType inReturnType
                           ?let @string inFunctionName
                           ?let @PLMType inReceiverType
                           ?let @routineFormalArgumentListIR inFormalArgumentListForGeneration
                           -> @string {
  result = [inReturnType llvmTypeName]
  result += " @" + inFunctionName + " ("
  var first = true
  if inReceiverType.kind != .void then
    result += [inReceiverType llvmTypeName] + " * %receiver"
    first = false
  end
  for () in inFormalArgumentListForGeneration do
    if first then
      first = false
    else
      result += ", "
    end
    switch mFormalArgumentKind
    case input :
      result += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      result += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      result += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  result += ")" + llvmAttributeFunction ()
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmFunctionCall ?let @PLMType inReturnType
                      ?let @string inFunctionName
                      ?let @PLMType inReceiverType
                      ?let @routineFormalArgumentListIR inFormalArgumentListForGeneration
                      -> @string {
  result = "call " + [inReturnType llvmTypeName] + " @" + inFunctionName + " ("
  var first = true
  if inReceiverType.kind != .void then
    result += [inReceiverType llvmTypeName] + " * %receiver"
    first = false
  end
  for () in inFormalArgumentListForGeneration do
    if first then
      first = false
    else
      result += ", "
    end
    switch mFormalArgumentKind
    case input :
      result += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      result += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      result += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @routineMapIR svcCodeGeneration
  ?!@string ioLLVMcode
  ?!@primitiveAndServiceIRlist ioPrimitiveAndServiceList
  ?!@sectionIRlist ioSectionList
{
  for svc in self do
    if not [svc.mKind isFunction] then
      let svcCallName = llvmNameForSVCCall (!svc.mRoutineNameForGeneration !svc.mKind)
      let svcImplementationName = llvmNameForSVCImplementation (!svc.mRoutineNameForGeneration !svc.mKind)
      switch svc.mKind
      case section :
        ioSectionList +=
          !svcCallName
          !svcImplementationName
          !svc.mReceiverType
          !svc.mFormalArgumentListForGeneration
          !svc.mReturnType
      case primitive, service :
        ioLLVMcode += llvmTitleComment (!svcCallName)
        let prototype = llvmFunctionPrototype (
          !svc.mReturnType
          !svcCallName
          !svc.mReceiverType
          !svc.mFormalArgumentListForGeneration
        )
        ioLLVMcode += "declare " + prototype + "\n\n"
        ioPrimitiveAndServiceList += !svcCallName !svcImplementationName !false
      case function (*) :
        error .nowhere : "INTERNAL ERROR"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateSectionAndSafeDispatcher
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?targetParameters:let @targetParameters inTargetParameters
  ?!@string ioAssemblerCode
  ?!@string ioLLVMcode
  ?let @sectionIRlist inSectionIRlist
{
  switch inTargetParameters.mSectionImplementation
  case svc (* sectionHandler sectionDispatcherEntry sectionDispatcherHeader sectionDispatcherInvocation):
    for (callName * receiverType formalArguments resultType) in inSectionIRlist do
      let prototype = llvmFunctionPrototype (
        !resultType
        !callName
        !receiverType
        !formalArguments
      )
      ioLLVMcode += llvmTitleComment (!callName)
      ioLLVMcode += "declare " + prototype + "\n\n"
    end
    for (callName implementationName * * *) in inSectionIRlist do (idx)
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + sectionDispatcherInvocation
      )
      s = [s stringByReplacingStringByString !"!USER_ROUTINE!" !callName]
      s = [s stringByReplacingStringByString !"!IMPLEMENTATION_ROUTINE!" !implementationName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    end
    ioAssemblerCode += getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName + "/" + sectionDispatcherHeader
    )
    for (callName implementationName * * *) in inSectionIRlist do (idx)
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + sectionDispatcherEntry
      )
      s = [s stringByReplacingStringByString !"!USER_ROUTINE!" !callName]
      s = [s stringByReplacingStringByString !"!IMPLEMENTATION_ROUTINE!" !implementationName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    end
    ioAssemblerCode += "\n"
    ioAssemblerCode += getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName + "/" + sectionHandler
    )
    ioAssemblerCode += "@-------------------------------------------------------------"
    ioAssemblerCode += "---------------------------------------------------------*\n"
  case function (disableInterruptInLLVM enableInterruptInLLVM) :
    for (callName implementationName receiverType formalArguments resultType) in inSectionIRlist do
      let prototype = llvmFunctionPrototype (
        !resultType
        !callName
        !receiverType
        !formalArguments
      )
      @string resultTypeName
      resultTypeName = [resultType llvmTypeName]
      ioLLVMcode += llvmTitleComment (!callName)
      ioLLVMcode += "define " + prototype + " {\n"
      ioLLVMcode += "  " + disableInterruptInLLVM + " ; Disable interrupt\n"
      ioLLVMcode += "  "
      if resultType.kind != .void then
        ioLLVMcode += "%result = "
      end
      ioLLVMcode += llvmFunctionCall (!resultType !implementationName !receiverType !formalArguments) + "\n"
      ioLLVMcode += "  " + enableInterruptInLLVM + " ; Enable interrupt\n"
      ioLLVMcode += "  ret " + resultTypeName
      if resultType.kind != .void then
        ioLLVMcode += " %result"
      end
      ioLLVMcode += "\n"
      ioLLVMcode += "}\n\n"
    end
  case none :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generatePrimitiveAndServiceDispatcher
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?!@string ioAssemblerCode
  ?let @primitiveAndServiceIRlist inServiceList
  ?targetParameters:let @targetParameters inTargetParameters
{
#--- Generate service handler
  ioAssemblerCode += getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName + "/" + inTargetParameters.mServiceHandler
  )
#---
  for (callName * hasReturnValue) in inServiceList do (idx)
    if hasReturnValue then
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + inTargetParameters.mServiceEntryWithReturnValue
      )
      s = [s stringByReplacingStringByString !"!ENTRY!" !callName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    else
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + inTargetParameters.mServiceEntryNoReturnedValue
      )
      s = [s stringByReplacingStringByString !"!ENTRY!" !callName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    end
  end
  ioAssemblerCode += getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName + "/" + inTargetParameters.mServiceDispatcherHeader
  )
  for (* implementationName *) in inServiceList do (idx)
    var s = getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName + "/" + inTargetParameters.mServiceDispatcherEntry
    )
    s = [s stringByReplacingStringByString !"!ENTRY!" !implementationName]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
  ioAssemblerCode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
