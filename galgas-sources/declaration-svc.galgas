#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @systemRoutineDeclarationListAST {
  @lstring mName
  @routineKind mRoutineKind
  @bool mPublic
  @lstringlist mAttributeList
  @routineFormalArgumentListAST mFormalArgumentList
  @lstring mReturnTypeName
  @instructionListAST mInstructionList
  @location mEndOfInstructionListLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <system_routine>?!@ast ioAST ?!@systemRoutineDeclarationListAST ioSVCListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    $section$
    $identifier$ ?let name
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_formal_arguments> !?ioAST ?let formalArgumentList
    @lstring returnTypeName
    select
      returnTypeName = ["" here]
    or
      $->$
      <type_definition> !?ioAST ?returnTypeName
    end
    ${$
    <instructionList> !?ioAST ?let instructionList
    ioSVCListAST +=
      !name
      !.section
      !public
      !attributeList
      !formalArgumentList
      !returnTypeName
      !instructionList
      !.here
    $}$
  }

  #·····················································································································

  # A primitive or a service accepts only input arguments and does not return any value

  rule <system_routine>?!@ast ioAST ?!@systemRoutineDeclarationListAST ioSVCListAST {
    @bool public
    select
      public = false
    or
      $public$
      public = true
    end
    @routineKind routineKind
    select
      $primitive$
      routineKind = .primitive
    or
      $service$
      routineKind = .service
    end
    $identifier$ ?let name
    @lstringlist attributeList = {}
    repeat
    while
      $@attribute$ ?let attribute
      attributeList += !attribute
    end
    <procedure_input_formal_arguments> !?ioAST ?let formalArgumentList
    ${$
    <instructionList> !?ioAST ?let instructionList
    $}$
    ioSVCListAST +=
      !name
      !routineKind
      !public
      !attributeList
      !formalArgumentList
      !["" here]
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES IN PRECEDENCE GRAPH                                                                                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @systemRoutineDeclarationListAST noteTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  for () in self do
    for (* * formalArgumentTypeName *) in mFormalArgumentList do
      [!?ioGraph noteNode !formalArgumentTypeName]
    end
    [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   UTILITIES                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func systemUserMangledNameFromAST ?let @string inReceiverLLVMBaseTypeName
                                  ?let @routineKind inKind
                                  ?let @lstring inGuardName
                                  ?let @routineFormalArgumentListAST inFormalArgumentList -> @lstring
{
  @string s
  switch inKind 
  case section :
    s = "section"
  case service :
    s = "service"
  case primitive :
    s = "primitive"
  case function (*) :
    s = "???"
  end
  s += ".user."
  if inReceiverLLVMBaseTypeName != "" then
    s += inReceiverLLVMBaseTypeName + "."
  end
  s += inGuardName.string
  s += "("
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  s += ")"
  result = .new {!s !inGuardName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func systemImplementationMangledNameFromAST ?let @string inReceiverLLVMBaseTypeName
                                            ?let @routineKind inKind
                                            ?let @lstring inGuardName
                                            ?let @routineFormalArgumentListAST inFormalArgumentList -> @lstring
{
  @string s
  switch inKind 
  case section :
    s = "section"
  case service :
    s = "service"
  case primitive :
    s = "primitive"
  case function (*) :
    s = "???"
  end
  s += ".implementation."
  if inReceiverLLVMBaseTypeName != "" then
    s += inReceiverLLVMBaseTypeName + "."
  end
  s += inGuardName.string
  s += "("
  for (formalArgumentPassingMode selector formalArgumentTypeName *) in inFormalArgumentList do
    s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
  end
  s += ")"
  result = .new {!s !inGuardName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @systemRoutineDeclarationListAST enterSystemRoutineInContext
  ?receiverTypeName:let @lstring inReceiverTypeName # Empty string if standalone
  ?receiverLLVMBaseTypeName:let @string inReceiverLLVMBaseTypeName  # Empty string if standalone
  ?!propertyMap: @propertyMap ioPropertyMap
  ?!context:@semanticContext ioContext
  ?!@decoratedRegularRoutineList ioDecoratedRoutineList
  ?!@routineListIR ioRoutineListIR
{
#---------------------------------------- Self type proxy
  [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !inReceiverTypeName ?let selfTypeProxy]
#---------------------------------------- Self type proxy
  for system in self do
  #--- Attributes
    @stringset attributeSet = {}
    for attribute in system.mAttributeList do
      attributeSet += !attribute.mValue.string
    end
#    let exportedRoutine = [attributeSet hasKey !exportedAttribute ()]
#    let canMutateProperties = [attributeSet hasKey !mutatingAttribute ()]
  #--- Routine mangled names
    let userRoutineMangledName = systemUserMangledNameFromAST (
      !inReceiverLLVMBaseTypeName
      !system.mRoutineKind
      !system.mName
      !system.mFormalArgumentList
    )
    let implementationRoutineMangledName = systemImplementationMangledNameFromAST (
      !inReceiverLLVMBaseTypeName
      !system.mRoutineKind
      !system.mName
      !system.mFormalArgumentList
    )
  #--- Signature
    routineSignature (!?ioContext.mTypeMap !system.mFormalArgumentList ?let signature)
  #--- Return type
    [@unifiedTypeMap-proxy makeOptionalProxy !?ioContext.mTypeMap !system.mReturnTypeName ?let returnTypeProxy]
  #--- Attributes
    var mutating = false
    var noUnusedWarning = false
    var isSafe = false
    for (attribute) in system.mAttributeList do
      if attribute.string == noUnusedWarningAttribute () then
        if noUnusedWarning then
          error attribute : "duplicated @" + noUnusedWarningAttribute () + " attribute" fixit { remove }
        end
        noUnusedWarning = true    
      elsif attribute.string == mutatingAttribute () then
        if mutating then
          error attribute : "duplicated @" + mutatingAttribute () + " attribute" fixit { remove }
        end
        mutating = true    
      elsif attribute.string == safeAttribute () then
        if isSafe then
          error attribute : "duplicated @" + safeAttribute () + " attribute" fixit { remove }
        end
        isSafe = true    
      else
        error attribute 
        : "unknown attribute; available attributes are @" + mutatingAttribute () + ", @" + mutatingAttribute ()
        fixit { remove }
      end
    end
  #--- 
    ioRoutineListIR += !@systemUserRoutineIR.new {
      !userRoutineMangledName
      !false
      !false
      !implementationRoutineMangledName
      !signature
      !selfTypeProxy
      !system.mRoutineKind == .section # If false, service or primitive
      !returnTypeProxy
    }
    @mode mode
    switch system.mRoutineKind
    case section : mode = .sectionMode
    case primitive : mode = .primitiveMode
    case service : mode = .serviceMode
    case function (*) : error system.mEndOfInstructionListLocation : "INTERNAL ERROR" : mode
    end
    @routineAttributes attributes = .mutating | .directPropertyAccess | .controlRegisterReadable
    if not isSafe then
      attributes = attributes | .panicAllowed
    end
    ioDecoratedRoutineList +=
      !receiverTypeName: inReceiverTypeName
      !mode:mode
      !isRequired:false
      !system.mRoutineKind # .function {!executionMode: mode}
      !warnIfUnused: not noUnusedWarning
      !exportedRoutine: true
      !attributes
      !implementationRoutineMangledName
      !system.mFormalArgumentList
      !noUnusedWarning
      !system.mInstructionList
      !system.mEndOfInstructionListLocation
      !returnTypeName: system.mReturnTypeName  # Empty string if no returned value
  #--- Enter in context
    var s = ""
    if inReceiverLLVMBaseTypeName != "" then
      s += inReceiverLLVMBaseTypeName + "."
    end
    s += system.mName.string
    s += "("
    for (formalArgumentPassingMode selector formalArgumentTypeName *) in system.mFormalArgumentList do
      s += [formalArgumentPassingMode formalPassingModeString] + selector + ":"
    end
    s += ")"
    let descriptor = @routineDescriptor.new {
      !isPublic:system.mPublic
      !exported:false
      !name:system.mName
      !nameForLLVMGeneration:s # routineMangledName
      !routineKind:system.mRoutineKind
      !signature:signature
      !returnTypeProxy:returnTypeProxy
      !canAccessProperties:true
      !canMutateProperties:mutating
      !safe:isSafe
    }
    [!?ioContext.mRoutineMapForContext insertRoutine
      !inReceiverTypeName
      !system.mName
      ![system.mFormalArgumentList routineSignature !system.mName]
      !.new{ !s !system.mName} # routineMangledName
      !descriptor
    ]
  #--- Enter in structure map
    let routineMangledName = routineMangledNameFromAST (
      !inReceiverLLVMBaseTypeName
      !system.mName
      !system.mFormalArgumentList
    )
    [!?ioPropertyMap insertKey !routineMangledName !system.mPublic !.nonVirtualMethod {!descriptor:descriptor}]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @sectionIRlist {
  @string mSectionCallName
  @string mSectionImplementationName
  @bool invocationFromAnyMode %selector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @primitiveAndServiceIRlist {
  @string mCallName
  @string mImplementationName
  @bool mHasReturnValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func llvmFunctionPrototype ?let @string inReturnTypeLLVMName
                           ?let @string inFunctionName
                           ?let @PLMType inReceiverType
                           ?let @routineFormalArgumentListIR inFormalArgumentListForGeneration
                           -> @string {
  result = inReturnTypeLLVMName
  result += " @" + inFunctionName + " ("
  var first = true
  if inReceiverType.kind != .void then
    result += [inReceiverType llvmTypeName] + " * %receiver"
    first = false
  end
  for () in inFormalArgumentListForGeneration do
    if first then
      first = false
    else
      result += ", "
    end
    switch mFormalArgumentKind
    case input :
      result += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      result += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
   case inputOutput :
      result += [mFormalArgumentType llvmTypeName] + " * " + llvmNameForLocalVariable (!mFormalArgumentName)
    end
  end
  result += ")" + llvmAttributeFunction ()
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateSectionDispatcher
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?targetParameters:let @targetParameters inTargetParameters
  ?!@string ioAssemblerCode
  ?let @sectionIRlist inSectionIRlist
{
  for section in inSectionIRlist do (idx)
    if section.invocationFromAnyMode then
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + inTargetParameters.mSectionDispatcherInvocationFromAnyMode
      )
      s = [s stringByReplacingStringByString !"!USER_ROUTINE!" !section.mSectionCallName]
      s = [s stringByReplacingStringByString !"!IMPLEMENTATION_ROUTINE!" !section.mSectionImplementationName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    else
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + inTargetParameters.mSectionDispatcherInvocationFromUserMode
      )
      s = [s stringByReplacingStringByString !"!USER_ROUTINE!" !section.mSectionCallName]
      s = [s stringByReplacingStringByString !"!IMPLEMENTATION_ROUTINE!" !section.mSectionImplementationName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    end
  end
  ioAssemblerCode += getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName + "/" + inTargetParameters.mSectionDispatcherHeader
  )
  for (callName implementationName invocationFromUserModeOnly) in inSectionIRlist do (idx)
    var s = getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName + "/" + inTargetParameters.mSectionDispatcherEntry
    )
    s = [s stringByReplacingStringByString !"!USER_ROUTINE!" !callName]
    s = [s stringByReplacingStringByString !"!IMPLEMENTATION_ROUTINE!" !implementationName]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
  ioAssemblerCode += "\n"
  ioAssemblerCode += getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName + "/" + inTargetParameters.mSectionHandler
  )
  ioAssemblerCode += "@-------------------------------------------------------------"
  ioAssemblerCode += "---------------------------------------------------------*\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generatePrimitiveAndServiceDispatcher
  ?let @string inCurrentDirectory
  ?let @string inTargetName
  ?!@string ioAssemblerCode
  ?let @primitiveAndServiceIRlist inServiceList
  ?targetParameters:let @targetParameters inTargetParameters
{
#--- Generate service handler
  ioAssemblerCode += getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName + "/" + inTargetParameters.mServiceHandler
  )
#---
  for service in inServiceList do (idx)
    if service.mHasReturnValue then
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + inTargetParameters.mServiceEntryWithReturnValue
      )
      s = [s stringByReplacingStringByString !"!ENTRY!" !service.mCallName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    else
      var s = getTargetTextFile (
        !currentDir:inCurrentDirectory
        !from:inTargetName + "/" + inTargetParameters.mServiceEntryNoReturnedValue
      )
      s = [s stringByReplacingStringByString !"!ENTRY!" !service.mCallName]
      s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
      ioAssemblerCode += s
    end
  end
  ioAssemblerCode += getTargetTextFile (
    !currentDir:inCurrentDirectory
    !from:inTargetName + "/" + inTargetParameters.mServiceDispatcherHeader
  )
  for service in inServiceList do (idx)
    var s = getTargetTextFile (
      !currentDir:inCurrentDirectory
      !from:inTargetName + "/" + inTargetParameters.mServiceDispatcherEntry
    )
    s = [s stringByReplacingStringByString !"!ENTRY!" !service.mImplementationName]
    s = [s stringByReplacingStringByString !"!IDX!" ![idx string]]
    ioAssemblerCode += s
  end
  ioAssemblerCode += "\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYSTEM USER ROUTINE IR
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @systemUserRoutineIR : @abstractRoutineIR {
  @string mMangledImplementationName
  @routineTypedSignature mFormalArgumentList
  @unifiedTypeMap-proxy mReceiverTypeProxy
  @bool mIsSection # If false, service or primitive
  @unifiedTypeMap-proxy mReturnTypeProxy
}

#·······················································································································

override method @systemUserRoutineIR enterAccessibleEntities
   ?!@stringset ioInvokedRoutineSet
   ?!@uint unused ioMaxBranchOfOnInstructions
{
  ioInvokedRoutineSet += !mMangledImplementationName
}

#·······················································································································

override method @systemUserRoutineIR svcDeclarationGeneration
  ?!@primitiveAndServiceIRlist ioPrimitiveAndServiceList
  ?!@sectionIRlist ioSectionList
  ?!@generationAdds unused ioGenerationAdds
{
  let userMangledName = [mRoutineMangledName assemblerRepresentation]
  let implementationMangledName = [mMangledImplementationName assemblerRepresentation]
  if mIsSection then
    ioSectionList += !userMangledName !implementationMangledName !invocationFromAnyMode: false
  else
    ioPrimitiveAndServiceList += !userMangledName !implementationMangledName !false
  end
}

#·······················································································································

override method @systemUserRoutineIR llvmCodeGeneration 
  ?!@string ioLLVMcode
  ?let @generationContext unused inGenerationContext
  ?!@generationAdds unused ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!mRoutineMangledName)
  ioLLVMcode += "declare "
  if mReturnTypeProxy == .null then
    ioLLVMcode += "void"
  else
    ioLLVMcode += [[mReturnTypeProxy type] llvmTypeName]
  end
  ioLLVMcode += " @" + [mRoutineMangledName assemblerRepresentation] + " ("
  var first = true
  if mReceiverTypeProxy != .null then
    ioLLVMcode += [[mReceiverTypeProxy type] llvmTypeName] + "* %receiver"
    first = false
  end
  for () in mFormalArgumentList do
    if first then
      first = false
    else
      ioLLVMcode += ", "
    end
    switch mFormalArgumentPassingMode
    case input :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName]
    case output :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + "*"
   case inputOutput :
      ioLLVMcode += [[mTypeProxy type] llvmTypeName] + "*"
    end
  end
  ioLLVMcode += ")" + llvmAttributeFunction () + "\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
