#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @checkInstructionAST : @instructionAST {
  @expressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension plm_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $check$
    let loc = @location.here
    <expression> ?let @expressionAST expression
    ioInstructionList += !@checkInstructionAST.new {
      !loc
      !expression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  NOTE TYPES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @checkInstructionAST noteInstructionTypesInPrecedenceGraph ?!@semanticTypePrecedenceGraph ioGraph {
  [mExpression noteExpressionTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SOLVE ENTITIES                                                                                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @checkInstructionSE : @instructionSE {
  @expressionSE mExpression
}

#·······················································································································

override method @checkInstructionAST solveEntities
  ?context:let @semanticContext inSemanticContext
  ?!@instructionListSE ioInstructionListSE
{
  [mExpression solveEntities
    !context:inSemanticContext
    ?let expression
  ]
  ioInstructionListSE += !@checkInstructionSE.new {!mInstructionLocation !expression}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @checkInstructionAST analyze
  ?self:let @PLMType inSelfType
  ?propertiesAreMutable:let @bool unused inRoutineCanMutateProperties
  ?directAccessToPropertiesAllowed:let @bool unused inDirectAccessToPropertiesAllowed
  ?routineNameForInvocationGraph:let @lstring inCallerNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?mode:let @mode inCurrentMode
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@unifiedSymbolMapEx unused ioVariableMap
  ?!variableMap:@universalPropertyAndRoutineMapForContext ioUniversalMap
  ?!alloca:@allocaList ioAllocaList
  ?!instructionListIR:@instructionListIR unused ioInstructionGenerationList
{
#--- Analyze expression
  @instructionListIR instructionGenerationList = {}
  [mExpression analyzeExpression
    !self:inSelfType
    !inGuard:false
    !routineNameForInvocationGraph:inCallerNameForInvocationGraph
    !optionalTargetType:.void
    !context:inContext
    !mode:inCurrentMode
    !?temporary:ioTemporaries
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioUniversalMap
    !?alloca:ioAllocaList
    !?instructionListIR:instructionGenerationList
    ?result:@objectIR expressionResult
  ]
#--- Check inferred type
  if not [[expressionResult type] isBoolean] then
    error mInstructionLocation : "expression is not boolean"
  end
#--- Check expression is static, and true
  if not [expressionResult isStatic] then
    error mInstructionLocation : "expression is not static: use assert instruction"
  else
    [expressionResult literalInteger ?1* ?value:@bigint value]
    if value != 1G then
      error mInstructionLocation : "check expression value is false"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
