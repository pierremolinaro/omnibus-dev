#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @funcFormalArgumentList {
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

list @functionDeclarationListAST {
  @lstring mFunctionName
  @lstring mFunctionMode
  @funcFormalArgumentList mFuncFormalArgumentList
  @lstring mResultTypeName
  @lstring mResultVarName
  @instructionListAST mInstructionList
  @location mEndOfFuncLocation
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $func$
    @lstring funcMode
    select
      funcMode = .new {!"" !.here}
    or
      $modeName$ ?funcMode
    end
    $identifier$ ?let funcName
    @funcFormalArgumentList funcFormalArgumentList = {}
    $($
    repeat
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $:$
      $identifier$ ?let formalArgumentTypeName
      funcFormalArgumentList +=
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
    $->$
    $identifier$ ?let resultVarName
    $:$
    $identifier$ ?let resultTypeName
    ${$
    <instructionList> ?let instructionList
    $}$
    ioAST.mFunctionListAST +=
      !funcName
      !funcMode
      !funcFormalArgumentList
      !resultTypeName
      !resultVarName
      !instructionList
      !.here
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

method @functionDeclarationListAST-element enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (* formalArgumentTypeName *) in mFuncFormalArgumentList do
    [!?ioGraph noteNode !formalArgumentTypeName]
  end
  [!?ioGraph noteNode !mResultTypeName]
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

list @funcSignature {
  @lstring mFormalSelector
  @unifiedTypeMap-proxy mArgumentType
}

#----------------------------------------------------------------------------------------------------------------------*

map @functionMap {
  @lstring mFunctionMode
  @funcSignature mSignature
  @unifiedTypeMap-proxy mResultType

  insert insertKey error message "the '%K' func is already declared in %L"
  search searchKey error message "there is no '%K' func"
}

#----------------------------------------------------------------------------------------------------------------------*

getter @functionDeclarationListAST-element mangledName -> @string outMangledName {
  outMangledName = mFunctionName.string
  for (selector * *) in mFuncFormalArgumentList do
    outMangledName += " ?" + selector.string
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @functionDeclarationListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
#--- Signature
  @funcSignature signature = {}
  for (selector formalArgumentTypeName *) in mFuncFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
    signature += !selector !typeProxy
  end
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mResultTypeName ?let resultType]
#--- Enter in context
  [!?ioContext.mFunctionMap insertKey
    !.new {![self mangledName] !mFunctionName.location}
    !mFunctionMode
    !signature
    !resultType
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

list @funcFormalArgumentListForGeneration {
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

method @functionDeclarationListAST-element functionSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@uint ioTemporaryIndex
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check mode
  if mFunctionMode.string != "" then
    [inContext.mModeMap searchKey !mFunctionMode]
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (!context:inContext !globalsAreConstant:true)
#--- Add 'result" variable
  let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mResultTypeName}
  [!?variableMap insertOutputFormalArgument
    !mResultVarName
    !resultType
    !{!mFunctionMode.string}
    !mResultVarName.string
    !.localVariable {!name:mResultVarName}
    !true
  ]
#--- Analyse formal arguments
  @funcFormalArgumentListForGeneration formalArguments = {}
  for (* formalArgumentTypeName formalArgumentName) in mFuncFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    [!?variableMap insertConstantInputFormalArgument
      !formalArgumentName
      !typeProxy
      !{!mFunctionMode.string}
      !mangledNameForInArgument (!name:formalArgumentName.string)
      !.inArgument {!name:formalArgumentName}
      ![typeProxy copiable]
    ]
    formalArguments += !typeProxy !mangledNameForInArgument (!name:formalArgumentName.string)
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !optionalReceiverType:.noReceiver
    !context:inContext
    !mode:mFunctionMode.string
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioIntermediateCodeStruct.mGlobalLiteralStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfFuncLocation]
#--- Code generation
  [!?ioIntermediateCodeStruct.mFunctionMapIR insertKey
    !mFunctionName # [self mangledName]
    !formalArguments
    !instructionGenerationList
    !resultType
    !mResultVarName.string
  ]  
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper functionGenerationTemplate in "../generation-templates" {
}{
}{
  template declaration "function-declaration.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@funcFormalArgumentListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-proxy RESULT_TYPE

  template implementation "function-implementation.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@funcFormalArgumentListForGeneration FORMAL_ARGUMENT_LIST
    ?@instructionListIR INSTRUCTION_GENERATION_LIST
    ?@unifiedTypeMap-proxy RESULT_TYPE
    ?@string RESULT_VAR_NAME
}

#----------------------------------------------------------------------------------------------------------------------*

getter @functionMapIR-element headerCodeGeneration -> @string outCode {
  outCode = [filewrapper functionGenerationTemplate.declaration
    !lkey.string
    !mFormalArgumentListForGeneration
    !mResultType
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

getter @functionMapIR-element implementationCodeGeneration -> @string outCode {
  outCode = [filewrapper functionGenerationTemplate.implementation
    !lkey.string # mFunctionMangledName
#    !mangledNameForFunction (!name:lkey.string) # mFunctionMangledName
    !mFormalArgumentListForGeneration
    !mInstructionGenerationList
    !mResultType
    !mResultVarName
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

