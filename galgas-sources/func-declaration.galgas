#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @funcFormalArgumentList {
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @lstring mFunctionName
  @lstringlist mFunctionModeList
  @lstringlist mFunctionAttributeList
  @funcFormalArgumentList mFuncFormalArgumentList
  @lstring mResultTypeName
  @instructionListAST mInstructionList
  @location mEndOfFuncLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $func$
    <function_declaration> !?ioAST.mFunctionListAST
  }
  
  #·····················································································································

  rule <function_declaration> ?!@functionDeclarationListAST ioFunctionDeclarationListAST {
    $identifier$ ?let funcName
    @lstringlist funcModeList = {}
    repeat
      $modeName$ ?let funcMode
      funcModeList += !funcMode
    while
    end
    @lstringlist funcAttributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      funcAttributeList += !attribute
    end
    @funcFormalArgumentList funcFormalArgumentList = {}
    $($
    repeat
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      funcFormalArgumentList +=
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
    $->$
    $typeName$ ?let resultTypeName
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioFunctionDeclarationListAST +=
      !funcName
      !funcModeList
      !funcAttributeList
      !funcFormalArgumentList
      !resultTypeName
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST-element enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (* formalArgumentTypeName *) in mFuncFormalArgumentList do
    let typeName = @lstring.new {!"$" + formalArgumentTypeName !formalArgumentTypeName.location}
    [!?ioGraph noteNode !typeName]
  end
  let resultTypeName = @lstring.new {!"$" + mResultTypeName !mResultTypeName.location}
  [!?ioGraph noteNode !resultTypeName]
  [mInstructionList noteInstructionListTypesInPrecedenceGraph !?ioGraph]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @funcSignature {
  @lstring mFormalSelector
  @unifiedTypeMap-proxy mArgumentType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @functionMap {
  @modeMap mFunctionModeMap
  @funcSignature mSignature
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "the '%K' func is already declared in %L"
  search searchKey error message "there is no '%K' func"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
#--- Signature
  @funcSignature signature = {}
  for (selector formalArgumentTypeName *) in mFuncFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !formalArgumentTypeName}
    signature += !selector !typeProxy
  end
#--- Mode map
  @modeMap functionModeMap = {}
  for () in mFunctionModeList do
    [!?functionModeMap insertKey !mValue] ;
  end
#--- Result type
  let resultType = @unifiedTypeMap-proxy.searchKey {!ioContext.mTypeMap !mResultTypeName}
#--- Enter in context
  [!?ioContext.mFunctionMap insertKey
    !mFunctionName
    !functionModeMap
    !signature
    !resultType
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST-element functionSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check modes
  @stringset functionModeSet = {}
  for mode in mFunctionModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    functionModeSet += !mode.mValue.string
  end
#--- Check attributes
  @bool warnIfUnused = true
  for (attribute) in mFunctionAttributeList do
    if attribute.string == noWarningIfUnusedAttribute () then
      if not warnIfUnused then
        error attribute : "duplicated attribute"
      end
      warnIfUnused = false
    else
      error attribute : "unknown attribute"
    end
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineNameForInvocation:funcNameForInvocationGraph (!.null !mFunctionName).string
    !context:inContext
    !globalsAreConstant:true
  )
#--- Add 'result" variable
  let resultVarName = @lstring.new {!"result" !mResultTypeName.location}
  let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mResultTypeName}
  [!?variableMap insertOutputFormalArgument
    !resultVarName
    !resultType
    !true
    !.localValue {!type:resultType !name:resultVarName.string}
    !true
    !{}
    !true
    !false # Is not constant
  ]
#--- Analyse formal arguments
  @procFormalArgumentListForGeneration formalArguments = {}
  for (* formalArgumentTypeName formalArgumentName) in mFuncFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    [!?variableMap insertConstantInputFormalArgument
      !formalArgumentName
      !typeProxy
      !true
      !.localValue {!type:typeProxy !name:formalArgumentName.string}
      ![typeProxy copiable]
      !{}
      !false
      !true # Is constant
    ]
    formalArguments += !.input !typeProxy !llvmNameForLocalVariable (!formalArgumentName.string)
  end
#---
  let routineNameForInvocationGraph = funcNameForInvocationGraph (!.null !mFunctionName)
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !modes:functionModeSet
    !allowException:not [functionModeSet hasKey !panicModeName ()]
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfFuncLocation]
#--- Code generation
  [!?ioIntermediateCodeStruct.mFunctionMapIR insertKey
    !mFunctionName
    !formalArguments
    !instructionGenerationList
    !resultType
    !resultVarName.string
    !warnIfUnused
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionMapIR-element implementationCodeGeneration
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"func " + lkey)
  ioLLVMcode += "define internal "
  ioLLVMcode += [mResultType llvmTypeName]
  ioLLVMcode += " @" + llvmNameForFunction (!name:lkey.string) + " ("
  for () in mFormalArgumentListForGeneration
  do
    switch mFormalArgumentKind
    case input :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
    case output :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
   case inputOutput :
      ioLLVMcode += [mFormalArgumentType llvmTypeName] + "* %" + mFormalArgumentName
    end
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ") nounwind {\n"
#--- Store result in memory
  let resultMangledName = "%" + llvmNameForLocalVariable (!mResultVarName)
  ioLLVMcode += "  " + resultMangledName + " = alloca " + [mResultType llvmTypeName] + "\n"
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    switch mFormalArgumentKind
    case input :
      let llvmType = [mFormalArgumentType llvmTypeName]
      ioLLVMcode += "  %" + mFormalArgumentName + " = alloca " + [mFormalArgumentType llvmTypeName] + "\n"
      ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + "* %" + mFormalArgumentName + "\n"
    case output, inputOutput :
    end
  end
#--- Instruction list
  [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Epilog
  ioLLVMcode += "  " + resultMangledName + ".loaded = load " + [mResultType llvmTypeName] + ", " + [mResultType llvmTypeName] + "* " + resultMangledName + "\n"
  ioLLVMcode += "  ret " + [mResultType llvmTypeName] + " " + resultMangledName + ".loaded\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

