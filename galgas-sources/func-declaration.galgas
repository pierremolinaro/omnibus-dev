#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @funcFormalArgumentList {
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

list @functionDeclarationListAST {
  @lstring mFunctionName
  @lstringlist mFunctionModeList
  @funcFormalArgumentList mFuncFormalArgumentList
  @lstring mResultTypeName
  @lstring mResultVarName
  @instructionListAST mInstructionList
  @location mEndOfFuncLocation
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $func$
    @lstringlist funcModeList = {}
    repeat
      $modeName$ ?let funcMode
      funcModeList += !funcMode
    while
    end
    $identifier$ ?let funcName
    @funcFormalArgumentList funcFormalArgumentList = {}
    $($
    repeat
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      funcFormalArgumentList +=
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
    $->$
    $identifier$ ?let resultVarName
    $typeName$ ?let resultTypeName
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioAST.mFunctionListAST +=
      !funcName
      !funcModeList
      !funcFormalArgumentList
      !resultTypeName
      !resultVarName
      !instructionList
      !.here
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  PRECEDENCE GRAPH                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

method @functionDeclarationListAST-element enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (* formalArgumentTypeName *) in mFuncFormalArgumentList do
    [!?ioGraph noteNode !formalArgumentTypeName]
  end
  [!?ioGraph noteNode !mResultTypeName]
}

#----------------------------------------------------------------------------------------------------------------------*
#  ENTER IN CONTEXT                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

list @funcSignature {
  @lstring mFormalSelector
  @unifiedTypeMap-proxy mArgumentType
}

#----------------------------------------------------------------------------------------------------------------------*

map @functionMap {
  @modeMap mFunctionModeMap
  @funcSignature mSignature
  @unifiedTypeMap-proxy mResultType

  insert insertKey error message "the '%K' func is already declared in %L"
  search searchKey error message "there is no '%K' func"
}

#----------------------------------------------------------------------------------------------------------------------*

getter @functionDeclarationListAST-element mangledName -> @string outMangledName {
  outMangledName = mFunctionName.string
  for (selector * *) in mFuncFormalArgumentList do
    outMangledName += " ?" + selector.string
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @functionDeclarationListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
#--- Signature
  @funcSignature signature = {}
  for (selector formalArgumentTypeName *) in mFuncFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
    signature += !selector !typeProxy
  end
#--- Mode map
  @modeMap functionModeMap = {}
  for () in mFunctionModeList do
    [!?functionModeMap insertKey !mValue] ;
  end
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mResultTypeName ?let resultType]
#--- Enter in context
  [!?ioContext.mFunctionMap insertKey
    !.new {![self mangledName] !mFunctionName.location}
    !functionModeMap
    !signature
    !resultType
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTIC ANALYSIS                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

list @funcFormalArgumentListForGeneration {
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#----------------------------------------------------------------------------------------------------------------------*

method @functionDeclarationListAST-element functionSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check modes
  @stringset functionModeSet = {}
  for mode in mFunctionModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    functionModeSet += !mode.mValue.string
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineMangledName:[self mangledName]
    !context:inContext
    !globalsAreConstant:true
  )
#--- Add 'result" variable
  let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mResultTypeName}
  [!?variableMap insertOutputFormalArgument
    !mResultVarName
    !resultType
    !true
    !.localValue {!type:resultType !name:mResultVarName}
    !true
    !{}
    !true
  ]
#--- Analyse formal arguments
  @funcFormalArgumentListForGeneration formalArguments = {}
  for (* formalArgumentTypeName formalArgumentName) in mFuncFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    [!?variableMap insertConstantInputFormalArgument
      !formalArgumentName
      !typeProxy
      !true
      !.localValue {!type:typeProxy !name:formalArgumentName}
      ![typeProxy copiable]
      !{}
      !false
    ]
    formalArguments += !typeProxy !mangledNameForLocalVariable (!formalArgumentName.string)
  end
#---
  let routineNameForInvocationGraph = @lstring.new  {!"func " + [self mangledName] !mFunctionName.location}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !optionalReceiverType:.noReceiver
    !context:inContext
    !modes:functionModeSet
    !allowException:not [functionModeSet hasKey !exceptionModeName ()]
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mGlobalLiteralStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfFuncLocation]
#--- Code generation
  [!?ioIntermediateCodeStruct.mFunctionMapIR insertKey
    !mFunctionName # [self mangledName]
    !formalArguments
    !instructionGenerationList
    !resultType
    !mResultVarName.string
  ]  
}

#----------------------------------------------------------------------------------------------------------------------*
#  CODE GENERATION                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

private filewrapper functionGenerationTemplate in "../generation-templates" {
}{
}{
  template implementation "function-implementation.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@funcFormalArgumentListForGeneration FORMAL_ARGUMENT_LIST
    ?@string INSTRUCTION_LLVM_CODE
    ?@unifiedTypeMap-proxy RESULT_TYPE
    ?@string RESULT_VAR_NAME
}

#----------------------------------------------------------------------------------------------------------------------*

method @functionMapIR-element implementationCodeGeneration
  ?!@string ioCode
  ?let @generationContext inGenerationContext
  ?!@stringset ioIntrinsicsDeclarationSet
{
  var code = ""
  [mInstructionGenerationList instructionListLLVMCode !?code !inGenerationContext !?ioIntrinsicsDeclarationSet]
  ioCode += [filewrapper functionGenerationTemplate.implementation
    !lkey.string # mFunctionMangledName
#    !mangledNameForFunction (!name:lkey.string) # mFunctionMangledName
    !mFormalArgumentListForGeneration
    !code
    !mResultType
    !mResultVarName
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

