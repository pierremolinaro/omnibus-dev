#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @funcFormalArgumentList {
  @lstring mSelector
  @lstring mFormalArgumentTypeName
  @lstring mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @functionDeclarationListAST {
  @lstring mFunctionName
  @lstringlist mFunctionModeList
  @lstringlist mFunctionAttributeList
  @funcFormalArgumentList mFuncFormalArgumentList
  @lstring mResultTypeName
  @lstring mResultVarName
  @instructionListAST mInstructionList
  @location mEndOfFuncLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <declaration> ?!@ast ioAST {
    $func$
    $identifier$ ?let funcName
    @lstringlist funcModeList = {}
    repeat
      $modeName$ ?let funcMode
      funcModeList += !funcMode
    while
    end
    @lstringlist funcAttributeList = {}
    repeat
    while
      $attribute$ ?let attribute
      funcAttributeList += !attribute
    end
    @funcFormalArgumentList funcFormalArgumentList = {}
    $($
    repeat
    while
      $?$ ?let selector
      $identifier$ ?let formalArgumentName
      $typeName$ ?let formalArgumentTypeName
      funcFormalArgumentList +=
        !selector
        !formalArgumentTypeName
        !formalArgumentName
    end
    $)$
    $->$
    $identifier$ ?let resultVarName
    $typeName$ ?let resultTypeName
    ${$
    @labelMap labelMap = {}
    <instructionList> ?let instructionList !?labelMap
    $}$
    ioAST.mFunctionListAST +=
      !funcName
      !funcModeList
      !funcAttributeList
      !funcFormalArgumentList
      !resultTypeName
      !resultVarName
      !instructionList
      !.here
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  PRECEDENCE GRAPH                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST-element enterInPrecedenceGraph
  ?!@semanticTypePrecedenceGraph ioGraph
{
  for (* formalArgumentTypeName *) in mFuncFormalArgumentList do
    [!?ioGraph noteNode !formalArgumentTypeName]
  end
  [!?ioGraph noteNode !mResultTypeName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ENTER IN CONTEXT                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @funcSignature {
  @lstring mFormalSelector
  @unifiedTypeMap-proxy mArgumentType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @functionMap {
  @modeMap mFunctionModeMap
  @funcSignature mSignature
  @unifiedTypeMap-proxy mResultType
  insert insertKey error message "the '%K' func is already declared in %L"
  search searchKey error message "there is no '%K' func"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST-element enterInContext
  ?!context:@semanticContext ioContext
{
#--- Signature
  @funcSignature signature = {}
  for (selector formalArgumentTypeName *) in mFuncFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !formalArgumentTypeName ?let typeProxy]
    signature += !selector !typeProxy
  end
#--- Mode map
  @modeMap functionModeMap = {}
  for () in mFunctionModeList do
    [!?functionModeMap insertKey !mValue] ;
  end
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioContext.mTypeMap !mResultTypeName ?let resultType]
#--- Enter in context
  [!?ioContext.mFunctionMap insertKey
    !mFunctionName
    !functionModeMap
    !signature
    !resultType
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTIC ANALYSIS                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @funcFormalArgumentListForGeneration {
  @unifiedTypeMap-proxy mFormalArgumentType
  @string mFormalArgumentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @functionDeclarationListAST-element functionSemanticAnalysis
  ?context:let @semanticContext inContext
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!intermediateCode:@intermediateCodeStruct ioIntermediateCodeStruct
{
#--- Check modes
  @stringset functionModeSet = {}
  for mode in mFunctionModeList do
    [inContext.mModeMap searchKey !mode.mValue]
    functionModeSet += !mode.mValue.string
  end
#--- Check attributes
  @bool warnIfUnused = true
  for (attribute) in mFunctionAttributeList do
    if attribute.string == noWarningIfUnusedAttribute () then
      if not warnIfUnused then
        error attribute : "duplicated attribute"
      end
      warnIfUnused = false
    else
      error attribute : "unknown attribute"
    end
  end
#--- Variable map
  @variableMap variableMap = initialVariableMap (
    !routineMangledName:mangledNameForFunction (!name:mFunctionName.string)
    !context:inContext
    !globalsAreConstant:true
  )
#--- Add 'result" variable
  let resultType = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !mResultTypeName}
  [!?variableMap insertOutputFormalArgument
    !mResultVarName
    !resultType
    !true
    !.localValue {!type:resultType !name:mResultVarName.string}
    !true
    !{}
    !true
    !false # Is not constant
  ]
#--- Analyse formal arguments
  @funcFormalArgumentListForGeneration formalArguments = {}
  for (* formalArgumentTypeName formalArgumentName) in mFuncFormalArgumentList do
    let typeProxy = @unifiedTypeMap-proxy.searchKey {!inContext.mTypeMap !formalArgumentTypeName}
    [!?variableMap insertConstantInputFormalArgument
      !formalArgumentName
      !typeProxy
      !true
      !.localValue {!type:typeProxy !name:formalArgumentName.string}
      ![typeProxy copiable]
      !{}
      !false
      !true # Is constant
    ]
    formalArguments += !typeProxy !mangledNameForLocalVariable (!formalArgumentName.string)
  end
#---
  let routineNameForInvocationGraph = @lstring.new{!mangledNameForFunction (!name:mFunctionName.string) !mFunctionName.location}
  if not [ioTemporaries.mSubprogramInvocationGraph isNodeDefined !routineNameForInvocationGraph.string] then
    [!?ioTemporaries.mSubprogramInvocationGraph addNode
      !routineNameForInvocationGraph
      !routineNameForInvocationGraph
    ]
  end
#--- Analyze instruction list
  @instructionListIR instructionGenerationList = {}
  [mInstructionList analyzeRoutineInstructionList
    !routineNameForInvocationGraph:routineNameForInvocationGraph
    !context:inContext
    !modes:functionModeSet
    !allowException:not [functionModeSet hasKey !panicModeName ()]
    !?temporary:ioTemporaries
    !?staticStringMap:ioIntermediateCodeStruct.mStaticStringMap
    !?variableMap:variableMap
    !?generatedCode:instructionGenerationList
  ]
#---
  [variableMap checkAutomatonStates !mEndOfFuncLocation]
#--- Code generation
  [!?ioIntermediateCodeStruct.mFunctionMapIR insertKey
    !mFunctionName
    !formalArguments
    !instructionGenerationList
    !resultType
    !mResultVarName.string
    !warnIfUnused
  ]  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  CODE GENERATION                                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#  @funcFormalArgumentListForGeneration mFormalArgumentListForGeneration
#  @instructionListIR mInstructionGenerationList
#  @unifiedTypeMap-proxy mResultType
#  @string mResultVarName

method @functionMapIR-element implementationCodeGeneration
  ?!@string ioLLVMcode
  ?let @generationContext inGenerationContext
  ?!@generationAdds ioGenerationAdds
{
  ioLLVMcode += llvmTitleComment (!"func " + lkey)
  ioLLVMcode += "define internal "
  ioLLVMcode += [mResultType llvmTypeName]
  ioLLVMcode += " @" + mangledNameForFunction (!name:lkey.string) + " ("
  for () in mFormalArgumentListForGeneration
  do
    ioLLVMcode += [mFormalArgumentType llvmTypeName] + " %in." + mFormalArgumentName
  between
    ioLLVMcode += ", "
  end
  ioLLVMcode += ") nounwind {\n"
#--- Store result in memory
  let resultMangledName = "%" + mangledNameForLocalVariable (!mResultVarName)
  ioLLVMcode += "  " + resultMangledName + " = alloca " + [mResultType llvmTypeName] + "\n"
#--- Store input arguments in memory
  for () in mFormalArgumentListForGeneration do
    let llvmType = [mFormalArgumentType llvmTypeName]
    ioLLVMcode += "  %" + mFormalArgumentName + " = alloca " + [mFormalArgumentType llvmTypeName] + "\n"
    ioLLVMcode += "  store " + llvmType + " %in." + mFormalArgumentName + ", " + llvmType + "* %" + mFormalArgumentName + "\n"
  end
 
#--- Instruction list
  [mInstructionGenerationList instructionListLLVMCode !?ioLLVMcode !inGenerationContext !?ioGenerationAdds]
#--- Epilog
  ioLLVMcode += "  " + resultMangledName + ".loaded = load " + [mResultType llvmTypeName] + ", " + [mResultType llvmTypeName] + "* " + resultMangledName + "\n"
  ioLLVMcode += "  ret " + [mResultType llvmTypeName] + " " + resultMangledName + ".loaded\n"
  ioLLVMcode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

