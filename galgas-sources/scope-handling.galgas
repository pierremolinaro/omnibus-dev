#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SCOPE HANDLING
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @scopeHandler {
  @scopeStack mScopeStack
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @scopeKind {
  case selectScope
  case repeatScope
}

#·······················································································································

list @scopeStack {
  @scopeKind mScopeKind
  @bool mFirstBranch
  @referenceStateMap mInitialStateMap
  @referenceStateMap mReferenceStateMap
  @lstringlist mObjectList
}

#·······················································································································

map @referenceStateMap {
  @valuedObjectState mState
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#·······················································································································

method @universalPropertyAndRoutineMapForContext checkLocalVariableFinalState {
  for entry in mInternalPropertyAndRoutineMapForContext do
    switch entry.mPossibleValuedObject
    case undefined :
    case property (* *) :
    case module (*) :
    case register (* * *) :
    case globalConstant (*) :
    case localConstant (*) :
      if entry.mObjectState == .hasUnreadValue then
        warning entry.lkey : "'" + entry.lkey + "' is never read"
      end
    case globalVariableReference (* *) :
    case localVariableReference (*) :
      if (entry.mObjectState == .noValue) && entry.mObjectShouldBeValuedAtEndOfScope then
        warning entry.lkey : "'" + entry.lkey + "' should be valued at the end of routine"
      end
    end
  end
}

#·······················································································································

setter @universalPropertyAndRoutineMapForContext openOverrideForSelectBlock {
  @referenceStateMap initialStateMap = {}
  for entry in mInternalPropertyAndRoutineMapForContext do
    switch entry.mPossibleValuedObject
    case undefined :
    case property (* *) :
    case module (*) :
    case register (* * *) :
    case globalConstant (*) :
    case localConstant (*) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    case globalVariableReference (* *) :
    case localVariableReference (*) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    end
  end
  mScopeStack += !.selectScope !true !initialStateMap !{} !mLocalObjectList
  mLocalObjectList = {}
}

#·······················································································································

setter @universalPropertyAndRoutineMapForContext openOverrideForRepeatBlock {
  @referenceStateMap initialStateMap = {}
  for entry in mInternalPropertyAndRoutineMapForContext do
    switch entry.mPossibleValuedObject
    case undefined :
    case property (* *) :
    case module (*) :
    case register (* * *) :
    case globalConstant (*) :
    case localConstant (*) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    case globalVariableReference (* *) :
    case localVariableReference (*) :
      [!?initialStateMap insertKey !entry.lkey !entry.mObjectState]
    end
  end
  mScopeStack += !.repeatScope !true !initialStateMap ! {} !mLocalObjectList
  mLocalObjectList = {}
}

#·······················································································································

setter @universalPropertyAndRoutineMapForContext openBranch {
  [mScopeStack last ?* ?* ?let initialStateMap ?2*]
  for (key objectState) in initialStateMap do
    [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !objectState !key]
  end
}

#·······················································································································

setter @universalPropertyAndRoutineMapForContext closeBranch ?let @location inErrorLocation {
  [!?mScopeStack popLast ?let scopeKind ?let firstBranch ?let initialStateMap ?let referenceStateMap ?let localObjectList]
  if firstBranch then
    @referenceStateMap newReferenceStateMap = {}
    for entry in mInternalPropertyAndRoutineMapForContext do
      switch entry.mPossibleValuedObject
      case undefined :
      case property (* *) :
      case module (*) :
      case register (* * *) :
      case globalConstant (*) :
      case localConstant (*) :
        [!?newReferenceStateMap insertKey !entry.lkey !entry.mObjectState]
      case globalVariableReference (* *) :
      case localVariableReference (*) :
        [!?newReferenceStateMap insertKey !entry.lkey !entry.mObjectState]
      end
    end
    mScopeStack += !scopeKind !false !initialStateMap !newReferenceStateMap !localObjectList
  else
    switch scopeKind
    case selectScope :
      for (lkey objectState) in referenceStateMap do
        [mInternalPropertyAndRoutineMapForContext searchKey !lkey ?let currentObjectState ?3*]
        if objectState != currentObjectState then
          error inErrorLocation
            : "invalid state for object '" + lkey + "': found " + currentObjectState + ", required " + objectState
        end
      end
      mScopeStack += !scopeKind !false !initialStateMap !referenceStateMap !localObjectList
    case repeatScope :
     for (lkey objectState) in referenceStateMap do
        [mInternalPropertyAndRoutineMapForContext searchKey !lkey ?let currentObjectState ?3*]
        if objectState != currentObjectState then
          error inErrorLocation
            : "invalid state for object '" + lkey + "': found " + currentObjectState + ", required " + objectState
        end
      end
      mScopeStack += !scopeKind !false !initialStateMap !referenceStateMap !localObjectList
    end
  end
}

#·······················································································································

setter @universalPropertyAndRoutineMapForContext closeOverride ?let @location inErrorLocation {
  [!?mScopeStack popLast ?* ?* ?* ?let referenceStateMap ?let localObjectList]
#--- Restore value object state
  for (key objectState) in referenceStateMap do
    [!?mInternalPropertyAndRoutineMapForContext setMObjectStateForKey !objectState !key]
  end
#--- For current scope objects, check their final state
  for (lkey) in mLocalObjectList do
    [mInternalPropertyAndRoutineMapForContext searchKey !lkey ?let currentObjectState ?let objectShouldBeValuedAtEndOfScope ?let possibleValuedObject ?*]
    switch possibleValuedObject
    case undefined :
    case property (* *) :
    case module (*) :
    case register (* * *) :
    case globalConstant (*) :
    case localConstant (*) :
      if currentObjectState == .hasUnreadValue then
        warning inErrorLocation : "'" + lkey + "' is never read"
      end
    case globalVariableReference (* *) :
    case localVariableReference (*) :
      if (currentObjectState == .noValue) && objectShouldBeValuedAtEndOfScope then
        warning inErrorLocation : "'" + lkey + "' should be valued at the end of routine"
      end
    end
  end
#--- Remove cuurent scope objets, by setting their kind to "undefined"
  for (lkey) in mLocalObjectList do
    [!?mInternalPropertyAndRoutineMapForContext setMPossibleValuedObjectForKey !.undefined !lkey]
  end
#--- Restore current scope objects
  mLocalObjectList = localObjectList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
