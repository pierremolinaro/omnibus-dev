#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  AST                                                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @methodCallInstructionAST : @instructionAST {
  @expressionAST mReceiverExpression
  @lstring mMethodName
  @procEffectiveParameterListAST mEffectiveParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SYNTAX                                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension common_syntax {

  #·····················································································································

  rule <instruction> ?!@instructionListAST ioInstructionList ?!@labelMap unused ioLabelMap {
    $[$
    <expression> ?let @expressionAST expression
    $identifier$ ?let methodName
    @procEffectiveParameterListAST effectiveParameterList = {}
    repeat
    while
      $!$ ?let selector
      <expression> ?let @expressionAST expression
      effectiveParameterList += !.output{!exp:expression !endOfExp:.here} !selector
    while
      $!?$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.outputInput{!name:effectiveParameterName} !selector
    while
      $?$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.input{!name:effectiveParameterName} !selector
    end
    $]$
    ioInstructionList += !@methodCallInstructionAST.new {
      !expression
      !methodName
      !effectiveParameterList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  SEMANTICS                                                                                                           *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @methodCallInstructionAST analyze
  ?routineNameForInvocationGraph:let @lstring inRoutineNameForInvocationGraph
  ?context:let @semanticContext inContext
  ?modes:let @stringset unused inModeSet
  ?allowException:let @bool unused inAllowExceptions
  ?!temporary:@semanticTemporariesStruct ioTemporaries
  ?!staticStringMap:@staticStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze receiver expression
  [mReceiverExpression analyzeExpression
     !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
     !optionalTargetType:.null
     !context:inContext
     !modes:{}
     !allowException:true
     !?temporary:ioTemporaries
     !?staticStringMap:ioGlobalLiteralStringMap
     !?variableMap:ioVariableMap
     !?instructionListIR:ioInstructionGenerationList
     ?result:let @operandIR receiverExpression
  ]
#--- Check parameters
  @procEffectiveParameterList parameterList = {}
  @string procMangledName = mMethodName.string
  for () in mEffectiveParameterList do
    procMangledName += " "
    switch mEffectiveParameterKind 
    case input (@lstring name) :
      procMangledName += "!" ;
      [!?ioVariableMap searchForWriteAccess
        !name
        ?let @unifiedTypeMap-proxy type
        ?let @bool unused readAccessAllowed
        ?let @objectInMemoryIR unused variableKind
        ?let @bool isCopiable
        ?let @registerBitSliceAccessMap unused fieldMap
        ?let @bool canBeUsedAsInputParameter
        ?let @bool isConstant
      ]
    #--- Check mode
      if isConstant then
        error name : "a constant cannot be modified"
      end
      if not canBeUsedAsInputParameter then
        error name : "this variable cannot be used as input effective parameter"
      end
      if not isCopiable then
        error name : "the '" + name + "' variable is not copiable"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type # !"& (" + valueAccess + ")"
    case output (@expressionAST exp @location unused endOfExp) :
      procMangledName += "?" ;
      [exp analyzeExpression
         !routineNameForInvocationGraph:inRoutineNameForInvocationGraph
         !optionalTargetType:.null
         !context:inContext
         !modes:{}
         !allowException:true
         !?temporary:ioTemporaries
         !?staticStringMap:ioGlobalLiteralStringMap
         !?variableMap:ioVariableMap
         !?instructionListIR:ioInstructionGenerationList
         ?result:let @operandIR expressionResult
      ]
      parameterList += !mEffectiveParameterKind !mSelector ![expressionResult mType] # !valueAccess
    case outputInput (@lstring name) :
      procMangledName += "?!" ;
      [!?ioVariableMap searchForReadWriteAccess
        !name
        ?let @unifiedTypeMap-proxy type
        ?let @bool unused readAccessAllowed
        ?let @objectInMemoryIR unused variableKind
        ?let @bool unused isCopiable
        ?let @registerBitSliceAccessMap unused fieldMap
        ?let @bool unused canBeUsedAsInputParameter
        ?let @bool isConstant
      ]
    #--- Check mode
      if isConstant then
        error name : "a constant cannot be modified"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type # !"& (" + valueAccess + ")"
    end
    procMangledName += mSelector.string
  end
#--- Search proc in proc map
  let receiverTypeProcedureMap = [[receiverExpression mType] procedureMap]
  [receiverTypeProcedureMap searchKey
    !.new {!procMangledName !mMethodName.location}
    ?let unused calledProcIsMutating
    ?let unused procedureModeMap
    ?let @procedureSignature calledProcSignature
    ?* # weak
  ]
#--- Check mode
#  if not [inModeSet hasKey !procedureMode] then
#    error mMethodName : "this variable cannot be used in $" + procedureMode + " mode"
#  end
#--- called method is not a mutating method
#  if calledProcIsMutating then
#    error mMethodName : "called proc is mutating: use \"[!?receiver procName ...]\" instruction"
#  end
#  switch inReceiverType
#  case noReceiver :
#    if calledProcIsMutating then
#      error mMethodName : "a mutating method cannot be called from a non mutating procedure"
#    end
#  case receiver (* *) :
#    if calledProcIsMutating then
#      error mMethodName : "a mutating method cannot be called from a non mutating method"
#    end
#  case mutatingReceiver (* *) :
#  end
#--- Check parameter list
  if [calledProcSignature length] != [parameterList length] then
    error mMethodName: "this proc requires " + [calledProcSignature length] + " argument(s), this call names "
      + [parameterList length] + " argument(s)"
  else
    for () formal_ in calledProcSignature, () actual_ in parameterList do
      if [formal_mType key] != [actual_mParameterType key] then
        error actual_mSelector : "the actual parameter type is '" + [actual_mParameterType key] +
           "', and is incompatible with the formal type '" + [formal_mType key] + "'"
      end
      let requiredPassingMode = [formal_mFormalArgumentPassingMode requiredActualPassingModeForSelector !formal_mSelector]
      let testedPassingMode = [actual_mEffectiveParameterPassingMode passingModeForActualSelector !actual_mSelector]
      if requiredPassingMode != testedPassingMode then
        error actual_mSelector : "the required selector is '" + requiredPassingMode + "'"
      end
    end  
  end
  error mMethodName : "Internal error : no code generation"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
