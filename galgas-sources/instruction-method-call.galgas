#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

class @methodCallInstructionAST : @instructionAST {
  @expressionAST mReceiverExpression
  @lstring mMethodName
  @procEffectiveParameterListAST mEffectiveParameterList
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <instruction> ?!@instructionListAST ioInstructionList {
    $[$
    <expression> ?let @expressionAST expression
    $identifier$ ?let methodName
    @procEffectiveParameterListAST effectiveParameterList = {}
    repeat
    while
      $!$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.output{!name:effectiveParameterName} !selector
    while
      $!?$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.outputInput{!name:effectiveParameterName} !selector
    while
      $?$ ?let selector
      $identifier$ ?let effectiveParameterName
      effectiveParameterList += !.input{!name:effectiveParameterName} !selector
    end
    $]$
    ioInstructionList += !@methodCallInstructionAST.new {
      !expression
      !methodName
      !effectiveParameterList
    }
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*
#  SEMANTICS                                                                                                           *
#----------------------------------------------------------------------------------------------------------------------*

override method @methodCallInstructionAST analyze
  ?optionalReceiverType:let @receiverType inReceiverType
  ?context:let @semanticContext inContext
  ?mode:let @string inMode
  ?!temporary:@uint ioTemporaryIndex
  ?!staticStringMap:@globalLiteralStringMap ioGlobalLiteralStringMap
  ?!variableMap:@variableMap ioVariableMap
  ?!instructionListIR:@instructionListIR ioInstructionGenerationList
{
#--- Analyze receiver expression
  [mReceiverExpression analyzeExpression
    !optionalReceiverType:inReceiverType
    !optionalTargetType:.null
    !context:inContext
    !mode:inMode
    !?temporary:ioTemporaryIndex
    !?staticStringMap:ioGlobalLiteralStringMap
    !?variableMap:ioVariableMap
    !?instructionListIR:ioInstructionGenerationList
    ?expressionType:let receiverExpressionType
    ?generatedCode:let unused receiverExpressionGeneratedCode
    ?result:@variableKindIR receiverValueName
  ]
#--- Check parameters
  @procEffectiveParameterList parameterList = {}
  @string procMangledName = mMethodName.string
  for () in mEffectiveParameterList do
    procMangledName += " "
    switch mEffectiveParameterKind 
    case input (@lstring name) :
      procMangledName += "!" ;
      [!?ioVariableMap searchForWriteAccess
        !name
        ?let type
        ?let acceptedModeSet
        ?let @string valueAccess
        ?let unused variableKind
        ?let isCopiable
      ]
    #--- Check mode
      if not [acceptedModeSet hasKey !inMode] then
        error name : "this variable cannot be used in $" + inMode + " mode"
      end
      if not isCopiable then
        error name : "the '" + name + "' variable is not copiable"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type !"& (" + valueAccess + ")"
    case output (@lstring name) :
      procMangledName += "?" ;
      [!?ioVariableMap searchForReadAccess
        !name
        ?let type
        ?let acceptedModeSet
        ?let valueAccess
        ?let unused variableKind
        ?*
      ]
    #--- Check mode
      if not [acceptedModeSet hasKey !inMode] then
        error name : "this variable cannot be used in $" + inMode + " mode"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type !valueAccess
    case outputInput (@lstring name) :
      procMangledName += "?!" ;
      [!?ioVariableMap searchForReadWriteAccess
        !name
        ?let type
        ?let acceptedModeSet
        ?let valueAccess
        ?let unused variableKind
        ?*
      ]
    #--- Check mode
      if not [acceptedModeSet hasKey !inMode] then
        error name : "this variable cannot be used in $" + inMode + " mode"
      end
      parameterList += !mEffectiveParameterKind !mSelector !type !"& (" + valueAccess + ")"
    end
    procMangledName += mSelector.string
  end
#--- Search proc in proc map
  let receiverTypeProcedureMap = [receiverExpressionType procedureMap]
  [receiverTypeProcedureMap searchKey
    !.new {!procMangledName !mMethodName.location}
    ?let calledProcIsMutating
    ?let procedureMode
    ?let @procedureSignature calledProcSignature
  ]
#--- Check mode
  if procedureMode.string != inMode then
    error mMethodName : "this variable cannot be used in $" + inMode + " mode"
  end
#--- called method is not a mutating method
  switch inReceiverType
  case noReceiver :
    if calledProcIsMutating then
      error mMethodName : "a mutating method cannot be called from a non mutating procedure"
    end
  case receiver (* *) :
    if calledProcIsMutating then
      error mMethodName : "a mutating method cannot be called from a non mutating method"
    end
  case mutatingReceiver (* *) :
  end
#--- Check parameter list
  if [calledProcSignature length] != [parameterList length] then
    error mMethodName: "this proc requires " + [calledProcSignature length] + " argument(s), this call names "
      + [parameterList length] + " argument(s)"
  else
    for () formal_ in calledProcSignature, () actual_ in parameterList do
      if [formal_mType key] != [actual_mParameterType key] then
        error actual_mSelector : "the actual parameter type is '" + [actual_mParameterType key] +
           "', and is incompatible with the formal type '" + [formal_mType key] + "'"
      end
      let requiredPassingMode = [formal_mFormalArgumentPassingMode requiredActualPassingModeForSelector !formal_mSelector]
      let testedPassingMode = [actual_mEffectiveParameterPassingMode passingModeForActualSelector !actual_mSelector]
      if requiredPassingMode != testedPassingMode then
        error actual_mSelector : "the required selector is '" + requiredPassingMode + "'"
      end
    end  
  end
#--- Code generation
#  if calledProcIsMutating then
#    [!?parameterList insertAtIndex
#      !.outputInput{!name:name}
#      !["" nowhere]
#      !receiverExpressionType
#      !"& " + [receiverExpressionGeneratedCode expressionCode]
#      !0
#    ]
#  else
#    [!?parameterList insertAtIndex
#      !.output
#      !["" nowhere]
#      !receiverExpressionType
#      ![receiverExpressionGeneratedCode expressionCode]
#      !0
#    ]
#  end
  error mMethodName : "Internal error : no code generation"
}

#----------------------------------------------------------------------------------------------------------------------*
