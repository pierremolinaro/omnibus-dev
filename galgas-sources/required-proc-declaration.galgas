#----------------------------------------------------------------------------------------------------------------------*
#  AST                                                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

list @requiredProcedureDeclarationListAST {
  @lstring mRequiredProcedureName
  @lstringlist mProcedureModeList
  @procFormalArgumentList mProcFormalArgumentList
  @location mEndOfProcLocation
}

#----------------------------------------------------------------------------------------------------------------------*
#  SYNTAX                                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension common_syntax {

  #--------------------------------------------------------------------------------------------------------------------*

  rule <declaration> ?!@ast ioAST {
    $required$
    <procedure_header>
      ?procModes:let requiredModeList
      ?name:let procName
      ?attributes:let unused attributeList
      ?formalArguments:let procFormalArgumentList
    ioAST.mRequiredProcList += !procName !requiredModeList !procFormalArgumentList !.here
  }

  #--------------------------------------------------------------------------------------------------------------------*

}

#----------------------------------------------------------------------------------------------------------------------*

proc checkRequiredProcedures
  ?ast:let @ast inAST
  ?context:let @semanticContext inSemanticContext
  ?endOfSourceFile:let @location inEndOfSourceFile
{
  for requiredProc in inAST.mRequiredProcList do
#    let requiredProcMangledName = mangledName (
#      !forProcedureKind:.standAloneProc
#      !procedureName:requiredProc.mRequiredProcedureName
#      !formalArgumentList:requiredProc.mProcFormalArgumentList
#    )
    if not [inSemanticContext.mProcedureMap hasKey !requiredProc.mRequiredProcedureName.string] then
      var s = "the '" + requiredProc.mRequiredProcedureName + "' should be defined as: proc"
      for (mode) in requiredProc.mProcedureModeList do
        s += " `" + mode
      end
      s += " " + requiredProc.mRequiredProcedureName
      for arg in requiredProc.mProcFormalArgumentList do
        s += " "
        switch arg.mFormalArgumentPassingMode
        case input : s += "?"
        case output : s += "!"
        case inputOutput : s += "?!"
        end
        if arg.mSelector.string != "" then
          s += arg.mSelector.string + ":"
        end
        s += arg.mFormalArgumentTypeName.string
      end
      error inEndOfSourceFile : s
    else
      [inSemanticContext.mProcedureMap searchKey ![requiredProc.mRequiredProcedureName nowhere] ?* ?let procModes ?2*]
      let actualProcModeSet = [procModes keySet]
      let requiredProcModeSet = @stringset.setWithLStringList{!requiredProc.mProcedureModeList}
      if actualProcModeSet != requiredProcModeSet then
        var s = "required modes:"
        for (mode) in requiredProcModeSet do
          s += " `" + mode
        end
        error [inSemanticContext.mProcedureMap locationForKey !requiredProc.mRequiredProcedureName.string] : s
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
